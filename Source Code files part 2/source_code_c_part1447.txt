RData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, (LPTSTR) (pmdrData->pbMDData), bUnicode);
                    break;
                }
                case BINARY_METADATA: {
                    pbdNew = new CMDBINData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, pmdrData->dwMDDataLen, pmdrData->pbMDData);
                    break;
                }
                case EXPANDSZ_METADATA: {
                    pbdNew = new CMDEXSZData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, (LPTSTR) (pmdrData->pbMDData), bUnicode);
                    break;
                }
                case MULTISZ_METADATA: {
                    pbdNew = new CMDMLSZData(pmdrData->dwMDIdentifier,
                                             pmdrData->dwMDAttributes,
                                             pmdrData->dwMDUserType,
                                             pmdrData->dwMDDataLen,
                                             (LPSTR)pmdrData->pbMDData,
                                             bUnicode);
                    break;
                }
                default: {
                    pbdNew = NULL;
                }
            }
            if (pbdNew != NULL) {
                if (!(pbdNew->IsValid())) {
                    delete (pbdNew);
                }
                else {
                    pbdNew->SetNextPtr(g_ppbdDataHashTable[dwHash]);
                    g_ppbdDataHashTable[dwHash] = pbdNew;
                    pbdReturn = pbdNew;
                }
            }
        }
    }
    return (pbdReturn);
}

HRESULT
GetHighestVersion(IN OUT STRAU *pstrauBackupLocation,
                  OUT DWORD *pdwVersion)
{
    long lHighestVersion = -1;
    long lVersion;
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD dwPathBytes = g_pstrBackupFilePath->QueryCB() + 1;
    DWORD dwNameBytes = pstrauBackupLocation->QueryCBA() - dwPathBytes;
    if (!pstrauBackupLocation->Append("*")) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        if (pstrauBackupLocation->QueryStrA() == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            HANDLE hFile = INVALID_HANDLE_VALUE;
            WIN32_FIND_DATA wfdFile;
            hFile = FindFirstFile(pstrauBackupLocation->QueryStrA(),
                                  &wfdFile);
            if (hFile == INVALID_HANDLE_VALUE) {
                if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                }
            }
            else {
                //
                // Process the first file
                //

                //
                // dwNameBytes could be wrong for this assert in MBCS,
                // so call MBCS strlen. Subtract 1 char for appended '*'
                //

                MD_ASSERT(MD_STRNICMP(pstrauBackupLocation->QueryStrA() + dwPathBytes,
                                      wfdFile.cFileName,
                                      MD_STRLEN(pstrauBackupLocation->QueryStrA() + dwPathBytes) - 1) == 0);
                if (CheckDigits(wfdFile.cFileName + (dwNameBytes))) {
                    //
                    // One of our files
                    //
                    lVersion = atol(wfdFile.cFileName + dwNameBytes);
                    if ((lVersion <= MD_BACKUP_MAX_VERSION) &&
                         (lVersion > lHighestVersion)) {
                        lHighestVersion = lVersion;
                    }
                }
                //
                // Process the remaining files
                //
                while (FindNextFile(hFile, &wfdFile)) {
                    MD_ASSERT(MD_STRNICMP(pstrauBackupLocation->QueryStrA() + dwPathBytes,
                                          wfdFile.cFileName,
                                          MD_STRLEN(pstrauBackupLocation->QueryStrA() + dwPathBytes) - 1) == 0);
                    if (CheckDigits(wfdFile.cFileName + dwNameBytes)) {
                        //
                        // One of our files
                        //
                        lVersion = atol(wfdFile.cFileName + dwNameBytes);
                        if ((lVersion <= MD_BACKUP_MAX_VERSION) &&
                             (lVersion > lHighestVersion)) {
                            lHighestVersion = lVersion;
                        }
                    }
                }
                FindClose(hFile);
            }
            if (SUCCEEDED(hresReturn)) {
                if (lHighestVersion == -1) {

                    //
                    // May not be an error, but need to indicate that
                    // no backups were found.
                    //

                    hresReturn = RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND);
                }
                else if (lHighestVersion <= MD_BACKUP_MAX_VERSION) {
                        *pdwVersion = lHighestVersion;
                }
                else {
                        hresReturn =  RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                }
            }
        }
        pstrauBackupLocation->SetLen(pstrauBackupLocation->QueryCCH() - 1);

    }

    return hresReturn;
}

BOOL
ValidateBackupLocation(LPSTR pszBackupLocation,
                       BOOL bUnicode)
{

    //
    // The main purpose of this routine is to make sure the user
    // is not putting in any file system controls, like .., /, etc.

    //
    // Secondarily, try to eliminate any characters that cannot be
    // used in database names
    //

    BOOL bReturn = TRUE;
    DWORD  dwStringLen;

    MD_ASSERT(pszBackupLocation != NULL);

	char *pszLocSave = setlocale(LC_CTYPE, NULL);	// Save cur locale
	setlocale(LC_CTYPE, "");						// Set sys locale
	
    //
    // strcspn doesn't have an error return, but will return
    // the index of the terminating NULL if the chars are not found
    //

    if (bUnicode) {
        dwStringLen = wcslen((LPWSTR)pszBackupLocation);
        if ((dwStringLen >= MD_BACKUP_MAX_LEN) ||
            (wcscspn((LPWSTR)pszBackupLocation, MD_BACKUP_INVALID_CHARS_W) !=
            dwStringLen)) {
            bReturn = FALSE;
        }
        else {
            LPWSTR pszIndex;
            for (pszIndex = (LPWSTR)pszBackupLocation;
                 (*pszIndex != (WCHAR)'\0') &&
                     (iswprint(*pszIndex));
                 pszIndex++) {
            }
            if (*pszIndex != (WCHAR)'\0') {
                bReturn = FALSE;

            }
        }
    }
    else {
        dwStringLen = _mbslen((PBYTE)pszBackupLocation);
        if ((dwStringLen >= MD_BACKUP_MAX_LEN) ||
            (_mbscspn((PBYTE)pszBackupLocation, (PBYTE)MD_BACKUP_INVALID_CHARS_A) !=
            dwStringLen)) {
            bReturn = FALSE;
        }
        else {
            LPSTR pszIndex;
            for (pszIndex = (LPSTR)pszBackupLocation;
                 (*pszIndex != (WCHAR)'\0') &&
                     (_ismbcprint(*pszIndex));
                     pszIndex = CharNextExA(CP_ACP,
                                            pszIndex,
                                            0)) {
            }
            if (*pszIndex != '\0') {
                bReturn = FALSE;

            }
        }
    }

	setlocale(LC_CTYPE, pszLocSave);
    return bReturn;
}

DWORD
GetBackupNameLen(LPSTR pszBackupName)

//
// Get Number of Bytes in name prior to suffix
//

{
    LPSTR pszSubString;
    LPSTR pszNextSubString;
    MD_REQUIRE((pszNextSubString = MD_STRSTR(pszBackupName, MD_BACKUP_SUFFIX)) != NULL);
    while (pszNextSubString != NULL) {

        //
        // In case the suffix happens to be part of the name
        //

        pszSubString = pszNextSubString;
        pszNextSubString = MD_STRSTR(pszSubString+(sizeof(MD_BACKUP_SUFFIX) - 1), MD_BACKUP_SUFFIX);
    }
    return DIFF(pszSubString - pszBackupName);
}

DWORD
GetBackupNameLen(LPWSTR pszBackupName)

//
// Get Number of WCHARs in name prior to version Number
//

{
    LPWSTR pszSubString;
    LPWSTR pszNextSubString;
    MD_REQUIRE((pszNextSubString = wcsstr(pszBackupName, MD_BACKUP_SUFFIXW)) != NULL);
    while (pszNextSubString != NULL) {
        pszSubString = pszNextSubString;
        pszNextSubString = wcsstr(pszSubString+((sizeof(MD_BACKUP_SUFFIXW) - 1)/ sizeof(WCHAR)),
                                  MD_BACKUP_SUFFIXW);
    }
    return DIFF(pszSubString - pszBackupName);
}

HRESULT CreateBackupFileName(IN LPSTR pszMDBackupLocation,
                             IN DWORD dwMDVersion,
                             IN BOOL  bUnicode,
                             IN OUT STRAU *pstrauBackupLocation)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszBackupLocation = pszMDBackupLocation;

    if (((dwMDVersion > MD_BACKUP_MAX_VERSION) &&
           (dwMDVersion != MD_BACKUP_NEXT_VERSION) &&
           (dwMDVersion != MD_BACKUP_HIGHEST_VERSION)) ||
        ((pszBackupLocation != NULL) &&
            !ValidateBackupLocation(pszBackupLocation, bUnicode))) {
        hresReturn = E_INVALIDARG;
    }
    else {

        if ((pszBackupLocation == NULL) ||
            (bUnicode && ((*(LPWSTR)pszBackupLocation) == (WCHAR)'\0')) ||
            (!bUnicode && ((*(LPSTR)pszBackupLocation) == (CHAR)'\0'))) {
            pszBackupLocation = MD_DEFAULT_BACKUP_LOCATION;
            bUnicode = FALSE;
        }

        if (!pstrauBackupLocation->Copy(g_pstrBackupFilePath->QueryStr())) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!pstrauBackupLocation->Append("\\")) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (bUnicode) {
                if (!pstrauBackupLocation->Append((LPWSTR)pszBackupLocation)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
            else {
                if (!pstrauBackupLocation->Append((LPSTR)pszBackupLocation)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if (!pstrauBackupLocation->Append(MD_BACKUP_SUFFIX)) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                DWORD dwVersion = dwMDVersion;
                if (dwVersion == MD_BACKUP_NEXT_VERSION) {
                    hresReturn = GetHighestVersion(pstrauBackupLocation, &dwVersion);
                    if (SUCCEEDED(hresReturn)) {
                        if (dwVersion < MD_BACKUP_MAX_VERSION) {
                            dwVersion++;
                        }
                        else {
                            hresReturn =  RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                        }
                    }
                    else if (hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) {

                        //
                        // Database doesn't exist, so new version is 0
                        //

                        dwVersion = 0;
                        hresReturn = ERROR_SUCCESS;
                    }
                }
                else if (dwVersion == MD_BACKUP_HIGHEST_VERSION) {
                    hresReturn = GetHighestVersion(pstrauBackupLocation, &dwVersion);
                }
                if (SUCCEEDED(hresReturn)) {
                    CHAR pszBuffer[MD_MAX_DWORD_STRING];
                    _ultoa((int)dwVersion, pszBuffer, 10);
                    if (!pstrauBackupLocation->Append(pszBuffer)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            //
            // Make sure the ANSI buffer is valid
            //
            if (pstrauBackupLocation->QueryStrA() == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    return hresReturn;
}

HRESULT SetBackupPath(LPSTR pszBackupPath)
{
    DWORD dwReturn = ERROR_DIRECTORY;
    DWORD dwDirectoryAttributes;

    dwDirectoryAttributes = GetFileAttributes(pszBackupPath);

    if (dwDirectoryAttributes == 0xffffffff) {
        //
        // Can't get attributes
        // Path probably doesn't exist
        //
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            dwReturn = GetLastError();
        }
        else if (!(CreateDirectory(pszBackupPath,
                                  NULL))) {
            dwReturn = GetLastError();
        }
        else {
            dwReturn = ERROR_SUCCESS;
        }
    }
    else if ((dwDirectoryAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {
        //
        // If a directory
        //
        dwReturn = ERROR_SUCCESS;
    }
    if (dwReturn == ERROR_SUCCESS) {
        //
        // Got it! Now set global variable
        //
        MD_ASSERT(g_pstrBackupFilePath == NULL);
        g_pstrBackupFilePath = new STR(pszBackupPath);
        if (g_pstrBackupFilePath == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if (!(g_pstrBackupFilePath->IsValid())) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            delete g_pstrBackupFilePath;
            g_pstrBackupFilePath = NULL;
        }
        else {
            dwReturn = ERROR_SUCCESS;
        }
    }

    return RETURNCODETOHRESULT(dwReturn);
}

HRESULT
SetGlobalDataFileValues(LPTSTR pszFileName)
{
    DWORD dwReturn = ERROR_SUCCESS;
    HANDLE hFileHandle;
    BOOL bMainFileFound = FALSE;

    hFileHandle = CreateFile(pszFileName,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             0);
    if (hFileHandle == INVALID_HANDLE_VALUE) {
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            dwReturn = GetLastError();
        }
        else {
            hFileHandle = CreateFile(pszFileName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     CREATE_NEW,
                                     FILE_ATTRIBUTE_NORMAL,
                                     0);
            if (hFileHandle == INVALID_HANDLE_VALUE) {
                dwReturn = GetLastError();
            }
            else {
                CloseHandle(hFileHandle);
                DeleteFile(pszFileName);
            }
        }
    }
    else {
        CloseHandle(hFileHandle);
        bMainFileFound = TRUE;
    }
    if (dwReturn == ERROR_SUCCESS) {
        g_strRealFileName = new STR(pszFileName);
        g_strTempFileName = new STR(pszFileName);
        if (g_strTempFileName->IsValid()) {
            g_strTempFileName->Append(MD_TEMP_DATA_FILE_EXT);
        }
        g_strBackupFileName = new STR(pszFileName);
        if (g_strBackupFileName->IsValid()) {
            g_strBackupFileName->Append(MD_BACKUP_DATA_FILE_EXT);
        }
        if (!g_strRealFileName->IsValid() || !g_strTempFileName->IsValid() ||
            !g_strBackupFileName->IsValid()) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {

            hFileHandle = CreateFile(g_strTempFileName->QueryStr(),
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     0);
            if (hFileHandle == INVALID_HANDLE_VALUE) {
                if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                    dwReturn = GetLastError();
                }
                else {
                    hFileHandle = CreateFile(g_strTempFileName->QueryStr(),
                                             GENERIC_READ | GENERIC_WRITE,
                                             0,
                                             NULL,
                                             CREATE_NEW,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0);
                    if (hFileHandle == INVALID_HANDLE_VALUE) {
                        dwReturn = GetLastError();
                    }
                    else {
                        CloseHandle(hFileHandle);
                        DeleteFile(g_strTempFileName->QueryStr());
                    }
                }
            }
            else {
                CloseHandle(hFileHandle);
            }

            if (dwReturn == ERROR_SUCCESS) {
                hFileHandle = CreateFile(g_strBackupFileName->QueryStr(),
                                         GENERIC_READ | GENERIC_WRITE,
                                         0,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_ATTRIBUTE_NORMAL,
                                         0);
                if (hFileHandle == INVALID_HANDLE_VALUE) {
                    if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                        dwReturn = GetLastError();
                    }
                    else {
                        hFileHandle = CreateFile(g_strBackupFileName->QueryStr(),
                                                 GENERIC_READ | GENERIC_WRITE,
                                                 0,
                                                 NULL,
                                                 CREATE_NEW,
                                                 FILE_ATTRIBUTE_NORMAL,
                                                 0);
                        if (hFileHandle == INVALID_HANDLE_VALUE) {
                            dwReturn = GetLastError();
                        }
                        else {
                            CloseHandle(hFileHandle);
                            DeleteFile(g_strBackupFileName->QueryStr());
                        }
                    }
                }
                else {
                    CloseHandle(hFileHandle);
                    if (!bMainFileFound) {
                        if (!MoveFile(g_strBackupFileName->QueryStr(), pszFileName)) {
                            dwReturn = GetLastError();
                        }
                    }
                }
            }
        }
        if (dwReturn != ERROR_SUCCESS) {
            delete(g_strRealFileName);
            g_strRealFileName = NULL;
            delete(g_strTempFileName);
            g_strRealFileName = NULL;
            delete(g_strBackupFileName);
            g_strRealFileName = NULL;
        }
    }
    return RETURNCODETOHRESULT(dwReturn);
}

HRESULT
SetDataFile()
{
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    TCHAR pszBuffer[MAX_PATH];
    HKEY hkRegistryKey = NULL;
    DWORD dwRegReturn;
    DWORD dwType;
    DWORD dwSize = MAX_PATH * sizeof(TCHAR);
    BOOL bAppendSlash;
    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                             ADMIN_REG_KEY,
                             &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS) {
        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                      MD_FILE_VALUE,
                                      NULL,
                                      &dwType,
                                      (BYTE *) pszBuffer,
                                      &dwSize);
        if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
            hresReturn = SetGlobalDataFileValues(pszBuffer);
        }

        MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        hkRegistryKey = NULL;

    }
    if (FAILED(hresReturn)) {
        dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                 SETUP_REG_KEY,
                                 &hkRegistryKey);
        if (dwRegReturn == ERROR_SUCCESS) {
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                          INSTALL_PATH_VALUE,
                                          NULL,
                                          &dwType,
                                          (BYTE *) pszBuffer,
                                          &dwSize);
            if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
                dwSize /= sizeof(TCHAR);
                if ((pszBuffer[dwSize-2] != (TCHAR)'/') &&
                    (pszBuffer[dwSize-2] != (TCHAR)'\\')) {
                    bAppendSlash = TRUE;
                }
                if ((dwSize + MD_STRBYTES(MD_DEFAULT_DATA_FILE_NAME) + ((bAppendSlash) ? 1 : 0)) <= MAX_PATH) {
                    if (bAppendSlash) {
                        pszBuffer[dwSize-1] = (TCHAR)'\\';
                        pszBuffer[dwSize] = (TCHAR)'\0';
                    }
                    MD_STRCAT(pszBuffer, MD_DEFAULT_DATA_FILE_NAME);
                    hresReturn = SetGlobalDataFileValues(pszBuffer);
                }
            }
            MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        }
        else {
            hresReturn = RETURNCODETOHRESULT(dwRegReturn);
        }
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // Now get the backup path.
        //
        hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                 METADATA_BACKUP_REG_KEY,
                                 &hkRegistryKey);
        if (dwRegReturn == ERROR_SUCCESS) {
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                          MD_BACKUP_PATH_VALUE,
                                          NULL,
                                          &dwType,
                                          (BYTE *) pszBuffer,
                                          &dwSize);
            if (dwRegReturn == ERROR_SUCCESS) {
                hresReturn = SetBackupPath(pszBuffer);
            }
            MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        }

        if (FAILED(hresReturn)) {
            dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                     SETUP_REG_KEY,
                                     &hkRegistryKey);
            if (dwRegReturn == ERROR_SUCCESS) {
                dwSize = MAX_PATH * sizeof(TCHAR);
                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                              INSTALL_PATH_VALUE,
                                              NULL,
                                              &dwType,
                                              (BYTE *) pszBuffer,
                                              &dwSize);
                if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
                    dwSize /= sizeof(TCHAR);
                    if ((pszBuffer[dwSize-2] != (TCHAR)'/') &&
                        (pszBuffer[dwSize-2] != (TCHAR)'\\')) {
                        bAppendSlash = TRUE;
                    }
                    if ((dwSize + MD_STRBYTES(MD_DEFAULT_DATA_FILE_NAME) + ((bAppendSlash) ? 1 : 0)) <= MAX_PATH) {
                        if (bAppendSlash) {
                            pszBuffer[dwSize-1] = (TCHAR)'\\';
                            pszBuffer[dwSize] = (TCHAR)'\0';
                        }
                        MD_STRCAT(pszBuffer, MD_DEFAULT_BACKUP_PATH_NAME);
                        hresReturn = SetBackupPath(pszBuffer);
                    }
                }
                MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
            }
            else {
                hresReturn = RETURNCODETOHRESULT(dwRegReturn);
            }
        }
    }

    return hresReturn;
}

DWORD GetObjectPath(CMDBaseObject *pboObject,
                    BUFFER *pbufPath,
                    DWORD &rdwStringLen,
                    CMDBaseObject *pboTopObject,
                    IN BOOL bUnicode)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwOldStringLen;

    MD_ASSERT(pboObject != NULL);
    if (pboObject != pboTopObject) {
        dwReturn = GetObjectPath(pboObject->GetParent(),
                                 pbufPath,
                                 rdwStringLen,
                                 pboTopObject,
                                 bUnicode);
        dwOldStringLen = rdwStringLen;
        if (pboObject->GetName(bUnicode) == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            if (bUnicode) {
                rdwStringLen += (1 + wcslen((LPWSTR)pboObject->GetName(bUnicode)));
                if (!pbufPath->Resize((rdwStringLen + 1) * sizeof(WCHAR))) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    LPWSTR lpzStringEnd = (LPWSTR)(pbufPath->QueryPtr()) + dwOldStringLen;
                    *lpzStringEnd = MD_PATH_DELIMETERW;
                    wcscpy(lpzStringEnd+1, (LPWSTR)(pboObject->GetName(bUnicode)));
                }
            }
            else {
                rdwStringLen += (1 + MD_STRBYTES(pboObject->GetName(bUnicode)));
                if (!pbufPath->Resize((rdwStringLen + 1) * sizeof(TCHAR))) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    LPTSTR lpzStringEnd = (LPTSTR)(pbufPath->QueryPtr()) + dwOldStringLen;
                    *lpzStringEnd = MD_PATH_DELIMETERA;
                    MD_STRCPY(lpzStringEnd+1, pboObject->GetName(bUnicode));
                }
            }
        }
    }
    return dwReturn;
}


HRESULT
MakeInsertPathData(STRAU *pstrauNewData,
                   LPTSTR pszPath,
                   LPTSTR pszOldData,
                   DWORD *pdwDataLen,
                   BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (bUnicode) {
        LPWSTR pszDataIndex, pszNextDataIndex;

        pstrauNewData->SetLen(0);
        for (pszDataIndex = (LPWSTR)pszOldData;
             SUCCEEDED(hresReturn) && ((pszNextDataIndex = wcsstr(pszDataIndex, MD_INSERT_PATH_STRINGW)) != NULL);
             pszDataIndex = pszNextDataIndex + ((sizeof(MD_INSERT_PATH_STRINGW) / sizeof(WCHAR)) - 1))  {
    //         *pszNextDataIndex = (TCHAR)'\0';
             if (!(pstrauNewData->Append(pszDataIndex, DIFF(pszNextDataIndex - pszDataIndex)))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
             if (!(pstrauNewData->Append((LPWSTR)pszPath))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
        }
        if (!(pstrauNewData->Append(pszDataIndex))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        *pdwDataLen = pstrauNewData->QueryCB(bUnicode) + sizeof(WCHAR);
    }
    else {
        LPTSTR pszDataIndex, pszNextDataIndex;

        pstrauNewData->SetLen(0);
        for (pszDataIndex = pszOldData;
             SUCCEEDED(hresReturn) && ((pszNextDataIndex = MD_STRSTR(pszDataIndex, MD_INSERT_PATH_STRINGA)) != NULL);
             pszDataIndex = pszNextDataIndex + ((sizeof(MD_INSERT_PATH_STRINGA) - 1)))  {
    //         *pszNextDataIndex = (TCHAR)'\0';
             if (!(pstrauNewData->Append(pszDataIndex, DIFF(pszNextDataIndex - pszDataIndex)))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
             if (!(pstrauNewData->Append(pszPath))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
        }
        if (!(pstrauNewData->Append(pszDataIndex))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        *pdwDataLen = pstrauNewData->QueryCB(bUnicode) + sizeof(CHAR);
    }
    return hresReturn;
}

HRESULT
InsertPathIntoData(BUFFER *pbufNewData,
                   STRAU *pstrData,
                   PBYTE *ppbNewData,
                   DWORD *pdwNewDataLen,
                   CMDBaseData *pbdRetrieve,
                   METADATA_HANDLE hHandle,
                   CMDBaseObject *pboDataMetaObject,
                   IN BOOL bUnicode)
{
    //
    // Need to insert path
    //
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD dwPathLen = 0;
    BUFFER bufPath;
    MD_ASSERT(GetHandleObject(hHandle) != NULL);
    CMDBaseObject *pboHandleMetaObject = (GetHandleObject(hHandle))->GetObject();

    MD_ASSERT((pbdRetrieve->GetDataType() != DWORD_METADATA) &&
        (pbdRetrieve->GetDataType() != BINARY_METADATA));

    if (pboHandleMetaObject->GetObjectLevel() > pboDataMetaObject->GetObjectLevel()) {
        hresReturn = MD_WARNING_PATH_NOT_INSERTED;
    }
    else {
        DWORD dwReturn;
        if ( (dwReturn = GetObjectPath(pboDataMetaObject,
                                       &bufPath,
                                       dwPathLen,
                                       pboHandleMetaObject,
                                       bUnicode)) != ERROR_SUCCESS) {
            hresReturn = RETURNCODETOHRESULT(dwReturn);
        }
        else if (!bufPath.Resize((dwPathLen + 2) * ((bUnicode) ? sizeof(WCHAR) : sizeof(CHAR)))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            LPTSTR pszPath;
            LPTSTR  pszOriginalData;
            DWORD dwDataLen;
            pszPath = (LPTSTR)(bufPath.QueryPtr());
            if (bUnicode) {
                ((LPWSTR)pszPath)[dwPathLen] = MD_PATH_DELIMETERW;
                ((LPWSTR)pszPath)[dwPathLen + 1] = (WCHAR)'\0';
            }
            else {
                pszPath[dwPathLen] = MD_PATH_DELIMETERA;
                pszPath[dwPathLen + 1] = (TCHAR)'\0';
            }
            //
            // If there was an error in GetData, it would have been
            // caught already.
            //
            MD_ASSERT(pbdRetrieve->GetData(bUnicode) != NULL);
            switch (pbdRetrieve->GetDataType()) {
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                {
                    hresReturn = MakeInsertPathData(pstrData,
                                             (LPTSTR)bufPath.QueryPtr(),
                                             (LPTSTR)pbdRetrieve->GetData(bUnicode),
                                             &dwDataLen,
                                             bUnicode);
                    if (SUCCEEDED(hresReturn)) {
                        //
                        // QueryStr should not fail in this instance
                        // since it was created with the same unicode flag
                        //
                        MD_ASSERT(pstrData->QueryStr(bUnicode) != NULL);
                        *ppbNewData = (PBYTE) pstrData->QueryStr(bUnicode);
                        *pdwNewDataLen = dwDataLen;
                    }
                }
                break;
            case MULTISZ_METADATA:
                {
                    if (bUnicode) {
                        LPWSTR pszDataIndex;
                        DWORD dwStringBytes;
                        dwDataLen = 0;
                        //
                        // Loop through all strings
                        //
                        for (pszDataIndex = (LPWSTR)pbdRetrieve->GetData(bUnicode);
                             SUCCEEDED(hresReturn) && (*pszDataIndex != (WCHAR)'\0');
                             pszDataIndex += (wcslen(pszDataIndex) + 1)) {
                            hresReturn = MakeInsertPathData(pstrData,
                                                            (LPSTR)bufPath.QueryPtr(),
                                                            (LPSTR)pszDataIndex,
                                                            &dwStringBytes,
                                                            bUnicode);
                            if (SUCCEEDED(hresReturn)) {
                                if (!pbufNewData->Resize(dwDataLen + dwStringBytes)) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    //
                                    // QueryStr should not fail in this instance
                                    // since it was created with the same unicode flag
                                    //
                                    MD_ASSERT(pstrData->QueryStr(bUnicode) != NULL);
                                    MD_COPY((PBYTE)(pbufNewData->QueryPtr()) + dwDataLen,
                                            pstrData->QueryStr(bUnicode),
                                            dwStringBytes);
                                    dwDataLen += dwStringBytes;
                                }
                            }
                        }
                        if (SUCCEEDED(hresReturn)) {
                            dwDataLen += sizeof(WCHAR);
                            if (!pbufNewData->Resize(dwDataLen)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            }
                            else {
                                *ppbNewData = (PBYTE)(pbufNewData->QueryPtr());
                                *(((LPWSTR)(*ppbNewData)) + ((dwDataLen / sizeof(WCHAR)) - 1)) = (WCHAR)'\0';
                                *pdwNewDataLen = dwDataLen;
                            }
                        }
                    }
                    else {
                        LPSTR pszDataIndex;
                        DWORD dwStringBytes;
                        dwDataLen = 0;
                        //
                        // Loop through all strings
                        //
                        for (pszDataIndex = (LPTSTR)pbdRetrieve->GetData(bUnicode);
                             SUCCEEDED(hresReturn) && (*pszDataIndex != (CHAR)'\0');
                             pszDataIndex += (MD_STRBYTES(pszDataIndex) + 1)) {
                            hresReturn = MakeInsertPathData(pstrData,
                                                     (LPTSTR)bufPath.QueryPtr(),
                                                     pszDataIndex,
                                                     &dwStringBytes);
                            if (SUCCEEDED(hresReturn)) {
                                if (!pbufNewData->Resize(dwDataLen + dwStringBytes)) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    //
                                    // QueryStr should not fail in this instance
                                    // since it was created with the same unicode flag
                                    //
                                    MD_ASSERT(pstrData->QueryStrA() != NULL);
                                    MD_COPY((PBYTE)(pbufNewData->QueryPtr()) + dwDataLen, pstrData->QueryStrA(), dwStringBytes);
                                    dwDataLen += dwStringBytes;
                                }
                            }
                        }
                        if (SUCCEEDED(hresReturn)) {
                            dwDataLen += sizeof(TCHAR);
                            if (!pbufNewData->Resize(dwDataLen)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            }
                            else {
                                *ppbNewData = (PBYTE)(pbufNewData->QueryPtr());
                                *(*ppbNewData + (dwDataLen-1)) = (CHAR)'\0';
                                *pdwNewDataLen = dwDataLen;
                            }
                        }
                    }
                }
                break;
            default:
                MD_ASSERT(FALSE);
            }
        }
    }
    return hresReturn;
}

HRESULT
MakeTreeCopyWithPath(CMDBaseObject *pboSource,
                     CMDBaseObject *&rpboNew,
                     LPSTR pszPath,
                     IN BOOL bUnicode)
{
    WCHAR pszName[METADATA_MAX_NAME_LEN];
    LPSTR pszTempPath = pszPath;
    CMDBaseObject *pboNew = NULL;
    CMDBaseObject *pboParent = NULL;
    CMDBaseObject *pboTree = NULL;
    CMDBaseObject *pboRoot = NULL;
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresExtractReturn;

    while ((SUCCEEDED(hresReturn)) &&
        (SUCCEEDED(hresExtractReturn = ExtractNameFromPath(pszTempPath, (LPSTR)pszName, bUnicode)))) {

        if (bUnicode) {
            pboNew = new CMDBaseObject((LPWSTR)pszName);
        }
        else {
            pboNew = new CMDBaseObject((LPSTR)pszName);
        }
        if (pboNew == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!pboNew->IsValid()) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            delete (pboNew);
        }
        else {
            if (pboParent != NULL) {
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (FAILED(hresReturn)) {
                    delete pboNew;
                    pboNew = pboParent;
                }
            }
            pboParent = pboNew;
        }
    }

    if ((SUCCEEDED(hresReturn)) && (hresExtractReturn != (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)))) {
        hresReturn = hresExtractReturn;
    }

    if (SUCCEEDED(hresReturn)) {

        //
        // Don't really want the leaf object, as MakeTreeCopy will create it.
        //

        LPWSTR pszTreeName = NULL;

        if (pboNew != NULL) {
            pszTreeName = (LPWSTR)pboNew->GetName(TRUE);
            pboParent = pboNew->GetParent();
            if (pszTreeName == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (SUCCEEDED(hresReturn)) {
            hresReturn = MakeTreeCopy(pboSource, pboTree, (LPSTR)pszTreeName, TRUE);

            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT(pboTree != NULL);

                if (pboParent != NULL) {
                    MD_REQUIRE(SUCCEEDED(pboParent->RemoveChildObject(pboNew)));
                    hresReturn = pboParent->InsertChildObject(pboTree);
                    if (FAILED(hresReturn)) {
                        delete(pboTree);
                        pboTree = NULL;
                    }
                }
            }
        }
        delete(pboNew);
        pboNew = NULL;
    }

    if (FAILED(hresReturn)) {
        if (pboParent != NULL) {
            CMDBaseObject *pboTemp;
            MD_ASSERT(pboNew != NULL);
            for (pboTemp = pboParent; pboTemp->GetParent() != NULL; pboTemp = pboTemp->GetParent()) {
            }
            //
            // destructor recurses through child objects
            //
            delete pboTemp;
        }
    }
    else {
        MD_ASSERT(pboTree != NULL);
        CMDBaseObject *pboTemp;
        for (pboTemp = pboTree; pboTemp->GetParent() != NULL; pboTemp = pboTemp->GetParent()) {
        }
        rpboNew = pboTemp;
    }

    return hresReturn;
}

HRESULT
MakeTreeCopy(CMDBaseObject *pboSource,
             CMDBaseObject *&rpboNew,
             LPSTR pszName,
             IN BOOL bUnicode)
{
    CMDBaseObject *pboTemp = NULL;
    CMDBaseObject *pboOldChild, *pboNewChild;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseData *pbdCurrent;
    HRESULT hresReturn = ERROR_SUCCESS;

    if (pszName == NULL) {
        if ((pboSource->GetName(TRUE)) != NULL) {
            pboTemp = new CMDBaseObject((LPWSTR)(pboSource->GetName(TRUE)), NULL);
        }
    }
    else {
        if (bUnicode) {
            pboTemp = new CMDBaseObject((LPWSTR)pszName, NULL);
        }
        else {
            pboTemp = new CMDBaseObject((LPSTR)pszName, NULL);
        }
    }
    if (pboTemp == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else if (!pboTemp->IsValid()) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        delete (pboTemp);
    }
    else {
        ppvMainDataBuf = GetMainDataBuffer();
        MD_ASSERT (ppvMainDataBuf != NULL);
        dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf, 0, ALL_METADATA, ALL_METADATA, FALSE);
        for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
            pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
            MD_ASSERT(pbdCurrent != NULL);
            hresReturn = pboTemp->SetDataObject(pbdCurrent);
        }
        FreeMainDataBuffer(ppvMainDataBuf);
    }
    if (SUCCEEDED(hresReturn)) {
        i = 0;
        pboOldChild = pboSource->EnumChildObject(i);
        while ((SUCCEEDED(hresReturn)) && (pboOldChild != NULL)) {
            hresReturn = MakeTreeCopy(pboOldChild, pboNewChild, NULL, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT (pboNewChild != NULL);
                hresReturn = pboTemp->InsertChildObject(pboNewChild);
            }
            i++;
            pboOldChild = pboSource->EnumChildObject(i);
        }
    }
    if (SUCCEEDED(hresReturn)) {
        rpboNew = pboTemp;
    }
    else {
        rpboNew = NULL;
        delete(pboTemp);
    }
    return (hresReturn);
}

void
AddNewChangeData(CMDHandle *phoDestHandle,
                 CMDBaseObject *pboNew)
{
    DWORD i, dwNumDataObjects;
    CMDBaseObject *pboChild;
    CMDBaseData *pbdCurrent;

    MD_ASSERT(pboNew != NULL);

    phoDestHandle->SetChangeData(pboNew, MD_CHANGE_TYPE_ADD_OBJECT, 0);
    if ((pbdCurrent = pboNew->EnumDataObject(0, 0, ALL_METADATA, ALL_METADATA)) != NULL) {
        phoDestHandle->SetChangeData(pboNew, MD_CHANGE_TYPE_SET_DATA, pbdCurrent->GetIdentifier());
    }
    i = 0;
    pboChild = pboNew->EnumChildObject(i);
    while (pboChild != NULL) {
        AddNewChangeData(phoDestHandle, pboChild);
        i++;
        pboChild = pboNew->EnumChildObject(i);
    }
}

HRESULT
CopyTree(CMDHandle *phoDestParentHandle,
         CMDBaseObject *pboDest,
         CMDBaseObject *pboSource,
         BOOL &rbChanged)

{
    CMDBaseObject *pboOldChild, *pboNewChild;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseData *pbdCurrent;
    LPSTR pszTempName;
    HRESULT hresReturn = ERROR_SUCCESS;

    MD_ASSERT(pboDest != NULL);
    MD_ASSERT(pboSource != NULL);
    ppvMainDataBuf = GetMainDataBuffer();
    MD_ASSERT (ppvMainDataBuf != NULL);
    dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf, 0, ALL_METADATA, ALL_METADATA, FALSE);
    for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
        pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
        MD_ASSERT(pbdCurrent != NULL);
        hresReturn = pboDest->SetDataObject(pbdCurrent);
        if (SUCCEEDED(hresReturn)) {
            rbChanged = TRUE;
            phoDestParentHandle->SetChangeData(pboDest, MD_CHANGE_TYPE_SET_DATA, pbdCurrent->GetIdentifier());
        }
    }
    if (SUCCEEDED(hresReturn)) {
        i = 0;
        pboOldChild = pboSource->EnumChildObject(i);
        while ((SUCCEEDED(hresReturn)) && (pboOldChild != NULL)) {
            pszTempName = (pboOldChild->GetName(TRUE));
            if (pszTempName == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                pboNewChild = pboDest->GetChildObject(pszTempName, &hresReturn, TRUE);
                if (SUCCEEDED(hresReturn)) {
                    if (pboNewChild != NULL) {
                        hresReturn = CopyTree(phoDestParentHandle, pboNewChild, pboOldChild, rbChanged);
                    }
                    else {
                        hresReturn = MakeTreeCopy(pboOldChild, pboNewChild);
                        if (SUCCEEDED(hresReturn)) {
                            MD_ASSERT (pboNewChild != NULL);
                            hresReturn = pboDest->InsertChildObject(pboNewChild);
                            if (SUCCEEDED(hresReturn)) {
                                rbChanged = TRUE;
                                AddNewChangeData(phoDestParentHandle, pboNewChild);
                            }
                            else {
                                delete(pboNewChild);
                            }
                        }
                    }
                    i++;
                    pboOldChild = pboSource->EnumChildObject(i);
                }
            }
        }
    }
    FreeMainDataBuffer(ppvMainDataBuf);
    return (hresReturn);
}

void CheckForNewMetabaseVersion()
{
    BOOL    bValueWasWrongType = FALSE;
    BOOL    bSomethingChanged = FALSE;
    HKEY    hkRegistryKey = NULL;
    DWORD   dwRegReturn,dwValue,dwType,dwSize = sizeof(DWORD);

    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                             SETUP_REG_KEY,
                             &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS) 
    {
        // Check for update to major version

        // get the Type of data only first
        // since a string won't fit in &dwValue
        dwValue = 0;
        dwSize = MAX_PATH * sizeof(TCHAR);
        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                        MD_SETMAJORVERSION_VALUE,
                        NULL,
                        &dwType,
                        NULL,
                        &dwSize);
        if ( dwRegReturn == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
            {
                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                MD_SETMAJORVERSION_VALUE,
                                NULL,
                                &dwType,
                                (BYTE *)&dwValue,
                                &dwSize);
                if ( dwRegReturn == ERROR_SUCCESS)
                {
                    // default the value with the version that this binary was compiled with
                    if (dwType == REG_DWORD)
                    {
                        if (g_dwMajorVersionNumber != dwValue && dwValue >= 1)
                        {
                            g_dwMajorVersionNumber = dwValue;
                            bSomethingChanged = TRUE;
                        }
                    }
                    else
                    {
                        bValueWasWrongType = TRUE;
                    }
                }
            }
            else
            {
                bValueWasWrongType = TRUE;
            }
        }

        if (FALSE == bValueWasWrongType)
        {
            // Check for update to minor version

            // get the Type of data only first
            // since a string won't fit in &dwValue
            dwValue = 0;
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                            MD_SETMINORVERSION_VALUE,
                            NULL,
                            &dwType,
                            NULL,
                            &dwSize);
            if ( dwRegReturn == ERROR_SUCCESS)
            {
                if (dwType == REG_DWORD)
                {
                    dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                    MD_SETMINORVERSION_VALUE,
                                    NULL,
                                    &dwType,
                                    (BYTE *)&dwValue,
                                    &dwSize);
                    if ( dwRegReturn == ERROR_SUCCESS)
                    {
                        if (dwType == REG_DWORD)
                        {
                            if (g_dwMinorVersionNumber != dwValue)
                            {
                                g_dwMinorVersionNumber = dwValue;
                                bSomethingChanged = TRUE;
                            }
                        }
                        else
                        {
                            bValueWasWrongType = TRUE;
                        }
                    }
                }
                else
                {
                    bValueWasWrongType = TRUE;
                }
            }
        }
        MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
    }

    if (TRUE == bValueWasWrongType)
    {
        // default the value with the version that this binary was compiled with

        if (g_dwMajorVersionNumber != MD_MAJOR_VERSION_NUMBER)
        {
            g_dwMajorVersionNumber = MD_MAJOR_VERSION_NUMBER;
            bSomethingChanged = TRUE;
        }

        if (g_dwMinorVersionNumber != MD_MINOR_VERSION_NUMBER)
        {
            g_dwMinorVersionNumber = MD_MINOR_VERSION_NUMBER;
            bSomethingChanged = TRUE;
        }
    }


    if (TRUE == bSomethingChanged)
    {
        // make sure that we tell the metabase that there was a change made..
        g_dwSystemChangeNumber++;
        IIS_PRINTF((buff,"MD:New Metabase Version:%d.%d\n",g_dwMajorVersionNumber,g_dwMinorVersionNumber));
    }
    return;
}

BOOL
CheckVersionNumber()
{
    BOOL bReturn = FALSE;

    if (g_dwMajorVersionNumber >= 1) {
        // 1 = IIS4
        //     we need to be able to open IIS4 in IIS5 during setup upgrade
        // 2 = IIS5
        bReturn = TRUE;
    }

    // g_dwMinorVersionNumber -- maybe use this for Major service pack releases or something in which
    //                           Metabase has been changed and we need to know the difference?

    return bReturn;
}

HRESULT
InitStorageAndSessionKey(
    IN IIS_CRYPTO_STORAGE *pCryptoStorage,
    OUT PIIS_CRYPTO_BLOB *ppSessionKeyBlob
    )
{
    HRESULT hresReturn;
    HCRYPTPROV hProv;

    //
    // Get a handle to the crypto provider, init the storage object,
    // then export the session key blob.
    //

    hresReturn = GetCryptoProvider( &hProv );

    if( SUCCEEDED(hresReturn) ) {
        hresReturn = pCryptoStorage->Initialize(
                         TRUE,                          // fUseMachineKeyset
                         hProv
                         );
    }

    if( SUCCEEDED(hresReturn) ) {
        hresReturn = pCryptoStorage->GetSessionKeyBlob( ppSessionKeyBlob );
    }

    return hresReturn;

}   // InitStorageAndSessionKey


VOID
SkipPathDelimeter(IN OUT LPSTR &rpszPath,
                    IN BOOL bUnicode)
{
    if (bUnicode) {
        LPWSTR pszPath = (LPWSTR)rpszPath;
        SKIP_PATH_DELIMETERW(pszPath);
        rpszPath = (LPSTR)pszPath;
    }
    else {
        SKIP_PATH_DELIMETERA(rpszPath);
    }
}

BOOL
IsStringTerminator(IN LPTSTR pszString,
                   IN BOOL bUnicode)
{
    if (bUnicode) {
        if (*(LPWSTR)pszString == (WCHAR)'\0') {
            return TRUE;
        }
    }
    else {
        if (*(LPSTR)pszString == (CHAR)'\0') {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT
GetLastHResult() {
    DWORD tmp = GetLastError();
    return RETURNCODETOHRESULT(tmp);
}


HRESULT STDMETHODCALLTYPE  BackupCertificates (LPCWSTR  backupName,PCHAR lpszToPath,PCHAR lpszFromPath)
{
    HRESULT             hresReturn = ERROR_SUCCESS;
    CHAR                *p1,*p2;
    LPSTR               searchMask = "*.mp";
    LPSTR               backupNameSeparator = ".";
    CHAR                strSourcePath[MAX_PATH];
    CHAR                strSearchPattern[MAX_PATH];
    CHAR                strDestPath[MAX_PATH];
    DWORD               dwLenOfBackupName, n1;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FileInfo; 
    BOOL                fFoundFile = TRUE, fValid;
    STRAU               strSrcFileName, strDestFileName;
        
    dwLenOfBackupName = wcslen (backupName) * sizeof (WCHAR);
    p1 = strrchr (lpszFromPath,'\\');
    p2 = strrchr (lpszToPath,'\\');
    if (p1 &&p2)
    {
        n1 = min (MAX_PATH-1, DIFF(p1 - lpszFromPath)+1);
        strncpy (strSourcePath,lpszFromPath,n1);
        strSourcePath[n1] = 0;
        strcpy (strSearchPattern,strSourcePath);
        
        n1 = min (MAX_PATH-1, DIFF(p2 - lpszToPath)+1);
        strncpy (strDestPath,lpszToPath,n1);
        strDestPath[n1] = 0;
        
        if (strlen (strSourcePath) +  strlen(searchMask) < MAX_PATH)
        {
            strcat (strSearchPattern,searchMask);
            hFindFile = FindFirstFile( strSearchPattern, &FileInfo);
            
            if (hFindFile == INVALID_HANDLE_VALUE)
            {
                // no certificate file found
                return ERROR_SUCCESS;
            }
            
            while (fFoundFile)
            {
                if ( strlen (FileInfo.cFileName) + strlen (strDestPath) + dwLenOfBackupName + 1 < MAX_PATH)
                {
                    
                    fValid = strSrcFileName.Copy (strSourcePath);
                    fValid = fValid && strSrcFileName.Append (FileInfo.cFileName);
                    
                    fValid = fValid && strDestFileName.Copy (strDestPath);
                    fValid = fValid && strDestFileName.Append ((LPWSTR)backupName);
                    fValid = fValid && strDestFileName.Append (backupNameSeparator);
                    fValid = fValid && strDestFileName.Append (FileInfo.cFileName);
                    
                    if (fValid)
                    {
                        if (!CopyFileW (strSrcFileName.QueryStrW(),strDestFileName.QueryStrW(),FALSE))
                        {
                            IIS_PRINTF((buff,"CertificateBackup: CopyFileW error 0x%0X \n",GetLastError()));                            
                        }
                    }
                    else
                    {
                        IIS_PRINTF((buff,"CertificateBackup: Failure in STRAU manipulation \n"));                            
                    }
                    
                }
                
                fFoundFile = FindNextFile(hFindFile,&FileInfo);
            }
            fFoundFile = FindClose (hFindFile);
            MD_ASSERT (fFoundFile);
        }
        else
        {
            IIS_PRINTF((buff,"CertificateBackup: strSourcePath filename was too long\n"));                            
        }
    }
    else
    {
        IIS_PRINTF((buff,"CertificateBackup: can't find last back slash in one of these strings %s %s\n",lpszToPath,lpszFromPath));                            
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE  RestoreCertificates (LPCWSTR  backupName,PCHAR lpszFromPath,PCHAR lpszToPath)
{
    HRESULT             hresReturn = ERROR_SUCCESS;
    DWORD               n1;
    CHAR                strDestinationPath[MAX_PATH];
    CHAR                strSourcePath[MAX_PATH];
    CHAR                *p1,*p2;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    BOOL                fFoundFile = TRUE, fValid;
    STRAU               strSearchPatttern, strDestFileName, strSrcFileName;
    WIN32_FIND_DATAW    FileInfo; 
    
    
    
    p1 = strrchr (lpszToPath,'\\');
    p2 = strrchr (lpszFromPath,'\\');
    
    
    if (p1 &&p2)
    {
        
        n1 = min (MAX_PATH-1, DIFF(p1 - lpszToPath)+1);
        strncpy (strDestinationPath,lpszToPath,n1);
        strDestinationPath[n1] = 0;
        
        n1 = min (MAX_PATH-1, DIFF(p2 - lpszFromPath)+1);
        strncpy (strSourcePath,lpszFromPath,n1);
        strSourcePath[n1] = 0;
        
        
        strSearchPatttern.Copy (strSourcePath);
        strSearchPatttern.Append ((LPWSTR)backupName);
        strSearchPatttern.Append ((LPWSTR)L".*.mp");
        
        
        hFindFile = FindFirstFileW( strSearchPatttern.QueryStrW(), &FileInfo);
        
        if (hFindFile == INVALID_HANDLE_VALUE)
        {
            // no certificate file found
            return ERROR_SUCCESS;
        }
        
        while (fFoundFile)
        {
            fValid = strDestFileName.Copy (strDestinationPath);
            fValid = fValid && strDestFileName.Append ((LPWSTR)(FileInfo.cFileName + wcslen (backupName) +1));
            
            fValid = fValid && strSrcFileName.Copy (strSourcePath);
            fValid = fValid && strSrcFileName.Append ((LPWSTR)FileInfo.cFileName);
            
            if (fValid)
            {
                if (!CopyFileW (strSrcFileName.QueryStrW(),strDestFileName.QueryStrW(),FALSE))
                {
                    IIS_PRINTF((buff,"CertificateBackup: CopyFileW error 0x%0X \n",GetLastError()));                            
                }
            }
            else
            {
                IIS_PRINTF((buff,"CertificateBackup: Failure in STRAU manipulation \n"));                            
            }
            
            fFoundFile = FindNextFileW(hFindFile,&FileInfo);
        }
        fFoundFile = FindClose (hFindFile);
        MD_ASSERT (fFoundFile);
    }
    else
    {
        IIS_PRINTF((buff,"CertificateRestore: can't find last back slash in one of these strings %s %s\n",lpszToPath,lpszFromPath));                            
    }
    
    return hresReturn;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\ptrmap.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation
  
    Module Name:
    
      ptrmap.cxx
      
    Abstract:
        
      A helper class for mapping ID to 32 or 64 bit ptr
       
    Author:
      Kestutis Patiejunas (kestutip)        08-Dec-1998
            
              
    Revision History:
                
      Notes:
                  
--*/

#include <mdcommon.hxx>
#include <ptrmap.hxx>




/*++
Routine Description:

  Constructor
  
    Arguments:
    nStartMaps - initial nubmer of possible mappings in table
    nIncreaseMaps - number of increase for table when there is not enought space
    
      Return Value:
      sucess is tored in m_fInitialized
      
--*/
CIdToPointerMapper::CIdToPointerMapper(DWORD nStartMaps,DWORD nIncreaseMaps):
                    m_nStartMaps(nStartMaps),                
                    m_nIncreaseMaps(nIncreaseMaps)
{
    if (!m_nStartMaps)
    {
        m_nStartMaps = DEFAULT_START_NUMBER_OF_MAPS;
    }
    if (!nIncreaseMaps)
    {
        m_nIncreaseMaps = DEFAULT_INCREASE_NUMBER_OF_MAPS;
    }
    
    
    // initial empty list head index
    m_EmptyPlace = 0;
    m_nMappings = 0;
    
    
    // allocate a mem for mapping
    m_pBufferObj = new BUFFER (m_nStartMaps * sizeof(PVOID));
    m_Map = (PVOID *) m_pBufferObj->QueryPtr();
    
    if (m_Map)
    {
        // initialized mappaing space so the every element point to next one
        for (DWORD i=0; i< m_nStartMaps; i++)
        {
            m_Map[i] = (PVOID) (((UINT_PTR)(i+1)) | MAPPING_MASK_SET);
        }
        
        // just he last has special value
        m_Map [m_nStartMaps-1] = (PVOID)MAPPING_NO_EMPTY_PLACE;
        
        m_fInitialized = TRUE;
    }
    else
    {
        m_fInitialized =FALSE;
    }
    
    
}


CIdToPointerMapper::~CIdToPointerMapper()
{
    VerifyOutstandinMappings ();
    if (m_fInitialized)
    {
        delete m_pBufferObj;
    }
}


VOID CIdToPointerMapper::VerifyOutstandinMappings ()
{
    MD_ASSERT (m_nMappings==0);
}




/*++
Routine Description:

  Finds a mapping in mapping table between DWORD ID and pointer associated
  
    Arguments:
    DWORD ID - and ID to which mapping should be deleted. 
    
      Return Value:
      
        DWORD - an ID associated with a given pointer . Starts from 1. 
        Zero indicates  a failure to craete mapping.
        
--*/

PVOID   CIdToPointerMapper::FindMapping (DWORD id)
{
    PVOID retVal = NULL;
    
    if (m_fInitialized)
    {
        id--;
        
        MD_ASSERT (id < m_nStartMaps);
        if (id < m_nStartMaps)
        {
            // there it's simple: get a ptr from  element [id]
            // check that highest bit isn't on
            retVal = m_Map[id];
            if ( ((UINT_PTR)retVal) & MAPPING_MASK_SET)
            {
                retVal = NULL;
                MD_ASSERT (retVal);
            }
        }
    }
    
    return retVal;
}


/*++
Routine Description:

  Deletes a mapping from mapping table between dword ID and PTR
  
    Arguments:
    DWORD ID - and ID to which mapping should be deleted. 
    
      Return Value:
      
        BOOL TRUE is succeded
--*/

BOOL  CIdToPointerMapper::DeleteMapping (DWORD id)
{
    BOOL retVal = FALSE;    
    PVOID ptr;
    
    if (m_fInitialized)
    {
        id--;
        
        MD_ASSERT (id < m_nStartMaps);
        if (id < m_nStartMaps)
        {
            // get the ptr from element with index [id]
            // check that it has not hihgest bit on
            ptr = m_Map[id];
            if ( ((UINT_PTR)ptr) & MAPPING_MASK_SET)
            {
                MD_ASSERT (0);
            }
            else
            {
                // add elemen to empty elements list  
                m_Map[id] = (PVOID)(((UINT_PTR)(m_EmptyPlace)) | MAPPING_MASK_SET);
                m_EmptyPlace = id;
                MD_ASSERT (m_nMappings);
                m_nMappings--;
                retVal = TRUE;
            }
        }
    }
    
    return retVal;
}


/*++
Routine Description:

  Takes a PVOID pointer and returns a DWORD ID associated,which should be used
  in mapping it back to ptr
  
    Arguments:
    PVOID ptr - a pointer of 32/64 bits which should be mapped into dword
    
      Return Value:
      
        DWORD - an ID associated with a given pointer . Starts from 1. 
        Zero indicates  a failure to craete mapping.
        
--*/
DWORD   CIdToPointerMapper::AddMapping (PVOID ptr)
{
    DWORD retVal=0;
    DWORD newSize, i, n, dwPlace;
    PVOID *tmpPtr;
    
    if (m_fInitialized)
    {
        if ( m_EmptyPlace == MAPPING_NO_EMPTY_PLACE_IDX)
        {
            // case when there is not enough mem , so then try to realloc
            newSize = m_nStartMaps + m_nIncreaseMaps;

            m_pBufferObj->Resize (newSize * sizeof(PVOID));
            tmpPtr = (PVOID *) m_pBufferObj->QueryPtr();

            if (tmpPtr)
            {
                m_Map = tmpPtr;
                
                // realloc succeded initialize the remainder as free list
                for (i=m_nStartMaps; i<newSize; i++)
                {
                    m_Map[i] = (PVOID)(((UINT_PTR)(i+1)) | MAPPING_MASK_SET);
                }
                m_Map [newSize-1] =  (PVOID)MAPPING_NO_EMPTY_PLACE;
                m_EmptyPlace = m_nStartMaps;
                m_nStartMaps = newSize;
            }
            else
            {
                MD_ASSERT (tmpPtr);
                return retVal;
            }
        }
            
            
            // case when there was at least one empty element in free list
            
            dwPlace = m_EmptyPlace;
            if (m_Map[m_EmptyPlace] != (PVOID)MAPPING_NO_EMPTY_PLACE)
            {
                // there still is another one element free
                // so take it's next->next and clear highest bit
                m_EmptyPlace = (DWORD)( ((UINT_PTR)m_Map[m_EmptyPlace]) & MAPPING_MASK_CLEAR);
            }
            else
            {
                // thsi one was last element so now free list is empty
                m_EmptyPlace = MAPPING_NO_EMPTY_PLACE_IDX;
            }
            
            // add a pointer into array and return associated ID
            // note, that we return dwPlace+1 ,a s we don't use ID zero
            m_Map[dwPlace] = ptr;
            retVal = dwPlace + 1;
            m_nMappings++;
        }
        return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\metafix.cpp ===
#include "main.h"

#include <locale.h>
#include <..\inc\mdcommon.hxx>
#include <dbgutil.h>
#include <tsres.hxx>
#include <inetsvcs.h>

CIdToPointerMapper  *g_PointerMapper = NULL;


// forwards...
//#define IsSecureMetadata(id,att) (((DWORD)(att) & METADATA_SECURE) != 0)

#if DBG

BOOL g_fShowMetaLocks = FALSE;

#endif DBG

HRESULT GetObjectFromPath(
         OUT CMDBaseObject *&rpboReturn,
         IN METADATA_HANDLE hHandle,
         IN DWORD dwPermissionNeeded,
         IN OUT LPTSTR &strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds an object from a path. Updates Path to point past the last
    object found if the whole path is not found. If the entire path
    is not found, the last object found is returned.

Arguments:

    Return - The object found.

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    PermissionNeeded - The read/write permissions needed. Compared with the
             permissions associated with Handle.

    Path   - The path of the object requested, relative to Handle. If the path
             is not found, this is updated to point to the portion of the path
             not found.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseObject *pboCurrent, *pboPrevious;
    LPTSTR strCurPath = strPath;

    CMDHandle *HandleObject = GetHandleObject(hHandle);
    if (HandleObject == NULL) {
        hresReturn = E_HANDLE;
    }
    else if ((((dwPermissionNeeded & METADATA_PERMISSION_WRITE) != 0) && (!HandleObject->IsWriteAllowed())) ||
        (((dwPermissionNeeded & METADATA_PERMISSION_READ) != 0) && (!HandleObject->IsReadAllowed()))) {
        hresReturn = E_ACCESSDENIED;
    }
    else {
        pboCurrent = HandleObject->GetObject();
        MD_ASSERT(pboCurrent != NULL);
        strCurPath = strPath;

        if (strCurPath != NULL) {
            SkipPathDelimeter(strCurPath, bUnicode);
            while ((pboCurrent != NULL) &&
                (!IsStringTerminator(strCurPath, bUnicode))) {
                pboPrevious = pboCurrent;
                //
                // GetChildObject increments strCurPath on success
                // and returns NULL if child not found
                //
                pboCurrent = pboCurrent->GetChildObject(strCurPath, &hresReturn, bUnicode);
                if (FAILED(hresReturn)) {
                    break;
                }
                if (pboCurrent != NULL) {
                    SkipPathDelimeter(strCurPath, bUnicode);
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if ((strCurPath == NULL) ||
                IsStringTerminator(strCurPath, bUnicode)) {  // Found the whole path
                rpboReturn = pboCurrent;
                hresReturn = ERROR_SUCCESS;
            }
            else {           //return last object found and an error code
                rpboReturn = pboPrevious;
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
                strPath = strCurPath;
            }
        }
    }

    return (hresReturn);
}

HRESULT AddObjectToDataBase(
         IN METADATA_HANDLE hHandle,
         IN LPTSTR strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Creates and adds one or more objects to the metabase. Finds the deepest object
    pointed to by Handle/Path and creates any subobject specified by path.

Arguments:

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    Path   - The path of the object(s) to be created.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_NOT_ENOUGH_MEMORY
             ERROR_INVALID_NAME

Notes:

--*/
{
    HRESULT hresReturn=ERROR_SUCCESS;
    CMDBaseObject *pboParent;
    LPTSTR strTempPath = strPath;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    HRESULT hresExtractRetCode = ERROR_SUCCESS;

    hresReturn = GetObjectFromPath(pboParent,
                                hHandle,
                                METADATA_PERMISSION_WRITE,
                                strTempPath,
                                bUnicode);
    //
    // This should return ERROR_PATH_NOT_FOUND and the parent object,
    // with strPath set to the remainder of the path,
    // which should be the child name, without a preceding delimeter.
    //
    if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
        MD_ASSERT(pboParent != NULL);
        for (hresExtractRetCode = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode);
            SUCCEEDED(hresExtractRetCode);
            hresExtractRetCode = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode)) {
            CMDBaseObject *pboNew;
            if (bUnicode) {
                pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
            }
            else {
                pboNew = new CMDBaseObject((LPSTR)strName, NULL);
            }
            if (pboNew == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                break;
            }
            else if (!pboNew->IsValid()) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                delete (pboNew);
                break;
            }
            else {
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (FAILED(hresReturn)) {
                    delete (pboNew);
                    break;
                }
                else {
                    pboParent = pboNew;
                    MD_ASSERT(GetHandleObject(hHandle) != NULL);
                    GetHandleObject(hHandle)->SetChangeData(pboNew, MD_CHANGE_TYPE_ADD_OBJECT, 0);
                }
            }
        }
    }
    else if (SUCCEEDED(hresReturn)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
    }
    if (hresExtractRetCode == RETURNCODETOHRESULT(ERROR_INVALID_NAME)) {
        hresReturn = hresExtractRetCode;
    }
    return(hresReturn);
}

HRESULT RemoveObjectFromDataBase(
         IN METADATA_HANDLE hHandle,
         IN LPTSTR strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a metaobject and all subobjects from the database.

Arguments:

    Handle - The Meta Data handle. A handle returned by MDOpenMetaObject with write permission.

    Path   - The path of the object(s) to be created.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND
             ERROR_INVALID_PARAMETER

Notes:

--*/
{
    HRESULT hresReturn;
    CMDBaseObject *pboDelete;
    LPTSTR strTempPath = strPath;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    //
    // Make sure that a valid path was specified
    //
    SkipPathDelimeter(strTempPath, bUnicode);
    hresReturn = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode);
    if (FAILED(hresReturn)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        strTempPath = strPath;
        hresReturn = GetObjectFromPath(pboDelete,
                                       hHandle,
                                       METADATA_PERMISSION_WRITE,
                                       strTempPath,
                                       bUnicode);
        if (SUCCEEDED(hresReturn)) {
            hresReturn = (pboDelete->GetParent())->RemoveChildObject(pboDelete);
            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT(GetHandleObject(hHandle) != NULL);
                if (GetHandleObject(hHandle)->SetChangeData(pboDelete, MD_CHANGE_TYPE_DELETE_OBJECT, 0)
                    != ERROR_SUCCESS) {
                    delete(pboDelete);
                }
            }
        }
    }
    return(hresReturn);
}

CMDHandle *GetHandleObject(
         IN METADATA_HANDLE hHandle)
/*++

Routine Description:

    Gets the handle object associated with Handle.

Arguments:

    Handle - The Meta Data handle to get. METADATA_MASTER_ROOT_HANDLE Or a handle
             returned by MDOpenMetaObject.

Return Value:

    CMDHandle * - The handle object, or NULL if not found.

Notes:

--*/
{
    CMDHandle *hoCurrent;
    for (hoCurrent = g_phHandleHead;
        (hoCurrent != NULL) && (hoCurrent->GetHandleIdentifier() != hHandle);
        hoCurrent = hoCurrent->GetNextPtr()) {
    }
    return (hoCurrent);
}

BOOL
PermissionsAvailable(
         IN CMDBaseObject *pboTest,
         IN DWORD dwRequestedPermissions,
         IN DWORD dwReadThreshHold
         )
/*++

Routine Description:

    Checks if the requested handle permissions are available for a meta object.

Arguments:

    Handle - The Meta Data handle to get. METADATA_MASTER_ROOT_HANDLE Or a handle
             returned by MDOpenMetaObject.

    RequestedPermissions - The permissions requested.

    ReadThreshHold - The number of reads allows on a write request. Normally 0.

Return Value:

    BOOL   - TRUE if the permissions are available.

Notes:

--*/
{
    BOOL bResults = TRUE;
    CMDBaseObject *pboCurrent;
    MD_ASSERT(pboTest != NULL);
    if (dwRequestedPermissions & METADATA_PERMISSION_WRITE) {
        if ((pboTest->GetReadPathCounter() != 0) ||
            (pboTest->GetWritePathCounter() != 0)) {
            bResults = FALSE;
        }
        if ((pboTest->GetReadCounter() > dwReadThreshHold) || (pboTest->GetWriteCounter() != 0)) {
            bResults = FALSE;
        }
        for (pboCurrent = pboTest->GetParent();bResults && (pboCurrent!=NULL);pboCurrent=pboCurrent->GetParent()) {
            if ((pboCurrent->GetReadCounter() != 0) || (pboCurrent->GetWriteCounter() != 0)) {
                bResults = FALSE;
            }
        }
    }
    else if (dwRequestedPermissions & METADATA_PERMISSION_READ) {
        if (pboTest->GetWritePathCounter() != 0) {
            bResults = FALSE;
        }
        for (pboCurrent = pboTest;bResults && (pboCurrent!=NULL);pboCurrent=pboCurrent->GetParent()) {
            if (pboCurrent->GetWriteCounter() != 0) {
                bResults = FALSE;
            }
        }
    }
    else {
        MD_ASSERT(FALSE);
    }
    return (bResults);
}

VOID RemovePermissions(
         IN CMDBaseObject *pboAffected,
         IN DWORD dwRemovePermissions
         )
/*++

Routine Description:

    Removes the handle permissions from a meta object.

Arguments:

    Affected - The object to remove permissions from.

    RemovePermissions - The permissions to remove.

Return Value:

Notes:

--*/
{
    MD_ASSERT(pboAffected != NULL);
    CMDBaseObject *pboCurrent;
    if ((dwRemovePermissions & METADATA_PERMISSION_WRITE) != 0) {
        pboAffected->DecrementWriteCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->DecrementWritePathCounter();
        }
    }
    if ((dwRemovePermissions & METADATA_PERMISSION_READ) != 0) {
        pboAffected->DecrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->DecrementReadPathCounter();
        }
    }
    
#if DBG
    char szBuf[1024];
    unsigned long cchSz;
    BUFFER bufName;
    unsigned long cchBuf = 0;
    int wCount;

    if (g_fShowMetaLocks)
        {
        if ((dwRemovePermissions & (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ)) ==
                (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read/Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRemovePermissions & (METADATA_PERMISSION_WRITE))
            {
            strcpy(szBuf, "Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRemovePermissions & (METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read");
            wCount = pboAffected->GetReadCounter();
            }
        else
            {
            strcpy(szBuf, "No");
            wCount = 0;
            }

        strcat(szBuf, " perms releasted (%d) on ");
        cchSz = strlen(szBuf);
    
        GetObjectPath(pboAffected, &bufName, cchBuf, g_pboMasterRoot, FALSE);
    
        cchBuf = (cchBuf + cchSz + 2 > sizeof(szBuf)) ? sizeof(szBuf) - cchSz - 2 : cchBuf;
        memcpy(szBuf + cchSz, bufName.QueryPtr(), cchBuf);
        szBuf[cchSz + cchBuf] = '\n';
        szBuf[cchSz + cchBuf + 1] = '\0';
    
        DBGPRINTF((DBG_CONTEXT, szBuf, wCount));
        }
#endif
}

VOID
AddPermissions(
         IN CMDBaseObject *pboAffected,
         IN DWORD dwRequestedPermissions
         )
/*++

Routine Description:

    Adds handle permissions to a meta object.

Arguments:

    Affected - The object to remove permissions from.

    ReqyestedPermissions - The permissions to add.

Return Value:

Notes:

--*/
{
    CMDBaseObject *pboCurrent;
    if (((dwRequestedPermissions & METADATA_PERMISSION_WRITE) != 0) &&
        ((dwRequestedPermissions & METADATA_PERMISSION_READ) != 0)) {
        pboAffected->IncrementWriteCounter();
        pboAffected->IncrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementWritePathCounter();
            pboCurrent->IncrementReadPathCounter();
        }
    }
    else if ((dwRequestedPermissions & METADATA_PERMISSION_WRITE) != 0) {
        pboAffected->IncrementWriteCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementWritePathCounter();
        }
    }
    else if ((dwRequestedPermissions & METADATA_PERMISSION_READ) != 0) {
        pboAffected->IncrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementReadPathCounter();
        }
    }

#if DBG
    char szBuf[1024];
    unsigned long cchSz;
    BUFFER bufName;
    unsigned long cchBuf = 0;
    int wCount;

    if (g_fShowMetaLocks)
        {
        if ((dwRequestedPermissions & (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ)) ==
                (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read/Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRequestedPermissions & (METADATA_PERMISSION_WRITE))
            {
            strcpy(szBuf, "Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRequestedPermissions & (METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read");
            wCount = pboAffected->GetReadCounter();
            }
        else
            {
            strcpy(szBuf, "No");
            wCount = 0;
            }

        strcat(szBuf, " perms obtained (%d) on ");
        cchSz = strlen(szBuf);
        
        GetObjectPath(pboAffected, &bufName, cchBuf, g_pboMasterRoot, FALSE);
        
        cchBuf = (cchBuf + cchSz + 2 > sizeof(szBuf)) ? sizeof(szBuf) - cchSz - 2 : cchBuf;
        memcpy(szBuf + cchSz, bufName.QueryPtr(), cchBuf);
        szBuf[cchSz + cchBuf] = '\n';
        szBuf[cchSz + cchBuf + 1] = '\0';
        
        DBGPRINTF((DBG_CONTEXT, szBuf, wCount));
        }
#endif
}

HRESULT
AddHandle(
         IN CMDBaseObject *pboAssociated,
         IN DWORD dwRequestedPermissions,
         IN METADATA_HANDLE &rmhNew
         )
/*++

Routine Description:

    Creates a handle object and adds it to the handle list.

Arguments:

    Handle - The object the handle is associated with.

    RequestedPermissions - The permissions for the handle.

    New - The handle id.

Return Value:
    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *hoNew = new CMDHandle(pboAssociated,
                                     dwRequestedPermissions,
                                     g_dwSystemChangeNumber,
                                     g_mhHandleIdentifier++);
    if (hoNew == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        rmhNew = hoNew->GetHandleIdentifier();
        hoNew->SetNextPtr(g_phHandleHead);
        g_phHandleHead = hoNew;
        AddPermissions(pboAssociated, dwRequestedPermissions);
    }
    return(hresReturn);
}

CMDHandle *
RemoveHandleObject(
         IN METADATA_HANDLE mhHandle
         )
/*++

Routine Description:

    Removes a handle object from the handle list.

Arguments:

    Handle - The handle to be removed.

Return Value:

    CMDHandle * - The Handle object removed.

Notes:

--*/
{
    CMDHandle *hoCurrent;
    CMDHandle *hoReturn;

    if (g_phHandleHead->GetHandleIdentifier() == mhHandle) {
        hoReturn = g_phHandleHead;
        g_phHandleHead = g_phHandleHead->GetNextPtr();
    }
    else {
        for (hoCurrent = g_phHandleHead;(hoCurrent->GetNextPtr() != NULL) &&
            (hoCurrent->GetNextPtr()->GetHandleIdentifier() != mhHandle);
            hoCurrent = hoCurrent->GetNextPtr()) {
        }
        hoReturn = hoCurrent->GetNextPtr();
        if (hoCurrent->GetNextPtr() != NULL) {
            MD_ASSERT (hoCurrent->GetNextPtr()->GetHandleIdentifier() == mhHandle);
            hoCurrent->SetNextPtr(hoCurrent->GetNextPtr()->GetNextPtr());
        }
    }
    return (hoReturn);
}

HRESULT
SaveDataObject(HANDLE hFileHandle,
               CMDBaseData *pbdSave,
               PBYTE pbLineBuf,
               DWORD dwWriteBufSize,
               PBYTE pbWriteBuf,
               PBYTE &pbrNextPtr,
               IIS_CRYPTO_STORAGE *pCryptoStorage)
/*++

Routine Description:

    Save a data object.

Arguments:

    FileHandle - File handle for use by WriteLine.

    Save       - The data object to save.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BOOL bGoodData = TRUE;
    int iStringLen;
    PBYTE pbData;
    DWORD dwTemp;

    if ((pbdSave->GetAttributes() & METADATA_VOLATILE) == 0) {

        *pbLineBuf = MD_ID_DATA;

        hresReturn = WriteLine(hFileHandle,
                            dwWriteBufSize,
                            pbWriteBuf,
                            pbLineBuf,
                            pbrNextPtr,
                            1,
                            FALSE);

        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetIdentifier();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetAttributes();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetUserType();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetDataType();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }

        if (SUCCEEDED(hresReturn)) {
            if (pbdSave->GetData(TRUE) == NULL) {
                //
                // This is to make sure that unicode conversion doesn't cause an error.
                //
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                if (IsSecureMetadata(pbdSave->GetIdentifier(), pbdSave->GetAttributes())) 
                {
                    //
                    // let's not save it!!!
                    //
                    //printf("Not saving encrypted data.\n");
                    MyPrintf(_T("Not saving encrypted data ID=%d.\n"), pbdSave->GetIdentifier());
                    IIS_PRINTF((buff,"Not saving encrypted data for ID=%d\n",pbdSave->GetIdentifier()));
                    hresReturn = ERROR_SUCCESS;

                    if (FALSE){
                    PIIS_CRYPTO_BLOB blob;

                    //
                    // This is a secure data object, so encrypt it before saving it
                    // to the file.
                    //

                    MD_ASSERT(pCryptoStorage != NULL);

                    hresReturn = pCryptoStorage->EncryptData(&blob,
                                                          pbdSave->GetData(TRUE),
                                                          pbdSave->GetDataLen(TRUE),
                                                          0);

                    if (SUCCEEDED(hresReturn)) {
                        hresReturn = WriteLine(hFileHandle,
                                            dwWriteBufSize,
                                            pbWriteBuf,
                                            (PBYTE)blob,
                                            pbrNextPtr,
                                            IISCryptoGetBlobLength(blob),
                                            TRUE);

                        ::IISCryptoFreeBlob(blob);
                    }
                    }

                } else {
                    hresReturn = WriteLine(hFileHandle,
                                        dwWriteBufSize,
                                        pbWriteBuf,
                                        (PBYTE)pbdSave->GetData(TRUE),
                                        pbrNextPtr,
                                        pbdSave->GetDataLen(TRUE),
                                        TRUE);
                }
            }
        }
    }
    return (hresReturn);
}

HRESULT
SaveMasterRoot(HANDLE hFileHandle,
               PBYTE pbLineBuf,
               DWORD  dwWriteBufSize,
               PBYTE pbWriteBuf,
               PBYTE &pbrNextPtr,
               IIS_CRYPTO_STORAGE *pCryptoStorage)
/*++

Routine Description:

    Save the master root object, including its data objects.

Arguments:

    FileHandle - File handle for use by WriteLine.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    PFILETIME pftTime;

    pftTime = g_pboMasterRoot->GetLastChangeTime();

    *pbLineBuf = MD_ID_ROOT_OBJECT;

    hresReturn = WriteLine(hFileHandle,
                        dwWriteBufSize,
                        pbWriteBuf,
                        pbLineBuf,
                        pbrNextPtr,
                        1,
                        FALSE);

    if (SUCCEEDED(hresReturn)) {
        hresReturn = WriteLine(hFileHandle,
                            dwWriteBufSize,
                            pbWriteBuf,
                            (PBYTE)pftTime,
                            pbrNextPtr,
                            sizeof(FILETIME),
                            TRUE);
    }

    for(dwEnumObjectIndex=0,dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
        (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
        dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
        hresReturn = SaveDataObject(hFileHandle,
                                 dataAssociatedData,
                                 pbLineBuf,
                                 dwWriteBufSize,
                                 pbWriteBuf,
                                 pbrNextPtr,
                                 pCryptoStorage);
    }

    return(hresReturn);
}

HRESULT
SaveTree(
         IN HANDLE hFileHandle,
         IN CMDBaseObject *pboRoot,
         IN PBYTE pbLineBuf,
         IN BUFFER *pbufParentPath,
         IN DWORD  dwWriteBufSize,
         IN PBYTE pbWriteBuf,
         IN OUT PBYTE &pbrNextPtr,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage)
/*++

Routine Description:

    Save a tree, recursively saving child objects. This works out as
    a depth first save.

Arguments:

    FileHandle - File handle for use by WriteLine.

    Root       - The root of the tree to save.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseObject *objChildObject;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    DWORD dwParentPathLen, dwNewParentPathLen;
    DWORD dwNameLen;
    LPWSTR strParentPath;
    PFILETIME pftTime;

    dwParentPathLen = wcslen((LPWSTR)pbufParentPath->QueryPtr());
    if (pboRoot->GetName(TRUE) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        dwNameLen = wcslen((LPWSTR)pboRoot->GetName(TRUE));
        //
        // include 1 for delimeter and 1 for \0
        //
        dwNewParentPathLen = dwParentPathLen + dwNameLen + 2;
        if (!pbufParentPath->Resize((dwNewParentPathLen) * sizeof(WCHAR))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            strParentPath = (LPWSTR)pbufParentPath->QueryPtr();
            wcscat(strParentPath, (LPWSTR)pboRoot->GetName(TRUE));
            strParentPath[dwParentPathLen + dwNameLen] = MD_PATH_DELIMETERW;
            strParentPath[dwNewParentPathLen - 1] = (WCHAR)'\0';
            pftTime = pboRoot->GetLastChangeTime();

            *pbLineBuf = MD_ID_OBJECT;

            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                pbLineBuf,
                                pbrNextPtr,
                                1,
                                FALSE);

            if (SUCCEEDED(hresReturn)) {
                hresReturn = WriteLine(hFileHandle,
                                    dwWriteBufSize,
                                    pbWriteBuf,
                                    (PBYTE)pftTime,
                                    pbrNextPtr,
                                    sizeof(FILETIME),
                                    FALSE);
            }

            if (SUCCEEDED(hresReturn)) {
                hresReturn = WriteLine(hFileHandle,
                                    dwWriteBufSize,
                                    pbWriteBuf,
                                    (PBYTE) strParentPath,
                                    pbrNextPtr,
                                    (dwNewParentPathLen) * sizeof(WCHAR),
                                    TRUE);
            }

            if (SUCCEEDED(hresReturn)) {

                for(dwEnumObjectIndex=0,dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
                    (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                    dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
                    hresReturn = SaveDataObject(hFileHandle,
                                             dataAssociatedData,
                                             pbLineBuf,
                                             dwWriteBufSize,
                                             pbWriteBuf,
                                             pbrNextPtr,
                                             pCryptoStorage);
                }

                for(dwEnumObjectIndex=0,objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++);
                    (SUCCEEDED(hresReturn)) && (objChildObject!=NULL);
                    objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++)) {
                    hresReturn = SaveTree(hFileHandle,
                                       objChildObject,
                                       pbLineBuf,
                                       pbufParentPath,
                                       dwWriteBufSize,
                                       pbWriteBuf,
                                       pbrNextPtr,
                                       pCryptoStorage);
                }
            }

            //
            // Buffer may have changed, so don't use strParentPath
            //
            ((LPWSTR)pbufParentPath->QueryPtr())[dwParentPathLen] = (WCHAR)'\0';
        }
    }

    return(hresReturn);
}

HRESULT
SaveAllData(
         IN BOOL bSetSaveDisallowed,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
         IN METADATA_HANDLE hHandle,
         IN BOOL bHaveReadSaveSemaphore
         )
/*++

Routine Description:

    Saves all meta data.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    PBYTE pbLineBuf = NULL;
    PBYTE pbWriteBuf = NULL;
    PBYTE pbNextPtr = NULL;
    BUFFER *pbufParentPath = new BUFFER(0);
    LPTSTR strTempFileName = g_strTempFileName->QueryStr();
    LPTSTR strRealFileName = g_strRealFileName->QueryStr();
    LPTSTR strBackupFileName = g_strBackupFileName->QueryStr();
    DWORD  dwWriteBufSize = READWRITE_BUFFER_LENGTH;
    HANDLE hTempFileHandle;
    CMDBaseObject *objChildObject;
    DWORD dwEnumObjectIndex;
    DWORD dwStringLen;
    BOOL bDeleteTemp = TRUE;
    DWORD dwTemp = ERROR_SUCCESS;
    DWORD dwTempLastSaveChangeNumber;
    BOOL  bSaveNeeded = FALSE;

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }
    if (!g_bSaveDisallowed) {
        g_bSaveDisallowed = bSetSaveDisallowed;
        pbLineBuf = new BYTE[MAX_RECORD_BUFFER];
        for ((pbWriteBuf = new BYTE[dwWriteBufSize]);
            (pbWriteBuf == NULL) && ((dwWriteBufSize/=2) >= MAX_RECORD_BUFFER);
            pbWriteBuf = new BYTE[dwWriteBufSize]) {
        }
        if ((pbWriteBuf == NULL) || (pbLineBuf == NULL)
            || (pbufParentPath == NULL) || (!pbufParentPath->Resize(MD_MAX_PATH_LEN))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            //
            // Write to a temp file first in case there are errors.
            //

            SECURITY_ATTRIBUTES saStorage;
            PSECURITY_ATTRIBUTES psaStorage = NULL;

            if (g_psdStorage != NULL) {
                saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
                saStorage.lpSecurityDescriptor = g_psdStorage;
                saStorage.bInheritHandle = FALSE;
                psaStorage = &saStorage;
            }

            hTempFileHandle = CreateFile(strTempFileName,
                                         GENERIC_READ | GENERIC_WRITE,
                                         0,
                                         psaStorage,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                         0);
            if (hTempFileHandle == INVALID_HANDLE_VALUE) {
                DWORD dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
            }
            else {
                g_rMasterResource->Lock(TSRES_LOCK_READ);

                //
                // Only Save if changes have been made since the last save.
                //

                if (g_dwLastSaveChangeNumber != g_dwSystemChangeNumber) {

                    //
                    //
                    //

                    bSaveNeeded = TRUE;

                    if (hHandle != METADATA_MASTER_ROOT_HANDLE) {
                        CMDHandle *phoHandle;
                        phoHandle = GetHandleObject(hHandle);
                        if ((phoHandle == NULL) || (phoHandle->GetObject() != g_pboMasterRoot)) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
                        }
                        else if ((!phoHandle->IsReadAllowed()) && (!phoHandle->IsWriteAllowed())) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_ACCESS_DENIED);
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {
                        *(LPWSTR)pbufParentPath->QueryPtr() = MD_PATH_DELIMETERW;
                        ((LPWSTR)pbufParentPath->QueryPtr())[1] = (WCHAR)'\0';
                        pbNextPtr = pbWriteBuf;
                        hresReturn = WriteLine(hTempFileHandle,
                                            dwWriteBufSize,
                                            pbWriteBuf,
                                            (PBYTE) MD_SIGNATURE_STRINGW,
                                            pbNextPtr,
                                            sizeof(MD_SIGNATURE_STRINGW),
                                            TRUE);
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf = MD_ID_MAJOR_VERSION_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwMajorVersionNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf = MD_ID_MINOR_VERSION_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwMinorVersionNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf =  MD_ID_CHANGE_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwSystemChangeNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            //
                            // Write the session key blob to the file.
                            //
                            *pbLineBuf =  MD_ID_SESSION_KEY;
                            memcpy((PCHAR)pbLineBuf+1, (PCHAR)pSessionKeyBlob, IISCryptoGetBlobLength(pSessionKeyBlob));
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + IISCryptoGetBlobLength(pSessionKeyBlob),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SaveMasterRoot(hTempFileHandle,
                                                     pbLineBuf,
                                                     dwWriteBufSize,
                                                     pbWriteBuf,
                                                     pbNextPtr,
                                                     pCryptoStorage);

                            for(dwEnumObjectIndex=0,objChildObject=g_pboMasterRoot->EnumChildObject(dwEnumObjectIndex++);
                                (SUCCEEDED(hresReturn)) && (objChildObject!=NULL);
                                objChildObject=g_pboMasterRoot->EnumChildObject(dwEnumObjectIndex++)) {
                                hresReturn = SaveTree(hTempFileHandle,
                                                   objChildObject,
                                                   pbLineBuf,
                                                   pbufParentPath,
                                                   dwWriteBufSize,
                                                   pbWriteBuf,
                                                   pbNextPtr,
                                                   pCryptoStorage);
                            }
                        }
                    }

                    //
                    // Must have MasterResource when accessing SystemChangeNumber
                    // so save it away here. Only update LastSaveChangeNumber on success.
                    //

                    dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;

                }

                //
                // Release lock before writing to file.
                //

                g_rMasterResource->Unlock();

                if (bSaveNeeded && SUCCEEDED(hresReturn)) {

                    hresReturn = FlushWriteBuf(hTempFileHandle,
                                           pbWriteBuf,
                                           pbNextPtr);
                }

                //
                // Always close the file handle
                //

                if (!CloseHandle(hTempFileHandle)) {
                    hresReturn = GetLastError();
                }

            }
            if (SUCCEEDED(hresReturn) && bSaveNeeded) {
                printf("Write Metabase.\n");
                //
                // New data file created successfully
                // Backup real file and copy temp
                // to real
                //
                if (!MoveFile(strTempFileName, strRealFileName)) {
                    if (GetLastError() != ERROR_ALREADY_EXISTS) {
                        dwTemp = GetLastError();
                        hresReturn = RETURNCODETOHRESULT(dwTemp);
                    }
                    //
                    // Real File exists, so back it up
                    //
                    else if (!MoveFile(strRealFileName, strBackupFileName)) {
                        //
                        // backup failed, check for old backup file
                        //
                        if (GetLastError() != ERROR_ALREADY_EXISTS) {
                            dwTemp = GetLastError();
                        }
                        else if (!DeleteFile(strBackupFileName)) {
                            dwTemp = GetLastError();
                        }
                        else if (!MoveFile(strRealFileName, strBackupFileName)) {
                            dwTemp = GetLastError();
                        }
                        hresReturn = RETURNCODETOHRESULT(dwTemp);
                    }
                    if (SUCCEEDED(hresReturn)) {
                        BOOL bDeleteBackup = TRUE;
                        //
                        // Real file is backed up
                        // so move in new file
                        //
                        if (!MoveFile(strTempFileName, strRealFileName)) {
                            dwTemp = GetLastError();
                            hresReturn = RETURNCODETOHRESULT(dwTemp);
                            //
                            // Moved real to backup but
                            // failed to move temp to real
                            // so restore from backup
                            //
                            if (!MoveFile(strBackupFileName, strRealFileName)) {
                                //
                                // Unable to write new file
                                // or restore original file so don't delete backup
                                //
                                bDeleteBackup = FALSE;
                            }
                        }
                        if (bDeleteBackup) {
                            DeleteFile(strBackupFileName);
                        }
                    }
                    if (FAILED(hresReturn)) {
                        //
                        // temp file was created ok but a problem
                        // occurred while moving it to real
                        // so don't delete it
                        //
                        bDeleteTemp = FALSE;
                    }
                    else {

                        //
                        // Update Change Number
                        // Must have ReadSaveSemaphore when accessing this.
                        //

                        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
                    }
                }
            }
            if (bDeleteTemp && (hTempFileHandle != INVALID_HANDLE_VALUE)) {
                DeleteFile(strTempFileName);
            }
        }
    }

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if ( pbufParentPath != NULL ) {
        delete(pbufParentPath);
    }

    if ( pbWriteBuf != NULL ) {
        delete(pbWriteBuf);
    }

    if ( pbLineBuf != NULL ) {
        delete(pbLineBuf);
    }

    if ( FAILED( hresReturn )) {
        DBGPRINTF(( DBG_CONTEXT, "Failed to flush metabase - error 0x%08lx\n", hresReturn));
    } else {
        //DBGPRINTF(( DBG_CONTEXT, "Successfully flushed metabase to disk\n" ));
    }

    return hresReturn;
}

DWORD
DeleteKeyFromRegistry(HKEY hkeyParent,
                      LPTSTR pszCurrent)
/*++

Routine Description:

    Deletes a key and all data and subkeys from the registry.

    RECURSIVE ROUTINE! DO NOT USE STACK!

Arguments:

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn;
    LPTSTR pszName;

    MDRegKey *pmdrkCurrent = new MDRegKey(hkeyParent,
                                          pszCurrent);
    if (pmdrkCurrent == NULL) {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
    }
    else {
        dwReturn = GetLastError();
    }
    if (dwReturn == ERROR_SUCCESS) {
        MDRegKeyIter *pmdrkiCurrent = new MDRegKeyIter(*pmdrkCurrent);
        if (pmdrkiCurrent == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            dwReturn = GetLastError();
        }
        while ((dwReturn == ERROR_SUCCESS) &&
            (dwReturn = pmdrkiCurrent->Next(&pszName, NULL, 0)) == ERROR_SUCCESS) {
            dwReturn = DeleteKeyFromRegistry(*pmdrkCurrent,
                                              pszName);
        }
        delete (pmdrkiCurrent);
        if (dwReturn == ERROR_NO_MORE_ITEMS) {
            dwReturn = ERROR_SUCCESS;
        }
    }
    delete (pmdrkCurrent);

    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegDeleteKey(hkeyParent,
                                pszCurrent);
    }
    return dwReturn;
}

HRESULT
ReadMetaObject(
         IN CMDBaseObject *&cboRead,
         IN BUFFER *pbufLine,
         IN DWORD dwLineLen,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN BOOL bUnicode)
/*++

Routine Description:

    Read a meta object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    Read       - Place to return the created object.

    ObjectLine - The object info.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS

Notes:

--*/
{
    HRESULT hresReturn;
    CMDBaseObject *pboParent;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    FILETIME ftTime;
    PFILETIME pftParentTime;
    FILETIME ftParentTime;
    PBYTE pbLine = (PBYTE)pbufLine->QueryPtr();
    LPTSTR strObjectName;

    if ((dwLineLen <= BASEMETAOBJECTLENGTH) || (*(pbLine + dwLineLen - 1) != '\0')) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
    }
    else {
        ftTime = *(UNALIGNED FILETIME *)(pbLine + 1);
        //
        // GetObjectFromPath checks permissions on the handle
        // This only gets called from init so just tell it read.
        //
        strObjectName = (LPTSTR)(pbLine + BASEMETAOBJECTLENGTH);
        hresReturn = GetObjectFromPath(pboParent,
                                    METADATA_MASTER_ROOT_HANDLE,
                                    METADATA_PERMISSION_READ,
                                    strObjectName,
                                    bUnicode);

        //
        // This should return ERROR_PATH_NOT_FOUND and the parent object,
        // with strObjectLine set to the remainder of the path,
        // which should be the child name, without a preceding delimeter.
        //

        if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
            MD_ASSERT(pboParent != NULL);
            if (bUnicode) {
                hresReturn = ExtractNameFromPath((LPWSTR *)&strObjectName, (LPWSTR)strName);
            }
            else {
                hresReturn = ExtractNameFromPath((LPSTR)strObjectName, (LPSTR)strName);
            }
            if (SUCCEEDED(hresReturn)) {
                CMDBaseObject *pboNew;
                if (bUnicode) {
                    pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
                }
                else {
                    pboNew = new CMDBaseObject((LPSTR)strName, NULL);
                }
                if (pboNew == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else if (!pboNew->IsValid()) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    delete (pboNew);
                }
                else {
                    //
                    // InsertChildObject sets the last change time to current time.
                    // This isn't really a change, so save and restore time.
                    //
                    pftParentTime = pboParent->GetLastChangeTime();
                    ftParentTime = *pftParentTime;
                    hresReturn = pboParent->InsertChildObject(pboNew);
                    if (SUCCEEDED(hresReturn)) {
                        pboParent->SetLastChangeTime(&ftParentTime);
                        pboNew->SetLastChangeTime(&ftTime);
                        cboRead = pboNew;
                    }
                    else {
                        delete (pboNew);
                    }
                }
            }
        }
        else if (SUCCEEDED(hresReturn)) {
            hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
        }
    }
    return (hresReturn);
}

HRESULT
ReadDataObject(
         IN CMDBaseObject *cboAssociated,
         IN BUFFER *pbufLine,
         IN DWORD dwLineLen,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN BOOL bUnicode)
/*++

Routine Description:

    Read a data object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    Associated - The associated meta object.

    DataLine   - The data info.

    BinaryBuf  - Buffer to use in UUDecode.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS
                 ERROR_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    PFILETIME pftTime;
    FILETIME ftTime;
    PBYTE pbDataLine = (PBYTE)pbufLine->QueryPtr();
    PBYTE pbDataValue;
    DWORD dwDataLength;
    PIIS_CRYPTO_BLOB blob = NULL;

    if (dwLineLen < DATAOBJECTBASESIZE) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
    }
    else {
        MD_ASSERT(pbufLine->QuerySize() >= DATAOBJECTBASESIZE);
        mdrData.dwMDIdentifier = *(UNALIGNED DWORD *)(pbDataLine + 1);
        mdrData.dwMDAttributes = *(UNALIGNED DWORD *)(pbDataLine + 1 + sizeof(DWORD));
        mdrData.dwMDUserType = *(UNALIGNED DWORD *)(pbDataLine + 1 + (2 * sizeof(DWORD)));
        mdrData.dwMDDataType = *(UNALIGNED DWORD *)(pbDataLine + 1 + (3 * sizeof(DWORD)));

        pbDataValue = pbDataLine + DATAOBJECTBASESIZE;
        dwDataLength = dwLineLen - DATAOBJECTBASESIZE;

        if (IsSecureMetadata(mdrData.dwMDIdentifier, mdrData.dwMDAttributes) &&
            pCryptoStorage != NULL) {


            IIS_PRINTF((buff,"Not reading encrypted data for ID=%d\n",mdrData.dwMDIdentifier));
            hresReturn = ERROR_SUCCESS;
            //printf("Not reading encrypted data.\n");
            MyPrintf(_T("Not reading encrypted data ID=%d.\n"), mdrData.dwMDIdentifier);
            if (FALSE){
                printf("Not reading encrypted data! Hah! :-(\n");
                
                IIS_PRINTF((buff,"Hah! ID=%d\n",mdrData.dwMDIdentifier));

            //
            // This is a secure data object, we we'll need to decrypt it
            // before proceeding. Note that we must clone the blob before
            // we can actually use it, as the blob data in the line buffer
            // is not DWORD-aligned. (IISCryptoCloneBlobFromRawData() is
            // the only IISCrypto function that can handle unaligned data.)
            //

            hresReturn = ::IISCryptoCloneBlobFromRawData(
                             &blob,
                             pbDataValue,
                             dwDataLength
                             );

            if (SUCCEEDED(hresReturn)) {
                DWORD dummyRegType;

                MD_ASSERT(::IISCryptoIsValidBlob(blob));
                hresReturn = pCryptoStorage->DecryptData(
                               (PVOID *)&pbDataValue,
                               &dwDataLength,
                               &dummyRegType,
                               blob
                               );

            }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            mdrData.pbMDData = pbDataValue;

            switch (mdrData.dwMDDataType) {
                case DWORD_METADATA: {
                    if (dwDataLength != sizeof(DWORD)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                    break;
                }
                case STRING_METADATA:
                case EXPANDSZ_METADATA:
                {
                    if ((LONG)dwDataLength < 1 ||
                        (!bUnicode && (pbDataValue[dwDataLength-1] != '\0')) ||
                        (bUnicode && *(((LPWSTR)pbDataValue) + ((dwDataLength / sizeof(WCHAR)) -1)) != (WCHAR)'\0')) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                    break;
                }
                case BINARY_METADATA:
                {
                    mdrData.dwMDDataLen = dwDataLength;
                    break;
                }
                case MULTISZ_METADATA:
                {
                    if (bUnicode) {
                        if (dwDataLength < (2 * sizeof(WCHAR)) ||
                            *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-1)) != (WCHAR)'\0' ||
                            *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-2)) != (WCHAR)'\0') {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                    }
                    else {
                        if (dwDataLength < 2 ||
                            pbDataValue[dwDataLength-1] != '\0' ||
                            pbDataValue[dwDataLength-2] != '\0') {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {
                        mdrData.dwMDDataLen = dwDataLength;
                    }
                    break;
                }
                default: {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                }
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // SetDataObject sets the last change time to current time.
        // This isn't really a change, so save and restore time.
        //
        pftTime = cboAssociated->GetLastChangeTime();
        ftTime = *pftTime;
        hresReturn = cboAssociated->SetDataObject(&mdrData, bUnicode);
        cboAssociated->SetLastChangeTime(&ftTime);
    }

    if (blob != NULL) {
        ::IISCryptoFreeBlob(blob);
    }

    return(hresReturn);
}

HRESULT
FlushWriteBuf(HANDLE hWriteFileHandle,
              PBYTE pbWriteBuf,
              PBYTE &pbrNextPtr)
/*++

Routine Description:

    Flush the write buffer to the file.

Arguments:

    FileHandle - File handle to write to.

    WriteBuf   - Buffer to write to file.

    NextPtr    - Pointer past end of buffer.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwBytesWritten;
    if (pbrNextPtr > pbWriteBuf) {
        if (!WriteFile(hWriteFileHandle,
                       pbWriteBuf,
                       DIFF((BYTE *)pbrNextPtr - (BYTE *)pbWriteBuf),
                       &dwBytesWritten,
                       NULL)) {
            dwReturn = GetLastError();
        }
    }
    return (RETURNCODETOHRESULT(dwReturn));
}

BOOL
CopyLineWithEscapes(PBYTE &pbrFileBuf,
                    DWORD &dwrFileBufLen,
                    PBYTE &pbrLineBuf,
                    DWORD &dwrLineBufLen,
                    BOOL  &brMidEscape)
    //
    // CopyLineWithExcapes updates parameters.
    // SUCCESS: pbrFileBuf, dwrFileBufLen, brMidEscape
    // FAILURE: pbrLineBuf, dwrLineBufLen, brMidEscape
    // On FAILURE, it fills to the end of the buffer
    //
{
    BOOL bReturn = TRUE;
    PBYTE pbFileBufEnd = pbrFileBuf + dwrFileBufLen;
    PBYTE pbLineBufEnd = pbrLineBuf + dwrLineBufLen;
    PBYTE pbFileBufIndex = pbrFileBuf;
    PBYTE pbLineBufIndex = pbrLineBuf;

    brMidEscape = FALSE;

    while ((pbLineBufIndex < pbLineBufEnd) && (pbFileBufIndex < (pbFileBufEnd - 1))) {
        if (NEEDS_ESCAPE(*pbLineBufIndex)) {
            *pbFileBufIndex++ = MD_ESCAPE_BYTE;
        }
        *pbFileBufIndex++ = *pbLineBufIndex++;
    }
    if ((pbLineBufIndex != pbLineBufEnd) && (pbFileBufIndex < pbFileBufEnd)) {
        MD_ASSERT(pbFileBufIndex == (pbFileBufEnd - 1));
        //
        // file last byte in buffer
        //
        if (NEEDS_ESCAPE(*pbLineBufIndex)) {
            *pbFileBufIndex++ = MD_ESCAPE_BYTE;
            brMidEscape = TRUE;
        }
        else {
            *pbFileBufIndex++ = *pbLineBufIndex++;
        }
    }
    if (pbLineBufIndex != pbLineBufEnd) {
        bReturn = FALSE;
        pbrLineBuf = pbLineBufIndex;
        dwrLineBufLen = DIFF(pbLineBufEnd - pbLineBufIndex);
    }
    else {
        pbrFileBuf = pbFileBufIndex;
        dwrFileBufLen = DIFF(pbFileBufEnd - pbFileBufIndex);
    }

    return bReturn;
}


HRESULT
WriteLine(HANDLE hWriteFileHandle,
          DWORD  dwWriteBufSize,
          PBYTE  pbWriteBuf,
          PBYTE  pbLineBuf,
          PBYTE  &pbNextPtr,
          DWORD  dwLineLen,
          BOOL   bTerminate)
/*++

Routine Description:

    Write a line. Performs buffered writes to a file. Does not append \n.
    The string does not need to be terminated with \0.

Arguments:

    FileHandle - File to write to.

    WriteBufSize - Buffer size.

    WriteBuf   - Buffer to store data in.

    LineBuf    - The line buffer with data to write.

    NextPtr    - Pointer to the next unused character in WriteBuf.

    Len        - The number of characters to write.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    PBYTE pbWriteBufEnd = pbWriteBuf + dwWriteBufSize;
    DWORD dwBufferBytesLeft = DIFF(pbWriteBufEnd - pbNextPtr);
    DWORD dwBytesWritten;
    BOOL  bMidEscape;

    MD_ASSERT(pbLineBuf != NULL);
    MD_ASSERT(pbWriteBuf != NULL);
    MD_ASSERT((pbNextPtr >= pbWriteBuf) && (pbNextPtr <= pbWriteBufEnd));

    //
    // CopyLineWithExcapes updates parameters.
    // SUCCESS: pbNextPtr, dwBufferBytesLeft
    // FAILURE: pbLineBuf, dwLineLen, bMidEscape
    // On FAILURE, it fills to the end of the buffer
    //

    while ((dwReturn == ERROR_SUCCESS) &&
        (!CopyLineWithEscapes(pbNextPtr, dwBufferBytesLeft, pbLineBuf, dwLineLen, bMidEscape))) {
        if (!WriteFile(hWriteFileHandle,
                       pbWriteBuf,
                       dwWriteBufSize,
                       &dwBytesWritten,
                       NULL)) {
            dwReturn = GetLastError();
        }
        dwBufferBytesLeft = dwWriteBufSize;
        pbNextPtr = pbWriteBuf;
        if (bMidEscape) {
            *pbNextPtr++ = *pbLineBuf++;
            dwBufferBytesLeft--;
            dwLineLen--;
        }
    }
    if (bTerminate && (dwReturn == ERROR_SUCCESS)) {
        if (dwBufferBytesLeft == 0) {
            if (!WriteFile(hWriteFileHandle,
                           pbWriteBuf,
                           dwWriteBufSize,
                           &dwBytesWritten,
                           NULL)) {
                dwReturn = GetLastError();
            }
            dwBufferBytesLeft = dwWriteBufSize;
            pbNextPtr = pbWriteBuf;
        }
        *pbNextPtr++ = MD_ESCAPE_BYTE;
        dwBufferBytesLeft--;
        if (dwBufferBytesLeft == 0) {
            if (!WriteFile(hWriteFileHandle,
                           pbWriteBuf,
                           dwWriteBufSize,
                           &dwBytesWritten,
                           NULL)) {
                dwReturn = GetLastError();
            }
            dwBufferBytesLeft = dwWriteBufSize;
            pbNextPtr = pbWriteBuf;
        }
        *pbNextPtr++ = MD_TERMINATE_BYTE;
    }
    return (RETURNCODETOHRESULT(dwReturn));
}

PBYTE
FindEndOfData(PBYTE pbNextPtr,
              PBYTE pbEndReadData,
              BOOL bEscapePending)
{
    PBYTE pbIndex = pbNextPtr;
    BOOL bEndFound = FALSE;

    if ((pbEndReadData > pbIndex) && bEscapePending) {
        if (*pbIndex == MD_TERMINATE_BYTE) {
            bEndFound = TRUE;
        }
        pbIndex++;
    }
    while ((pbEndReadData -1 > pbIndex) && !bEndFound) {
        if (*pbIndex == MD_ESCAPE_BYTE) {
            pbIndex++;
            if (*pbIndex == MD_TERMINATE_BYTE) {
                bEndFound = TRUE;
            }
        }
        pbIndex++;
    }
    if (!bEndFound) {
        MD_ASSERT(pbIndex == pbEndReadData - 1);
        pbIndex++;
    }
    return pbIndex;
}

DWORD
GetLineFromBuffer(PBYTE &pbrNextPtr,
                  PBYTE &pbrEndReadData,
                  BUFFER *pbufLine,
                  DWORD &dwrLineLen,
                  BOOL &brEscapePending)
    //
    // GetLineFromBuffer modifies variables!!!!
    // SUCCESS: pbrNextPtr, pbufLine, dwrLineLen
    // FAILURE: pbrNextPtr, pbufLine, dwrLineLen, bEscapePending
    //
{
    DWORD dwReturn = ERROR_HANDLE_EOF;
    PBYTE pbLineIndex;
    DWORD dwBytesToRead;
    PBYTE pbEndReadLine;
    PBYTE pbReadDataIndex = pbrNextPtr;

    if (pbrNextPtr != pbrEndReadData) {
        //
        // first find out how many bytes we need to read
        //
        pbEndReadLine = FindEndOfData(pbrNextPtr, pbrEndReadData, brEscapePending);
        MD_ASSERT(pbEndReadLine > pbrNextPtr);

        //
        // Actual number of bytes needed may be less than the size of the data
        // but never more, so just resize for the max we might need
        //
        if (!pbufLine->Resize(dwrLineLen + DIFF(pbEndReadLine - pbrNextPtr))) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            pbLineIndex = (PBYTE)pbufLine->QueryPtr() + dwrLineLen;
            if (brEscapePending) {
                brEscapePending = FALSE;
                if (*pbReadDataIndex == MD_ESCAPE_BYTE) {
                    *pbLineIndex++ = *pbReadDataIndex++;
                }
                else {
                    MD_ASSERT(*pbReadDataIndex == MD_TERMINATE_BYTE);
                    dwReturn = ERROR_SUCCESS;
                    pbReadDataIndex++;
                }
            }
            while ((dwReturn != ERROR_SUCCESS) && (pbReadDataIndex < pbEndReadLine)) {
                if (*pbReadDataIndex != MD_ESCAPE_BYTE) {
                    *pbLineIndex++ = *pbReadDataIndex++;
                }
                else {
                    pbReadDataIndex++;
                    if (pbReadDataIndex == pbEndReadLine) {
                        brEscapePending = TRUE;
                    }
                    else {
                        if (*pbReadDataIndex == MD_ESCAPE_BYTE) {
                            *pbLineIndex++ = *pbReadDataIndex++;
                        }
                        else {
                            MD_ASSERT(*pbReadDataIndex == MD_TERMINATE_BYTE);
                            pbReadDataIndex++;
                            dwReturn = ERROR_SUCCESS;
                        }
                    }
                }
            }
            dwrLineLen = DIFF(pbLineIndex - (PBYTE)pbufLine->QueryPtr());
            pbrNextPtr = pbReadDataIndex;
        }
    }
    return dwReturn;
}

HRESULT
GetNextLine(
         IN HANDLE hReadFileHandle,
         IN OUT PBYTE &pbrEndReadData,
         IN BUFFER *pbufRead,
         IN OUT BUFFER *pbufLine,
         IN OUT DWORD &dwrLineLen,
         IN OUT PBYTE &pbrNextPtr)
/*++

Routine Description:

    Get the next line. Performs buffered reads from a file. Only pbrCurPtr may be modified between calls.
    Other variables must be set up before the first call and not changed.

Arguments:

    ReadFileHandle - File to write to.

    EndReadDataPtr - Points past the end of the data in ReadBuf.

    Read       - Buffer for file data.

    Line       - A line buffer which the returned line is stored in.

    LineLen    - The length of the data in line

    NextPtr    - On entry, pointer to the next unread character in ReadBuf.
                 On exit, pointer to the new next unread character in ReadBuf.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_INVALID_DATA
                 Return codes from file system

Notes:
    On EOF, returns ERROR_SUCCESS, dwrLineLen = 0.

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwBytesRead;
    DWORD dwLineLen = 0;
    BOOL bEscapePending = FALSE;
    DWORD dwGetLineReturn = ERROR_HANDLE_EOF;
    BOOL bEOF = FALSE;

    //
    // GetLineFromBuffer modifies variables!!!!
    // SUCCESS: pbrNextPtr, pbufLine, dwrLineLen
    // FAILURE: pbrNextPtr, pbufLine, dwrLineLen, bEscapePending
    //

    while ((dwReturn == ERROR_SUCCESS) && (dwGetLineReturn == ERROR_HANDLE_EOF) && (!bEOF)) {

        dwGetLineReturn = GetLineFromBuffer(pbrNextPtr,
                                            pbrEndReadData,
                                            pbufLine,
                                            dwLineLen,
                                            bEscapePending);

        if (dwGetLineReturn == ERROR_HANDLE_EOF) {
            if (!ReadFile(hReadFileHandle,
                          (LPVOID) pbufRead->QueryPtr(),
                          pbufRead->QuerySize(),
                          &dwBytesRead,
                          NULL)) {
                dwReturn = GetLastError();
            }
            else {
                pbrEndReadData = (BYTE *)pbufRead->QueryPtr() + dwBytesRead;
                pbrNextPtr = (PBYTE)pbufRead->QueryPtr();
                if (dwBytesRead == 0) {
                    bEOF = TRUE;
                }
            }
        }
    }
    if (bEOF) {
        MD_ASSERT(dwGetLineReturn = ERROR_HANDLE_EOF);
        dwLineLen = 0;
    }
    else if (dwGetLineReturn != ERROR_SUCCESS) {
        dwReturn = dwGetLineReturn;
    }

    dwrLineLen = dwLineLen;
    return RETURNCODETOHRESULT(dwReturn);
}

DWORD
GetLineID(
         IN OUT LPTSTR &strCurPtr)
/*++

Routine Description:

    Determines the ID of a line from the metadata file.

Arguments:

    CurPtr     - The line to ID. Updated on successful ID to point past
                 the id string.

Return Value:

    DWORD      - MD_ID_OBJECT
                 MD_ID_DATA
                 MD_ID_REFERENCE
                 MD_ID_ROOT_OBJECT
                 MD_ID_NONE

Notes:

--*/
{
    DWORD dwLineID;
    if (MD_STRNICMP(strCurPtr, MD_OBJECT_ID_STRING, ((sizeof(MD_OBJECT_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_OBJECT;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_OBJECT_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_DATA_ID_STRING, ((sizeof(MD_DATA_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_DATA;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_DATA_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_REFERENCE_ID_STRING, ((sizeof(MD_REFERENCE_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_REFERENCE;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_REFERENCE_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_ROOT_OBJECT_ID_STRING, ((sizeof(MD_ROOT_OBJECT_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_ROOT_OBJECT;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_ROOT_OBJECT_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_CHANGE_NUMBER_ID_STRING, ((sizeof(MD_CHANGE_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_CHANGE_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_CHANGE_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_MAJOR_VERSION_NUMBER_ID_STRING, ((sizeof(MD_MAJOR_VERSION_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_MAJOR_VERSION_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_MAJOR_VERSION_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_MINOR_VERSION_NUMBER_ID_STRING, ((sizeof(MD_MINOR_VERSION_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_MINOR_VERSION_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_MINOR_VERSION_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else {
        dwLineID = MD_ID_NONE;
    }
    return(dwLineID);
}

HRESULT
GetWarning(
         IN HRESULT hresWarningCode)
/*++

Routine Description:

    Converts error to warnings.

Arguments:

    WarnignCode - The error code to convert.

Return Value:

    DWORD      - MD_WARNING_PATH_NOT_FOUND
                 MD_WARNING_DUP_NAME
                 MD_WARNING_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn;
    switch (hresWarningCode) {
        case (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)):
            hresReturn = MD_WARNING_PATH_NOT_FOUND;
            break;
        case (RETURNCODETOHRESULT(ERROR_DUP_NAME)):
            hresReturn = MD_WARNING_DUP_NAME;
            break;
        case (RETURNCODETOHRESULT(ERROR_INVALID_DATA)):
            hresReturn = MD_WARNING_INVALID_DATA;
            break;
        case (RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS)):
            hresReturn = MD_WARNING_DUP_NAME;
            break;
        default:
            hresReturn = hresWarningCode;
    }
    return (hresReturn);
}

BOOL CheckDigits(LPTSTR pszString)
{
    LPTSTR pszTemp;
    BOOL bDigitFound = FALSE;
    BOOL bReturn = FALSE;
    for (pszTemp = pszString;MD_ISDIGIT(*pszTemp); pszTemp++) {
        bDigitFound = TRUE;
    }
    if (bDigitFound && (*pszTemp == (TCHAR)'\0')) {
        bReturn = TRUE;
    }
    return bReturn;
}

HRESULT
InitStorageHelper(
    PBYTE RawBlob,
    DWORD RawBlobLength,
    IIS_CRYPTO_STORAGE **NewStorage
    )
/*++

Routine Description:

    Helper routine to create and initialize a new IIS_CRYPTO_STORAGE
    object from an unaligned blob.

Arguments:

    RawBlob - Pointer to the raw unaligned session key blob.

    RawBlobLength - Length of the raw blob data.

    NewStorage - Receives a pointer to the new IIS_CRYPTO_STORAGE object
        if successful.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    PIIS_CRYPTO_BLOB alignedBlob;
    IIS_CRYPTO_STORAGE *storage = NULL;
    HRESULT hresReturn = NO_ERROR;

    //
    // Make a copy of the blob. This is necessary, as the incoming
    // raw blob pointer is most likely not DWORD-aligned.
    //

    hresReturn = ::IISCryptoCloneBlobFromRawData(
                   &alignedBlob,
                   RawBlob,
                   RawBlobLength
                   );

    if (SUCCEEDED(hresReturn)) {
        //
        // Create a new IIS_CRYPTO_STORAGE object and initialize it from
        // the DWORD-aligned blob.
        //

        storage = new IIS_CRYPTO_STORAGE();

        if (storage == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        } else {
            HCRYPTPROV hProv;

            hresReturn = GetCryptoProvider( &hProv );

            if (SUCCEEDED(hresReturn)) {
                hresReturn = storage->Initialize(
                             alignedBlob,
                             TRUE,          // fUseMachineKeyset
                             hProv
                             );
            }

            if (FAILED(hresReturn)) {
                delete storage;
                storage = NULL;
            }
        }

        ::IISCryptoFreeBlob(alignedBlob);
    }

    *NewStorage = storage;
    return hresReturn;

}   // InitStorageHelper


HRESULT
ReadAllData(BOOL bHaveReadSaveSemaphore)
/*++

Routine Description:

    Reads all meta data from a file.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresWarningCode = ERROR_SUCCESS;
    PBYTE  pbEndReadData;
    PBYTE  pbNextPtr;
    DWORD  dwLineLen;
    LPTSTR strReadFileName = g_strRealFileName->QueryStr();
    HANDLE hReadFileHandle;
    BYTE   bLineId;
    DWORD  dwTemp;
    CMDBaseObject *pboRead;
    FILETIME ftTime;
    BUFFER *pbufRead = new BUFFER(0);
    BUFFER *pbufLine = new BUFFER(0);
    IIS_CRYPTO_STORAGE *pStorage = NULL;
    BOOL bUnicode;
    DWORD dwTempLastSaveChangeNumber;

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }
    //
    // Open the file.
    //
    printf("Read Metabase.\n");
    hReadFileHandle = CreateFile(strReadFileName,
                                 GENERIC_READ,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 0);

    if (hReadFileHandle == INVALID_HANDLE_VALUE) {
        dwTemp = GetLastError();
        hresReturn = RETURNCODETOHRESULT(dwTemp);
    }
    else {
        //
        // Allocate Buffers
        //
        if (!pbufLine->Resize(MAX_RECORD_BUFFER) ||
            !pbufRead->Resize(READWRITE_BUFFER_LENGTH)) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            pbEndReadData = (PBYTE)pbufRead->QueryPtr();
            //
            // GetNextLine makes sure that the next line is in the buffer and sets strCurPtr to point to it
            // The line is NULL terminated, no new line. The variables passed in must not be modified outside
            // of GetNextLine.
            //
            dwLineLen = 0;
            pbNextPtr = pbEndReadData;
            hresReturn = GetNextLine(hReadFileHandle,
                                  pbEndReadData,
                                  pbufRead,
                                  pbufLine,
                                  dwLineLen,
                                  pbNextPtr);
            if (SUCCEEDED(hresReturn)) {
                //
                // See if it's our file
                //
                if (dwLineLen == sizeof(MD_SIGNATURE_STRINGA) &&
                    (MD_CMP(MD_SIGNATURE_STRINGA, pbufLine->QueryPtr(), dwLineLen) == 0)) {
                    bUnicode = FALSE;
                }
                else if  (dwLineLen == sizeof(MD_SIGNATURE_STRINGW) &&
                    (MD_CMP(MD_SIGNATURE_STRINGW, pbufLine->QueryPtr(), dwLineLen) == 0)) {
                    bUnicode = TRUE;
                }
                else {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                }

                if (SUCCEEDED(hresReturn)) {
                    //
                    // The first GetNextLine filled the buffer
                    // so we may not need to do any file system stuff
                    // with g_rMasterResource locked.
                    //
                    g_rMasterResource->Lock(TSRES_LOCK_WRITE);

                    while ((SUCCEEDED(hresReturn)) &&
                           (SUCCEEDED(hresReturn = GetNextLine(hReadFileHandle,
                                                   pbEndReadData,
                                                   pbufRead,
                                                   pbufLine,
                                                   dwLineLen,
                                                   pbNextPtr))) &&
                           (dwLineLen > 0) &&
                           (((bLineId = *(BYTE *)(pbufLine->QueryPtr())) == MD_ID_NONE) ||
                               (bLineId == MD_ID_MAJOR_VERSION_NUMBER) ||
                               (bLineId == MD_ID_MINOR_VERSION_NUMBER) ||
                               (bLineId == MD_ID_CHANGE_NUMBER) ||
                               (bLineId == MD_ID_SESSION_KEY))) {

                        if (bLineId != MD_ID_NONE) {
                            if (bLineId != MD_ID_SESSION_KEY &&
                                dwLineLen != (1 + sizeof(DWORD))) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                            }
                            else {
                                dwTemp = *(UNALIGNED DWORD *)FIRSTDATAPTR(pbufLine);
                                switch (bLineId) {
                                case MD_ID_MAJOR_VERSION_NUMBER:
                                    g_dwMajorVersionNumber = dwTemp;
                                    break;
                                case MD_ID_MINOR_VERSION_NUMBER:
                                    g_dwMinorVersionNumber = dwTemp;
                                    break;
                                case MD_ID_CHANGE_NUMBER:
                                    g_dwSystemChangeNumber = dwTemp;
                                    break;
                                case MD_ID_SESSION_KEY:
                                    {
                                        BOOL    fSecuredRead = TRUE;
                                        HKEY    hkRegistryKey = NULL;
                                        DWORD   dwRegReturn, dwValue,dwType,dwSize = sizeof(DWORD);


                                        // aaronl
                                        // skip thru the session key stuff!!!
                                        //
                                        hresReturn = NO_ERROR;
                                        pStorage = NULL;
                                        fSecuredRead = FALSE;


/*

                                            dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                                                     SETUP_REG_KEY,
                                                                     &hkRegistryKey);
                                            if (dwRegReturn == ERROR_SUCCESS) 
                                            {
                                                dwSize = MAX_PATH * sizeof(TCHAR);
                                                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                                                MD_UNSECUREDREAD_VALUE,
                                                                NULL,
                                                                &dwType,
                                                                (BYTE *)&dwValue,
                                                                &dwSize);
                                                if ( dwRegReturn == ERROR_SUCCESS && 
                                                     dwType == REG_DWORD &&
                                                     dwValue == 1)
                                                {
                                                    hresReturn = NO_ERROR;
                                                    pStorage = NULL;
                                                    fSecuredRead = FALSE;

                                                    DBGPRINTF(( DBG_CONTEXT,
                                                                "Temporary disabling  decryption for metabase read\n"));


                                                    // special indicator for IIS setup that we passed this point
                                                    dwValue = 2;
                                                    dwRegReturn = RegSetValueEx(hkRegistryKey,
                                                                    MD_UNSECUREDREAD_VALUE,
                                                                    0,
                                                                    REG_DWORD,
                                                                    (PBYTE)&dwValue,
                                                                    sizeof(dwValue));
                                                    if (dwRegReturn == ERROR_SUCCESS) 
                                                    {
                                                        DBGPRINTF(( DBG_CONTEXT,"Reanabling decryption after W9z upgrade\n"));
                                                    }

                                                }
                                                MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
                                            }
*/

                                        if (fSecuredRead)
                                        {
                                            if (IISCryptoIsClearTextSignature((IIS_CRYPTO_BLOB UNALIGNED *) FIRSTDATAPTR(pbufLine)))
                                            {
                                                    // call special function focibly tell that this machine has no 
                                                    // encryption enabled even if it happens to be so
                                                    // that's a special handling for French case with US locale
                                                    IISCryptoInitializeOverride (FALSE);
                                            }


                                            hresReturn = InitStorageHelper(
                                                           FIRSTDATAPTR(pbufLine),
                                                           dwLineLen-1,
                                                           &pStorage
                                                           );
                                        }
                                    }
                                    break;
                                default:
                                    MD_ASSERT(FALSE);
                                }
                            }
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {
                        //
                        // This must be the global master object
                        //
                        if ((dwLineLen != 1 + sizeof(FILETIME)) || (bLineId != MD_ID_ROOT_OBJECT)) {
                            //
                            // This file is hosed
                            //
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                        else {
                            //
                            // Got the MasterRoot Object.
                            //

                            ftTime = *(UNALIGNED FILETIME *)FIRSTDATAPTR(pbufLine);
                            g_pboMasterRoot->SetLastChangeTime(&ftTime);
                            //
                            // Read in MasterRoot Data.
                            //
                            for (hresReturn = GetNextLine(hReadFileHandle,
                                                  pbEndReadData,
                                                  pbufRead,
                                                  pbufLine,
                                                  dwLineLen,
                                                  pbNextPtr);
                                ((SUCCEEDED(hresReturn)) && (dwLineLen != 0)
                                && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                hresReturn = GetNextLine(hReadFileHandle,
                                                      pbEndReadData,
                                                      pbufRead,
                                                      pbufLine,
                                                      dwLineLen,
                                                      pbNextPtr)) {
                                if (bLineId == MD_ID_DATA) {
                                    hresReturn = ReadDataObject(g_pboMasterRoot, pbufLine, dwLineLen, pStorage, bUnicode);
                                }
                            }
                        }
                    }
                    //
                    // All of the required stuff is read in, and the next line is either
                    // NULL or the first normal object.
                    // Loop through all normal objects.
                    //
                    if (SUCCEEDED(hresReturn)) {
                        while ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)) {
                            MD_ASSERT(bLineId == MD_ID_OBJECT);
                            for (hresReturn = ReadMetaObject(pboRead,
                                                           pbufLine,
                                                           dwLineLen,
                                                           pStorage,
                                                           bUnicode);
                                (FAILED(hresReturn));
                                hresReturn = ReadMetaObject(pboRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pStorage,
                                                          bUnicode)) {
                                //
                                // This for loop normally shouldn't be executed.
                                // The purpose of the loop is to ignore problems if
                                // the object is bad.
                                //
                                if (hresReturn == RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) {
                                    //
                                    // Serious error, we're done.
                                    //
                                    break;
                                }
                                else {
                                    //
                                    // Just give a warning and go to the next object
                                    // Ignore everything until we get to the next object
                                    //
                                    hresWarningCode = hresReturn;

                                    for (hresReturn = GetNextLine(hReadFileHandle,
                                                          pbEndReadData,
                                                          pbufRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pbNextPtr);
                                        ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)
                                        && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                        hresReturn = GetNextLine(hReadFileHandle,
                                                              pbEndReadData,
                                                              pbufRead,
                                                              pbufLine,
                                                              dwLineLen,
                                                              pbNextPtr)) {

                                    }
                                    if (dwLineLen == 0) {
                                        //
                                        // EOF, we're done
                                        //
                                        break;
                                    }
                                }
                            }
                            if ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)) {
                                //
                                // Got an object.
                                // Read in data.
                                //
                                for (hresReturn = GetNextLine(hReadFileHandle,
                                                      pbEndReadData,
                                                      pbufRead,
                                                      pbufLine,
                                                      dwLineLen,
                                                      pbNextPtr);
                                    ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)
                                    //
                                    // GetLineID increments strCurPtr if a match is found
                                    //
                                    && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                    hresReturn = GetNextLine(hReadFileHandle,
                                                          pbEndReadData,
                                                          pbufRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pbNextPtr)) {
                                    if (bLineId == MD_ID_DATA) {
                                        hresReturn = ReadDataObject(pboRead,
                                                                    pbufLine,
                                                                    dwLineLen,
                                                                    pStorage,
                                                                    bUnicode);
                                        //
                                        // dwReturn gets blown away by the for loop.
                                        // Most errors we can just ignore anyway, but
                                        // save a warning.
                                        //
                                        if (FAILED(hresReturn)) {
                                            if (hresReturn != RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) {
                                                hresWarningCode = hresReturn;
                                            }
                                            else {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    //
                    // Must have MasterResource when accessing SystemChangeNumber
                    // so save it away here. Only update LastSaveChangeNumber on success.
                    //

                    dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;
                    g_rMasterResource->Unlock();
                }
            }
            if (!CloseHandle(hReadFileHandle)) {
                dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
            }
        }
    }

    
    //
    // File not found is ok
    // Start with MasterRoot only
    //
    if (hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) {
        hresReturn = ERROR_SUCCESS;
    }

    if ((SUCCEEDED(hresReturn)) && (hresWarningCode != ERROR_SUCCESS)) {
        hresReturn = GetWarning(hresWarningCode);
    }

    if (SUCCEEDED(hresReturn)) {
        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
    }

    //
    // Cleanup
    //
    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }
    delete(pbufRead);
    delete(pbufLine);
    delete(pStorage);
    return hresReturn;
}

HRESULT
InitWorker(
    IN BOOL bHaveReadSaveSemaphore
    )
{
    HRESULT hresReturn = ERROR_SUCCESS;

    g_rMasterResource->Lock(TSRES_LOCK_WRITE);
    if (g_dwInitialized++ > 0) {
        hresReturn = g_hresInitWarning;
    }
    else {
        g_pboMasterRoot = NULL;
        g_phHandleHead = NULL;
        for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
            g_phEventHandles[i] = NULL;
        }
        g_mhHandleIdentifier = METADATA_MASTER_ROOT_HANDLE;

        g_pboMasterRoot = new CMDBaseObject(MD_MASTER_ROOT_NAME);

        g_ppbdDataHashTable = NULL;
        g_dwSystemChangeNumber = 0;
        g_strRealFileName = NULL;
        g_strTempFileName = NULL;
        g_strBackupFileName = NULL;
        g_pstrBackupFilePath = NULL;

        g_psidSystem = NULL;
        g_psidAdmin = NULL;
        g_paclDiscretionary = NULL;
        g_psdStorage = NULL;

        if ((g_pboMasterRoot == NULL) || (!(g_pboMasterRoot->IsValid()))) {

            IIS_PRINTF((buff,"Unable to allocate CMDBaseObject\n"));
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            g_pboMasterRoot->SetParent(NULL);
            g_phHandleHead = new CMDHandle(g_pboMasterRoot,
                                           METADATA_PERMISSION_READ,
                                           g_dwSystemChangeNumber,
                                           g_mhHandleIdentifier++);
            if (g_phHandleHead == NULL) {
                IIS_PRINTF((buff,"Unable to allocate CMDHandle\n"));
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                g_phHandleHead->SetNextPtr(NULL);
                if( ( g_phEventHandles[EVENT_READ_INDEX] = IIS_CREATE_EVENT(
                                                               "g_phEventHandles[EVENT_READ_INDEX]",
                                                               &g_phEventHandles[EVENT_READ_INDEX],
                                                               TRUE,
                                                               FALSE
                                                               ) ) == NULL ) {
                    hresReturn = GetLastHResult();
                    IIS_PRINTF((buff,"CreateEvent Failed with %x\n",hresReturn));
                }
                else if( ( g_phEventHandles[EVENT_WRITE_INDEX] = IIS_CREATE_EVENT(
                                                                   "g_phEventHandles[EVENT_WRITE_INDEX]",
                                                                   &g_phEventHandles[EVENT_WRITE_INDEX],
                                                                   TRUE,
                                                                   FALSE
                                                                   ) ) == NULL ) {
                    hresReturn = GetLastHResult();
                    IIS_PRINTF((buff,"CreateEvent Failed with %x\n",hresReturn));
                }
                else if ((g_ppbdDataHashTable = new CMDBaseData *[DATA_HASH_TABLE_LEN]) == NULL) {
                    IIS_PRINTF((buff,"Unable to allocate CMDBaseData\n"));
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    hresReturn = InitBufferPool();
                    if (SUCCEEDED(hresReturn)) {
                        for (int i =0; i < DATA_HASH_TABLE_LEN; i++) {
                            g_ppbdDataHashTable[i] = NULL;
                        }
                        //
                        // BugBug - There is a conceiveable deadlock if ReadAllData is called
                        // with g_rMasterResource Locked, due to the semaphore used to control
                        // file access. Would like to release g_rMasterResource, but that could
                        // cause duplicate inits.
                        //

                        hresReturn = SetStorageSecurityDescriptor();
                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SetDataFile();
                            if (SUCCEEDED(hresReturn)) {
                                hresReturn = ReadAllData(bHaveReadSaveSemaphore);
                            }
//                            if ((RetCode = SetRegistryStoreValues()) == ERROR_SUCCESS) {
//                                RetCode = ReadAllDataFromRegistry();
//                            }
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if (!CheckVersionNumber()) {
                IIS_PRINTF((buff,"MD: Invalid version number\n"));
                hresReturn = MD_ERROR_INVALID_VERSION;
            }
        }

        if (FAILED(hresReturn)) {
            g_dwInitialized--;
            delete(g_pboMasterRoot);
            delete(g_phHandleHead);
            delete(g_ppbdDataHashTable);
            DeleteBufferPool();
            for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
                if (g_phEventHandles[i] != NULL) {
                    CloseHandle(g_phEventHandles[i]);
                }
            }
            ReleaseStorageSecurityDescriptor();
        }
        //
        // Save the return code.
        // Secondary init's repeat warnings.
        // If error, the next init will overwrite this.
        // So don't worry about setting this to errors.
        //
        g_hresInitWarning = hresReturn;
    }
    g_rMasterResource->Unlock();
    return hresReturn;
}

HRESULT
TerminateWorker1(
         IN BOOL bHaveReadSaveSemaphore
         )
{
    HRESULT hresReturn;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;

    hresReturn = InitStorageAndSessionKey(
                     &CryptoStorage,
                     &pSessionKeyBlob
                     );

    if( SUCCEEDED(hresReturn) ) {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        if (g_dwInitialized == 0) {
            hresReturn = MD_ERROR_NOT_INITIALIZED;
        }
        else {
            if (g_dwInitialized == 1) {
                hresReturn = SaveAllData(FALSE,
                                         &CryptoStorage,
                                         pSessionKeyBlob,
                                         METADATA_MASTER_ROOT_HANDLE,
                                         bHaveReadSaveSemaphore);
//                RetCode = SaveAllDataToRegistry();
            }
            if (SUCCEEDED(hresReturn)) {
                if (--g_dwInitialized == 0)
                    TerminateWorker();
            }
        }
        g_rMasterResource->Unlock();
        ::IISCryptoFreeBlob(pSessionKeyBlob);
    }

    return hresReturn;
}

VOID
TerminateWorker()
{
/*++

Routine Description:

    Worker routine for termination.

Arguments:

    SaveData   - If true, saves metadata.

Return Value:

    DWORD      - ERROR_SUCCESS
                 MD_ERROR_NOT_INITIALIZED
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

    If SaveData is TRUE and the save fails, the termination code is not executed
    and an error code is returned.

--*/
    CMDHandle *CurHandle, *NextHandle;
    for (CurHandle = g_phHandleHead;CurHandle!=NULL;CurHandle=NextHandle) {
        NextHandle = CurHandle->GetNextPtr();
        delete (CurHandle);
    }

    for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
        if (g_phEventHandles[i] != NULL) {
            CloseHandle(g_phEventHandles[i]);
        }
    }
    delete(g_pboMasterRoot);

    //
    // All data objects should be deleted by
    // deleting the handles and masterroot
    // but it's possible a client failed
    // to release a data by reference so
    // destroy all remaining data objects
    //

    DeleteAllRemainingDataObjects();
    ReleaseStorageSecurityDescriptor();

    delete (g_ppbdDataHashTable);
    delete(g_strRealFileName);
    delete(g_strTempFileName);
    delete(g_strBackupFileName);
    delete(g_pstrBackupFilePath);
    DeleteBufferPool();
}

HRESULT
SetStorageSecurityDescriptor()
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BOOL status;
    DWORD dwDaclSize;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PLATFORM_TYPE platformType;

    //
    // Verify that globals were initialized correctly.
    //


    MD_ASSERT(g_psidSystem == NULL);
    MD_ASSERT(g_psidAdmin == NULL);
    MD_ASSERT(g_paclDiscretionary == NULL);
    MD_ASSERT(g_psdStorage == NULL);

    //
    // Of course, we only need to do this under NT...
    //

    platformType = IISGetPlatformType();

    if( (platformType == PtNtWorkstation) || (platformType == PtNtServer ) ) {


        g_psdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (g_psdStorage == NULL) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Initialize the security descriptor.
        //

        status = InitializeSecurityDescriptor(
                     g_psdStorage,
                     SECURITY_DESCRIPTOR_REVISION
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Create the SIDs for the local system and admin group.
        //

        status = AllocateAndInitializeSid(
                     &ntAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &g_psidSystem
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }
        status=  AllocateAndInitializeSid(
                     &ntAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &g_psidAdmin
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Create the DACL containing an access-allowed ACE
        // for the local system and admin SIDs.
        //

        dwDaclSize = sizeof(ACL)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(g_psidAdmin)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(g_psidSystem)
                       - sizeof(DWORD);

        g_paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

        if( g_paclDiscretionary == NULL ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = InitializeAcl(
                     g_paclDiscretionary,
                     dwDaclSize,
                     ACL_REVISION
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     g_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     g_psidSystem
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     g_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     g_psidAdmin
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;

        }

        //
        // Set the DACL into the security descriptor.
        //

        status = SetSecurityDescriptorDacl(
                     g_psdStorage,
                     TRUE,
                     g_paclDiscretionary,
                     FALSE
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;

        }
    }

fatal:

    if (FAILED(hresReturn)) {
        ReleaseStorageSecurityDescriptor();

    }

    return hresReturn;

}

VOID
ReleaseStorageSecurityDescriptor()
{
    if( g_paclDiscretionary != NULL ) {
        LocalFree( g_paclDiscretionary );
        g_paclDiscretionary = NULL;
    }

    if( g_psidAdmin != NULL ) {
        FreeSid( g_psidAdmin );
        g_psidAdmin = NULL;

    }

    if( g_psidSystem != NULL ) {
        FreeSid( g_psidSystem );
        g_psidSystem = NULL;
    }

    if( g_psdStorage != NULL ) {
        LocalFree( g_psdStorage );
        g_psdStorage = NULL;
    }
}

HRESULT
ExtractNameFromPath(
         IN OUT LPSTR &strPath,
         OUT LPSTR strNameBuffer,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds the next name in a path.

Arguments:

    Path       - The path. Updated on success to point past the name.

    NameBuffer - The buffer to store the name.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_PATH_NOT_FOUND
                 ERROR_INVALID_NAME

Notes:

--*/
{
    LPSTR pszIndex;
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);

    MD_ASSERT(strNameBuffer != NULL);
    if (bUnicode) {
        LPWSTR wstrPath = (LPWSTR)strPath;
        hresReturn = ExtractNameFromPath(&wstrPath, (LPWSTR)strNameBuffer);
        strPath = (LPSTR) wstrPath;
    }
    else {
        if (strPath != NULL) {
            for (pszIndex = strPath;
                 ((pszIndex - strPath) < METADATA_MAX_NAME_LEN) && (*pszIndex != (TCHAR)'\0') &&
                    (*pszIndex != MD_PATH_DELIMETER) && (*pszIndex != MD_ALT_PATH_DELIMETER);
                 pszIndex = CharNextExA(CP_ACP,
                                        pszIndex,
                                        0)) {
            }
            DWORD dwStrBytes = DIFF(pszIndex - strPath);
            if ((dwStrBytes) >= METADATA_MAX_NAME_LEN) {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
            }
            else {
                MD_COPY(strNameBuffer, strPath, dwStrBytes);
                strNameBuffer[dwStrBytes] = (TCHAR)'\0';
                strPath = pszIndex;
                if (*strNameBuffer != (TCHAR)'\0') {
                    //
                    // if a non-null name
                    //
                    SKIP_PATH_DELIMETERA(strPath);
                    hresReturn = ERROR_SUCCESS;
                }
            }
        }
    }
    return (hresReturn);
}

HRESULT
ExtractNameFromPath(
         IN OUT LPWSTR *pstrPath,
         OUT LPWSTR strNameBuffer)
/*++

Routine Description:

    Finds the next name in a path.

Arguments:

    Path       - The path. Updated on success to point past the name.

    NameBuffer - The buffer to store the name.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_PATH_NOT_FOUND
                 ERROR_INVALID_NAME

Notes:

--*/
{
    int i;
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);

    MD_ASSERT(strNameBuffer != NULL);
    if (*pstrPath != NULL) {
        for (i = 0;
            (i < METADATA_MAX_NAME_LEN) && ((*pstrPath)[i] != (WCHAR)'\0') &&
                ((*pstrPath)[i] != (WCHAR)MD_PATH_DELIMETER) && ((*pstrPath)[i] != (WCHAR)MD_ALT_PATH_DELIMETER);
            i++) {
            strNameBuffer[i] = (*pstrPath)[i];
        }
        if (i == METADATA_MAX_NAME_LEN) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
        }
        else {
            strNameBuffer[i] = (WCHAR)'\0';
            *pstrPath += i;
            if (*strNameBuffer != (WCHAR)'\0') {
                //
                // if a non-null name
                //
                SKIP_PATH_DELIMETERW(*pstrPath);
                hresReturn = ERROR_SUCCESS;
            }
        }
    }
    return (hresReturn);
}

BOOL DataMatch(IN CMDBaseData *pbdExisting,
               IN PMETADATA_RECORD pmdrData,
               OUT PBOOL pbError,
               IN BOOL bUnicode)
{
/*++

Routine Description:

    Determines if a set of data maches an existing object.

Arguments:

    Existing   - The existing data object.

    Identifier - The Identifier of the data.

    Attributes - The flags for the data.
                      METADATA_INHERIT

    UserType   - The User Type for the data. User Defined.

    DataType   - The Type of the data.
                      DWORD_METADATA
                      STRING_METADATA
                      BINARY_METADATA

    DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.
                 Binary data must not exceed METADATA_MAX_BINARY_LEN bytes.
                 String data must not exceed METADATA_MAX_STRING_LEN characters,
                 include the trailing '\0'.

    Data       - Pointer to the data.


Return Value:

    BOOL       - TRUE if the data matches

Notes:

--*/
    BOOL bReturn = TRUE;
    BOOL bError = FALSE;

    if ((pmdrData->dwMDIdentifier != pbdExisting->GetIdentifier()) ||
        (pmdrData->dwMDAttributes != pbdExisting->GetAttributes()) ||
        (pmdrData->dwMDUserType != pbdExisting->GetUserType()) ||
        (pmdrData->dwMDDataType != pbdExisting->GetDataType())) {
        bReturn = FALSE;
    }
    else {
        if (pbdExisting->GetData(bUnicode) == NULL) {
            bError = TRUE;
        }
        else {
            switch(pmdrData->dwMDDataType) {
                case DWORD_METADATA: {
                    if (*(DWORD *)(pmdrData->pbMDData) != *(DWORD *)(pbdExisting->GetData())) {
                        bReturn = FALSE;
                    }
                    break;
                }
                case STRING_METADATA:
                case EXPANDSZ_METADATA:
                {
                    if (bUnicode) {
                        LPWSTR pszStringData = (LPWSTR)(pmdrData->pbMDData);
                        if (pszStringData == NULL) {
                            pszStringData = (LPWSTR)L"";
                        }
                        if (wcscmp(pszStringData, (LPWSTR)(pbdExisting->GetData(bUnicode))) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    else {
                        LPSTR pszStringData = (LPSTR)(pmdrData->pbMDData);
                        if (pszStringData == NULL) {
                            pszStringData = "";
                        }
                        if (MD_STRCMP(pszStringData, (LPSTR)(pbdExisting->GetData(bUnicode))) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    break;
                }
                case BINARY_METADATA:
                case MULTISZ_METADATA:
                {
                    if (pmdrData->dwMDDataLen != pbdExisting->GetDataLen(bUnicode)) {
                        bReturn = FALSE;
                    }
                    else {
                        if (MD_CMP(pmdrData->pbMDData, pbdExisting->GetData(bUnicode), pmdrData->dwMDDataLen) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    break;
                }
                default: {
                    bReturn = FALSE;
                }
            }
        }
    }
    *pbError = bError;
    return (bReturn);
}

VOID
DeleteDataObject(
         IN CMDBaseData *pbdDelete)
/*++

Routine Description:

    Decrements the reference count of an object and deletes it if the reference count becomes 0.

Arguments:

    Delete      - The data object to delete.

Return Value:

Notes:

--*/
{
    DWORD dwHash = DATA_HASH(pbdDelete->GetIdentifier());
    CMDBaseData *pdataIndex;

    MD_ASSERT(pbdDelete != NULL);
    if (pbdDelete->DecrementReferenceCount() == 0) {
        if (g_ppbdDataHashTable[dwHash] == pbdDelete) {
            g_ppbdDataHashTable[dwHash] = pbdDelete->GetNextPtr();
        }
        else {
            for (pdataIndex=g_ppbdDataHashTable[dwHash];
                pdataIndex->GetNextPtr() != pbdDelete;
                pdataIndex = pdataIndex->GetNextPtr()) {
            }
            pdataIndex->SetNextPtr(pbdDelete->GetNextPtr());
        }
        switch (pbdDelete->GetDataType()) {
        case DWORD_METADATA: {
            delete ((CMDDWData *) pbdDelete);
            break;
        }
        case STRING_METADATA: {
            delete ((CMDSTRData *) pbdDelete);
            break;
        }
        case BINARY_METADATA: {
            delete ((CMDBINData *) pbdDelete);
            break;
        }
        case EXPANDSZ_METADATA: {
            delete ((CMDEXSZData *) pbdDelete);
            break;
        }
        case MULTISZ_METADATA: {
            delete ((CMDMLSZData *) pbdDelete);
            break;
        }
        default: {
            MD_ASSERT(FALSE);
            delete (pbdDelete);
        }
        }
    }
}

VOID
DeleteAllRemainingDataObjects()
{
    DWORD i;
    CMDBaseData *pbdIndex;
    CMDBaseData *pbdSave;

    for (i = 0; i < DATA_HASH_TABLE_LEN; i++) {
        for (pbdIndex=g_ppbdDataHashTable[i];
            pbdIndex != NULL;
            pbdIndex = pbdSave) {
            pbdSave = pbdIndex->GetNextPtr();
            switch (pbdIndex->GetDataType()) {
            case DWORD_METADATA: {
                delete ((CMDDWData *) pbdIndex);
                break;
            }
            case STRING_METADATA: {
                delete ((CMDSTRData *) pbdIndex);
                break;
            }
            case BINARY_METADATA: {
                delete ((CMDBINData *) pbdIndex);
                break;
            }
            case EXPANDSZ_METADATA: {
                delete ((CMDEXSZData *) pbdIndex);
                break;
            }
            case MULTISZ_METADATA: {
                delete ((CMDMLSZData *) pbdIndex);
                break;
            }
            default: {
                MD_ASSERT(FALSE);
                delete (pbdIndex);
            }
            }
        }
    }
}


BOOL
ValidateData(IN PMETADATA_RECORD pmdrData,
             IN BOOL bUnicode)
/*++

Routine Description:

    Checks data values for new metadata.

Arguments:

    Data       - The data structure. All fields must be set.

        Attributes - The flags for the data.
                 METADATA_INHERIT - If set on input, inherited data will be returned.
                                    If not set on input, inherited data will not be returned.

                 METADATA_PARTIAL_PATH - If set on input, this routine will return ERROR_SUCCESS
                                    and the inherited data even if the entire path is not present.
                                    Only valid if METADATA_INHERIT is also set.

        DataType   - The Type of the data.
                 DWORD_METADATA
                 STRING_METADATA
                 BINARY_METADATA

Return Value:

    BOOL       - TRUE if the data values are valid.

Notes:
--*/
{
    BOOL bReturn = TRUE;

    if (((pmdrData->pbMDData == NULL) &&
            ((pmdrData->dwMDDataType == DWORD_METADATA) ||
                (((pmdrData->dwMDDataType == BINARY_METADATA) ||
                    (pmdrData->dwMDDataType == MULTISZ_METADATA)) &&
                        (pmdrData->dwMDDataLen > 0)))) ||
        (pmdrData->dwMDDataType <= ALL_METADATA) ||
        (pmdrData->dwMDDataType >= INVALID_END_METADATA) ||
        ((pmdrData->dwMDAttributes &
            ~(METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE | METADATA_VOLATILE | METADATA_INSERT_PATH | METADATA_LOCAL_MACHINE_ONLY))!=0) ||
        (((pmdrData->dwMDAttributes & METADATA_REFERENCE) != 0) &&
            ((pmdrData->dwMDAttributes & METADATA_INSERT_PATH) != 0)) ||
        (((pmdrData->dwMDAttributes & METADATA_INSERT_PATH) != 0) &&
            ((pmdrData->dwMDDataType == DWORD_METADATA) || (pmdrData->dwMDDataType == BINARY_METADATA)))) {
        bReturn = FALSE;
    }

    if (bReturn && (pmdrData->dwMDDataType == MULTISZ_METADATA)) {
        if (bUnicode) {
            LPWSTR pszData = (LPWSTR) pmdrData->pbMDData;
            DWORD dwDataLen = pmdrData->dwMDDataLen;
            if (dwDataLen > 0) {
                if (((dwDataLen / 2) <= 1) ||
                    (pszData[(dwDataLen / 2) - 1] != (WCHAR)'\0') ||
                    (pszData[(dwDataLen / 2) - 2] != (WCHAR)'\0')) {
                    bReturn = FALSE;
                }
            }
        }
        else {
            LPSTR pszData = (LPSTR) pmdrData->pbMDData;
            DWORD dwDataLen = pmdrData->dwMDDataLen;
            if (dwDataLen > 0) {
                if (((dwDataLen) == 1) ||
                    (pszData[(dwDataLen) - 1] != '\0') ||
                    (pszData[(dwDataLen) - 2] != '\0')) {
                    bReturn = FALSE;
                }
            }
        }
    }

    return (bReturn);
}

CMDBaseData *
MakeDataObject(IN PMETADATA_RECORD pmdrData,
               IN BOOL bUnicode)
{
/*++

Routine Description:

    Looks for a data object matching the parameters.
    If found, increments the reference count. If not found, it
    creates it.

Arguments:

    Data - The data for the new object.

        Identifier - The Identifier of the data.

        Attributes - The flags for the data.
                          METADATA_INHERIT

        UserType   - The User Type for the data. User Defined.

        DataType   - The Type of the data.
                          DWORD_METADATA
                          STRING_METADATA
                          BINARY_METADATA

        DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.

        Data       - Pointer to the data.

Return Value:

    BOOL       - TRUE if the data matches

Notes:

--*/
    CMDBaseData *pbdIndex;
    CMDBaseData *pbdReturn = NULL;
    CMDBaseData *pbdNew = NULL;
    DWORD dwHash = DATA_HASH(pmdrData->dwMDIdentifier);
    BOOL bDataMatchError = FALSE;

    for (pbdIndex = g_ppbdDataHashTable[dwHash];
        (pbdIndex != NULL) &&
        !DataMatch(pbdIndex, pmdrData, &bDataMatchError, bUnicode) &&
        !bDataMatchError;
        pbdIndex = pbdIndex->GetNextPtr()) {
    }
    if (!bDataMatchError) {
        if (pbdIndex != NULL) {
            pbdReturn = pbdIndex;
            pbdReturn->IncrementReferenceCount();
        }
        else {
            switch(pmdrData->dwMDDataType) {
                case DWORD_METADATA: {
                    pbdNew = new CMDDWData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, *(DWORD *)(pmdrData->pbMDData));
                    break;
                }
                case STRING_METADATA: {
                    pbdNew = new CMDSTRData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, (LPTSTR) (pmdrData->pbMDData), bUnicode);
                    break;
                }
                case BINARY_METADATA: {
                    pbdNew = new CMDBINData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, pmdrData->dwMDDataLen, pmdrData->pbMDData);
                    break;
                }
                case EXPANDSZ_METADATA: {
                    pbdNew = new CMDEXSZData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, (LPTSTR) (pmdrData->pbMDData), bUnicode);
                    break;
                }
                case MULTISZ_METADATA: {
                    pbdNew = new CMDMLSZData(pmdrData->dwMDIdentifier,
                                             pmdrData->dwMDAttributes,
                                             pmdrData->dwMDUserType,
                                             pmdrData->dwMDDataLen,
                                             (LPSTR)pmdrData->pbMDData,
                                             bUnicode);
                    break;
                }
                default: {
                    pbdNew = NULL;
                }
            }
            if (pbdNew != NULL) {
                if (!(pbdNew->IsValid())) {
                    delete (pbdNew);
                }
                else {
                    pbdNew->SetNextPtr(g_ppbdDataHashTable[dwHash]);
                    g_ppbdDataHashTable[dwHash] = pbdNew;
                    pbdReturn = pbdNew;
                }
            }
        }
    }
    return (pbdReturn);
}

HRESULT
GetHighestVersion(IN OUT STRAU *pstrauBackupLocation,
                  OUT DWORD *pdwVersion)
{
    long lHighestVersion = -1;
    long lVersion;
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD dwPathBytes = g_pstrBackupFilePath->QueryCB() + 1;
    DWORD dwNameBytes = pstrauBackupLocation->QueryCBA() - dwPathBytes;
    if (!pstrauBackupLocation->Append("*")) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        if (pstrauBackupLocation->QueryStrA() == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            HANDLE hFile = INVALID_HANDLE_VALUE;
            WIN32_FIND_DATA wfdFile;
            hFile = FindFirstFile(pstrauBackupLocation->QueryStrA(),
                                  &wfdFile);
            if (hFile == INVALID_HANDLE_VALUE) {
                if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                }
            }
            else {
                //
                // Process the first file
                //

                //
                // dwNameBytes could be wrong for this assert in MBCS,
                // so call MBCS strlen. Subtract 1 char for appended '*'
                //

                MD_ASSERT(MD_STRNICMP(pstrauBackupLocation->QueryStrA() + dwPathBytes,
                                      wfdFile.cFileName,
                                      MD_STRLEN(pstrauBackupLocation->QueryStrA() + dwPathBytes) - 1) == 0);
                if (CheckDigits(wfdFile.cFileName + (dwNameBytes))) {
                    //
                    // One of our files
                    //
                    lVersion = atol(wfdFile.cFileName + dwNameBytes);
                    if ((lVersion <= MD_BACKUP_MAX_VERSION) &&
                         (lVersion > lHighestVersion)) {
                        lHighestVersion = lVersion;
                    }
                }
                //
                // Process the remaining files
                //
                while (FindNextFile(hFile, &wfdFile)) {
                    MD_ASSERT(MD_STRNICMP(pstrauBackupLocation->QueryStrA() + dwPathBytes,
                                          wfdFile.cFileName,
                                          MD_STRLEN(pstrauBackupLocation->QueryStrA() + dwPathBytes) - 1) == 0);
                    if (CheckDigits(wfdFile.cFileName + dwNameBytes)) {
                        //
                        // One of our files
                        //
                        lVersion = atol(wfdFile.cFileName + dwNameBytes);
                        if ((lVersion <= MD_BACKUP_MAX_VERSION) &&
                             (lVersion > lHighestVersion)) {
                            lHighestVersion = lVersion;
                        }
                    }
                }
                FindClose(hFile);
            }
            if (SUCCEEDED(hresReturn)) {
                if (lHighestVersion == -1) {

                    //
                    // May not be an error, but need to indicate that
                    // no backups were found.
                    //

                    hresReturn = RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND);
                }
                else if (lHighestVersion <= MD_BACKUP_MAX_VERSION) {
                        *pdwVersion = lHighestVersion;
                }
                else {
                        hresReturn =  RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                }
            }
        }
        pstrauBackupLocation->SetLen(pstrauBackupLocation->QueryCCH() - 1);

    }

    return hresReturn;
}

BOOL
ValidateBackupLocation(LPSTR pszBackupLocation,
                       BOOL bUnicode)
{

    //
    // The main purpose of this routine is to make sure the user
    // is not putting in any file system controls, like .., /, etc.

    //
    // Secondarily, try to eliminate any characters that cannot be
    // used in database names
    //

    BOOL bReturn = TRUE;
    DWORD  dwStringLen;

    MD_ASSERT(pszBackupLocation != NULL);

	char *pszLocSave = setlocale(LC_CTYPE, NULL);	// Save cur locale
	setlocale(LC_CTYPE, "");						// Set sys locale
	
    //
    // strcspn doesn't have an error return, but will return
    // the index of the terminating NULL if the chars are not found
    //

    if (bUnicode) {
        dwStringLen = wcslen((LPWSTR)pszBackupLocation);
        if ((dwStringLen >= MD_BACKUP_MAX_LEN) ||
            (wcscspn((LPWSTR)pszBackupLocation, MD_BACKUP_INVALID_CHARS_W) !=
            dwStringLen)) {
            bReturn = FALSE;
        }
        else {
            LPWSTR pszIndex;
            for (pszIndex = (LPWSTR)pszBackupLocation;
                 (*pszIndex != (WCHAR)'\0') &&
                     (iswprint(*pszIndex));
                 pszIndex++) {
            }
            if (*pszIndex != (WCHAR)'\0') {
                bReturn = FALSE;

            }
        }
    }
    else {
        dwStringLen = _mbslen((PBYTE)pszBackupLocation);
        if ((dwStringLen >= MD_BACKUP_MAX_LEN) ||
            (_mbscspn((PBYTE)pszBackupLocation, (PBYTE)MD_BACKUP_INVALID_CHARS_A) !=
            dwStringLen)) {
            bReturn = FALSE;
        }
        else {
            LPSTR pszIndex;
            for (pszIndex = (LPSTR)pszBackupLocation;
                 (*pszIndex != (WCHAR)'\0') &&
                     (_ismbcprint(*pszIndex));
                     pszIndex = CharNextExA(CP_ACP,
                                            pszIndex,
                                            0)) {
            }
            if (*pszIndex != '\0') {
                bReturn = FALSE;

            }
        }
    }

	setlocale(LC_CTYPE, pszLocSave);
    return bReturn;
}

DWORD
GetBackupNameLen(LPSTR pszBackupName)

//
// Get Number of Bytes in name prior to suffix
//

{
    LPSTR pszSubString;
    LPSTR pszNextSubString;
    MD_REQUIRE((pszNextSubString = MD_STRSTR(pszBackupName, MD_BACKUP_SUFFIX)) != NULL);
    while (pszNextSubString != NULL) {

        //
        // In case the suffix happens to be part of the name
        //

        pszSubString = pszNextSubString;
        pszNextSubString = MD_STRSTR(pszSubString+(sizeof(MD_BACKUP_SUFFIX) - 1), MD_BACKUP_SUFFIX);
    }
    return DIFF(pszSubString - pszBackupName);
}

DWORD
GetBackupNameLen(LPWSTR pszBackupName)

//
// Get Number of WCHARs in name prior to version Number
//

{
    LPWSTR pszSubString;
    LPWSTR pszNextSubString;
    MD_REQUIRE((pszNextSubString = wcsstr(pszBackupName, MD_BACKUP_SUFFIXW)) != NULL);
    while (pszNextSubString != NULL) {
        pszSubString = pszNextSubString;
        pszNextSubString = wcsstr(pszSubString+((sizeof(MD_BACKUP_SUFFIXW) - 1)/ sizeof(WCHAR)),
                                  MD_BACKUP_SUFFIXW);
    }
    return DIFF(pszSubString - pszBackupName);
}

HRESULT CreateBackupFileName(IN LPSTR pszMDBackupLocation,
                             IN DWORD dwMDVersion,
                             IN BOOL  bUnicode,
                             IN OUT STRAU *pstrauBackupLocation)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszBackupLocation = pszMDBackupLocation;

    if (((dwMDVersion > MD_BACKUP_MAX_VERSION) &&
           (dwMDVersion != MD_BACKUP_NEXT_VERSION) &&
           (dwMDVersion != MD_BACKUP_HIGHEST_VERSION)) ||
        ((pszBackupLocation != NULL) &&
            !ValidateBackupLocation(pszBackupLocation, bUnicode))) {
        hresReturn = E_INVALIDARG;
    }
    else {

        if ((pszBackupLocation == NULL) ||
            (bUnicode && ((*(LPWSTR)pszBackupLocation) == (WCHAR)'\0')) ||
            (!bUnicode && ((*(LPSTR)pszBackupLocation) == (CHAR)'\0'))) {
            pszBackupLocation = MD_DEFAULT_BACKUP_LOCATION;
            bUnicode = FALSE;
        }

        if (!pstrauBackupLocation->Copy(g_pstrBackupFilePath->QueryStr())) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!pstrauBackupLocation->Append("\\")) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (bUnicode) {
                if (!pstrauBackupLocation->Append((LPWSTR)pszBackupLocation)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
            else {
                if (!pstrauBackupLocation->Append((LPSTR)pszBackupLocation)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if (!pstrauBackupLocation->Append(MD_BACKUP_SUFFIX)) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                DWORD dwVersion = dwMDVersion;
                if (dwVersion == MD_BACKUP_NEXT_VERSION) {
                    hresReturn = GetHighestVersion(pstrauBackupLocation, &dwVersion);
                    if (SUCCEEDED(hresReturn)) {
                        if (dwVersion < MD_BACKUP_MAX_VERSION) {
                            dwVersion++;
                        }
                        else {
                            hresReturn =  RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                        }
                    }
                    else if (hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) {

                        //
                        // Database doesn't exist, so new version is 0
                        //

                        dwVersion = 0;
                        hresReturn = ERROR_SUCCESS;
                    }
                }
                else if (dwVersion == MD_BACKUP_HIGHEST_VERSION) {
                    hresReturn = GetHighestVersion(pstrauBackupLocation, &dwVersion);
                }
                if (SUCCEEDED(hresReturn)) {
                    CHAR pszBuffer[MD_MAX_DWORD_STRING];
                    _ultoa((int)dwVersion, pszBuffer, 10);
                    if (!pstrauBackupLocation->Append(pszBuffer)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            //
            // Make sure the ANSI buffer is valid
            //
            if (pstrauBackupLocation->QueryStrA() == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    return hresReturn;
}

HRESULT SetBackupPath(LPSTR pszBackupPath)
{
    DWORD dwReturn = ERROR_DIRECTORY;
    DWORD dwDirectoryAttributes;

    dwDirectoryAttributes = GetFileAttributes(pszBackupPath);

    if (dwDirectoryAttributes == 0xffffffff) {
        //
        // Can't get attributes
        // Path probably doesn't exist
        //
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            dwReturn = GetLastError();
        }
        else if (!(CreateDirectory(pszBackupPath,
                                  NULL))) {
            dwReturn = GetLastError();
        }
        else {
            dwReturn = ERROR_SUCCESS;
        }
    }
    else if ((dwDirectoryAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {
        //
        // If a directory
        //
        dwReturn = ERROR_SUCCESS;
    }
    if (dwReturn == ERROR_SUCCESS) {
        //
        // Got it! Now set global variable
        //
        MD_ASSERT(g_pstrBackupFilePath == NULL);
        g_pstrBackupFilePath = new STR(pszBackupPath);
        if (g_pstrBackupFilePath == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if (!(g_pstrBackupFilePath->IsValid())) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            delete g_pstrBackupFilePath;
            g_pstrBackupFilePath = NULL;
        }
        else {
            dwReturn = ERROR_SUCCESS;
        }
    }

    return RETURNCODETOHRESULT(dwReturn);
}

HRESULT
SetGlobalDataFileValues(LPTSTR pszFileName)
{
    DWORD dwReturn = ERROR_SUCCESS;
    HANDLE hFileHandle;
    BOOL bMainFileFound = FALSE;

    hFileHandle = CreateFile(pszFileName,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             0);
    if (hFileHandle == INVALID_HANDLE_VALUE) {
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            dwReturn = GetLastError();
        }
        else {
            hFileHandle = CreateFile(pszFileName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     CREATE_NEW,
                                     FILE_ATTRIBUTE_NORMAL,
                                     0);
            if (hFileHandle == INVALID_HANDLE_VALUE) {
                dwReturn = GetLastError();
            }
            else {
                CloseHandle(hFileHandle);
                DeleteFile(pszFileName);
            }
        }
    }
    else {
        CloseHandle(hFileHandle);
        bMainFileFound = TRUE;
    }
    if (dwReturn == ERROR_SUCCESS) {
        g_strRealFileName = new STR(pszFileName);
        g_strTempFileName = new STR(pszFileName);
        if (g_strTempFileName->IsValid()) {
            g_strTempFileName->Append(MD_TEMP_DATA_FILE_EXT);
        }
        g_strBackupFileName = new STR(pszFileName);
        if (g_strBackupFileName->IsValid()) {
            g_strBackupFileName->Append(MD_BACKUP_DATA_FILE_EXT);
        }
        if (!g_strRealFileName->IsValid() || !g_strTempFileName->IsValid() ||
            !g_strBackupFileName->IsValid()) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {

            hFileHandle = CreateFile(g_strTempFileName->QueryStr(),
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     0);
            if (hFileHandle == INVALID_HANDLE_VALUE) {
                if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                    dwReturn = GetLastError();
                }
                else {
                    hFileHandle = CreateFile(g_strTempFileName->QueryStr(),
                                             GENERIC_READ | GENERIC_WRITE,
                                             0,
                                             NULL,
                                             CREATE_NEW,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0);
                    if (hFileHandle == INVALID_HANDLE_VALUE) {
                        dwReturn = GetLastError();
                    }
                    else {
                        CloseHandle(hFileHandle);
                        DeleteFile(g_strTempFileName->QueryStr());
                    }
                }
            }
            else {
                CloseHandle(hFileHandle);
            }

            if (dwReturn == ERROR_SUCCESS) {
                hFileHandle = CreateFile(g_strBackupFileName->QueryStr(),
                                         GENERIC_READ | GENERIC_WRITE,
                                         0,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_ATTRIBUTE_NORMAL,
                                         0);
                if (hFileHandle == INVALID_HANDLE_VALUE) {
                    if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                        dwReturn = GetLastError();
                    }
                    else {
                        hFileHandle = CreateFile(g_strBackupFileName->QueryStr(),
                                                 GENERIC_READ | GENERIC_WRITE,
                                                 0,
                                                 NULL,
                                                 CREATE_NEW,
                                                 FILE_ATTRIBUTE_NORMAL,
                                                 0);
                        if (hFileHandle == INVALID_HANDLE_VALUE) {
                            dwReturn = GetLastError();
                        }
                        else {
                            CloseHandle(hFileHandle);
                            DeleteFile(g_strBackupFileName->QueryStr());
                        }
                    }
                }
                else {
                    CloseHandle(hFileHandle);
                    if (!bMainFileFound) {
                        if (!MoveFile(g_strBackupFileName->QueryStr(), pszFileName)) {
                            dwReturn = GetLastError();
                        }
                    }
                }
            }
        }
        if (dwReturn != ERROR_SUCCESS) {
            delete(g_strRealFileName);
            g_strRealFileName = NULL;
            delete(g_strTempFileName);
            g_strRealFileName = NULL;
            delete(g_strBackupFileName);
            g_strRealFileName = NULL;
        }
    }
    return RETURNCODETOHRESULT(dwReturn);
}

HRESULT
SetDataFile()
{
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    TCHAR pszBuffer[MAX_PATH];
    HKEY hkRegistryKey = NULL;
    DWORD dwRegReturn;
    DWORD dwType;
    DWORD dwSize = MAX_PATH * sizeof(TCHAR);
    BOOL bAppendSlash;
    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                             ADMIN_REG_KEY,
                             &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS) {
        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                      MD_FILE_VALUE,
                                      NULL,
                                      &dwType,
                                      (BYTE *) pszBuffer,
                                      &dwSize);
        if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
            hresReturn = SetGlobalDataFileValues(pszBuffer);
        }

        MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        hkRegistryKey = NULL;

    }
    if (FAILED(hresReturn)) {
        dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                 SETUP_REG_KEY,
                                 &hkRegistryKey);
        if (dwRegReturn == ERROR_SUCCESS) {
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                          INSTALL_PATH_VALUE,
                                          NULL,
                                          &dwType,
                                          (BYTE *) pszBuffer,
                                          &dwSize);
            if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
                dwSize /= sizeof(TCHAR);
                if ((pszBuffer[dwSize-2] != (TCHAR)'/') &&
                    (pszBuffer[dwSize-2] != (TCHAR)'\\')) {
                    bAppendSlash = TRUE;
                }
                if ((dwSize + MD_STRBYTES(MD_DEFAULT_DATA_FILE_NAME) + ((bAppendSlash) ? 1 : 0)) <= MAX_PATH) {
                    if (bAppendSlash) {
                        pszBuffer[dwSize-1] = (TCHAR)'\\';
                        pszBuffer[dwSize] = (TCHAR)'\0';
                    }
                    MD_STRCAT(pszBuffer, MD_DEFAULT_DATA_FILE_NAME);
                    hresReturn = SetGlobalDataFileValues(pszBuffer);
                }
            }
            MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        }
        else {
            hresReturn = RETURNCODETOHRESULT(dwRegReturn);
        }
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // Now get the backup path.
        //
        hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                 METADATA_BACKUP_REG_KEY,
                                 &hkRegistryKey);
        if (dwRegReturn == ERROR_SUCCESS) {
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                          MD_BACKUP_PATH_VALUE,
                                          NULL,
                                          &dwType,
                                          (BYTE *) pszBuffer,
                                          &dwSize);
            if (dwRegReturn == ERROR_SUCCESS) {
                hresReturn = SetBackupPath(pszBuffer);
            }
            MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        }

        if (FAILED(hresReturn)) {
            dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                     SETUP_REG_KEY,
                                     &hkRegistryKey);
            if (dwRegReturn == ERROR_SUCCESS) {
                dwSize = MAX_PATH * sizeof(TCHAR);
                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                              INSTALL_PATH_VALUE,
                                              NULL,
                                              &dwType,
                                              (BYTE *) pszBuffer,
                                              &dwSize);
                if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
                    dwSize /= sizeof(TCHAR);
                    if ((pszBuffer[dwSize-2] != (TCHAR)'/') &&
                        (pszBuffer[dwSize-2] != (TCHAR)'\\')) {
                        bAppendSlash = TRUE;
                    }
                    if ((dwSize + MD_STRBYTES(MD_DEFAULT_DATA_FILE_NAME) + ((bAppendSlash) ? 1 : 0)) <= MAX_PATH) {
                        if (bAppendSlash) {
                            pszBuffer[dwSize-1] = (TCHAR)'\\';
                            pszBuffer[dwSize] = (TCHAR)'\0';
                        }
                        MD_STRCAT(pszBuffer, MD_DEFAULT_BACKUP_PATH_NAME);
                        hresReturn = SetBackupPath(pszBuffer);
                    }
                }
                MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
            }
            else {
                hresReturn = RETURNCODETOHRESULT(dwRegReturn);
            }
        }
    }

    return hresReturn;
}

DWORD GetObjectPath(CMDBaseObject *pboObject,
                    BUFFER *pbufPath,
                    DWORD &rdwStringLen,
                    CMDBaseObject *pboTopObject,
                    IN BOOL bUnicode)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwOldStringLen;

    MD_ASSERT(pboObject != NULL);
    if (pboObject != pboTopObject) {
        dwReturn = GetObjectPath(pboObject->GetParent(),
                                 pbufPath,
                                 rdwStringLen,
                                 pboTopObject,
                                 bUnicode);
        dwOldStringLen = rdwStringLen;
        if (pboObject->GetName(bUnicode) == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            if (bUnicode) {
                rdwStringLen += (1 + wcslen((LPWSTR)pboObject->GetName(bUnicode)));
                if (!pbufPath->Resize((rdwStringLen + 1) * sizeof(WCHAR))) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    LPWSTR lpzStringEnd = (LPWSTR)(pbufPath->QueryPtr()) + dwOldStringLen;
                    *lpzStringEnd = MD_PATH_DELIMETERW;
                    wcscpy(lpzStringEnd+1, (LPWSTR)(pboObject->GetName(bUnicode)));
                }
            }
            else {
                rdwStringLen += (1 + MD_STRBYTES(pboObject->GetName(bUnicode)));
                if (!pbufPath->Resize((rdwStringLen + 1) * sizeof(TCHAR))) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    LPTSTR lpzStringEnd = (LPTSTR)(pbufPath->QueryPtr()) + dwOldStringLen;
                    *lpzStringEnd = MD_PATH_DELIMETERA;
                    MD_STRCPY(lpzStringEnd+1, pboObject->GetName(bUnicode));
                }
            }
        }
    }
    return dwReturn;
}


HRESULT
MakeInsertPathData(STRAU *pstrauNewData,
                   LPTSTR pszPath,
                   LPTSTR pszOldData,
                   DWORD *pdwDataLen,
                   BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (bUnicode) {
        LPWSTR pszDataIndex, pszNextDataIndex;

        pstrauNewData->SetLen(0);
        for (pszDataIndex = (LPWSTR)pszOldData;
             SUCCEEDED(hresReturn) && ((pszNextDataIndex = wcsstr(pszDataIndex, MD_INSERT_PATH_STRINGW)) != NULL);
             pszDataIndex = pszNextDataIndex + ((sizeof(MD_INSERT_PATH_STRINGW) / sizeof(WCHAR)) - 1))  {
    //         *pszNextDataIndex = (TCHAR)'\0';
             if (!(pstrauNewData->Append(pszDataIndex, DIFF(pszNextDataIndex - pszDataIndex)))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
             if (!(pstrauNewData->Append((LPWSTR)pszPath))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
        }
        if (!(pstrauNewData->Append(pszDataIndex))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        *pdwDataLen = pstrauNewData->QueryCB(bUnicode) + sizeof(WCHAR);
    }
    else {
        LPTSTR pszDataIndex, pszNextDataIndex;

        pstrauNewData->SetLen(0);
        for (pszDataIndex = pszOldData;
             SUCCEEDED(hresReturn) && ((pszNextDataIndex = MD_STRSTR(pszDataIndex, MD_INSERT_PATH_STRINGA)) != NULL);
             pszDataIndex = pszNextDataIndex + ((sizeof(MD_INSERT_PATH_STRINGA) - 1)))  {
    //         *pszNextDataIndex = (TCHAR)'\0';
             if (!(pstrauNewData->Append(pszDataIndex, DIFF(pszNextDataIndex - pszDataIndex)))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
             if (!(pstrauNewData->Append(pszPath))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
        }
        if (!(pstrauNewData->Append(pszDataIndex))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        *pdwDataLen = pstrauNewData->QueryCB(bUnicode) + sizeof(CHAR);
    }
    return hresReturn;
}

HRESULT
InsertPathIntoData(BUFFER *pbufNewData,
                   STRAU *pstrData,
                   PBYTE *ppbNewData,
                   DWORD *pdwNewDataLen,
                   CMDBaseData *pbdRetrieve,
                   METADATA_HANDLE hHandle,
                   CMDBaseObject *pboDataMetaObject,
                   IN BOOL bUnicode)
{
    //
    // Need to insert path
    //
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD dwPathLen = 0;
    BUFFER bufPath;
    MD_ASSERT(GetHandleObject(hHandle) != NULL);
    CMDBaseObject *pboHandleMetaObject = (GetHandleObject(hHandle))->GetObject();

    MD_ASSERT((pbdRetrieve->GetDataType() != DWORD_METADATA) &&
        (pbdRetrieve->GetDataType() != BINARY_METADATA));

    if (pboHandleMetaObject->GetObjectLevel() > pboDataMetaObject->GetObjectLevel()) {
        hresReturn = MD_WARNING_PATH_NOT_INSERTED;
    }
    else {
        DWORD dwReturn;
        if ( (dwReturn = GetObjectPath(pboDataMetaObject,
                                       &bufPath,
                                       dwPathLen,
                                       pboHandleMetaObject,
                                       bUnicode)) != ERROR_SUCCESS) {
            hresReturn = RETURNCODETOHRESULT(dwReturn);
        }
        else if (!bufPath.Resize((dwPathLen + 2) * ((bUnicode) ? sizeof(WCHAR) : sizeof(CHAR)))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            LPTSTR pszPath;
            LPTSTR  pszOriginalData;
            DWORD dwDataLen;
            pszPath = (LPTSTR)(bufPath.QueryPtr());
            if (bUnicode) {
                ((LPWSTR)pszPath)[dwPathLen] = MD_PATH_DELIMETERW;
                ((LPWSTR)pszPath)[dwPathLen + 1] = (WCHAR)'\0';
            }
            else {
                pszPath[dwPathLen] = MD_PATH_DELIMETERA;
                pszPath[dwPathLen + 1] = (TCHAR)'\0';
            }
            //
            // If there was an error in GetData, it would have been
            // caught already.
            //
            MD_ASSERT(pbdRetrieve->GetData(bUnicode) != NULL);
            switch (pbdRetrieve->GetDataType()) {
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                {
                    hresReturn = MakeInsertPathData(pstrData,
                                             (LPTSTR)bufPath.QueryPtr(),
                                             (LPTSTR)pbdRetrieve->GetData(bUnicode),
                                             &dwDataLen,
                                             bUnicode);
                    if (SUCCEEDED(hresReturn)) {
                        //
                        // QueryStr should not fail in this instance
                        // since it was created with the same unicode flag
                        //
                        MD_ASSERT(pstrData->QueryStr(bUnicode) != NULL);
                        *ppbNewData = (PBYTE) pstrData->QueryStr(bUnicode);
                        *pdwNewDataLen = dwDataLen;
                    }
                }
                break;
            case MULTISZ_METADATA:
                {
                    if (bUnicode) {
                        LPWSTR pszDataIndex;
                        DWORD dwStringBytes;
                        dwDataLen = 0;
                        //
                        // Loop through all strings
                        //
                        for (pszDataIndex = (LPWSTR)pbdRetrieve->GetData(bUnicode);
                             SUCCEEDED(hresReturn) && (*pszDataIndex != (WCHAR)'\0');
                             pszDataIndex += (wcslen(pszDataIndex) + 1)) {
                            hresReturn = MakeInsertPathData(pstrData,
                                                            (LPSTR)bufPath.QueryPtr(),
                                                            (LPSTR)pszDataIndex,
                                                            &dwStringBytes,
                                                            bUnicode);
                            if (SUCCEEDED(hresReturn)) {
                                if (!pbufNewData->Resize(dwDataLen + dwStringBytes)) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    //
                                    // QueryStr should not fail in this instance
                                    // since it was created with the same unicode flag
                                    //
                                    MD_ASSERT(pstrData->QueryStr(bUnicode) != NULL);
                                    MD_COPY((PBYTE)(pbufNewData->QueryPtr()) + dwDataLen,
                                            pstrData->QueryStr(bUnicode),
                                            dwStringBytes);
                                    dwDataLen += dwStringBytes;
                                }
                            }
                        }
                        if (SUCCEEDED(hresReturn)) {
                            dwDataLen += sizeof(WCHAR);
                            if (!pbufNewData->Resize(dwDataLen)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            }
                            else {
                                *ppbNewData = (PBYTE)(pbufNewData->QueryPtr());
                                *(((LPWSTR)(*ppbNewData)) + ((dwDataLen / sizeof(WCHAR)) - 1)) = (WCHAR)'\0';
                                *pdwNewDataLen = dwDataLen;
                            }
                        }
                    }
                    else {
                        LPSTR pszDataIndex;
                        DWORD dwStringBytes;
                        dwDataLen = 0;
                        //
                        // Loop through all strings
                        //
                        for (pszDataIndex = (LPTSTR)pbdRetrieve->GetData(bUnicode);
                             SUCCEEDED(hresReturn) && (*pszDataIndex != (CHAR)'\0');
                             pszDataIndex += (MD_STRBYTES(pszDataIndex) + 1)) {
                            hresReturn = MakeInsertPathData(pstrData,
                                                     (LPTSTR)bufPath.QueryPtr(),
                                                     pszDataIndex,
                                                     &dwStringBytes);
                            if (SUCCEEDED(hresReturn)) {
                                if (!pbufNewData->Resize(dwDataLen + dwStringBytes)) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    //
                                    // QueryStr should not fail in this instance
                                    // since it was created with the same unicode flag
                                    //
                                    MD_ASSERT(pstrData->QueryStrA() != NULL);
                                    MD_COPY((PBYTE)(pbufNewData->QueryPtr()) + dwDataLen, pstrData->QueryStrA(), dwStringBytes);
                                    dwDataLen += dwStringBytes;
                                }
                            }
                        }
                        if (SUCCEEDED(hresReturn)) {
                            dwDataLen += sizeof(TCHAR);
                            if (!pbufNewData->Resize(dwDataLen)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            }
                            else {
                                *ppbNewData = (PBYTE)(pbufNewData->QueryPtr());
                                *(*ppbNewData + (dwDataLen-1)) = (CHAR)'\0';
                                *pdwNewDataLen = dwDataLen;
                            }
                        }
                    }
                }
                break;
            default:
                MD_ASSERT(FALSE);
            }
        }
    }
    return hresReturn;
}

HRESULT
MakeTreeCopyWithPath(CMDBaseObject *pboSource,
                     CMDBaseObject *&rpboNew,
                     LPSTR pszPath,
                     IN BOOL bUnicode)
{
    WCHAR pszName[METADATA_MAX_NAME_LEN];
    LPSTR pszTempPath = pszPath;
    CMDBaseObject *pboNew = NULL;
    CMDBaseObject *pboParent = NULL;
    CMDBaseObject *pboTree = NULL;
    CMDBaseObject *pboRoot = NULL;
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresExtractReturn;

    while ((SUCCEEDED(hresReturn)) &&
        (SUCCEEDED(hresExtractReturn = ExtractNameFromPath(pszTempPath, (LPSTR)pszName, bUnicode)))) {

        if (bUnicode) {
            pboNew = new CMDBaseObject((LPWSTR)pszName);
        }
        else {
            pboNew = new CMDBaseObject((LPSTR)pszName);
        }
        if (pboNew == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!pboNew->IsValid()) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            delete (pboNew);
        }
        else {
            if (pboParent != NULL) {
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (FAILED(hresReturn)) {
                    delete pboNew;
                    pboNew = pboParent;
                }
            }
            pboParent = pboNew;
        }
    }

    if ((SUCCEEDED(hresReturn)) && (hresExtractReturn != (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)))) {
        hresReturn = hresExtractReturn;
    }

    if (SUCCEEDED(hresReturn)) {

        //
        // Don't really want the leaf object, as MakeTreeCopy will create it.
        //

        LPWSTR pszTreeName = NULL;

        if (pboNew != NULL) {
            pszTreeName = (LPWSTR)pboNew->GetName(TRUE);
            pboParent = pboNew->GetParent();
            if (pszTreeName == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (SUCCEEDED(hresReturn)) {
            hresReturn = MakeTreeCopy(pboSource, pboTree, (LPSTR)pszTreeName, TRUE);

            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT(pboTree != NULL);

                if (pboParent != NULL) {
                    MD_REQUIRE(SUCCEEDED(pboParent->RemoveChildObject(pboNew)));
                    hresReturn = pboParent->InsertChildObject(pboTree);
                    if (FAILED(hresReturn)) {
                        delete(pboTree);
                        pboTree = NULL;
                    }
                }
            }
        }
        delete(pboNew);
        pboNew = NULL;
    }

    if (FAILED(hresReturn)) {
        if (pboParent != NULL) {
            CMDBaseObject *pboTemp;
            MD_ASSERT(pboNew != NULL);
            for (pboTemp = pboParent; pboTemp->GetParent() != NULL; pboTemp = pboTemp->GetParent()) {
            }
            //
            // destructor recurses through child objects
            //
            delete pboTemp;
        }
    }
    else {
        MD_ASSERT(pboTree != NULL);
        CMDBaseObject *pboTemp;
        for (pboTemp = pboTree; pboTemp->GetParent() != NULL; pboTemp = pboTemp->GetParent()) {
        }
        rpboNew = pboTemp;
    }

    return hresReturn;
}

HRESULT
MakeTreeCopy(CMDBaseObject *pboSource,
             CMDBaseObject *&rpboNew,
             LPSTR pszName,
             IN BOOL bUnicode)
{
    CMDBaseObject *pboTemp = NULL;
    CMDBaseObject *pboOldChild, *pboNewChild;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseData *pbdCurrent;
    HRESULT hresReturn = ERROR_SUCCESS;

    if (pszName == NULL) {
        if ((pboSource->GetName(TRUE)) != NULL) {
            pboTemp = new CMDBaseObject((LPWSTR)(pboSource->GetName(TRUE)), NULL);
        }
    }
    else {
        if (bUnicode) {
            pboTemp = new CMDBaseObject((LPWSTR)pszName, NULL);
        }
        else {
            pboTemp = new CMDBaseObject((LPSTR)pszName, NULL);
        }
    }
    if (pboTemp == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else if (!pboTemp->IsValid()) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        delete (pboTemp);
    }
    else {
        ppvMainDataBuf = GetMainDataBuffer();
        MD_ASSERT (ppvMainDataBuf != NULL);
        dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf, 0, ALL_METADATA, ALL_METADATA, FALSE);
        for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
            pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
            MD_ASSERT(pbdCurrent != NULL);
            hresReturn = pboTemp->SetDataObject(pbdCurrent);
        }
        FreeMainDataBuffer(ppvMainDataBuf);
    }
    if (SUCCEEDED(hresReturn)) {
        i = 0;
        pboOldChild = pboSource->EnumChildObject(i);
        while ((SUCCEEDED(hresReturn)) && (pboOldChild != NULL)) {
            hresReturn = MakeTreeCopy(pboOldChild, pboNewChild, NULL, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT (pboNewChild != NULL);
                hresReturn = pboTemp->InsertChildObject(pboNewChild);
            }
            i++;
            pboOldChild = pboSource->EnumChildObject(i);
        }
    }
    if (SUCCEEDED(hresReturn)) {
        rpboNew = pboTemp;
    }
    else {
        rpboNew = NULL;
        delete(pboTemp);
    }
    return (hresReturn);
}

void
AddNewChangeData(CMDHandle *phoDestHandle,
                 CMDBaseObject *pboNew)
{
    DWORD i, dwNumDataObjects;
    CMDBaseObject *pboChild;
    CMDBaseData *pbdCurrent;

    MD_ASSERT(pboNew != NULL);

    phoDestHandle->SetChangeData(pboNew, MD_CHANGE_TYPE_ADD_OBJECT, 0);
    if ((pbdCurrent = pboNew->EnumDataObject(0, 0, ALL_METADATA, ALL_METADATA)) != NULL) {
        phoDestHandle->SetChangeData(pboNew, MD_CHANGE_TYPE_SET_DATA, pbdCurrent->GetIdentifier());
    }
    i = 0;
    pboChild = pboNew->EnumChildObject(i);
    while (pboChild != NULL) {
        AddNewChangeData(phoDestHandle, pboChild);
        i++;
        pboChild = pboNew->EnumChildObject(i);
    }
}

HRESULT
CopyTree(CMDHandle *phoDestParentHandle,
         CMDBaseObject *pboDest,
         CMDBaseObject *pboSource,
         BOOL &rbChanged)

{
    CMDBaseObject *pboOldChild, *pboNewChild;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseData *pbdCurrent;
    LPSTR pszTempName;
    HRESULT hresReturn = ERROR_SUCCESS;

    MD_ASSERT(pboDest != NULL);
    MD_ASSERT(pboSource != NULL);
    ppvMainDataBuf = GetMainDataBuffer();
    MD_ASSERT (ppvMainDataBuf != NULL);
    dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf, 0, ALL_METADATA, ALL_METADATA, FALSE);
    for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
        pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
        MD_ASSERT(pbdCurrent != NULL);
        hresReturn = pboDest->SetDataObject(pbdCurrent);
        if (SUCCEEDED(hresReturn)) {
            rbChanged = TRUE;
            phoDestParentHandle->SetChangeData(pboDest, MD_CHANGE_TYPE_SET_DATA, pbdCurrent->GetIdentifier());
        }
    }
    if (SUCCEEDED(hresReturn)) {
        i = 0;
        pboOldChild = pboSource->EnumChildObject(i);
        while ((SUCCEEDED(hresReturn)) && (pboOldChild != NULL)) {
            pszTempName = (pboOldChild->GetName(TRUE));
            if (pszTempName == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                pboNewChild = pboDest->GetChildObject(pszTempName, &hresReturn, TRUE);
                if (SUCCEEDED(hresReturn)) {
                    if (pboNewChild != NULL) {
                        hresReturn = CopyTree(phoDestParentHandle, pboNewChild, pboOldChild, rbChanged);
                    }
                    else {
                        hresReturn = MakeTreeCopy(pboOldChild, pboNewChild);
                        if (SUCCEEDED(hresReturn)) {
                            MD_ASSERT (pboNewChild != NULL);
                            hresReturn = pboDest->InsertChildObject(pboNewChild);
                            if (SUCCEEDED(hresReturn)) {
                                rbChanged = TRUE;
                                AddNewChangeData(phoDestParentHandle, pboNewChild);
                            }
                            else {
                                delete(pboNewChild);
                            }
                        }
                    }
                    i++;
                    pboOldChild = pboSource->EnumChildObject(i);
                }
            }
        }
    }
    FreeMainDataBuffer(ppvMainDataBuf);
    return (hresReturn);
}

BOOL
CheckVersionNumber()
{
    BOOL bReturn = TRUE;

    MyPrintf(_T("Metabase Version:%d.%d.\n"), g_dwMajorVersionNumber, g_dwMinorVersionNumber);

    if (g_dwMajorVersionNumber >= 1) 
    {
        bReturn = TRUE;
    }

    return bReturn;
}

HRESULT
InitStorageAndSessionKey(
    IN IIS_CRYPTO_STORAGE *pCryptoStorage,
    OUT PIIS_CRYPTO_BLOB *ppSessionKeyBlob
    )
{
    HRESULT hresReturn;
    HCRYPTPROV hProv;

    //
    // Get a handle to the crypto provider, init the storage object,
    // then export the session key blob.
    //

    hresReturn = GetCryptoProvider( &hProv );

    if( SUCCEEDED(hresReturn) ) {
        hresReturn = pCryptoStorage->Initialize(
                         TRUE,                          // fUseMachineKeyset
                         hProv
                         );
    }

    if( SUCCEEDED(hresReturn) ) {
        hresReturn = pCryptoStorage->GetSessionKeyBlob( ppSessionKeyBlob );
    }

    return hresReturn;

}   // InitStorageAndSessionKey


VOID
SkipPathDelimeter(IN OUT LPSTR &rpszPath,
                    IN BOOL bUnicode)
{
    if (bUnicode) {
        LPWSTR pszPath = (LPWSTR)rpszPath;
        SKIP_PATH_DELIMETERW(pszPath);
        rpszPath = (LPSTR)pszPath;
    }
    else {
        SKIP_PATH_DELIMETERA(rpszPath);
    }
}

BOOL
IsStringTerminator(IN LPTSTR pszString,
                   IN BOOL bUnicode)
{
    if (bUnicode) {
        if (*(LPWSTR)pszString == (WCHAR)'\0') {
            return TRUE;
        }
    }
    else {
        if (*(LPSTR)pszString == (CHAR)'\0') {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT
GetLastHResult() {
    DWORD tmp = GetLastError();
    return RETURNCODETOHRESULT(tmp);
}


HRESULT STDMETHODCALLTYPE  BackupCertificates (LPCWSTR  backupName,PCHAR lpszToPath,PCHAR lpszFromPath)
{
    HRESULT             hresReturn = ERROR_SUCCESS;
    CHAR                *p1,*p2;
    LPSTR               searchMask = "*.mp";
    LPSTR               backupNameSeparator = ".";
    CHAR                strSourcePath[MAX_PATH];
    CHAR                strSearchPattern[MAX_PATH];
    CHAR                strDestPath[MAX_PATH];
    DWORD               dwLenOfBackupName, n1;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FileInfo; 
    BOOL                fFoundFile = TRUE, fValid;
    STRAU               strSrcFileName, strDestFileName;
        
    dwLenOfBackupName = wcslen (backupName) * sizeof (WCHAR);
    p1 = strrchr (lpszFromPath,'\\');
    p2 = strrchr (lpszToPath,'\\');
    if (p1 &&p2)
    {
        n1 = min (MAX_PATH-1, DIFF(p1 - lpszFromPath)+1);
        strncpy (strSourcePath,lpszFromPath,n1);
        strSourcePath[n1] = 0;
        strcpy (strSearchPattern,strSourcePath);
        
        n1 = min (MAX_PATH-1, DIFF(p2 - lpszToPath)+1);
        strncpy (strDestPath,lpszToPath,n1);
        strDestPath[n1] = 0;
        
        if (strlen (strSourcePath) +  strlen(searchMask) < MAX_PATH)
        {
            strcat (strSearchPattern,searchMask);
            hFindFile = FindFirstFile( strSearchPattern, &FileInfo);
            
            if (hFindFile == INVALID_HANDLE_VALUE)
            {
                // no certificate file found
                return ERROR_SUCCESS;
            }
            
            while (fFoundFile)
            {
                if ( strlen (FileInfo.cFileName) + strlen (strDestPath) + dwLenOfBackupName + 1 < MAX_PATH)
                {
                    
                    fValid = strSrcFileName.Copy (strSourcePath);
                    fValid = fValid && strSrcFileName.Append (FileInfo.cFileName);
                    
                    fValid = fValid && strDestFileName.Copy (strDestPath);
                    fValid = fValid && strDestFileName.Append ((LPWSTR)backupName);
                    fValid = fValid && strDestFileName.Append (backupNameSeparator);
                    fValid = fValid && strDestFileName.Append (FileInfo.cFileName);
                    
                    if (fValid)
                    {
                        if (!CopyFileW (strSrcFileName.QueryStrW(),strDestFileName.QueryStrW(),FALSE))
                        {
                            IIS_PRINTF((buff,"CertificateBackup: CopyFileW error 0x%0X \n",GetLastError()));                            
                        }
                    }
                    else
                    {
                        IIS_PRINTF((buff,"CertificateBackup: Failure in STRAU manipulation \n"));                            
                    }
                    
                }
                
                fFoundFile = FindNextFile(hFindFile,&FileInfo);
            }
            fFoundFile = FindClose (hFindFile);
            MD_ASSERT (fFoundFile);
        }
        else
        {
            IIS_PRINTF((buff,"CertificateBackup: strSourcePath filename was too long\n"));                            
        }
    }
    else
    {
        IIS_PRINTF((buff,"CertificateBackup: can't find last back slash in one of these strings %s %s\n",lpszToPath,lpszFromPath));                            
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE  RestoreCertificates (LPCWSTR  backupName,PCHAR lpszFromPath,PCHAR lpszToPath)
{
    HRESULT             hresReturn = ERROR_SUCCESS;
    DWORD               n1;
    CHAR                strDestinationPath[MAX_PATH];
    CHAR                strSourcePath[MAX_PATH];
    CHAR                *p1,*p2;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    BOOL                fFoundFile = TRUE, fValid;
    STRAU               strSearchPatttern, strDestFileName, strSrcFileName;
    WIN32_FIND_DATAW    FileInfo; 
    
    
    
    p1 = strrchr (lpszToPath,'\\');
    p2 = strrchr (lpszFromPath,'\\');
    
    
    if (p1 &&p2)
    {
        
        n1 = min (MAX_PATH-1, DIFF(p1 - lpszToPath)+1);
        strncpy (strDestinationPath,lpszToPath,n1);
        strDestinationPath[n1] = 0;
        
        n1 = min (MAX_PATH-1, DIFF(p2 - lpszFromPath)+1);
        strncpy (strSourcePath,lpszFromPath,n1);
        strSourcePath[n1] = 0;
        
        
        strSearchPatttern.Copy (strSourcePath);
        strSearchPatttern.Append ((LPWSTR)backupName);
        strSearchPatttern.Append ((LPWSTR)L".*.mp");
        
        
        hFindFile = FindFirstFileW( strSearchPatttern.QueryStrW(), &FileInfo);
        
        if (hFindFile == INVALID_HANDLE_VALUE)
        {
            // no certificate file found
            return ERROR_SUCCESS;
        }
        
        while (fFoundFile)
        {
            fValid = strDestFileName.Copy (strDestinationPath);
            fValid = fValid && strDestFileName.Append ((LPWSTR)(FileInfo.cFileName + wcslen (backupName) +1));
            
            fValid = fValid && strSrcFileName.Copy (strSourcePath);
            fValid = fValid && strSrcFileName.Append ((LPWSTR)FileInfo.cFileName);
            
            if (fValid)
            {
                if (!CopyFileW (strSrcFileName.QueryStrW(),strDestFileName.QueryStrW(),FALSE))
                {
                    IIS_PRINTF((buff,"CertificateBackup: CopyFileW error 0x%0X \n",GetLastError()));                            
                }
            }
            else
            {
                IIS_PRINTF((buff,"CertificateBackup: Failure in STRAU manipulation \n"));                            
            }
            
            fFoundFile = FindNextFileW(hFindFile,&FileInfo);
        }
        fFoundFile = FindClose (hFindFile);
        MD_ASSERT (fFoundFile);
    }
    else
    {
        IIS_PRINTF((buff,"CertificateRestore: can't find last back slash in one of these strings %s %s\n",lpszToPath,lpszFromPath));                            
    }
    
    return hresReturn;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\main.cpp ===
#include "main.h"
#include <mdcommon.hxx>

#pragma hdrstop


typedef struct _MDEntry {
    LPTSTR szMDPath;
    DWORD dwMDIdentifier;
    DWORD dwMDAttributes;
    DWORD dwMDUserType;
    DWORD dwMDDataType;
    DWORD dwMDDataLen;
    LPBYTE pbMDData;
} MDEntry;



int g_Flag_u = FALSE;
int g_Flag_r = FALSE;
int g_Flag_f = FALSE;
int g_Flag_v = FALSE;
int g_GlobalReturnForBatchFile = 0;

int   __cdecl main(int ,char *argv[]);
void  ShowHelp();
DWORD SetAdminACL(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount);
DWORD WriteIISComputer(void);
DWORD WriteToMD_IIsWebService_WWW(void);
BOOL  StripMetabase(void);
BOOL  DisplayMetabaseVersion(void);

//-------------------------------------------------------------------
//  purpose: main
//-------------------------------------------------------------------
int __cdecl main(int argc,char *argv[])
{
	LPSTR pArg = NULL;
	LPSTR pCmdStart = NULL;

    int argno;
    int nflags=0;
	char szTempFileName[MAX_PATH];
	szTempFileName[0] = '\0';

    //printf("Start.\n");

    // process command line arguments
    for(argno=1; argno<argc; argno++)
        {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' )
            {
            nflags++;
            switch (argv[argno][1])
                {
                case 'u':
				case 'U':
					g_Flag_u = TRUE;
					break;
                case 'r':
				case 'R':
					g_Flag_r = TRUE;
                    break;
                case 'f':
				case 'F':
					g_Flag_f = TRUE;
                    break;
                case 'v':
                case 'V':
                    g_Flag_v = TRUE;
                    break;
                case '?':
                    goto main_exit_with_help;
                    break;
                }
            } // if switch character found
        else
            {
            if ( *szTempFileName == '\0' )
                {
                // if no arguments, then
                // get the ini_filename_dir and put it into
                strcpy(szTempFileName, argv[argno]);
                }
            } // non-switch char found
        } // for all arguments

    g_GlobalReturnForBatchFile = 0;

    if (!g_Flag_u && !g_Flag_r && !g_Flag_f && !g_Flag_v)
    {
        g_GlobalReturnForBatchFile++;
        goto main_exit_with_help;
    }

    if (g_Flag_v && g_Flag_u)
    {
        // the g_flag_u will show the version,
        // so we don't have to do both...
    }
    else
    {
        if (g_Flag_v)
        {
            if (FALSE == StopServiceAndDependencies("IISADMIN", FALSE))
            {
                printf("Unable to stop service:IISADMIN\n");
            }
            else
            {
                if (FALSE == DisplayMetabaseVersion())
                    {g_GlobalReturnForBatchFile++;}
            }
        }
    }

    if (g_Flag_u)
    {
        if (FALSE == StopServiceAndDependencies("IISADMIN", FALSE))
        {
            printf("Unable to stop service:IISADMIN\n");
        }
        else
        {
            if (FALSE == StripMetabase())
                {g_GlobalReturnForBatchFile++;}
        }
    }

    if (g_Flag_r)
    {
        printf("Set ACL on '/'.\n");
        if (ERROR_SUCCESS != SetAdminACL(_T(""), (MD_ACR_READ | MD_ACR_ENUM_KEYS)))
            {g_GlobalReturnForBatchFile++;}
       
        printf("Set ACL on 'LM/W3SVC/Info'.\n");
        if (ERROR_SUCCESS != SetAdminACL(_T("LM/W3SVC/Info"), (MD_ACR_READ | MD_ACR_ENUM_KEYS)))
            {g_GlobalReturnForBatchFile++;}
        
        printf("Set ACL on 'LM/MSFTPSVC/Info'.\n");
        if (ERROR_SUCCESS != SetAdminACL(_T("LM/MSFTPSVC/Info"), (MD_ACR_READ | MD_ACR_ENUM_KEYS)))
            {g_GlobalReturnForBatchFile++;}
    }

    if (g_Flag_f)
    {
        WriteIISComputer();

        printf("Saving Metabase.\n");
        CMDKey cmdKey;
        if (ERROR_SUCCESS != cmdKey.ForceWriteMetabaseToDisk())
            {g_GlobalReturnForBatchFile++;}
    }

	goto main_exit_gracefully;
	
main_exit_gracefully:
    //printf("Done.\n");
    return g_GlobalReturnForBatchFile;

main_exit_with_help:
    ShowHelp();
    return g_GlobalReturnForBatchFile;
}

void MyPrintf(TCHAR *pszfmt, ...)
{
    TCHAR acsString[1000];

    __try
    {
        va_list va;
        va_start(va, pszfmt);
        _vstprintf(acsString, pszfmt, va);
        va_end(va);
        _tprintf(acsString);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TCHAR szErrorString[100];
        _stprintf(szErrorString, _T("\r\n\r\nException Caught in MyPrintf().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
        _tprintf(szErrorString);
    }
}


void ShowHelp()
{
	TCHAR szModuleName[_MAX_PATH];
	TCHAR szFilename_only[_MAX_FNAME];
	TCHAR szMyString[_MAX_PATH + _MAX_PATH];
	GetModuleFileName(NULL, szModuleName, _MAX_PATH);

	// Trim off the filename only.
	_tsplitpath(szModuleName, NULL, NULL, szFilename_only, NULL);

    MyPrintf(_T("\n%s - Removes encrypted entries from a IIS5 Metabase\n"),szFilename_only);
    MyPrintf(_T("       Stops the iisadmin service (and dependent services if needed)\n"));
    MyPrintf(_T("------------------------------------------------------------------------\n"),szFilename_only);
	MyPrintf(_T("Usage: %s [-v] [-u] [-r] [-f]\n"), szFilename_only);
    MyPrintf(_T("  -v   Opens the metabase.bin as a file and displays the version.\n"));
    MyPrintf(_T("  -u   Opens the metabase.bin as a file and removes any encrypted data.\n"));
    MyPrintf(_T("  -r   Replaces Administrator\\Everyone acls on the '/','W3SVC/Info' and 'MSFTPSVC/Info' nodes.\n"));
    MyPrintf(_T("       Calls metabase api's -- so a working metabase is required.\n"));
    MyPrintf(_T("  -f   Forces the metabase to save it's settings to the file system.\n"));
    MyPrintf(_T("       Calls metabase api's -- so a working metabase is required.\n"));

	MyPrintf(_T("Example: %s -u -r -f\n"), szFilename_only);

    return;
}

BOOL DisplayMetabaseVersion(void)
{
    int bReturn = FALSE;

    g_PointerMapper = new CIdToPointerMapper (DEFAULT_START_NUMBER_OF_MAPS, DEFAULT_INCREASE_NUMBER_OF_MAPS);
    MD_ASSERT(g_PointerMapper);

    g_pboMasterRoot = NULL;
    g_phHandleHead = NULL;
    g_ppbdDataHashTable = NULL;
    for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
        g_phEventHandles[i] = NULL;
    }
    g_hReadSaveSemaphore = NULL;
    g_bSaveDisallowed = FALSE;
    g_rMasterResource = new TS_RESOURCE();
    g_rSinkResource = new TS_RESOURCE();
    g_pFactory = NULL;
    //g_pFactory = new CMDCOMSrvFactory();
    //if ((g_pFactory == NULL) || (g_rSinkResource == NULL) || (g_rMasterResource == NULL))
    bReturn = TRUE;
    if ((g_rSinkResource == NULL) || (g_rMasterResource == NULL))
        {bReturn = FALSE;}
    if (bReturn) {bReturn = InitializeMetabaseSecurity();}

    bReturn = FALSE;
    // other initialization stuff
    g_hReadSaveSemaphore = IIS_CREATE_SEMAPHORE("g_hReadSaveSemaphore",&g_hReadSaveSemaphore,1,1);
    if( g_hReadSaveSemaphore == NULL ) 
    {
        printf("CreateSemaphore Failed\n");
    }
    else
    {
        InitWorker(FALSE);
        bReturn = TRUE;
    }

    if (g_hReadSaveSemaphore != NULL) {CloseHandle(g_hReadSaveSemaphore);}
    //MD_ASSERT(g_PointerMapper);
    //if (g_PointerMapper) delete g_PointerMapper;

    return bReturn;
}



BOOL StripMetabase(void)
{
    int bReturn = FALSE;

    g_PointerMapper = new CIdToPointerMapper (DEFAULT_START_NUMBER_OF_MAPS, DEFAULT_INCREASE_NUMBER_OF_MAPS);
    MD_ASSERT(g_PointerMapper);

    g_pboMasterRoot = NULL;
    g_phHandleHead = NULL;
    g_ppbdDataHashTable = NULL;
    for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
        g_phEventHandles[i] = NULL;
    }
    g_hReadSaveSemaphore = NULL;
    g_bSaveDisallowed = FALSE;
    g_rMasterResource = new TS_RESOURCE();
    g_rSinkResource = new TS_RESOURCE();
    g_pFactory = NULL;
    //g_pFactory = new CMDCOMSrvFactory();
    //if ((g_pFactory == NULL) || (g_rSinkResource == NULL) || (g_rMasterResource == NULL))
    bReturn = TRUE;
    if ((g_rSinkResource == NULL) || (g_rMasterResource == NULL))
        {bReturn = FALSE;}
    if (bReturn) {bReturn = InitializeMetabaseSecurity();}

    bReturn = FALSE;
    // other initialization stuff
    g_hReadSaveSemaphore = IIS_CREATE_SEMAPHORE("g_hReadSaveSemaphore",&g_hReadSaveSemaphore,1,1);
    if( g_hReadSaveSemaphore == NULL ) 
    {
        printf("CreateSemaphore Failed\n");
    }
    else
    {
        // initialize metabase stuff
        //printf("ReadAllData -->\n");
        InitWorker(FALSE);
        //printf("ReadAllData <--\n");

        // Make some changes..
        g_dwSystemChangeNumber++;
        g_dwSystemChangeNumber++;


        // now save the metabase...
        METADATA_HANDLE hMDHandle = 0;

        HRESULT hresReturn;
        IIS_CRYPTO_STORAGE CryptoStorage;
        PIIS_CRYPTO_BLOB pSessionKeyBlob;

        if (g_dwInitialized == 0) 
        {
            hresReturn = MD_ERROR_NOT_INITIALIZED;
        }
        else 
        {
            hresReturn = InitStorageAndSessionKey(&CryptoStorage,&pSessionKeyBlob);
            if( SUCCEEDED(hresReturn) ) 
            {
                if (g_dwInitialized == 0) 
                {
                    hresReturn = MD_ERROR_NOT_INITIALIZED;
                }
                else 
                {
                    //printf("SaveAllData -->\n");
                    hresReturn = SaveAllData(FALSE, &CryptoStorage, pSessionKeyBlob, hMDHandle);
                    if( SUCCEEDED(hresReturn) ) 
                        {bReturn = TRUE;}
                    //printf("SaveAllData <--\n");
                }
                ::IISCryptoFreeBlob(pSessionKeyBlob);
            }
       }

    }

    return bReturn;
}

void StripMetabase_End(void)
{
    if (g_hReadSaveSemaphore != NULL) {
        CloseHandle(g_hReadSaveSemaphore);
    }

   MD_ASSERT(g_PointerMapper);
   delete g_PointerMapper;
}




DWORD SetMDEntry(MDEntry *pMDEntry)
{
    CMDKey cmdKey;
    DWORD  dwReturn = ERROR_SUCCESS;

    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)pMDEntry->szMDPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        dwReturn = ERROR_SUCCESS;
        dwReturn = cmdKey.SetData(pMDEntry->dwMDIdentifier,pMDEntry->dwMDAttributes,pMDEntry->dwMDUserType,pMDEntry->dwMDDataType,pMDEntry->dwMDDataLen,pMDEntry->pbMDData);
        // output what we set to the log file...
        if (FAILED(dwReturn))
        {
            //SetErrorFlag(__FILE__, __LINE__);
            //iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), pMDEntry->dwMDIdentifier, dwReturn));
        }
        cmdKey.Close();
    }

    return dwReturn;
}


DWORD WriteIISComputer(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    TCHAR szMyString[255];
   
    _tcscpy(szMyString, _T("IIsComputer"));

    stMDEntry.szMDPath = _T("LM");
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = sizeof(szMyString);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)szMyString;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


DWORD WriteSDtoMetaBase(PSECURITY_DESCRIPTOR outpSD, LPCTSTR szKeyPath)
{
    DWORD dwReturn = E_FAIL;
    DWORD dwLength = 0;
    CMDKey cmdKey;
    HRESULT hReturn = E_FAIL;
    
    if (!outpSD)
    {
        dwReturn = ERROR_INVALID_SECURITY_DESCR;
        printf("WriteSDtoMetaBase:FAILED:ERROR_INVALID_SECURITY_DESCR\n");
        goto WriteSDtoMetaBase_Exit;
    }

    // Apply the new security descriptor to the metabase
    dwLength = GetSecurityDescriptorLength(outpSD);

    // open the metabase
    // stick it into the metabase.  warning those hoses a lot because
    // it uses encryption.  rsabase.dll
    hReturn = cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, szKeyPath);
    if ( (METADATA_HANDLE)cmdKey ) 
    {
        dwReturn = cmdKey.SetData(MD_ADMIN_ACL,METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA,dwLength,(LPBYTE)outpSD);
        if (FAILED(dwReturn))
        {
            printf("WriteSDtoMetaBase:FAILED:cmdKey.SetData\n");
        }
        else
        {
            dwReturn = ERROR_SUCCESS;
        }
        cmdKey.Close();
    }
    else
    {
        printf("WriteSDtoMetaBase:FAILED:cmdKey.CreateNode\n");
        dwReturn = hReturn;
    }
   
WriteSDtoMetaBase_Exit:
    return dwReturn;
}



DWORD SetAdminACL(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount)
{
    int iErr=0;
    DWORD dwErr=0;

    DWORD dwRetCode = ERROR_SUCCESS;
    BOOL b = FALSE;
    DWORD dwLength = 0;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR outpSD = NULL;
    DWORD cboutpSD = 0;
    PACL pACLNew = NULL;
    DWORD cbACL = 0;
    PSID pAdminsSID = NULL, pEveryoneSID = NULL;
    BOOL bWellKnownSID = FALSE;

    // Initialize a new security descriptor
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (!pSD)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        dwErr=GetLastError();
        printf("SetAdminACL:FAILED:Initialize a new security descriptor\n");
    }
    iErr = InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
    if (iErr == 0)
    {
        printf("SetAdminACL:FAILED:InitializeSecurityDescriptor\n");
        dwErr=GetLastError();
    }

    // Get Local Admins Sid
    dwErr = GetPrincipalSID (_T("Administrators"), &pAdminsSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        printf("SetAdminACL:FAILED:GetPrincipalSID Administrators\n");

    }

    // Get everyone Sid
    dwErr = GetPrincipalSID (_T("Everyone"), &pEveryoneSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        printf("SetAdminACL:FAILED:GetPrincipalSID Everyone\n");
    }

    // Initialize a new ACL, which only contains 2 aaace
    cbACL = sizeof(ACL) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminsSID) - sizeof(DWORD)) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pEveryoneSID) - sizeof(DWORD)) ;
    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);
    if ( !pACLNew )
    {
        dwErr=GetLastError();
        printf("SetAdminACL:FAILED:!pACLNew\n");
    }

    if (!InitializeAcl(pACLNew, cbACL, ACL_REVISION))
    {
        dwErr=GetLastError();
        printf("SetAdminACL:FAILED:!InitializeAcl\n");
    }

    if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,(MD_ACR_READ |MD_ACR_WRITE |MD_ACR_RESTRICTED_WRITE |MD_ACR_UNSECURE_PROPS_READ |MD_ACR_ENUM_KEYS |MD_ACR_WRITE_DAC),pAdminsSID))
    {
        printf("SetAdminACL:FAILED:!AddAccessAllowedAce1\n");
        dwErr=GetLastError();
    }
    if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,dwAccessForEveryoneAccount,pEveryoneSID))
    {
        printf("SetAdminACL:FAILED:!AddAccessAllowedAce2\n");
        dwErr=GetLastError();
    }

    // Add the ACL to the security descriptor
    b = SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE);
    if (!b)
    {
        printf("SetAdminACL:FAILED:SetSecurityDescriptorDacl\n");
        dwErr=GetLastError();
    }

    b = SetSecurityDescriptorOwner(pSD, pAdminsSID, TRUE);
    if (!b)
    {
        printf("SetAdminACL:FAILED:SetSecurityDescriptorOwner\n");
        dwErr=GetLastError();
    }

    b = SetSecurityDescriptorGroup(pSD, pAdminsSID, TRUE);
    if (!b)
    {
        printf("SetAdminACL:FAILED:SetSecurityDescriptorGroup\n");
        dwErr=GetLastError();
    }

    // Security descriptor blob must be self relative
    b = MakeSelfRelativeSD(pSD, outpSD, &cboutpSD);
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
    if ( !outpSD )
    {
        printf("SetAdminACL:FAILED:MakeSelfRelativeSD\n");
        dwErr=GetLastError();
    }

    b = MakeSelfRelativeSD( pSD, outpSD, &cboutpSD );
    if (!b)
    {
        printf("SetAdminACL:FAILED:MakeSelfRelativeSD2\n");
        dwErr=GetLastError();
    }

    if (IsValidSecurityDescriptor(outpSD))
    {
        // Apply the new security descriptor to the metabase
        dwRetCode = WriteSDtoMetaBase(outpSD, szKeyPath);
    }
    else
    {
    }

    if (outpSD){GlobalFree(outpSD);outpSD=NULL;}
  

//Cleanup:
  // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
  if (pAdminsSID){FreeSid(pAdminsSID);}
  if (pEveryoneSID){FreeSid(pEveryoneSID);}
  if (pSD){LocalFree((HLOCAL) pSD);}
  if (pACLNew){LocalFree((HLOCAL) pACLNew);}
  return (dwRetCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\registry.cxx ===
#include <mdcommon.hxx>

MDRegKey::MDRegKey (
    HKEY hKeyBase,
    LPCTSTR pchSubKey,
    REGSAM regSam,
    LPCTSTR pchServerName
    )
    : m_hKey(NULL),
      m_dwDisposition(0)
{
    HKEY hkBase = NULL ;
    DWORD err = ERROR_SUCCESS;

    if ( pchServerName != NULL)
    {
        //
        // This is a remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)pchServerName, hKeyBase, &hkBase);
        if (err != ERROR_SUCCESS)
        {
            hkBase = NULL ;
            SetLastError(err);
        }

        hkBase = NULL ;
    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == ERROR_SUCCESS)
    {
        if ( pchSubKey )
        {
            err = ::RegOpenKeyEx( hkBase, pchSubKey, 0, regSam, & m_hKey ) ;
        }
        else
        {
            m_hKey = hkBase ;
            hkBase = NULL ;
        }

        if ( hkBase && hkBase != hKeyBase )
        {
            ::RegCloseKey( hkBase ) ;
        }
    }

    if ( err != ERROR_SUCCESS)
    {
        m_hKey = NULL ;
    }
    SetLastError(err);
}

//
//  Constructor creating a new key.
//
MDRegKey::MDRegKey (
    LPCTSTR pchSubKey,
    HKEY hKeyBase,
    DWORD dwOptions,
    REGSAM regSam,
    LPSECURITY_ATTRIBUTES pSecAttr,
    LPCTSTR pchServerName
    )
    : m_hKey(NULL),
      m_dwDisposition(0)
{
    HKEY hkBase = NULL ;
    DWORD err = 0;

    if (pchServerName != NULL)
    {
        //
        // This is a remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)pchServerName, hKeyBase, & hkBase);
        if (err != ERROR_SUCCESS)
        {
            hkBase = NULL;
            SetLastError(err);
        }

        hkBase = NULL;
    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == ERROR_SUCCESS)
    {
        LPCTSTR szEmpty = TEXT("") ;

        err = ::RegCreateKeyEx( hkBase, pchSubKey, 0, (TCHAR *) szEmpty,
            dwOptions, regSam, pSecAttr, &m_hKey, &m_dwDisposition );
    }
    if (err != ERROR_SUCCESS)
    {
        m_hKey = NULL ;
    }
    SetLastError(err);
}

MDRegKey::~MDRegKey()
{
    if (m_hKey != NULL)
    {
        ::RegCloseKey( m_hKey ) ;
    }
}

DWORD
MDRegKey::QueryValue (
    LPTSTR pchValueName,
    DWORD * pdwType,
    DWORD * pdwSize,
    BUFFER *pbufData
    )
{
    DWORD dwReturn = ERROR_SUCCESS;

    *pdwSize = pbufData->QuerySize();

    dwReturn = ::RegQueryValueEx(*this, (LPTSTR) pchValueName,
        0, pdwType, (PBYTE) pbufData->QueryPtr(), pdwSize);

    if (dwReturn == ERROR_MORE_DATA) {
        if (pbufData->Resize(*pdwSize)) {
            *pdwSize = pbufData->QuerySize();
            dwReturn = ::RegQueryValueEx(*this, (LPTSTR) pchValueName,
                0, pdwType, (PBYTE)pbufData->QueryPtr(), pdwSize);
        }
    }

    return dwReturn;
}

//
//  Overloaded value setting members.
//
DWORD
MDRegKey::SetValue (
    LPCTSTR pchValueName,
    DWORD dwType,
    DWORD dwSize,
    PBYTE pbData
    )
{
    return ::RegSetValueEx( *this, pchValueName, 0, dwType,
        pbData, dwSize );
}


DWORD
MDRegKey::DeleteValue (
    LPCTSTR pchValueName
    )
{
    return ::RegDeleteValue( *this, (LPTSTR) pchValueName);
}

DWORD
MDRegKey::QueryKeyInfo (
    MDREGKEY_KEY_INFO * pRegKeyInfo
    )
{
    DWORD err = 0 ;

    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;

    err = ::RegQueryInfoKey(*this,
        pRegKeyInfo->chBuff,
        &pRegKeyInfo->dwClassNameSize,
        NULL,
        &pRegKeyInfo->dwNumSubKeys,
        &pRegKeyInfo->dwMaxSubKey,
        &pRegKeyInfo->dwMaxClass,
        &pRegKeyInfo->dwMaxValues,
        &pRegKeyInfo->dwMaxValueName,
        &pRegKeyInfo->dwMaxValueData,
        &pRegKeyInfo->dwSecDesc,
        &pRegKeyInfo->ftKey
        );

    return err ;
}

//
// Iteration class
//
MDRegKeyIter::MDRegKeyIter (
    MDRegKey & regKey
    )
    : m_rk_iter( regKey ),
      m_p_buffer( NULL ),
      m_cb_buffer( 0 )
{
    DWORD err = 0 ;

    MDRegKey::MDREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        m_cb_buffer = regKeyInfo.dwMaxSubKey + sizeof (DWORD) ;
        m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        if (m_p_buffer == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }
    SetLastError(err);
}

MDRegKeyIter :: ~ MDRegKeyIter ()
{
    delete [] m_p_buffer ;
}

//
// Get the name (and optional last write time) of the next key.
//

DWORD MDRegKeyIter::Next(
    LPTSTR *ppszName,
    FILETIME *pTime,
    DWORD dwIndex
    )
{
    DWORD err = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cb_buffer ;

    if (dwIndex != 0xffffffff) {
        m_dw_index = dwIndex;
    }

    err = ::RegEnumKeyEx( m_rk_iter, m_dw_index, m_p_buffer, & dwNameSize,
        NULL, NULL, NULL, & ftDummy ) ;

    if (err == ERROR_SUCCESS)
    {
        ++m_dw_index;

        if ( pTime )
        {
            *pTime = ftDummy ;
        }

        *ppszName = m_p_buffer;
    }

    return err;
}

MDRegValueIter::MDRegValueIter (
    MDRegKey &regKey
    )
    : m_rk_iter(regKey),
      m_p_buffer(NULL),
      m_cb_buffer(0)
{
    DWORD err = 0;

    MDRegKey::MDREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if (err == ERROR_SUCCESS)
    {
        m_cb_buffer = regKeyInfo.dwMaxValueName + sizeof (DWORD);
        m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        if (m_p_buffer == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }
    SetLastError(err);
}

MDRegValueIter::~MDRegValueIter()
{
    delete [] m_p_buffer;
}

DWORD
MDRegValueIter::Next (
    LPTSTR * ppszName,
    DWORD * pdwType
    )
{
    DWORD err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;

    err = ::RegEnumValue(m_rk_iter, m_dw_index, m_p_buffer,
        &dwNameLength, NULL, pdwType, NULL, NULL );

    if ( err == ERROR_SUCCESS )
    {
        ++m_dw_index;

        *ppszName = m_p_buffer;
    }

    return err;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\mdkey.cpp ===
#include "main.h"
#include "iadmw.h"

#define TIMEOUT_VALUE 5000


#if defined(UNICODE) || defined(_UNICODE)
#else
void MyMultiByteToWideChar( char *sData, WCHAR *wData, int cbBufSize, BOOL fMultiSZ)
{
    MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
    while (fMultiSZ) 
    {
        sData = _tcsninc( sData, _tcslen(sData)) + 1;
        while (*wData++);
        if (*sData)
        {
            MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
        }
        else 
        {
            *wData = L'\0';
            break;
        }
    }
    return;
}

void MyWideCharToMultiByte( WCHAR *wData, char *sData, int cbBufSize, BOOL fMultiSZ)
{
    WideCharToMultiByte( CP_ACP, 0, wData, -1, sData, cbBufSize, NULL, NULL );
    while (fMultiSZ) 
    {
        while (*wData++);
        sData = _tcsninc( sData, _tcslen(sData)) + 1;
        if (*wData)
        {
            WideCharToMultiByte( CP_ACP, 0, wData, -1, sData, cbBufSize, NULL, NULL );
        }
        else 
        {
            *sData = '\0';
            break;
        }
    }
    return;
}
#endif      // unicode


CMDKey::CMDKey():
    m_cCoInits(0)
{
    m_pcCom = NULL;
    m_hKey = NULL;
}

CMDKey::~CMDKey()
{
    this->Close();

    // while there are outstanding coinits, close them
    while ( m_cCoInits > 0 && !(m_cCoInits < 0) )
        DoCoUnInit();
}


HRESULT CMDKey::DoCoInitEx()
{
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    // track our calls to coinit
    if ( SUCCEEDED(hRes) )
    {
        m_cCoInits++;
    }

    return hRes;
}

void CMDKey::DoCoUnInit()
{
    HRESULT hRes = NOERROR;

    // if there are outstanding coinits, uninit one
    if ( m_cCoInits > 0 )
    {
        ////iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
        CoUninitialize();
        ////iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));
        m_cCoInits--;
    }

    // we shouldn't ever have a negative count. But just in case...
    //ASSERT( m_cCoInits >= 0 );
    if ( m_cCoInits < 0 )
    {
        // something is seriously wrong here. Prevent looping
        // by going straight to zero, and write an error to the log.
        m_cCoInits = 0;
        //iisDebugOut((LOG_TYPE_WARN, _T("WARNING: CoInits in mdkey have gone negative")));
    }
}


HRESULT CMDKey::OpenNode(LPCTSTR pchSubKeyPath)
{
    HRESULT hRes = ERROR_SUCCESS;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];

    pszFailedAPI = NULL;


    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) 
    {
        *szSubKeyPath = L'\0';
    }
    else 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH);
#endif
    }

    hRes = DoCoInitEx();
    if (FAILED(hRes))
    {
        printf("CMDKey::OpenNode failed at DoCoInitEx");
    }

    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hRes)) 
    {
        printf("CMDKey::OpenNode failed at CoGetClassObject");
    }
    else 
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
        pcsfFactory->Release();
        if (FAILED(hRes)) 
        {
            printf("CMDKey::OpenNode failed at pcsfFactory->CreateInstance");
        }
        else 
        {
            hRes = m_pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,szSubKeyPath,METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&m_hKey);
            if (FAILED(hRes)) 
            {
                if (hRes != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) 
                {
                    printf("CMDKey::OpenNode failed at OpenKey");
                }
            }
            else 
            {
                b = TRUE;
            }
        } // end of CoCreateInstance
    } // end of CoGetClassObject

    if (!b) {this->Close();}
    return hRes;
}


HRESULT CMDKey::ForceWriteMetabaseToDisk()
{
    HRESULT hRes = ERROR_SUCCESS;
    IClassFactory * pcsfFactory = NULL;
    m_pcCom = NULL;

    hRes = DoCoInitEx();
    if (FAILED(hRes))
    {
        printf("ForceWriteMetabaseToDisk failed at DoCoInitEx\n");
    }

    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hRes)) 
    {
        printf("ForceWriteMetabaseToDisk failed at CoGetClassObject\n");
    }
    else 
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
        pcsfFactory->Release();
        if (FAILED(hRes)) 
        {
            printf("ForceWriteMetabaseToDisk failed at CreateInstance\n");
        }
        else 
        {
            if (m_pcCom) 
            {
                hRes = m_pcCom->SaveData();
                printf("ForceWriteMetabaseToDisk Success.\n");
            }
        } // end of CoCreateInstance
    } // end of CoGetClassObject

    return hRes;
}


HRESULT CMDKey::Close()
{
    HRESULT hRes = ERROR_SUCCESS;
    if (m_pcCom) 
    {
        if (m_hKey){hRes = m_pcCom->CloseKey(m_hKey);}
        hRes = m_pcCom->Release();
    }
    DoCoUnInit();
    m_pcCom = NULL;
    m_hKey = NULL;

    return hRes;
}


HRESULT CMDKey::SetData(DWORD id,DWORD attr,DWORD uType,DWORD dType,DWORD cbLen, LPBYTE pbData,PWCHAR pszSubString )
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    BUFFER bufData;
    WCHAR *pData = (WCHAR *)pbData;
    int iPlsDoNoEncryption = FALSE;

    switch (dType) 
    {
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            pData = (WCHAR *)pbData;
#else
            if ( ! (bufData.Resize(cbLen * sizeof(WCHAR))) )
            {
                // insufficient memory
                hRes = RETURNCODETOHRESULT(GetLastError());
                goto SetData_Exit;
            }

            pData = (WCHAR *)(bufData.QueryPtr());
            MyMultiByteToWideChar( (LPTSTR)pbData, pData, cbLen, FALSE);
            cbLen = cbLen * sizeof(WCHAR);
#endif
            break;

        case MULTISZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            pData = (WCHAR *)pbData;
#else
            if ( ! (bufData.Resize(cbLen * sizeof(WCHAR))) )
            {
                // insufficient memory
                hRes = RETURNCODETOHRESULT(GetLastError());
                goto SetData_Exit;
            }
            pData = (WCHAR *)(bufData.QueryPtr());
            MyMultiByteToWideChar( (LPTSTR)pbData, pData, cbLen, TRUE );
            cbLen = cbLen * sizeof(WCHAR);
#endif
            break;

        default:
            break;

    }

    if (cbLen >= 0) 
    {

        MD_SET_DATA_RECORD(&mdrData, id, attr, uType, dType, cbLen, (LPBYTE)pData);
        hRes = m_pcCom->SetData(m_hKey, pszSubString, &mdrData);
        if (FAILED(hRes))
        {
            // Check if it failed...
            // if it failed and the METADATA_SECURE flag is set, then
            // check if we can retry without the METADATA_SECURE flag!
            if ( attr & METADATA_SECURE )
            {
                iPlsDoNoEncryption = TRUE;
                if (TRUE == iPlsDoNoEncryption)
                {
                    attr &= ~METADATA_SECURE;
                    MD_SET_DATA_RECORD(&mdrData, id, attr, uType, dType, cbLen, (LPBYTE)pData);
                    hRes = m_pcCom->SetData(m_hKey, pszSubString, &mdrData);
                    // set the attr back to what it was
                    attr &= ~METADATA_SECURE;
                }
            }
        }
    }
    goto SetData_Exit;

SetData_Exit:
    return hRes;
}

// Note: only use to access the AnonyName and AnonyPassword,
// buffer size 256 is big enough here
BOOL CMDKey::GetData(DWORD id,DWORD *pdwAttr,DWORD *pdwUType,DWORD *pdwDType,DWORD *pcbLen,LPBYTE pbData,DWORD  BufSize,DWORD  dwAttributes,DWORD  dwUType,DWORD  dwDType,PWCHAR pszSubString )
{
    int ReturnIndex;
    BOOL fReturn = FALSE;
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen = 0;
    LPBYTE ReturnBuf=NULL;
    int ReturnBufSize;

    // if we are just trying to get the size of the field, just do that.
    if ( !pbData || (BufSize == 0) )
    {
        MD_SET_DATA_RECORD(&mdrData, id, dwAttributes, dwUType, dwDType, 0, NULL);
        hRes = m_pcCom->GetData(m_hKey, pszSubString, &mdrData, &dwRequiredDataLen);
        *pcbLen = dwRequiredDataLen;
        fReturn = (hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER));
        goto GetData_Exit;
    }

#if defined(UNICODE) || defined(_UNICODE)
    ReturnBufSize = BufSize;
#else
    ReturnBufSize = 2 * BufSize;
#endif
    ReturnBuf = (LPBYTE)LocalAlloc(LPTR, ReturnBufSize);
    if (!ReturnBuf)
    {
        ReturnBuf = NULL;
        goto GetData_Exit;
    }

    //DisplayStringForMetabaseID(id);

    MD_SET_DATA_RECORD(&mdrData, id, dwAttributes, dwUType, dwDType, ReturnBufSize, (PBYTE) ReturnBuf);
    hRes = m_pcCom->GetData(m_hKey, pszSubString, &mdrData, &dwRequiredDataLen);

    if (FAILED(hRes)) 
    {
        if (hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) 
        {
#if defined(UNICODE) || defined(_UNICODE)
            *pcbLen = dwRequiredDataLen;
#else
            *pcbLen = dwRequiredDataLen / 2;
#endif
        }
        else 
        {
            *pcbLen = 0;
            if (hRes != MD_ERROR_DATA_NOT_FOUND)
            {
                MessageBox(NULL, _T("GETDATA_ERROR"), NULL, MB_OK | MB_SETFOREGROUND);
            }
        }
        goto GetData_Exit;
    }

    // --------
    // We have successfully retrieved the data at this point
    // --------
    *pdwAttr = mdrData.dwMDAttributes;
    *pdwUType = mdrData.dwMDUserType;
    *pdwDType = mdrData.dwMDDataType;
    *pcbLen = mdrData.dwMDDataLen; // number of SBCS chars + ending \0
    switch (*pdwDType) 
    {
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
#else
            *pcbLen = (*pcbLen) / sizeof(WCHAR);
            WideCharToMultiByte(CP_ACP,0,(WCHAR *)(mdrData.pbMDData),-1,(LPSTR)pbData,*pcbLen, NULL, NULL);
#endif
            fReturn = TRUE;
            break;
        case MULTISZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
#else
            *pcbLen = (*pcbLen) / sizeof(WCHAR);
            MyWideCharToMultiByte((WCHAR *)(mdrData.pbMDData),(LPSTR)pbData, *pcbLen, TRUE);
#endif
            fReturn = TRUE;
            break;
        default:
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
            fReturn = TRUE;
            break;
    }

GetData_Exit:
    if(ReturnBuf) {LocalFree(ReturnBuf);}
    return fReturn;
}


HRESULT CMDKey::CreateNode(METADATA_HANDLE hKeyBase, LPCTSTR pchSubKeyPath)
{
    HRESULT hRes = ERROR_SUCCESS;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];


    pszFailedAPI = NULL;

    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) 
    {
        *szSubKeyPath = L'\0';
    }
    else 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH);
#endif
    }

    hRes = DoCoInitEx();
    if (FAILED(hRes))
    {
        //iisDebugOut((LOG_TYPE_ERROR, _T("CoInitializeEx() failed, hRes=%x\n"), hRes));
    }

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoGetClassObject().Start.")));
    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoGetClassObject().End.")));
    if (FAILED(hRes)) 
    {
        ///MyMessageBox(NULL, _T("CoGetClassObject"), hRes, MB_OK | MB_SETFOREGROUND);
    }
    else 
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
        pcsfFactory->Release();
        if (FAILED(hRes)) 
        {
            //MyMessageBox(NULL, _T("CreateInstance"), hRes, MB_OK | MB_SETFOREGROUND);
        }
        else 
        {
            hRes = m_pcCom->OpenKey(hKeyBase,szSubKeyPath,METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&m_hKey);
            if (FAILED(hRes)) 
            {
                if (hRes == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) 
                {
                    METADATA_HANDLE RootHandle;
                    hRes = m_pcCom->OpenKey(hKeyBase,L"",METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&RootHandle);
                    hRes = m_pcCom->AddKey(RootHandle, szSubKeyPath);
                    if (FAILED(hRes)) 
                    {
                        //MyMessageBox(NULL, _T("AddKey"), hRes, MB_OK | MB_SETFOREGROUND);
                    }
                    hRes = m_pcCom->CloseKey(RootHandle);
                    if (FAILED(hRes)) 
                    {
                        //MyMessageBox(NULL, _T("CloseKey of the AddKey"), hRes, MB_OK | MB_SETFOREGROUND);
                    }
                    else 
                    {
                        // open it again to set m_hKey
                        hRes = m_pcCom->OpenKey(hKeyBase,szSubKeyPath,METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&m_hKey);
                        if (FAILED(hRes)) 
                        {
                            //MyMessageBox(NULL, _T("OpenKey"), hRes, MB_OK | MB_SETFOREGROUND);
                        }
                        else 
                        {
                            b = TRUE;
                        }
                    }
                }
                else 
                {
                    //iisDebugOut((LOG_TYPE_ERROR, _T("calling OpenKey()...failed....something other than ERROR_PATH_NOT_FOUND\n")));
                    //MyMessageBox(NULL, _T("OpenKey"), hRes, MB_OK | MB_SETFOREGROUND);
                }
            }
            else 
            {
                b = TRUE;
            } // end of OpenKey
        } // end of CoCreateInstance
    } // end of CoGetClassObject

    if (!b) {this->Close();}

    return hRes;
}



BOOL CMDKey::GetData(DWORD id,DWORD *pdwAttr,DWORD *pdwUType,DWORD *pdwDType,DWORD *pcbLen,LPBYTE pbData,DWORD BufSize,PWCHAR pszSubString )
{
    return GetData(id,pdwAttr,pdwUType,pdwDType,pcbLen,pbData,BufSize,0,0,0,pszSubString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\unitest\sink.cxx ===
#define UNICODE
#define MD_UNICODE_SUPPORT
#include <windows.h>
#include <ole2.h>
#include <imd.h>
#include <stdio.h>
#include <sink.hxx>

//extern HANDLE          hevtDone;

CImpIMDCOMSINK::CImpIMDCOMSINK()
{
    m_dwRefCount=0;
}

CImpIMDCOMSINK::~CImpIMDCOMSINK()
{
}

HRESULT
CImpIMDCOMSINK::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOMSINK) {
        *ppObject = (IMDCOMSINK *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CImpIMDCOMSINK::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CImpIMDCOMSINK::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CImpIMDCOMSINK::ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT_A __RPC_FAR pcoChangeList[  ])
{
    DWORD i, j;
    printf("Recieved callback for handle %X\n", hMDHandle);
    for (i = 0; i < dwMDNumElements; i++) {
        printf("Change Type = %X, Path = %s\n", pcoChangeList[i].dwMDChangeType, pcoChangeList[i].pszMDPath);
        for (j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++) {
            printf("\tData Changed ID = %X\n", pcoChangeList[i].pdwMDDataIDs[j]);
        }
    }
    printf("\n");
    return (0);
}


CImpIMDCOMSINKW::CImpIMDCOMSINKW()
{
    m_dwRefCount=0;
}

CImpIMDCOMSINKW::~CImpIMDCOMSINKW()
{
}

HRESULT
CImpIMDCOMSINKW::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOMSINK_W) {
        *ppObject = (IMDCOMSINKW *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CImpIMDCOMSINKW::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CImpIMDCOMSINKW::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CImpIMDCOMSINKW::ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
    DWORD i, j;
    printf("Recieved UNICODE callback for handle %X\n", hMDHandle);
    for (i = 0; i < dwMDNumElements; i++) {
        printf("Change Type = %X, Path = %S\n", pcoChangeList[i].dwMDChangeType, pcoChangeList[i].pszMDPath);
        for (j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++) {
            printf("\tData Changed ID = %X\n", pcoChangeList[i].pdwMDDataIDs[j]);
        }
    }
    printf("\n");
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\security.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    security.cxx

Abstract:

    IIS MetaBase security routines.

Author:

    Keith Moore (keithmo)       13-Mar-1997

Revision History:

--*/


#include <mdcommon.hxx>


//
// Private data.
//

CRITICAL_SECTION p_SecurityLock;
HCRYPTPROV       p_CryptoProvider = CRYPT_NULL;


//
// Public functions.
//


BOOL
InitializeMetabaseSecurity(
    VOID
    )
/*++

Routine Description:

    Initializes metabase security.

Arguments:

    None.

Return Value:

    BOOL - TRUE if successful, FALSE otherwise.

--*/
{

    HRESULT result;

    INITIALIZE_CRITICAL_SECTION( &p_SecurityLock );

    result = ::IISCryptoInitialize();

    if( FAILED(result) ) {
        DBGPRINTF((
            DBG_CONTEXT,
            "InitializeMetabaseSecurity: error %lx\n",
            result
            ));
    }

    return SUCCEEDED(result);

}   // InitializeMetabaseSecurity


VOID
TerminateMetabaseSecurity(
    VOID
    )
/*++

Routine Description:

    Terminates metabase security. Basically, undoes anything done in
    InitializeMetabaseSecurity().

Arguments:

    None.

Return Value:

    None.

--*/
{

    HRESULT result;

    if( p_CryptoProvider != CRYPT_NULL ) {
        result = ::IISCryptoCloseContainer( p_CryptoProvider );
        DBG_ASSERT( SUCCEEDED(result) );
    }

    result = ::IISCryptoTerminate();
    DBG_ASSERT( SUCCEEDED(result) );

    DeleteCriticalSection( &p_SecurityLock );

}   // TerminateMetabaseSecurity


HRESULT
GetCryptoProvider(
    HCRYPTPROV *Provider
    )
/*++

Routine Description:

    This routine returns a handle to the crypto provider we need to
    use, deferring creation of the handle until it is actually needed.

Arguments:

    Provider - Receives the handle to the provider.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;
    HCRYPTPROV hprov;

    //
    // If the handle is already initialized, then just use it. Otherwise,
    // grab the lock and check it again.
    //

    hprov = p_CryptoProvider;
    if( hprov == CRYPT_NULL ) {

        EnterCriticalSection( &p_SecurityLock );

        hprov = p_CryptoProvider;
        if( hprov == CRYPT_NULL ) {

            result = ::IISCryptoGetStandardContainer(
                           &hprov,
                           CRYPT_MACHINE_KEYSET
                           );

            if( SUCCEEDED(result) ) {
                p_CryptoProvider = hprov;
            }

        }

        LeaveCriticalSection( &p_SecurityLock );

    }

    *Provider = hprov;
    return result;

}   // GetCryptoProvider
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\svc.cpp ===
#include "main.h"
#include <inetsvcs.h>

/*----------------------------------------------------------------------------------------
Routine Description:
    This routine allocates a buffer for the specified service's configuration parameters,
    and retrieves those parameters into the buffer.  The caller is responsible for freeing
    the buffer.
Remarks:
    The pointer whose address is contained in ServiceConfig is guaranteed to be NULL upon
    return if any error occurred.
-----------------------------------------------------------------------------------------*/
DWORD RetrieveServiceConfig(IN SC_HANDLE ServiceHandle,OUT LPQUERY_SERVICE_CONFIG *ServiceConfig)
{
    DWORD ServiceConfigSize = 0, Err;
    *ServiceConfig = NULL;
    while(TRUE) {
        if(QueryServiceConfig(ServiceHandle, *ServiceConfig, ServiceConfigSize, &ServiceConfigSize)) 
			{
            //assert(*ServiceConfig);
            return NO_ERROR;
			}
		else 
			{
            Err = GetLastError();
            if(*ServiceConfig) {free(*ServiceConfig);}
            if(Err == ERROR_INSUFFICIENT_BUFFER) 
				{
                // Allocate a larger buffer, and try again.
                if(!(*ServiceConfig = (LPQUERY_SERVICE_CONFIG) malloc(ServiceConfigSize)))  {return ERROR_NOT_ENOUGH_MEMORY;}
				} 
			else 
				{
                *ServiceConfig = NULL;
                return Err;
				}
			}
    }
}

int IsThisServiceADriver(LPCTSTR lpServiceName)
{
    int iReturn = FALSE;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    BYTE ConfigBuffer[4096];
    LPENUM_SERVICE_STATUS ServiceConfigEnum = (LPENUM_SERVICE_STATUS) &ConfigBuffer;
    if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
        // Failed, or more likely the service doesn't exist
        //iReturn = GetLastError();
        goto IsThisServiceADriver_Exit;
        }

	if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
		{
        //iReturn = GetLastError();
		goto IsThisServiceADriver_Exit;
		}

    if ( (ServiceConfig->dwServiceType & SERVICE_KERNEL_DRIVER) || (ServiceConfig->dwServiceType & SERVICE_FILE_SYSTEM_DRIVER))
    {
        iReturn = TRUE;
    }

IsThisServiceADriver_Exit:
    if (ServiceConfig) free(ServiceConfig);
    if (hService) CloseServiceHandle(hService);
    if (hScManager) CloseServiceHandle(hScManager);
    return iReturn;
}


//
//Routine Description:
//    Stop the named service and all those services which depend upon it.
//    And if the service is hung and can't be stopped, then kill the darn thing.
//
//Arguments:
//    ServiceName (Name of service to stop)
//
//Return Status:
//    TRUE - Indicates service successfully stopped
//    FALSE - Timeout occurred.
//
int StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList)
{
    ////iisDebugOut_Start1(_T("StopServiceAndDependencies"),(LPTSTR) ServiceName);

    int Err = 0;
    int iBeforeServiceStatus = 0;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    DWORD Timeout;
	int iReturn = FALSE;
    DWORD TimeoutMaxSecs = 60;
    DWORD dwSvcMaxSleep = 0;

    //
    // Open a handle to the Service.
    //
    ScManagerHandle = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT );
    if (ScManagerHandle == NULL) 
	{
        Err = GetLastError();
		//iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():OpenSCManager: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
        goto Cleanup;
    }

    ServiceHandle = OpenService(ScManagerHandle,ServiceName,SERVICE_QUERY_STATUS | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_STOP | SERVICE_QUERY_CONFIG );
    if ( ServiceHandle == NULL ) 
	{
        Err = GetLastError();
        if (Err == ERROR_SERVICE_DOES_NOT_EXIST)
        {
             iReturn = TRUE;
             //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("StopServiceAndDependencies():%s Service does not exist.\n"), ServiceName));
        }
        else
        {
	     //iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():OpenService: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
        }
        goto Cleanup;
    }

    // Get the before service status.
    if (QueryServiceStatus(ServiceHandle, &ServiceStatus)) 
    {
        iBeforeServiceStatus = ServiceStatus.dwCurrentState;
    }

    //
    // Ask the service to stop.
    //
    if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) 
	{
        Err = GetLastError();
        // If there are dependent services running,
        //  determine their names and stop them.
        if ( Err == ERROR_DEPENDENT_SERVICES_RUNNING ) 
		{
            BYTE ConfigBuffer[4096];
            LPENUM_SERVICE_STATUS ServiceConfig = (LPENUM_SERVICE_STATUS) &ConfigBuffer;
            DWORD BytesNeeded;
            DWORD ServiceCount;
            DWORD ServiceIndex;

            //
            // Get the names of the dependent services.
            //
            if ( !EnumDependentServices( ServiceHandle,SERVICE_ACTIVE,ServiceConfig,sizeof(ConfigBuffer),&BytesNeeded,&ServiceCount ) ) 
			{
                Err = GetLastError();
				//iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():EnumDependentServices: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
                goto Cleanup;
            }

            //
            // Stop those services.
            //
            for ( ServiceIndex=0; ServiceIndex<ServiceCount; ServiceIndex++ ) 
			{
                //MyPrintf(_T("Stopping service:%s\n"),ServiceConfig[ServiceIndex].lpServiceName);
                StopServiceAndDependencies( ServiceConfig[ServiceIndex].lpServiceName, AddToRestartList);
            }

            //
            // Ask the original service to stop.
            //
            MyPrintf(_T("Stopping service:%s\n"),ServiceName);
            if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) 
			{
                Err = GetLastError();

				// check if the service is already stopped..
				if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE) 
				{
					// check if the service is alread stopped.
					if (QueryServiceStatus( ServiceHandle, &ServiceStatus )) 
					{
						if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) 
							{
                            iReturn = TRUE;
                            goto Cleanup;
                            }
					}
				}
				else
				{
                    // The service must be in a hung mode.  Let's kill it.
                    //iisDebugOut((LOG_TYPE_WARN, _T("StopServiceAndDependencies():'%s' Service must be in a hung mode.  Let's kill it.\n"), ServiceName));
                    //KillService(ServiceHandle);
                    goto WaitLoop;
				}
			
                goto Cleanup;
            }
        }
		else 
		{
			// check if the service is already stopped..
			if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE) 
			{
				// check if the service is alread stopped.
				if (QueryServiceStatus( ServiceHandle, &ServiceStatus )) 
				{
					if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) 
						{
                        Err = ServiceStatus.dwCurrentState;
                        iReturn = TRUE;
                        goto Cleanup;
                        }
				}
			}
			else
			{
					// The service must be in a hung mode.  Let's kill it.
					//iisDebugOut((LOG_TYPE_WARN, _T("StopServiceAndDependencies():'%s' Service must be in a hung mode.  Let's kill it.\n"), ServiceName));
					//KillService(ServiceHandle);
					goto WaitLoop;
			}
		
            goto Cleanup;
        }
    }
    else
    {
        MyPrintf(_T("Stopping service:%s\n"),ServiceName);
        // We successfully asked the service to stop...
    }


WaitLoop:
    // Calculcate if this is a "special" service which we 
    // need to give more time to in order to stop.
    dwSvcMaxSleep = 180000 * 2;
    // dwSvcMaxSleep returns 3 minute intervals.  so default dwSvcMaxSleep will be 180000 (3 minutes)
    // we need to convert this into how many seconds
    TimeoutMaxSecs = (dwSvcMaxSleep/1000);

    // Loop waiting for the service to stop.
    for ( Timeout=0; Timeout < TimeoutMaxSecs; Timeout++ ) 
    {
        // Return or continue waiting depending on the state of the service.
        if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED ) 
		{
			// The service successfully stopped.
            ////iisDebugOut((LOG_TYPE_TRACE, _T("StopServiceAndDependencies(): %s Service stopped.\n"), ServiceName));
			iReturn = TRUE;
            goto Cleanup;
        }

        // Wait a second for the service to finish stopping.
        Sleep( 1000 );

        // Query the status of the service again.
        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus ))
		{
            Err = GetLastError();
			//iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():QueryServiceStatus: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
            goto Cleanup;
        }

        // if the service we are trying to stop is a driver,
        // then heck we should just get out of here..
        if (TRUE == IsThisServiceADriver(ServiceName))
        {
            //iisDebugOut((LOG_TYPE_WARN, _T("StopServiceAndDependencies(): %s service is a driver, and can only be removed upon reboot.\n"), ServiceName));
            goto Cleanup;
        }
    }

    // if we get here then the service failed to stop.
    //iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies(): failed to stop %s service.\n"), ServiceName));

Cleanup:
    if ( ScManagerHandle != NULL )  {(VOID) CloseServiceHandle(ScManagerHandle);}
	if ( ServiceHandle != NULL ) {(VOID) CloseServiceHandle(ServiceHandle);}

    // if we successfully stopped this service, then
    // add it to the restart service list
    if (iReturn == TRUE)
    {
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("StopServiceAndDependencies(): %s service. success.\n"), ServiceName));
        if (iBeforeServiceStatus == SERVICE_RUNNING)
        {
            //if (AddToRestartList) {ServicesRestartList_Add(ServiceName);}
        }
    }
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\unitest\main.cxx ===
#define UNICODE

#include <windows.h>

#define INITGUID

#include <ole2.h>
#include <stdio.h>
#include <mdmsg.h>
#include <mdcommsg.h>
#include <imd.h>
#include <sink.hxx>

// {BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}
//static const GUID CLSID_MDCOM =
//{ 0xba4e57f0, 0xfab6, 0x11cf, { 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51 } };
// {BA4E57F1-FAB6-11cf-9D1A-00AA00A70D51}
//static const GUID IID_IMDCOMSRVFACTORY =
//{ 0xba4e57f1, 0xfab6, 0x11cf, { 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51 } };

// {C1AA48C0-FACC-11cf-9D1A-00AA00A70D51}
//static const GUID IID_IMDCOM =
//{ 0xc1aa48c0, 0xfacc, 0x11cf, { 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51 } };

#define MD_TEST_MAX_STRING_LEN   2048
#define MD_TEST_MAX_BINARY_LEN   2048

#define FILL_RETURN_BUFF   for(ReturnIndex=0;ReturnIndex<sizeof(ReturnBuf);ReturnIndex++)ReturnBuf[ReturnIndex]=0xff;
#define SET_RETURN_DATA    {ReturnDataLen=sizeof(ReturnBuf);ReturnUserType=0;ReturnDataType=0;ReturnAttributes=(METADATA_INHERIT | METADATA_PARTIAL_PATH);FILL_RETURN_BUFF}
#define MD_SET_DATA_RECORD(PMDR, ID, ATTR, UTYPE, DTYPE, DLEN, PD) \
            { \
            (PMDR)->dwMDIdentifier=ID; \
            (PMDR)->dwMDAttributes=ATTR | g_dwSecurityFlags; \
            (PMDR)->dwMDUserType=UTYPE; \
            (PMDR)->dwMDDataType=DTYPE; \
            (PMDR)->dwMDDataLen=DLEN; \
            (PMDR)->pbMDData=(PBYTE)PD; \
            }

#define TIMEOUT_VALUE      1000
#define INITIAL_TIMEOUT_VALUE 15000

#define DWORD_DATA_NAME    1
#define BINARY_DATA_NAME   2
#define STRING_DATA_NAME   3
#define BAD_BINARY_DATA_NAME 4

#define DWORD_DATA_NAME_INHERIT 5
#define DWORD_DATA_NAME_NO_INHERIT 6

#define REFERENCE_DATA_NAME  7

#define EXPANDSZ_DATA_NAME   8

#define MULTISZ_DATA_NAME   9

#define INSERT_PATH_DATA_NAME  10

#define MAX_DATA_ENTRIES   5
#define MY_GREATEROF(p1,p2) ((p1) > (p2))?(p1):(p2)
#define MAX_BUFFER_LEN     MY_GREATEROF((MD_TEST_MAX_STRING_LEN * sizeof(TCHAR)), MD_TEST_MAX_BINARY_LEN)
#define BUFFER_SIZE        5000

#define HUNDREDNANOSECONDSPERSECOND (DWORDLONG)10000000
#define HUNDREDNANOSECONDSPERMINUTE (HUNDREDNANOSECONDSPERSECOND * (DWORDLONG)60)
#define HUNDREDNANOSECONDSPERHOUR (HUNDREDNANOSECONDSPERMINUTE * (DWORDLONG)60)
#define HUNDREDNANOSECONDSPERDAY (HUNDREDNANOSECONDSPERHOUR * (DWORDLONG)24)
#define HUNDREDNANOSECONDSPERYEAR ((HUNDREDNANOSECONDSPERDAY * (DWORDLONG)365) + (HUNDREDNANOSECONDSPERDAY / (DWORDLONG)4))

#define INSERT_PATH_DATA L##"The path be inserted here: " MD_INSERT_PATH_STRINGW L##":Before here"

#define SET_GETALL_PARMS(p1) dwBufferSize = BUFFER_SIZE;dwNumDataEntries = MAX_DATA_ENTRIES;dwDataSetNumber=0;for (i=0;i<p1;i++){structDataEntries[i].pbMDData=binDataEntries[i];}

#define RELEASE_INTERFACE(p)\
{\
  IUnknown* pTmp = (IUnknown*)p;\
  p = NULL;\
  if (NULL != pTmp)\
    pTmp->Release();\
}

DWORD g_dwSecurityFlags = 0;

VOID
PrintTime(PFILETIME pftTime)
{
    DWORDLONG dwlTime = *(PDWORDLONG)pftTime;
    printf("Year = %d\n", ((DWORD)(dwlTime / (DWORDLONG)HUNDREDNANOSECONDSPERYEAR)) + 1601);
    printf("Day = %d\n", (DWORD)((dwlTime % (DWORDLONG)HUNDREDNANOSECONDSPERYEAR) / (DWORDLONG)HUNDREDNANOSECONDSPERDAY));
    printf("Time = %d minutes\n", (DWORD)((dwlTime % (DWORDLONG)HUNDREDNANOSECONDSPERDAY) / (DWORDLONG)HUNDREDNANOSECONDSPERMINUTE));

    ULARGE_INTEGER uliTime = *(PULARGE_INTEGER)pftTime;
    printf("Time High Word = %X, Low Word = %X\n", uliTime.HighPart, uliTime.LowPart);

}

LPSTR
ConvertDataTypeToString(DWORD dwDataType)
{
    LPSTR strReturn;
    switch (dwDataType) {
    case DWORD_METADATA:
        strReturn = "DWORD";
        break;
    case STRING_METADATA:
        strReturn = "STRING";
        break;
    case BINARY_METADATA:
        strReturn = "BINARY";
        break;
    case EXPANDSZ_METADATA:
        strReturn = "EXPANDSZ";
        break;
    case MULTISZ_METADATA:
        strReturn = "MULTISZ";
        break;
    case ALL_METADATA:
        strReturn = "ALL";
        break;
    default:
        strReturn = "Invalid Data Type";
    }
    return (strReturn);
}

VOID
PrintDataBuffer(PMETADATA_RECORD pmdrData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x, DataTag = %x",
        pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes, pmdrData->dwMDUserType,
        ConvertDataTypeToString(pmdrData->dwMDDataType), pmdrData->dwMDDataLen, pmdrData->dwMDDataTag);
    if (bPrintData) {
        printf(", Data = ");
        if (pmdrData->pbMDData != NULL) {
            switch (pmdrData->dwMDDataType) {
            case DWORD_METADATA:
                printf("%x", *(DWORD *)(pmdrData->pbMDData));
                break;
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                printf("%S", (LPTSTR)(pmdrData->pbMDData));
                break;
            case BINARY_METADATA:
                for (i = 0; i < pmdrData->dwMDDataLen; i++) {
                    printf("%.2x ", ((PBYTE)(pmdrData->pbMDData))[i]);
                }
                break;
            case MULTISZ_METADATA:
                printf("\n\t");
                LPTSTR pszData = (LPTSTR) pmdrData->pbMDData;
                for (i = 0; i < (pmdrData->dwMDDataLen / sizeof(TCHAR)); i++) {
                    if (pszData[i] != '\0') {
                        printf("%C", pszData[i]);
                    }
                    else {
                        printf("\n\t");
                    }
                }
                break;
            }
        }
        else {
            printf("NULL");
        }
    }
    printf("\n");
}

VOID
PrintGetAllDataBuffer(PBYTE pbBase, PMETADATA_GETALL_RECORD pmdgarData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x, DataTag = %x",
        pmdgarData->dwMDIdentifier, pmdgarData->dwMDAttributes, pmdgarData->dwMDUserType,
        ConvertDataTypeToString(pmdgarData->dwMDDataType), pmdgarData->dwMDDataLen, pmdgarData->dwMDDataTag);
    if (bPrintData) {
        PBYTE pbData;
        if (pmdgarData->dwMDDataTag != 0) {
            printf(", Reference Data Address = 0x%x", (DWORD)pmdgarData->pbMDData);
        }
        else {
            printf(", Data = ");
            pbData = pbBase + (pmdgarData->dwMDDataOffset);
            switch (pmdgarData->dwMDDataType) {
            case DWORD_METADATA:
                printf("%x", *(DWORD *)pbData);
                break;
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                printf("%S", (LPTSTR)pbData);
                break;
            case BINARY_METADATA:
                for (i = 0; i < pmdgarData->dwMDDataLen; i++) {
                    printf("%.2x ", ((PBYTE)pbData)[i]);
                }
                break;
            case MULTISZ_METADATA:
                printf("\n\t");
                LPTSTR pszData = (LPTSTR) pbData;
                for (i = 0; i < (pmdgarData->dwMDDataLen / sizeof(TCHAR)); i++) {
                    if (pszData[i] != '\0') {
                        printf("%C", pszData[i]);
                    }
                    else {
                        printf("\n\t");
                    }
                }
                break;
            }
        }
    }
    printf("\n");
}

LPSTR ConvertReturnCodeToString(DWORD ReturnCode)
{
    LPSTR RetCode = NULL;
    switch (ReturnCode) {
    case ERROR_SUCCESS:
        RetCode = "ERROR_SUCCESS";
        break;
    case ERROR_PATH_NOT_FOUND:
        RetCode = "ERROR_PATH_NOT_FOUND";
        break;
    case ERROR_INVALID_HANDLE:
        RetCode = "ERROR_INVALID_HANDLE";
        break;
    case ERROR_INVALID_DATA:
        RetCode = "ERROR_INVALID_DATA";
        break;
    case ERROR_INVALID_PARAMETER:
        RetCode = "ERROR_INVALID_PARAMETER";
        break;
    case ERROR_NOT_SUPPORTED:
        RetCode = "ERROR_NOT_SUPPORTED";
        break;
    case ERROR_ACCESS_DENIED:
        RetCode = "ERROR_ACCESS_DENIED";
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        RetCode = "ERROR_NOT_ENOUGH_MEMORY";
        break;
    case ERROR_FILE_NOT_FOUND:
        RetCode = "ERROR_FILE_NOT_FOUND";
        break;
    case ERROR_DUP_NAME:
        RetCode = "ERROR_DUP_NAME";
        break;
    case ERROR_PATH_BUSY:
        RetCode = "ERROR_PATH_BUSY";
        break;
    case ERROR_NO_MORE_ITEMS:
        RetCode = "ERROR_NO_MORE_ITEMS";
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        RetCode = "ERROR_INSUFFICIENT_BUFFER";
        break;
    case ERROR_PROC_NOT_FOUND:
        RetCode = "ERROR_PROC_NOT_FOUND";
        break;
    case ERROR_INTERNAL_ERROR:
        RetCode = "ERROR_INTERNAL_ERROR";
        break;
    case MD_ERROR_NOT_INITIALIZED:
        RetCode = "MD_ERROR_NOT_INITIALIZED";
        break;
    case MD_ERROR_DATA_NOT_FOUND:
        RetCode = "MD_ERROR_DATA_NOT_FOUND";
        break;
    case MD_ERROR_INVALID_VERSION:
        RetCode = "MD_ERROR_INVALID_VERSION";
        break;
    case MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE:
        RetCode = "MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE";
        break;
    case ERROR_ALREADY_EXISTS:
        RetCode = "ERROR_ALREADY_EXISTS";
        break;
    case MD_WARNING_PATH_NOT_FOUND:
        RetCode = "MD_WARNING_PATH_NOT_FOUND";
        break;
    case MD_WARNING_DUP_NAME:
        RetCode = "MD_WARNING_DUP_NAME";
        break;
    case MD_WARNING_INVALID_DATA:
        RetCode = "MD_WARNING_INVALID_DATA";
        break;
    case ERROR_INVALID_NAME:
        RetCode = "ERROR_INVALID_NAME";
        break;
    case REGDB_E_CLASSNOTREG:
        RetCode = "REGDB_E_CLASSNOTREG";
        break;
    case ERROR_NO_SYSTEM_RESOURCES:
        RetCode = "ERROR_NO_SYSTEM_RESOURCES";
        break;
    default:
        RetCode = "Unrecognized Error Code";
        break;
    }
    return (RetCode);
}

DWORD ConvertHresToDword(HRESULT hRes)
{
    return HRESULTTOWIN32(hRes);
}

LPSTR ConvertHresToString(HRESULT hRes)
{
    LPSTR strReturn = NULL;

    if ((HRESULT_FACILITY(hRes) == FACILITY_WIN32) ||
        (HRESULT_FACILITY(hRes) == FACILITY_INTERNET) ||
        (hRes == 0)) {
        strReturn = ConvertReturnCodeToString(ConvertHresToDword(hRes));
    }
    else {
        strReturn = "Unrecognized hRes facility";
    }
    return(strReturn);
}

void
ConsumeRegistry(IMDCOM * pcCom, METADATA_HANDLE hHandle, LPTSTR pszPath, DWORD dwUnitSize = 10000);

void
ConsumeRegistry(IMDCOM * pcCom, METADATA_HANDLE hHandle, LPTSTR pszPath, DWORD dwUnitSize)
{
    METADATA_RECORD mdrData;
    HRESULT hRes = ERROR_SUCCESS;
    DWORD i;

    BYTE *bData = new BYTE[dwUnitSize];

    if (bData != NULL) {

        for (i = 0; i < dwUnitSize; i++) {
            bData[i] = 0;
        }

        for (i = 0; SUCCEEDED(hRes); i++) {
            MD_SET_DATA_RECORD(&mdrData, i, METADATA_NO_ATTRIBUTES, 0, BINARY_METADATA, dwUnitSize, bData)
            hRes = pcCom->ComMDSetMetaData(hHandle,
                pszPath,
                &mdrData);
            printf("MDSetMetaData(hHandle, %s, &mdrData); Returns %s\n",
                pszPath,
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                hRes = pcCom->ComMDSaveData();
                printf("\nMDSaveData(); Returns hRes = %X, %s\n",
                    hRes,
                    ConvertHresToString(hRes));

            }
            (bData[i % dwUnitSize])++;
        }
        delete (bData);
    }
}

DWORD
SetMultisz(LPWSTR pszBuffer, LPWSTR ppszStrings[], DWORD dwNumStrings)
{
    DWORD i;
    LPWSTR pszIndex = pszBuffer;

    for (i = 0; i < dwNumStrings; i++) {
        wcscpy(pszIndex, ppszStrings[i]);
        pszIndex += wcslen(pszIndex) + 1;
    }

    *pszIndex = (WCHAR)'\0';

    return (((pszIndex - pszBuffer) + 1) * sizeof(WCHAR));

}

DWORD
GetMultiszDataLen(LPTSTR pszData)
{
    DWORD i;

    for (i = 1; (pszData[i-1] != (TCHAR)'\0') || (pszData[i] != (TCHAR)'\0'); i++) {
    }

    return((i + 1) * sizeof(WCHAR));
}

DWORD __cdecl
main( INT    cArgs,
      char * pArgs[] )
{
    DWORD RetCode;
    DWORD TestDword = 3;
    int TestBinary[] = {1,2,3,4};
    int i, j, ReturnIndex;
    DWORD ReturnDword = 0;
    DWORD ReturnAttributes = 0;
    DWORD ReturnDataType = 0;
    DWORD ReturnUserType = 0;
    METADATA_RECORD mdrData;
    UCHAR ReturnBuf[MAX_BUFFER_LEN];
    DWORD ReturnDataLen = sizeof(ReturnBuf);
    DWORD dwRequiredDataLen = 0;
    DWORD dwRequiredBufferLen = 0;
    TCHAR NameBuf[METADATA_MAX_NAME_LEN];
    METADATA_HANDLE OpenHandle, RootHandle;
    DWORD ReturnDataIdentifier;
    METADATA_RECORD structDataEntries[MAX_DATA_ENTRIES];
    BYTE binDataEntries[MAX_DATA_ENTRIES][MAX_BUFFER_LEN];
    DWORD dwNumDataEntries;
    BYTE pbBuffer[BUFFER_SIZE];
    DWORD dwBufferSize = BUFFER_SIZE;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = NULL;
    OLECHAR rgchName[256];
    DWORD dwSystemChangeNumber;
    DWORD dwDataSetNumber;
    METADATA_HANDLE_INFO mhiInfo;
    FILETIME ftTime;
    LPTSTR ppszData[10];
    DWORD dwMultiszLen;

    IClassFactory * pcsfFactory = NULL;
    IClassFactory * pcsfFactory2 = NULL;
    IMDCOM * pcCom = NULL;
    HRESULT hRes;
    CImpIMDCOMSINK *pEventSink = new CImpIMDCOMSINK();
    CImpIMDCOMSINKW *pEventSinkW = new CImpIMDCOMSINKW();
    IConnectionPoint* pConnPoint = NULL;
    IConnectionPoint* pConnPointW = NULL;
    IConnectionPointContainer* pConnPointContainer = NULL;
    DWORD dwCookie;
    BOOL bSinkConnected = FALSE;
    BOOL bSinkConnectedW = FALSE;

    if (cArgs > 1) {
        j = 1;

        if (_stricmp(pArgs[1], "-s") == 0) {
            g_dwSecurityFlags = METADATA_SECURE;
            j++;
        }

        if (j < cArgs) {
            for (i = 0; pArgs[j][i] != '\0'; i++) {
                rgchName[i] = (OLECHAR) pArgs[j][i];
            }
            csiName.pwszName =  rgchName;
            csiName.pAuthInfo = NULL;
            pcsiParam = &csiName;
        }
    }

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hRes)) {
        printf("CoInitializeEx Failed\n");
    }
/*
    hRes = CoCreateInstance(GETMDCLSID(TRUE), NULL, CLSCTX_SERVER, IID_IMDCOM, (void**) &pcCom);
    if (FAILED(hRes)) {
        printf("CoCreateInstance Attaching to service failed, hRes = %X\n", hRes);
        hRes = CoCreateInstance(GETMDCLSID(FALSE), NULL, CLSCTX_SERVER, IID_IMDCOM, (void**) &pcCom);
    }
    if (FAILED(hRes)) {
        printf("CoCreateInstance attaching to exe failed, hRes = %X\n", hRes);
    }
    else {
*/

    hRes = CoGetClassObject(GETMDCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
    hRes = CoGetClassObject(GETMDCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory2);
    printf("CoGetClassObject(GETMDCLSID(TRUE), ...; Returns hRes = %x, %s\n",
        hRes, ConvertHresToString(hRes));
    if (FAILED(hRes)) {
        hRes = CoGetClassObject(GETMDCLSID(FALSE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
        printf("CoGetClassObject(GETMDCLSID(FALSE), ...; Returns hRes = %x, %s\n",
            hRes, ConvertHresToString(hRes));
    }

    if (FAILED(hRes)) {
    }
    else {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMDCOM, (void **) &pcCom);
        printf("Factory->CreateInstance(...); Returns hRes = %X, %s\n",
            hRes, ConvertHresToString(hRes));

        pcsfFactory->Release();
        printf("Factory->Release() called\n");

        if (FAILED(hRes)) {
            printf("Factory->CreateInstance failed, hRes = %X\n", hRes);
        }
        else {
/*
        hRes = pcCom->ComMDInitialize();

        hRes = pcCom->ComMDAddMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof("Garbage"), (unsigned char *)"Garbage");

        hRes = pcCom->ComMDTerminate(FALSE);

        hRes = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(""), (PBYTE)"", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
        printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
            ConvertHresToString(hRes));
*/


        // First query the object for its Connection Point Container. This
        // essentially asks the object in the server if it is connectable.
        hRes = pcCom->QueryInterface(
               IID_IConnectionPointContainer,
               (PVOID *)&pConnPointContainer);
        if SUCCEEDED(hRes)
        {
          // Find the requested Connection Point. This AddRef's the
          // returned pointer.
          hRes = pConnPointContainer->FindConnectionPoint(IID_IMDCOMSINK_A, &pConnPoint);
          if (SUCCEEDED(hRes)) {
              hRes = pConnPoint->Advise((IUnknown *)pEventSink, &dwCookie);
              if (SUCCEEDED(hRes)) {
                  bSinkConnected = TRUE;
              }
              printf("pConnPoint->Advise((IUnknown *)pEventSink, &dwCookie); Returns %s\n", ConvertHresToString(hRes));
          }

          hRes = pConnPointContainer->FindConnectionPoint(IID_IMDCOMSINK_W, &pConnPointW);
          if (SUCCEEDED(hRes)) {
              hRes = pConnPointW->Advise((IUnknown *)pEventSinkW, &dwCookie);
              if (SUCCEEDED(hRes)) {
                  bSinkConnectedW = TRUE;
              }
              printf("pConnPointW->Advise((IUnknown *)pEventSink, &dwCookie); Returns %s\n", ConvertHresToString(hRes));
          }

          RELEASE_INTERFACE(pConnPointContainer);
        }


        hRes = pcCom->ComMDInitialize();
        printf("MDInitialize(); Returns %s\n", ConvertHresToString(hRes));

        if (SUCCEEDED(hRes))  {

            hRes = pcCom->ComMDInitialize();
            printf("MDInitialize(); Returns %s\n", ConvertHresToString(hRes));

            if (SUCCEEDED(hRes))  {
                hRes = pcCom->ComMDTerminate(FALSE);
                printf("\nMDTerminate(FALSE); Returns %s\n",
                    ConvertHresToString(hRes));
            }

            hRes = pcCom->ComMDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, TEXT("Root Object"), &ftTime);
            printf("MDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->ComMDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, NULL, &ftTime);
            printf("MDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, NULL, &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            hRes = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, INITIAL_TIMEOUT_VALUE, &RootHandle);
            printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, \"\", METADATA_PERMISSION_WRITE || METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
                ConvertHresToString(hRes));

            if (!FAILED(hRes)) {

                hRes = pcCom->ComMDDeleteAllMetaData(RootHandle, TEXT("Root Object"), ALL_METADATA, ALL_METADATA);
                printf("MDDeleteAllMetaData(RootHandle, TEXT(\"Root Object\"), ALL_METADATA, ALL_METADATA); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteAllMetaData(RootHandle, TEXT("junk 1"), ALL_METADATA, ALL_METADATA);
                printf("MDDeleteAllMetaData(RootHandle, TEXT(\"junk 1\"), ALL_METADATA, ALL_METADATA); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteChildMetaObjects(RootHandle, TEXT("junk 1"));
                printf("MDDeleteChildObjects(RootHandle, TEXT(\"junk 1\"); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteChildMetaObjects(RootHandle, TEXT("Root Object"));
                printf("MDDeleteChildObjects(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaObject(RootHandle, TEXT("Root Object"));
                printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                    ConvertHresToString(hRes));

                //
                // Delete everything we created last time.
                //

                hRes = pcCom->ComMDDeleteMetaObject(RootHandle, TEXT("junk 1"));
                printf("MDDeleteMetaObject(RootHandle, TEXT(\"junk 1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetHandleInfo(RootHandle, &mhiInfo);
                printf("MDGetHandleInfo(RootHandle, &mhiInfo); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Handle Change Number = %d, Handle Permissions = %X\n", mhiInfo.dwMDSystemChangeNumber, mhiInfo.dwMDPermissions);
                }

                hRes = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, TEXT(""), METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
                printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, \"\", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDAddMetaObject(RootHandle, TEXT("junk 1/junk 2/junk 3/junk 4"));
                printf("MDAddMetaObject(RootHandle, \"junk 1/junk 2/junk 3/junk 4\"); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                hRes = pcCom->ComMDAddMetaObject(RootHandle,
                    TEXT( "junk 1/This is a very long name for a metaobject and should generate an error")
                    TEXT(" qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf")
                    TEXT(" fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf 012345"));
                printf("MDAddMetaObject(RootHandle, \"junk 1/This is a very long name for a metaobject and should generate"
                       " an error qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf"
                       " fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf\"));"
                       " Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                hRes = pcCom->ComMDAddMetaObject(RootHandle, TEXT("Root Object"));
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                    ConvertHresToString(hRes));

//                ConsumeRegistry(pcCom, RootHandle, "Root Object");

                hRes = pcCom->ComMDAddMetaObject(RootHandle, TEXT("Root Object/Child Object1"));
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1"), &ftTime);
                printf("MDGetLastChangeTime(RootHandle, TEXT(\"Root Object/Child Object1\"), &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDAddMetaObject(RootHandle, TEXT("Root Object/Child Object2"));
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDAddMetaObject(RootHandle, TEXT("Root Object/Child Object2"));
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1"), &ftTime);
                printf("MDGetLastChangeTime(RootHandle, TEXT(\"Root Object/Child Object1\"), &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDAddMetaObject(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"));
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1"), &ftTime);
                printf("MDGetLastChangeTime(RootHandle, TEXT(\"Root Object/Child Object1\"), &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDAddMetaObject(RootHandle, TEXT("Root Object/Reference Object1"));
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDAddMetaObject(RootHandle, TEXT("Root Object/Subject Object1"));
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Subject Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetDataSetNumber(RootHandle, TEXT("Root Object/Child Object1"), &dwDataSetNumber);
                printf("MDGetDataSetNumber(RootHandle,TEXT(\"Root Object/Child Object1\"), &dwDataSetNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Data Set Number = %d\n", dwDataSetNumber);
                }

                hRes = pcCom->ComMDGetDataSetNumber(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &dwDataSetNumber);
                printf("MDGetDataSetNumber(RootHandle,TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &dwDataSetNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Data Set Number = %d\n", dwDataSetNumber);
                }

                hRes = pcCom->ComMDGetDataSetNumber(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1/Doesn't Exist"), &dwDataSetNumber);
                printf("MDGetDataSetNumber(RootHandle,TEXT(\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\"), &dwDataSetNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Data Set Number = %d\n", dwDataSetNumber);
                }

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, 4, NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, 0, NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),&mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                ppszData[0] = TEXT("Hello ");
                ppszData[1] = TEXT("World ");
                ppszData[2] = TEXT("Test ");
                dwMultiszLen = SetMultisz((LPWSTR)binDataEntries, ppszData, 3);
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, dwMultiszLen - 1, (PBYTE)binDataEntries)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                ppszData[0] = TEXT("Hello ");
                ppszData[1] = TEXT("World ");
                ppszData[2] = TEXT("Test ");
                dwMultiszLen = SetMultisz((LPTSTR)binDataEntries, ppszData, 3);
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, dwMultiszLen, (PBYTE)binDataEntries)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),&mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                ppszData[0] = TEXT("Hello ");
                ppszData[1] = INSERT_PATH_DATA;
                ppszData[2] = TEXT("Test ");
                dwMultiszLen = SetMultisz((LPTSTR)binDataEntries, ppszData, 3);
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_INSERT_PATH | METADATA_INHERIT, 0, MULTISZ_METADATA, dwMultiszLen, (PBYTE)binDataEntries)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME,  METADATA_INSERT_PATH | METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),&mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include the MULTISZ Data %x without path replacement ID. Get normally.\n", MULTISZ_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        TEXT("Root Object/Child Object1/GrandChild Object1"),
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include the MULTISZ Data %x with path replacement ID. Get normally.\n", MULTISZ_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_INSERT_PATH, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        TEXT("Root Object/Child Object1/GrandChild Object1"),
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                hRes = pcCom->ComMDGetDataSetNumber(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1/Doesn't Exist"), &dwDataSetNumber);
                printf("MDGetDataSetNumber(RootHandle,TEXT(\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\"), &dwDataSetNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Data Set Number = %d\n", dwDataSetNumber);
                }

                hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    DWORD_DATA_NAME, ALL_METADATA);

                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), DWORD_DATA_NAME, ALL_METADATA); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetDataSetNumber(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1/Doesn't Exist"), &dwDataSetNumber);
                printf("MDGetDataSetNumber(RootHandle,TEXT(\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\"), &dwDataSetNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Data Set Number = %d\n", dwDataSetNumber);
                }

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }


/*
                hRes = pcCom->ComMDSetReferenceObject(RootHandle, TEXT("Root Object/Reference Object1"),
                    RootHandle, TEXT("Root Object/Reference Object1");
                printf("MDSetReferenceObject(RootHandle, TEXT(\"Root Object/Reference Object1\"),\n\tRootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));
*/

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),&mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword);
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object"), &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object"), &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &ftTime);
                printf("MDGetLastChangeTime(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof(TEXT("STRING Data")), TEXT("STRING Data"))
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, EXPANDSZ_METADATA, sizeof(TEXT("STRING Data")), TEXT("STRING Data"))
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof(TEXT("STRING Data for Binary Name")), TEXT("STRING Data for Binary Name"))
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));


                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(TestBinary), (PBYTE)TestBinary)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, BAD_BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, 0x80000000, (PBYTE)TestBinary)
                PrintDataBuffer(&mdrData, FALSE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                if (pcsiParam == NULL) {

                    printf("\nTESTING REFERENCE DATA\n\n");

                    MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, STRING_METADATA, sizeof(TEXT("STRING Data")), TEXT("STRING Data"))
                    PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                    hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                        &mdrData);
                    printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));

                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }
                    else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                        printf("DataLen = %X\n", dwRequiredDataLen);
                    }

                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                        hRes = pcCom->ComMDAddRefReferenceData(mdrData.dwMDDataTag);
                        printf("MDAddRefReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                            ConvertHresToString(hRes));
                        hRes = pcCom->ComMDReleaseReferenceData(mdrData.dwMDDataTag);
                        printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                            ConvertHresToString(hRes));
                        hRes = pcCom->ComMDReleaseReferenceData(mdrData.dwMDDataTag);
                        printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                            ConvertHresToString(hRes));
                    }
                    else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                        printf("DataLen = %X\n", dwRequiredDataLen);
                    }

                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                        hRes = pcCom->ComMDReleaseReferenceData(mdrData.dwMDDataTag);
                        printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                            ConvertHresToString(hRes));
                    }
                    else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                        printf("DataLen = %X\n", dwRequiredDataLen);
                    }

                    hRes = ERROR_SUCCESS;
                    printf("\nThis Enum should include the reference ID %x. Get normally.\n", REFERENCE_DATA_NAME);
                    for (i=0;hRes == ERROR_SUCCESS; i++) {
                        FILL_RETURN_BUFF;
                        MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                        PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                        hRes = pcCom->ComMDEnumMetaData(RootHandle,
                            TEXT("Root Object/Child Object1/GrandChild Object1"),
                            &mdrData, i, &dwRequiredDataLen);
                        printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                            ConvertHresToString(hRes));
                        if (hRes == ERROR_SUCCESS) {
                            PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                            if (mdrData.dwMDDataTag != 0) {
                                hRes = pcCom->ComMDReleaseReferenceData(mdrData.dwMDDataTag);
                                printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                                    ConvertHresToString(hRes));

                            }
                        }
                    }

                    hRes = ERROR_SUCCESS;
                    printf("\nThis Enum should include the reference ID %x. Get by reference.\n", REFERENCE_DATA_NAME);
                    for (i=0;hRes == ERROR_SUCCESS; i++) {
                        FILL_RETURN_BUFF;
                        MD_SET_DATA_RECORD(&mdrData, 0, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                        PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                        hRes = pcCom->ComMDEnumMetaData(RootHandle,
                            TEXT("Root Object/Child Object1/GrandChild Object1"),
                            &mdrData, i, &dwRequiredDataLen);
                        printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                            ConvertHresToString(hRes));
                        if (hRes == ERROR_SUCCESS) {
                            PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                            if (mdrData.dwMDDataTag != 0) {
                                hRes = pcCom->ComMDReleaseReferenceData(mdrData.dwMDDataTag);
                                printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                                    ConvertHresToString(hRes));

                            }
                        }
                    }

                    SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                    printf("\nThis GetAll should include the reference ID %x. Get normally.\n", REFERENCE_DATA_NAME);
                    hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                        TEXT("Root Object/Child Object1/GrandChild Object1"),
                        METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                        &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                    printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                           "\tMETADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                           " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                           ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                            PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))), TRUE, "GetAll Output Values");
                            DWORD dwDT = ((PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))))->dwMDDataTag;
                            if (dwDT != 0) {
                                hRes = pcCom->ComMDReleaseReferenceData(dwDT);
                                printf("MDReleaseReferenceData(dwDT); Returns %s\n",
                                    ConvertHresToString(hRes));

                            }
                        }
                    }

                    SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                    printf("\nThis GetAll should include the reference ID %x. Get by reference.\n", REFERENCE_DATA_NAME);
                    hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                        TEXT("Root Object/Child Object1/GrandChild Object1"),
                        METADATA_REFERENCE, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                        &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                    printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                           "\tMETADATA_REFERENCE, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                           " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                           ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                            PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))), TRUE, "GetAll Output Values");
                            DWORD dwDT = ((PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))))->dwMDDataTag;
                            if (dwDT != 0) {
                                hRes = pcCom->ComMDReleaseReferenceData(dwDT);
                                printf("MDReleaseReferenceData(dwDT); Returns %s\n",
                                    ConvertHresToString(hRes));

                            }
                        }
                    }

                    hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                        TEXT("Root Object/Child Object1/GrandChild Object1"),
                        REFERENCE_DATA_NAME, ALL_METADATA);
                    printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), REFERENCE_DATA_NAME, ALL_METADATA); returns %s\n",
                        ConvertHresToString(hRes));

                    printf("\nEND TESTING REFERENCE DATA\n\n");

                }

                MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_INSERT_PATH | METADATA_INHERIT, 0, STRING_METADATA, sizeof(INSERT_PATH_DATA), (PBYTE)INSERT_PATH_DATA)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, TEXT("Root Object/Child Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_INSERT_PATH, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                printf("\nThis Enum should include the INSERT_PATH Data %x with path replacement ID.\n", INSERT_PATH_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_INSERT_PATH | METADATA_INHERIT, 0, STRING_METADATA, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                    else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                        printf("DataLen = %X\n", dwRequiredDataLen);
                    }
                }


                for (i = 0; i < BUFFER_SIZE; i++) {
                    pbBuffer[i] = 0xff;
                }
                dwBufferSize = 0;
                printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER.\n");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    METADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                for (i = 0; i < BUFFER_SIZE; i++) {
                    pbBuffer[i] = 0xff;
                }
                dwBufferSize = (dwRequiredBufferLen < BUFFER_SIZE) ? dwRequiredBufferLen : BUFFER_SIZE;
                printf("\nThis GetAll should include the INSERT_PATH Data %x with path replacement ID.\n", INSERT_PATH_DATA_NAME);
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    METADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, 0, (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    TEXT("Root Object/Doesn't Exist"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    TEXT("Root Object/Doesn't Exist"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), DWORD_DATA_NAME_NO_INHERIT,\n\t &ReturnAttributes, &ReturnUserType, &ReturnDataType, &ReturnDataLen, (PVOID) ReturnBuf); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    TEXT("Root Object/Doesn't Exist"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    TEXT("Root Object/Doesn't Exist"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        TEXT("Root Object/Child Object1/GrandChild Object1"),
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll is a test case of a failure reported by Philippe\n");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    TEXT("LM/W3SVC/1//Scripts"),
                    METADATA_INHERIT | METADATA_PARTIAL_PATH, 2, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"LM/W3SVC/1//Scripts\"),\n"
                       "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH,2, ALL_METADATA, &dwNumDataEntries,"
                       "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);"
                       " Returns %s\n", ConvertHresToString(hRes));
                printf("dwBufferSize = %d, dwDataSetNumber = %d\n", dwBufferSize, dwDataSetNumber);
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll is a test case of a failure reported by Philippe\n");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    TEXT("LM/W3SVC/1//Scripts/garbage/"),
                    METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"LM/W3SVC/1//Scripts/garbage/\"),\n"
                       "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                printf("dwBufferSize = %d, dwDataSetNumber = %d\n", dwBufferSize, dwDataSetNumber);
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                //SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                dwBufferSize = 0;
                printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, "
                       "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen));"
                       " Returns %s\n", ConvertHresToString(hRes));
                printf("dwRequiredBufferLen = %d, dwDataSetNumber = %d\n", dwRequiredBufferLen, dwDataSetNumber);

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                dwBufferSize = 101;
                printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, "
                       "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen));"
                       " Returns %s\n", ConvertHresToString(hRes));
                printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

                for (i = 0; i < BUFFER_SIZE; i++) {
                    pbBuffer[i] = 0xff;
                }
                dwBufferSize = (dwRequiredBufferLen < BUFFER_SIZE)? dwRequiredBufferLen : BUFFER_SIZE;
                printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        TEXT("Root Object/Child Object1/GrandChild Object1"),
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Partial Path Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        TEXT("Root Object/Doesn't Exist"),
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis Partial Path GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    TEXT("Root Object/Doesn't Exist"),
                    METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n"
                       "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Partial Path Enum should FAIL with ERROR_PATH_NOT_FOUND\n");
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf);
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        TEXT("Root Object/Doesn't Exist"),
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis Partial Path GetAll should FAIL with ERROR_PATH_NOT_FOUND\n");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    TEXT("Root Object/Doesn't Exist"),
                    METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwDataSetNumber,
                    dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n"
                       "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwDataSetNumber,"
                       " dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                hRes = pcCom->ComMDCopyMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    RootHandle,
                    TEXT("Root Object/Child Object1"),
                    METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, TRUE);
                printf("\nMDCopyMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), RootHandle,\n\tTEXT(\"Root Object/Child Object1\"), METADATA_INHERIT | METADATA_PARTIAL_PATH, 0, TRUE); Returns %s\n",
                    ConvertHresToString(hRes));

                dwBufferSize = 10;
                printf("\nThis GetMetaDataPaths should return ERROR_INSUFFICIENT_BUFFER");
                hRes = pcCom->ComMDGetMetaDataPaths(
                    RootHandle,
                    TEXT("Root Object/Child Object1"),
                    DWORD_DATA_NAME,
                    ALL_METADATA,
                    dwBufferSize,
                    (LPWSTR)pbBuffer,
                    &dwRequiredBufferLen);
                printf("\nMDGetMetaDataPaths(...) Returns %s\n", ConvertHresToString(hRes));
                printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

                for (i = 0; i < BUFFER_SIZE; i++) {
                    pbBuffer[i] = 0xff;
                }
                dwBufferSize = (dwRequiredBufferLen < (BUFFER_SIZE/ sizeof(WCHAR)))? dwRequiredBufferLen : (BUFFER_SIZE/sizeof(WCHAR));
                printf("\nThis GetMetaDataPaths should return ERROR_SUCCESS");
                hRes = pcCom->ComMDGetMetaDataPaths(
                    RootHandle,
                    TEXT("Root Object/Child Object1"),
                    DWORD_DATA_NAME,
                    ALL_METADATA,
                    dwBufferSize,
                    (LPWSTR)pbBuffer,
                    &dwRequiredBufferLen);
                printf("\nMDGetMetaDataPaths(...) Returns %s\n", ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    for (LPWSTR pszString = (LPWSTR)pbBuffer;
                         *pszString != (WCHAR)'\0';
                         pszString += (wcslen(pszString) + 1)) {
                        printf("\tReturned Path = %S\n", pszString);
                    }
                }

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, TEXT("/Root Object"), RootHandle, TEXT("junk 1/Root Object"), TRUE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"/Root Object\", RootHandle, (PBYTE)\"junk 1/Root Object\", TRUE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/junk 2/NewCopyName"), TRUE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", TRUE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/junk 2/NewCopyName"), TRUE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", TRUE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/NewCopyTree/NewCopyName"), TRUE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/NewCopyTree/NewCopyName\", TRUE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/NewCopyTree2/Root Object"), TRUE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/NewCopyTree2/Root Object\", TRUE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/junk 2/NewCopyName"), FALSE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", FALSE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                dwBufferSize = 10;
                printf("\nThis GetMetaDataPaths should return ERROR_INSUFFICIENT_BUFFER");
                hRes = pcCom->ComMDGetMetaDataPaths(
                    RootHandle,
                    TEXT("junk 1"),
                    DWORD_DATA_NAME,
                    ALL_METADATA,
                    dwBufferSize,
                    (LPWSTR)pbBuffer,
                    &dwRequiredBufferLen);
                printf("\nMDGetMetaDataPaths(...) Returns %s\n", ConvertHresToString(hRes));
                printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

                for (i = 0; i < BUFFER_SIZE; i++) {
                    pbBuffer[i] = 0xff;
                }
                dwBufferSize = (dwRequiredBufferLen < (BUFFER_SIZE/ sizeof(WCHAR)))? dwRequiredBufferLen : (BUFFER_SIZE/sizeof(WCHAR));
                printf("\nThis GetMetaDataPaths should return ERROR_SUCCESS");
                hRes = pcCom->ComMDGetMetaDataPaths(
                    RootHandle,
                    TEXT("junk 1"),
                    DWORD_DATA_NAME,
                    ALL_METADATA,
                    dwBufferSize,
                    (LPWSTR)pbBuffer,
                    &dwRequiredBufferLen);
                printf("\nMDGetMetaDataPaths(...) Returns %s\n", ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    for (LPWSTR pszString = (LPWSTR)pbBuffer;
                         *pszString != (WCHAR)'\0';
                         pszString += (wcslen(pszString) + 1)) {
                        printf("\tReturned Path = %S\n", pszString);
                    }
                }

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/junk 2/NewCopyName"), FALSE, FALSE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", FALSE, FALSE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDRenameMetaObject(RootHandle, TEXT("junk 1/junk 2/NewCopyName"), TEXT("Renamed Object Long Name To Generate Resize"));
                printf("MDRenameMetaObject(RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", (PBYTE)\"Renamed Object Long Name To Generate Resize\"); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                ftTime.dwHighDateTime = 1;
                ftTime.dwLowDateTime = 2;

                hRes = pcCom->ComMDSetLastChangeTime(RootHandle, TEXT("Root Object"), &ftTime);
                printf("MDSetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDSetLastChangeTime(RootHandle, NULL, &ftTime);
                printf("MDSetLastChangeTime(RootHandle, NULL, &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ);
                printf("MDChangePermissions(RootHandle, METADATA_PERMISSION_READ); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDOpenMetaObject(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
                printf("MDOpenMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), METADATA_PERMISSION_READ, &OpenHandle); Returns %s\n\n",
                    ConvertHresToString(hRes));

                if (hRes == ERROR_SUCCESS) {

                    hRes = pcCom->ComMDGetHandleInfo(OpenHandle, &mhiInfo);
                    printf("MDGetHandleInfo(RootHandle, &mhiInfo); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (!FAILED(hRes)) {
                        printf("Handle Change Number = %d, Handle Permissions = %X\n", mhiInfo.dwMDSystemChangeNumber, mhiInfo.dwMDPermissions);
                    }

                    for (i=0;hRes == ERROR_SUCCESS;i++) {
                        hRes = pcCom->ComMDEnumMetaObjects(OpenHandle, TEXT(""), NameBuf, i);
                        printf("MDEnumMetaObjects(OpenHandle, NULL, NameBuf, i); returns %s\n",
                            ConvertHresToString(hRes));
                    }

                    hRes = pcCom->ComMDChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                    printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                        ConvertHresToString(hRes));

                    hRes = pcCom->ComMDChangePermissions(OpenHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                    printf("MDChangePermissions(OpenHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                        ConvertHresToString(hRes));

                    hRes = pcCom->ComMDCloseMetaObject(OpenHandle);
                    printf("MDCloseMetaObject(OpenHandle); Returns %s\n\n",
                        ConvertHresToString(hRes));
                }

                for (i=0;hRes == ERROR_SUCCESS;i++) {
                    hRes = pcCom->ComMDEnumMetaObjects(RootHandle, TEXT(""), NameBuf, i);
                    printf("MDEnumMetaObjects(RootHandle, NULL, (LPTSTR)NameBuf, i); returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        printf("Object Name = %S\n", NameBuf);
                    }
                }

                hRes = pcCom->ComMDSaveData();
                printf("\nMDSaveData(); Returns %s\n",
                    ConvertHresToString(hRes));
                hRes = pcCom->ComMDSaveData(RootHandle);
                printf("\nMDSaveData(RootHandle); Returns %s\n",
                    ConvertHresToString(hRes));
                hRes = pcCom->ComMDSaveData(OpenHandle);
                printf("\nMDSaveData(OpenHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, BINARY_METADATA, 0, NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, BINARY_METADATA, 1, NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, STRING_METADATA, 0, NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, 0, 0, DWORD_METADATA, 0, NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    BINARY_DATA_NAME, BINARY_METADATA);
                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, BINARY_METADATA); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, TEXT("Root Object"), &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDSetLastChangeTime(RootHandle, TEXT("Root Object"), &ftTime);
                printf("MDSetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, TEXT("Root Object"), &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    BINARY_DATA_NAME, STRING_METADATA);
                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, STRING_METADATA); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                    TEXT("Root Object"),
                    BINARY_DATA_NAME, ALL_METADATA);
                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                    TEXT("Root Object/Trash"),
                    BINARY_DATA_NAME, ALL_METADATA);
                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Trash\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteAllMetaData(RootHandle,
                                                     TEXT("Root Object/Child Object1/GrandChild Object1"),
                                                      ALL_METADATA,
                                                      ALL_METADATA);
                printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteAllMetaData(RootHandle,
                                                     TEXT("Root Object"),
                                                      ALL_METADATA,
                                                      ALL_METADATA);
                printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaObject(RootHandle, TEXT("Root Object/Child Object1"));
                printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaObject(RootHandle, TEXT("Root Object"));
                printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteChildMetaObjects(RootHandle, TEXT("junk 1"));
                printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"junk 1\"); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDBackup(RootHandle,
                                          TEXT("NamedBackup"),
                                          MD_BACKUP_NEXT_VERSION,
                                          MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST);

                printf("\nMDBackup(...); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDBackup(RootHandle,
                                          TEXT("NamedBackup"),
                                          MD_BACKUP_NEXT_VERSION,
                                          MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST);

                hRes = pcCom->ComMDBackup(RootHandle,
                                          TEXT("NamedBackup"),
                                          27,
                                          MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST);

                printf("\nMDBackup(...); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCloseMetaObject(RootHandle);
                printf("MDCloseMetaObject(RootHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                WCHAR pszBackupName[MD_BACKUP_MAX_LEN];
                DWORD dwBackupVersion;
                FILETIME ftBackupTime;
                hRes = ERROR_SUCCESS;
                for (i = 0;SUCCEEDED(hRes);i++) {
                    pszBackupName[0] = (WCHAR)'\0';
                    hRes = pcCom->ComMDEnumBackups(pszBackupName,
                                                   &dwBackupVersion,
                                                   &ftBackupTime,
                                                   i);

                    printf("\nMDEnumBackups(...); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (SUCCEEDED(hRes)) {
                        printf("\tBackupName = %S, Backup Version = %d\n", pszBackupName, dwBackupVersion);
                    }
                }

                //
                // Restore blows away existing handles,
                // so do this here, where all handles are closed.
                //

                hRes = pcCom->ComMDRestore(TEXT("NamedBackup"),
                                           MD_BACKUP_HIGHEST_VERSION,
                                           0);

                printf("\nMDRestore(...); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteBackup(TEXT("NamedBackup"),
                                                27);

                printf("\nMDDeleteBackup(...); Returns %s\n",
                    ConvertHresToString(hRes));

            }
/*
            hRes = pcCom->ComMDRemoveCallBack(&MDCallBack);
            printf("\nMDRemoveCallBack(&MDCallBack); Returns %s\n",
                ConvertHresToString(hRes));
*/

            hRes = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, TEXT(""), METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle);
            printf("\n\nMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(\"\"), \"\", METADATA_PERMISSION_WRITE || METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
                ConvertHresToString(hRes));

            if (hRes == ERROR_SUCCESS) {

                hRes = pcCom->ComMDAddMetaObject(RootHandle, TEXT("//"));
                printf("\nMDAddMetaObject(RootHandle, TEXT(\"//\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDAddMetaObject(RootHandle, TEXT("Root Object/instance1//"));
                printf("\nMDAddMetaObject(RootHandle, TEXT(\"Root Object/instance1//\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCloseMetaObject(RootHandle);
                printf("MDCloseMetaObject(OpenHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, TEXT("Root Object/instance1/"), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &OpenHandle);
                printf("\nMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(\"Root Object/instance1/\"), (PBYTE)\"Root Object/instance1/\", METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                if (hRes == ERROR_SUCCESS) {

                    MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword);
                    PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                    hRes = pcCom->ComMDSetMetaData(OpenHandle, TEXT("//"), &mdrData);
                    printf("MDSetMetaData(OpenHandle, sizeof(\"//\"), (PBYTE)\"//\", &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));

                    MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof(TEXT("STRING Data")), TEXT("STRING Data"))
                    PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                    hRes = pcCom->ComMDSetMetaData(OpenHandle,
                        TEXT("/"),
                        &mdrData);
                    printf("MDSetMetaData(RootHandle, sizeof(\"/\"), TEXT(\"Root Object/instance1/\", &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));

                    MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, EXPANDSZ_METADATA, sizeof(TEXT("STRING Data")), TEXT("STRING Data"))
                    PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                    hRes = pcCom->ComMDSetMetaData(OpenHandle,
                        TEXT("/"),
                        &mdrData);
                    printf("MDSetMetaData(RootHandle, sizeof(\"/\"), TEXT(\"Root Object/instance1/\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));

                    printf("\nThis Get should SUCCEED.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        TEXT("//"),
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        TEXT("/"),
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should SUCCEED.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        TEXT("/"),
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should SUCCEED.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        TEXT("/"),
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should SUCCEED.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        TEXT("//"),
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should SUCCEED.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        TEXT("//"),
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        TEXT("//"),
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        TEXT("//"),
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    hRes = pcCom->ComMDCloseMetaObject(OpenHandle);
                    printf("MDCloseMetaObject(OpenHandle); Returns %s\n",
                        ConvertHresToString(hRes));
                }
            }
        }
        hRes = pcCom->ComMDTerminate(TRUE);
        printf("\nMDTerminate(FALSE); Returns %s\n",
            ConvertHresToString(hRes));

        if (bSinkConnected) {
            hRes = pConnPoint->Unadvise(dwCookie);
        }
        if (bSinkConnectedW) {
            hRes = pConnPointW->Unadvise(dwCookie);
        }
        pcCom->Release();
    }

    }
    CoFreeUnusedLibraries();

    CoUninitialize();

    delete (pEventSink);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\sec\proto.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    Contains prototype definitions for various locally defined functions.

Author:

    Madan Appiah (madana)  19-Sep-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PROTO_H_
#define _PROTO_H_

#ifdef __cplusplus
extern "C" {
#endif

PVOID
INetpMemoryAllocate(
    DWORD Size
    );

VOID
INetpMemoryFree(
    PVOID Memory
    );

DWORD
INetpInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    );

DWORD
INetpInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    );

DWORD
NetpInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    );

DWORD
INetpAllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
    );

DWORD
INetpDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    );

DWORD
INetpCreateSecurityDescriptor(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

#ifdef __cplusplus
}
#endif


#endif  // _PROTO_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\rpcref\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    main.cxx

        Library initialization for rpcref.dll  --
           This Dll adds a ref count around the RPC runtime call -
           RpcServerListen(). This enables multiple services in
           the inetinfo process to do a RpcServerListen() without
           stomping over each other.

           This Dll will maintain a ref count on calls to RpcServerListen()
           and call RpcMgmtStopServerListening() when the ref count goes to 0.

    FILE HISTORY:
        RajeevR     18-Aug-1997 Created.
*/

#include <windows.h>
#include <stdio.h>

extern "C" {
	#include <rpc.h>
};

#include <pudebug.h>
	
DWORD				cRefs = 0;
CRITICAL_SECTION	csCritRef;

extern "C"
BOOL WINAPI DLLEntry( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
	    case DLL_PROCESS_ATTACH:

	    	cRefs = 0;
	    	INITIALIZE_CRITICAL_SECTION( &csCritRef );
	    	break;
	    	
	    case DLL_PROCESS_DETACH:

	    	DeleteCriticalSection( &csCritRef );
	    	break;
	    	
    	case DLL_THREAD_ATTACH:
	    case DLL_THREAD_DETACH:
    	default:
        	break ;
    }

    return ( fReturn);

}  // main()

DWORD
InetinfoStartRpcServerListen(
    VOID
    )
/*++

Routine Description:

    This function starts RpcServerListen for this process. The first
    service that is calling this function will actually start the
    RpcServerListen, subsequent calls just bump a ref count

Arguments:

    None.

Return Value:

    None.

--*/
{

    RPC_STATUS Status = RPC_S_OK;

    EnterCriticalSection( &csCritRef );

    if( cRefs++ == 0 ) {
	    Status = RpcServerListen(
    	                1,                              // minimum num threads.
        	            RPC_C_LISTEN_MAX_CALLS_DEFAULT, // max concurrent calls.
            	        TRUE );                         // don't wait
    }

    LeaveCriticalSection( &csCritRef );

    return( Status );
}

DWORD
InetinfoStopRpcServerListen(
    VOID
    )
/*++

Routine Description:

	Bump ref count down. Last caller will do actual cleanup.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    EnterCriticalSection( &csCritRef );

	if( --cRefs == 0 ) {
	    Status = RpcMgmtStopServerListening(0);

    	//
	    // wait for all RPC threads to go away.
    	//

	    if( Status == RPC_S_OK) {
    	    Status = RpcMgmtWaitServerListen();
	    }
    }

    LeaveCriticalSection( &csCritRef );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\rdns\rdns.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rdns.cxx

Abstract:

    Reverse DNS service

Author:

    Philippe Choquier (phillich)    5-june-1996

--*/

// only need async if not every HTTP req ends up calling DNS resolution
// if async then potentially 100s of HTTP requests
// so should be sync.

// Bind(addr) @ session start
// Init(BLOB) / CheckAccess( callbakc ) / Terminate()
// callback : yes or no, post empty completion status

#define dllexp __declspec( dllexport )

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <time.h>
#include <stdio.h>
#include <malloc.h>
#include <windns.h>

#include <iis64.h>
#include <dbgutil.h>

#include <rdns.hxx>
#include <issched.hxx>
#include <isplat.h>
#include <inetsvcs.h>

#define DN_LEN  64

#define RDNS_REG_KEY    "SYSTEM\\CurrentControlSet\\Services\\InetInfo\\Parameters"
#define RDNS_REG_MAX_THREAD     "DnsMaxThread"
#define RDNS_REG_CACHE_SIZE     "DnsCacheSizeInK"
#define RDNS_REG_TTL            "DnsTTLInSeconds"
#define RDNS_REG_MAX_THREAD_DEF 0
#define RDNS_REG_CACHE_SIZE_DEF 256
// in seconds
#define RDNS_REG_TTL_DEF    (20*60)


#define RDNS_SCAVENGER_GRANULARITY  (2*60)

#define XBF_EXTEND      64
#define RDNS_HASH_SIZE  1021

#define ENTRYPTR( a, b ) (a+b-1)

#define LOCALHOST_ADDRESS        0x0100007F  // 127.0.0.1

//
// Local classes
//

class RDnsCacheEntry {
public:
    BOOL Init( UINT i );
    void Reset();
    //
    UINT RemoveFromPrio( RDnsCacheEntry* );
    UINT RemoveFromHash( RDnsCacheEntry* );
    void InsertInPrioBefore( RDnsCacheEntry*, UINT );
    void InsertInHashBefore( RDnsCacheEntry*, UINT );
    UINT GetNextHash() { return m_pHashNext; }
    UINT GetNextPrio() { return m_pPrioNext; }
    BOOL MatchAddr(struct sockaddr *, time_t tNow );
    BOOL MatchName(LPSTR pszName, time_t tNow );
    BOOL CopyName(LPSTR pszResult, DWORD dwResMaxLen)
    {
        UINT l = strlen(m_achName) + 1;
        if ( dwResMaxLen >= l  )
        {
            memcpy( pszResult, m_achName, l );
            return TRUE;
        }

        return FALSE;
    }
    BOOL CopyAddr( sockaddr* p )
    {
        memcpy( p, &m_addr, sizeof(m_addr) ); return TRUE;
    }
    DWORD GetHash() { return m_h; }
    void SetFree() { m_fIsFree = TRUE; }
    BOOL Store(struct sockaddr *pAddr, DWORD h, time_t Expire, LPSTR pszName );
    BOOL Expired( time_t tNow ) { return !m_fIsFree && m_Expire <= tNow; }
    BOOL IsIp2Dns() { return m_fIsIp2Dns; }
    VOID SetIsIp2Dns( BOOL f ) { m_fIsIp2Dns = f; }

private:
    struct sockaddr     m_addr;
    CHAR                m_achName[DN_LEN];
    UINT                m_pHashNext;
    UINT                m_pHashPrev;
    UINT                m_pPrioNext;
    UINT                m_pPrioPrev;
    UINT                m_iIndex;
    DWORD               m_h;
    BOOL                m_fIsFree;
    time_t              m_Expire;
    BOOL                m_fIsIp2Dns;
} ;


class RDnsDict {

public:
    BOOL Init()
    {
        m_cAlloc = 0;
        m_cSize = 0;
        INITIALIZE_CRITICAL_SECTION( &m_csLock );
        if ( m_FreeList = Append() )
        {
            ENTRYPTR(m_pV,m_FreeList)->Init( m_FreeList );
        }
        if ( m_PrioList = Append() )
        {
            ENTRYPTR(m_pV,m_PrioList)->Init( m_PrioList );
        }
        return TRUE;
    }

    void Terminate()
    {
        if (m_cAlloc )
        {
            LocalFree( m_pV );
        }

        DeleteCriticalSection( &m_csLock );
    }

    void Lock() { EnterCriticalSection( &m_csLock ); }
    void Unlock() { LeaveCriticalSection( &m_csLock ); }

    // Append an entry

    UINT NewEntry( struct sockaddr *pAddr, DWORD h, time_t Expire, LPSTR pszName );
    UINT NewDns2IpEntry( struct sockaddr *pAddr, DWORD h, time_t Expire, LPSTR pszName );
    DWORD ComputeHash( struct sockaddr* pAddr );
    DWORD ComputeHash( LPSTR pszName );
    BOOL Search( struct sockaddr* pAddr, DWORD h, LPSTR pszResult, DWORD dwResMaxLen );
    BOOL SearchByName( struct sockaddr* pAddr, DWORD h, LPSTR pszName );
    UINT GetFreeEntry();
    UINT Append();
    void FreeEntry( UINT i);
    void Scavenger();

private:
    UINT                m_cAlloc;       // allocated memory
    UINT                m_cSize;        // used memory
    CRITICAL_SECTION    m_csLock;
    RDnsCacheEntry*     m_pV;
    UINT                m_PrioList;
    UINT                m_FreeList;
    UINT                m_pHash[RDNS_HASH_SIZE];
    UINT                m_pDns2IpHash[RDNS_HASH_SIZE];
} ;


//
// Local functions
//

VOID
AddrCheckDnsCallBack(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    );

VOID
AddrCheckDnsCallBack2(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    );

VOID
AddrCheckDnsCallBack3(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    );

VOID
ResolveDnsCallBack(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    );

//
// globals
//

DWORD g_cCacheSize = RDNS_REG_CACHE_SIZE_DEF * 1024;
DWORD g_cTTL = RDNS_REG_TTL_DEF;
HANDLE g_hThreadsTerminated = NULL;
HANDLE g_hDnsPort = NULL;
UINT g_cThreads;
UINT g_cMaxThreadLimit = RDNS_REG_MAX_THREAD_DEF;
long g_cAvailableThreads;
RDnsDict g_RDns;
CSidCache * g_pscPen = NULL;
DWORD g_dwScavengerWorkItem = NULL;
BOOL g_fEnableRdns = TRUE;
DNSFUNCDESC g_Dns2Ip = { RDNS_REQUEST_TYPE_DNS2IP, ::AddrCheckDnsCallBack2 };
DNSFUNCDESC g_Ip2Dns = { RDNS_REQUEST_TYPE_IP2DNS, ::AddrCheckDnsCallBack};
DNSFUNCDESC g_ResolveDns = { RDNS_REQUEST_TYPE_IP2DNS, ::ResolveDnsCallBack};
DNSFUNCDESC g_ResolveDns2Ip = { RDNS_REQUEST_TYPE_DNS2IP, ::AddrCheckDnsCallBack3 };
BYTE NULL_IP_ADDR[]="\x00\x00\x00\x00";

//
//
//

dllexp
BOOL
PenAddToCache(
    PSID pS,
    DWORD dwTTL
    )
/*++

Routine Description:

    Add to Pwd Exp Notification cache

Arguments:

    pS - ptr to SID to add to cache

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    return g_pscPen->AddToCache( pS, dwTTL );
}


dllexp
BOOL
PenIsInCache(
    PSID pS
    )
/*++

Routine Description:

    Check if SID in Pwd Exp Notification cache

Arguments:

    pS - ptr to SID to check

Return Value:

    TRUE if SID in cache, FALSE otherwise

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    return g_pscPen->IsInCache( pS );
}


dllexp
BOOL
PenCheckPresentAndResetTtl(
    PSID pS,
    DWORD dwTtl
    )
/*++

Routine Description:

    Check if SID in Pwd Exp Notification cache
    and update TTL

Arguments:

    pS - ptr to SID to check
    dwTtl - new TTL value

Return Value:

    TRUE if SID in cache, FALSE otherwise

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    return g_pscPen->CheckPresentAndResetTtl( pS, dwTtl );
}


//
//
//

BOOL
RDnsCacheEntry::Init(
    UINT i
    )
/*++

Routine Description:

    Initialize a cache entry

Arguments:

    i - index (1-based) of this entry in the dict array

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    m_iIndex = i;
    Reset();

    return TRUE;
}


void
RDnsCacheEntry::Reset(
    VOID
    )
/*++

Routine Description:

    Reset a cache entry

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    m_pHashNext = NULL;     // non-circular list
    m_pHashPrev = NULL;
    m_pPrioNext = m_iIndex; // circular list
    m_pPrioPrev = m_iIndex;

    m_fIsFree = TRUE;
}


BOOL
RDnsCacheEntry::MatchAddr(
    struct sockaddr * pAddr,
    time_t tNow
    )
/*++

Routine Description:

    Check if entry match specified address and not expired

Arguments:

    pAddr - ptr to address
    tNow - current time

Return Value:

    TRUE if match and not expired, FALSE otherwise

--*/
{
    int l;
    LPBYTE p1;
    LPBYTE p2;

    DBG_ASSERT(g_fEnableRdns);
    switch ( pAddr->sa_family )
    {
        case AF_INET:
            l = SIZEOF_IP_ADDRESS;
            p1 = (LPBYTE)(&((PSOCKADDR_IN)pAddr)->sin_addr);
            p2 = (LPBYTE)(&((PSOCKADDR_IN)&m_addr)->sin_addr);
            break;
#if 0
        case AF_IPX:
            l = 6;
            p1 = (LPBYTE)(((PSOCKADDR)pAddr)->sa_data);
            p2 = (LPBYTE)(((PSOCKADDR)&m_addr)->sa_data);
            break;
#endif
        default:
            return FALSE;
    }

    return !memcmp( p1, p2, l ) && m_Expire > tNow;
}


BOOL
RDnsCacheEntry::MatchName(
    LPSTR pszName,
    time_t tNow
    )
/*++

Routine Description:

    Check if entry match specified DNS name and not expired

Arguments:

    pszName - ptr to DNS name
    tNow - current time

Return Value:

    TRUE if match and not expired, FALSE otherwise

--*/
{
    DBG_ASSERT(g_fEnableRdns);

    return !strcmp( pszName, m_achName ) && m_Expire > tNow;
}


BOOL
RDnsCacheEntry::Store(
    struct sockaddr *pAddr,
    DWORD h,
    time_t Expire,
    LPSTR pszName
    )
/*++

Routine Description:

    Store a address<>name pair with expiration time

Arguments:

    pAddr - ptr to address
    h - hash value of this address
    Expire - expiration time
    pszName - DNS name

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    int l;

    DBG_ASSERT(g_fEnableRdns);
    memcpy( &m_addr, pAddr, sizeof(m_addr) );
    if ( (l=strlen(pszName)+1) <= sizeof(m_achName) )
    {
        memcpy( m_achName, pszName, l );
    }
    else
    {
        return FALSE;
    }

    m_h = h;
    m_fIsFree = FALSE;
    m_Expire = Expire;

    return TRUE;
}


UINT
RDnsCacheEntry::RemoveFromPrio(
    RDnsCacheEntry* pE
    )
/*++

Routine Description:

    Remove from priority list

Arguments:

    pE - ptr to base of array

Return Value:

    next index in the priority list

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    if ( m_pPrioPrev )
    {
        ENTRYPTR(pE,m_pPrioPrev)->m_pPrioNext = m_pPrioNext;
    }
    if ( m_pPrioNext )
    {
        ENTRYPTR(pE,m_pPrioNext)->m_pPrioPrev = m_pPrioPrev;
    }

    return m_pPrioNext;
}


void
RDnsCacheEntry::InsertInPrioBefore(
    RDnsCacheEntry* pE,
    UINT i
    )
/*++

Routine Description:

    Insert in priority list after specified index

Arguments:

    pE - ptr to base of array
    i - index of element to insert before

Return Value:

    Nothing

--*/
{
    m_pPrioPrev = NULL;

    DBG_ASSERT(g_fEnableRdns);
    if ( i )
    {
        UINT iPrev = ENTRYPTR(pE,i)->m_pPrioPrev;
        ENTRYPTR(pE,i)->m_pPrioPrev = m_iIndex;
        if ( iPrev )
        {
            ENTRYPTR(pE,iPrev)->m_pPrioNext = m_iIndex;
            m_pPrioPrev = iPrev;
        }
    }
    m_pPrioNext = i;
}


UINT
RDnsCacheEntry::RemoveFromHash(
    RDnsCacheEntry* pE
    )
/*++

Routine Description:

    Remove from hash list

Arguments:

    pE - ptr to base of array

Return Value:

    next index in the hash list

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    if ( m_pHashPrev )
    {
        ENTRYPTR(pE,m_pHashPrev)->m_pHashNext = m_pHashNext;
    }
    if ( m_pHashNext )
    {
        ENTRYPTR(pE,m_pHashNext)->m_pHashPrev = m_pHashPrev;
    }

    return m_pHashNext;
}


void
RDnsCacheEntry::InsertInHashBefore(
    RDnsCacheEntry* pE,
    UINT i
    )
/*++

Routine Description:

    Insert in hash list after specified index

Arguments:

    pE - ptr to base of array
    i - index of element to insert before

Return Value:

    Nothing

--*/
{
    m_pHashPrev = NULL;

    DBG_ASSERT(g_fEnableRdns);
    if ( i )
    {
        UINT iPrev = ENTRYPTR(pE,i)->m_pHashPrev;
        ENTRYPTR(pE,i)->m_pHashPrev = m_iIndex;
        if ( iPrev )
        {
            ENTRYPTR(pE,iPrev)->m_pHashNext = m_iIndex;
            m_pHashPrev = iPrev;
        }
    }
    m_pHashNext = i;
}


UINT
RDnsDict::NewEntry(
    struct sockaddr *pAddr,
    DWORD h,
    time_t Expire,
    LPSTR pszName
    )
/*++

Routine Description:

    Store a address<>name pair with expiration time

Arguments:

    pAddr - ptr to address
    h - hash value of this address
    Expire - expiration time
    pszName - DNS name

Return Value:

    index (1-based) of new entry, NULL if error

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    Lock();
    UINT i = GetFreeEntry();

    if ( i )
    {
        RDnsCacheEntry *p = ENTRYPTR(m_pV,i);

        if ( !p->Store( pAddr, h, Expire, pszName ) )
        {
            // put back on free list
            p->InsertInPrioBefore( m_pV, m_FreeList );
            i = NULL;
        }
        else
        {
            p->InsertInPrioBefore( m_pV, m_PrioList );
            p->InsertInHashBefore( m_pV, m_pHash[h] );
            m_pHash[h] = i;
        }

        p->SetIsIp2Dns( TRUE );
    }

    Unlock();

    return i;
}


UINT
RDnsDict::NewDns2IpEntry(
    struct sockaddr *pAddr,
    DWORD h,
    time_t Expire,
    LPSTR pszName
    )
/*++

Routine Description:

    Store a address<>name pair with expiration time

Arguments:

    pAddr - ptr to address
    h - hash value of DNS name
    Expire - expiration time
    pszName - DNS name

Return Value:

    index (1-based) of new entry, NULL if error

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    Lock();
    UINT i = GetFreeEntry();

    if ( i )
    {
        RDnsCacheEntry *p = ENTRYPTR(m_pV,i);

        if ( !p->Store( pAddr, h, Expire, pszName ) )
        {
            // put back on free list
            p->InsertInPrioBefore( m_pV, m_FreeList );
            i = NULL;
        }
        else
        {
            p->InsertInPrioBefore( m_pV, m_PrioList );
            p->InsertInHashBefore( m_pV, m_pDns2IpHash[h] );
            m_pDns2IpHash[h] = i;
        }

        p->SetIsIp2Dns( FALSE );
    }

    Unlock();

    return i;
}


DWORD
RDnsDict::ComputeHash(
    struct sockaddr* pAddr
    )
/*++

Routine Description:

    Compute hash code of address

Arguments:

    pAddr - ptr to address

Return Value:

    Hash code <0...RDNS_HASH_SIZE>

--*/
{
    UINT x;
    UINT l;
    DWORD h = 0;
    LPBYTE p;

    DBG_ASSERT(g_fEnableRdns);
    switch ( pAddr->sa_family )
    {
        case AF_INET:
            l = SIZEOF_IP_ADDRESS;
            p = (LPBYTE)(&((PSOCKADDR_IN)pAddr)->sin_addr);
            break;

#if 0
        case AF_IPX:
            l = 6;
            p = (LPBYTE)pAddr->sa_data;
            break;
#endif

        default:
            l = 8;
            p = (LPBYTE)pAddr->sa_data;
            break;
    }

    for ( x = 0 ; x < l ; ++x )
    {
        h = ((h<<5)|(h>>27)) ^ p[x];
    }

    return h % RDNS_HASH_SIZE;
}


DWORD
RDnsDict::ComputeHash(
    LPSTR pszName
    )
/*++

Routine Description:

    Compute hash code of name

Arguments:

    pszName - DNS name

Return Value:

    Hash code <0...RDNS_HASH_SIZE>

--*/
{
    UINT x;
    UINT l;
    DWORD h = 0;
    LPBYTE p;

    DBG_ASSERT(g_fEnableRdns);

    l = strlen( pszName );
    p = (LPBYTE)pszName;

    for ( x = 0 ; x < l ; ++x )
    {
        h = ((h<<5)|(h>>27)) ^ p[x];
    }

    return h % RDNS_HASH_SIZE;
}


BOOL
RDnsDict::Search(
    struct sockaddr* pAddr,
    DWORD h,
    LPSTR pszResult,
    DWORD dwResMaxLen
    )
/*++

Routine Description:

    Search for address in cache

Arguments:

    pAddr - ptr to address
    h - hash code for address
    pszResult - ptr to array updated with name if found
    dwResMaxLen - size of pszResult array

Return Value:

    TRUE if found and stored in pszResult, otherwise FALSE

--*/
{
    UINT i = m_pHash[h];
    RDnsCacheEntry *p;
    BOOL fSt = FALSE;
    time_t tNow = time(NULL);

    DBG_ASSERT(g_fEnableRdns);
    Lock();

    while ( i )
    {
        p = ENTRYPTR(m_pV,i);
        if ( p->MatchAddr( pAddr, tNow ) )
        {
            fSt = p->CopyName( pszResult, dwResMaxLen );

            // update position in LRU list
            p->RemoveFromPrio( m_pV );
            p->InsertInPrioBefore( m_pV, m_PrioList );

            break;
        }
        i = p->GetNextHash();
    }

    Unlock();

    return fSt;
}


BOOL
RDnsDict::SearchByName(
    struct sockaddr* pAddr,
    DWORD h,
    LPSTR pszName
    )
/*++

Routine Description:

    Search for name in cache

Arguments:

    pAddr - ptr to address
    h - hash code for address
    pszName - name to search for

Return Value:

    TRUE if found and stored in pAddr, otherwise FALSE

--*/
{
    UINT i = m_pDns2IpHash[h];
    RDnsCacheEntry *p;
    BOOL fSt = FALSE;
    time_t tNow = time(NULL);

    DBG_ASSERT(g_fEnableRdns);
    Lock();

    while ( i )
    {
        p = ENTRYPTR(m_pV,i);
        if ( p->MatchName( pszName, tNow ) )
        {
            fSt = p->CopyAddr( pAddr );

            // update position in LRU list
            p->RemoveFromPrio( m_pV );
            p->InsertInPrioBefore( m_pV, m_PrioList );

            break;
        }
        i = p->GetNextHash();
    }

    Unlock();

    return fSt;
}


UINT
RDnsDict::GetFreeEntry(
    VOID
    )
/*++

Routine Description:

    Get a free entry in cache array

Arguments:

    None

Return Value:

    index ( 1-based ) of free element to use

--*/
{
    UINT i;
    UINT iN;
    RDnsCacheEntry *p;

    DBG_ASSERT(g_fEnableRdns);
    if ( m_PrioList == NULL || m_FreeList == NULL )
    {
        return NULL;
    }

    i = ENTRYPTR(m_pV,m_FreeList)->GetNextPrio();

    if ( i != m_FreeList )
    {
        ENTRYPTR(m_pV,i)->RemoveFromPrio( m_pV );
        ENTRYPTR(m_pV,i)->Reset();
    }
    else
    {
        if ( i = Append() )
        {
            ENTRYPTR(m_pV,i)->Init( i );
        }
        else
        {
            // get from LRU

            i = ENTRYPTR(m_pV,m_PrioList)->GetNextPrio();

            if ( i != m_PrioList )
            {
                // remove from hash list

                p = ENTRYPTR(m_pV,i);
                p->RemoveFromPrio( m_pV );
                iN = p->RemoveFromHash(m_pV);
                // if hash entry pointed to this element, update hash entry
                if ( p->IsIp2Dns() )
                {
                    if ( m_pHash[p->GetHash()] == i )
                    {
                        m_pHash[p->GetHash()] = iN;
                    }
                }
                else
                {
                    if ( m_pDns2IpHash[p->GetHash()] == i )
                    {
                        m_pDns2IpHash[p->GetHash()] = iN;
                    }
                }
                p->Reset();
            }
            else
            {
                return NULL;
            }
        }
    }

    return i;
}


UINT
RDnsDict::Append(
    VOID
    )
/*++

Routine Description:

    Append an entry to the cache array

Arguments:

    None

Return Value:

    index ( 1-based ) of new element

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    if ( m_cSize + 1 > m_cAlloc )
    {
        int cNew = (( m_cSize + 1 + XBF_EXTEND )/XBF_EXTEND)*XBF_EXTEND;
        if ( cNew*sizeof(RDnsCacheEntry) > g_cCacheSize )
        {
            return NULL;
        }
        LPBYTE pN = (LPBYTE)LocalAlloc( LMEM_FIXED, cNew*sizeof(RDnsCacheEntry) );
        if ( pN == NULL )
        {
            return NULL;
        }
        if ( m_cSize )
        {
            memcpy( pN, m_pV, m_cSize*sizeof(RDnsCacheEntry) );
        }
        if ( m_cAlloc )
        {
            LocalFree( m_pV );
        }
        m_pV = (RDnsCacheEntry*)pN;
        m_cAlloc = cNew;
    }
    return ++m_cSize;
}


void
RDnsDict::FreeEntry(
    UINT i
    )
/*++

Routine Description:

    Free an element in the cache array, put it on free list

Arguments:

    index ( 1-based ) of element to be freed

Return Value:

    Nothing

--*/
{
    DBG_ASSERT(g_fEnableRdns);

    UINT iN;
    RDnsCacheEntry *p = ENTRYPTR(m_pV,i);

    iN = p->RemoveFromHash(m_pV);
    // if hash entry pointed to this element, update hash entry
    if ( p->IsIp2Dns() )
    {
        if ( m_pHash[p->GetHash()] == i )
        {
            m_pHash[p->GetHash()] = iN;
        }
    }
    else
    {
        if ( m_pDns2IpHash[p->GetHash()] == i )
        {
            m_pDns2IpHash[p->GetHash()] = iN;
        }
    }
    p->SetFree();

    p->RemoveFromPrio( m_pV );
    p->InsertInPrioBefore( m_pV, m_FreeList );
}


void
RDnsDict::Scavenger(
    VOID
    )
/*++

Routine Description:

    Scavenger code to delete expired entries in the cache array

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    Lock();
    RDnsCacheEntry *p = m_pV;
    UINT i;
    time_t tNow = time(NULL);

    for ( i = 0 ; i < m_cSize ; ++i, ++p )
    {
        if ( p->Expired( tNow ) )
        {
            FreeEntry( i + 1 );
        }
    }

    Unlock();
}


VOID
WINAPI
RDnsScavenger(
    LPVOID
    )
/*++

Routine Description:

    Scavenger function for RDns & Pen

Arguments:

    LPVOID - not used

Return Value:

    Nothing

--*/
{
    DBG_ASSERT(g_fEnableRdns);
    g_RDns.Scavenger();
    
    if ( g_pscPen != NULL )
    {
        g_pscPen->Scavenger();
    }
}


BOOL
InitRDns(
    VOID
    )
/*++

Routine Description:

    Init the Reverse DNS API

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    //
    // Don't enable for win95
    //

    if ( IISGetPlatformType() == PtWindows95 ) {
        g_fEnableRdns = FALSE;
        return(TRUE);
    }

#if DBG
    //
    // check that RDNS_HASH_SIZE is prime
    //

    UINT x = 2;
    UINT x2;
    for ( x = 2 ; (x2=x*x) <= RDNS_HASH_SIZE; ++x )
    {
        if ( (RDNS_HASH_SIZE/x)*x == RDNS_HASH_SIZE )
        {
            ASSERT( FALSE );
        }
    }
#endif

    HKEY hKey;

    // get cache size, max # threads
    if ( RegOpenKey( HKEY_LOCAL_MACHINE, RDNS_REG_KEY, &hKey )
            == ERROR_SUCCESS )
    {
        DWORD dwType;
        DWORD dwValue;

        DWORD dwSize = sizeof(dwValue);
        if ( RegQueryValueEx( hKey,
                              RDNS_REG_MAX_THREAD,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwSize ) == ERROR_SUCCESS
             && dwType == REG_DWORD )
        {
            g_cMaxThreadLimit = dwValue;
        }
        else
        {
            g_cMaxThreadLimit = RDNS_REG_MAX_THREAD_DEF;
        }

        dwSize = sizeof(dwValue);
        if ( RegQueryValueEx( hKey,
                              RDNS_REG_CACHE_SIZE,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwSize ) == ERROR_SUCCESS
             && dwType == REG_DWORD )
        {
            g_cCacheSize = dwValue * 1024;
        }
        else
        {
            g_cCacheSize = RDNS_REG_CACHE_SIZE_DEF * 1024;
        }

        dwSize = sizeof(dwValue);
        if ( RegQueryValueEx( hKey,
                              RDNS_REG_TTL,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwValue,
                              &dwSize ) == ERROR_SUCCESS
             && dwType == REG_DWORD )
        {
            g_cTTL = dwValue;
        }
        else
        {
            g_cTTL = RDNS_REG_TTL_DEF;
        }

        RegCloseKey( hKey );

    }

    if ( g_RDns.Init() == FALSE )
    {
        return FALSE;
    }

    g_pscPen = new CSidCache;
    if ( g_pscPen == NULL )
    {
        return FALSE;
    }
    g_pscPen->Init();

    g_cAvailableThreads = 0;
    g_cThreads = 0;
    g_hDnsPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE,
            NULL,
            NULL,
            g_cMaxThreadLimit );

    g_hThreadsTerminated = IIS_CREATE_EVENT(
                               "g_hThreadsTerminated",
                               &g_hThreadsTerminated,
                               TRUE,
                               FALSE
                               );

    if ( g_hDnsPort == NULL || g_hThreadsTerminated == NULL )
    {
        CloseHandle( g_hDnsPort );
        CloseHandle( g_hThreadsTerminated );
        g_hDnsPort = NULL;
        g_hThreadsTerminated = NULL;
        return FALSE;
    }

    g_dwScavengerWorkItem = ScheduleWorkItem( RDnsScavenger,
                                              NULL,
                                              1000 * RDNS_SCAVENGER_GRANULARITY,
                                              TRUE );

    return TRUE;
}


void
TerminateRDns(
    VOID
    )
/*++

Routine Description:

    Terminate the Reverse DNS API

Arguments:

    None

Return Value:

    Nothing

--*/
{
    UINT x;

    if ( !g_fEnableRdns ) {
        return;
    }

    //
    // post queued to everybody
    // all threads will dec global count of thread, when 0 set event
    // close port

    if ( g_cThreads )
    {
        for ( x = 0 ; x < g_cThreads ; ++x )
        {
            PostQueuedCompletionStatus( g_hDnsPort, NULL, NULL, NULL );
        }
        WaitForSingleObject( g_hThreadsTerminated, 5 * 1000 );
    }

    CloseHandle( g_hDnsPort );
    CloseHandle( g_hThreadsTerminated );
    g_hDnsPort = NULL;
    g_hThreadsTerminated = NULL;

    if ( g_dwScavengerWorkItem != NULL )
    {
        RemoveWorkItem( g_dwScavengerWorkItem );
        g_dwScavengerWorkItem = NULL;
    }

    g_RDns.Terminate();

    if ( g_pscPen != NULL )
    {
        g_pscPen->Terminate();
        delete g_pscPen;
        g_pscPen = NULL;
    }
}


DWORD WINAPI
AsyncThread(
    LPVOID
    )
/*++

Routine Description:

    Thread handling reverse DNS request

Arguments:

    LPVOID - not used

Return Value:

    Thread exit status

--*/
{
    DWORD dwSize;
    ULONG_PTR dwKey;
    PVOID * ppInfo; 
    DNSARG  pArg;
    struct sockaddr *pAddr;
    struct sockaddr EmptyAddr;
    LPSTR pName;
    CHAR achName[DN_LEN];
    DWORD h;
    BOOL fSt;
    struct hostent* pH;


    DBG_ASSERT(g_fEnableRdns);
    
    while ( GetQueuedCompletionStatus( g_hDnsPort,
            &dwSize,
            &dwKey,
            (LPOVERLAPPED*)&ppInfo,
            (DWORD)-1 ) )
    {
        InterlockedDecrement( &g_cAvailableThreads );

        //
        // if pInfo is NULL it is close request
        //
        
        if ( NULL == ppInfo)
        {
            if ( InterlockedDecrement( (PLONG)&g_cThreads ) == 0)
            {
                SetEvent( g_hThreadsTerminated );
            }
            break;
        }

        pAddr = (struct sockaddr *)ppInfo[0];
        pArg  = ppInfo[1];
        
        switch ( ((PDNSFUNCDESC)dwKey)->dwRequestType )
        {
            case RDNS_REQUEST_TYPE_IP2DNS:
                h = g_RDns.ComputeHash( pAddr );
                fSt = FALSE;

                if ( pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)pAddr)->sin_addr),
                                         SIZEOF_IP_ADDRESS,
                                         PF_INET ) )
                {
                    g_RDns.NewEntry( pAddr, h, time(NULL)+g_cTTL, pH->h_name );
                    fSt = TRUE;
                }
                else
                {
                    //
                    // Create entry with empty name as result of negative search
                    //

                    g_RDns.NewEntry( pAddr, h, time(NULL)+g_cTTL, "" );
                }

                (((PDNSFUNCDESC)dwKey)->pFunc)(pArg, fSt, pH ? pH->h_name : NULL );
                break;

            case RDNS_REQUEST_TYPE_DNS2IP:
                pName = (LPSTR)pAddr;
                h = g_RDns.ComputeHash( pName );
                fSt = FALSE;

                if ( pH = gethostbyname( pName ) )
                {
                    memcpy( &((sockaddr_in*)&EmptyAddr)->sin_addr, pH->h_addr, SIZEOF_IP_ADDRESS );
                    EmptyAddr.sa_family = AF_INET;
                    fSt = TRUE;
                }
                else
                {
                    //
                    // Create entry with null addr as result of negative search
                    //

                    memset( &EmptyAddr, '\0', sizeof(EmptyAddr) );
                }

                g_RDns.NewDns2IpEntry( &EmptyAddr, h, time(NULL)+g_cTTL, pName );
                (((PDNSFUNCDESC)dwKey)->pFunc)(pArg, fSt, (LPSTR)&EmptyAddr );
                break;
        }

        InterlockedIncrement( &g_cAvailableThreads );

        pAddr = NULL;
        pArg  = NULL;

        free(ppInfo);
       
    }

    return 0;
}

//AtqPostCompletionStatus(
//        IN PATQ_CONTEXT patqContext,      from QueryClientConn()->QueryAtqContext()
//        IN DWORD        BytesTransferred  will be 0
//        )

BOOL
AsyncHostByAddr(
    PDNSFUNCDESC pFunc,     // will store DNS name, post dummy completion status
                            // if NULL ( or g_cMaxThreadLimit==0 ) then sync request
    DNSARG pArg,            // ptr to be passed to FUNC
    struct sockaddr *pHostAddr,

    BOOL *pfSync,           // updated with TRUE if sync call
    LPSTR pName,
    DWORD dwMaxNameLen
    )
/*++

Routine Description:

    Reverse DNS query

Arguments:

    pFunc - ptr to function to be called for asynchronous result
    pArg - argument to be supplied while calling pFunc
    pHostAddr - address to reverse resolve
    pfSync - updated with TRUE if synchronous result ( i.e. pName updated
             with result if function returns TRUE )
    pName - to be updated with DNS name if synchronous result
    dwMaxNameLen - size of supplied pName buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL fRet = TRUE;
    DWORD h;

    DBG_ASSERT(g_fEnableRdns);

    h = g_RDns.ComputeHash( pHostAddr );

    if ( g_RDns.Search( pHostAddr, h, pName, dwMaxNameLen ) )
    {
        *pfSync = TRUE;
        return TRUE;
    }

    if ( pFunc == NULL || g_cMaxThreadLimit == 0 )
    {
        struct hostent* pH;
        if ( pHostAddr->sa_family == AF_INET &&
             (pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)pHostAddr)->sin_addr),
                                  SIZEOF_IP_ADDRESS,
                                  PF_INET )) )
        {
            UINT l = strlen( pH->h_name ) + 1;
            if ( l <= dwMaxNameLen )
            {
                memcpy( pName, pH->h_name, l );
                fRet = TRUE;
            }
            else
            {
                *pName = '\0';
                fRet = FALSE;
            }
        }
        else
        {
            //
            // Create entry with empty name as result of negative search
            //

            *pName = '\0';
            fRet = FALSE;
        }

        g_RDns.NewEntry( pHostAddr,
                         h,
                         time(NULL)+g_cTTL,
                         pName );

        *pfSync = TRUE;
        return fRet;
    }

    *pfSync = FALSE;

    return FireUpNewThread( pFunc, pArg, (LPVOID)pHostAddr );
}


BOOL
AsyncAddrByHost(
    PDNSFUNCDESC pFunc,     // will store DNS name, post dummy completion status
                            // if NULL ( or g_cMaxThreadLimit==0 ) then sync request
    DNSARG pArg,            // ptr to be passed to FUNC
    struct sockaddr *pHostAddr,

    BOOL *pfSync,           // updated with TRUE if sync call
    LPSTR pszName
    )
/*++

Routine Description:

    DNS query

Arguments:

    pFunc - ptr to function to be called for asynchronous result
    pArg - argument to be supplied while calling pFunc
    pHostAddr - to be updated with address
    pfSync - updated with TRUE if synchronous result ( i.e. pName updated
             with result if function returns TRUE )
    pName - to be updated with DNS name if synchronous result

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL fRet = TRUE;
    DWORD h;

    DBG_ASSERT(g_fEnableRdns);

    h = g_RDns.ComputeHash( pszName );

    if ( g_RDns.SearchByName( pHostAddr, h, pszName ) )
    {
        *pfSync = TRUE;
        return TRUE;
    }

    if ( pFunc == NULL || g_cMaxThreadLimit == 0 )
    {
        struct hostent* pH;
        if ( pH = gethostbyname( pszName ) )
        {
            memcpy( &((sockaddr_in*)pHostAddr)->sin_addr, pH->h_addr, pH->h_length );
            pHostAddr->sa_family = AF_INET;
            fRet = TRUE;
        }
        else
        {
            //
            // Create entry with empty name as result of negative search
            //

            memset( pHostAddr, '\0', sizeof(struct sockaddr) );
            fRet = FALSE;
        }

        g_RDns.NewDns2IpEntry( pHostAddr,
                               h,
                               time(NULL)+g_cTTL,
                               pszName );

        *pfSync = TRUE;
        return fRet;
    }

    *pfSync = FALSE;

    return FireUpNewThread( pFunc, pArg, (LPVOID)pszName );
}


BOOL
FireUpNewThread(
    PDNSFUNCDESC pFunc,
    DNSARG pArg,
    LPVOID pOvr
    )
{
    //
    //  If no threads are available, kick a new one off up to the limit
    //

    if ( (g_cAvailableThreads == 0) &&
         (g_cThreads < g_cMaxThreadLimit) )
    {

        HANDLE hThread;
        DWORD  dwThreadID;

        InterlockedIncrement( (PLONG)&g_cThreads );

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AsyncThread,
                                NULL,
                                0,
                                &dwThreadID );

        if ( hThread )
        {
            CloseHandle( hThread );     // Free system resources
            InterlockedIncrement( &g_cAvailableThreads );
        }
        else
        {

            //
            // We fail if there are no threads running
            //

            if ( InterlockedDecrement( (PLONG)&g_cThreads ) == 0)
            {
                return FALSE;
            }
        }
    }

    PVOID * ppInfo = (PVOID *) malloc(2*sizeof(PVOID));

    if (NULL != ppInfo)
    {
        ppInfo[0]   = pOvr;
        ppInfo[1]   = pArg;
    }
    
    BOOL fRet = PostQueuedCompletionStatus( g_hDnsPort,
                                            0,
                                            (ULONG_PTR)pFunc,
                                            (LPOVERLAPPED)ppInfo 
                                            );
    if( !fRet )
    {
        free( ppInfo );
    }
    
    return fRet;
}


#if DBG


typedef struct _TEST_RDNS
{
    LPSTR pIA;
    char achName[32];
    struct sockaddr sa;
} TEST_RDNS;

TEST_RDNS TR[]={
    { "157.55.83.72", "PHILLICH3" },
    { "157.55.91.17", "JOHNL0" },
    { "157.55.84.160", "JOHNSONA" },
    { "157.55.87.80", "MICHTH1" },
    { "157.55.86.54", "MICHTH2" },
} ;

LONG cPending = 0;

void CheckAddr( TEST_RDNS*p, LPSTR a)
{
//    char achErr[80];
//    wsprintf( achErr, "Arg=%d, bool=%d, addr=%s\n", a, f, p );
//    OutputDebugString( achErr );

    int l = strlen( p->achName );
    if ( _memicmp( p->achName, a, l ) )
    {
        ASSERT( FALSE );
    }
}

void pFunc( DNSARG a, BOOL f, LPSTR p)
{
    if ( f )
    {
        CheckAddr( (TEST_RDNS*)a, p );
    }
    else
    {
        char achErr[80];
        wsprintf( achErr, "Failed gethostbyaddr=%s\n", ((TEST_RDNS*)a)->pIA );
        OutputDebugString( achErr );
    }
    InterlockedDecrement( &cPending );
}


DNSFUNCDESC g_TestFunc = { RDNS_REQUEST_TYPE_IP2DNS, pFunc };


void TestRDns()
{
    static struct sockaddr sa;
    BOOL fS;
    UINT x;
    UINT y;
    CHAR achName[64];
    UINT a,b,c,d;


    for ( x = y = 0 ; x < 1000 ; ++x )
    {
        TEST_RDNS *p = TR+y;

        sscanf( p->pIA, "%u.%u.%u.%u", &a, &b, &c, &d );
        ((PSOCKADDR_IN)&p->sa)->sin_addr.s_net = (u_char)a;
        ((PSOCKADDR_IN)&p->sa)->sin_addr.s_host = (u_char)b;
        ((PSOCKADDR_IN)&p->sa)->sin_addr.s_lh = (u_char)c;
        ((PSOCKADDR_IN)&p->sa)->sin_addr.s_impno = (u_char)d;
        p->sa.sa_family = AF_INET;

        if ( AsyncHostByAddr(
            (PDNSFUNCDESC)&g_TestFunc,
            (DNSARG)p,
            &p->sa,
            &fS,
            achName,
            sizeof(achName)
            ) )
        {
            if ( fS )
            {
                CheckAddr( p, achName );
            }
            else
            {
                InterlockedIncrement( &cPending );
                Sleep( 500 );
            }
        }
        else
        {
            ASSERT( FALSE );
        }
        if ( ++y == sizeof(TR)/sizeof(TEST_RDNS) )
        {
            y = 0;
        }
    }

    for ( ;; )
    {
        if ( cPending == 0 )
        {
            break;
        }
        Sleep( 1000 );
    }

    OutputDebugString( "Done" );
}
#endif


LPVOID
BsearchEx (
    LPVOID      key,
    LPVOID      base,
    size_t      num,
    size_t      width,
    CMPFUNC     compare,
    LPVOID      param
    )
/*++

Routine Description:

    Binary search with additional parameter to be passed
    to compare routine

Arguments:

    key - ptr to key
    base - ptr to base of array
    num - number of elements in array
    width - size of array element
    compare - compare routine, called with ptr to 2 elements and param
    param - additional parameter presented to the compare routine

Return Value:

    ptr to element in array if key found, else NULL

--*/
{
    char *lo = (char *)base;
    char *hi = (char *)base + (num - 1) * width;
    char *mid;
    unsigned int half;
    int result;

    while (lo <= hi)
        if (half = num / 2)
        {
            mid = lo + (num & 1 ? half : (half - 1)) * width;
            if (!(result = (*compare)(key,mid,param)))
                return(mid);
            else if (result < 0)
            {
                hi = mid - width;
                num = num & 1 ? half : half-1;
            }
            else    {
                lo = mid + width;
                num = half;
            }
        }
        else if (num)
            return((*compare)(key,lo,param) ? NULL : lo);
        else
            break;

    return(NULL);
}


BOOL
ADDRESS_CHECK::BindCheckList(
    LPBYTE p,
    DWORD c
    )
/*++

Routine Description:

    Bind a check list ( presented as a BLOB ) to an
    ADDRESS_CHECK object

Arguments:

    p - ptr to BLOB
    c - size of BLOB

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    PADDRESS_CHECK_LIST pList;
    UINT                l;

    if ( p == NULL )
    {
        if ( m_Storage.Init() && m_Storage.Resize( sizeof(ADDRESS_CHECK_LIST)
                + sizeof(ADDRESS_HEADER) * 2
                + sizeof(NAME_HEADER) * 2 ) )
        {
            DWORD i;
            pList = (PADDRESS_CHECK_LIST)m_Storage.GetAlloc();
                        
                        // BugFix: 47982 Whistler
                        //         Prefix bug pList not being valid.
                        //         EBK 5/5/2000         
                        if (pList)
                        {
                                pList->iDenyAddr = i = MAKEREF( sizeof(ADDRESS_CHECK_LIST) );
                                i += sizeof(ADDRESS_HEADER);
                                pList->iGrantAddr = i;
                                i += sizeof(ADDRESS_HEADER);
                                pList->iDenyName = i;
                                i += sizeof(NAME_HEADER);
                                pList->iGrantName = i;
                                i += sizeof(NAME_HEADER);
                                pList->cRefSize = MAKEOFFSET(i);
                                pList->dwFlags = RDNS_FLAG_DODNS2IPCHECK;

                                return TRUE;
                        }
        }

        return FALSE;
    }
    else
    {
        return m_Storage.Init( p, c );
    }
}


BOOL
ADDRESS_CHECK::SetFlag(
    DWORD   dwFlag,
    BOOL    fEnable
    )
/*++

Routine Description:

    Set flag in address check object

Arguments:

    dwFlag - flag to enable/disable
    fEnable - TRUE to enable, else FALSE

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        if ( fEnable )
        {
            pList->dwFlags |= dwFlag;
        }
        else
        {
            pList->dwFlags &= ~dwFlag;
        }

        return TRUE;
    }

    return FALSE;
}


DWORD
ADDRESS_CHECK::GetFlags(
    )
/*++

Routine Description:

    Get flags in address check object

Arguments:

    None

Return Value:

    Flags if object exists, otherwise 0

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;

        return pList->dwFlags;
    }

    return 0;
}


BOOL
ADDRESS_CHECK::LocateAddr(
    BOOL fGrant,
    DWORD iIndex,
    PADDRESS_HEADER* ppHd,
    PADDRESS_LIST_ENTRY* pHeader,
    LPDWORD piIndexInHeader
    )
/*++

Routine Description:

    Locate an address in the specified list, returns ptr
    to header & element in address list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )
    ppHd - updated with ptr to address header
    pHeader - updated with ptr to address list entry
    piIndexInHeader - updated with index in array addressed by
                      pHeader->iFirstAddress

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;
    UINT                iL;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        *ppHd = pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            // adjust index by 1: 1st entry is mask
            if ( iIndex < (pHd->Entries[iL].cAddresses-1) )
            {
                *pHeader = pHd->Entries+iL;
                *piIndexInHeader = iIndex+1;
                return TRUE;
            }
            iIndex -= (pHd->Entries[iL].cAddresses-1);
        }
    }

    return FALSE;
}


BOOL
ADDRESS_CHECK::GetAddr(
    BOOL fGrant,
    DWORD iIndex,
    LPDWORD pdwFamily,
    LPBYTE* pMask,
    LPBYTE* pAddr
    )
/*++

Routine Description:

    Get an address entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )
    pdwFamily - updated with address family ( as in sockaddr.sa_type )
    pMask - updated with ptr to mask
    pAddr - updated with ptr to address

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    PADDRESS_LIST_ENTRY pHeader;
    PADDRESS_HEADER     pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateAddr( fGrant, iIndex, &pHd, &pHeader, &iIndexInHeader ) )
    {
        UINT cS = GetAddrSize( pHeader->iFamily );
        *pdwFamily = pHeader->iFamily;
        pStore = MAKEPTR(pStore, pHeader->iFirstAddress);
        *pMask = pStore;
        *pAddr = pStore+iIndexInHeader*cS;

        return TRUE;
    }

    return FALSE;
}


BOOL
ADDRESS_CHECK::DeleteAddr(
    BOOL fGrant,
    DWORD iIndex
    )
/*++

Routine Description:

    Delete an address entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    PADDRESS_LIST_ENTRY pHeader;
    PADDRESS_HEADER     pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateAddr( fGrant, iIndex, &pHd, &pHeader, &iIndexInHeader ) )
    {
        UINT cS = GetAddrSize( pHeader->iFamily );
        UINT iS = MAKEOFFSET(pHeader->iFirstAddress)+iIndexInHeader*cS;
        LPBYTE pAddr = MAKEPTR(pStore, iS);

        memmove( pAddr,
                 pAddr + cS,
                 m_Storage.GetUsed() - iS - cS );
        m_Storage.AdjustUsed( -(int)cS );
        --pHeader->cAddresses;
        AdjustRefs( pStore, MAKEOFFSET(pHeader->iFirstAddress)+1, -(int)cS );
        --pHd->cAddresses;
        return TRUE;
    }

    return FALSE;
}


int __cdecl
AddrCmp(
    LPVOID pA,
    LPVOID pB,
    LPVOID pP
    )
/*++

Routine Description:

    Compare 2 address entries.
    uses mask as defined by PADDRCMPDESC pP

Arguments:

    pA - ptr to 1st address entry ( as byte array )
    pB - ptr to 2nd address entry ( as byte array )
    pP - ptr yo ADDRCMDDESC

Return Value:

    -1 if *pA < *pB, 0 if *pA == *pB, 1 if *pA > *pB

--*/
{
    PADDRCMPDESC    pacd = (PADDRCMPDESC)pP;
    int             l;
    UINT            a;
    UINT            b;


    if ( pacd->cFullBytes || pacd->LastByte )
    {
        if ( (l = memcmp( pA, pB, pacd->cFullBytes )) )
        {
            return l;
        }

        if ( pacd->LastByte )
        {
            a = ((LPBYTE)pA)[pacd->cFullBytes] & pacd->LastByte;
            b = ((LPBYTE)pB)[pacd->cFullBytes] & pacd->LastByte;

            return a < b ? -1 : ( a==b ? 0 : 1 );
        }

        return 0;
    }
    else
    {
        // bit cmp from pMask
        LPBYTE pM = pacd->pMask;
        LPBYTE pMM = pM + pacd->cSizeAddress;
        for ( ; pM < pMM ; ++pM )
        {
            a = *((LPBYTE)pA) & *pM;
            b = *((LPBYTE)pB) & *pM;
            if ( a<b )
            {
                return -1;
            }
            else if ( a > b )
            {
                return 1;
            }
            pA = (LPVOID)(((LPBYTE)pA) + 1);
            pB = (LPVOID)(((LPBYTE)pB) + 1);
        }
        return 0;
    }
}


int __cdecl
NameCmp(
    LPVOID pA,
    LPVOID pB,
    LPVOID pP
    )
/*++

Routine Description:

    Compare 2 name entries.
    Entry is either defined as a ptr to ASCII ( if equal to NAMECMPDESC.pName )
    or as ptr to DWORD offset in LPSTR array based as NAMECMPDESC.pBase

Arguments:

    pA - ptr to 1st name entry
    pB - ptr to 2nd name entry
    pP - ptr yo NAMECMDDESC

Return Value:

    -1 if *pA < *pB, 0 if *pA == *pB, 1 if *pA > *pB

--*/
{
    int             l;
    UINT            a;
    UINT            b;
    PNAMECMPDESC    pncd = (PNAMECMPDESC)pP;
    LPVOID          pName = pncd->pName;
    LPBYTE          pBase = pncd->pBase;


    if ( pA != pName )
    {
        pA = MAKEPTR( pBase, *(DWORD*)pA );
    }
    if ( pB != pName )
    {
        pB = MAKEPTR( pBase, *(DWORD*)pB );
    }

    return _stricmp( (const char*)pA, (const char*)pB );
}


BOOL
ADDRESS_CHECK::AddAddr(
    BOOL fGrant,
    DWORD dwFamily,
    LPBYTE pMask,
    LPBYTE pAddr
    )
/*++

Routine Description:

    Add an address entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    dwFamily - address family, as in sockaddr.sa_type
    pMask - ptr to mask
    pAddr - ptr to address

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;
    UINT                iL;
    UINT                cS = GetAddrSize( dwFamily );
    LPBYTE              pA;
    ADDRCMPDESC         acd;
    LPBYTE              pS;
    PADDRESS_LIST_ENTRY pE;

    MakeAcd( &acd, pMask, cS );

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            if ( pHd->Entries[iL].iFamily == dwFamily )
            {
                pS = MAKEPTR(pStore, pHd->Entries[iL].iFirstAddress );
                int cm;
                if ( !(cm = memcmp( pMask, pS, cS )) )
                {
                    // found matching family, mask
                    // find where to insert
                    DWORD i;
                    for ( i= 1, cm = 1 ; i < pHd->Entries[iL].cAddresses ; ++i )
                    {
                        if ( !(cm = AddrCmp( pAddr, pS+cS*i, &acd )) )
                        {
                            // already exist
                            return FALSE;
                        }
                        else if ( cm < 0 )
                        {
                            // insert @ i
insert_addr:
                            UINT s = m_Storage.GetUsed();
                            if ( m_Storage.Resize( cS ) )
                            {
                                int l;
                                pStore = m_Storage.GetAlloc();
                                pList = (PADDRESS_CHECK_LIST)pStore;
                                pHd = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
                                pS = MAKEPTR(pStore, l=MAKEOFFSET(pHd->Entries[iL].iFirstAddress+i*cS) );
                                memmove( pS+cS, pS, s-l );
                                memcpy( pS, pAddr, cS );
                                AdjustRefs( pStore, pHd->Entries[iL].iFirstAddress+1, cS );
                                ++pHd->Entries[iL].cAddresses;
                                ++pHd->cAddresses;
                                return TRUE;
                            }
                            return FALSE;
                        }
                    }
                    goto insert_addr;
                }
                else if ( cm < 0 )
                {
insert_at_current_pos:
                    // must insert new Entry @ iL
                    int i = m_Storage.GetUsed()+sizeof(ADDRESS_LIST_ENTRY);
                    UINT cWasUsed = m_Storage.GetUsed();
                    if ( m_Storage.Resize( sizeof(ADDRESS_LIST_ENTRY)+cS*2 ) )
                    {
                        // refresh pointers

                        pStore = m_Storage.GetAlloc();
                        pList = (PADDRESS_CHECK_LIST)pStore;
                        pList->cRefSize += sizeof(ADDRESS_LIST_ENTRY);
                        pHd = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
                        pE = pHd->Entries + iL;

                        // SELFREFINDEX where to insert
                        UINT iS = DIFF((LPBYTE)(pHd->Entries+iL)-pStore);

                        // make room for entry
                        memmove( pE+1,
                                 pE,
                                 cWasUsed-iS );
                        AdjustRefs( pStore, DIFF((LPBYTE)pHd->Entries-pStore), sizeof(ADDRESS_LIST_ENTRY) );

                        // fill entry
                        pE->iFamily = dwFamily;
                        pE->cAddresses = 2;
                        pE->iFirstAddress = MAKEREF( i );
                        pE->cFullBytes = acd.cFullBytes;
                        pE->LastByte = acd.LastByte;

                        // copy mask & addr
                        pA = MAKEPTR( pStore, i );
                        memcpy( pA, pMask, cS );
                        memcpy( pA+cS, pAddr, cS );

                        ++pHd->cEntries;
                        ++pHd->cAddresses;
                        return TRUE;
                    }
                    break;
                }
            }
            else if ( pHd->Entries[iL].iFamily > dwFamily )
            {
                goto insert_at_current_pos;
            }
        }
        goto insert_at_current_pos;
    }

    return FALSE;
}

inline
DWORD
ADDRESS_CHECK::GetNbAddr(
    BOOL fGrant
    )
/*++

Routine Description:

    Get number of entries in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list

Return Value:

    Number of entries in list

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        return pHd->cAddresses;
    }

    return 0;
}


VOID
ADDRESS_CHECK::MakeAcd(
    PADDRCMPDESC pacd,
    LPBYTE pMask,
    UINT cLen
    )
/*++

Routine Description:

    Build a ADDRCMPDESC struct based on ptr to mask and address length

Arguments:

    pacd - ptr to ADDRCMPDESC to build
    pMask - ptr to mask
    cLen - address length

Return Value:

    Nothing

--*/
{
    pacd->pMask = pMask;
    pacd->cFullBytes = 0;
    pacd->LastByte = 0;
    pacd->cSizeAddress = cLen;

    while ( pacd->cFullBytes < cLen &&
            pMask[pacd->cFullBytes] == 0xff )
    {
        ++pacd->cFullBytes;
    }

    if ( pacd->cFullBytes < cLen )
    {
        UINT i;

        pacd->LastByte = pMask[pacd->cFullBytes];
        for ( i = pacd->cFullBytes+1 ; i < cLen ; ++i )
        {
            if ( pMask[i] != 0 )
            {
                // non-standard mask
                pacd->cFullBytes = 0;
                pacd->LastByte = 0;
                break;
            }
        }
    }
}


BOOL
ADDRESS_CHECK::IsMatchAddr(
    BOOL fGrant,
    DWORD dwFamily,
    LPBYTE pAddr
    )
/*++

Routine Description:

    Check if address in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    dwFamily - address family, as in sockaddr.sa_type
    pAddr - ptr to address

Return Value:

    TRUE if address is in specified list, otherwise FALSE

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;
    UINT                iL;
    UINT                cS = GetAddrSize( dwFamily );

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        for ( iL = 0 ; iL < pHd->cEntries  ; ++iL )
        {
            if ( dwFamily == pHd->Entries[iL].iFamily )
            {
                ADDRCMPDESC acd;
                LPBYTE pA = MAKEPTR( pStore, pHd->Entries[iL].iFirstAddress );
                acd.cSizeAddress = cS;
                acd.pMask = pA;
                acd.cFullBytes = pHd->Entries[iL].cFullBytes;
                acd.LastByte = pHd->Entries[iL].LastByte;
                if ( BsearchEx( pAddr, pA+cS, pHd->Entries[iL].cAddresses - 1, cS, (CMPFUNC)AddrCmp, &acd ) )
                {
                    return TRUE;
                }
            }
            else if ( dwFamily > pHd->Entries[iL].iFamily )
            {
                break;
            }
        }
    }

    return FALSE;
}


VOID
ADDRESS_CHECK::AdjustRefs(
    LPBYTE pStore,
    DWORD dwCut,
    DWORD dwAdj
    )
/*++

Routine Description:

    Adjust references in ADDRESS_CHECK by offset dwAdj for references
    above or equal to dwCut

Arguments:

    pStore - ptr to address check binary object
    dwCut - references above or equal to this parameter are to be adjusted
            by dwAdj
    dwAdj - offset to add to reference above or equal to dwCut

Return Value:

    Nothing

--*/
{
    LPBYTE pL = pStore + ((PADDRESS_CHECK_LIST)pStore)->cRefSize;
    dwCut = MAKEREF( dwCut );
    for ( ; pStore < pL ; pStore += sizeof(DWORD) )
    {
        if ( *((LPDWORD)pStore) >= dwCut )
        {
            *((LPDWORD)pStore) += dwAdj;
        }
    }
}


UINT
ADDRESS_CHECK::GetAddrSize(
    DWORD dwF
    )
/*++

Routine Description:

    Returns address size in byte based on family ( sockaddr.sa_type )

Arguments:

    dwF - address family ( as in sockaddr.sa_type )

Return Value:

    Address length, in byte. 0 for unknown address families

--*/
{
    DWORD dwS;

    switch ( dwF )
    {
        case AF_INET:
            dwS = SIZEOF_IP_ADDRESS;
            break;

        default:
            dwS = 0;
            break;
    }

    return dwS;
}


BOOL
ADDRESS_CHECK::DeleteAllAddr(
    BOOL fGrant
    )
/*++

Routine Description:

    Delete all address entries in specified list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    while ( DeleteAddr( fGrant, 0 ) )
    {
    }

    return TRUE;
}


BOOL
XAR::Resize(
    DWORD dwDelta
    )
/*++

Routine Description:

    Resize storage by dwDelta.
    This can modify storage ptr, so ptr based on value returned by GetAlloc()
    are invalidated by calling this.

Arguments:

    dwDelta - delta to add ( substract if (int)dwDelta < 0 )
              to storage

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( (int)dwDelta > 0 )
    {
        if ( (m_cUsed + dwDelta > m_cAlloc) )
        {
            UINT cNew = ((m_cUsed+dwDelta+XAR_GRAIN)/XAR_GRAIN)*XAR_GRAIN;
            LPBYTE p = (LPBYTE)LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT, cNew );
            if ( p )
            {
                memcpy( p, m_pAlloc, m_cUsed );
                if ( m_fDidAlloc )
                {
                    LocalFree( m_pAlloc );
                }
                m_pAlloc = p;
                m_cAlloc = cNew;
                m_fDidAlloc = TRUE;
            }
            else
            {
                return FALSE;
            }
        }
    }

    m_cUsed += dwDelta;

    return TRUE;
}


AC_RESULT
ADDRESS_CHECK::CheckAddress(
    struct sockaddr*    pAddr
    )
/*++

Routine Description:

    Check if address is in grant or deny list

Arguments:

    pAddr - ptr to address

Return Value:

    TRUE if address is granted access, otherwise FALSE

--*/
{
    LPBYTE p;

    if ( !pAddr || !g_fEnableRdns )
    {
        goto ex;
    }

    // if deny list non empty, check not in list
    switch ( pAddr->sa_family )
    {
        case AF_INET:
            p = (LPBYTE)(&((PSOCKADDR_IN)pAddr)->sin_addr);
            break;

        case AF_IPX:
            goto ex;
            //p = (LPBYTE)(((PSOCKADDR)pAddr)->sa_data);
            //break;
    }

    if ( GetNbAddr( FALSE ) )
    {
        if ( IsMatchAddr( FALSE, pAddr->sa_family, p ) )
        {
            return AC_IN_DENY_LIST;
        }
        return AC_NOT_IN_DENY_LIST;
    }

    // if grant list non empty, check in list

    if ( GetNbAddr( TRUE ) )
    {
        if ( IsMatchAddr( TRUE, pAddr->sa_family, p ) )
        {
            return AC_IN_GRANT_LIST;
        }
        return AC_NOT_IN_GRANT_LIST;
    }

ex:
    return AC_NO_LIST;
}


VOID
AddrCheckDnsCallBack(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS resolver.
    Shell for real function in ADDRESS_CHECK

Arguments:

    p - ptr to ADDRESS_CHECK
    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    ((ADDRESS_CHECK*)p)->AddrCheckDnsCallBack( fSt, pDns );
}


VOID
AddrCheckDnsCallBack2(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS2 resolver.
    Shell for real function in ADDRESS_CHECK

Arguments:

    p - ptr to ADDRESS_CHECK
    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    ((ADDRESS_CHECK*)p)->AddrCheckDnsCallBack2( fSt, (struct sockaddr *)pDns );
}


VOID
AddrCheckDnsCallBack3(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS3 resolver.
    Shell for real function in ADDRESS_CHECK

Arguments:

    p - ptr to ADDRESS_CHECK
    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    ((ADDRESS_CHECK*)p)->AddrCheckDnsCallBack3( fSt, (struct sockaddr *)pDns );
}


VOID
ResolveDnsCallBack(
    DNSARG  p,
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS resolver.
    Shell for real function in ADDRESS_CHECK

Arguments:

    p - ptr to ADDRESS_CHECK
    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    ((ADDRESS_CHECK*)p)->ResolveDnsCallBack( fSt, pDns );
}


VOID
ADDRESS_CHECK::AddrCheckDnsCallBack(
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS resolver

Arguments:

    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    m_fDnsResolved = TRUE;

    if ( fSt )
    {
        strncpy( m_pszDnsName, pDns, DNS_MAX_NAME_LENGTH );
        m_pszDnsName[ DNS_MAX_NAME_LENGTH ] = '\0';

        if ( !m_Storage.GetAlloc() ||
             (((PADDRESS_CHECK_LIST)m_Storage.GetAlloc())->dwFlags & RDNS_FLAG_DODNS2IPCHECK) )
        {
            if ( !m_fIpResolved )
            {
                BOOL fSync;
                BOOL St;

                // get IP addr
                St = AsyncAddrByHost(
                        (PDNSFUNCDESC)&g_Dns2Ip,
                        (DNSARG)this,
                        &m_ResolvedAddr,
                        &fSync,
                        m_pszDnsName );

                if ( St )
                {
                    if ( !fSync )
                    {
                        return;
                    }
                    fSt = (!memcmp( (LPBYTE)(&((PSOCKADDR_IN)&m_ResolvedAddr)->sin_addr),
                                   (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                                   SIZEOF_IP_ADDRESS ) ||
                              (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr == LOCALHOST_ADDRESS)) &&
                          CheckName( pDns );
                }
                else
                {
                    m_dwErrorResolving = ERROR_INVALID_PARAMETER;
                    fSt = FALSE;
                }
                m_fIpResolved = TRUE;
            }
        }
        else
        {
            fSt = CheckName( pDns );
        }
    }
    else
    {
        m_dwErrorResolving = ERROR_INVALID_PARAMETER;
    }

    (m_HttpReqCallback)( m_HttpReqParam, fSt );
}


VOID
ADDRESS_CHECK::AddrCheckDnsCallBack2(
    BOOL    fSt,
    struct sockaddr*pAddr
    )
/*++

Routine Description:

    Callback routine from reverse DNS2 resolver

Arguments:

    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pAddr - address if fSt is TRUE

Return Value:

    Nothing

--*/
{
    m_fIpResolved = TRUE;

    memcpy( &m_ResolvedAddr, pAddr, sizeof(struct sockaddr*) );

    if ( fSt )
    {
        fSt = (!memcmp( (LPBYTE)(&((PSOCKADDR_IN)pAddr)->sin_addr),
                       (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                       SIZEOF_IP_ADDRESS ) ||
                  (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr == LOCALHOST_ADDRESS)) &&
              CheckName( m_pszDnsName );
    }
    else
    {
        m_dwErrorResolving = ERROR_INVALID_PARAMETER;
    }

    (m_HttpReqCallback)( m_HttpReqParam, fSt );
}


VOID
ADDRESS_CHECK::AddrCheckDnsCallBack3(
    BOOL    fSt,
    struct sockaddr*pAddr
    )
/*++

Routine Description:

    Callback routine from reverse DNS3 resolver

Arguments:

    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pAddr - address if fSt is TRUE

Return Value:

    Nothing

--*/
{
    m_fIpResolved = TRUE;

    memcpy( &m_ResolvedAddr, pAddr, sizeof(struct sockaddr*) );

    if ( fSt )
    {
        fSt = !memcmp( (LPBYTE)(&((PSOCKADDR_IN)pAddr)->sin_addr),
                       (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                       SIZEOF_IP_ADDRESS ) ||
              (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr == LOCALHOST_ADDRESS);
        if ( !fSt )
        {
            m_pszDnsName[ 0 ] = '\0';
        }
    }

    (m_HttpReqCallbackEx)( m_HttpReqParam, fSt, m_pszDnsName );
}


VOID
ADDRESS_CHECK::ResolveDnsCallBack(
    BOOL    fSt,
    LPSTR   pDns
    )
/*++

Routine Description:

    Callback routine from reverse DNS resolver

Arguments:

    fSt - TRUE if reverse DNS resolver success, otherwise FALSE
    pDns - DNS name if fSt is TRUE

Return Value:

    Nothing

--*/
{
    m_fDnsResolved = TRUE;

    if ( fSt )
    {
        strncpy( m_pszDnsName, pDns, DNS_MAX_NAME_LENGTH );
        m_pszDnsName[ DNS_MAX_NAME_LENGTH ] = '\0';

        if ( !m_Storage.GetAlloc() ||
             (((PADDRESS_CHECK_LIST)m_Storage.GetAlloc())->dwFlags & RDNS_FLAG_DODNS2IPCHECK) )
        {
            if ( !m_fIpResolved )
            {
                BOOL fSync;
                BOOL St;

                // get IP addr
                St = AsyncAddrByHost(
                        (PDNSFUNCDESC)&g_ResolveDns2Ip,
                        (DNSARG)this,
                        &m_ResolvedAddr,
                        &fSync,
                        m_pszDnsName );

                if ( St )
                {
                    if ( !fSync )
                    {
                        return;
                    }
                    fSt = (!memcmp( (LPBYTE)(&((PSOCKADDR_IN)&m_ResolvedAddr)->sin_addr),
                                   (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                                   SIZEOF_IP_ADDRESS ) ||
                              (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr == LOCALHOST_ADDRESS)) &&
                          CheckName( pDns );
                }
                else
                {
                    fSt = FALSE;
                }
                m_fIpResolved = TRUE;
            }
        }
    }

    (m_HttpReqCallbackEx)( m_HttpReqParam, fSt, pDns );
}


AC_RESULT
ADDRESS_CHECK::CheckAccess(
    LPBOOL           pfSync,
    ADDRCHECKFUNC    pFunc,
    ADDRCHECKARG     pArg
    )
/*++

Routine Description:

    Check that bound address has access to bound check list
    validation can be either synchronous or asynchronous, caller
    must handle both cases.
    If async, caller must be prepared to handle completion notification
    at any time after calling this function.

Arguments:

    pfSync - updated with TRUE if validation was synchronous
             ( i.e. if return value reflect validation status )
    pFunc - ptr to callback routine use if asynchronous validation
    pArg - argument used when calling pFunc

Return Value:

    If sync, TRUE if bound address validated, otherwise FALSE
    If async, TRUE if request successfully queued, otherwise FALSE

--*/
{
    BOOL St;
    AC_RESULT fSt = CheckAddress( m_pAddr );

    if ( fSt == AC_IN_DENY_LIST || fSt == AC_IN_GRANT_LIST )
    {
        *pfSync = TRUE;
        return fSt;
    }

    if ( !GetNbName( TRUE ) && !GetNbName(FALSE) )
    {
        *pfSync = TRUE;
        return fSt;
    }

    if ( !m_fDnsResolved )
    {
        if ( m_pszDnsName == NULL )
        {
            m_pszDnsName = (CHAR*) LocalAlloc( LPTR, DNS_MAX_NAME_LENGTH + 1 );
            if ( m_pszDnsName == NULL )
            {
                *pfSync = TRUE;
                return AC_NOT_CHECKED;
            }
        }

        m_HttpReqCallback = pFunc;
        m_HttpReqParam = pArg;

        // get DNS name
        St = AsyncHostByAddr(
                (PDNSFUNCDESC)&g_Ip2Dns,
                (DNSARG)this,
                m_pAddr,
                pfSync,
                m_pszDnsName,
                DNS_MAX_NAME_LENGTH
                );
        if ( !St || !*pfSync )
        {
            return AC_NOT_CHECKED;
        }
        m_fDnsResolved = TRUE;
    }
    else
    {
        *pfSync = TRUE;
    }

    if ( !m_Storage.GetAlloc() ||
         (((PADDRESS_CHECK_LIST)m_Storage.GetAlloc())->dwFlags & RDNS_FLAG_DODNS2IPCHECK) )
    {
        if ( !m_fIpResolved )
        {
            // get IP addr
            St = AsyncAddrByHost(
                    (PDNSFUNCDESC)&g_Dns2Ip,
                    (DNSARG)this,
                    &m_ResolvedAddr,
                    pfSync,
                    m_pszDnsName );
            if ( !St || !*pfSync )
            {
                return AC_NOT_CHECKED;
            }
            m_fIpResolved = TRUE;
        }
        if ( memcmp( (LPBYTE)(&((PSOCKADDR_IN)&m_ResolvedAddr)->sin_addr),
                     (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                     SIZEOF_IP_ADDRESS ) &&
             (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr != LOCALHOST_ADDRESS))
        {
            return AC_IN_DENY_LIST;
        }
    }

    return CheckName( m_pszDnsName );
}


AC_RESULT
ADDRESS_CHECK::CheckIpAccess(
    LPBOOL pfNeedDns
    )
/*++

Routine Description:

    Check that bound address has access to bound IP check list

Arguments:

    pfNeedDns - updated with TRUE if DNS access check necessary

Return Value:

    returns AC_RESULT

--*/
{
    AC_RESULT ac = CheckAddress( m_pAddr );

    if ( ac != AC_IN_DENY_LIST && ac != AC_IN_GRANT_LIST )
    {
        *pfNeedDns = (GetNbName( TRUE ) || GetNbName(FALSE));
    }
    else
    {
        *pfNeedDns = FALSE;
    }

    return ac;
}

#if 0
AC_RESULT
ADDRESS_CHECK::CheckDnsAccess(
    LPBOOL pfGranted,
    LPBOOL pfIsList
    )
/*++

Routine Description:

    Check that bound DNS name has access to bound DNS check list

Arguments:

    pfGranted - updated with TRUE if access granted, otherwise FALSE
    pfIsList- updated with TRUE if address found in deny/grant list

Return Value:

    return TRUE if no error, otherwise FALSE

--*/
{
    return CheckName( m_pszDnsName );

}
#endif


LPSTR
ADDRESS_CHECK::InitReverse(
    LPSTR pR,
    LPSTR pTarget,
    LPBOOL pfAlloc
    )
/*++

Routine Description:

    Build a reversed DNS representation of supplied DNS name

Arguments:

    pR - DNS name to reverse
    pTarget - ptr to buffer to be used for reverse representation,
              assumed to be SIZE_FAST_REVERSE_DNS byte wide
    pfAlloc - updated with TRUE if memory allocation was necessary
              to hold result. To be presented to TerminateReverse()

Return Value:

    buffer holding reversed representation of DNS name, to be presented
    to TerminateReverse()

--*/
{
    UINT    l = strlen( pR );
    LPSTR   p = pTarget;
    if ( l > SIZE_FAST_REVERSE_DNS )
    {
        if ( (p = (LPSTR)LocalAlloc( LMEM_FIXED, l ))==NULL )
        {
                        // BugFix: 47980, 47981, 47989 Whistler
                        //         Prefix bug pfAlloc not being set.
                        //         EBK 5/5/2000
                        *pfAlloc = FALSE;
            return p;
        }
        *pfAlloc = TRUE;
    }
    else
    {
        *pfAlloc = FALSE;
    }

    // reverse pR to p

    LPSTR pD;
    UINT cS;
    LPSTR pT = p + l;

    *pT = '\0';

    if ( *pR )
    {
        for ( ;; )
        {
            if ( pD = (LPSTR)memchr( pR, '.', l ) )
            {
                cS = DIFF(pD - pR);
            }
            else
            {
                cS = l;
            }

            memcpy( pT - cS, pR, cS );

            if ( pR[cS++] )
            {
                pR += cS;
                pT -= cS;
                *pT = '.';
                l -= cS;
            }
            else
            {
                break;
            }
        }
    }

    return p;
}


VOID
ADDRESS_CHECK::TerminateReverse(
    LPSTR   pAlloc,
    BOOL    fAlloc
    )
/*++

Routine Description:

    Free resources used by InitReverse

Arguments:

    pAlloc - buffer holding result of InitReverse()
    fAlloc - flag updated by InitReverse()

Return Value:

    Nothing

--*/
{
    if ( fAlloc )
    {
        LocalFree( pAlloc );
    }
}


BOOL
ADDRESS_CHECK::CheckReversedName(
    LPSTR            pName
    )
/*++

Routine Description:

    Check if DNS name ( reversed format ) is in grant or deny list

Arguments:

    pName - DNS name

Return Value:

    TRUE if name is granted access, otherwise FALSE

--*/
{
    CHAR    achReversed[SIZE_FAST_REVERSE_DNS];

        // BugFix: 117800, 117809, 117818,  Whistler
        //         Prefix bug fAlloc not being set.
        //         Prefix did not like the fix to just make
        //         sure it was set in InitReverse, so now I 
        //         am initializing it prior to the call.  It's
        //         overkill, but should make prefix happy.
        //         EBK 5/15/2000
    BOOL    fAlloc = FALSE;
    LPSTR   pReversed;
    BOOL    fSt;

    if ( pReversed = InitReverse( pName, achReversed, &fAlloc ) )
    {
        fSt = CheckReversedName( pReversed );
    }
    else
    {
        fSt = FALSE;
    }

    TerminateReverse( pReversed, fAlloc );

    return fSt;
}


AC_RESULT
ADDRESS_CHECK::CheckName(
    LPSTR            pName
    )
/*++

Routine Description:

    Check if DNS name is in grant or deny list

Arguments:

    pName - DNS name

Return Value:

    TRUE if name is granted access, otherwise FALSE

--*/
{
    // if name is empty, it cannot be checked
    if (pName[0] == '\0')
    {
        return AC_NOT_CHECKED;
    }
    
    // if deny list non empty, check not in list

    if ( GetNbName( FALSE ) )
    {
        if ( IsMatchName( FALSE, pName ) )
        {
            return AC_IN_DENY_LIST;
        }
        return AC_NOT_IN_DENY_LIST;
    }

    // if grant list non empty, check in list

    if ( GetNbName( TRUE ) )
    {
        if ( IsMatchName( TRUE, pName ) )
        {
            return AC_IN_GRANT_LIST;
        }
        return AC_NOT_IN_GRANT_LIST;
    }

    return AC_NO_LIST;
}


UINT
ADDRESS_CHECK::GetNbComponent(
    LPSTR pName
    )
/*++

Routine Description:

    Returns number of components in DNS name

Arguments:

    pName - DNS name

Return Value:

    Number of components.

--*/
{
    LPSTR   pDot = pName;
    UINT    cComp;

    for ( cComp = 1 ; pDot = strchr( pDot, '.') ; ++cComp )
    {
        ++pDot;
    }

    return cComp;
}


BOOL
ADDRESS_CHECK::AddReversedName(
    BOOL fGrant,
    LPSTR pName
    )
/*++

Routine Description:

    Add a name entry, reversing its DNS components

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    pName - ptr to DNS name

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CHAR    achReversed[SIZE_FAST_REVERSE_DNS];
        // BugFix: 117800, 117809, 117818,  Whistler
        //         Prefix bug fAlloc not being set.
        //         Prefix did not like the fix to just make
        //         sure it was set in InitReverse, so now I 
        //         am initializing it prior to the call.  It's
        //         overkill, but should make prefix happy.
        //         EBK 5/15/2000
    BOOL    fAlloc = FALSE;
    LPSTR   pReversed;
    BOOL    fSt;

    if ( pReversed = InitReverse( pName, achReversed, &fAlloc ) )
    {
        fSt = AddName( fGrant, pReversed );
    }
    else
    {
        fSt = FALSE;
    }

    TerminateReverse( pReversed, fAlloc );

    return fSt;
}


BOOL
ADDRESS_CHECK::AddName(
    BOOL    fGrant,
    LPSTR   pName,
    DWORD   dwFlags
    )
/*++

Routine Description:

    Add a name entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    pName - ptr to DNS name
    dwFlags - flags

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;
    UINT                iL;
    UINT                cS = GetNbComponent( pName ) | ( dwFlags & DNSLIST_FLAG_NOSUBDOMAIN );
    UINT                cN = strlen( pName ) + 1;
    LPBYTE              pA;
    LPBYTE              pS;
    PNAME_LIST_ENTRY    pE;
    UINT                iS;
    int                 cm;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        pE = (PNAME_LIST_ENTRY)((LPBYTE)pHd + sizeof(NAME_HEADER));
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            if ( pE->cComponents == cS )
            {
                // found matching family, mask
                // find where to insert
                DWORD i;
                for ( i= 0 ; i < pE->cNames ; ++i )
                {
                    pS = MAKEPTR(pStore, pE->iName[i] );
                    if ( !(cm = _stricmp( pName, (LPSTR)pS )) )
                    {
                        // already exist
                        return FALSE;
                    }
                    else if ( cm < 0 )
                    {
                        // insert @ i
insert_name:
                        UINT s = m_Storage.GetUsed();
                        iS = DIFF((LPBYTE)pE - pStore);
                        if ( m_Storage.Resize( sizeof(SELFREFINDEX)+cN ) )
                        {
                            int l;
                            // refresh ptrs
                            pStore = m_Storage.GetAlloc();
                            pList = (PADDRESS_CHECK_LIST)pStore;
                            pHd = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
                            pE = (PNAME_LIST_ENTRY)(pStore+iS);

                            pS = MAKEPTR(pStore, l=DIFF((LPBYTE)(pE->iName+i)-pStore) );
                            memmove( pS+sizeof(SELFREFINDEX), pS, s-l );
                            pList->cRefSize += sizeof(SELFREFINDEX);
                            AdjustRefs( pStore, l, sizeof(SELFREFINDEX) );
                            s+=sizeof(SELFREFINDEX);
                            pE->iName[i] = MAKEREF(s);
                            memcpy( MAKEPTR(pStore,s), pName, cN );
                            ++pE->cNames;
                            ++pHd->cNames;
                            return TRUE;
                        }
                        return FALSE;
                    }
                }
                goto insert_name;
            }
            else if ( cS < pE->cComponents )
            {
insert_at_current_pos:
                // must insert new Entry @ pE
                int i = m_Storage.GetUsed()+sizeof(NAME_LIST_ENTRY)+sizeof(SELFREFINDEX);
                UINT iS = DIFF((LPBYTE)pE - pStore);
                UINT cWasUsed = m_Storage.GetUsed();
                if ( m_Storage.Resize( sizeof(NAME_LIST_ENTRY)+sizeof(SELFREFINDEX)+cN ) )
                {
                    // refresh ptrs
                    pStore = m_Storage.GetAlloc();
                    pList = (PADDRESS_CHECK_LIST)pStore;
                    pHd = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
                    pE = (PNAME_LIST_ENTRY)(pStore +iS);
                    pList->cRefSize += sizeof(NAME_LIST_ENTRY)+sizeof(SELFREFINDEX);

                    // make room for entry
                    memmove( (LPBYTE)(pE+1) + sizeof(SELFREFINDEX),
                             pE,
                             cWasUsed - iS );
                    AdjustRefs( pStore, iS, sizeof(NAME_LIST_ENTRY)+sizeof(SELFREFINDEX) );

                    pE->cComponents = cS;
                    pE->cNames = 1;
                    pE->iName[0] = MAKEREF( i );

                    // copy name
                    pA = MAKEPTR( pStore, i );
                    memcpy( pA, pName, cN );

                    ++pHd->cEntries;
                    ++pHd->cNames;
                    return TRUE;
                }
                break;
            }
            pE = (PNAME_LIST_ENTRY)((LPBYTE)pE + sizeof(NAME_LIST_ENTRY) + pE->cNames * sizeof(SELFREFINDEX));
        }
        goto insert_at_current_pos;
    }

    return FALSE;
}


BOOL
ADDRESS_CHECK::DeleteName(
    BOOL fGrant,
    DWORD iIndex
    )
/*++

Routine Description:

    Delete a DNS name entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    PNAME_LIST_ENTRY    pE;
    PNAME_HEADER        pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateName( fGrant, iIndex, &pHd, &pE, &iIndexInHeader ) )
    {
        UINT iS = MAKEOFFSET( pE->iName[iIndexInHeader] );
        LPBYTE pAddr = MAKEPTR(pStore, iS);
        UINT cS = strlen( (LPSTR)pAddr ) + 1;

        memmove( pAddr,
                 pAddr + cS,
                 m_Storage.GetUsed() - iS - cS );
        AdjustRefs( pStore, iS, -(int)cS );
        m_Storage.AdjustUsed( -(int)cS );

        iS = DIFF((LPBYTE)(pE->iName+iIndexInHeader) - pStore);
        memmove( pE->iName+iIndexInHeader,
                 pE->iName+iIndexInHeader+1,
                 m_Storage.GetUsed() - iS - sizeof(SELFREFINDEX) );
        ((PADDRESS_CHECK_LIST)pStore)->cRefSize -= sizeof(SELFREFINDEX);
        AdjustRefs( pStore, DIFF((LPBYTE)pE - pStore), (DWORD)-(int)sizeof(SELFREFINDEX) );
        m_Storage.AdjustUsed( -(int)sizeof(SELFREFINDEX) );

        --pE->cNames;
        --pHd->cNames;

        return TRUE;
    }

    return FALSE;
}


BOOL
ADDRESS_CHECK::GetReversedName(
    BOOL fGrant,
    DWORD iIndex,
    LPSTR pName,
    LPDWORD pdwSize
    )
/*++

Routine Description:

    Get DNS name in specified list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index (0-based) in specified list
    pName - ptr to buffer to be used to hold result
    pdwSize - in: specify buffer max length. out: result size
              ( including '\0' delimiter )

Return Value:

    TRUE if iIndex valid in specified list and buffer wide enough
    to hold result, FALSE otherwise ( can be ERROR_NOT_ENOUGH_MEMORY,
    ERROR_INVALID_PARAMETER )

--*/
{
    CHAR    achReversed[SIZE_FAST_REVERSE_DNS];

        // BugFix: 117800, 117809, 117818,  Whistler
        //         Prefix bug fAlloc not being set.
        //         Prefix did not like the fix to just make
        //         sure it was set in InitReverse, so now I 
        //         am initializing it prior to the call.  It's
        //         overkill, but should make prefix happy.
        //         EBK 5/15/2000
    BOOL    fAlloc = FALSE;
    LPSTR   pReversed;
    BOOL    fSt = FALSE;
    LPSTR   pRName;

    if ( GetName( fGrant, iIndex, &pRName ) )
    {
        if ( pReversed = InitReverse( pRName, achReversed, &fAlloc ) )
        {
            UINT l = strlen( pReversed ) + 1;
            if ( l <= *pdwSize )
            {
                memcpy( pName, pReversed, l );
                fSt = TRUE;
            }
            else
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            }
            *pdwSize = l;
        }
        else
        {
            SetLastError( 0 );
            *pdwSize = 0;
        }

        TerminateReverse( pReversed, fAlloc );
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        *pdwSize = 0;
    }

    return fSt;
}


BOOL
ADDRESS_CHECK::GetName(
    BOOL        fGrant,
    DWORD       iIndex,
    LPSTR*      ppName,
    LPDWORD     pdwFlags
    )
/*++

Routine Description:

    Get DNS name in specified list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index (0-based) in specified list
    ppName - updated with ptr to DNS name
    pdwFlags - updated with DNS flags, can be NULL

Return Value:

    TRUE if iIndex valid in specified list, otherwise FALSE

--*/
{
    PNAME_LIST_ENTRY    pHeader;
    PNAME_HEADER        pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateName( fGrant, iIndex, &pHd, &pHeader, &iIndexInHeader ) )
    {
        *ppName = (LPSTR)MAKEPTR(pStore, pHeader->iName[iIndexInHeader] );
        if ( pdwFlags )
        {
            *pdwFlags = pHeader->cComponents & DNSLIST_FLAGS;
        }

        return TRUE;
    }

    return FALSE;
}


DWORD
ADDRESS_CHECK::GetNbName(
    BOOL fGrant
    )
/*++

Routine Description:

    Get number of entries in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list

Return Value:

    Number of entries in list

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        return pHd->cNames;
    }

    return 0;
}


BOOL
ADDRESS_CHECK::LocateName(
    BOOL fGrant,
    DWORD iIndex,
    PNAME_HEADER* ppHd,
    PNAME_LIST_ENTRY* pHeader,
    LPDWORD piIndexInHeader
    )
/*++

Routine Description:

    Locate a name in the specified list, returns ptr
    to header & element in address list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list ( 0-based )
    ppHd - updated with ptr to name header
    pHeader - updated with ptr to name list entry
    piIndexInHeader - updated with index in array pHeader->iName

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;
    PNAME_LIST_ENTRY    pE;
    UINT                iL;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        *ppHd = pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        pE = (PNAME_LIST_ENTRY)((LPBYTE)pHd + sizeof(NAME_HEADER));
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            if ( iIndex < pE->cNames )
            {
                *pHeader = pE;
                *piIndexInHeader = iIndex;
                return TRUE;
            }
            iIndex -= pE->cNames;
            pE = (PNAME_LIST_ENTRY)((LPBYTE)pE + sizeof(NAME_LIST_ENTRY) + pE->cNames * sizeof(SELFREFINDEX));
        }
    }

    return FALSE;
}


BOOL
ADDRESS_CHECK::DeleteAllName(
    BOOL fGrant
    )
/*++

Routine Description:

    Delete all DNS name entries

Arguments:

    fGrant - TRUE to delete in grant list, FALSE for deny list

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    while ( DeleteName( fGrant, 0 ) )
    {
    }

    return TRUE;
}


BOOL
ADDRESS_CHECK::IsMatchName(
    BOOL fGrant,
    LPSTR pName
    )
/*++

Routine Description:

    Check if name in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    pName - ptr to DNS name

Return Value:

    TRUE if name is in specified list, otherwise FALSE

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;
    PNAME_LIST_ENTRY    pE;
    UINT                iL;
    UINT                cS;
    NAMECMPDESC         ncd;
    DWORD               cbNameLength;
    BOOL                fTryAgain = FALSE;
    CHAR                achName[ DNS_MAX_NAME_LENGTH + 1 ];
    
    ncd.pBase = pStore;

    if ( pStore )
    {
        strncpy( achName, pName, DNS_MAX_NAME_LENGTH );
        achName[ DNS_MAX_NAME_LENGTH ] = '\0';
        
        cbNameLength = strlen( achName );
        pName = achName; 

        // BugFix: 47983 Whistler
        //         Prefix bug pName not being valid.
        //         EBK 5/5/2000         
        DBG_ASSERT(cbNameLength >= 1);
        
        if ( pName && pName[ cbNameLength - 1 ] == '.' )
        {
            // This is an FQDN (i.e. it has a period at the end).  
            // We need to be more careful with our handling of it, since we want
            // to match against checks which didn't specify the trailing period.
        
            fTryAgain = TRUE;
     
            // Temporarily remove the trailing period
        
            pName[ cbNameLength - 1 ] = '\0';
        }
TryAgain:
        /* INTRINSA suppress = uninitialized */
        cS = GetNbComponent( pName );

        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        pE = (PNAME_LIST_ENTRY)((LPBYTE)pHd + sizeof(NAME_HEADER));
        for ( iL = 0 ; iL < pHd->cEntries  ; ++iL )
        {
            UINT cASComp = pE->cComponents & ~DNSLIST_FLAGS;
            if ( cS == cASComp ||
                 ((cS > cASComp) && !(pE->cComponents & DNSLIST_FLAG_NOSUBDOMAIN)) )
            {
                LPSTR p = pName;
                BOOL fSt;
                if ( cS > cASComp )
                {
                    int i = cS - cASComp;
                    for ( ; i-- ; )
                    {
                        if ( p = strchr( p, '.' ) )
                        {
                            ++p;
                        }
                    }
                }
                ncd.pName = (LPVOID)p;

                fSt = BsearchEx( p,
                                 pE->iName,
                                 pE->cNames,
                                 sizeof(SELFREFINDEX),
                                 (CMPFUNC)NameCmp,
                                 &ncd ) != NULL;
                if ( fSt )
                {
                    return TRUE;
                }
            }
            pE = (PNAME_LIST_ENTRY)((LPBYTE)pE + sizeof(NAME_LIST_ENTRY) + pE->cNames * sizeof(SELFREFINDEX));
        }
        
        if ( fTryAgain )
        {
            fTryAgain = FALSE;
            
            pName[ cbNameLength - 1 ] = '.';
            goto TryAgain;
        }
    }

    return FALSE;
}

#if 0 // inlined now

BOOL
ADDRESS_CHECK::BindAddr(
    struct sockaddr* pAddr
    )
/*++

Routine Description:

    Bind an address to an ADDRESS_CHECK object

Arguments:

    pAddr - ptr to address

Return Value:

    TRUE if sucess, FALSE otherwise

--*/
{
    m_pAddr = pAddr;
    m_fDnsResolved = FALSE;
    m_fIpResolved = FALSE;
    m_dwErrorResolving = 0;

    return TRUE;
}


VOID
ADDRESS_CHECK::UnbindAddr(
    VOID
    )
/*++

Routine Description:

    Unbind an address to an ADDRESS_CHECK object

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_pAddr = NULL;
    m_fDnsResolved = FALSE;
}

# endif // 0

BOOL
ADDRESS_CHECK::QueryDnsName(
    LPBOOL           pfSync,
    ADDRCHECKFUNCEX  pFunc,
    ADDRCHECKARG     pArg,
    LPSTR *          ppName
    )
/*++

Routine Description:

    Reverse resolve bound address to DNS name

Arguments:

    pfSync - updated with TRUE if validation was synchronous
             ( i.e. if return value reflect validation status )
    pFunc - ptr to callback routine use if asynchronous validation
    pArg - argument used when calling pFunc

Return Value:

    If sync, TRUE if bound address validated, otherwise FALSE
    If async, TRUE if request successfully queued, otherwise FALSE

--*/
{
    BOOL fSt;

    if ( !m_pAddr )
    {
        return FALSE;
    }

    if ( !m_fDnsResolved )
    {
        if ( m_pszDnsName == NULL )
        {
            m_pszDnsName = (CHAR*) LocalAlloc( LPTR, DNS_MAX_NAME_LENGTH + 1 );
            if ( m_pszDnsName == NULL )
            {
                return FALSE;
            }
        }

        m_HttpReqCallbackEx = pFunc;
        m_HttpReqParam = pArg;

        // get DNS name
        fSt = AsyncHostByAddr(
            (PDNSFUNCDESC)(pFunc ? &g_ResolveDns : NULL),
                (DNSARG)this,
                m_pAddr,
                pfSync,
                m_pszDnsName,
                DNS_MAX_NAME_LENGTH
                );
        if ( !fSt || !*pfSync )
        {
            return fSt;
        }
        m_fDnsResolved = TRUE;
        
        if ( m_pszDnsName[ 0 ] == '\0' )
        {
            m_dwErrorResolving = ERROR_INVALID_PARAMETER;
            return FALSE;
        }
    }
    else
    {
        *pfSync = TRUE;
    }

    if ( !m_Storage.GetAlloc() ||
         (((PADDRESS_CHECK_LIST)m_Storage.GetAlloc())->dwFlags & RDNS_FLAG_DODNS2IPCHECK) )
    {
        if ( !m_fIpResolved )
        {
            m_HttpReqCallbackEx = pFunc;
            m_HttpReqParam = pArg;

            // get IP addr
            fSt = AsyncAddrByHost(
                (PDNSFUNCDESC)(pFunc ? &g_ResolveDns2Ip : NULL),
                    (DNSARG)this,
                    &m_ResolvedAddr,
                    pfSync,
                    m_pszDnsName );
            if ( !fSt || !*pfSync )
            {
                return fSt;
            }
            m_fIpResolved = TRUE;
            if ( !memcmp( (LPBYTE)(&((PSOCKADDR_IN)&m_ResolvedAddr)->sin_addr),
                          (LPBYTE)NULL_IP_ADDR,
                          SIZEOF_IP_ADDRESS ) )
            {
                m_dwErrorResolving = ERROR_INVALID_PARAMETER;
                return FALSE;
            }
        }
        if ( memcmp( (LPBYTE)(&((PSOCKADDR_IN)&m_ResolvedAddr)->sin_addr),
                     (LPBYTE)(&((PSOCKADDR_IN)m_pAddr)->sin_addr),
                     SIZEOF_IP_ADDRESS ) && 
             (((PSOCKADDR_IN)m_pAddr)->sin_addr.s_addr != LOCALHOST_ADDRESS ) )
        {
            m_pszDnsName[ 0 ] = '\0';
            return FALSE;
        }
    }

    *ppName = m_pszDnsName;

    return TRUE;
}


BOOL
CSidCache::Init(
    VOID
    )
/*++

Routine Description:

    Initialize SID cache object

Arguments:

    None

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    INITIALIZE_CRITICAL_SECTION( &csLock );

    return TRUE;
}


VOID
CSidCache::Terminate(
    VOID
    )
/*++

Routine Description:

    Terminate SID cache object

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DeleteCriticalSection( &csLock );
}


BOOL
CSidCache::AddToCache(
    PSID pSid,
    DWORD dwTTL
    )
/*++

Routine Description:

    Add SID entry to cache

Arguments:

    pSid - SID to add to cache
    dwTTL - Time to Live ( in seconds ) in cache

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    BOOL fSt = TRUE;

    EnterCriticalSection( &csLock );

    if ( !IsInCache( pSid ) )
    {
        DWORD dwL = GetLengthSid( pSid );
        DWORD dwWas = xaStore.GetUsed();
        if ( xaStore.Resize( sizeof(SID_CACHE_ENTRY) + dwL ) )
        {
            PSID_CACHE_ENTRY pB = (PSID_CACHE_ENTRY)(xaStore.GetAlloc()
                                                     + dwWas );
            pB->tExpire = (DWORD)(time(NULL) + dwTTL);
            pB->dwSidLen = dwL;
            memcpy( pB->Sid, pSid, dwL );
        }
        else
        {
            fSt = FALSE;
        }
    }

    LeaveCriticalSection( &csLock );

    return fSt;
}


BOOL
CSidCache::IsInCache(
    PSID  pSid
    )
/*++

Routine Description:

    Check if SID present and in cache

Arguments:

    pSid - SID to add to cache

Return Value:

    TRUE if found, FALSE otherwise

--*/
{
    return CheckPresentAndResetTtl( pSid, 0xffffffff );
}


BOOL
CSidCache::CheckPresentAndResetTtl(
    PSID  pSid,
    DWORD dwTtl
    )
/*++

Routine Description:

    Check if SID present and in cache and if found
    update its TTL

Arguments:

    pSid - SID to add to cache
    dwTTL - Time to Live ( in seconds ) in cache

Return Value:

    TRUE if found, FALSE otherwise

--*/
{
    // walk through xaStore,
    BOOL fSt = FALSE;

    EnterCriticalSection( &csLock );

    PSID_CACHE_ENTRY pB = (PSID_CACHE_ENTRY)(xaStore.GetAlloc() );
    PSID_CACHE_ENTRY pM = (PSID_CACHE_ENTRY)(xaStore.GetAlloc()
                                             + xaStore.GetUsed());

    if ( pB )
    {
        while ( pB < pM )
        {
            if ( EqualSid( (PSID)(pB->Sid), pSid ) )
            {
                if ( dwTtl != 0xffffffff )
                {
                    pB->tExpire = (DWORD)(time(NULL) + dwTtl);
                }
                fSt = TRUE;
                break;
            }
            pB = (PSID_CACHE_ENTRY)( (LPBYTE)pB + pB->dwSidLen + sizeof(SID_CACHE_ENTRY) );
        }
    }

    LeaveCriticalSection( &csLock );

    return fSt;
}


BOOL
CSidCache::Scavenger(
    VOID
    )
/*++

Routine Description:

    Remove expired entries from cache based on TTL

Arguments:

    None

Return Value:

    TRUE if no error, FALSE otherwise

--*/
{
    // walk through xaStore,
    BOOL fSt = TRUE;

    EnterCriticalSection( &csLock );

    PSID_CACHE_ENTRY pB = (PSID_CACHE_ENTRY)(xaStore.GetAlloc() );
    PSID_CACHE_ENTRY pM = (PSID_CACHE_ENTRY)(xaStore.GetAlloc()
                                             + xaStore.GetUsed());
    DWORD tNow = (DWORD)(time(NULL));
    DWORD dwAdj = 0;

    if ( pB )
    {
        while ( pB < pM )
        {
            DWORD dwL = pB->dwSidLen+sizeof(SID_CACHE_ENTRY);
            if ( pB->tExpire <= tNow )
            {
                dwAdj += dwL;
            }
            else if ( dwAdj )
            {
                memmove( (LPBYTE)pB-dwAdj,
                         pB,
                         dwL );
            }
            pB = (PSID_CACHE_ENTRY)( (LPBYTE)pB + dwL );
        }
        xaStore.AdjustUsed( -(int)dwAdj );
    }

    LeaveCriticalSection( &csLock );

    return fSt;
}


#if DBG
VOID
ADDRESS_CHECK::DumpAddr(
    BOOL fGrant
    )
{
    UINT i = GetNbAddr( fGrant );
    UINT x;
    for ( x = 0 ; x < i ; ++x )
    {
        LPBYTE pM;
        LPBYTE pA;
        DWORD dwF;
        GetAddr( fGrant, x, &dwF, &pM, &pA );

        CHAR achE[80];
        wsprintf( achE, "%d.%d.%d.%d %d.%d.%d.%d\r\n",
            pM[0], pM[1], pM[2], pM[3],
            pA[0], pA[1], pA[2], pA[3] );
        OutputDebugString( achE );
    }
}


VOID
ADDRESS_CHECK::DumpName(
    BOOL fGrant
    )
{
    UINT i = GetNbName( fGrant );
    UINT x;
    for ( x = 0 ; x < i ; ++x )
    {
        //CHAR achN[80];
        //DWORD dwN = sizeof(achN);
        LPSTR pN;
        GetName( fGrant, x, &pN );  //achN, &dwN );
        OutputDebugString( pN );
        OutputDebugString( "\r\n" );
    }
}


VOID
ADDRESS_CHECK::DumpAddrAndName(
    VOID
    )
{
    OutputDebugString( "Addr granted:\r\n" );
    DumpAddr( TRUE );
    OutputDebugString( "Addr denied:\r\n" );
    DumpAddr( FALSE );

    OutputDebugString( "Name granted:\r\n" );
    DumpName( TRUE );
    OutputDebugString( "Name denied:\r\n" );
    DumpName( FALSE );
}


void CaBack( ADDRCHECKARG pArg, BOOL f )
{
    CHAR achE[80];
    wsprintf( achE, "pArg=%08x, BOOL = %d\r\n", pArg, f );
    OutputDebugString( achE );
}


VOID TestAPI()
{
    ADDRESS_CHECK *pac=new ADDRESS_CHECK;

    pac->BindCheckList();

    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\xff\x0\x0", (LPBYTE)"\x55\x66\x77\x88" );
    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\xff\x0\x0", (LPBYTE)"\x44\x66\x77\x88" );
    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\xff\x0\x0", (LPBYTE)"\x55\x77\x77\x88" );
    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\xff\x0\x0", (LPBYTE)"\x55\x66\x77\x88" );  // should fail
    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\x00\x0\x0", (LPBYTE)"\x55\x66\x77\x88" );
    pac->AddAddr( TRUE, AF_INET, (LPBYTE)"\xff\xff\xff\x0",(LPBYTE)"\x55\x66\x77\x88" );

    UINT i = pac->GetNbAddr( TRUE );
    UINT x;
    for ( x = 0 ; x < i ; ++x )
    {
        LPBYTE pM;
        LPBYTE pA;
        DWORD dwF;
        pac->GetAddr( TRUE, x, &dwF, &pM, &pA );
    }

    pac->DeleteAddr( TRUE, 1 );
    pac->DeleteAddr( TRUE, 1 );
    pac->DeleteAddr( TRUE, 1 );
    pac->DeleteAddr( TRUE, 1 );
    pac->DeleteAddr( TRUE, 1 );   // should fail
    pac->DeleteAddr( TRUE, 0 );
    pac->DeleteAddr( TRUE, 0 );   // should fail

    // names

    pac->AddName( TRUE, "msft.com" );
    pac->AddName( TRUE, "msft.com" ); // should fail
    pac->AddName( TRUE, "fr" );
    pac->AddName( TRUE, "www.sunw.com" );
    pac->AddName( TRUE, "ftp.sunw.com" );
    pac->AddName( TRUE, "aapl.com" );

    i = pac->GetNbName( TRUE );
    x;
    for ( x = 0 ; x < i ; ++x )
    {
        //CHAR achN[80];
        //DWORD dwN = sizeof(achN);
        LPSTR pN;
        pac->GetName( TRUE, x, &pN );  //achN, &dwN );
    }

    pac->CheckName( "msft.com" );

    sockaddr* psa = new sockaddr;
    BOOL fInList;
    psa->sa_family = AF_INET;
    memcpy( (&((PSOCKADDR_IN)psa)->sin_addr), "\x44\x66\xaa\xbb", SIZEOF_IP_ADDRESS );
    pac->CheckAddress( psa );

    BOOL fSync;
    psa->sa_family = AF_INET;
    memcpy( (&((PSOCKADDR_IN)psa)->sin_addr), "\x9d\x37\x53\x48", SIZEOF_IP_ADDRESS );    // PHILLICH3
    pac->BindAddr( psa );
    pac->CheckAccess( &fSync, (ADDRCHECKFUNC)CaBack, (ADDRCHECKARG)NULL );

//    pac->DeleteName( TRUE, 1 );
//    pac->DeleteName( TRUE, 1 );
//    pac->DeleteName( TRUE, 1 );
//    pac->DeleteName( TRUE, 1 );
//    pac->DeleteName( TRUE, 1 );   // should fail
//    pac->DeleteName( TRUE, 0 );
//    pac->DeleteName( TRUE, 0 );   // should fail
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\sec\secobj.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    secobj.c

Abstract:

    This module provides support routines to simplify the creation of
    security descriptors for user-mode objects.

    Adapted the code from \nt\private\net\netlib\secobj.h

Author:

    Rita Wong (ritaw) 27-Feb-1991

Environment:

    Contains NT specific code.

Revision History:

    16-Apr-1991 JohnRo
        Include header files for <netlib.h>.

    14 Apr 1992 RichardW
        Changed for modified ACE_HEADER struct.

    19 Sep. 1995 MadanA
        Adapted the code for the internet project and made to use WIN32
        APIs instead RTL functions.

--*/

#include <windows.h>
#include <rpc.h>

#include <inetsec.h>
#include <proto.h>

#if DBG
#define STATIC
#else
#define STATIC static
#endif // DBG

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// NT well-known SIDs
//

PSID NullSid = NULL;                  // No members SID
PSID WorldSid = NULL;                 // All users SID
PSID LocalSid = NULL;                 // NT local users SID
PSID NetworkSid = NULL;               // NT remote users SID
PSID LocalSystemSid = NULL;           // NT system processes SID
PSID BuiltinDomainSid = NULL;         // Domain Id of the Builtin Domain

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//

PSID LocalAdminSid = NULL;            // NT local admins SID
PSID AliasAdminsSid = NULL;
PSID AliasUsersSid = NULL;
PSID AliasGuestsSid = NULL;
PSID AliasPowerUsersSid = NULL;
PSID AliasAccountOpsSid = NULL;
PSID AliasSystemOpsSid = NULL;
PSID AliasPrintOpsSid = NULL;
PSID AliasBackupOpsSid = NULL;

STATIC
struct _SID_DATA {
    PSID *Sid;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    ULONG SubAuthority;
} SidData[] = {
 {&NullSid,          SECURITY_NULL_SID_AUTHORITY,  SECURITY_NULL_RID},
 {&WorldSid,         SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID},
 {&LocalSid,         SECURITY_LOCAL_SID_AUTHORITY, SECURITY_LOCAL_RID},
 {&NetworkSid,       SECURITY_NT_AUTHORITY,        SECURITY_NETWORK_RID},
 {&LocalSystemSid,   SECURITY_NT_AUTHORITY,        SECURITY_LOCAL_SYSTEM_RID},
 {&BuiltinDomainSid, SECURITY_NT_AUTHORITY,        SECURITY_BUILTIN_DOMAIN_RID}
};

STATIC
struct _BUILTIN_DOMAIN_SID_DATA {
    PSID *Sid;
    ULONG RelativeId;
} BuiltinDomainSidData[] = {
    { &LocalAdminSid, DOMAIN_ALIAS_RID_ADMINS},
    { &AliasAdminsSid, DOMAIN_ALIAS_RID_ADMINS },
    { &AliasUsersSid, DOMAIN_ALIAS_RID_USERS },
    { &AliasGuestsSid, DOMAIN_ALIAS_RID_GUESTS },
    { &AliasPowerUsersSid, DOMAIN_ALIAS_RID_POWER_USERS },
    { &AliasAccountOpsSid, DOMAIN_ALIAS_RID_ACCOUNT_OPS },
    { &AliasSystemOpsSid, DOMAIN_ALIAS_RID_SYSTEM_OPS },
    { &AliasPrintOpsSid, DOMAIN_ALIAS_RID_PRINT_OPS },
    { &AliasBackupOpsSid, DOMAIN_ALIAS_RID_BACKUP_OPS }
};

PVOID
INetpMemoryAllocate(
    DWORD Size
    )
/*++

Routine Description:

    This function allocates the required size of memory by calling
    LocalAlloc.

Arguments:

    Size - size of the memory block required.

Return Value:

    Pointer to the allocated block.

--*/
{

    LPVOID NewPointer;

    NewPointer = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Size );

#if DBG
    // ASSERT( NewPointer != NULL );
#endif

    return( NewPointer );
}

VOID
INetpMemoryFree(
    PVOID Memory
    )
/*++

Routine Description:

    This function frees up the memory that was allocated by
    InternetAllocateMemory.

Arguments:

    Memory - pointer to the memory block that needs to be freed up.

Return Value:

    none.

--*/
{

    LPVOID Ptr;

#if DBG
    // ASSERT( Memory != NULL );
#endif

    Ptr = LocalFree( Memory );

#if DBG
    // ASSERT( Ptr == NULL );
#endif
}

DWORD
INetpInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an allowed type ACE.

Arguments:

    AllowedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is allowed
        the specified access.

Return Value:

    WIN32 Error Code.

--*/
{
    AllowedAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    AllowedAce->Header.AceSize = AceSize;
    AllowedAce->Header.AceFlags = AceFlags | InheritFlags;

    AllowedAce->Mask = Mask;

    if( CopySid(
            GetLengthSid(AllowedSid), // should be valid SID ??
            &(AllowedAce->SidStart),
            AllowedSid ) == FALSE ) {

        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

DWORD
INetpInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into a denied type ACE.

Arguments:

    DeniedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the denied access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is denied
        the specified access.

Return Value:

    WIN32 Error Code.

--*/
{
    DeniedAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    DeniedAce->Header.AceSize = AceSize;
    DeniedAce->Header.AceFlags = AceFlags | InheritFlags;

    DeniedAce->Mask = Mask;

    if( CopySid(
            GetLengthSid(DeniedSid), // should be valid SID ??
            &(DeniedAce->SidStart),
            DeniedSid ) == FALSE ) {

        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

DWORD
INetpInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an audit type ACE.

Arguments:

    AuditAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AuditSid - Supplies the pointer to the SID of user/group which is to be
        audited.

Return Value:

    WIN32 Error Code.

--*/
{
    AuditAce->Header.AceType = SYSTEM_AUDIT_ACE_TYPE;
    AuditAce->Header.AceSize = AceSize;
    AuditAce->Header.AceFlags = AceFlags | InheritFlags;

    AuditAce->Mask = Mask;

    if( CopySid(
               GetLengthSid(AuditSid),
               &(AuditAce->SidStart),
               AuditSid ) == FALSE ) {

        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}
DWORD
INetpAllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
    )
/*++

Routine Description:

    This function allocates memory for a SID and initializes it.

Arguments:

    None.

Return Value:

    WIN32 Error Code.

--*/
{
    *Sid = (PSID)
        INetpMemoryAllocate(
            GetSidLengthRequired( (BYTE)SubAuthorityCount) );

    if (*Sid == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeSid( *Sid, IdentifierAuthority, (BYTE)SubAuthorityCount );

    return( ERROR_SUCCESS );
}

DWORD
INetpDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    )
/*++

Routine Description:

    Given a domain Id and a relative ID create a SID

Arguments:

    DomainId - The template SID to use.

    RelativeId - The relative Id to append to the DomainId.

    Sid - Returns a pointer to an allocated buffer containing the resultant
            Sid.  Free this buffer using NetpMemoryFree.

Return Value:

    WIN32 Error Code.

--*/
{
    DWORD Error;
    BYTE DomainIdSubAuthorityCount; // Number of sub authorities in domain ID
    ULONG SidLength;    // Length of newly allocated SID

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(GetSidSubAuthorityCount( DomainId ));

    SidLength = GetSidLengthRequired( (BYTE)(DomainIdSubAuthorityCount+1) );

    if ((*Sid = (PSID) INetpMemoryAllocate( SidLength )) == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if( CopySid(SidLength, *Sid, DomainId) == FALSE ) {

        Error = GetLastError();

        INetpMemoryFree( *Sid );
        return( Error );
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(GetSidSubAuthorityCount( *Sid ))) ++;
    *GetSidSubAuthority( *Sid, DomainIdSubAuthorityCount ) = RelativeId;

    return( ERROR_SUCCESS );
}

DWORD
INetpCreateSecurityDescriptor(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates an absolutes security descriptor containing
    the supplied ACE information.

    A sample usage of this function:

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &LocalAdminSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        return NetpCreateSecurityDescriptor(
                   AceData,
                   4,
                   NullSid,
                   LocalSystemSid,
                   &ConfigurationInfoSd
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.  If not specified, a security descriptor with no owner
        will be created.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.  If not specified, a security descriptor with no primary
        group will be created.

    NewDescriptor - Returns a pointer to the absolute secutiry descriptor
        allocated using NetpMemoryAllocate.

Return Value:

    WIN32 Error Code.

--*/
{
    DWORD Error;
    DWORD i;

    //
    // Pointer to memory dynamically allocated by this routine to hold
    // the absolute security descriptor, the DACL, the SACL, and all the ACEs.
    //
    // +---------------------------------------------------------------+
    // |                     Security Descriptor                       |
    // +-------------------------------+-------+---------------+-------+
    // |          DACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    // |          SACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    //

    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    PACL Dacl = NULL;   // Pointer to the DACL portion of above buffer
    PACL Sacl = NULL;   // Pointer to the SACL portion of above buffer

    DWORD DaclSize = sizeof(ACL);
    DWORD SaclSize = sizeof(ACL);
    DWORD MaxAceSize = 0;
    PVOID MaxAce = NULL;

    LPBYTE CurrentAvailable;
    DWORD Size;

    // ASSERT( AceCount > 0 );

    //
    // Compute the total size of the DACL and SACL ACEs and the maximum
    // size of any ACE.
    //

    for (i = 0; i < AceCount; i++) {

        DWORD AceSize;

        AceSize = GetLengthSid( *(AceData[i].Sid) );

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            AceSize += sizeof(ACCESS_ALLOWED_ACE);
            DaclSize += AceSize;
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE);
            DaclSize += AceSize;
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE);
            SaclSize += AceSize;
            break;

        default:
            return( ERROR_INVALID_PARAMETER );
        }

        MaxAceSize = max( MaxAceSize, AceSize );
    }

    //
    // Allocate a chunk of memory large enough the security descriptor
    // the DACL, the SACL and all ACEs.
    //
    // A security descriptor is of opaque data type but
    // SECURITY_DESCRIPTOR_MIN_LENGTH is the right size.
    //

    Size = SECURITY_DESCRIPTOR_MIN_LENGTH;

    if ( DaclSize != sizeof(ACL) ) {
        Size += DaclSize;
    }

    if ( SaclSize != sizeof(ACL) ) {
        Size += SaclSize;
    }

    if ((AbsoluteSd = INetpMemoryAllocate( Size )) == NULL) {

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize the Dacl and Sacl
    //

    CurrentAvailable = (LPBYTE)AbsoluteSd + SECURITY_DESCRIPTOR_MIN_LENGTH;

    if ( DaclSize != sizeof(ACL) ) {

        Dacl = (PACL)CurrentAvailable;
        CurrentAvailable += DaclSize;

        if( InitializeAcl( Dacl, DaclSize, ACL_REVISION ) == FALSE ) {

            Error = GetLastError();
            goto Cleanup;
        }
    }

    if ( SaclSize != sizeof(ACL) ) {

        Sacl = (PACL)CurrentAvailable;
        CurrentAvailable += SaclSize;

        if( InitializeAcl( Sacl, SaclSize, ACL_REVISION ) == FALSE ) {

            Error = GetLastError();
            goto Cleanup;
        }
    }

    //
    // Allocate a temporary buffer big enough for the biggest ACE.
    //

    if ((MaxAce = INetpMemoryAllocate( MaxAceSize )) == NULL ) {

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize each ACE, and append it into the end of the DACL or SACL.
    //

    for (i = 0; i < AceCount; i++) {

        DWORD AceSize;
        PACL CurrentAcl;

        AceSize = GetLengthSid( *(AceData[i].Sid) );

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:

            AceSize += sizeof(ACCESS_ALLOWED_ACE);
            CurrentAcl = Dacl;

            Error = INetpInitializeAllowedAce(
                            MaxAce,
                            (USHORT) AceSize,
                            AceData[i].InheritFlags,
                            AceData[i].AceFlags,
                            AceData[i].Mask,
                            *(AceData[i].Sid) );
            break;

        case ACCESS_DENIED_ACE_TYPE:

            AceSize += sizeof(ACCESS_DENIED_ACE);
            CurrentAcl = Dacl;

            Error = INetpInitializeDeniedAce(
                            MaxAce,
                            (USHORT) AceSize,
                            AceData[i].InheritFlags,
                            AceData[i].AceFlags,
                            AceData[i].Mask,
                            *(AceData[i].Sid) );
            break;

        case SYSTEM_AUDIT_ACE_TYPE:

            AceSize += sizeof(SYSTEM_AUDIT_ACE);
            CurrentAcl = Sacl;

            Error = INetpInitializeAuditAce(
                            MaxAce,
                            (USHORT) AceSize,
                            AceData[i].InheritFlags,
                            AceData[i].AceFlags,
                            AceData[i].Mask,
                            *(AceData[i].Sid) );
            break;
        }

        if ( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // Append the initialized ACE to the end of DACL or SACL
        //


        if ( AddAce(
                CurrentAcl,
                ACL_REVISION,
                MAXDWORD,
                MaxAce,
                AceSize ) == FALSE ) {

            Error = GetLastError();
            goto Cleanup;
        }
    }

    //
    // Create the security descriptor with absolute pointers to SIDs
    // and ACLs.
    //
    // Owner = OwnerSid
    // Group = GroupSid
    // Dacl  = Dacl
    // Sacl  = Sacl
    //

    if ( InitializeSecurityDescriptor(
            AbsoluteSd,
            SECURITY_DESCRIPTOR_REVISION ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( SetSecurityDescriptorOwner(
            AbsoluteSd,
            OwnerSid,
            FALSE ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( SetSecurityDescriptorGroup(
            AbsoluteSd,
            GroupSid,
            FALSE ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( SetSecurityDescriptorDacl(
            AbsoluteSd,
            TRUE,
            Dacl,
            FALSE ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( SetSecurityDescriptorSacl(
            AbsoluteSd,
            FALSE,
            Sacl,
            FALSE ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    //
    // Done
    //

    *NewDescriptor = AbsoluteSd;
    AbsoluteSd = NULL;
    Error = ERROR_SUCCESS;

    //
    // Clean up
    //

Cleanup:

    if( AbsoluteSd != NULL ) {

        //
        // delete the partially made SD if we are not completely
        // successful
        //

        INetpMemoryFree( AbsoluteSd );
    }

    //
    // Delete the temporary ACE
    //

    if ( MaxAce != NULL ) {

        INetpMemoryFree( MaxAce );
    }

    return( Error );
}

DWORD
INetCreateWellKnownSids(
    VOID
    )
/*++

Routine Description:

    This function creates some well-known SIDs and store them in global
    variables.

Arguments:

    none.

Return Value:

    WIN32 Error Code.

--*/
{
    DWORD Error;
    DWORD i;

    //
    // Allocate and initialize well-known SIDs which aren't relative to
    // the domain Id.
    //

    for (i = 0; i < (sizeof(SidData) / sizeof(SidData[0])) ; i++) {

        Error = INetpAllocateAndInitializeSid(
                        SidData[i].Sid,
                        &(SidData[i].IdentifierAuthority),
                        1);

        if ( Error != ERROR_SUCCESS ) {
            return Error;
        }

        *(GetSidSubAuthority(*(SidData[i].Sid), 0)) = SidData[i].SubAuthority;
    }

    //
    // Build each SID which is relative to the Builtin Domain Id.
    //

    for ( i = 0;
                i < (sizeof(BuiltinDomainSidData) /
                        sizeof(BuiltinDomainSidData[0]));
                    i++) {


        Error = INetpDomainIdToSid(
                        BuiltinDomainSid,
                        BuiltinDomainSidData[i].RelativeId,
                        BuiltinDomainSidData[i].Sid );

        if ( Error != ERROR_SUCCESS ) {
            return Error;
        }
    }

    return ERROR_SUCCESS;
}

VOID
INetFreeWellKnownSids(
    VOID
    )
/*++

Routine Description:

    This function frees up the dynamic memory consumed by the well-known
    SIDs.

Arguments:

    none.

Return Value:

    none

--*/
{
    DWORD i;

    //
    // free up memory allocated for well-known SIDs
    //

    for (i = 0; i < (sizeof(SidData) / sizeof(SidData[0])) ; i++) {

        if( *SidData[i].Sid != NULL ) {
            INetpMemoryFree( *SidData[i].Sid );
            *SidData[i].Sid = NULL;
        }
    }

    //
    // free up memory allocated for Builtin Domain SIDs
    //

    for (i = 0;
            i < (sizeof(BuiltinDomainSidData) /
                sizeof(BuiltinDomainSidData[0])) ;
                    i++) {

        if( *BuiltinDomainSidData[i].Sid != NULL ) {
            INetpMemoryFree( *BuiltinDomainSidData[i].Sid );
            *BuiltinDomainSidData[i].Sid = NULL;
        }
    }

}

DWORD
INetCreateSecurityObject(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates the DACL for the security descriptor based on
    on the ACE information specified, and creates the security descriptor
    which becomes the user-mode security object.

    A sample usage of this function:

        //
        // Structure that describes the mapping of Generic access rights to
        // object specific access rights for the ConfigurationInfo object.
        //

        GENERIC_MAPPING WsConfigInfoMapping = {
            STANDARD_RIGHTS_READ            |      // Generic read
                WKSTA_CONFIG_GUEST_INFO_GET |
                WKSTA_CONFIG_USER_INFO_GET  |
                WKSTA_CONFIG_ADMIN_INFO_GET,
            STANDARD_RIGHTS_WRITE |                // Generic write
                WKSTA_CONFIG_INFO_SET,
            STANDARD_RIGHTS_EXECUTE,               // Generic execute
            WKSTA_CONFIG_ALL_ACCESS                // Generic all
            };

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &LocalAdminSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        return INetCreateSecurityObject(
                   AceData,
                   4,
                   NullSid,
                   LocalSystemSid,
                   &WsConfigInfoMapping,
                   &ConfigurationInfoSd
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.

    GenericMapping - Supplies the pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

    NewDescriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    WIN32 Error Code.

    NOTE : the security object created by calling this function may be
                freed up by calling INetDeleteSecurityObject().

--*/
{
    DWORD Error;
    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    HANDLE TokenHandle = NULL;


    Error = INetpCreateSecurityDescriptor(
                   AceData,
                   AceCount,
                   OwnerSid,
                   GroupSid,
                   &AbsoluteSd
                   );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    if( OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &TokenHandle ) == FALSE ) {

        TokenHandle = INVALID_HANDLE_VALUE;
        Error = GetLastError();
        goto Cleanup;
    }

    //
    // Create the security object (a user-mode object is really a pseudo-
    // object represented by a security descriptor that have relative
    // pointers to SIDs and ACLs).  This routine allocates the memory to
    // hold the relative security descriptor so the memory allocated for the
    // DACL, ACEs, and the absolute descriptor can be freed.
    //
    if( CreatePrivateObjectSecurity(
            NULL,                   // Parent descriptor
            AbsoluteSd,             // Creator descriptor
            NewDescriptor,          // Pointer to new descriptor
            FALSE,                  // Is directory object
            TokenHandle,            // Token
            GenericMapping          // Generic mapping
                ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( TokenHandle != NULL ) {
        CloseHandle( TokenHandle );
    }

    //
    // Free dynamic memory before returning
    //

    if( AbsoluteSd != NULL ) {
        INetpMemoryFree( AbsoluteSd );
    }

    return( Error );
}

DWORD
INetDeleteSecurityObject(
    IN PSECURITY_DESCRIPTOR *Descriptor
    )
/*++

Routine Description:

    This function deletes a security object that was created by calling
    INetCreateSecurityObject() function.

Arguments:

    Descriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    WIN32 Error Code.

--*/
{
    if( DestroyPrivateObjectSecurity( Descriptor ) == FALSE ) {

        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

DWORD
INetAccessCheckAndAuditW(
    IN  LPCWSTR SubsystemName,
    IN  LPWSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheckAndAuditAlarm; and reverts back to
    itself before returning.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling this routine.

    ObjectTypeName - Supplies the name of the type of the object being
        accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    DWORD Error;

    ACCESS_MASK GrantedAccess;
    BOOL GenerateOnClose;
    BOOL AccessStatus;

    Error = RpcImpersonateClient( NULL ) ;

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    if( AccessCheckAndAuditAlarmW(
            SubsystemName,
            NULL,                        // No handle for object
            ObjectTypeName,
            NULL,
            SecurityDescriptor,
            DesiredAccess,
            GenericMapping,
            FALSE,  // open existing object.
            &GrantedAccess,
            &AccessStatus,
            &GenerateOnClose ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( AccessStatus == FALSE ) {

        Error = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    RpcRevertToSelf();

    return( Error );
}

DWORD
INetAccessCheckAndAuditA(
    IN  LPCSTR SubsystemName,
    IN  LPSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheckAndAuditAlarm; and reverts back to
    itself before returning.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling this routine.

    ObjectTypeName - Supplies the name of the type of the object being
        accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    DWORD Error;

    ACCESS_MASK GrantedAccess;
    BOOL GenerateOnClose;
    BOOL AccessStatus;

    Error = RpcImpersonateClient( NULL ) ;

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    if( AccessCheckAndAuditAlarmA(
            SubsystemName,
            NULL,                        // No handle for object
            ObjectTypeName,
            NULL,
            SecurityDescriptor,
            DesiredAccess,
            GenericMapping,
            FALSE,  // open existing object.
            &GrantedAccess,
            &AccessStatus,
            &GenerateOnClose ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    if ( AccessStatus == FALSE ) {

        Error = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    RpcRevertToSelf();

    return( Error );
}

DWORD
INetAccessCheck(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheck; and reverts back to
    itself before returning.

    This routine differs from NetpAccessCheckAndAudit in that it doesn't require
    the caller to have SE_AUDIT_PRIVILEGE nor does it generate audits.
    That is typically fine since the passed in security descriptor typically doesn't
    have a SACL requesting an audit.

Arguments:

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    DWORD Error;

    HANDLE ClientToken = NULL;

    DWORD GrantedAccess;
    BOOL AccessStatus;
    BYTE PrivilegeSet[500]; // Large buffer

    DWORD PrivilegeSetSize;


    //
    // Impersonate the client.
    //

    Error = RpcImpersonateClient(NULL);

    if ( Error != ERROR_SUCCESS ) {

        return( Error );
    }

    //
    // Open the impersonated token.
    //

    if ( OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE, // use process security context to open token
            &ClientToken ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;
    }

    //
    // Check if the client has the required access.
    //

    PrivilegeSetSize = sizeof(PrivilegeSet);
    if ( AccessCheck(
            SecurityDescriptor,
            ClientToken,
            DesiredAccess,
            GenericMapping,
            (PPRIVILEGE_SET)&PrivilegeSet,
            &PrivilegeSetSize,
            &GrantedAccess,
            &AccessStatus ) == FALSE ) {

        Error = GetLastError();
        goto Cleanup;

    }

    if ( AccessStatus == FALSE ) {

        Error = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Success
    //

    Error = ERROR_SUCCESS;

Cleanup:

    RpcRevertToSelf();

    if ( ClientToken != NULL ) {
        CloseHandle( ClientToken );
    }

    return( Error );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\setup\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

        Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Revision History:
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_

#ifndef _NO_TRACING_

#include "pudebug.h"

#else // !_NO_TRACING_

// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   (  DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable
// begin_user_unmodifiable


# if DBG 

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>

/***********************************************************
 *    Macros
 ************************************************************/


extern   DEBUG_PRINTS  *  g_pDebug;        // define a global debug variable


# define DECLARE_DEBUG_PRINTS_OBJECT()          \
         DEBUG_PRINTS  *  g_pDebug = NULL;


//                                      
// Call the following macro as part of your initialization for program
//  planning to use the debugging class.
//
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)  \
        g_pDebug = PuCreateDebugPrintsObject( pszLabel, DEFAULT_OUTPUT_FLAGS);\
         if  ( g_pDebug == NULL) {   \
               OutputDebugString( "Unable to Create Debug Print Object \n"); \
         }

//
// Call the following macro once as part of the termination of program
//    which uses the debugging class.
//
# define DELETE_DEBUG_PRINT_OBJECT( )  \
        g_pDebug = PuDeleteDebugPrintsObject( g_pDebug);


# define VALID_DEBUG_PRINT_OBJECT()     \
        ( ( g_pDebug != NULL) && g_pDebug->m_fInitialized)


//
//  Use the DBG_CONTEXT without any surrounding braces.
//  This is used to pass the values for global DebugPrintObject 
//     and File/Line information
//
# define DBG_CONTEXT        g_pDebug, __FILE__, __LINE__ 



# define DBG_CODE(s)          s          /* echoes code in debugging mode */


# define DBG_ASSERT( exp)    if ( !(exp)) { \
                                 PuDbgAssertFailed( DBG_CONTEXT, #exp, NULL); \
                             } else {}

# define DBG_ASSERT_MSG( exp, pszMsg)    \
                            if ( !(exp)) { \
                               PuDbgAssertFailed( DBG_CONTEXT, #exp, pszMsg); \
                            } else {}

# define DBG_REQUIRE( exp)    DBG_ASSERT( exp)

# define DBG_LOG()            PuDbgPrint( DBG_CONTEXT, "\n")

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)   \
                  PuOpenDbgPrintFile( g_pDebug, (pszFile), (pszPath))

# define DBG_CLOSE_LOG_FILE( )   \
                  PuCloseDbgPrintFile( g_pDebug)

# define SET_DEBUG_PRINT_FLAGS( dwFlags)   \
                  PuSetDbgOutputFlags( g_pDebug, (dwFlags))

# define GET_DEBUG_PRINT_FLAGS() \
                  PuGetDbgOutputFlags( g_pDebug)


//
//  DBGPRINTF() is printing function ( much like printf) but always called
//    with the DBG_CONTEXT as follows
//   DBGPRINTF( ( DBG_CONTEXT, format-string, arguments for format list);
//
# define DBGPRINTF( args)     PuDbgPrint args

# else // DBG


# define DECLARE_DEBUG_PRINTS_OBJECT()           /* Do Nothing */
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)    /* Do Nothing */
# define DELETE_DEBUG_PRINT_OBJECT( )            /* Do Nothing */
# define VALID_DEBUG_PRINT_OBJECT()              ( TRUE)

# define DBG_CODE(s)                             /* Do Nothing */

# define DBG_ASSERT(exp)                         /* Do Nothing */

# define DBG_ASSERT_MSG(exp, pszMsg)             /* Do Nothing */

# define DBG_REQUIRE( exp)                       ( (void) (exp))

# define DBGPRINTF( args)                        /* Do Nothing */

# define SET_DEBUG_PRINT_FLAGS( dwFlags)         /* Do Nothing */
# define GET_DEBUG_PRINT_FLAGS( )                ( 0)

# define DBG_LOG()                               /* Do Nothing */

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)    /* Do Nothing */

# define DBG_CLOSE_LOG_FILE()                    /* Do Nothing */

# endif // DBG


// end_user_modifiable
// begin_user_unmodifiable


#ifdef ASSERT 
# undef ASSERT
#endif


# define ASSERT( exp)           DBG_ASSERT( exp)


//
//  Define the debugging constants 
// 

# define DEBUG_TEST1                      0x00000001
# define DEBUG_TEST2                      0x00000002


# if DBG 

extern     DWORD  g_dwDebugFlags;           // Debugging Flags

# define DECLARE_DEBUG_VARIABLE()     \
             DWORD  g_dwDebugFlags

# define SET_DEBUG_FLAGS( dwFlags)         g_dwDebugFlags = dwFlags
# define GET_DEBUG_FLAGS()                 ( g_dwDebugFlags)

# define DEBUG_IF( arg, s)     if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                } else {}

# define IF_DEBUG( arg)        if ( DEBUG_## arg & GET_DEBUG_FLAGS()) 


# else   // DBG


# define DECLARE_DEBUG_VARIABLE()                /* Do Nothing */
# define SET_DEBUG_FLAGS( dwFlags)               /* Do Nothing */
# define GET_DEBUG_FLAGS()                       ( 0)

# define DEBUG_IF( arg, s)                       /* Do Nothing */
# define IF_DEBUG( arg)                          if ( 0) 

# endif // DBG

#endif // !_NO_TRACING_


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\setup\msnsvc.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    msnsvc.h

    This file contains constants & type definitions shared between the
    Shuttle Service, Installer, and Administration UI.


    FILE HISTORY:
        VladimV     30-May-1995     Created
        rkamicar    7-June-1995     Added Admin Stuff
        VladimV     26-June-1995    Replace W3 with MSN info.

*/


#ifndef _MSNSVC_H_
#define _MSNSVC_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
#include <winsock2.h>
#endif

//
//  Service name.
//

#define MSN_SERVICE_NAME_A         "MSNSVC"
#define MSN_SERVICE_NAME_W         L"MSNSVC"

//
//  Name of the log file, used for logging file accesses.
//

#define MSN_LOG_FILE_A             "MSNSVC.LOG"
#define MSN_LOG_FILE_W             L"MSNSVC.LOG"


//
//  Configuration parameters registry key.
//

#define MSN_PARAMETERS_KEY_A \
            "System\\CurrentControlSet\\Services\\MsnSvc\\Parameters"

#define MSN_PARAMETERS_KEY_W \
            L"System\\CurrentControlSet\\Services\\MsnSvc\\Parameters"


//
//  Performance key.
//

#define MSN_PERFORMANCE_KEY_A \
            "System\\CurrentControlSet\\Services\\MsnSvc\\Performance"

#define MSN_PERFORMANCE_KEY_W \
            L"System\\CurrentControlSet\\Services\\MsnSvc\\Performance"


//
//  If this registry key exists under the MsnSvc\Parameters key,
//  it is used to validate MSNSVC access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the MSN Server.
//

#define MSN_ACCESS_KEY_A           "AccessCheck"
#define MSN_ACCESS_KEY_W           L"AccessCheck"


//
//  Configuration value names.
//

#define MSN_ALLOW_ANONYMOUS_A      "AllowAnonymous"
#define MSN_ALLOW_ANONYMOUS_W      L"AllowAnonymous"

#define MSN_ALLOW_GUEST_ACCESS_A   "AllowGuestAccess"
#define MSN_ALLOW_GUEST_ACCESS_W   L"AllowGuestAccess"

#define MSN_ANONYMOUS_ONLY_A       "AnonymousOnly"
#define MSN_ANONYMOUS_ONLY_W       L"AnonymousOnly"

#define MSN_LOG_ANONYMOUS_A        "LogAnonymous"
#define MSN_LOG_ANONYMOUS_W        L"LogAnonymous"

#define MSN_LOG_NONANONYMOUS_A     "LogNonAnonymous"
#define MSN_LOG_NONANONYMOUS_W     L"LogNonAnonymous"

#define MSN_ANONYMOUS_USERNAME_A   "AnonymousUserName"
#define MSN_ANONYMOUS_USERNAME_W   L"AnonymousUserName"

#define MSN_HOME_DIRECTORY_A       "HomeDirectory"
#define MSN_HOME_DIRECTORY_W       L"HomeDirectory"

#define MSN_MAX_CONNECTIONS_A      "MaxConnections"
#define MSN_MAX_CONNECTIONS_W      L"MaxConnections"

#define MSN_READ_ACCESS_MASK_A     "ReadAccessMask"
#define MSN_READ_ACCESS_MASK_W     L"ReadAccessMask"

#define MSN_WRITE_ACCESS_MASK_A    "WriteAccessMask"
#define MSN_WRITE_ACCESS_MASK_W    L"WriteAccessMask"

#define MSN_CONNECTION_TIMEOUT_A   "ConnectionTimeout"
#define MSN_CONNECTION_TIMEOUT_W   L"ConnectionTimeout"

#define MSN_MSDOS_DIR_OUTPUT_A     "MsdosDirOutput"
#define MSN_MSDOS_DIR_OUTPUT_W     L"MsdosDirOutput"

#define MSN_GREETING_MESSAGE_A     "GreetingMessage"
#define MSN_GREETING_MESSAGE_W     L"GreetingMessage"

#define MSN_EXIT_MESSAGE_A         "ExitMessage"
#define MSN_EXIT_MESSAGE_W         L"ExitMessage"

#define MSN_MAX_CLIENTS_MSG_A      "MaxClientsMessage"
#define MSN_MAX_CLIENTS_MSG_W      L"MaxClientsMessage"

#define MSN_DEBUG_FLAGS_A          "DebugFlags"
#define MSN_DEBUG_FLAGS_W          L"DebugFlags"

#define MSN_ANNOTATE_DIRS_A        "AnnotateDirectories"
#define MSN_ANNOTATE_DIRS_W        L"AnnotateDirectories"

#define MSN_LOWERCASE_FILES_A      "LowercaseFiles"
#define MSN_LOWERCASE_FILES_W      L"LowercaseFiles"

#define MSN_LOG_FILE_ACCESS_A      "LogFileAccess"
#define MSN_LOG_FILE_ACCESS_W      L"LogFileAccess"

#define MSN_LOG_FILE_DIRECTORY_A   "LogFileDirectory"
#define MSN_LOG_FILE_DIRECTORY_W   L"LogFileDirectory"

#define MSN_LISTEN_BACKLOG_A       "ListenBacklog"
#define MSN_LISTEN_BACKLOG_W       L"ListenBacklog"

#define MSN_ENABLE_LICENSING_A     "EnableLicensing"
#define MSN_ENABLE_LICENSING_W     L"EnableLicensing"

#define MSN_DEFAULT_LOGON_DOMAIN_A "DefaultLogonDomain"
#define MSN_DEFAULT_LOGON_DOMAIN_W L"DefaultLogonDomain"


//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon and virtual UNC roots
//

#define MSN_ANONYMOUS_SECRET_A     "MSN_ANONYMOUS_DATA"
#define MSN_ANONYMOUS_SECRET_W     L"MSN_ANONYMOUS_DATA"

#define MSN_ROOT_SECRET_A          "MSN_ROOT_DATA"
#define MSN_ROOT_SECRET_W          L"MSN_ROOT_DATA"

//
//  Handle ANSI/UNICODE sensitivity.
//

#ifdef UNICODE

#define MSN_SERVICE_NAME           MSN_SERVICE_NAME_W
#define MSN_ANNOTATION_FILE        MSN_ANNOTATION_FILE_W
#define MSN_PARAMETERS_KEY         MSN_PARAMETERS_KEY_W
#define MSN_PERFORMANCE_KEY        MSN_PERFORMANCE_KEY_W
#define MSN_ACCESS_KEY             MSN_ACCESS_KEY_W
#define MSN_ALLOW_ANONYMOUS        MSN_ALLOW_ANONYMOUS_W
#define MSN_ALLOW_GUEST_ACCESS     MSN_ALLOW_GUEST_ACCESS_W
#define MSN_ANONYMOUS_ONLY         MSN_ANONYMOUS_ONLY_W
#define MSN_LOG_ANONYMOUS          MSN_LOG_ANONYMOUS_W
#define MSN_LOG_NONANONYMOUS       MSN_LOG_NONANONYMOUS_W
#define MSN_ANONYMOUS_USERNAME     MSN_ANONYMOUS_USERNAME_W
#define MSN_HOME_DIRECTORY         MSN_HOME_DIRECTORY_W
#define MSN_MAX_CONNECTIONS        MSN_MAX_CONNECTIONS_W
#define MSN_READ_ACCESS_MASK       MSN_READ_ACCESS_MASK_W
#define MSN_WRITE_ACCESS_MASK      MSN_WRITE_ACCESS_MASK_W
#define MSN_CONNECTION_TIMEOUT     MSN_CONNECTION_TIMEOUT_W
#define MSN_MSDOS_DIR_OUTPUT       MSN_MSDOS_DIR_OUTPUT_W
#define MSN_GREETING_MESSAGE       MSN_GREETING_MESSAGE_W
#define MSN_EXIT_MESSAGE           MSN_EXIT_MESSAGE_W
#define MSN_MAX_CLIENTS_MSG        MSN_MAX_CLIENTS_MSG_W
#define MSN_DEBUG_FLAGS            MSN_DEBUG_FLAGS_W
#define MSN_ANNOTATE_DIRS          MSN_ANNOTATE_DIRS_W
#define MSN_ANONYMOUS_SECRET       MSN_ANONYMOUS_SECRET_W
#define MSN_LOWERCASE_FILES        MSN_LOWERCASE_FILES_W
#define MSN_LOG_FILE_ACCESS        MSN_LOG_FILE_ACCESS_W
#define MSN_LOG_FILE               MSN_LOG_FILE_W
#define MSN_LOG_FILE_DIRECTORY     MSN_LOG_FILE_DIRECTORY_W
#define MSN_LISTEN_BACKLOG         MSN_LISTEN_BACKLOG_W
#define MSN_ENABLE_LICENSING       MSN_ENABLE_LICENSING_W
#define MSN_DEFAULT_LOGON_DOMAIN   MSN_DEFAULT_LOGON_DOMAIN_W

#else   // !UNICODE

#define MSN_SERVICE_NAME           MSN_SERVICE_NAME_A
#define MSN_ANNOTATION_FILE        MSN_ANNOTATION_FILE_A
#define MSN_PARAMETERS_KEY         MSN_PARAMETERS_KEY_A
#define MSN_PERFORMANCE_KEY        MSN_PERFORMANCE_KEY_A
#define MSN_ACCESS_KEY             MSN_ACCESS_KEY_A
#define MSN_ANONYMOUS_ONLY         MSN_ANONYMOUS_ONLY_A
#define MSN_LOG_ANONYMOUS          MSN_LOG_ANONYMOUS_A
#define MSN_LOG_NONANONYMOUS       MSN_LOG_NONANONYMOUS_A
#define MSN_ALLOW_ANONYMOUS        MSN_ALLOW_ANONYMOUS_A
#define MSN_ALLOW_GUEST_ACCESS     MSN_ALLOW_GUEST_ACCESS_A
#define MSN_ANONYMOUS_USERNAME     MSN_ANONYMOUS_USERNAME_A
#define MSN_HOME_DIRECTORY         MSN_HOME_DIRECTORY_A
#define MSN_MAX_CONNECTIONS        MSN_MAX_CONNECTIONS_A
#define MSN_READ_ACCESS_MASK       MSN_READ_ACCESS_MASK_A
#define MSN_WRITE_ACCESS_MASK      MSN_WRITE_ACCESS_MASK_A
#define MSN_CONNECTION_TIMEOUT     MSN_CONNECTION_TIMEOUT_A
#define MSN_MSDOS_DIR_OUTPUT       MSN_MSDOS_DIR_OUTPUT_A
#define MSN_GREETING_MESSAGE       MSN_GREETING_MESSAGE_A
#define MSN_EXIT_MESSAGE           MSN_EXIT_MESSAGE_A
#define MSN_MAX_CLIENTS_MSG        MSN_MAX_CLIENTS_MSG_A
#define MSN_DEBUG_FLAGS            MSN_DEBUG_FLAGS_A
#define MSN_ANNOTATE_DIRS          MSN_ANNOTATE_DIRS_A
#define MSN_ANONYMOUS_SECRET       MSN_ANONYMOUS_SECRET_A
#define MSN_LOWERCASE_FILES        MSN_LOWERCASE_FILES_A
#define MSN_LOG_FILE_ACCESS        MSN_LOG_FILE_ACCESS_A
#define MSN_LOG_FILE               MSN_LOG_FILE_A
#define MSN_LOG_FILE_DIRECTORY     MSN_LOG_FILE_DIRECTORY_A
#define MSN_LISTEN_BACKLOG         MSN_LISTEN_BACKLOG_A
#define MSN_ENABLE_LICENSING       MSN_ENABLE_LICENSING_A
#define MSN_DEFAULT_LOGON_DOMAIN   MSN_DEFAULT_LOGON_DOMAIN_A

#endif  // UNICODE

//
//  Values for LogFileAccess
//

#define MSN_LOG_DISABLED   0
#define MSN_LOG_SINGLE 1
#define MSN_LOG_DAILY  2



#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _MSNSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spud\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!INCLUDE ..\..\..\..\place.inc

MAJORCOMP=inetsvcs
MINORCOMP=uspud

TARGETNAME=uspud
TARGETPATH=..\$(_OBJ_DIR)
TARGETTYPE=LIBRARY

C_DEFINES=$(C_DEFINES)

SOURCES=

UMTYPE=console
UMINCL=..;
UMLIBS=..\$(O)\uspud.lib

NTTARGETFILE0=$(IISBASEDIR)\svcs\infocomm\spuddrv\services.tab \
              $(O)\usrstubs.$(ASM_SUFFIX)

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spud\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Oct-22-1996 JBallard Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spud\makefile.inc ===
KMODEDIR=$(IISBASEDIR)\svcs\infocomm\spuddrv

$(KMODEDIR)\$(ALT_PROJECT)\$(O)\services.tab: $(KMODEDIR)\services.tab
    @echo Creating $@ from $**
    $(C_PREPROCESSOR)  $** > $@

$(O)\usrstubs.obj: $(O)\usrstubs.$(ASM_SUFFIX)

$(O)\usrstubs.$(ASM_SUFFIX): $(KMODEDIR)\$(ALT_PROJECT)\$(O)\services.tab $(KMODEDIR)\$(TARGET_DIRECTORY)\table.stb $(KMODEDIR)\$(TARGET_DIRECTORY)\services.stb
    gensrv -d $(O) -e $(ASM_SUFFIX) -g $(O) $(TARGET_BRACES) -s $(KMODEDIR)\$(TARGET_DIRECTORY) $(KMODEDIR)\$(ALT_PROJECT)\$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\setup\svcsetup.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      svcsetup.c

   Abstract:

     Setup program for installing / removing the Internet Services.
      This enables setting up the Service GUID and protocol bindings.

   Author:

       Murali R. Krishnan    ( MuraliK )     08-March-1995

   Project:

       Internet Services Setup Application

   Functions Exported:



   Revision History:

--*/


/*++

  NOTE:
    There are sections in this code which should be modified
    whenever a new service is added.

    Please look for begin_modifiable_code to identify the code that
     may require modification when a new service is added.


   -MuraliK
--*/



/************************************************************
 *     Include Headers
 ************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ntsam.h>
#include <ntlsa.h>

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winsock2.h>
#include <nspapi.h>

//#include <inetasrv.h>
#include <ftpd.h>
#include <w3svc.h>
#include <msnsvc.h>



//  begin_modifiable_code


//
// For each service create a GUID using uuidgen and store it in static
//  variable for further use below.
//   Gopher Service GUID: 62388f10-58a2-11ce-bec8-00aa0047ae4e
//

static  GUID   g_GopherGuid = { 0x62388f10, 0x58a2, 0x11ce, 0xbe, 0xc8,
                                0x00, 0xaa, 0x00, 0x47, 0xae, 0x4e };

static GUID    g_HTTPGuid   = {  0x585908c0, 0x6305, 0x11ce, 0xae, 0x00,
                                 0x00, 0xaa, 0x00, 0x4a, 0x38, 0xb9 };

static GUID    g_FTPGuid    = { 0x91604620, 0x6305, 0x11ce, 0xae, 0x00,
                                0x00, 0xaa, 0x00, 0x4a, 0x38, 0xb9 };

static GUID    g_MsnGuid    = { 0x11f5d300, 0xada7, 0x11ce, 0xb4, 0x8f,
                                0x00, 0xaa, 0x00, 0x6c, 0x35, 0x02 };

//
// For each of the service make an entry in the following list of services
//
//  Format for each service info is:
//   ServiceInfo( SymbolicName, ServiceName, DisplayName, TcpPort,
//                pointer-to-guid-for-the-service)
//
//  This is a macro. Please be considerate to use a terminating "\"
//

# define AllServicesInfo()   \
  ServiceInfo( GOPHER_SERVICE, "GopherSvc",              \
               "Microsoft Gopher Service (1995)",        \
               ( 70), &g_GopherGuid,                     \
               GOPHERD_ANONYMOUS_SECRET_W,               \
               GOPHERD_ROOT_SECRET_W)                    \
                                                         \
  ServiceInfo( W3_SERVICE_NAME, "W3Svc",                 \
               "Microsoft HTTP Service (1995)",          \
               (80), &g_HTTPGuid,                        \
               W3_ANONYMOUS_SECRET_W,                    \
               W3_ROOT_SECRET_W)                         \
                                                         \
  ServiceInfo( FTP_SERVICE_NAME, "FtpSvc",               \
               "Microsoft FTP Service (1995)",           \
               (21), &g_FTPGuid,                         \
               FTPD_ANONYMOUS_SECRET_W,                  \
               FTPD_ROOT_SECRET_W)                       \
                                                         \
  ServiceInfo( MSN_SERVICE_NAME, "MsnSvc",               \
               "MSN Gateway Service (1995)",             \
               (568), &g_MsnGuid,                        \
               MSN_ANONYMOUS_SECRET_W,                   \
               MSN_ROOT_SECRET_W)                        \

//
// end_modifiable_code
//



//  begin_unmodifiable_code


//
// Few convenience macros
//

// For setting up the Values in ServiceTypeValue structure.
# define SetServiceTypeValues( pSvcTypeValue, dwNS, dwType, dwSize, lpValName, lpVal)   \
       ( pSvcTypeValue)->dwNameSpace = ( dwNS);           \
       ( pSvcTypeValue)->dwValueType = ( dwType);         \
       ( pSvcTypeValue)->dwValueSize = ( dwSize);         \
       ( pSvcTypeValue)->lpValueName = ( lpValName);      \
       ( pSvcTypeValue)->lpValue     = (PVOID ) ( lpVal); \

# define SetServiceTypeValuesDword( pSvcTypeValue, dwNS, lpValName, lpVal) \
   SetServiceTypeValues( (pSvcTypeValue), (dwNS), REG_DWORD, sizeof( DWORD), \
                         ( lpValName), ( lpVal))



typedef struct  _ServiceSetupInfo {

    char *      m_pszServiceName;
    char *      m_pszDisplayName;
    DWORD       m_tcpPort;            // TCP/IP port number
    LPGUID      m_lpGuid;
    WCHAR *     m_pszAnonPwdSecret;   // Anonymous password secret name
    WCHAR *     m_pszRootPwdSecret;   // Virtual roots password secret name

} ServiceSetupInfo;

//
// Macro to be used for defining a value for ServiceSetupInfo structure
//
# define ServiceInfoValue( svcName, dispName, tcpPort, lpGuid, AnonPwd, RootPwd)  \
   {  svcName, dispName, tcpPort, lpGuid, AnonPwd, RootPwd }


//
// Form an enumerated list of the service names. These form the
//   index into the array of service setup information structures.
//

# define ServiceInfo( sym, svc, disp, tcpport, lpGuid, AnonPwd, RootPwd)  \
   i ## sym,

typedef enum  {

    AllServicesInfo()
    iMaxService

  } eServiceInfo;

# undef ServiceInfo


//
// Form the array of ServiceSetyupInfo objects.
//

# define ServiceInfo( sym, svc, disp, tcpport, lpGuid, AnonPwd, RootPwd)   \
   ServiceInfoValue( svc, disp, tcpport, lpGuid, AnonPwd, RootPwd),

static ServiceSetupInfo   g_svcSetupInfo[] =  {

    AllServicesInfo()
      { NULL, NULL, 0, 0, NULL, NULL}         //  a sentinel for the array
};

# undef ServiceInfo

//  end_unmodifiable_code


/************************************************************
 *    Functions
 ************************************************************/

//
// Local functions
//


static BOOL
CreateServiceEntry( IN char * pszServiceName,
                    IN char * pszDisplayName,
                    IN char * pszPath);

static BOOL
CreateEventLogEntry( IN char *   pszServiceName,
                     IN char *   pszServicePath
                    );

static VOID PrintUsageMessage( IN char * pszProgramName);

static BOOL
PerformSetService( IN const ServiceSetupInfo * pSvcSetupInfo,
                   IN DWORD svcOperation);

DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    );



int __cdecl
main(  int argc,  char * argv[] )
{
    BOOL fRet = TRUE;

    char *  pszProgram = argv[ 0];
    char *  pszOperation;
    char *  pszSvc;

    int  i;
    ServiceSetupInfo * pSvcSetupInfo = NULL;
    DWORD    svcOperation = SERVICE_ADD_TYPE;

    //
    //  Parse the command line arguments.
    //

    if ( argc != 3) {

        PrintUsageMessage( argv[ 0]);
        return ( 1);
    }

    pszSvc = argv[ 1];
    pszOperation = argv[ 2];

    //
    // Lookup the service setup info structure from the array
    //  command line argument 1 is the service name.
    // Find the associated service setup info structure.
    //
    for( i = 0; i < iMaxService; i++) {

        if ( _stricmp( g_svcSetupInfo[ i].m_pszServiceName, pszSvc) == 0) {

            pSvcSetupInfo = ( g_svcSetupInfo + i);
            break;
        }
    } // for


    if ( pSvcSetupInfo == NULL) {

        fprintf( stderr, " Unknown Service Name %s specified.\n", pszSvc);
        PrintUsageMessage( pszProgram);
        return ( 1);
    }

    //
    //  Identify the operation to be performed and execute the same.
    //

    if ( _strnicmp( pszOperation, "/add", 4) == 0) {

        svcOperation = SERVICE_ADD_TYPE;

    } else if ( _strnicmp( pszOperation, "/delete", 4) == 0) {

        svcOperation = SERVICE_DELETE_TYPE;

    } else if ( _strnicmp( pszOperation, "/svc:", 5) == 0) {

        fRet = CreateServiceEntry( pSvcSetupInfo->m_pszServiceName,
                                   pSvcSetupInfo->m_pszDisplayName,
                                  strchr( pszOperation, ':') + 1);

    } else if ( _strnicmp( pszOperation, "/eventlog:", 10) == 0) {

        fRet = CreateEventLogEntry( pSvcSetupInfo->m_pszServiceName,
                                   strchr( pszOperation, ':') + 1);
    } else {

        PrintUsageMessage( pszProgram);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRet = FALSE;
    }


    fRet = fRet && PerformSetService( pSvcSetupInfo, svcOperation);

    return ( (fRet) ? NO_ERROR : GetLastError());
} // main()





VOID
PrintUsageMessage( IN char * pszProgramName)
/*++
  Prints the usage message along with possible list of services allowed.
--*/
{
    int i;

    fprintf( stderr,
            "Usage:\n  %s  <service-name> "
            " [ /add | /delete | /svc:<path-of-process>"
            " /eventlog:<eventlog-messages-binary> \n",
            pszProgramName);

    //
    // Print the services name.
    //

    fprintf( stderr, "\t  Possible Services: \n\t\tName\t Other Details\n");

    for( i = 0; i < iMaxService; i++) {

        fprintf( stderr, "\t\t %s [ %s]  TcpPort=%d) \n",
                 g_svcSetupInfo[ i].m_pszServiceName,
                 g_svcSetupInfo[ i].m_pszDisplayName,
                 g_svcSetupInfo[ i].m_tcpPort
                );
    } // for

    return;
} // PrintUsageMessage()


/************************************************************
 *  Following are general functions usable by other Internet services
 ************************************************************/




static BOOL
PerformSetService( IN const ServiceSetupInfo * pSvcSetupInfo,
                   IN DWORD svcOperation)
{
    int err;

    WSADATA  WsaData;

    SERVICE_INFO serviceInfo;
    LPSERVICE_TYPE_INFO_ABS lpServiceTypeInfo ;
    LPSERVICE_TYPE_VALUE_ABS lpServiceTypeValues ;
    BYTE serviceTypeInfoBuffer[sizeof(SERVICE_TYPE_INFO) + 1024];
             // Buffer large enough for 3 values ( SERVICE_TYPE_VALUE_ABS)

    DWORD Value1 = 1 ;
    DWORD TcpPortValue = pSvcSetupInfo->m_tcpPort;
    DWORD statusFlags;

    //
    // Initialize Windows Sockets DLL
    //

    err = WSAStartup( 0x0101, & WsaData);
    if ( err == SOCKET_ERROR) {

        fprintf( stderr, " WSAStartup() Failed. Error = %ld\n",
                GetLastError());
        return ( FALSE);
    }


    //
    // Setup the service information to be passed to SetService() for adding
    //   or deleting this service. Most of the SERVICE_INFO fields are not
    //   required for add or delete operation. The main things of interests are
    //  GUIDs and ServiceSpecificInfo structure.
    //

    memset( (PVOID ) & serviceInfo, 0, sizeof( serviceInfo)); //null all fields

    serviceInfo.lpServiceType     =  pSvcSetupInfo->m_lpGuid;

    //
    // The "Blob" will contain the service specific information.
    // In this case, fill it with a SERVICE_TYPE_INFO_ABS structure
    //  and associated information.
    //
    serviceInfo.ServiceSpecificInfo.pBlobData = serviceTypeInfoBuffer;
    serviceInfo.ServiceSpecificInfo.cbSize    = sizeof( serviceTypeInfoBuffer);


    lpServiceTypeInfo = (LPSERVICE_TYPE_INFO_ABS ) serviceTypeInfoBuffer;

    //
    //  There's only one value for TCP.
    //

    lpServiceTypeInfo->dwValueCount = 1;
    lpServiceTypeInfo->lpTypeName   = pSvcSetupInfo->m_pszServiceName;

    lpServiceTypeValues = lpServiceTypeInfo->Values;

    SetServiceTypeValuesDword( ( lpServiceTypeValues + 0),
                              NS_DNS,
                              SERVICE_TYPE_VALUE_TCPPORT,
                              &TcpPortValue);

    //
    // Finally, call SetService to actually perform the operation.
    //

    err = SetService(
                     NS_DEFAULT,             // all default name spaces
                     svcOperation,           // either ADD or DELETE
                     0,                      // dwFlags not used
                     &serviceInfo,           // the service info structure
                     NULL,                   // lpServiceAsyncInfo
                     &statusFlags            // additional status information
                     );

    if ( err != NO_ERROR ) {

        fprintf( stderr, "SetService failed: %ld\n", GetLastError( ) );

    } else {

        printf( "SetService( %s) succeeded, status flags = %ld\n",
               pSvcSetupInfo->m_pszServiceName, statusFlags );
    }

    //
    //  Create the LSA secrets for the anonymous user password and the virtual
    //  root passwords
    //

    if ( !SetSecret( NULL,
                     pSvcSetupInfo->m_pszAnonPwdSecret,
                     L"",
                     sizeof(WCHAR) ) ||
         !SetSecret( NULL,
                     pSvcSetupInfo->m_pszRootPwdSecret,
                     L"",
                     sizeof(WCHAR) ))
    {
        err = GetLastError();

        fprintf( stderr,
                "SetService( %s ) failed to create Lsa Secrets for anonymous\n"
                "username password or virtual root passwords.  Error = %d\n",
                pSvcSetupInfo->m_pszServiceName,
                err);

    }

    //
    //  For HTTP, set the catapult impersonation user for the proxy
    //

    if ( pSvcSetupInfo->m_lpGuid == &g_HTTPGuid )
    {
        if ( !SetSecret( NULL,
                         W3_PROXY_USER_SECRET_W,
                         L"",
                         sizeof(WCHAR) ))
        {
            err = GetLastError();

            fprintf( stderr,
                    "SetService( %s ) failed to create Lsa Secrets proxy user\n"
                    "Error = %d\n",
                    pSvcSetupInfo->m_pszServiceName,
                    err);

        }
    }

    return ( err != NO_ERROR);

} // PerformSetService()





static BOOL
CreateServiceEntry( IN char * pszServiceName,
                    IN char * pszDisplayName,
                    IN char * pszPath)
/*++

  This function calls the service controller to create a new service.

  Arguments:
    pszServiceName  pointer to service name
    pszDisplayName  pointer to Display name
    pszPath    pointer to null-terminated string containing the path for
                 the service DLL.

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
{
    BOOL fReturn = FALSE;
    SC_HANDLE hServiceManager;

    //
    //  Create the service.
    //

    hServiceManager = OpenSCManager( NULL,       // machine name
                                    NULL,       // database name
                                    STANDARD_RIGHTS_REQUIRED
                                    | SC_MANAGER_CREATE_SERVICE );

    if ( hServiceManager != NULL) {

        SC_HANDLE   hService;

        //
        // create the service itself.
        //

        hService = CreateService( hServiceManager,
                                 pszServiceName,
                                 pszDisplayName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 SERVICE_WIN32_SHARE_PROCESS,
                                 SERVICE_DEMAND_START,
                                 SERVICE_ERROR_NORMAL,
                                 pszPath,
                                 NULL,      // lpszLoadOrderGroup
                                 NULL,      // lpdwTagId
                                 NULL,      // lpszDependencies
                                 NULL,      // lpszStartUserName
                                 NULL );    // lpszPassword


        if( hService != NULL ) {

            fReturn = TRUE;
            CloseServiceHandle( hService);
        }

        CloseServiceHandle( hServiceManager);

    } else {

        fprintf( stderr,  "OpenSCManager failed: %ld\n", GetLastError() );

    }


    fprintf( stderr, " %s created with path %s. Return %d ( Error = %ld)\n",
            pszServiceName, pszPath,
            fReturn, ( fReturn) ? NO_ERROR : GetLastError());


    return ( fReturn);
} // CreateServiceEntry()







# define EVENT_LOG_REG_KEY   \
            "System\\CurrentControlSet\\Services\\EventLog\\System"

# define LEN_EVENT_LOG_REG_KEY  ( sizeof( EVENT_LOG_REG_KEY))



static BOOL
CreateEventLogEntry( IN char *   pszServiceName,
                     IN char *   pszServicePath
                    )
/*++

  This function creates an entry for a service in the Eventlog registry
   so that the messages of the service may be decoded.

  Arguments:
    pszServiceName     pointer to string containing the service name.
    pszServicePath     pointer to string containing the path for the service
                         dll with the embedded messages.

  Returns:
    TRUE on success and FALSE if there are any errors. Use GetLastError()
      to get detailed error message.

--*/
{
    char rgchKeyName[ LEN_EVENT_LOG_REG_KEY + 100];
    HKEY hkeyReg;
    LONG err;
    DWORD Disposition;


    if ( strlen( pszServiceName) >= 100) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return ( FALSE);
    }

    sprintf( rgchKeyName, "%s\\%s", EVENT_LOG_REG_KEY, pszServiceName);

    //
    //  Add the data to the EventLog's registry key so that the
    //  log insertion strings may be found by the Event Viewer.
    //

    err = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                          rgchKeyName,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_WRITE,
                          NULL,
                          &hkeyReg,
                          &Disposition );

    if( err != 0 ) {

        fprintf( stderr, "RegCreateKeyEx failed: %ld\n", err );

        SetLastError( err);
        return ( FALSE);
    }

    err = RegSetValueEx( hkeyReg,
                         "EventMessageFile",
                         0,
                         REG_EXPAND_SZ,
                         pszServicePath,
                         strlen( pszServicePath ) + 1 );

    if( err == 0 ) {

        DWORD Value;

        Value = ( EVENTLOG_ERROR_TYPE  |
                 EVENTLOG_WARNING_TYPE |
                 EVENTLOG_INFORMATION_TYPE
                 );

        err = RegSetValueEx( hkeyReg,
                            "TypesSupported",
                             0,
                             REG_DWORD,
                             (CONST BYTE *)&Value,
                             sizeof(Value) );
    }

    RegCloseKey( hkeyReg );

    if( err != 0 ) {

        fprintf( stderr, "RegSetValueEx failed: %ld\n", err );
        SetLastError( err);
    }

    return ( err == 0);

}  // CreateEventLogEntry()

DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    )
/*++

   Description

     Sets the specified LSA secret

   Arguments:

     Server - Server name (or NULL) secret lives on
     SecretName - Name of the LSA secret
     pSecret - Pointer to secret memory
     cbSecret - Size of pSecret memory block

   Note:

--*/
{
    LSA_HANDLE        hPolicy;
    UNICODE_STRING    unicodePassword;
    UNICODE_STRING    unicodeServer;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE        hSecret;
    UNICODE_STRING    unicodeSecret;


    RtlInitUnicodeString( &unicodeServer,
                          Server );

    //
    //  Initialize the unicode string by hand so we can handle '\0' in the
    //  string
    //

    unicodePassword.Buffer        = pSecret;
    unicodePassword.Length        = (USHORT) cbSecret;
    unicodePassword.MaximumLength = (USHORT) cbSecret;

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( &unicodeServer,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( RtlNtStatusToDosError( ntStatus ) );
        return FALSE;
    }

    //
    //  Create or open the LSA secret
    //

    RtlInitUnicodeString( &unicodeSecret,
                          SecretName );

    ntStatus = LsaCreateSecret( hPolicy,
                                &unicodeSecret,
                                SECRET_ALL_ACCESS,
                                &hSecret );

    if ( !NT_SUCCESS( ntStatus ))
    {

        //
        //  If the secret already exists, then we just need to open it
        //

        if ( ntStatus == STATUS_OBJECT_NAME_COLLISION )
        {
            ntStatus = LsaOpenSecret( hPolicy,
                                      &unicodeSecret,
                                      SECRET_ALL_ACCESS,
                                      &hSecret );
        }

        if ( !NT_SUCCESS( ntStatus ))
        {
            LsaClose( hPolicy );
            SetLastError( RtlNtStatusToDosError( ntStatus ) );
            return FALSE;
        }
    }

    //
    //  Set the secret value
    //

    ntStatus = LsaSetSecret( hSecret,
                             &unicodePassword,
                             &unicodePassword );

    LsaClose( hSecret );
    LsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ))
    {
        return RtlNtStatusToDosError( ntStatus );
    }

    return TRUE;
}



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\complete.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    complete.c

Abstract:

    This module contains the Completion handling code for SPUD.

Author:

    John Ballard (jballard)     11-Nov-1996

Revision History:

    Keith Moore (keithmo)       04-Feb-1998
        Cleanup, added much needed comments.

--*/


#include "spudp.h"


//
// Private prototypes.
//

VOID
SpudpCompleteRequest(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

VOID
SpudpNormalApcRoutine(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SpudpRundownRoutine(
    IN PKAPC Apc
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SpudpCompleteRequest )
#pragma alloc_text( PAGE, SpudpNormalApcRoutine )
#pragma alloc_text( PAGE, SpudpRundownRoutine )
#endif
#if 0
NOT PAGEABLE -- SpudCompleteRequest
#endif


//
// Public functions.
//


VOID
SpudCompleteRequest(
    IN PSPUD_AFD_REQ_CONTEXT SpudReqContext
    )

/*++

Routine Description:

    Common completion routine for XxxAndRecv IRPs.

Arguments:

    SpudReqContext - The request context associated with the request
        to be completed.

Return Value:

    None.

--*/

{
    PIRP irp;
    PETHREAD thread;
    PFILE_OBJECT fileObject;

    //
    // Snag the IRP from the request context, clear the MDL from the
    // IRP so IO won't chock. (The MDL is also stored in the request
    // context and will be freed in the APC below.)
    //

    irp = SpudReqContext->Irp;
    irp->MdlAddress = NULL;

    //
    // Snag the target thread and file object from the IRP. The APC
    // will be queued against the target thread, and the file object
    // will be a parameter to the APC.
    //

    thread = irp->Tail.Overlay.Thread;
    fileObject = irp->Tail.Overlay.OriginalFileObject;

    //
    // We must pass in a non-NULL function pointer for the NormalRoutine
    // parameter to KeInitializeApc(). This is necessary to keep the APC
    // a "normal" kernel APC. If we were to pass a NULL NormalRoutine, then
    // this would become a "special" APC that could not be blocked via the
    // KeEnterCriticalRegion() and KeLeaveCriticalRegion() functions.
    //

    KeInitializeApc(
        &irp->Tail.Apc,                         // Apc
        (PKTHREAD)&thread,                      // Thread
        irp->ApcEnvironment,                    // Environment
        SpudpCompleteRequest,                   // KernelRoutine
        SpudpRundownRoutine,                    // RundownRoutine
        SpudpNormalApcRoutine,                  // NormalRoutine
        KernelMode,                             // ProcessorMode
        NULL                                    // NormalContext
        );

    KeInsertQueueApc(
        &irp->Tail.Apc,                         // Apc
        SpudReqContext,                         // SystemArgument1
        fileObject,                             // SystemArgument2
        SPUD_PRIORITY_BOOST                     // Increment
        );

}   // SpudCompleteRequest


//
// Private functions.
//

//
// PREFIX Bug 57653. No way do we want to mess with this. This is 
// not on a path that we should be executing based on an initial
// look and the likelyhood of mucking this up with any changes is 
// quite high.
//
/* #pragma INTRINSA suppress=all */
VOID
SpudpCompleteRequest(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    Kernel APC for SPUD IO completion. This routine is responsible for
    writing any final status back to the user-mode code, then signalling
    the completion port.

Arguments:

    Apc - The APC that is firing. Since we always use the APC embedded in
        the IRP, we can use this pointer to get back to the completing IRP.

    NormalRoutine - Indirect pointer to the normal APC routine. We'll use
        this to "short circuit" normal routine invocation.

    NormalContext - Indirect pointer to the normal APC routine context
        (unused).

    SystemArgument1 - Actually an indirect pointer to the SPUD request
        context.

    SystemArgument2 - Actually an indirect pointer to the file object
        that's being completed.

Return Value:

    None.

--*/

{
    PSPUD_AFD_REQ_CONTEXT SpudReqContext;
    PSPUD_REQ_CONTEXT reqContext;
    PIRP irp;
    PFILE_OBJECT fileObject;

    //
    // Sanity check.
    //

    PAGED_CODE();

#if DBG
    if( KeAreApcsDisabled() ) {
        DbgPrint(
            "SPUD: Thread %08lx has non-zero APC disable\n",
            KeGetCurrentThread()
            );

        KeBugCheckEx(
            0xbaadf00d,
            (ULONG_PTR)KeGetCurrentThread(),
            0x77,
            (ULONG_PTR)*SystemArgument1,
            (ULONG_PTR)*SystemArgument2
            );
    }
#endif  // DBG

    //
    // Setting *NormalRoutine to NULL tells the kernel to not
    // dispatch the normal APC routine.
    //

    *NormalRoutine = NULL;
    UNREFERENCED_PARAMETER( NormalContext );

    //
    // Snag the IRP from the APC pointer, then retrieve our parameters
    // from the SystemArgument pointers.
    //

    irp = CONTAINING_RECORD( Apc, IRP, Tail.Apc );
    SpudReqContext = *SystemArgument1;
    fileObject = *SystemArgument2;
    reqContext = SpudReqContext->AtqContext;

    //
    // We're done with the file object.
    //

    TRACE_OB_DEREFERENCE( fileObject );
    ObDereferenceObject( fileObject );

    //
    // Try to write the final completion status back to the user-mode
    // buffer.
    //

    try {
        reqContext->IoStatus1 = SpudReqContext->IoStatus1;
        reqContext->IoStatus2 = SpudReqContext->IoStatus2;
        reqContext->KernelReqInfo = SPUD_INVALID_REQ_HANDLE;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        //
        // There's nothing we can do here other than drop the request
        // on the floor. We cannot return the exception code to the
        // user-mode code. This is OK, as the application will itself
        // throw an exception when it tries to touch the request context.
        //
    }

    //
    // Cleanup the request context.
    //

    SpudFreeRequestContext( SpudReqContext );

    //
    // Post the IRP to the I/O completion port.
    //

    irp->Tail.CompletionKey = reqContext;
    irp->Tail.Overlay.CurrentStackLocation = NULL;
    irp->IoStatus.Status = 0;
    irp->IoStatus.Information = 0xffffffff;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;
    IopDequeueThreadIrp( irp );

    KeInsertQueue(
        (PKQUEUE)SpudCompletionPort,
        &irp->Tail.Overlay.ListEntry
        );

    SpudDereferenceCompletionPort();

}   // SpudpCompleteRequest


VOID
SpudpNormalApcRoutine(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    "Normal" APC routine for our completion APC. This should never be
    invoked.

Arguments:

    NormalContext - Unused.

    SystemArgument1 - Unused.

    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{

    //
    // This routine should never be called. The "*NormalRoutine = NULL"
    // line in SpudpCompleteRequest() prevents the kernel from invoking
    // this routine.
    //

    ASSERT( FALSE );

    UNREFERENCED_PARAMETER( NormalContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

}   // SpudpNormalApcRoutine


VOID
SpudpRundownRoutine(
    IN PKAPC Apc
    )

/*++

Routine Description:

    Rundown routine invoked if our APC got queued to a thread, but the
    thread terminated before the APC could be delivered.

Arguments:

    Apc - The orphaned APC.

Return Value:

    None.

--*/

{
    PKNORMAL_ROUTINE normalRoutine;
    PVOID normalContext;
    PVOID systemArgument1;
    PVOID systemArgument2;

    //
    // This routine is invoked by the kernel if an APC is in a thread's
    // queue when the thread terminates. We'll just call through to the
    // "real" APC routine and let it do its thang (we still want to
    // post the request to the completion port, free resources, etc).
    //

    normalRoutine = Apc->NormalRoutine;
    normalContext = Apc->NormalContext;
    systemArgument1 = Apc->SystemArgument1;
    systemArgument2 = Apc->SystemArgument2;

    SpudpCompleteRequest(
        Apc,
        &normalRoutine,
        &normalContext,
        &systemArgument1,
        &systemArgument2
        );

}   // SpudpRundownRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\context.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module contains SPUD context management routines.

    Request contexts are referenced via a request handle. This necessary
    to validate requests incoming from user-mode. (We can't trust user-
    mode code to give us valid pointers, so instead of storing a pointer
    to our request context structure in the user-mode structure, we store
    a request handle.)

    Request handles identify a SPUD_HANDLE_ENTRY structure in a lookup
    table. Each SPUD_HANDLE_ENTRY contains a copy of the request handle
    (for validation) and a pointer to a SPUD_AFD_REQ_CONTEXT structure.
    Free handle entries are linked together. As handles are allocated,
    they are removed from the free list. Once the free list becomes empty,
    the lookup table is grown appropriately.

Author:

    Keith Moore (keithmo)       01-Oct-1997

Revision History:

--*/


#include "spudp.h"


//
// Private constants.
//

#define SPUD_HANDLE_TABLE_GROWTH    32  // entries

#define LOCK_HANDLE_TABLE()                                                 \
    if( TRUE ) {                                                            \
        KeEnterCriticalRegion();                                            \
        ExAcquireResourceExclusiveLite(                                     \
            &SpudNonpagedData->ReqHandleTableLock,                          \
            TRUE                                                            \
            );                                                              \
    } else

#define UNLOCK_HANDLE_TABLE()                                               \
    if( TRUE ) {                                                            \
        ExReleaseResourceLite(                                              \
            &SpudNonpagedData->ReqHandleTableLock                           \
            );                                                              \
        KeLeaveCriticalRegion();                                            \
    } else


//
// Private types.
//

typedef union _SPUD_HANDLE_ENTRY {
    LIST_ENTRY FreeListEntry;
    struct {
        PVOID ReqHandle;
        PVOID Context;
    };
} SPUD_HANDLE_ENTRY, *PSPUD_HANDLE_ENTRY;


//
// Private globals.
//

PSPUD_HANDLE_ENTRY SpudpHandleTable;
LONG SpudpHandleTableSize;
LIST_ENTRY SpudpFreeList;


//
// Private prototypes.
//

PVOID
SpudpAllocateReqHandle(
    IN PSPUD_AFD_REQ_CONTEXT SpudReqContext
    );

VOID
SpudpFreeReqHandle(
    IN PVOID ReqHandle
    );

PSPUD_AFD_REQ_CONTEXT
SpudpGetReqHandleContext(
    IN PVOID ReqHandle
    );

PSPUD_HANDLE_ENTRY
SpudpMapHandleToEntry(
    IN PVOID ReqHandle
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, SpudInitializeContextManager )
#pragma alloc_text( PAGE, SpudTerminateContextManager )
#pragma alloc_text( PAGE, SpudAllocateRequestContext )
#pragma alloc_text( PAGE, SpudFreeRequestContext )
#pragma alloc_text( PAGE, SpudGetRequestContext )
#pragma alloc_text( PAGE, SpudpAllocateReqHandle )
#pragma alloc_text( PAGE, SpudpFreeReqHandle )
#pragma alloc_text( PAGE, SpudpGetReqHandleContext )
#pragma alloc_text( PAGE, SpudpMapHandleToEntry )
#endif  // ALLOC_PRAGMA

//
// Public functions.
//


NTSTATUS
SpudInitializeContextManager(
    VOID
    )

/*++

Routine Description:

    Performs global initialization for the context manager package.

Arguments:

    None.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Note that the resource protecting the handle table is initialized
    // in SpudInitializeData().
    //

    SpudpHandleTable = NULL;
    SpudpHandleTableSize = 0;
    InitializeListHead( &SpudpFreeList );

    return STATUS_SUCCESS;

}   // SpudInitializeContextManager


VOID
SpudTerminateContextManager(
    VOID
    )

/*++

Routine Description:

    Performs global termination for the context manager package.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Free the handle table (if allocated), reset the other globals.
    //

    if( SpudpHandleTable != NULL ) {
        SPUD_FREE_POOL( SpudpHandleTable );
    }

    SpudpHandleTable = NULL;
    SpudpHandleTableSize = 0;
    InitializeListHead( &SpudpFreeList );

}   // SpudTerminateContextManager


NTSTATUS
SpudAllocateRequestContext(
    OUT PSPUD_AFD_REQ_CONTEXT *SpudReqContext,
    IN PSPUD_REQ_CONTEXT ReqContext,
    IN PAFD_RECV_INFO RecvInfo OPTIONAL,
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    )

/*++

Routine Description:

    Allocates & initializes a new SPUD_AFD_REQ_CONTEXT structure.

Arguments:

    SpudReqContext - If successful, receives a pointer to the newly
        allocated SPUD_AFD_REQ_CONTEXT structure.

    ReqContext - Pointer to the user-mode SPUD_REQ_CONTEXT structure.
        The newly allocated context structure will be associated with
        this user-mode context.

    RecvInfo - An optional pointer to a AFD_RECV_INFO structure describing
        a future receive operation.

    Irp - Pointer to an IO request packet to associate with the new context
        structure.

    IoStatusBlock - An optional pointer to an IO_STATUS_BLOCK used to
        initialize one of the fields in the new context structure.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    PSPUD_AFD_REQ_CONTEXT spudReqContext;
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Try to allocate a new structure.
    //

    spudReqContext = ExAllocateFromNPagedLookasideList(
                         &SpudNonpagedData->ReqContextList
                         );

    if( spudReqContext == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
        spudReqContext,
        sizeof(*spudReqContext)
        );

    //
    // Try to allocate a request handle for the context structure.
    //

    spudReqContext->ReqHandle = SpudpAllocateReqHandle( spudReqContext );

    if( spudReqContext->ReqHandle == SPUD_INVALID_REQ_HANDLE ) {
        SpudFreeRequestContext( spudReqContext );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    spudReqContext->Signature = SPUD_REQ_CONTEXT_SIGNATURE;
    spudReqContext->Irp = Irp;
    spudReqContext->AtqContext = ReqContext;

    try {

        ReqContext->KernelReqInfo = spudReqContext->ReqHandle;

        if( IoStatusBlock != NULL ) {
            spudReqContext->IoStatus1 = *IoStatusBlock;
        }

        //
        // If we got an AFD_RECV_INFO structure, then save the buffer
        // length and create a MDL describing the buffer.
        //

        if( RecvInfo != NULL ) {

            spudReqContext->IoStatus2.Information = RecvInfo->BufferArray->len;
            spudReqContext->Mdl = IoAllocateMdl(
                                      RecvInfo->BufferArray->buf,
                                      RecvInfo->BufferArray->len,
                                      FALSE,
                                      FALSE,
                                      NULL
                                      );

            if( spudReqContext->Mdl == NULL ) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            MmProbeAndLockPages(
                spudReqContext->Mdl,
                UserMode,
                IoWriteAccess
                );

        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Bad news. This is either due to a) an AV trying to access
        // the user-mode request context structure, or b) an exception
        // trying to lock down the receive buffer. If we managed to
        // allocate a MDL for the context, then we know the problem
        // was because the pages could not be locked, so we'll need to
        // free the MDL before continuing. In any case, we'll need to
        // free the newly allocated request context.
        //

        status = GetExceptionCode();

        if( spudReqContext->Mdl != NULL ) {
            IoFreeMdl( spudReqContext->Mdl );
            spudReqContext->Mdl = NULL;
        }

        SpudFreeRequestContext( spudReqContext );
        spudReqContext = NULL;
    }

    *SpudReqContext = spudReqContext;
    return status;

}   // SpudAllocateRequestContext


VOID
SpudFreeRequestContext(
    IN PSPUD_AFD_REQ_CONTEXT SpudReqContext
    )

/*++

Routine Description:

    Frees a SPUD_AFD_REQ_CONTEXT structure allocated above.

Arguments:

    SpudReqContext - A context structure allocated above.

Return Value:

    None.

--*/

{

    PMDL mdl, nextMdl;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( SpudReqContext != NULL );
    ASSERT( SpudReqContext->Signature == SPUD_REQ_CONTEXT_SIGNATURE );

    //
    // Unlock & free any MDL chain still attached to the
    // request context.
    //

    mdl = SpudReqContext->Mdl;
    SpudReqContext->Mdl = NULL;

    while( mdl != NULL ) {
        nextMdl = mdl->Next;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
        mdl = nextMdl;
    }

    //
    // Free the handle if we managed to allocate one.
    //

    if( SpudReqContext->ReqHandle != SPUD_INVALID_REQ_HANDLE ) {
        ASSERT( SpudpGetReqHandleContext( SpudReqContext->ReqHandle ) == SpudReqContext );
        SpudpFreeReqHandle( SpudReqContext->ReqHandle );
        SpudReqContext->ReqHandle = SPUD_INVALID_REQ_HANDLE;
    }

    //
    // Free the context.
    //

    SpudReqContext->Signature = SPUD_REQ_CONTEXT_SIGNATURE_X;
    SpudReqContext->Irp = NULL;

    ExFreeToNPagedLookasideList(
        &SpudNonpagedData->ReqContextList,
        SpudReqContext
        );

}   // SpudFreeRequestContext


PSPUD_AFD_REQ_CONTEXT
SpudGetRequestContext(
    IN PSPUD_REQ_CONTEXT ReqContext
    )

/*++

Routine Description:

    Retrieves the SPUD_AFD_REQ_CONTEXT structure associated with the
    incoming user-mode SPUD_REQ_CONTEXT.

Arguments:

    ReqContext - The incoming user-mode SPUD_REQ_CONTEXT structure.

Return Value:

    PSPUD_AFD_REQ_CONTEXT - Pointer to the associated context structure
        if successful, NULL otherwise.

--*/

{

    PSPUD_AFD_REQ_CONTEXT spudReqContext = NULL;
    PVOID reqHandle;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Snag the kernel-mode request context handle from the user-mode
    // context.
    //

    try {
        reqHandle = ReqContext->KernelReqInfo;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        reqHandle = SPUD_INVALID_REQ_HANDLE;
    }

    if( reqHandle != SPUD_INVALID_REQ_HANDLE ) {

        //
        // Map the handle.
        //

        spudReqContext = SpudpGetReqHandleContext( reqHandle );

    }

    return spudReqContext;

}   // SpudGetRequestContext


//
// Private functions.
//


PVOID
SpudpAllocateReqHandle(
    IN PSPUD_AFD_REQ_CONTEXT SpudReqContext
    )

/*++

Routine Description:

    Allocates a new request handle for the specified context.

Arguments:

    SpudReqContext - A context structure.

Return Value:

    PVOID - The new request handle if successful, SPUD_INVALID_REQ_HANDLE
        otherwise.

--*/

{

    LONG groupValue;
    PSPUD_HANDLE_ENTRY handleEntry;
    PSPUD_HANDLE_ENTRY newHandleTable;
    LONG newHandleTableSize;
    LONG i;
    PLIST_ENTRY listEntry;
    PVOID reqHandle;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( SpudReqContext != NULL );

    //
    // See if there's room at the inn.
    //

    LOCK_HANDLE_TABLE();

    if( IsListEmpty( &SpudpFreeList ) ) {

        //
        // No room, we'll need to create/expand the table.
        //

        newHandleTableSize = SpudpHandleTableSize + SPUD_HANDLE_TABLE_GROWTH;

        newHandleTable = SPUD_ALLOCATE_POOL(
                             PagedPool,
                             newHandleTableSize * sizeof(SPUD_HANDLE_ENTRY),
                             SPUD_HANDLE_TABLE_POOL_TAG
                             );

        if( newHandleTable == NULL ) {
            UNLOCK_HANDLE_TABLE();
            return NULL;
        }

        if( SpudpHandleTable == NULL ) {

            //
            // This is the initial table allocation, so reserve the
            // first entry. (NULL is not a valid request handle.)
            //

            newHandleTable[0].ReqHandle = NULL;
            newHandleTable[0].Context = NULL;

            SpudpHandleTableSize++;

        } else {

            //
            // Copy the old table into the new table, then free the
            // old table.
            //

            RtlCopyMemory(
                newHandleTable,
                SpudpHandleTable,
                SpudpHandleTableSize * sizeof(SPUD_HANDLE_ENTRY)
                );

            SPUD_FREE_POOL( SpudpHandleTable );

        }

        //
        // Add the new entries to the free list.
        //

        for( i = newHandleTableSize - 1 ; i >= SpudpHandleTableSize ; i-- ) {

            InsertHeadList(
                &SpudpFreeList,
                &newHandleTable[i].FreeListEntry
                );

        }

        SpudpHandleTable = newHandleTable;
        SpudpHandleTableSize = newHandleTableSize;

    }

    //
    // Pull the next free entry off the list.
    //

    ASSERT( !IsListEmpty( &SpudpFreeList ) );

    listEntry = RemoveHeadList( &SpudpFreeList );

    handleEntry = CONTAINING_RECORD(
                      listEntry,
                      SPUD_HANDLE_ENTRY,
                      FreeListEntry
                      );

    //
    // Compute the handle and initialize the new handle entry.
    //

    reqHandle = (PVOID)( handleEntry - SpudpHandleTable );
    ASSERT( reqHandle != SPUD_INVALID_REQ_HANDLE );

    handleEntry->ReqHandle = reqHandle;
    handleEntry->Context = SpudReqContext;

    UNLOCK_HANDLE_TABLE();
    return reqHandle;

}   // SpudpAllocateReqHandle


VOID
SpudpFreeReqHandle(
    IN PVOID ReqHandle
    )

/*++

Routine Description:

    Frees a request handle.

Arguments:

    ReqHandle - The request handle to free.

Return Value:

    None.

--*/

{

    PSPUD_HANDLE_ENTRY handleEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Map the handle to the table entry. If successful, put the
    // entry onto the free list.
    //

    handleEntry = SpudpMapHandleToEntry( ReqHandle );

    if( handleEntry != NULL ) {

        InsertTailList(
            &SpudpFreeList,
            &handleEntry->FreeListEntry
            );

        UNLOCK_HANDLE_TABLE();

    }

}   // SpudpFreeReqHandle


PSPUD_AFD_REQ_CONTEXT
SpudpGetReqHandleContext(
    IN PVOID ReqHandle
    )

/*++

Routine Description:

    Retrieves the context value associated with the given request handle.

Arguments:

    ReqHandle - The request handle to retrieve.

Return Value:

    PSPUD_AFD_REQ_CONTEXT - Pointer to the context if successful,
        NULL otherwise.

--*/

{

    PSPUD_HANDLE_ENTRY handleEntry;
    PSPUD_AFD_REQ_CONTEXT spudReqContext;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Map the handle to the table entry. If successful, retrieve
    // the context.
    //

    handleEntry = SpudpMapHandleToEntry( ReqHandle );

    if( handleEntry != NULL ) {

        spudReqContext = handleEntry->Context;
        ASSERT( spudReqContext != NULL );

        UNLOCK_HANDLE_TABLE();
        return spudReqContext;

    }

    return NULL;

}   // SpudpGetReqHandleContext


PSPUD_HANDLE_ENTRY
SpudpMapHandleToEntry(
    IN PVOID ReqHandle
    )

/*++

Routine Description:

    Maps the given request handle to the corresponding SPUD_HANDLE_ENTRY
    structure.

    N.B. This routine returns with the handle table lock held if successful.

Arguments:

    ReqHandle - The handle to map.

Return Value:

    PSPUD_HANDLE_ENTRY - The entry corresponding to the request handle if
        successful, NULL otherwise.

--*/

{

    PSPUD_HANDLE_ENTRY handleEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Validate the handle.
    //

    LOCK_HANDLE_TABLE();

    if( (LONG_PTR)ReqHandle > 0 && (LONG_PTR)ReqHandle < (LONG_PTR)SpudpHandleTableSize ) {

        handleEntry = SpudpHandleTable + (ULONG_PTR)ReqHandle;

        //
        // The handle is within legal range, ensure it's in use.
        //

        if( handleEntry->ReqHandle == ReqHandle ) {
            return handleEntry;
        }

    }

    //
    // Invalid handle, fail it.
    //

    UNLOCK_HANDLE_TABLE();
    return NULL;

}   // SpudpMapHandleToEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\init.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module performs initialization for the SPUD device driver.

Author:

    John Ballard (jballard)     21-Oct-1996

Revision History:

    Keith Moore (keithmo)       04-Feb-1998
        Cleanup, added much needed comments.

--*/


#include "spudp.h"


//
// Private constants.
//

#define REGISTRY_SPUD_INFORMATION   L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Spud"
#define REGISTRY_PARAMETERS         L"Parameters"

#define REGISTRY_DO_NOT_LOAD        L"DoNotLoad"

#if DBG
#define REGISTRY_BREAK_ON_STARTUP   L"BreakOnStartup"
#define REGISTRY_USE_PRIVATE_ASSERT L"UsePrivateAssert"
#endif

#if ALLOW_UNLOAD
#define REGISTRY_ENABLE_UNLOAD      L"EnableUnload"
#endif


//
// Private globals.
//

BOOLEAN SpudpFailLoad;

#if ALLOW_UNLOAD
BOOLEAN SpudpEnableUnload;
#endif


//
// Private prototypes.
//

VOID
SpudpReadRegistry(
    VOID
    );

NTSTATUS
SpudpOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    );

ULONG
SpudpReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

#if ALLOW_UNLOAD
VOID
SpudpUnload(
    IN PDRIVER_OBJECT DriverObject
    );
#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( INIT, SpudpReadRegistry )
#pragma alloc_text( INIT, SpudpOpenRegistry )
#pragma alloc_text( INIT, SpudpReadSingleParameter )
#if ALLOW_UNLOAD
#pragma alloc_text( PAGE, SpudpUnload )
#endif
#endif


//
// Public functions.
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the SPUD driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{

    NTSTATUS status;
    UNICODE_STRING deviceName;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Read any configuration information from the registry.
    //

    SpudpReadRegistry();

    //
    // If we're configured to fail the load, then bail.
    //

    if( SpudpFailLoad ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Create and initialize our device object.
    //

    RtlInitUnicodeString(
        &deviceName,
        SPUD_DEVICE_NAME
        );

    status = IoCreateDevice(
                 DriverObject,                  // DriverObject
                 0,                             // DeviceExtension
                 &deviceName,                   // DeviceName
                 FILE_DEVICE_NAMED_PIPE,        // DeviceType
                 0,                             // DeviceCharacteristics
                 TRUE,                          // Exclusive
                 &SpudSelfDeviceObject          // DeviceObject
                 );

    if( !NT_SUCCESS(status) ) {
        KdPrint(( "SPUD DriverEntry: unable to create device object: %X\n", status ));
        return status;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = SpudIrpCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SpudIrpClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SpudIrpCleanup;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = SpudIrpQuery;

#if ALLOW_UNLOAD
    if( SpudpEnableUnload ) {
        DriverObject->DriverUnload = SpudpUnload;
        KdPrint(( "SPUD DriverEntry: unload enabled\n" ));
    }
#endif

    //
    // Initialize the context manager.
    //

    status = SpudInitializeContextManager();

    if( !NT_SUCCESS(status) ) {
        IoDeleteDevice( SpudSelfDeviceObject );
        return status;
    }

    //
    // Initialize other global data.
    //

    status = SpudInitializeData();

    if( !NT_SUCCESS(status) ) {
        SpudTerminateContextManager();
        IoDeleteDevice( SpudSelfDeviceObject );
        return status;
    }

    //
    // Add our service table to the system.
    //

    if( !KeAddSystemServiceTable(
            SpudServiceTable,                   // Base
            NULL,                               // Count
            SpudServiceLimit,                   // Limit
            SpudArgumentTable,                  // Number
            IIS_SERVICE_INDEX                   // Index
            ) ) {
        SpudTerminateContextManager();
        IoDeleteDevice( SpudSelfDeviceObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;

}   // DriverEntry


//
// Private functions.
//


VOID
SpudpReadRegistry(
    VOID
    )

/*++

Routine Description:

    Reads the SPUD section of the registry.  Any values listed in the
    registry override defaults.

Arguments:

    None.

Return Value:

    None -- if anything fails, the default value is used.

--*/
{

    HANDLE parametersHandle;
    NTSTATUS status;
    UNICODE_STRING registryPath;
    CLONG i;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Open the registry.
    //

    RtlInitUnicodeString(
        &registryPath,
        REGISTRY_SPUD_INFORMATION
        );

    status = SpudpOpenRegistry( &registryPath, &parametersHandle );

    if( status != STATUS_SUCCESS ) {
        return;
    }

#if DBG
    //
    // Force a breakpoint if so requested.
    //

    if( SpudpReadSingleParameter(
            parametersHandle,
            REGISTRY_BREAK_ON_STARTUP,
            0 ) != 0 ) {
        DbgBreakPoint();
    }

    //
    // Enable private assert function if requested. Note that the
    // default value is TRUE for free builds and FALSE for checked
    // builds.
    //

    SpudUsePrivateAssert = ( *(PULONG)&NtBuildNumber & 0xF0000000 ) == 0xF0000000;

    SpudUsePrivateAssert = SpudpReadSingleParameter(
                              parametersHandle,
                              REGISTRY_USE_PRIVATE_ASSERT,
                              (LONG)SpudUsePrivateAssert
                              ) != 0;

#endif

#if ALLOW_UNLOAD
    //
    // Enable driver unload on checked builds only if the proper
    // value is in the registry. NEVER enable driver unload on free
    // builds.
    //

    SpudpEnableUnload = SpudpReadSingleParameter(
                           parametersHandle,
                           REGISTRY_ENABLE_UNLOAD,
                           (LONG)SpudpEnableUnload
                           ) != 0;
#endif

    //
    // Fail Load if so requested.
    //

    if( SpudpReadSingleParameter(
            parametersHandle,
            REGISTRY_DO_NOT_LOAD,
            0 ) != 0 ) {
        SpudpFailLoad = TRUE;
        KdPrint(("Spud.sys load aborted! DoNotLoad is configured in the registry.\n"));
    } else {
        SpudpFailLoad = FALSE;
        KdPrint(("Spud.sys load enabled! DoNotLoad is configured in the registry.\n"));
    }

    //
    // Cleanup.
    //

    ZwClose( parametersHandle );

}   // SpudpReadRegistry


NTSTATUS
SpudpOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by SPUD to open the registry. If the registry
    tree exists, then it opens it and returns STATUS_SUCCESS.

Arguments:

    BaseName - Where in the registry to start looking for the information.

    LinkageHandle - Returns the handle used to read linkage information.

    ParametersHandle - Returns the handle used to read other
        parameters.

Return Value:

    The status of the request.

--*/
{

    HANDLE configHandle;
    NTSTATUS status;
    PWSTR parametersString = REGISTRY_PARAMETERS;
    UNICODE_STRING parametersKeyName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Open the registry for the initial string.
    //

    InitializeObjectAttributes(
        &objectAttributes,
        BaseName,                   // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    status = ZwOpenKey(
                 &configHandle,
                 KEY_READ,
                 &objectAttributes
                 );

    if( !NT_SUCCESS(status) ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now open the parameters key.
    //

    RtlInitUnicodeString(
        &parametersKeyName,
        parametersString
        );

    InitializeObjectAttributes(
        &objectAttributes,
        &parametersKeyName,         // name
        OBJ_CASE_INSENSITIVE,       // attributes
        configHandle,               // root
        NULL                        // security descriptor
        );

    status = ZwOpenKey(
                 ParametersHandle,
                 KEY_READ,
                 &objectAttributes
                 );

    if( !NT_SUCCESS(status) ) {
        ZwClose( configHandle );
        return status;
    }

    //
    // All keys successfully opened.
    //

    ZwClose( configHandle );
    return STATUS_SUCCESS;

}   // SpudpOpenRegistry


ULONG
SpudpReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )

/*++

Routine Description:

    This routine is called by SPUD to read a single parameter
    from the registry. If the parameter is found it is stored
    in Data.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to search for.

    DefaultValue - The default value.

Return Value:

    The value to use; will be the default if the value is not
    found or is not in the correct range.

--*/

{

    static ULONG informationBuffer[32];   // declare ULONG to get it aligned
    PKEY_VALUE_FULL_INFORMATION information =
        (PKEY_VALUE_FULL_INFORMATION)informationBuffer;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    LONG returnValue;
    NTSTATUS status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Read the registry value.
    //

    RtlInitUnicodeString(
        &valueKeyName,
        ValueName
        );

    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValueFullInformation,
                 (PVOID)information,
                 sizeof (informationBuffer),
                 &informationLength
                 );

    if( (status == STATUS_SUCCESS) && (information->DataLength == sizeof(ULONG)) ) {

        RtlMoveMemory(
            (PVOID)&returnValue,
            ((PUCHAR)information) + information->DataOffset,
            sizeof(ULONG)
            );

        if (returnValue < 0) {
            returnValue = DefaultValue;
        }

    } else {

        returnValue = DefaultValue;
    }

    return returnValue;

}   // SpudpReadSingleParameter


#if ALLOW_UNLOAD

VOID
SpudpUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Unload routine.

Arguments:

    DriverObject - Pointer to target driver object.

Return Value:

    None.

--*/

{

    PKSERVICE_TABLE_DESCRIPTOR serviceTable;
    ULONG i;

    //
    // Sanity check.
    //

    PAGED_CODE();
    UNREFERENCED_PARAMETER( DriverObject );

    //
    // Yank the system service table. What a hack.
    //
    // Note that this can never be perfectly synchronized, and you
    // risk a blue-screen everytime you unload the driver. Only
    // initiate an unload if you're absolutely sure the server is
    // idle. This is the reason this code is conditionally compiled
    // and will never see the light of day in a public, retail build.
    //

    serviceTable = *KeServiceDescriptorTable;

    serviceTable[IIS_SERVICE_INDEX].Base = NULL;
    serviceTable[IIS_SERVICE_INDEX].Count = NULL;
    serviceTable[IIS_SERVICE_INDEX].Limit = 0;
    serviceTable[IIS_SERVICE_INDEX].Number = NULL;

    try {
        serviceTable += NUMBER_SERVICE_TABLES;

        for( i = 0 ; i < 1000 ; i++ ) {
            if( serviceTable->Base == SpudServiceTable &&
                serviceTable->Count == NULL &&
                serviceTable->Limit == SpudServiceLimit &&
                serviceTable->Number == SpudArgumentTable
                ) {
                serviceTable->Base = NULL;
                serviceTable->Count = NULL;
                serviceTable->Limit = 0;
                serviceTable->Number = NULL;
                break;
            }

            serviceTable = (PKSERVICE_TABLE_DESCRIPTOR)( (PUCHAR)serviceTable + sizeof(ULONG_PTR) );
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NOTHING;
    }

    //
    // Dereference the I/O completion port.
    //

    if( SpudCompletionPort != NULL ) {
        TRACE_OB_DEREFERENCE( SpudCompletionPort );
        ObDereferenceObject(SpudCompletionPort);
        SpudCompletionPort = NULL;
    }

    //
    // Destroy the non-paged data.
    //

    if( SpudNonpagedData != NULL ) {

        ExDeleteNPagedLookasideList( &SpudNonpagedData->ReqContextList );
        ExDeleteResourceLite( &SpudNonpagedData->ReqHandleTableLock );

        SPUD_FREE_POOL( SpudNonpagedData );
        SpudNonpagedData = NULL;

    }

    //
    // Nuke the device object.
    //

    IoDeleteDevice( SpudSelfDeviceObject );
    SpudSelfDeviceObject = NULL;

    //
    // Free the trace log.
    //

#if ENABLE_OB_TRACING
    if( SpudTraceLog != NULL ) {
        DestroyRefTraceLog( SpudTraceLog );
        SpudTraceLog = NULL;
    }
#endif

}   // SpudpUnload

#endif  // ALLOW_UNLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\dispatch.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the IRP dispatch code for SPUD.

Author:

    Keith Moore (keithmo)       09-Feb-1998

Revision History:

--*/


#include "spudp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SpudIrpCreate )
#pragma alloc_text( PAGE, SpudIrpClose )
#pragma alloc_text( PAGE, SpudIrpQuery )
#endif
#if 0
NOT PAGEABLE -- SpudIrpCleanup
#endif


//
// Public functions.
//


NTSTATUS
SpudIrpCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_CREATE IRPs. IRP_MJ_CREATE is issued when
    a new file object is being created.

Arguments:

    DeviceObject - Pointer to the target device object.

    Irp - Pointer to the I/O request packet.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status = STATUS_SUCCESS;
    PVOID xchg;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Ensure this is the only process that may access the driver.
    //

    xchg = InterlockedCompareExchangePointer(
               (PVOID *)&SpudOwningProcess,
               (PVOID)PsGetCurrentProcess(),
               NULL
               );

    ASSERT( xchg == NULL );

    //
    // Complete the IRP.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, SPUD_PRIORITY_BOOST );

    return status;

}   // SpudIrpCreate


NTSTATUS
SpudIrpClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_CLOSE IRPs. IRP_MJ_CLOSE is issued when
    the final reference to a file object is removed and the object is
    being destroyed.

Arguments:

    DeviceObject - Pointer to the target device object.

    Irp - Pointer to the I/O request packet.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status = STATUS_SUCCESS;
    PVOID xchg;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Clear the owner process.
    //

    xchg = InterlockedCompareExchangePointer(
               (PVOID *)&SpudOwningProcess,
               NULL,
               (PVOID)PsGetCurrentProcess()
               );

    ASSERT( xchg == (PVOID)PsGetCurrentProcess() );

    //
    // Dereference the I/O completion port.
    //

    SpudDereferenceCompletionPort();

    //
    // Complete the IRP;
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, SPUD_PRIORITY_BOOST );

    return status;

}   // SpudIrpClose


NTSTATUS
SpudIrpCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_CLEANUP IRPs. IRP_MJ_CLEANUP is issued
    when the last handle to a file object is closed.

Arguments:

    DeviceObject - Pointer to the target device object.

    Irp - Pointer to the I/O request packet.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Complete the IRP;
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, SPUD_PRIORITY_BOOST );

    return status;

}   // SpudIrpCleanup


NTSTATUS
SpudIrpQuery(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_QUERY IRPs.

Arguments:

    DeviceObject - Pointer to the target device object.

    Irp - Pointer to the I/O request packet.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    PFILE_NAME_INFORMATION nameInfo;
    ULONG bytesRequired;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Validate the input arguments.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    bytesRequired = sizeof(*nameInfo) - sizeof(nameInfo->FileName);

    if( irpSp->Parameters.QueryFile.Length >= bytesRequired ) {
        status = STATUS_INVALID_PARAMETER;
    }

    //
    // Return an empty name.
    //

    if( NT_SUCCESS(status) ) {
        nameInfo = Irp->AssociatedIrp.SystemBuffer;

        nameInfo->FileNameLength = 0;
        Irp->IoStatus.Information = bytesRequired;
    }

    //
    // Complete the IRP.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, SPUD_PRIORITY_BOOST );

    return status;

}   // SpudIrpQuery
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\misc.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains the miscellaneous SPUD routines.

Author:

    John Ballard (jballard)     21-Oct-1996

Revision History:

    Keith Moore (keithmo)       04-Feb-1998
        Cleanup, added much needed comments.

--*/


#include "spudp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SpudEnterService )
#pragma alloc_text( PAGE, SpudLeaveService )
#pragma alloc_text( PAGE, SpudGetAfdDeviceObject )
#endif
#if 0
NOT PAGEABLE -- SpudAssert
NOT PAGEABLE -- SpudReferenceCompletionPort
NOT PAGEABLE -- SpudDereferenceCompletionPort
#endif


//
// Public funcitons.
//


NTSTATUS
SpudEnterService(
#if DBG
    IN PSTR ServiceName,
#endif
    IN BOOLEAN InitRequired
    )

/*++

Routine Description:

    Common service entry prologue. This routine ensures that all necessary
    initialization required by the service has been performed.

Arguments:

    ServiceName - Name of the service being invoked (DBG only).

    InitRequired - If TRUE, then the driver must have already been fully
        initialized. This parameter is TRUE for all services *except*
        SPUDInitialize().

Return Value:

    NTSTATUS - Completion status

--*/

{

    //
    // Sanity check.
    //

    PAGED_CODE();

#if DBG
    UNREFERENCED_PARAMETER( ServiceName );
#endif

    //
    // If InitRequired is TRUE, then the current process must match the
    // one that owns our driver.
    //

    if( InitRequired &&
        ( SpudOwningProcess != PsGetCurrentProcess() ) ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // If InitRequired is FALSE, then there must be no owning process.
    //

    if( !InitRequired &&
        ( SpudOwningProcess != NULL ) ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Looks good.
    //

    return STATUS_SUCCESS;

}   // SpudEnterService


VOID
SpudLeaveService(
#if DBG
    IN PSTR ServiceName,
    IN NTSTATUS Status,
#endif
    IN BOOLEAN DerefRequired
    )

/*++

Routine Description:

    Common service exit routine.

Arguments:

    ServiceName - Name of the service being invoked (DBG only).

    Status - Service completion status (DBG only).

    DerefRequired - TRUE if the completion port should be dereferenced
        before returning.

Return Value:

    None.

--*/

{

    //
    // Sanity check.
    //

    PAGED_CODE();

#if DBG
    UNREFERENCED_PARAMETER( ServiceName );
    UNREFERENCED_PARAMETER( Status );
#endif

    if( DerefRequired ) {
        SpudDereferenceCompletionPort();
    }

}   // SpudLeaveService


NTSTATUS
SpudGetAfdDeviceObject(
    IN PFILE_OBJECT AfdFileObject
    )

/*++

Routine Description:

    Retreives AFD's device object & fast IO dispatch table from a
    socket's file object.

Arguments:

    AfdFileObject - The FILE_OBJECT for an open socket.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Chase down the device object associated with the file object, then
    // snag the fast I/O dispatch table.
    //

    SpudAfdDeviceObject = IoGetRelatedDeviceObject( AfdFileObject );

    if( !SpudAfdDeviceObject ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    SpudAfdFastIoDeviceControl =
        SpudAfdDeviceObject->DriverObject->FastIoDispatch->FastIoDeviceControl;

    if( !SpudAfdFastIoDeviceControl ) {
        SpudAfdDeviceObject = NULL;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    return STATUS_SUCCESS;

}   // SpudGetAfdDeviceObject

#if DBG


VOID
SpudAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )

/*++

Routine Description:

    Private assertion failure handler. This is necessary to make ASSERT()s
    work on free builds. (RtlAssert() is a noop on free builds.)

Arguments:

    FailedAssertion - The text of the failed assertion.

    FileName - The file name containing the failed assertion.

    LineNumber - The line number of the failed assertion.

    Message - An optional message to display with the assertion.

Return Value:

    None.

--*/

{

    //
    // If we 're to use our private assert, then do it ourselves.
    // Otherwise, let RtlAssert() handle it.
    //

    if( SpudUsePrivateAssert ) {

        DbgPrint(
            "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
            Message
                ? Message
                : "",
            FailedAssertion,
            FileName,
            LineNumber
            );

        DbgBreakPoint();

    } else {

        RtlAssert(
            FailedAssertion,
            FileName,
            LineNumber,
            Message
            );

    }

}   // SpudAssert

#endif  // DBG


PVOID
SpudReferenceCompletionPort(
    VOID
    )

/*++

Routine Description:

    Bumps our private reference on the completion port pointer.

Arguments:

    None.

Return Value:

    PVOID - A pointer to the completion port object if successful,
        NULL otherwise.

--*/

{

    PVOID port;
    KIRQL oldIrql;

    KeAcquireSpinLock(
        &SpudCompletionPortLock,
        &oldIrql
        );

    port = SpudCompletionPort;

    if( port != NULL ) {
        SpudCompletionPortRefCount++;
        ASSERT( SpudCompletionPortRefCount > 0 );
    }

    KeReleaseSpinLock(
        &SpudCompletionPortLock,
        oldIrql
        );

    return port;

}   // SpudReferenceCompletionPort


VOID
SpudDereferenceCompletionPort(
    VOID
    )

/*++

Routine Description:

    Removes a private reference from the completion port object.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL oldIrql;

    KeAcquireSpinLock(
        &SpudCompletionPortLock,
        &oldIrql
        );

    if( SpudCompletionPort != NULL ) {

        ASSERT( SpudCompletionPortRefCount > 0 );
        SpudCompletionPortRefCount--;

        if( SpudCompletionPortRefCount == 0 ) {
            TRACE_OB_DEREFERENCE( SpudCompletionPort );
            ObDereferenceObject( SpudCompletionPort );
            SpudCompletionPort = NULL;
        }

    }

    KeReleaseSpinLock(
        &SpudCompletionPortLock,
        oldIrql
        );

}   // SpudDereferenceCompletionPort
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    oplock.c

Abstract:

    This module contains the SPUDCreateFile service.

Author:

    John Ballard (jballard)     13-Dec-1996

Revision History:

    Keith Moore (keithmo)       02-Feb-1998
        Made it work, added much needed comments.

--*/


#include "spudp.h"


//
// Private prototypes.
//

NTSTATUS
SpudpOplockCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SPUDCreateFile )
#endif
#if 0
NOT PAGEABLE -- SpudpOplockCompletion
#endif


//
// Public routines.
//


NTSTATUS
SPUDCreateFile(
    OUT PHANDLE FileHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateOptions,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecDescBuffer,
    IN ULONG SecDescLength,
    OUT PULONG SecDescLengthNeeded,
    IN PVOID OplockContext,
    IN LARGE_INTEGER OplockMaxFileSize,
    OUT PBOOLEAN OplockGranted,
    OUT PSPUD_FILE_INFORMATION FileInfo
    )

/*++

Routine Description:

    This service opens a file and queries information about the file. This
    service can also optionally retrieve any security descriptor associated
    with the file and issue an oplock request.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open
        file.

    ObjectAttributes - Supplies the attributes to be used for file object
        (name, SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    FileAttributes - Specifies the attributes that should be set on the file,
        if it is created.

    ShareAccess - Supplies the types of share access that the caller would
        like to the file.

    CreateOptions - Caller options for how to perform the create/open.

    SecurityInformation - Indicates the type of security information to
        retrieve.

    SecDescBuffer - Supplies a buffer to receive the file's security
        descriptor.

    SecDescLength - Supplies the length of the security descriptor buffer.

    SecDescLengthNeeded - Receives the length needed to store the security
        descriptor.

    OplockContext - Supplies an uninterpreted context used during oplock
        break notifications. If this value is NULL, then no oplock request
        is issued.

    OplockMaxFileSize = If the size of the file opened is larger than
         OplockMaxFileSize then no oplock request is issued.

    OplockGranted - A pointer to a variable to receive the status of the
        oplock request. This parameter is ignored if OplockContext is NULL.

    FileInfo - Supplies a buffer to receive information about the file.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    HANDLE localFileHandle;
    IO_STATUS_BLOCK localIoStatusBlock;
    FILE_BASIC_INFORMATION basicInfo;
    FILE_STANDARD_INFORMATION standardInfo;
    PVOID completionPort;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( SPUD_OPLOCK_BREAK_OPEN == FILE_OPLOCK_BROKEN_TO_LEVEL_2 );
    ASSERT( SPUD_OPLOCK_BREAK_CLOSE == FILE_OPLOCK_BROKEN_TO_NONE );

    status = SPUD_ENTER_SERVICE( "SPUDCreateFile", TRUE );

    if( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // SPUD doesn't support kernel-mode callers. In fact, we don't
    // even build the "system stubs" necessary to invoke SPUD from
    // kernel-mode.
    //

    ASSERT( ExGetPreviousMode() == UserMode );

    //
    // Probe the generic arguments. We don't need to probe the FileHandle
    // and IoStatusBlock parameters, as they will be probed by IoCreateFile().
    //

    try {

        //
        // The FileInfo parameter must be writeable by the caller.
        //

        ProbeForWrite( FileInfo, sizeof(*FileInfo), sizeof(ULONG) );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, FALSE );
        return status;
    }

    //
    // Open the file. If successful, this will write the newly-opened
    // file handle into *FileHandle.
    //

    status = IoCreateFile(
                 FileHandle,                    // FileHandle
                 GENERIC_READ                   // DesiredAccess
                    | SYNCHRONIZE               //
                    | FILE_READ_ATTRIBUTES,     //
                 ObjectAttributes,              // ObjectAttributes
                 IoStatusBlock,                 // IoStatusBlock
                 NULL,                          // AllocationSize
                 FileAttributes,                // FileAttributes
                 ShareAccess,                   // ShareAccess
                 FILE_OPEN,                     // Disposition
                 CreateOptions,                 // CreateOptions
                 NULL,                          // EaBuffer
                 0,                             // EaLength
                 CreateFileTypeNone,            // CreateFileType
                 NULL,                          // ExtraCreateParameters
                 0                              // Options
                 );

    if( !NT_SUCCESS(status) ) {
        SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, FALSE );
        return status;
    }

    //
    // Snag the handle from the user-mode buffer.
    //

    try {
        localFileHandle = *FileHandle;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        //
        // We faulted trying to read the file handle from user-mode memory.
        // The user-mode code must have mucked with the virtual address
        // space after we called IoCreateFile(). Since we cannot get the
        // file handle, we cannot close the file, and the user-mode code is
        // going to leak the handle.
        //

        status = GetExceptionCode();
        SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, FALSE );
        return status;
    }

    //
    // Query the file attributes.
    //

    status = ZwQueryInformationFile(
                 localFileHandle,               // FileHandle
                 &localIoStatusBlock,           // IoStatusBlock
                 &basicInfo,                    // FileInformation
                 sizeof(basicInfo),             // Length
                 FileBasicInformation           // FileInformationClass
                 );

    if( NT_SUCCESS(status) ) {
        status = ZwQueryInformationFile(
                     localFileHandle,           // FileHandle
                     &localIoStatusBlock,       // IoStatusBlock
                     &standardInfo,             // FileInformation
                     sizeof(standardInfo),      // Length
                     FileStandardInformation    // FileInformationClass
                     );
    }

    if( NT_SUCCESS(status) ) {
        //
        // Copy the file attributes to the user-mode buffer.
        //

        try {
            RtlCopyMemory(
                &FileInfo->BasicInformation,
                &basicInfo,
                sizeof(basicInfo)
                );

            RtlCopyMemory(
                &FileInfo->StandardInformation,
                &standardInfo,
                sizeof(standardInfo)
                );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            status = GetExceptionCode();
        }
    }

    //
    // If we failed for any reason (either we failed to query the attributes
    // or we faulted trying to copy them to user-mode) then close the file
    // handle and bail.
    //

    if( !NT_SUCCESS(status) ) {
        NtClose( localFileHandle );
        SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, FALSE );
        return status;
    }

    //
    // If the caller passed in a security descriptor buffer, then try to
    // query the security descriptor.
    //

    if( SecDescLength > 0 ) {

        //
        // Query the security descriptor from the file. Note that
        // since the previous mode == UserMode, we don't need to
        // probe SecDescBuffer or SecDescLengthNeeded (they will be
        // probed by the NtQuerySecurityObject() API).
        //

        status = NtQuerySecurityObject(
                     localFileHandle,           // Handle
                     SecurityInformation,       // SecurityInformation
                     SecDescBuffer,             // SecurityDescriptor
                     SecDescLength,             // Length
                     SecDescLengthNeeded        // LengthNeeded
                     );

        if( !NT_SUCCESS(status) ) {

            if( status == STATUS_NOT_SUPPORTED ) {
                //
                // This status code is returned for filesystems that don't
                // support security. We'll just fake an empty descriptor.
                //

                try {
                    *SecDescLengthNeeded = 0;
                    status = STATUS_SUCCESS;
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    status = GetExceptionCode();
                }
            } else if( status == STATUS_BUFFER_TOO_SMALL ) {
                //
                // Mapping STATUS_BUFFER_TOO_SMALL to STATUS_SUCCESS seems
                // a bit bizarre. The intent here is to succeed the
                // SPUDCreateFile() call. The fact that *SecDescLengthNeeded
                // is returned with a value larger than SecDescLength is the
                // user-mode code's signal that it should allocate a new
                // buffer & retrieve the security descriptor "out-of-band".
                //

#if DBG
                try {
                    ASSERT( *SecDescLengthNeeded > SecDescLength );
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    NOTHING;
                }
#endif

                status = STATUS_SUCCESS;
            }

            if( !NT_SUCCESS(status) ) {
                NtClose( localFileHandle );
                SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, FALSE );
                return status;
            }

        }

    }

    //
    // If OplockContext == NULL then the caller is not interested in
    // oplocks, so we can just return successfully right now.
    //

    if( OplockContext == NULL ) {
        ASSERT( status == STATUS_SUCCESS );
        SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, FALSE );
        return status;
    }

    //
    // Probe the oplock-specific parameters.
    //

    try {

        //
        // The OplockGranted parameter must be writeable. Set it to
        // FALSE until proven otherwise.
        //

        ProbeAndWriteBoolean( OplockGranted, FALSE );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        NtClose( localFileHandle );
        SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, FALSE );
        return status;
    }

    //
    // If the entity just opened is actually a directory (rather than
    // a "normal" file) then there's no point in trying to acquire the
    // oplock.
    //
    // Note that this check must be after the OplockGranted parameter
    // is probed so that we know it is set to FALSE.
    //

    if( standardInfo.Directory ) {
        ASSERT( status == STATUS_SUCCESS );
        SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, FALSE );
        return status;
    }

    //
    // If the file is smaller than the size specified in the
    // OplockMaxFileSize parameter, then the user doesn't want
    // an oplock.
    //

    if ( standardInfo.EndOfFile.QuadPart > OplockMaxFileSize.QuadPart ) {
        ASSERT( status == STATUS_SUCCESS );
        SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, FALSE );
        return status;
    }


    //
    // See if we can acquire the completion port.
    //

    completionPort = SpudReferenceCompletionPort();

    if( completionPort == NULL ) {
        status = STATUS_INVALID_DEVICE_REQUEST;
        SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, FALSE );
        return status;
    }

    //
    // Reference the file handle
    //

    status = ObReferenceObjectByHandle(
                 localFileHandle,               // Handle
                 0L,                            // DesiredAccess
                 *IoFileObjectType,             // ObjectType
                 UserMode,                      // AccessMode
                 (PVOID *)&fileObject,          // Object
                 NULL                           // HandleInformation
                 );

    if( !NT_SUCCESS(status) ) {
        NtClose( localFileHandle );
        SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, TRUE );
        return status;
    }

    TRACE_OB_REFERENCE( fileObject );

    //
    // Chase down the device object associated with this file object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the IRP.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );

    if( !irp ) {
        TRACE_OB_DEREFERENCE( fileObject );
        ObDereferenceObject( fileObject );
        NtClose( localFileHandle );
        status = STATUS_INSUFFICIENT_RESOURCES;
        SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, TRUE );
        return status;
    }

    irp->RequestorMode = UserMode;
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->FileObject = fileObject;
    irpSp->DeviceObject = deviceObject;

    // irpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
    // irpSp->Parameters.FileSystemControl.InputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.FsControlCode = FSCTL_REQUEST_BATCH_OPLOCK;

    IoSetCompletionRoutine(
        irp,                                    // Irp
        SpudpOplockCompletion,                  // CompletionRoutine
        OplockContext,                          // Context
        TRUE,                                   // InvokeOnSuccess
        TRUE,                                   // InvokeOnError
        TRUE                                    // InvokeOnCancel
        );

    //
    // Issue the IRP to the file system.
    //

    status = IoCallDriver( deviceObject, irp );

    if( NT_SUCCESS(status) ) {
        //
        // The oplock IRP was successfully issued to the file system. We
        // can now assume the IRP will complete later, therefore we will
        // set the user's OplockGranted flag.
        //

        try {
            *OplockGranted = TRUE;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            //
            // Grr...
            //
            // This is a sticky situation. We've already opened the file
            // and successfully acquired the oplock. Closing the file handle
            // here would probably confuse the user-mode code, as it would
            // see the oplock break after an unsuccessful SPUDCreateFile().
            //
            // The only thing we can do here is just drop the failure on the
            // floor. This is not as bad as it seems, as the user-mode code
            // will presumably fault when it tries to access OplockGranted.
            //
        }
    }

    //
    // Regardless of the completion status of the oplock IRP, return
    // STATUS_SUCCESS to the caller. Failure to acquire the oplock is
    // insufficient grounds to fail the SPUDCreateFile() call.
    //

    status = STATUS_SUCCESS;
    SPUD_LEAVE_SERVICE( "SPUDCreateFile", status, FALSE );
    return status;

}   // SPUDCreateFile


//
// Private routines.
//


NTSTATUS
SpudpOplockCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

    Completion routine for oplock IRPs.

Arguments:

    DeviceObject - The device object completing the request (unused).

    Irp - The IRP being completed.

    Context - The context associated with the request. This is actually
        the user's OplockContext passed into SPUDCreateFile().

Return Value:

    NTSTATUS - Completion status.

--*/

{

    PFILE_OBJECT fileObject;

    //
    // Dereference the file object since we're done with it.
    //

    fileObject = Irp->Tail.Overlay.OriginalFileObject;
    TRACE_OB_DEREFERENCE( fileObject );
    ObDereferenceObject( fileObject );

    if( NT_SUCCESS(Irp->IoStatus.Status) ) {

        //
        // Sanity check.
        //

        ASSERT( Irp->IoStatus.Information == SPUD_OPLOCK_BREAK_OPEN ||
                Irp->IoStatus.Information == SPUD_OPLOCK_BREAK_CLOSE );

        //
        // Post the IRP to the completion port. The completion key must be
        // the OplockContext passed into SPUDCreateFile().
        //
        // Note that NULL is used as a distinguished value in UserApcContext.
        // This is an indicator to AtqpProcessContext() that an I/O
        // completion is actually an oplock break.
        //

        Irp->Tail.CompletionKey = Context;
        Irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

        //
        // Hack-O-Rama. This is absolutely required to get the I/O completion
        // port stuff to work. It turns out that the CurrentStackLocation
        // field overlays the PacketType field. Since PacketType must be set
        // to IopCompletionPacketIrp (which just happens to be zero), we'll
        // set CurrentStackLocation to NULL. Ugly. We should really make this
        // part of the kernel. Maybe something like this:
        //
        //     VOID
        //     IoSetIrpCompletion(
        //         IN PVOID IoCompletion,
        //         IN PVOID KeyContext,
        //         IN PVOID ApcContext,
        //         IN PIRP Irp
        //         );
        //
        // We could then replace the following lines (and a few lines above)
        // with:
        //
        //      IoSetIrpCompletion(
        //          SpudCompletionPort,
        //          Context,
        //          NULL,
        //          Irp
        //          );
        //

        Irp->Tail.Overlay.CurrentStackLocation = NULL;

        KeInsertQueue(
            (PKQUEUE)SpudCompletionPort,
            &Irp->Tail.Overlay.ListEntry
            );

    } else {

        //
        // The oplock IRP failed. We'll just drop this IRP on the floor and
        // free it. Since we already notified the caller (through the
        // OplockGranted parameter to SPUDCreateFile) that the oplock could
        // not be acquired, we don't want to notify them again through the
        // completion port.
        //
        // Also note that pending oplock IRPs are not cancelled in the
        // "normal" sense (i.e. with STATUS_CANCELLED) when the file handle
        // is closed. Rather, they are completed *successfully* with the
        // FILE_OPLOCK_BROKEN_TO_NONE (SPUD_OPLOCK_BREAK_CLOSE) completion
        // code. Ergo, cancelled oplock IRPs should never go through this
        // code path.
        //

        IoFreeIrp( Irp );

    }

    //
    // We're done with the completion port. Remove the reference we added
    // in SPUDCreateFile().
    //

    SpudDereferenceCompletionPort();

    //
    // Tell IO to stop processing this IRP. The IRP will be freed in
    // NtRemoveIoCompletion (the kernel-mode worker for the
    // GetQueuedCompletionStatus() API).
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // SpudpOplockCompletion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\miscsvc.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    miscsvc.c

Abstract:

    This module contains miscellaneous SPUD services.

Author:

    Keith Moore (keithmo)       09-Feb-1998

Revision History:

--*/


#include "spudp.h"


//
// Private prototypes.
//

NTSTATUS
SpudpOpenSelfHandle(
    OUT PHANDLE SelfHandle
    );

NTSTATUS
SpudpCloseSelfHandle(
    IN HANDLE SelfHandle
    );

NTSTATUS
SpudpInitCompletionPort(
    IN HANDLE CompletionPort
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SPUDInitialize )
#pragma alloc_text( PAGE, SPUDTerminate )
#pragma alloc_text( PAGE, SPUDCancel )
#pragma alloc_text( PAGE, SPUDGetCounts )
#pragma alloc_text( PAGE, SpudpOpenSelfHandle )
#pragma alloc_text( PAGE, SpudpCloseSelfHandle )
#endif
#if 0
NOT PAGEABLE -- SpudpInitCompletionPort
#endif


//
// Public functions.
//


NTSTATUS
SPUDInitialize(
    ULONG Version,
    HANDLE hPort
    )

/*++

Routine Description:

    Performs per-process SPUD initialization.

Arguments:

    Version - The SPUD interface version the user-mode client is expecting.

    hPort - The handle to the user-mode code's I/O completion port.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;
    HANDLE selfHandle;

    //
    // Sanity check.
    //

    PAGED_CODE();

    status = SPUD_ENTER_SERVICE( "SPUDInitialize", FALSE );

    if( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    selfHandle = NULL;

    //
    // SPUD doesn't support kernel-mode callers. In fact, we don't
    // even build the "system stubs" necessary to invoke SPUD from
    // kernel-mode.
    //

    ASSERT( ExGetPreviousMode() == UserMode );

    //
    // Ensure we got the SPUD interface version number we're expecting.
    //

    if( Version != SPUD_VERSION ) {
        status = STATUS_INVALID_PARAMETER;
    }

    //
    // Open an exclusive handle to ourselves.
    //

    if( NT_SUCCESS(status) ) {
        status = SpudpOpenSelfHandle( &selfHandle );
    }

    //
    // Reference the I/O completion port handle so we can use the
    // pointer directly in KeInsertQueue().
    //

    if( NT_SUCCESS(status) ) {
        status = SpudpInitCompletionPort( hPort );
    }

    //
    // Remember that we're initialized.
    //

    if( NT_SUCCESS(status) ) {
        SpudSelfHandle = selfHandle;
    } else {

        //
        // Fatal error, cleanup our self handle if we managed to
        // open it.
        //

        if( selfHandle != NULL ) {
            SpudpCloseSelfHandle( selfHandle );
        }

    }

    SPUD_LEAVE_SERVICE( "SPUDInitialize", status, FALSE );
    return status;

}   // SPUDInitialize


NTSTATUS
SPUDTerminate(
    VOID
    )

/*++

Routine Description:

    Performs per-process SPUD termination.

Arguments:

    None.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    status = SPUD_ENTER_SERVICE( "SPUDTerminate", TRUE );

    if( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // SPUD doesn't support kernel-mode callers. In fact, we don't
    // even build the "system stubs" necessary to invoke SPUD from
    // kernel-mode.
    //

    ASSERT( ExGetPreviousMode() == UserMode );

    //
    // Close the handle we opened to ourself. The IRP_MJ_CLOSE handler
    // will dereference the completion port and reset the global variables.
    //

    ASSERT( SpudSelfHandle != NULL );
    SpudpCloseSelfHandle( SpudSelfHandle );
    SpudSelfHandle = NULL;

    ASSERT( status == STATUS_SUCCESS );
    SPUD_LEAVE_SERVICE( "SPUDTerminate", status, FALSE );
    return status;

}   // SPUDTerminate


NTSTATUS
SPUDCancel(
    IN PSPUD_REQ_CONTEXT reqContext
    )

/*++

Routine Description:

    Cancels an outstanding XxxAndRecv() request.

Arguments:

    reqContext - The user-mode context associated with the I/O request.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;
    PSPUD_AFD_REQ_CONTEXT SpudReqContext;
    PIRP irp;

    //
    // Sanity check.
    //

    PAGED_CODE();

    status = SPUD_ENTER_SERVICE( "SPUDCancel", TRUE );

    if( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // SPUD doesn't support kernel-mode callers. In fact, we don't
    // even build the "system stubs" necessary to invoke SPUD from
    // kernel-mode.
    //

    ASSERT( ExGetPreviousMode() == UserMode );

    try {

        //
        // Make sure we can write to reqContext
        //

        ProbeForRead(
            reqContext,
            sizeof(SPUD_REQ_CONTEXT),
            sizeof(ULONG)
            );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    //
    // Get the kernel-mode context from the user-mode context.
    //

    if( NT_SUCCESS(status) ) {
        SpudReqContext = SpudGetRequestContext( reqContext );

        if( SpudReqContext == NULL ) {
            status = STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Snag the IRP from the context & cancel the request.
    //

    if( NT_SUCCESS(status) ) {
        irp = SpudReqContext->Irp;
        if (irp) {
            IoCancelIrp(irp);
        }
    }

    SPUD_LEAVE_SERVICE( "SPUDCancel", status, FALSE );
    return status;

}   // SPUDCancel


NTSTATUS
SPUDGetCounts(
    PSPUD_COUNTERS UserCounters
    )

/*++

Routine Description:

    Retrieves the SPUD activity counters.

Arguments:

    UserCounters - Receives the counters.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // N.B. We do not perform the usual driver initialization and
    // exclusivity checks here. We *want* SPUDGetCounts to be callable
    // by processes other than the server.
    //

    //
    // SPUD doesn't support kernel-mode callers. In fact, we don't
    // even build the "system stubs" necessary to invoke SPUD from
    // kernel-mode.
    //

    ASSERT( ExGetPreviousMode() == UserMode );

    try {

        //
        // The SpudCounters parameter must be writable.
        //

        ProbeForWrite( UserCounters, sizeof(*UserCounters), sizeof(ULONG) );

        //
        // Copy the counters to the user-mode buffer.
        //

        RtlCopyMemory(
            UserCounters,
            &SpudCounters,
            sizeof(SpudCounters)
            );

        status = STATUS_SUCCESS;

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = GetExceptionCode();
    }

    return status;

}   // SPUDGetCounts


//
// Private prototypes.
//


NTSTATUS
SpudpOpenSelfHandle(
    OUT PHANDLE SelfHandle
    )

/*++

Routine Description:

    Opens a handle to \Device\Spud and marks it so that it cannot be
    closed.

Arguments:

    SelfHandle - Pointer to a variable that receives the handle.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;
    HANDLE selfHandle;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_HANDLE_FLAG_INFORMATION handleInfo;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Open an exclusive handle to ourselves.
    //

    RtlInitUnicodeString(
        &deviceName,
        SPUD_DEVICE_NAME
        );

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        &deviceName,                            // ObjectName
        OBJ_CASE_INSENSITIVE,                   // Attributes
        NULL,                                   // RootDirectory
        NULL                                    // SecurityDescriptor
        );

    status = IoCreateFile(
                 &selfHandle,                   // FileHandle
                 GENERIC_READ                   // DesiredAccess
                    | SYNCHRONIZE               //
                    | FILE_READ_ATTRIBUTES,     //
                 &objectAttributes,             // ObjectAttributes
                 &ioStatusBlock,                // IoStatusBlock
                 NULL,                          // AllocationSize
                 0L,                            // FileAttributes
                 0L,                            // ShareAccess
                 FILE_OPEN,                     // Disposition
                 0L,                            // CreateOptions
                 NULL,                          // EaBuffer
                 0,                             // EaLength
                 CreateFileTypeNone,            // CreateFileType
                 NULL,                          // ExtraCreateParameters
                 IO_NO_PARAMETER_CHECKING       // Options
                 );

    if( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Mark the handle so that those pesky user-mode applications
    // can't close it. While we're at it, make the handle not
    // inheritable.
    //

    handleInfo.ProtectFromClose = TRUE;
    handleInfo.Inherit = FALSE;

    status = ZwSetInformationObject(
                 selfHandle,                    // Handle
                 ObjectHandleFlagInformation,   // ObjectInformationClass
                 &handleInfo,                   // ObjectInformation
                 sizeof(handleInfo)             // ObjectInformationLength
                 );

    //
    // If all went well, then return the handle to the caller. Otherwise,
    // carefully close the handle (avoiding an exception if the user-mode
    // code has already closed it).
    //

    if( NT_SUCCESS(status) ) {
        *SelfHandle = selfHandle;
    } else {
        if( selfHandle != NULL ) {
            try {
                NtClose( selfHandle );
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                NOTHING;
            }
        }
    }

    return status;

}   // SpudpOpenSelfHandle


NTSTATUS
SpudpCloseSelfHandle(
    IN HANDLE SelfHandle
    )

/*++

Routine Description:

    Closes the handle opened by SpudpOpenSelfHandle().

Arguments:

    SelfHandle - The handle to close.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;
    OBJECT_HANDLE_FLAG_INFORMATION handleInfo;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Mark the handle so that we can close it.
    //

    handleInfo.ProtectFromClose = FALSE;
    handleInfo.Inherit = FALSE;

    status = ZwSetInformationObject(
                 SelfHandle,                    // Handle
                 ObjectHandleFlagInformation,   // ObjectInformationClass
                 &handleInfo,                   // ObjectInformation
                 sizeof(handleInfo)             // ObjectInformationLength
                 );

    //
    // Carefully close the handle, even if the above APIs failed.
    //

    try {
        status = NtClose( SelfHandle );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = GetExceptionCode();
    }

    return status;

}   // SpudpCloseSelfHandle


NTSTATUS
SpudpInitCompletionPort(
    IN HANDLE CompletionPort
    )

/*++

Routine Description:

    References the specified completion port and sets our local reference
    count.

    N.B. This is a separate routine so that SPUDInitialize() can be pageable.

Arguments:

    CompletionPort - The completion port handle.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;
    KIRQL oldIrql;
    PVOID completionPort;

    //
    // Reference the I/O completion port handle so we can use the
    // pointer directly in KeInsertQueue().
    //

    status = ObReferenceObjectByHandle(
                 CompletionPort,                // Handle
                 IO_COMPLETION_MODIFY_STATE,    // DesiredAccess
                 NULL,                          // ObjectType
                 UserMode,                      // AccessMode
                 &completionPort,               // Object
                 NULL                           // HandleInformation
                 );

    //
    // Remember that we're initialized.
    //

    if( NT_SUCCESS(status) ) {
        TRACE_OB_REFERENCE( completionPort );

        KeAcquireSpinLock(
            &SpudCompletionPortLock,
            &oldIrql
            );

        ASSERT( SpudCompletionPort == NULL );
        ASSERT( SpudCompletionPortRefCount == 0 );

        SpudCompletionPort = completionPort;
        SpudCompletionPortRefCount = 1;

        KeReleaseSpinLock(
            &SpudCompletionPortLock,
            oldIrql
            );
    }

    return status;

}   // SpudpInitCompletionPort
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\makefile.inc ===
$(O)\services.tab: ..\services.tab
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\sysstubs.obj: $(O)\sysstubs.$(ASM_SUFFIX)
$(O)\systable.obj: $(O)\systable.$(ASM_SUFFIX)

$(O)\sysstubs.$(ASM_SUFFIX) $(O)\systable.$(ASM_SUFFIX): $(O)\services.tab ..\$(TARGET_DIRECTORY)\table.stb ..\$(TARGET_DIRECTORY)\services.stb
    gensrv -d $(O) -e $(ASM_SUFFIX) -g $(O) $(TARGET_BRACES) -s ..\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\reftrace.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    reftrace.c

Abstract:

    This module implements a reference count tracing facility.

Author:

    Keith Moore (keithmo)       01-May-1997

Revision History:

--*/


#include "spudp.h"


#if 0
NOT PAGEABLE -- CreateRefTraceLog
NOT PAGEABLE -- DestroyRefTraceLog
NOT PAGEABLE -- WriteRefTraceLog
#endif


//
// Public functions.
//


PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )

/*++

Routine Description:

    Creates a new (empty) ref count trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/

{

    return CreateTraceLog(
               LogSize,
               ExtraBytesInHeader,
               sizeof(REF_TRACE_LOG_ENTRY)
               );

}   // CreateRefTraceLog


VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    )

/*++

Routine Description:

    Destroys a ref count trace log buffer created with CreateRefTraceLog().

Arguments:

    Log - The ref count trace log buffer to destroy.

Return Value:

    None.

--*/

{

    DestroyTraceLog( Log );

}   // DestroyRefTraceLog


VOID
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Object,
    IN ULONG Operation,
    IN PSTR FileName,
    IN ULONG LineNumber
    )

/*++

Routine Description:

    Writes a new entry to the specified ref count trace log. The entry
    written contains the object, operation (ref or deref), filename, and
    line number of the caller.

Arguments:

    Log - The log to write to.

    Object - The object being referenced or dereferenced.

    Operation - Usually either +1 (ref) or -1 (deref).

    FileName - The file name of the caller.

    LineNumber - The line number of the caller.

Return Value:

    None.

--*/

{

    REF_TRACE_LOG_ENTRY entry;
    POBJECT_HEADER header;

    //
    // Initialize the entry.
    //

    entry.Object = Object;
    entry.Operation = Operation;
    entry.FileName = FileName;
    entry.LineNumber = LineNumber;

    header = OBJECT_TO_OBJECT_HEADER( Object );

    entry.PointerCount = header->PointerCount;
    entry.HandleCount = header->HandleCount;
    entry.Type = header->Type;
    entry.Header = header;

    //
    // Write it to the log.
    //

    WriteTraceLog(
        Log,
        &entry
        );

}   // WriteRefTraceLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\recv.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    recv.c

Abstract:

    This module contains the Recv code for SPUD.

Author:

    John Ballard (jballard)     21-Oct-1996

Revision History:

    Keith Moore (keithmo)       04-Feb-1998
        Cleanup, added much needed comments.

--*/


#include "spudp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SpudAfdRecvFastReq )
#endif
#if 0
NOT PAGEABLE -- SpudAfdContinueRecv
NOT PAGEABLE -- SpudAfdCompleteRecv
#endif


//
// Public functions.
//

NTSTATUS
SpudAfdRecvFastReq(
    PFILE_OBJECT fileObject,
    PAFD_RECV_INFO recvInfo,
    PSPUD_REQ_CONTEXT reqContext
    )

/*++

Routine Description:

    Attempts a fast-path AFD receive.

Arguments:

    fileObject - The file object for the target socket.

    recvInfo - Information describing the receive.

    reqContext - The user-mode context for the request.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;
    IO_STATUS_BLOCK localIoStatus;
    PSPUD_AFD_REQ_CONTEXT SpudReqContext;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PVOID completionPort;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Let's check to see if fast I/O will work.
    //

    if( SpudAfdFastIoDeviceControl(
            fileObject,
            TRUE,
            (PVOID)recvInfo,
            sizeof(AFD_RECV_INFO),
            NULL,
            0,
            IOCTL_AFD_RECEIVE,
            &localIoStatus,
            SpudAfdDeviceObject
            ) ) {

        //
        // Fast I/O succeeded.
        //

        if( reqContext->ReqType == TransmitFileAndRecv ) {
            BumpCount(CtrTransRecvFastRecv);
        } else {
            BumpCount(CtrSendRecvFastRecv);
        }

        //
        // Remember the completion status for this operation.
        //

        try {
            reqContext->IoStatus2 = localIoStatus;
        } except( EXCEPTION_EXECUTE_HANDLER) {
            localIoStatus.Status = GetExceptionCode();
            localIoStatus.Information = 0;
        }

        return localIoStatus.Status;

    }

    //
    // Fast I/O failed.
    //

    if (reqContext->ReqType == TransmitFileAndRecv) {
        BumpCount(CtrTransRecvSlowRecv);
    } else {
        BumpCount(CtrSendRecvSlowRecv);
    }

    //
    // It looks like we will have to it the hard way.
    // We will now build an IRP for AFD.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Reference the completion port.
    //

    completionPort = SpudReferenceCompletionPort();

    if( completionPort == NULL ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Allocate the IRP.
    //

    irp = IoAllocateIrp( SpudAfdDeviceObject->StackSize, TRUE );

    if (!irp) {
        SpudDereferenceCompletionPort();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Allocate and initialize a kernel-mode context for this request.
    //

    status = SpudAllocateRequestContext(
                 &SpudReqContext,
                 reqContext,
                 recvInfo,
                 irp,
                 &reqContext->IoStatus1
                 );

    if( !NT_SUCCESS(status) ) {
        IoFreeIrp( irp );
        SpudDereferenceCompletionPort();
        return status;
    }

    //
    // Initialize the IRP, call the driver.
    //

    irp->RequestorMode = UserMode;
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    IoQueueThreadIrp( irp );

    irpSp = IoGetNextIrpStackLocation( irp );

    irp->MdlAddress = SpudReqContext->Mdl;
    SpudReqContext->Mdl = NULL;

    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;
    irpSp->DeviceObject = SpudAfdDeviceObject;

    irpSp->Parameters.Read.Length = (ULONG)SpudReqContext->IoStatus2.Information;
    // irpSp->Parameters.Read.Key = 0;
    // irpSp->Parameters.Read.ByteOffset.QuadPart = 0;

    IoSetCompletionRoutine(
        irp,
        SpudAfdCompleteRecv,
        SpudReqContext,
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver( SpudAfdDeviceObject, irp );

    return STATUS_PENDING;

}   // SpudAfdRecvFastReq


NTSTATUS
SpudAfdContinueRecv(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

    Completion handler for IOCTL_AFD_SEND and IOCTL_AFD_TRANSMIT_FILE
    IRPs. This completion handler is responsible for initiating the
    receive part of the XxxAndRecv() API.

Arguments:

    DeviceObject - The device object completing the request (unused).

    Irp - The IRP being completed.

    Context - The context associated with the request. This is actually
        the kernel-mode SPUD_REQ_CONTEXT for this request.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;
    PSPUD_AFD_REQ_CONTEXT SpudReqContext = Context;
    PIO_STACK_LOCATION irpSp;
    PULONG majorFunction;
    PMDL mdl, nextMdl;

    //
    // Snag the completion status.
    //

    SpudReqContext->IoStatus1 = Irp->IoStatus;
    status = Irp->IoStatus.Status;

    //
    // Cleanup the IRP.
    //

    if( Irp->MdlAddress != NULL ) {
        for( mdl = Irp->MdlAddress ; mdl != NULL ; mdl = nextMdl ) {
            nextMdl = mdl->Next;
            MmUnlockPages( mdl );
            IoFreeMdl( mdl );
        }

        Irp->MdlAddress = NULL;
    }

    //
    // If the initial operation failed, then complete the request now
    // without issuing the receive.
    //

    if( !NT_SUCCESS(status) ) {
        SpudReqContext->IoStatus2.Status = 0;
        SpudReqContext->IoStatus2.Information = 0;

        SpudCompleteRequest( SpudReqContext );
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // Reinitialize the IRP and initiate the receive operation.
    //

    Irp->MdlAddress = SpudReqContext->Mdl;
    SpudReqContext->Mdl = NULL;

    irpSp = IoGetNextIrpStackLocation( Irp );

    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->MinorFunction = 0;
    irpSp->FileObject = Irp->Tail.Overlay.OriginalFileObject;
    irpSp->DeviceObject = SpudAfdDeviceObject;

    irpSp->Parameters.Read.Length = (ULONG)SpudReqContext->IoStatus2.Information;
    irpSp->Parameters.Read.Key = 0;
    irpSp->Parameters.Read.ByteOffset.QuadPart = 0;

    IoSetCompletionRoutine(
        Irp,
        SpudAfdCompleteRecv,
        SpudReqContext,
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver( SpudAfdDeviceObject, Irp );

    //
    // Tell IO to stop processing this IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // SpudAfdContinueRecv


NTSTATUS
SpudAfdCompleteRecv(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

    Completion routine for receive IRPs issued as part of an XxxAndRecv().

Arguments:

    DeviceObject - The device object completing the request (unused).

    Irp - The IRP being completed.

    Context - The context associated with the request. This is actually
        the kernel-mode SPUD_REQ_CONTEXT for this request.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;
    PSPUD_AFD_REQ_CONTEXT SpudReqContext = Context;
    PMDL mdl, nextMdl;

    //
    // Snag the completion status.
    //

    SpudReqContext->IoStatus2 = Irp->IoStatus;
    status = Irp->IoStatus.Status;

    //
    // Cleanup the IRP.
    //

    if( Irp->MdlAddress != NULL ) {
        for( mdl = Irp->MdlAddress ; mdl != NULL ; mdl = nextMdl ) {
            nextMdl = mdl->Next;
            MmUnlockPages( mdl );
            IoFreeMdl( mdl );
        }

        Irp->MdlAddress = NULL;
    }

    //
    // Complete the original request.
    //

    SpudCompleteRequest( SpudReqContext );

    //
    // Tell IO to stop processing this IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // SpudAfdCompleteRecv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=spud

TARGETNAME=spud
TARGETTYPE=DRIVER

# ..\spud relies on services.tab during PASS0
SYNCHRONIZE_BLOCK=1

INCLUDES=..;$(IISBASEDIR)\inc;$(BASE_INC_PATH);$(NET_INC_PATH)

C_DEFINES=$(C_DEFINES) -DNT -D_NTDRIVER_

SOURCES=                \
        ..\complete.c   \
        ..\context.c    \
        ..\dispatch.c   \
        ..\init.c       \
        ..\misc.c       \
        ..\miscsvc.c    \
        ..\oplock.c     \
        ..\recv.c       \
        ..\reftrace.c   \
        ..\sendrecv.c   \
        ..\spuddata.c   \
        ..\tracelog.c   \
        ..\tranrecv.c   \
        ..\spud.rc      \

UMRES= $(O)\spud.res

!IF "$(NTNOPCH)" == ""
PRECOMPILED_INCLUDE=..\spudp.h
PRECOMPILED_PCH=spudp.pch
PRECOMPILED_OBJ=spudp.obj
!ENDIF

NTTARGETFILE0=$(O)\services.tab

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\reftrace.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    reftrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging reference count problems. This module uses the generic
    TRACE_LOG facility in tracelog.h.

    Ref count trace logs can be dumped via the !inetdbg.ref command
    in either NTSD or CDB.

Author:

    Keith Moore (keithmo)       01-May-1997

Revision History:

--*/


#ifndef _REFTRACE_H_
#define _REFTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


#include <tracelog.h>


//
// This defines the entry written to the trace log.
//

typedef struct _REF_TRACE_LOG_ENTRY {

    PVOID Object;
    ULONG Operation;
    PSTR FileName;
    ULONG LineNumber;

    //
    // Stuff from the OBJECT_HEADER.
    //

    LONG PointerCount;
    LONG HandleCount;
    POBJECT_TYPE Type;
    PVOID Header;

} REF_TRACE_LOG_ENTRY, *PREF_TRACE_LOG_ENTRY;


//
// Manipulators.
//

PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    );

VOID
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Object,
    IN ULONG Operation,
    IN PSTR FileName,
    IN ULONG LineNumber
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _REFTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\spuddata.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    spuddata.h

Abstract:

    This module declares global data for SPUD.

Author:

    John Ballard (jballard)     21-Oct-1996

Revision History:

--*/


#ifndef _SPUDDATA_H_
#define _SPUDDATA_H_


extern SPUD_COUNTERS SpudCounters;
extern PSPUD_NONPAGED_DATA SpudNonpagedData;

extern PVOID SpudCompletionPort;
extern ULONG SpudCompletionPortRefCount;
extern KSPIN_LOCK SpudCompletionPortLock;

extern PEPROCESS SpudOwningProcess;
extern PDEVICE_OBJECT SpudSelfDeviceObject;
extern HANDLE SpudSelfHandle;

extern PDEVICE_OBJECT SpudAfdDeviceObject;
extern PFAST_IO_DEVICE_CONTROL SpudAfdFastIoDeviceControl;

#if DBG
extern BOOLEAN SpudUsePrivateAssert;
#endif

#if ENABLE_OB_TRACING
extern struct _TRACE_LOG *SpudTraceLog;
#endif


//
// The following three globals are defined in the assembly-language code
// generated by gensrv.exe. For example, the x86 version is built into
// daytona\i386\systable.asm.
//

extern ULONG_PTR SpudServiceTable[];
extern ULONG SpudServiceLimit;
extern UCHAR SpudArgumentTable[];


#endif  // _SPUDDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\sendrecv.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sendrecv.c

Abstract:

    This module contains the SPUDSendAndRecv service.

Author:

    John Ballard (jballard)     21-Oct-1996

Revision History:

    Keith Moore (keithmo)       04-Feb-1998
        Cleanup, added much needed comments.

--*/


#include "spudp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SPUDSendAndRecv )
#endif


//
// Public functions.
//


NTSTATUS
SPUDSendAndRecv(
    HANDLE hSocket,
    struct _AFD_SEND_INFO *sendInfo,
    struct _AFD_RECV_INFO *recvInfo,
    PSPUD_REQ_CONTEXT reqContext
    )

/*++

Routine Description:

    Batch send & receive request.

Arguments:

    hSocket - The target socket for the request.

    sendInfo - Information describing the send.

    recvInfo - Information describing the receive.

    reqContext - The user-mode context for the request.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;
    PFILE_OBJECT fileObject;
    IO_STATUS_BLOCK localIoStatus;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PSPUD_AFD_REQ_CONTEXT SpudReqContext;
    PVOID completionPort;

    //
    // Sanity check.
    //

    PAGED_CODE();

    status = SPUD_ENTER_SERVICE( "SPUDSendAndRecv", TRUE );

    if( !NT_SUCCESS(status) ) {
        return status;
    }

    BumpCount( CtrSendAndRecv );

    //
    // SPUD doesn't support kernel-mode callers. In fact, we don't
    // even build the "system stubs" necessary to invoke SPUD from
    // kernel-mode.
    //

    ASSERT( ExGetPreviousMode() == UserMode );

    try {

        //
        // Make sure we can write to reqContext
        //

        ProbeForWrite(
            reqContext,
            sizeof(SPUD_REQ_CONTEXT),
            sizeof(ULONG)
            );

        //
        // Make initial status invalid
        //

        reqContext->IoStatus1.Status = 0xffffffff;
        reqContext->IoStatus1.Information = 0;
        reqContext->IoStatus2.Status = 0xffffffff;
        reqContext->IoStatus2.Information = 0;
        reqContext->ReqType = SendAndRecv;
        reqContext->KernelReqInfo = SPUD_INVALID_REQ_HANDLE;

        //
        // Make sure the buffer looks good
        //

        ProbeForRead(
            recvInfo,
            sizeof(*recvInfo),
            sizeof(ULONG)
            );

        if( recvInfo->BufferCount < 1 ) {
            ExRaiseStatus( STATUS_INVALID_PARAMETER );
        }

        ProbeForRead(
            recvInfo->BufferArray,
            sizeof(*recvInfo->BufferArray),
            sizeof(ULONG)
            );

        ProbeForRead(
            recvInfo->BufferArray->buf,
            recvInfo->BufferArray->len,
            sizeof(UCHAR)
            );

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = GetExceptionCode();
        SPUD_LEAVE_SERVICE( "SPUDSendAndRecv", status, FALSE );
        return status;
    }

    //
    // Reference the socket handle
    //

    status = ObReferenceObjectByHandle(
                 hSocket,
                 0L,
                 *IoFileObjectType,
                 UserMode,
                 (PVOID *)&fileObject,
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        SPUD_LEAVE_SERVICE( "SPUDSendAndRecv", status, FALSE );
        return status;
    }

    TRACE_OB_REFERENCE( fileObject );

    //
    // If we haven't already cached the Device Object and FastIoControl
    // pointers, then do so now.
    //

    if( !SpudAfdDeviceObject ) {

        status = SpudGetAfdDeviceObject( fileObject );

        if( !NT_SUCCESS(status) ) {
            TRACE_OB_DEREFERENCE( fileObject );
            ObDereferenceObject( fileObject );
            status = STATUS_INVALID_DEVICE_REQUEST;
            SPUD_LEAVE_SERVICE( "SPUDSendAndRecv", status, FALSE );
            return status;
        }

    }

    //
    // Reference the completion port.
    //

    completionPort = SpudReferenceCompletionPort();

    if( completionPort == NULL ) {
        TRACE_OB_DEREFERENCE( fileObject );
        ObDereferenceObject( fileObject );
        status = STATUS_INVALID_DEVICE_REQUEST;
        SPUD_LEAVE_SERVICE( "SPUDSendAndRecv", status, FALSE );
        return status;
    }

    //
    // Let's check to see if fast io will work
    //

    if( SpudAfdFastIoDeviceControl(
            fileObject,
            TRUE,
            (PVOID)sendInfo,
            sizeof(AFD_SEND_INFO),
            NULL,
            0,
            IOCTL_AFD_SEND,
            &localIoStatus,
            SpudAfdDeviceObject
            )) {

        BumpCount( CtrSendRecvFastSend );

        //
        // Lets remember the completion status for this operation
        //

        try {
            reqContext->IoStatus1 = localIoStatus;
        } except( EXCEPTION_EXECUTE_HANDLER) {
            localIoStatus.Status = GetExceptionCode();
            localIoStatus.Information = 0;
        }

        if( localIoStatus.Status == STATUS_SUCCESS ) {
            localIoStatus.Status = SpudAfdRecvFastReq(
                                       fileObject,
                                       recvInfo,
                                       reqContext
                                       );
        }

        //
        // If everything completed without pending then we can queue
        // a completion packet to the port now.
        //
        // Note that we must not queue a completion packet if the
        // request is failing in-line.
        //

        if( localIoStatus.Status != STATUS_PENDING ) {

            if( NT_SUCCESS(localIoStatus.Status) ) {
                localIoStatus.Status = IoSetIoCompletion(
                                           SpudCompletionPort,  // IoCompletion
                                           reqContext,          // KeyContext
                                           NULL,                // ApcContext
                                           STATUS_SUCCESS,      // IoStatus
                                           0xFFFFFFFF,          // IoStatusInformation
                                           TRUE                 // Quota
                                           );
            }

            TRACE_OB_DEREFERENCE( fileObject );
            ObDereferenceObject( fileObject );

        }

        //
        // At this point, we know the fast-path send has completed
        // in-line and the receive either completed in-line or has pended.
        // Since it is the receive code's responsibility to add any necessary
        // references to the completion port (and since we know the send
        // has not pended) we can remove the reference we added above.
        //

        SPUD_LEAVE_SERVICE( "SPUDSendAndRecv", localIoStatus.Status, TRUE );
        return localIoStatus.Status;

    }

    BumpCount( CtrSendRecvSlowSend );

    //
    // It looks like we will have to it the hard way.
    // We will now build an IRP for AFD.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the IRP.
    //

    irp = IoAllocateIrp( SpudAfdDeviceObject->StackSize, TRUE );

    if( !irp ) {
        TRACE_OB_DEREFERENCE( fileObject );
        ObDereferenceObject( fileObject );
        status = STATUS_INSUFFICIENT_RESOURCES;
        SPUD_LEAVE_SERVICE( "SPUDSendAndRecv", status, TRUE );
        return status;
    }

    status = SpudAllocateRequestContext(
                 &SpudReqContext,
                 reqContext,
                 recvInfo,
                 irp,
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        TRACE_OB_DEREFERENCE( fileObject );
        ObDereferenceObject( fileObject );
        IoFreeIrp( irp );
        SPUD_LEAVE_SERVICE( "SPUDSendAndRecv", status, TRUE );
        return status;
    }

    BumpCount( CtrSendRecvSlowRecv );

    irp->RequestorMode = UserMode;
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    IoQueueThreadIrp( irp );

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->FileObject = fileObject;
    irpSp->DeviceObject = SpudAfdDeviceObject;

    // irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(AFD_SEND_INFO);
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_AFD_SEND;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = sendInfo;

    IoSetCompletionRoutine(
        irp,
        SpudAfdContinueRecv,
        SpudReqContext,
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver( SpudAfdDeviceObject, irp );

    status = STATUS_PENDING;
    SPUD_LEAVE_SERVICE( "SPUDSendAndRecv", status, FALSE );
    return status;

}   // SPUDSendAndRecv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\spuddata.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    spuddata.c

Abstract:

    This module contains global data for SPUD.

Author:

    John Ballard (jballard)     21-Oct-1996

Revision History:

    Keith Moore (keithmo)       04-Feb-1998
        Cleanup, added much needed comments.

--*/


#include "spudp.h"


//
// Public globals.
//

SPUD_COUNTERS SpudCounters;
PSPUD_NONPAGED_DATA SpudNonpagedData;

PVOID SpudCompletionPort;
ULONG SpudCompletionPortRefCount;
KSPIN_LOCK SpudCompletionPortLock;

PEPROCESS SpudOwningProcess;
PDEVICE_OBJECT SpudSelfDeviceObject;
HANDLE SpudSelfHandle;

PDEVICE_OBJECT SpudAfdDeviceObject;
PFAST_IO_DEVICE_CONTROL SpudAfdFastIoDeviceControl;

#if DBG
BOOLEAN SpudUsePrivateAssert;
#endif

#if ENABLE_OB_TRACING
struct _TRACE_LOG *SpudTraceLog;
#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, SpudInitializeData )
#endif


//
// Public functions.
//


NTSTATUS
SpudInitializeData (
    VOID
    )

/*++

Routine Description:

    Performs one-time global SPUD initialization.

Arguments:

    None.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // We don't allow SPUD on NTW systems.
    //

    if( !MmIsThisAnNtAsSystem() ) {
        return FALSE;
    }

    //
    // Initialize the spinlock that protects the completion port.
    //

    KeInitializeSpinLock(
        &SpudCompletionPortLock
        );

    //
    // Allocate the structure that's to contain all of our non-paged
    // data.
    //

    SpudNonpagedData = ExAllocatePoolWithTag(
                           NonPagedPool,
                           sizeof(*SpudNonpagedData),
                           SPUD_NONPAGED_DATA_POOL_TAG
                           );

    if( SpudNonpagedData == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize it.
    //

    ExInitializeNPagedLookasideList(
        &SpudNonpagedData->ReqContextList,
        NULL,
        NULL,
        NonPagedPool,
        sizeof( SPUD_AFD_REQ_CONTEXT ),
        SPUD_REQ_CONTEXT_POOL_TAG,
        12
        );

    ExInitializeResourceLite(
        &SpudNonpagedData->ReqHandleTableLock
        );

#if ENABLE_OB_TRACING
    SpudTraceLog = CreateRefTraceLog( 4096, 0 );
#endif

    RtlZeroMemory(
        &SpudCounters,
        sizeof(SpudCounters)
        );

    return STATUS_SUCCESS;

}   // SpudInitializeData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\spudproc.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    spudproc.h

Abstract:

    This module contains routine prototypes for SPUD.

Author:

    John Ballard (jballard)     21-Oct-1996

Revision History:

--*/


#ifndef _SPUDPROCS_H_
#define _SPUDPROCS_H_


//
// Driver entrypoint.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


//
// Initialization routines.
//

NTSTATUS
SpudInitializeData(
    VOID
    );


//
// IRP handlers.
//

NTSTATUS
SpudIrpCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpudIrpClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpudIrpCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpudIrpQuery(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


//
// Completion port safety.
//

PVOID
SpudReferenceCompletionPort(
    VOID
    );

VOID
SpudDereferenceCompletionPort(
    VOID
    );


//
// XxxAndRecv routines.
//

NTSTATUS
SpudAfdRecvFastReq(
    PFILE_OBJECT fileObject,
    PAFD_RECV_INFO recvInfo,
    PSPUD_REQ_CONTEXT reqContext
    );

NTSTATUS
SpudAfdContinueRecv(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

NTSTATUS
SpudAfdCompleteRecv(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

VOID
SpudCompleteRequest(
    PSPUD_AFD_REQ_CONTEXT SpudReqContext
    );

NTSTATUS
SpudInitializeContextManager(
    VOID
    );

VOID
SpudTerminateContextManager(
    VOID
    );

NTSTATUS
SpudAllocateRequestContext(
    OUT PSPUD_AFD_REQ_CONTEXT *SpudReqContext,
    IN PSPUD_REQ_CONTEXT ReqContext,
    IN PAFD_RECV_INFO RecvInfo OPTIONAL,
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );

VOID
SpudFreeRequestContext(
    IN PSPUD_AFD_REQ_CONTEXT SpudReqContext
    );

PSPUD_AFD_REQ_CONTEXT
SpudGetRequestContext(
    IN PSPUD_REQ_CONTEXT ReqContext
    );


//
// Service entry/exit routines.
//

NTSTATUS
SpudEnterService(
#if DBG
    IN PSTR ServiceName,
#endif
    IN BOOLEAN InitRequired
    );

VOID
SpudLeaveService(
#if DBG
    IN PSTR ServiceName,
    IN NTSTATUS Status,
#endif
    IN BOOLEAN DerefRequired
    );

#if DBG
#define SPUD_ENTER_SERVICE( name, init )                                    \
    SpudEnterService( (PSTR)(name), (BOOLEAN)(init) )
#define SPUD_LEAVE_SERVICE( name, status, deref )                           \
    SpudLeaveService( (PSTR)(name), (NTSTATUS)(status), (BOOLEAN)(deref) )
#else
#define SPUD_ENTER_SERVICE( name, init )                                    \
    SpudEnterService( (BOOLEAN)(init) )
#define SPUD_LEAVE_SERVICE( name, status, deref )                           \
    SpudLeaveService( (BOOLEAN)(deref) )
#endif


//
// Miscellaneous helper routines.
//

NTSTATUS
SpudGetAfdDeviceObject(
    IN PFILE_OBJECT AfdFileObject
    );


//
// Macros stolen from NTOS\IO\IOP.H.
//

//+
//
// VOID
// IopDequeueThreadIrp(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine dequeues the specified I/O Request Packet (IRP) from the
//     thread IRP queue which it is currently queued.
//
// Arguments:
//
//     Irp - Specifies the IRP that is dequeued.
//
// Return Value:
//
//     None.
//
//-

#define IopDequeueThreadIrp( Irp ) { RemoveEntryList( &Irp->ThreadListEntry ); }

//+
// VOID
// IopQueueThreadIrp(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine queues the specified I/O Request Packet (IRP) to the thread
//     whose TCB address is stored in the packet.
//
// Arguments:
//
//     Irp - Supplies the IRP to be queued for the specified thread.
//
// Return Value:
//
//     None.
//
//-

#define IopQueueThreadIrp( Irp ) {                      \
    KIRQL irql;                                         \
    KeRaiseIrql( APC_LEVEL, &irql );                    \
    InsertHeadList( &Irp->Tail.Overlay.Thread->IrpList, \
                    &Irp->ThreadListEntry );            \
    KeLowerIrql( irql );                                \
    }


#endif  // _SPUDPROCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Oct-22-1996 JBallard Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\spudp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    spudp.h

Abstract:

    This is the local header file for SPUD. It includes all other
    necessary header files for SPUD.

Author:

    John Ballard (jballard)     21-Oct-1996

Revision History:

--*/


#ifndef _SPUDP_H_
#define _SPUDP_H_


//
// N.B. ntos\inc\init.h and ntos\inc\ke.h declare NtBuildNumber and
// KeServiceDescriptorTable without the additional level of indirection
// necessary to access them through an export thunk. To get around this,
// we'll #define them to goofy values, include the header files, then
// undef them before declaring them properly.
//

#include <ntosp.h>
#include <zwapi.h>
#include <tdikrnl.h>

//
// Our device name.
//

#define SPUD_DEVICE_NAME L"\\Device\\Spud"


//
// Priority boost for completed I/O requests.
//

#define SPUD_PRIORITY_BOOST 2


//
// Set ENABLE_OB_TRACING to enable OB reference count tracing.
//
// Set ALLOW_UNLOAD to allow the driver to be conditionally unloaded.
//
// Set USE_SPUD_COUNTERS to enable SPUD activity counters.
//

#if DBG
#define ENABLE_OB_TRACING   1
#define ALLOW_UNLOAD        0
#define USE_SPUD_COUNTERS   1
#else
#define ENABLE_OB_TRACING   0
#define ALLOW_UNLOAD        0
#define USE_SPUD_COUNTERS   1
#endif


//
// Pool tags.
//

#define SPUD_NONPAGED_DATA_POOL_TAG     'NupS'
#define SPUD_HANDLE_TABLE_POOL_TAG      'HupS'
#define SPUD_TRACE_LOG_POOL_TAG         'TupS'
#define SPUD_REQ_CONTEXT_POOL_TAG       'RupS'


typedef struct _TRANSMIT_FILE_BUFFERS {
    PVOID Head;
    ULONG HeadLength;
    PVOID Tail;
    ULONG TailLength;
} TRANSMIT_FILE_BUFFERS, *PTRANSMIT_FILE_BUFFERS, *LPTRANSMIT_FILE_BUFFERS;


//
// Goodies stolen from WINSOCK2.H (to make AFD.H happy).
//

#ifndef SG_UNCONSTRAINED_GROUP
#define SG_UNCONSTRAINED_GROUP   0x01
#endif

#ifndef SG_CONSTRAINED_GROUP
#define SG_CONSTRAINED_GROUP     0x02
#endif

#include <afd.h>
#include <uspud.h>
#include "spudstr.h"
#include "spudproc.h"
#include "spuddata.h"
#include "reftrace.h"


//
// Pool allocators.
//

#define SPUD_ALLOCATE_POOL(a,b,t)    ExAllocatePoolWithTag(a,b,t)
#define SPUD_FREE_POOL(a)            ExFreePool(a)


//
// Debug-specific stuff.
//

#if DBG

//
// Define our own assert so that we can actually catch assertion failures
// when running a checked SPUD on a free kernel.
//

VOID
SpudAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        SpudAssert( #exp, __FILE__, __LINE__, NULL )

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        SpudAssert( #exp, __FILE__, __LINE__, msg )

#endif  // DBG


//
// OB reference tracing stuff.
//

#if ENABLE_OB_TRACING

#define TRACE_OB_REFERENCE( obj )                                           \
    if( SpudTraceLog != NULL ) {                                            \
        WriteRefTraceLog(                                                   \
            SpudTraceLog,                                                   \
            (PVOID)(obj),                                                   \
            +1,                                                             \
            __FILE__,                                                       \
            __LINE__                                                        \
            );                                                              \
    } else

#define TRACE_OB_DEREFERENCE( obj )                                         \
    if( SpudTraceLog != NULL ) {                                            \
        WriteRefTraceLog(                                                   \
            SpudTraceLog,                                                   \
            (PVOID)(obj),                                                   \
            -1,                                                             \
            __FILE__,                                                       \
            __LINE__                                                        \
            );                                                              \
    } else

#else   // !ENABLE_OB_TRACING

#define TRACE_OB_REFERENCE( obj )
#define TRACE_OB_DEREFERENCE( obj )

#endif  // ENABLE_OB_TRACING


//
// Activity counters.
//

#if USE_SPUD_COUNTERS

#define BumpCount(c) InterlockedIncrement( &SpudCounters.c )

#else   // !USE_SPUD_COUNTERS

#define BumpCount(c) ((void)0)

#endif  // USE_SPUD_COUNTERS


#endif  // _SPUDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\spudstr.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    spudstr.h

Abstract:

    This header file contains all of the private structure definitions
    for SPUD.

Author:

    John Ballard (jballard)     21-Oct-1996

Revision History:

--*/


#ifndef _SPUDSTR_H_
#define _SPUDSTR_H_


//
// A kernel-mode request context.
//

typedef struct _SPUD_AFD_REQ_CONTEXT {
    ULONG Signature;
    PIRP Irp;
    PMDL Mdl;
    IO_STATUS_BLOCK IoStatus1;
    IO_STATUS_BLOCK IoStatus2;
    PVOID AtqContext;
    PVOID ReqHandle;
} SPUD_AFD_REQ_CONTEXT, *PSPUD_AFD_REQ_CONTEXT;

//
// Signatures for the above structure.
//

#define SPUD_REQ_CONTEXT_SIGNATURE      ((ULONG)'XCPS')
#define SPUD_REQ_CONTEXT_SIGNATURE_X    ((ULONG)'xcps')

//
// An invalid request handle.
//

#define SPUD_INVALID_REQ_HANDLE         NULL


//
// Everything that must always be nonpaged (even if we decide to page
// the entire driver out) is kept in the following structure.
//

typedef struct _SPUD_NONPAGED_DATA {
    NPAGED_LOOKASIDE_LIST ReqContextList;
    ERESOURCE ReqHandleTableLock;
} SPUD_NONPAGED_DATA, *PSPUD_NONPAGED_DATA;


#endif  // _SPUDSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\tracelog.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    This module implements a trace log.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

Author:

    Keith Moore (keithmo)       30-Apr-1997

Revision History:

--*/


#include "spudp.h"


//
// Private contants.
//

#define ALLOC_MEM(cb)                                                       \
    SPUD_ALLOCATE_POOL(                                                     \
        NonPagedPool,                                                       \
        (ULONG)(cb),                                                        \
        SPUD_TRACE_LOG_POOL_TAG                                             \
        )

#define FREE_MEM(ptr)                                                       \
    SPUD_FREE_POOL(                                                         \
        (PVOID)(ptr)                                                        \
        )

#define DBG_ASSERT ASSERT


#if 0
NOT PAGEABLE -- CreateTraceLog
NOT PAGEABLE -- DestroyTraceLog
NOT PAGEABLE -- WriteTraceLog
NOT PAGEABLE -- ResetTraceLog
#endif


//
// Public functions.
//


PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    )

/*++

Routine Description:

    Creates a new (empty) trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

    EntrySize - The size (in bytes) of each entry.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/

{

    LONG totalSize;
    PTRACE_LOG log;

    //
    // Sanity check the parameters.
    //

    DBG_ASSERT( LogSize > 0 );
    DBG_ASSERT( EntrySize > 0 );
    DBG_ASSERT( ( EntrySize & 3 ) == 0 );

    //
    // Allocate & initialize the log structure.
    //

    totalSize = sizeof(*log) + ( LogSize * EntrySize ) + ExtraBytesInHeader;
    DBG_ASSERT( totalSize > 0 );

    log = (PTRACE_LOG)ALLOC_MEM( totalSize );

    //
    // Initialize it.
    //

    if( log != NULL ) {

        RtlZeroMemory( log, totalSize );

        log->Signature = TRACE_LOG_SIGNATURE;
        log->LogSize = LogSize;
        log->NextEntry = -1;
        log->EntrySize = EntrySize;
        log->LogBuffer = (PUCHAR)( log + 1 ) + ExtraBytesInHeader;
    }

    return log;

}   // CreateTraceLog


VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    )

/*++

Routine Description:

    Destroys a trace log buffer created with CreateTraceLog().

Arguments:

    Log - The trace log buffer to destroy.

Return Value:

    None.

--*/

{

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

    Log->Signature = TRACE_LOG_SIGNATURE_X;
    FREE_MEM( Log );

}   // DestroyTraceLog


VOID
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    )

/*++

Routine Description:

    Writes a new entry to the specified trace log.

Arguments:

    Log - The log to write to.

    Entry - Pointer to the data to write. This buffer is assumed to be
        Log->EntrySize bytes long.

Return Value:

    None

--*/

{

    PUCHAR target;
    LONG index;

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );
    DBG_ASSERT( Entry != NULL );

    //
    // Find the next slot, copy the entry to the slot.
    //

    index = InterlockedIncrement( &Log->NextEntry ) % Log->LogSize;
    target = Log->LogBuffer + ( index * Log->EntrySize );

    RtlCopyMemory(
        target,
        Entry,
        Log->EntrySize
        );

}   // WriteTraceLog


VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    )

/*++

Routine Description:

    Resets the specified trace log.

Arguments:

    Log - The log to reset.

Return Value:

    None

--*/

{

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

    RtlZeroMemory(
        ( Log + 1 ),
        Log->LogSize * Log->EntrySize
        );

    Log->NextEntry = -1;

}   // ResetTraceLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\tracelog.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)       30-Apr-1997

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


typedef struct _TRACE_LOG {

    //
    // Signature.
    //

    LONG Signature;

    //
    // The total number of entries available in the log.
    //

    LONG LogSize;

    //
    // The index of the next entry to use.
    //

    LONG NextEntry;

    //
    // The byte size of each entry.
    //

    LONG EntrySize;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR LogBuffer;

    //
    // Filler to keep the log entries aligned on a 16-byte boundary.
    // (Makes it much easier to interpret the log from within a debugger.)
    //

    LONG Filler[3];

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

} TRACE_LOG, *PTRACE_LOG;


//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   ((ULONG)'gOlT')
#define TRACE_LOG_SIGNATURE_X ((ULONG)'golX')


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    );

VOID
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\irptrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    irptrace.c

Abstract:

    This module implements an IRP tracing facility.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/


#include "spudp.h"


#if IRP_DEBUG



PTRACE_LOG
CreateIrpTraceLog(
    IN LONG LogSize
    )
/*++

Routine Description:

    Creates a new (empty) ref count trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    return CreateTraceLog(
               LogSize,
               0,
               sizeof(IRP_TRACE_LOG_ENTRY)
               );

}   // CreateIrpTraceLog


VOID
DestroyIrpTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a ref count trace log buffer created with CreateIrpTraceLog().

Arguments:

    Log - The ref count trace log buffer to destroy.

Return Value:

    None.

--*/
{

    DestroyTraceLog( Log );

}   // DestroyIrpTraceLog


VOID
WriteIrpTraceLog(
    IN PTRACE_LOG Log,
    IN PIRP Irp,
    IN ULONG Operation,
    IN PVOID Context
    )
/*++

Routine Description:

    Writes a new entry to the specified ref count trace log.

Arguments:

    Log - The log to write to.

    Irp - The IRP to log.

    Operation - The operation performed on the IRP.

    Context - An uninterpreted context.

Return Value:

    None

--*/
{

    IRP_TRACE_LOG_ENTRY entry;

    //
    // Initialize the entry.
    //

    entry.Irp = Irp;
    entry.Operation = Operation;
    entry.Thread = PsGetCurrentThread();
    entry.Context = Context;

    //
    // Write it to the log.
    //

    WriteTraceLog(
        Log,
        &entry
        );

}   // WriteIrpTraceLog


#endif  // IRP_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\complete.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    complete.c

Abstract:

    This module contains the Completion handling code for SPUD.

Author:

    John Ballard (jballard)    11-Nov-1996

Revision History:

--*/

#include "spudp.h"

VOID
SpudpCompleteRequest(
    IN PKAPC    Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID    *NormalContext,
    IN PVOID    *SystemArgument1,
    IN PVOID    *SystemArgument2
    )
{
    PSPUD_AFD_REQ_CONTEXT    SpudReqContext;
    PSPUD_REQ_CONTEXT        reqContext;
    PIO_MINI_COMPLETION_PACKET miniPacket = NULL;
    PIRP                    irp;
    KIRQL                   oldirql;
    PFILE_OBJECT            fileObject;

    UNREFERENCED_PARAMETER( NormalRoutine );
    UNREFERENCED_PARAMETER( NormalContext );

    irp = CONTAINING_RECORD( Apc, IRP, Tail.Apc );
    SpudReqContext = *SystemArgument1;
    fileObject = *SystemArgument2;
    reqContext = SpudReqContext->AtqContext;

    ObDereferenceObject( fileObject );

#if STATUS_SUPPORTED
    KeAcquireSpinLock( &SpudReqContext->Lock, &oldirql );
#endif
    reqContext->IoStatus1 = SpudReqContext->IoStatus1;
    reqContext->IoStatus2 = SpudReqContext->IoStatus2;
    SpudReqContext->Signature = 0;
    SpudReqContext->Irp = NULL;
#if STATUS_SUPPORTED
    KeReleaseSpinLock( &SpudReqContext->Lock, oldirql );
#endif

    reqContext->KernelReqInfo = NULL;
    ExFreeToNPagedLookasideList( &SpudLookasideLists->ReqContextList,
                                 SpudReqContext );

    irp->Tail.CompletionKey = (ULONG)reqContext;
    irp->Tail.Overlay.CurrentStackLocation = NULL;
    irp->IoStatus.Status = 0;
    irp->IoStatus.Information = 0xffffffff;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    KeInsertQueue( (PKQUEUE) ATQIoCompletionPort,
                        &irp->Tail.Overlay.ListEntry );

    return;
}


NTSTATUS
SpudCompleteRequest(
    PSPUD_AFD_REQ_CONTEXT  SpudReqContext
    )
{
    PIRP     irp;
    PETHREAD thread;
    PFILE_OBJECT fileObject;

    irp = SpudReqContext->Irp;
    irp->MdlAddress = NULL;

    thread = irp->Tail.Overlay.Thread;
    fileObject = irp->Tail.Overlay.OriginalFileObject;
    KeInitializeApc( &irp->Tail.Apc,
                     &thread->Tcb,
                     irp->ApcEnvironment,
                     SpudpCompleteRequest,
                     NULL,
                     NULL,
                     KernelMode,
                     NULL );

    KeInsertQueueApc( &irp->Tail.Apc, SpudReqContext, fileObject, 0 );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\irptrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    irptrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging IRP problems. This module uses the generic TRACE_LOG
    facility in tracelog.h.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/


#ifndef _IRPTRACE_H_
#define _IRPTRACE_H_


#if IRP_DEBUG


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


#include <tracelog.h>


//
// This defines the entry written to the trace log.
//

#define IRP_TRACE_INITIATE      0
#define IRP_TRACE_SUCCESS       1
#define IRP_TRACE_FAILURE       2
#define IRP_TRACE_CANCEL        3

typedef struct _IRP_TRACE_LOG_ENTRY {

    PIRP Irp;
    ULONG Operation;
    PVOID Thread;
    PVOID Context;

} IRP_TRACE_LOG_ENTRY, *PIRP_TRACE_LOG_ENTRY;


//
// Manipulators.
//

PTRACE_LOG
CreateIrpTraceLog(
    IN LONG LogSize
    );

VOID
DestroyIrpTraceLog(
    IN PTRACE_LOG Log
    );

VOID
WriteIrpTraceLog(
    IN PTRACE_LOG Log,
    IN PIRP Irp,
    IN ULONG Operation,
    IN PVOID Context
    );



#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // IRP_DEBUG


#endif  // _IRPTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\tranrecv.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tranrecv.c

Abstract:

    This module contains the SPUDTransmitFileAndRecv service.

Author:

    John Ballard (jballard)     21-Oct-1996

Revision History:

    Keith Moore (keithmo)       04-Feb-1998
        Cleanup, added much needed comments.

--*/


#include "spudp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SPUDTransmitFileAndRecv )
#endif


//
// Public functions.
//


NTSTATUS
SPUDTransmitFileAndRecv(
    HANDLE hSocket,
    struct _AFD_TRANSMIT_FILE_INFO *transmitInfo,
    struct _AFD_RECV_INFO *recvInfo,
    PSPUD_REQ_CONTEXT reqContext
    )

/*++

Routine Description:

    Batch TransmitFile & receive request.

Arguments:

    hSocket - The target socket for the request.

    transmitInfo - Information describing the TransmitFile.

    recvInfo - Information describing the receive.

    reqContext - The user-mode context for the request.

Return Value:

    NTSTATUS - Completion status.

--*/

{

    NTSTATUS status;
    PFILE_OBJECT fileObject;
    IO_STATUS_BLOCK localIoStatus;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PSPUD_AFD_REQ_CONTEXT SpudReqContext;
    PVOID completionPort;

    //
    // Sanity check.
    //

    PAGED_CODE();

    status = SPUD_ENTER_SERVICE( "SPUDTransmitFileAndRecv", TRUE );

    if( !NT_SUCCESS(status) ) {
        return status;
    }

    BumpCount( CtrTransmitfileAndRecv );

    //
    // SPUD doesn't support kernel-mode callers. In fact, we don't
    // even build the "system stubs" necessary to invoke SPUD from
    // kernel-mode.
    //

    ASSERT( ExGetPreviousMode() == UserMode );

    try {

        //
        // Make sure we can write to reqContext
        //

        ProbeForWrite(
            reqContext,
            sizeof(SPUD_REQ_CONTEXT),
            sizeof(ULONG)
            );

        //
        // Make initial status invalid
        //

        reqContext->IoStatus1.Status = 0xffffffff;
        reqContext->IoStatus1.Information = 0;
        reqContext->IoStatus2.Status = 0xffffffff;
        reqContext->IoStatus2.Information = 0;
        reqContext->ReqType = TransmitFileAndRecv;
        reqContext->KernelReqInfo = SPUD_INVALID_REQ_HANDLE;

        //
        // Make sure the buffer looks good
        //

        ProbeForRead(
            recvInfo,
            sizeof(*recvInfo),
            sizeof(ULONG)
            );

        if( recvInfo->BufferCount < 1 ) {
            ExRaiseStatus( STATUS_INVALID_PARAMETER );
        }

        ProbeForRead(
            recvInfo->BufferArray,
            sizeof(*recvInfo->BufferArray),
            sizeof(ULONG)
            );

        ProbeForRead(
            recvInfo->BufferArray->buf,
            recvInfo->BufferArray->len,
            sizeof(UCHAR)
            );

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = GetExceptionCode();
        SPUD_LEAVE_SERVICE( "SPUDTransmitFileAndRecv", status, FALSE );
        return status;
    }

    //
    // Reference the socket handle
    //

    status = ObReferenceObjectByHandle(
                 hSocket,
                 0L,
                 *IoFileObjectType,
                 UserMode,
                 (PVOID *)&fileObject,
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        SPUD_LEAVE_SERVICE( "SPUDTransmitFileAndRecv", status, FALSE );
        return status;
    }

    TRACE_OB_REFERENCE( fileObject );

    //
    // If we haven't already cached the Device Object and FastIoControl
    // pointers, then do so now.
    //

    if( !SpudAfdDeviceObject ) {

        status = SpudGetAfdDeviceObject( fileObject );

        if( !NT_SUCCESS(status) ) {
            TRACE_OB_DEREFERENCE( fileObject );
            ObDereferenceObject( fileObject );
            status = STATUS_INVALID_DEVICE_REQUEST;
            SPUD_LEAVE_SERVICE( "SPUDTransmitFileAndRecv", status, FALSE );
            return status;
        }

    }

    //
    // Reference the completion port.
    //

    completionPort = SpudReferenceCompletionPort();

    if( completionPort == NULL ) {
        TRACE_OB_DEREFERENCE( fileObject );
        ObDereferenceObject( fileObject );
        status = STATUS_INVALID_DEVICE_REQUEST;
        SPUD_LEAVE_SERVICE( "SPUDTransmitFileAndRecv", status, FALSE );
        return status;
    }

    //
    // Let's check to see if fast io will work
    //

    if( SpudAfdFastIoDeviceControl(
            fileObject,
            TRUE,
            (PVOID)transmitInfo,
            sizeof(AFD_TRANSMIT_FILE_INFO),
            NULL,
            0,
            IOCTL_AFD_TRANSMIT_FILE,
            &localIoStatus,
            SpudAfdDeviceObject
            )) {

        BumpCount( CtrTransRecvFastTrans );

        //
        // Lets remember the completion status for this operation
        //

        try {
            reqContext->IoStatus1 = localIoStatus;
        } except( EXCEPTION_EXECUTE_HANDLER) {
            localIoStatus.Status = GetExceptionCode();
            localIoStatus.Information = 0;
        }

        if( localIoStatus.Status == STATUS_SUCCESS ) {
            localIoStatus.Status = SpudAfdRecvFastReq(
                                       fileObject,
                                       recvInfo,
                                       reqContext
                                       );
        }

        //
        // If everything completed without pending then we can queue
        // a completion packet to the port now.
        //
        // Note that we must not queue a completion packet if the
        // request is failing in-line.
        //

        if( localIoStatus.Status != STATUS_PENDING ) {

            if( NT_SUCCESS(localIoStatus.Status) ) {
                localIoStatus.Status = IoSetIoCompletion(
                                           SpudCompletionPort,  // IoCompletion
                                           reqContext,          // KeyContext
                                           NULL,                // ApcContext
                                           STATUS_SUCCESS,      // IoStatus
                                           0xFFFFFFFF,          // IoStatusInformation
                                           TRUE                 // Quota
                                           );
            }

            TRACE_OB_DEREFERENCE( fileObject );
            ObDereferenceObject( fileObject );

        }

        //
        // At this point, we know the fast-path transmit-file has completed
        // in-line and the receive either completed in-line or has pended.
        // Since it is the receive code's responsibility to add any necessary
        // references to the completion port (and since we know the transmit-
        // file has not pended) we can remove the reference we added above.
        //

        SPUD_LEAVE_SERVICE( "SPUDTransmitFileAndRecv", localIoStatus.Status, TRUE );
        return localIoStatus.Status;
    }

    BumpCount( CtrTransRecvSlowTrans );

    //
    // It looks like we will have to it the hard way.
    // We will now build an IRP for AFD.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the IRP.
    //

    irp = IoAllocateIrp( SpudAfdDeviceObject->StackSize, TRUE );

    if( !irp ) {
        TRACE_OB_DEREFERENCE( fileObject );
        ObDereferenceObject( fileObject );
        status = STATUS_INSUFFICIENT_RESOURCES;
        SPUD_LEAVE_SERVICE( "SPUDTransmitFileAndRecv", status, TRUE );
        return status;
    }

    status = SpudAllocateRequestContext(
                 &SpudReqContext,
                 reqContext,
                 recvInfo,
                 irp,
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        TRACE_OB_DEREFERENCE( fileObject );
        ObDereferenceObject( fileObject );
        IoFreeIrp( irp );
        SPUD_LEAVE_SERVICE( "SPUDTransmitFileAndRecv", status, TRUE );
        return status;
    }

    BumpCount( CtrTransRecvSlowRecv );

    irp->RequestorMode = UserMode;
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    IoQueueThreadIrp( irp );

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->FileObject = fileObject;
    irpSp->DeviceObject = SpudAfdDeviceObject;

    // irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(AFD_TRANSMIT_FILE_INFO);
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_AFD_TRANSMIT_FILE;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = transmitInfo;

    IoSetCompletionRoutine(
        irp,
        SpudAfdContinueRecv,
        SpudReqContext,
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver( SpudAfdDeviceObject, irp );

    status = STATUS_PENDING;
    SPUD_LEAVE_SERVICE( "SPUDTransmitFileAndRecv", status, FALSE );
    return status;

}   // SPUDTransmitFileAndRecv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\oplock.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oplock.c

Abstract:

    This module contains the oplock code for SPUD.

Author:

    John Ballard (jballard)    13-Dec-1996

Revision History:

--*/

#include "spudp.h"

#ifdef PAGE_DRIVER
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SPUDCancel)
#endif
#endif

#if DBG
#define ENABLE_OPLOCK_COUNTERS  1
#define OPLOCKDBG               0
#else
#define ENABLE_OPLOCK_COUNTERS  0
#define OPLOCKDBG               0
#endif

#if ENABLE_OPLOCK_COUNTERS
typedef struct _OPLOCK_COUNTERS {
    LONG OplockIrpInitiated;
    LONG OplockIrpCompleted;
} OPLOCK_COUNTERS;

OPLOCK_COUNTERS SpudOplockCounters;

#define UPDATE_OPLOCK_IRP_INITIATED()                                   \
            InterlockedIncrement( &SpudOplockCounters.OplockIrpInitiated )

#define UPDATE_OPLOCK_IRP_COMPLETED()                                   \
            InterlockedIncrement( &SpudOplockCounters.OplockIrpCompleted )
#else   // !ENABLE_OPLOCK_COUNTERS
#define UPDATE_OPLOCK_IRP_INITIATED()
#define UPDATE_OPLOCK_IRP_COMPLETED()
#endif  // ENABLE_OPLOCK_COUNTERS

NTSTATUS
SpudOplockCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    );

NTSTATUS
SPUDCreateFile(
    OUT PHANDLE FileHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateOptions,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded,
    PVOID pOplock
    )
{

    NTSTATUS Status;
    KPROCESSOR_MODE requestorMode;
    PFILE_OBJECT fileObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PULONG majorFunction;
    PDEVICE_OBJECT deviceObject;
    CLONG method;

#ifdef PAGE_DRIVER
    PAGED_CODE();
#endif

    if (!DriverInitialized) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    requestorMode = KeGetPreviousMode();

    if (requestorMode != KernelMode) {
        try {

            //
            // Make sure we can write to Args
            //

            //
            // The FileHandle parameter must be writeable by the caller.
            // Probe it for a write operation.
            //

            ProbeAndWriteHandle( FileHandle, 0L );

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception has occurred while trying to probe one
            // of the callers parameters. Simply return the error
            // status code.
            //

            return GetExceptionCode();

        }
    }

    Status = IoCreateFile( FileHandle,
                           GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                           ObjectAttributes,
                           IoStatusBlock,
                           NULL,
                           FileAttributes,
                           ShareAccess,
                           FILE_OPEN,
                           CreateOptions,
                           NULL,
                           0,
                           CreateFileTypeNone,
                           (PVOID)NULL,
                           0 );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // If Length == 0 then no Security support is requested.
    //

    if (Length > 0) {

        if (requestorMode != KernelMode) {
            try {

                //
                // Make sure we can write to Args
                //

                ProbeForWriteUlong( LengthNeeded );

                ProbeForWrite( SecurityDescriptor, Length, sizeof(ULONG) );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception has occurred while trying to probe one
                // of the callers parameters. Simply return the error
                // status code.
                //

                return GetExceptionCode();

            }
        }

        Status = NtQuerySecurityObject( *FileHandle,
                                        SecurityInformation,
                                        SecurityDescriptor,
                                        Length,
                                        LengthNeeded );

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_NOT_SUPPORTED) {
                *LengthNeeded = 0;
                Status = STATUS_SUCCESS;
            } else {
                if (Status == STATUS_BUFFER_TOO_SMALL) {
                    Status = STATUS_SUCCESS;
                } else {
                    return Status;
                }
            }
        }

    }

    //
    // If CompletionRoutine == NULL then no OPLOCK support is requested
    //

    if (pOplock == NULL) {
        return Status;
    }

    //
    // Reference the file handle
    //

    Status = ObReferenceObjectByHandle( *FileHandle,
                                        0L,
                                        NULL,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );



    if (!NT_SUCCESS(Status)) {
        return Status;
    }

#if OPLOCKDBG
    DbgPrint("SPUDCreateFile - FileName = >%ws<\n", fileObject->FileName.Buffer );
#endif

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the irp
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );

    if (!irp) {
        ObDereferenceObject( fileObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.AuxiliaryBuffer = (PCHAR)pOplock;
    irp->RequestorMode = requestorMode;
    irp->IoStatus.Status = 0;
    irp->IoStatus.Information = 0;

    irpSp = IoGetNextIrpStackLocation( irp );

    IoSetCompletionRoutine( irp,
                            SpudOplockCompletion,
                            (PVOID)0x0a0a0a0a,    // SpudOplockContext,
                            TRUE,
                            TRUE,
                            TRUE );

    irpSp->MajorFunction = (UCHAR)IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->MinorFunction = 0;
    irpSp->FileObject = fileObject;
    irpSp->DeviceObject = deviceObject;

    irpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.InputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.FsControlCode = FSCTL_REQUEST_BATCH_OPLOCK;

    UPDATE_OPLOCK_IRP_INITIATED();
    IRP_TRACE( irp, INITIATE, pOplock );
    IoCallDriver( deviceObject, irp );

    return STATUS_SUCCESS;

}   // SPUDCreateFile


NTSTATUS
SpudOplockCompletion(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    )
{
    PFILE_OBJECT fileObject;
    PVOID pOplock;

    UPDATE_OPLOCK_IRP_COMPLETED();

    fileObject = Irp->Tail.Overlay.OriginalFileObject;
    pOplock = (PVOID)Irp->Tail.Overlay.AuxiliaryBuffer;

    if( Irp->IoStatus.Status == STATUS_SUCCESS ) {
        IRP_TRACE( Irp, SUCCESS, pOplock );
        ASSERT( Irp->IoStatus.Information == FILE_OPLOCK_BROKEN_TO_LEVEL_2 ||
                Irp->IoStatus.Information == FILE_OPLOCK_BROKEN_TO_NONE );
    } else {
        IRP_TRACE( Irp, FAILURE, pOplock );
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ASSERT( Irp->IoStatus.Information == 0 );
        Irp->IoStatus.Information = 1;  // OPLOCK_BREAK_NO_OPLOCK from atq.h
    }

#if OPLOCKDBG
    DbgPrint("SpudpOplockComplete - FileName = >%ws<\n", fileObject->FileName.Buffer );
#endif

    ObDereferenceObject( fileObject );

    Irp->Tail.CompletionKey = (ULONG)pOplock;
    Irp->Tail.Overlay.CurrentStackLocation = NULL;
    Irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    KeInsertQueue( (PKQUEUE) ATQOplockCompletionPort,
                        &Irp->Tail.Overlay.ListEntry );

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // SpudOplockCompletion


NTSTATUS
SPUDOplockAcknowledge(
    IN HANDLE FileHandle,
    IN PVOID  pOplock
    )
{
    NTSTATUS Status;
    KPROCESSOR_MODE requestorMode;
    PFILE_OBJECT fileObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PULONG majorFunction;
    PDEVICE_OBJECT deviceObject;
    CLONG method;

#ifdef PAGE_DRIVER
    PAGED_CODE();
#endif

    if (!DriverInitialized) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    requestorMode = KeGetPreviousMode();

    //
    // Reference the file handle
    //

    Status = ObReferenceObjectByHandle( FileHandle,
                                        0L,
                                        NULL,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );



    if (!NT_SUCCESS(Status)) {
        return Status;
    }

#if OPLOCKDBG
    DbgPrint("SPUDOplockAcknowledge - FileName = >%ws<\n", fileObject->FileName.Buffer );
#endif

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the irp
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );

    if (!irp) {
        ObDereferenceObject( fileObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.AuxiliaryBuffer = (PCHAR)pOplock;
    irp->RequestorMode = requestorMode;
    irp->IoStatus.Status = 0;
    irp->IoStatus.Information = 0;

    irpSp = IoGetNextIrpStackLocation( irp );

    IoSetCompletionRoutine( irp,
                            SpudOplockCompletion,
                            (PVOID)0x0a0a0a0a,    // SpudOplockContext,
                            TRUE,
                            TRUE,
                            TRUE );

    irpSp->MajorFunction = (UCHAR)IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->MinorFunction = 0;
    irpSp->FileObject = fileObject;
    irpSp->DeviceObject = deviceObject;

    irpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.InputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.FsControlCode = FSCTL_OPLOCK_BREAK_ACKNOWLEDGE;

    Status = IoCallDriver( deviceObject, irp );

    if (Status == STATUS_PENDING) {
        Status = STATUS_SUCCESS;
    }

    if (Status == STATUS_INVALID_PARAMETER) {
        Status = STATUS_SUCCESS;
        ObDereferenceObject( fileObject );
    }

    if (Status != STATUS_SUCCESS) {
        ObDereferenceObject( fileObject );
    }

    return Status;

}   // SPUDOplockAcknowledge
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\dispatch.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the dispatch code for SPUD.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

--*/

#include "spudp.h"

#ifdef PAGE_DRIVER
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SPUDInitialize)
#pragma alloc_text(PAGE, SPUDTerminate)
#pragma alloc_text(PAGE, SPUDCancel)
#endif
#endif

NTSTATUS
SPUDCancel(
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    )
{
    KPROCESSOR_MODE         requestorMode;
    PSPUD_AFD_REQ_CONTEXT   SpudReqContext;
    PIRP                    irp;

#ifdef PAGE_DRIVER
    PAGED_CODE();
#endif

    if (!DriverInitialized) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    requestorMode = KeGetPreviousMode();

    if (requestorMode != KernelMode) {
        try {

            //
            // Make sure we can write to reqContext
            //

            ProbeForRead( reqContext,
                           sizeof(SPUD_REQ_CONTEXT),
                           sizeof(DWORD) );

            SpudReqContext = reqContext->KernelReqInfo;

            if ( SpudReqContext->Signature != SPUD_REQ_CONTEXT_SIGNATURE ) {
                ExRaiseStatus(STATUS_INVALID_PARAMETER);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception has occurred while trying to probe one
            // of the callers parameters. Simply return the error
            // status code.
            //

            return GetExceptionCode();

        }
    } else {
        SpudReqContext = reqContext->KernelReqInfo;

    }

    irp = SpudReqContext->Irp;
    if (irp) {
        IoCancelIrp(irp);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SPUDCheckStatus(
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    )
{
    KPROCESSOR_MODE         requestorMode;
    PSPUD_AFD_REQ_CONTEXT   SpudReqContext;
    KIRQL                   oldirql;

    if (!DriverInitialized) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

#if STATUS_SUPPORTED
    requestorMode = KeGetPreviousMode();

    if (requestorMode != KernelMode) {
        try {

            //
            // Make sure we can write to reqContext
            //

            ProbeForWrite( reqContext,
                           sizeof(SPUD_REQ_CONTEXT),
                           sizeof(DWORD) );

            SpudReqContext = reqContext->KernelReqInfo;

            if ( SpudReqContext->Signature != SPUD_REQ_CONTEXT_SIGNATURE ) {
                ExRaiseStatus(STATUS_INVALID_PARAMETER);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception has occurred while trying to probe one
            // of the callers parameters. Simply return the error
            // status code.
            //

            return GetExceptionCode();

        }
    } else {
        SpudReqContext = reqContext->KernelReqInfo;

    }

    KeAcquireSpinLock( &SpudReqContext->Lock, &oldirql );

    if ( SpudReqContext->Signature != SPUD_REQ_CONTEXT_SIGNATURE ) {
        KeReleaseSpinLock( &SpudReqContext->Lock, oldirql );
        return STATUS_INVALID_PARAMETER;
    }

    reqContext->IoStatus1 = SpudReqContext->IoStatus1;
    reqContext->IoStatus2 = SpudReqContext->IoStatus2;
    KeReleaseSpinLock( &SpudReqContext->Lock, oldirql );

    return STATUS_SUCCESS;

#else

    return STATUS_INVALID_DEVICE_REQUEST;

#endif

}

NTSTATUS
SPUDGetCounts(
    PSPUD_COUNTERS          SpudCounters,        // Counters
    DWORD                   ClearCounters
    )
{
    KPROCESSOR_MODE         requestorMode;
    KIRQL                   oldirql;

    if (!DriverInitialized) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

#if USE_SPUD_COUNTERS
    requestorMode = KeGetPreviousMode();

    if (requestorMode != KernelMode) {
        try {

            //
            // Make sure we can write to reqContext
            //

            ProbeForWrite( SpudCounters,
                           sizeof(SPUD_COUNTERS),
                           sizeof(DWORD) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception has occurred while trying to probe one
            // of the callers parameters. Simply return the error
            // status code.
            //

            return GetExceptionCode();

        }
    }

    KeAcquireSpinLock( &CounterLock, &oldirql );

    SpudCounters->CtrTransmitfileAndRecv = CtrTransmitfileAndRecv;
    SpudCounters->CtrTransRecvFastTrans = CtrTransRecvFastTrans;
    SpudCounters->CtrTransRecvSlowTrans = CtrTransRecvSlowTrans;
    SpudCounters->CtrTransRecvFastRecv = CtrTransRecvFastRecv;
    SpudCounters->CtrTransRecvSlowRecv = CtrTransRecvSlowRecv;
    SpudCounters->CtrSendAndRecv = CtrSendAndRecv;
    SpudCounters->CtrSendRecvFastSend = CtrSendRecvFastSend;
    SpudCounters->CtrSendRecvSlowSend = CtrSendRecvSlowSend;
    SpudCounters->CtrSendRecvFastRecv = CtrSendRecvFastRecv;
    SpudCounters->CtrSendRecvSlowRecv = CtrSendRecvSlowRecv;

    if (ClearCounters) {
        CtrTransmitfileAndRecv = 0;
        CtrTransRecvFastTrans = 0;
        CtrTransRecvSlowTrans = 0;
        CtrTransRecvFastRecv = 0;
        CtrTransRecvSlowRecv = 0;
        CtrSendAndRecv = 0;
        CtrSendRecvFastSend = 0;
        CtrSendRecvSlowSend = 0;
        CtrSendRecvFastRecv = 0;
        CtrSendRecvSlowRecv = 0;
    }

    KeReleaseSpinLock( &CounterLock, oldirql );

    return STATUS_SUCCESS;

#else

    return STATUS_INVALID_DEVICE_REQUEST;

#endif

}

NTSTATUS
SPUDInitialize(
    DWORD       Version,        // Version information from Spud.h
    HANDLE      hIoPort,        // Handle of IO completion port for ATQ
    HANDLE      hOplockPort     // Handle of oplock completion port for ATQ
    )
{
    NTSTATUS Status;

#ifdef PAGE_DRIVER
    PAGED_CODE();
#endif

    if (Version != SPUD_VERSION) {
        return STATUS_INVALID_PARAMETER;
    }

    if (DriverInitialized) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    Status = ObReferenceObjectByHandle( hIoPort,
                                        IO_COMPLETION_MODIFY_STATE,
                                        NULL,
                                        KeGetPreviousMode(),
                                        &ATQIoCompletionPort,
                                        NULL
                                        );

    if (Status != STATUS_SUCCESS) {
        return STATUS_INVALID_HANDLE;
    }

    Status = ObReferenceObjectByHandle( hOplockPort,
                                        IO_COMPLETION_MODIFY_STATE,
                                        NULL,
                                        KeGetPreviousMode(),
                                        &ATQOplockCompletionPort,
                                        NULL
                                        );

    if (Status != STATUS_SUCCESS) {
        ObDereferenceObject( ATQIoCompletionPort );
        ATQIoCompletionPort = NULL;
        return STATUS_INVALID_HANDLE;
    }

    DriverInitialized = TRUE;

    return STATUS_SUCCESS;
}


NTSTATUS
SPUDTerminate(
    VOID
    )
{
#ifdef PAGE_DRIVER
    PAGED_CODE();
#endif

    if (!DriverInitialized) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ObDereferenceObject(ATQIoCompletionPort);
    ATQIoCompletionPort = NULL;

    ObDereferenceObject(ATQOplockCompletionPort);
    ATQOplockCompletionPort = NULL;

    DriverInitialized = FALSE;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\init.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module performs initialization for the SPUD device driver.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

--*/

#include "spudp.h"

#define REGISTRY_PARAMETERS         L"Parameters"
#define REGISTRY_SPUD_INFORMATION    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Spud"

#if DBG
#define REGISTRY_DEBUG_FLAGS        L"DebugFlags"
#define REGISTRY_BREAK_ON_STARTUP   L"BreakOnStartup"
#define REGISTRY_USE_PRIVATE_ASSERT L"UsePrivateAssert"
#endif
#define REGISTRY_DO_NOT_LOAD        L"DoNotLoad"

// for the time being, don't load spud.sys by default.
BOOLEAN FailLoad = FALSE;

ULONG
SpudReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

NTSTATUS
SpudOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    );

VOID
SpudReadRegistry (
    VOID
    );

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( INIT, SpudReadSingleParameter )
#pragma alloc_text( INIT, SpudOpenRegistry )
#pragma alloc_text( INIT, SpudReadRegistry )
#endif


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the SPUD driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN success;

    PAGED_CODE( );

    success = SpudInitializeData( );
    if ( !success ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SpudReadRegistry( );

    if (FailLoad) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (!KeAddSystemServiceTable(
            SPUDpServiceTable,
            NULL,
            SPUDpServiceLimit,
            SPUDpArgumentTable,
            SPUDServiceIndex
            )) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DriverInitialized = FALSE;
    ATQIoCompletionPort = NULL;
    ATQOplockCompletionPort = NULL;

    return (status);

} // DriverEntry



VOID
SpudReadRegistry (
    VOID
    )

/*++

Routine Description:

    Reads the SPUD section of the registry.  Any values listed in the
    registry override defaults.

Arguments:

    None.

Return Value:

    None -- if anything fails, the default value is used.

--*/
{
    HANDLE parametersHandle;
    NTSTATUS status;
    UNICODE_STRING registryPath;
    CLONG i;

    PAGED_CODE( );

    RtlInitUnicodeString( &registryPath, REGISTRY_SPUD_INFORMATION );

    status = SpudOpenRegistry( &registryPath, &parametersHandle );

    if (status != STATUS_SUCCESS) {
        return;
    }

#if DBG
    //
    // Read the debug flags from the registry.
    //

    SpudDebug = SpudReadSingleParameter(
                   parametersHandle,
                   REGISTRY_DEBUG_FLAGS,
                   SpudDebug
                   );

    //
    // Force a breakpoint if so requested.
    //

    if( SpudReadSingleParameter(
            parametersHandle,
            REGISTRY_BREAK_ON_STARTUP,
            0 ) != 0 ) {
        DbgBreakPoint();
    }

    //
    // Enable private assert function if requested.
    //

    SpudUsePrivateAssert = SpudReadSingleParameter(
                              parametersHandle,
                              REGISTRY_USE_PRIVATE_ASSERT,
                              (LONG)SpudUsePrivateAssert
                              ) != 0;
#endif

    //
    // Fail Load if so requested.
    //

    if( SpudReadSingleParameter(
            parametersHandle,
            REGISTRY_DO_NOT_LOAD,
            0 ) != 0 ) {
        FailLoad = TRUE;
#if DBG
        DbgPrint("Spud.sys load aborted! DoNotLoad is configured in the registry.\n");
#endif
    } else {
        FailLoad = FALSE;
#if DBG
        DbgPrint("Spud.sys load enabled! DoNotLoad is configured in the registry.\n");
#endif
    }

    ZwClose( parametersHandle );

    return;

} // SpudReadRegistry


NTSTATUS
SpudOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by SPUD to open the registry. If the registry
    tree exists, then it opens it and returns STATUS_SUCCESS.

Arguments:

    BaseName - Where in the registry to start looking for the information.

    LinkageHandle - Returns the handle used to read linkage information.

    ParametersHandle - Returns the handle used to read other
        parameters.

Return Value:

    The status of the request.

--*/
{

    HANDLE configHandle;
    NTSTATUS status;
    PWSTR parametersString = REGISTRY_PARAMETERS;
    UNICODE_STRING parametersKeyName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE( );

    //
    // Open the registry for the initial string.
    //

    InitializeObjectAttributes(
        &objectAttributes,
        BaseName,                   // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    status = ZwOpenKey(
                 &configHandle,
                 KEY_READ,
                 &objectAttributes
                 );

    if (!NT_SUCCESS(status)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now open the parameters key.
    //

    RtlInitUnicodeString (&parametersKeyName, parametersString);

    InitializeObjectAttributes(
        &objectAttributes,
        &parametersKeyName,         // name
        OBJ_CASE_INSENSITIVE,       // attributes
        configHandle,               // root
        NULL                        // security descriptor
        );

    status = ZwOpenKey(
                 ParametersHandle,
                 KEY_READ,
                 &objectAttributes
                 );
    if (!NT_SUCCESS(status)) {

        ZwClose( configHandle );
        return status;
    }

    //
    // All keys successfully opened.
    //

    ZwClose( configHandle );
    return STATUS_SUCCESS;

} // SpudOpenRegistry


ULONG
SpudReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )

/*++

Routine Description:

    This routine is called by SPUD to read a single parameter
    from the registry. If the parameter is found it is stored
    in Data.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to search for.

    DefaultValue - The default value.

Return Value:

    The value to use; will be the default if the value is not
    found or is not in the correct range.

--*/

{
    static ULONG informationBuffer[32];   // declare ULONG to get it aligned
    PKEY_VALUE_FULL_INFORMATION information =
        (PKEY_VALUE_FULL_INFORMATION)informationBuffer;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    LONG returnValue;
    NTSTATUS status;

    PAGED_CODE( );

    RtlInitUnicodeString( &valueKeyName, ValueName );

    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValueFullInformation,
                 (PVOID)information,
                 sizeof (informationBuffer),
                 &informationLength
                 );

    if ((status == STATUS_SUCCESS) && (information->DataLength == sizeof(ULONG))) {

        RtlMoveMemory(
            (PVOID)&returnValue,
            ((PUCHAR)information) + information->DataOffset,
            sizeof(ULONG)
            );

        if (returnValue < 0) {

            returnValue = DefaultValue;

        }

    } else {

        returnValue = DefaultValue;
    }

    return returnValue;

} // SpudReadSingleParameter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=spud

TARGETNAME=spud
TARGETTYPE=DRIVER

INCLUDES=..;..\..\..\..\inc;\nt\private\ntos\inc;\nt\private\inc

C_DEFINES=$(C_DEFINES) -DNT -D_NTDRIVER_

SOURCES=                \
        ..\complete.c   \
        ..\dispatch.c   \
        ..\init.c       \
        ..\irptrace.c   \
        ..\misc.c       \
        ..\oplock.c     \
        ..\recv.c       \
        ..\sendrecv.c   \
        ..\spuddata.c   \
        ..\tracelog.c   \
        ..\tranrecv.c   \
        ..\spud.rc      \

UMRES=obj\*\spud.res

MSC_WARNING_LEVEL=/W3 /WX

!IF "$(NTNOPCH)" == ""
PRECOMPILED_INCLUDE=..\spudp.h
PRECOMPILED_PCH=spudp.pch
PRECOMPILED_OBJ=spudp.obj
!ENDIF

NTTARGETFILE0=services.tab

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\sendrecv.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sendrecv.c

Abstract:

    This module contains the SendAndRecv code for SPUD.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

--*/

#include "spudp.h"


NTSTATUS
SPUDSendAndRecv(
    HANDLE                  hSocket,                // Socket handle to use for operation
    PAFD_SEND_INFO          sendInfo,               // send req info
    PAFD_RECV_INFO          recvInfo,               // recv req info
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    )
{
    NTSTATUS                Status;
    KPROCESSOR_MODE         requestorMode;
    PFILE_OBJECT            fileObject;
    IO_STATUS_BLOCK         localIoStatus;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    PULONG                  majorFunction;
    PSPUD_AFD_REQ_CONTEXT   SpudReqContext;


    if (!DriverInitialized) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

#if USE_SPUD_COUNTERS
    BumpCount(CtrSendAndRecv);
#endif

    requestorMode = KeGetPreviousMode();

    if (requestorMode != KernelMode) {
        try {

            //
            // Make sure we can write to reqContext
            //

            ProbeForWrite( reqContext,
                           sizeof(SPUD_REQ_CONTEXT),
                           sizeof(DWORD) );

            //
            // Make initial status invalid
            //

            reqContext->IoStatus1.Status = 0xffffffff;
            reqContext->IoStatus1.Information = 0;
            reqContext->IoStatus2.Status = 0xffffffff;
            reqContext->IoStatus2.Information = 0;
            reqContext->ReqType = SendAndRecv;
            reqContext->KernelReqInfo = NULL;

            //
            // Make sure the buffer looks good
            //

            if ( recvInfo->BufferCount < 1 ) {
                ExRaiseStatus(STATUS_INVALID_PARAMETER);
            }

            ProbeForWrite( recvInfo->BufferArray->buf,
                           recvInfo->BufferArray->len,
                           sizeof(UCHAR) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception has occurred while trying to probe one
            // of the callers parameters. Simply return the error
            // status code.
            //

            return GetExceptionCode();

        }
    } else {
        reqContext->IoStatus1.Status = 0xffffffff;
        reqContext->IoStatus1.Information = 0;
        reqContext->IoStatus2.Status = 0xffffffff;
        reqContext->IoStatus2.Information = 0;
        reqContext->ReqType = SendAndRecv;
        reqContext->KernelReqInfo = NULL;
    }


    //
    // Reference the socket handle
    //

    Status = ObReferenceObjectByHandle( hSocket,
                                        0L,
                                        NULL,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    //
    // If we haven't already cached the Device Object and FastIoControl
    // pointers, then do so now.
    //

    if (!AfdDeviceObject) {

        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            AfdDeviceObject = IoGetRelatedDeviceObject( fileObject );
        } else {
            AfdDeviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
        }

        if (!AfdDeviceObject) {
            ObDereferenceObject( fileObject );
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        AfdFastIoDeviceControl =
            AfdDeviceObject->DriverObject->FastIoDispatch->FastIoDeviceControl;

        if (!AfdFastIoDeviceControl) {
            AfdDeviceObject = NULL;
            ObDereferenceObject( fileObject );
            return STATUS_INVALID_DEVICE_REQUEST;
        }

    }

    //
    // Let's check to see if fast io will work
    //

    if (AfdFastIoDeviceControl( fileObject,
                                TRUE,
                                (PVOID) sendInfo,
                                sizeof(AFD_SEND_INFO),
                                NULL,
                                0,
                                IOCTL_AFD_SEND,
                                &localIoStatus,
                                AfdDeviceObject
                                )) {


#if USE_SPUD_COUNTERS
    BumpCount(CtrSendRecvFastSend);
#endif

        //
        // Lets remember the completion status for this operation
        //

        try {
            reqContext->IoStatus1 = localIoStatus;
        } except( EXCEPTION_EXECUTE_HANDLER) {
            localIoStatus.Status = GetExceptionCode();
            localIoStatus.Information = 0;
        }

        if (localIoStatus.Status == STATUS_SUCCESS) {
            localIoStatus.Status = SpudAfdRecvFastReq( fileObject,
                                               recvInfo,
                                               reqContext,
                                               requestorMode );
        }

        //
        // If everything completed without pending then we can queue
        // a completion packet to the port now.
        //

        if (localIoStatus.Status != STATUS_PENDING) {

            PIO_MINI_COMPLETION_PACKET miniPacket = NULL;

            try {
                miniPacket = ExAllocatePoolWithQuotaTag( NonPagedPool,
                                                         sizeof( *miniPacket ),
                                                         'pcUI' );
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                NOTHING;
            }

            if (miniPacket) {
                miniPacket->TypeFlag = 0xffffffff;
                miniPacket->KeyContext = (ULONG)reqContext;
                miniPacket->ApcContext = NULL;
                miniPacket->IoStatus = 0;
                miniPacket->IoStatusInformation = 0xffffffff;

                KeInsertQueue( (PKQUEUE) ATQIoCompletionPort,
                                &miniPacket->ListEntry );

            } else {
                localIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            ObDereferenceObject( fileObject );
        }

        return localIoStatus.Status;
    }

#if USE_SPUD_COUNTERS
    BumpCount(CtrSendRecvSlowSend);
#endif

    //
    // It looks like we will have to it the hard way
    // We will now build an irp for AFD
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the irp
    //

    irp = IoAllocateIrp( AfdDeviceObject->StackSize, TRUE );

    if (!irp) {
        ObDereferenceObject( fileObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SpudReqContext = ExAllocateFromNPagedLookasideList(
                         &SpudLookasideLists->ReqContextList);

    if (!SpudReqContext) {
        ObDereferenceObject( fileObject );
        IoFreeIrp( irp );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

#if STATUS_SUPPORTED
    KeInitializeSpinLock( &SpudReqContext->Lock );
#endif
    SpudReqContext->Signature = SPUD_REQ_CONTEXT_SIGNATURE;
    SpudReqContext->Irp = irp;
    SpudReqContext->AtqContext = reqContext;
    reqContext->KernelReqInfo = SpudReqContext;

    //
    // Allocate MDL for receive buffer and Probe and Lock it.
    //

    try {

        if (recvInfo != NULL) {
            SpudReqContext->IoStatus2.Information = recvInfo->BufferArray->len;
            SpudReqContext->Mdl = IoAllocateMdl( recvInfo->BufferArray->buf,
                                                recvInfo->BufferArray->len,
                                                FALSE,
                                                FALSE,
                                                NULL );

            if ( SpudReqContext->Mdl == NULL ) {
                ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
            }

            MmProbeAndLockPages( SpudReqContext->Mdl,
                                 requestorMode,
                                 IoWriteAccess );

        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ObDereferenceObject( fileObject );
        IoFreeIrp( irp );
        ExFreeToNPagedLookasideList( &SpudLookasideLists->ReqContextList,
                                     SpudReqContext );
        return GetExceptionCode();
    }

#if USE_SPUD_COUNTERS
    BumpCount(CtrSendRecvSlowRecv);
#endif

    IoSetCompletionRoutine( irp, SpudAfdContinueRecv, SpudReqContext, TRUE, TRUE, TRUE);

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID)NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL)NULL;
    irp->UserEvent = NULL;
    irp->UserIosb = &reqContext->IoStatus1;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    irpSp = IoGetNextIrpStackLocation( irp );

    majorFunction = (PULONG) (&irpSp->MajorFunction);
    *majorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->FileObject = fileObject;
    irpSp->Control = SL_INVOKE_ON_SUCCESS |
                     SL_INVOKE_ON_ERROR   |
                     SL_INVOKE_ON_CANCEL;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(AFD_SEND_INFO);
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_AFD_SEND;
    irp->UserBuffer = NULL;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = sendInfo;

    IoCallDriver( AfdDeviceObject, irp ) ;
    return STATUS_PENDING;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\spuddata.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    spuddata.h

Abstract:

    This module declares global data for SPUD.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

--*/

#ifndef _SPUDDATA_
#define _SPUDDATA_

#define USE_SPUD_COUNTERS   1

#if USE_SPUD_COUNTERS
extern  KSPIN_LOCK  CounterLock;
extern  ULONG       CtrTransmitfileAndRecv;
extern  ULONG       CtrTransRecvFastTrans;
extern  ULONG       CtrTransRecvFastRecv;
extern  ULONG       CtrTransRecvSlowTrans;
extern  ULONG       CtrTransRecvSlowRecv;
extern  ULONG       CtrSendAndRecv;
extern  ULONG       CtrSendRecvFastSend;
extern  ULONG       CtrSendRecvFastRecv;
extern  ULONG       CtrSendRecvSlowSend;
extern  ULONG       CtrSendRecvSlowRecv;

#define  BumpCount(c)                               \
    {                                               \
        KIRQL   oldirql;                            \
                                                    \
        KeAcquireSpinLock( &CounterLock, &oldirql ); \
        c++;                                        \
        KeReleaseSpinLock( &CounterLock, oldirql ); \
    }

#endif

extern KSPIN_LOCK SpudWorkQueueSpinLock;
extern LIST_ENTRY SpudWorkQueueListHead;

extern ULONG    SPUDpServiceTable[];
extern ULONG    SPUDpServiceLimit;
extern UCHAR    SPUDpArgumentTable[];
#define         SPUDServiceIndex     2

extern  PVOID   ATQIoCompletionPort;
extern  PVOID   ATQOplockCompletionPort;
extern  BOOLEAN DriverInitialized;
extern  PDEVICE_OBJECT  AfdDeviceObject;
extern  PFAST_IO_DEVICE_CONTROL AfdFastIoDeviceControl;
extern  PSPUD_LOOKASIDE_LISTS SpudLookasideLists;

#endif // ndef _SPUDDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\spuddata.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    spuddata.c

Abstract:

    This module contains global data for SPUD.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

--*/

#include "spudp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, SpudInitializeData )
#endif

PVOID   ATQIoCompletionPort = NULL;
PVOID   ATQOplockCompletionPort = NULL;
BOOLEAN DriverInitialized = FALSE;
PDEVICE_OBJECT  AfdDeviceObject = NULL;
PFAST_IO_DEVICE_CONTROL AfdFastIoDeviceControl = NULL;
PSPUD_LOOKASIDE_LISTS SpudLookasideLists;

#if USE_SPUD_COUNTERS
KSPIN_LOCK  CounterLock;
ULONG       CtrTransmitfileAndRecv;
ULONG       CtrTransRecvFastTrans;
ULONG       CtrTransRecvFastRecv;
ULONG       CtrTransRecvSlowTrans;
ULONG       CtrTransRecvSlowRecv;
ULONG       CtrSendAndRecv;
ULONG       CtrSendRecvFastSend;
ULONG       CtrSendRecvFastRecv;
ULONG       CtrSendRecvSlowSend;
ULONG       CtrSendRecvSlowRecv;
#endif

#if DBG
ULONG SpudDebug = 0;
ULONG SpudLocksAcquired = 0;
BOOLEAN SpudUsePrivateAssert = FALSE;
#endif

#if IRP_DEBUG
PTRACE_LOG IrpTraceLog = NULL;
#endif

BOOLEAN
SpudInitializeData (
    VOID
    )
{
    PAGED_CODE( );

    if( !MmIsThisAnNtAsSystem() ) {
        return FALSE;
    }

    SpudLookasideLists = ExAllocatePoolWithTag( NonPagedPool,
                                               sizeof(*SpudLookasideLists),
                                               'lDUI' );

    if (SpudLookasideLists == NULL) {
        return FALSE;
    }

    ExInitializeNPagedLookasideList(
        &SpudLookasideLists->ReqContextList,
        NULL,
        NULL,
        NonPagedPool,
        sizeof( SPUD_AFD_REQ_CONTEXT ),
        'cDUI',
        12
        );

#if USE_SPUD_COUNTERS
    KeInitializeSpinLock( &CounterLock );
    CtrTransmitfileAndRecv = 0;
    CtrTransRecvFastTrans = 0;
    CtrTransRecvFastRecv = 0;
    CtrTransRecvSlowTrans = 0;
    CtrTransRecvSlowRecv = 0;
    CtrSendAndRecv = 0;
    CtrSendRecvFastSend = 0;
    CtrSendRecvFastRecv = 0;
    CtrSendRecvSlowSend = 0;
    CtrSendRecvSlowRecv = 0;
#endif

    IrpTraceLog = CreateIrpTraceLog( 1024 );

    return TRUE;

} // SpudInitializeData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\spudp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    spud.h

Abstract:

    This is the local header file for SPUD.  It includes all other
    necessary header files for SPUD.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

--*/

#ifndef _SPUDP_
#define _SPUDP_

typedef unsigned long   DWORD;
typedef void           *LPVOID;

#define STATUS_SUPPORTED    0

#include <ntos.h>
#include <ke.h>
#include <zwapi.h>
#include <fsrtl.h>
#include <tdikrnl.h>

//
// Set IRP_DEBUG to a non-zero value to enable tracing of all
// IRP operations.
//

#if DBG
#define IRP_DEBUG   1
#else   // !DBG
#define IRP_DEBUG   0
#endif  // DBG


typedef struct _TRANSMIT_FILE_BUFFERS {
    LPVOID Head;
    DWORD HeadLength;
    LPVOID Tail;
    DWORD TailLength;
} TRANSMIT_FILE_BUFFERS, *PTRANSMIT_FILE_BUFFERS, *LPTRANSMIT_FILE_BUFFERS;

//
// Define the type for completion packets inserted onto completion ports when
// there is no full I/O request packet that was used to perform the I/O
// operation.  This occurs when the fast I/O path is used, and when the user
// directly inserts a completion message.
//

typedef struct _IO_MINI_COMPLETION_PACKET {
    LIST_ENTRY ListEntry;
    ULONG TypeFlag;
    ULONG KeyContext;
    PVOID ApcContext;
    NTSTATUS IoStatus;
    ULONG IoStatusInformation;
} IO_MINI_COMPLETION_PACKET, *PIO_MINI_COMPLETION_PACKET;


//
// Goodies stolen from other header files.
//

#ifndef FAR
#define FAR
#endif

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

typedef unsigned short u_short;

#ifndef SG_UNCONSTRAINED_GROUP
#define SG_UNCONSTRAINED_GROUP   0x01
#endif

#ifndef SG_CONSTRAINED_GROUP
#define SG_CONSTRAINED_GROUP     0x02
#endif

#include <afd.h>
#include <spud.h>
#include <uspud.h>
#include "spudstr.h"
#include "spudproc.h"
#include "spuddata.h"
#include "tracelog.h"
#include "irptrace.h"

#define SPUD_POOL_TAG            'BduI'

#define SPUD_ALLOCATE_POOL(a,b,t)    ExAllocatePoolWithTag(a,b,t)
#define SPUD_FREE_POOL(a)            ExFreePool(a)

#if IRP_DEBUG
extern PTRACE_LOG IrpTraceLog;
#define IRP_TRACE( irp, operation, context )                                \
    if( IrpTraceLog != NULL ) {                                             \
        WriteIrpTraceLog(                                                   \
            IrpTraceLog,                                                    \
            (irp),                                                          \
            IRP_TRACE_ ## operation,                                        \
            (context)                                                       \
            );                                                              \
    } else
#else
#define IRP_TRACE( irp, operation, context )
#endif

#if DBG

extern ULONG SpudDebug;
extern ULONG SpudLocksAcquired;
extern BOOLEAN SpudUsePrivateAssert;

#undef IF_DEBUG
#define IF_DEBUG(a) if ( (SPUD_DEBUG_ ## a & SpudDebug) != 0 )

#define SPUD_DEBUG_INITIALIZATION    0x00000001

#define DEBUG

//
// Define our own assert so that we can actually catch assertion failures
// when running a checked SPUD on a free kernel.
//

VOID
SpudAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        SpudAssert( #exp, __FILE__, __LINE__, NULL )

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        SpudAssert( #exp, __FILE__, __LINE__, msg )

#else   // !DBG

#undef IF_DEBUG
#define IF_DEBUG(a) if (FALSE)
#define DEBUG if ( FALSE )

#endif // def DBG

#endif // ndef _SPUDP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\spudproc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    spudproc.h

Abstract:

    This module contains routine prototypes for SPUD.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

--*/

#ifndef _SPUDPROCS_
#define _SPUDPROCS_


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


BOOLEAN
SpudInitializeData (
    VOID
    );

NTSTATUS
SpudAfdRecvFastReq(
    PFILE_OBJECT            fileObject,             // socket file object
    PAFD_RECV_INFO          recvInfo,               // recv req info
    PSPUD_REQ_CONTEXT       reqContext,             // context info for req
    KPROCESSOR_MODE         requestorMode           // mode of caller
    );


NTSTATUS
SpudAfdContinueRecv(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    );

NTSTATUS
SpudAfdCompleteRecv(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp,
    PVOID           Context
    );

NTSTATUS
SpudCompleteRequest(
    PSPUD_AFD_REQ_CONTEXT   SpudReqContext
    );

#endif // ndef _SPUDPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\tracelog.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    This module implements a trace log.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#include "spudp.h"


#if IRP_DEBUG


//
// Environmental stuff.
//

#define MY_ALLOC_MEM(cb)                                                    \
    (PVOID)SPUD_ALLOCATE_POOL(                                              \
        NonPagedPool,                                                       \
        (ULONG)(cb),                                                        \
        SPUD_POOL_TAG                                                       \
        )

#define MY_FREE_MEM(ptr)                                                    \
    SPUD_FREE_POOL(                                                         \
        (PVOID)(ptr)                                                        \
        )

#define MY_ASSERT(expr) ASSERT(expr)



PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    )
/*++

Routine Description:

    Creates a new (empty) trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

    EntrySize - The size (in bytes) of each entry.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    LONG totalSize;
    PTRACE_LOG log;

    //
    // Sanity check the parameters.
    //

    MY_ASSERT( LogSize > 0 );
    MY_ASSERT( EntrySize > 0 );
    MY_ASSERT( ( EntrySize & 3 ) == 0 );

    //
    // Allocate & initialize the log structure.
    //

    totalSize = sizeof(*log) + ( LogSize * EntrySize ) + ExtraBytesInHeader;
    MY_ASSERT( totalSize > 0 );

    log = (PTRACE_LOG)MY_ALLOC_MEM( totalSize );

    //
    // Initialize it.
    //

    if( log != NULL ) {

        RtlZeroMemory( log, totalSize );

        log->Signature = TRACE_LOG_SIGNATURE;
        log->LogSize = LogSize;
        log->NextEntry = -1;
        log->EntrySize = EntrySize;
        log->LogBuffer = (PUCHAR)( log + 1 ) + ExtraBytesInHeader;

    }

    return log;

}   // CreateTraceLog


VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a trace log buffer created with CreateTraceLog().

Arguments:

    Log - The trace log buffer to destroy.

Return Value:

    None.

--*/
{

    MY_ASSERT( Log != NULL );
    MY_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

    Log->Signature = TRACE_LOG_SIGNATURE_X;
    MY_FREE_MEM( Log );

}   // DestroyTraceLog


VOID
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    )
/*++

Routine Description:

    Writes a new entry to the specified trace log.

Arguments:

    Log - The log to write to.

    Entry - Pointer to the data to write. This buffer is assumed to be
        Log->EntrySize bytes long.

Return Value:

    None

--*/
{

    PUCHAR target;
    LONG index;

    MY_ASSERT( Log != NULL );
    MY_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );
    MY_ASSERT( Entry != NULL );

    //
    // Find the next slot, copy the entry to the slot.
    //

    index = InterlockedIncrement( &Log->NextEntry ) % Log->LogSize;
    target = Log->LogBuffer + ( index * Log->EntrySize );

    RtlCopyMemory(
        target,
        Entry,
        Log->EntrySize
        );

}   // WriteTraceLog


VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    )
{

    MY_ASSERT( Log != NULL );
    MY_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

    RtlZeroMemory(
        ( Log + 1 ),
        Log->LogSize * Log->EntrySize
        );

    Log->NextEntry = -1;

}   // ResetTraceLog


#endif  // IRP_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\tranrecv.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tranrecv.c

Abstract:

    This module contains the TransmitFileAndRecv code for SPUD.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

--*/

#include "spudp.h"


NTSTATUS
SPUDTransmitFileAndRecv(
    HANDLE                  hSocket,                // Socket handle to use for operation
    PAFD_TRANSMIT_FILE_INFO transmitInfo,           // transmit file req info
    PAFD_RECV_INFO          recvInfo,               // recv req info
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    )
{
    NTSTATUS                Status;
    KPROCESSOR_MODE         requestorMode;
    PFILE_OBJECT            fileObject;
    IO_STATUS_BLOCK         localIoStatus;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    PULONG                  majorFunction;
    PSPUD_AFD_REQ_CONTEXT   SpudReqContext;


    if (!DriverInitialized) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

#if USE_SPUD_COUNTERS
    BumpCount(CtrTransmitfileAndRecv);
#endif

    requestorMode = KeGetPreviousMode();

    if (requestorMode != KernelMode) {
        try {

            //
            // Make sure we can write to reqContext
            //

            //
            // Make initial status invalid
            //

            reqContext->IoStatus1.Status = 0xffffffff;
            reqContext->IoStatus1.Information = 0;
            reqContext->IoStatus2.Status = 0xffffffff;
            reqContext->IoStatus2.Information = 0;
            reqContext->ReqType = TransmitFileAndRecv;
            reqContext->KernelReqInfo = NULL;

            //
            // Make sure the buffer looks good
            //

            if ( recvInfo->BufferCount < 1 ) {
                ExRaiseStatus(STATUS_INVALID_PARAMETER);
            }

            ProbeForWrite( recvInfo->BufferArray->buf,
                           recvInfo->BufferArray->len,
                           sizeof(UCHAR) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception has occurred while trying to probe one
            // of the callers parameters. Simply return the error
            // status code.
            //

            return GetExceptionCode();

        }
    } else {
        reqContext->IoStatus1.Status = 0xffffffff;
        reqContext->IoStatus1.Information = 0;
        reqContext->IoStatus2.Status = 0xffffffff;
        reqContext->IoStatus2.Information = 0;
        reqContext->ReqType = TransmitFileAndRecv;
        reqContext->KernelReqInfo = NULL;
    }


    //
    // Reference the socket handle
    //

    Status = ObReferenceObjectByHandle( hSocket,
                                        0L,
                                        NULL,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    //
    // If we haven't already cached the Device Object and FastIoControl
    // pointers, then do so now.
    //

    if (!AfdDeviceObject) {

        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            AfdDeviceObject = IoGetRelatedDeviceObject( fileObject );
        } else {
            AfdDeviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
        }

        if (!AfdDeviceObject) {
            ObDereferenceObject( fileObject );
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        AfdFastIoDeviceControl =
            AfdDeviceObject->DriverObject->FastIoDispatch->FastIoDeviceControl;

        if (!AfdFastIoDeviceControl) {
            AfdDeviceObject = NULL;
            ObDereferenceObject( fileObject );
            return STATUS_INVALID_DEVICE_REQUEST;
        }

    }

    //
    // Let's check to see if fast io will work
    //

    if (AfdFastIoDeviceControl( fileObject,
                                TRUE,
                                (PVOID) transmitInfo,
                                sizeof(AFD_TRANSMIT_FILE_INFO),
                                NULL,
                                0,
                                IOCTL_AFD_TRANSMIT_FILE,
                                &localIoStatus,
                                AfdDeviceObject
                                )) {


#if USE_SPUD_COUNTERS
    BumpCount(CtrTransRecvFastTrans);
#endif

        //
        // Lets remember the completion status for this operation
        //

        try {
            reqContext->IoStatus1 = localIoStatus;
        } except( EXCEPTION_EXECUTE_HANDLER) {
            localIoStatus.Status = GetExceptionCode();
            localIoStatus.Information = 0;
        }

        if (localIoStatus.Status == STATUS_SUCCESS) {
            localIoStatus.Status = SpudAfdRecvFastReq( fileObject,
                                               recvInfo,
                                               reqContext,
                                               requestorMode );
        }

        //
        // If everything completed without pending then we can queue
        // a completion packet to the port now.
        //

        if (localIoStatus.Status != STATUS_PENDING) {

            PIO_MINI_COMPLETION_PACKET miniPacket = NULL;

            try {
                miniPacket = ExAllocatePoolWithQuotaTag( NonPagedPool,
                                                         sizeof( *miniPacket ),
                                                         'pcUI' );
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                NOTHING;
            }

            if (miniPacket) {
                miniPacket->TypeFlag = 0xffffffff;
                miniPacket->KeyContext = (ULONG)reqContext;
                miniPacket->ApcContext = NULL;
                miniPacket->IoStatus = 0;
                miniPacket->IoStatusInformation = 0xffffffff;

                KeInsertQueue( (PKQUEUE) ATQIoCompletionPort,
                                &miniPacket->ListEntry );

            } else {
                localIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            ObDereferenceObject( fileObject );
        }

        return localIoStatus.Status;
    }

#if USE_SPUD_COUNTERS
    BumpCount(CtrTransRecvSlowTrans);
#endif

    //
    // It looks like we will have to it the hard way
    // We will now build an irp for AFD
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the irp
    //

    irp = IoAllocateIrp( AfdDeviceObject->StackSize, TRUE );

    if (!irp) {
        ObDereferenceObject( fileObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SpudReqContext = ExAllocateFromNPagedLookasideList(
                         &SpudLookasideLists->ReqContextList);

    if (!SpudReqContext) {
        ObDereferenceObject( fileObject );
        IoFreeIrp( irp );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

#if STATUS_SUPPORTED
    KeInitializeSpinLock( &SpudReqContext->Lock );
#endif
    SpudReqContext->Signature = SPUD_REQ_CONTEXT_SIGNATURE;
    SpudReqContext->Irp = irp;
    SpudReqContext->AtqContext = reqContext;
    reqContext->KernelReqInfo = SpudReqContext;

    //
    // Allocate MDL for receive buffer and Probe and Lock it.
    //

    try {

        if (recvInfo != NULL) {
            SpudReqContext->IoStatus2.Information = recvInfo->BufferArray->len;
            SpudReqContext->Mdl = IoAllocateMdl( recvInfo->BufferArray->buf,
                                                recvInfo->BufferArray->len,
                                                FALSE,
                                                FALSE,
                                                NULL );

            if ( SpudReqContext->Mdl == NULL ) {
                ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
            }

            MmProbeAndLockPages( SpudReqContext->Mdl,
                                 requestorMode,
                                 IoWriteAccess );

        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ObDereferenceObject( fileObject );
        IoFreeIrp( irp );
        ExFreeToNPagedLookasideList( &SpudLookasideLists->ReqContextList,
                                     SpudReqContext );
        return GetExceptionCode();
    }

#if USE_SPUD_COUNTERS
    BumpCount(CtrTransRecvSlowRecv);
#endif

    IoSetCompletionRoutine( irp, SpudAfdContinueRecv, SpudReqContext, TRUE, TRUE, TRUE);

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID)NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL)NULL;
    irp->UserEvent = NULL;
    irp->UserIosb = &reqContext->IoStatus1;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    irpSp = IoGetNextIrpStackLocation( irp );

    majorFunction = (PULONG) (&irpSp->MajorFunction);
    *majorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->FileObject = fileObject;
    irpSp->Control = SL_INVOKE_ON_SUCCESS |
                     SL_INVOKE_ON_ERROR   |
                     SL_INVOKE_ON_CANCEL;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(AFD_TRANSMIT_FILE_INFO);
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_AFD_TRANSMIT_FILE;
    irp->UserBuffer = NULL;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = transmitInfo;

    IoCallDriver( AfdDeviceObject, irp );
    return STATUS_PENDING;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\spuddrv\oplock\tracelog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


#if IRP_DEBUG


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


typedef struct _TRACE_LOG {

    //
    // Signature.
    //

    LONG Signature;

    //
    // The total number of entries available in the log.
    //

    LONG LogSize;

    //
    // The index of the next entry to use.
    //

    LONG NextEntry;

    //
    // The byte size of each entry.
    //

    LONG EntrySize;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR LogBuffer;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

} TRACE_LOG, *PTRACE_LOG;


//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   ((LONG)'gOlT')
#define TRACE_LOG_SIGNATURE_X ((LONG)'golX')


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    );

VOID
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // IRP_DEBUG


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\httphdr\httphdr.cxx ===
/*++


   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       httphdr.cxx

   Abstract:
       This module defines the functions for handling the dictionary items.
       It contains custom implementation of dictionary for HTTP header parsing.

   Author:

       Murali R. Krishnan    ( MuraliK )     8-Nov-1996

   Environment:
       User Mode - Win32

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "httphdr.hxx"
# include <iis64.h>


// NYI:  Temporary copy for now
struct NAME_COLLECTION {
 LPCSTR pszName;
 INT    cchName;
};

# define HfmHeader( HfmId, HfmString)  { HfmString, (sizeof( HfmString) - 1) },

NAME_COLLECTION   g_HttpHeaders[] = {

    ALL_HTTP_FAST_MAP_HEADERS()
    { NULL, NULL}
};

# undef HfmHeader


# define NUM_HTTP_HEADERS (sizeof( g_HttpHeaders)/sizeof( g_HttpHeaders[0]) - 1)


# define  _HTTP_HEADER_SIG_CHARS    ( 32)

// SigBits avoids the upcase-low-case troubles.
# define  SigBits( ch)    ( (ch) & 0x1F)

# define  SigBit_I        ( ('I') & 0x1F)  // SigBit of I
# define  SigBit_U        ( ('U') & 0x1F)  // SigBit of U

//
// This header hash is specifically tailored for HTTP Headers in
//  ALL_HTTP_FAST_MAP_HEADERS()
//

inline int _HTTP_HEADER_HASH( LPCSTR psz, DWORD cchLen, DWORD sigChar)
{
    register DWORD ch = SigBits( (DWORD ) *psz);

    return (( ch * (sigChar/2)) +
            //            ((( SigBits( *psz) == SigBit_I) && (cchLen > 6)) ?
            // ((cchLen > 6) ? SigBits(psz[6]) :
            ((ch == SigBit_I && cchLen>6) ? SigBits(psz[6]) :
             (((ch == SigBit_U)?
               (cchLen) :
               SigBits( psz[cchLen/2])))
             )
            );
} // _HTTP_HEADER_HASH()


// extract the case-insetive bits for US-ASCII character set.
# define IcaseBits(ch)         ( (ch) & 0xDF)

// emulate stricmp by disregarding bit 5
inline BOOL _HTTP_HEADER_CHAR_I_NOTEQUAL( CHAR ch1, CHAR ch2)
{   return ( (IcaseBits(ch1)) != ( IcaseBits(ch2))); }


/*++
  I tried using the cached case-insensitive name for comparison
  using the _HTTP_HEADER_CHAR_I_NORMAL_1()
  but that requires more instructions since the x86 generated
  some unwanted instructions for access to memory :(
  x86 is smart to execute the above function _HTTP_HEADER_CHAR_I_NOTEQUAL()
   very well.
  --*/

// same as func _HTTP_HEADER_CHAR_I_NOTEQUAL()
// except that ch2 is already normalized
inline BOOL _HTTP_HEADER_CHAR_I_NOTEQUAL_1( CHAR ch1, CHAR ch2)
{   return ( (IcaseBits(ch1)) != ( ch2)); }



#if COMPRESSED_HEADERS
//
// Lookup table for compressed headers.
//

HTTP_FAST_MAP_HEADERS
CHeaderLUT[] =
{
    HM_ACC,                 //#A  // Accept:
    HM_MAX,                 //#B
    HM_MAX,                 //#C
    HM_MAX,                 //#D
    HM_MAX,                 //#E
    HM_MAX,                 //#F
    HM_MAX,                 //#G
    HM_AUT,                 //#H  // Authorization:
    HM_MAX,                 //#I
    HM_CON,                 //#J  // Connection:
    HM_MAX,                 //#K
    HM_MAX,                 //#L
    HM_MAX,                 //#M
    HM_CLE,                 //#N  // Content-Length:
    HM_MAX,                 //#O
    HM_MAX,                 //#P
    HM_MAX,                 //#Q
    HM_CTY,                 //#R  // Content-Type:
    HM_MAX,                 //#S
    HM_MAX,                 //#T
    HM_MAX,                 //#U
    HM_VIA,                 //#V
    HM_HST,                 //#W  // Host:
    HM_IMS,                 //#X  // If-Modified-Since:
    HM_MAX,                 //#Y
    HM_MAX,                 //#Z
    HM_MAX,                 //#a
    HM_MAX,                 //#b
    HM_MAX,                 //#c
    HM_MAX,                 //#d
    HM_MAX,                 //#e
    HM_MAX,                 //#f
    HM_MAX,                 //#g
    HM_PRA,                 //#h  // Proxy-Authorization:
    HM_MAX,                 //#i
    HM_RNG,                 //#j  // Range:
    HM_MAX,                 //#k
    HM_MAX,                 //#l
    HM_MAX,                 //#m
    HM_TEC,                 //#n  // Transfer-Encoding:
    HM_MAX,                 //#o
    HM_MAX,                 //#p
    HM_MAX,                 //#q
    HM_MAX,                 //#r
    HM_MAX,                 //#s
    HM_MAX,                 //#t
    HM_UMS                  //#u  // Unless-Modified-Since:

};

#endif

/************************************************************
 *    Functions
 ************************************************************/


HTTP_HEADER_MAPPER::~HTTP_HEADER_MAPPER( VOID)
{
    if ( NULL != m_rgOnNameMapper) {
        delete [] m_rgOnNameMapper;
        m_rgOnNameMapper = NULL;
    }

} // HTTP_HEADER_MAPPER::~HTTP_HEADER_MAPPER()

BOOL
HTTP_HEADER_MAPPER::Initialize( VOID)
{
    DWORD i;

    m_rgOnNameMapper = new int[ SizeOfNameMapper()];

    if ( NULL == m_rgOnNameMapper) {
        IF_DEBUG(ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                        "Allocation of Name Mapper of size %d failed\n",
                        SizeOfNameMapper()));
        }
        return FALSE;
    }

    // initialize the array of indexes
    for ( i = 0 ; i < SizeOfNameMapper() ; ++i ) {
        m_rgOnNameMapper[i] = -1; // set to invalid index
    }

    NAME_COLLECTION * pnc = g_HttpHeaders;

    for( pnc = g_HttpHeaders; pnc->pszName != NULL; pnc++) {


        int iN = _HTTP_HEADER_HASH(pnc->pszName, pnc->cchName, m_nSigChars);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF(( DBG_CONTEXT,
                        " _HTTP_HEADER_HASH( %s, len=%d, %d) => %d\n",
                        pnc->pszName, pnc->cchName, m_nSigChars, iN));
        }


        // We are using a very strict Algorithm for generating the mapping.
        // If the following assert fails, then someone has broken the algo's
        //   assumption, by adding a new entry. We have to find a new algo.
        // Algo's assumption: 1st char and next to last char are unique.
        // If not, modify the algo to use another pair or a different method
        //   (different hash function).

        if ((iN < 0)                              ||
            (((DWORD ) iN) >= SizeOfNameMapper()) ||
            (m_rgOnNameMapper[ iN] != -1)) {
            IF_DEBUG( ERROR) {
                DBGPRINTF(( DBG_CONTEXT,
                            " %08x::Initialize() OnName Mapper failed."
                            " Item (%s) indexes to location %d=>%d with (%s).\n",
                            this, pnc->pszName, iN,
                            m_rgOnNameMapper[iN],
                            g_HttpHeaders[ m_rgOnNameMapper[iN]].pszName
                            ));
            }

            // DBG_ASSERT( m_rgOnNameMapper[iN] == -1 );
            return ( FALSE);
        }

        // store the index here
        m_rgOnNameMapper[iN] = DIFF(pnc - g_HttpHeaders);

    } // for

    m_nItems = DIFF(pnc - g_HttpHeaders);

    return (TRUE);
} // HTTP_HEADER_MAPPER::Initialize()


BOOL
HTTP_HEADER_MAPPER:: FindOrdinal(
   IN LPCSTR pszName,
   IN INT    cchName,
   OUT DWORD * pdwOrdinal) const
{
    DBG_ASSERT( m_rgOnNameMapper);

    if ( cchName > 2 ) {


#if COMPRESSED_HEADERS

        if (*pszHeader == '#')
        {
            HM_ID       i;
            CHAR        c;

            c = pszHeader[1];
            if (c >= 'A')
            {
                i = CHeaderLUT[c - ( !(c & 0x20) ? 'A' : ('a' - ('Z' - 'A') - 1) )];

                *FieldIndex = i;

                return (i != HM_MAX);
            }

            return FALSE;

        }
#endif

        int iHash = _HTTP_HEADER_HASH( pszName, cchName, m_nSigChars);
        DBG_ASSERT( iHash >= 0);

        if (((DWORD ) iHash) >= SizeOfNameMapper()) {

            //
            // Out of bounds index value received for the index into our
            // lookup table => our hash calculator indicates this is not
            // a fast-mappable header => fail the FindOrdinal() call
            //

            return ( FALSE);
        }

        int i = m_rgOnNameMapper[iHash];

        //
        // The value from the m_rgOnNameMapper should be
        //  -1, if the header is not a fast-map header at all
        //  < NUM_HTTP_HEADERS if this is a valid fast-map header thus
        //    giving the index of the header in the header-mapper structure.
        //

        DBG_ASSERT( (i== -1) || (i < NUM_HTTP_HEADERS));

        if ( (i != -1) && (cchName == g_HttpHeaders[i].cchName) ) {

            LPCSTR pszFN = g_HttpHeaders[i].pszName;

            // let us use stride 2 and be pipeline friendly
            if ((cchName & 0x1)) {
                // odd length => eliminate the first char
                cchName--;
                if ( _HTTP_HEADER_CHAR_I_NOTEQUAL(
                        pszName[cchName],
                        pszFN[cchName] ) )
                {
                    return FALSE;
                }
            }


            DBG_ASSERT( (cchName % 2) == 0);
            while ( (cchName-= 2) >= 0 ) {

                if ( _HTTP_HEADER_CHAR_I_NOTEQUAL( pszName[cchName],
                                                   pszFN[cchName] ) ||
                     _HTTP_HEADER_CHAR_I_NOTEQUAL( pszName[cchName + 1],
                                                   pszFN[cchName + 1] )
                     )
                {
                    return FALSE;
                }
            } // while

            *pdwOrdinal = (DWORD ) i;
            return TRUE;
        }
    }

    return FALSE;
} // HTTP_HEADER_MAPPER::FindOrdinal()


LPCSTR
HTTP_HEADER_MAPPER::FindName( IN DWORD dwOrdinal) const
{
    DBG_ASSERT( dwOrdinal < NUM_HTTP_HEADERS );
    return ( g_HttpHeaders[dwOrdinal].pszName);

} // HTTP_HEADER_MAPPER::FindName()



VOID
HTTP_HEADER_MAPPER::PrintToBuffer( IN CHAR * pchBuffer,
                                   IN OUT LPDWORD pcch) const
{
    DWORD cb;
    DWORD i;

    DBG_ASSERT( NULL != pchBuffer);

    // 0. Print the location of this object
    // 1. Print all the <Name, ordinal> pairs
    // 2. Print the OnNameMapper values

    cb = wsprintfA( pchBuffer,
                    "HTTP_HEADER_MAPPER (%08x). NumItems= %d. NameColl= %08x"
                    " NSigChars= %d\n\n",
                    this, m_nItems, g_HttpHeaders, m_nSigChars
                    );

    for ( i = 0; i < NUM_HTTP_HEADERS; i++) {

        if ( cb + 80 < *pcch) {
            cb += wsprintfA( pchBuffer + cb,
                             " [%2d] @%4d\tLen=%-4d %-25s\n",
                             i,
                             _HTTP_HEADER_HASH( g_HttpHeaders[i].pszName,
                                                g_HttpHeaders[i].cchName,
                                                m_nSigChars),
                             g_HttpHeaders[i].cchName,
                             g_HttpHeaders[i].pszName
                             );

        } else {
            cb += 80;
        }
    } // for

    if ( cb + 60 < *pcch) {
        cb += wsprintfA( pchBuffer + cb, "\n Sizeof OnNameMapper = %d\n\n",
                         SizeOfNameMapper()
                         );
    } else {
        cb += 60;
    }

    if ( NULL != m_rgOnNameMapper) {

        for( i = 0; i < SizeOfNameMapper(); i++) {

            if ( (i % 20) == 0) {
                pchBuffer[cb++] = '\n';
                pchBuffer[cb] = '\0';
            }

            if ( cb + 5 < *pcch) {
                cb += wsprintfA( pchBuffer + cb,
                                 "%4d", m_rgOnNameMapper[ i]
                                 );
            } else {
                cb += 5;
            }
        } // for
    }


    if ( cb + 80 < *pcch) {
        cb += wsprintfA( pchBuffer+cb,
                         "\n   %d items stored in %d buckets. Density = %5d\n",
                         NUM_HTTP_HEADERS, SizeOfNameMapper(),
                         ( 10000 * NUM_HTTP_HEADERS)/SizeOfNameMapper()
                         );
    } else {
        cb += 80;
    }

    *pcch = cb;
    return;
} // HTTP_HEADER_MAPPER::PrintToBuffer( )


VOID
HTTP_HEADER_MAPPER::Print( VOID) const
{
    CHAR  pchBuffer[ 20000];
    DWORD cb = sizeof( pchBuffer);

    PrintToBuffer( pchBuffer, &cb);
    DBG_ASSERT( cb < sizeof(pchBuffer));

    DBGDUMP(( DBG_CONTEXT, pchBuffer));

    return;
} // HTTP_HEADER_MAPPER::Print()



/************************************************************
 *   HTTP_HEADERS
 ************************************************************/

#ifdef _PRIVATE_HTTP_HEADERS_TEST
HTTP_HEADER_MAPPER *
HTTP_HEADERS::QueryHHMapper(void)
{
   return ( &sm_hhm);

} // HTTP_HEADERS::QueryHHMapper()
# endif //  _PRIVATE_HTTP_HEADERS_TEST

inline VOID
UpdatePointer( IN OUT LPCSTR * ppsz, IN const CHAR * pchOld,
               IN DWORD cchLen, IN const CHAR * pchNew)
{
    if ( (*ppsz >= pchOld) &&
         (*ppsz < (pchOld + cchLen))
         ){

        IF_DEBUG( ERROR) {
            DBGPRINTF(( DBG_CONTEXT,
                        " Updating pointer [%08x] from %08x to %08x\n",
                        ppsz, *ppsz,  ((*ppsz - pchOld) + pchNew)));
        }

        // update the pointer
        *ppsz = ((*ppsz - pchOld) + pchNew);
    }
}

DWORD
NAME_VALUE_CHUNK::PrintToBuffer( IN CHAR * pchOut, IN OUT LPDWORD  pcchMax) const
{
    DBG_ASSERT( NULL != pchOut);
    DBG_ASSERT( NULL != pcchMax);

    NAME_VALUE_PAIR * pnv;
    DWORD cch = 0;

    if ( m_nPairs == 0) {
        *pcchMax = 0;
        return ( 0);
    }

    if ( 80 < *pcchMax) {
        cch = wsprintfA( pchOut, " NAME_VALUE_CHUNK: %08x;  NumPairs = %d\n",
                         this, m_nPairs);
    } else {
        cch = 80;
    }

    // Iterate over given pairs of name-value items and dump the output
    for ( pnv = (NAME_VALUE_PAIR *) m_rgNVP;
          pnv < ((NAME_VALUE_PAIR *) m_rgNVP) + m_nPairs;
          pnv++) {

        if ( pnv->pchName != NULL) {

            if ( (cch + pnv->cchName + pnv->cchValue + 3) < *pcchMax ) {
                pchOut[cch++] = '\t';
                CopyMemory( pchOut + cch, pnv->pchName, pnv->cchName);
                cch += pnv->cchName;
                pchOut[cch++] = '=';
                CopyMemory( pchOut + cch, pnv->pchValue, pnv->cchValue);
                cch += pnv->cchValue;
                pchOut[cch++] = '\n';
            } else {
                cch +=  pnv->cchName + pnv->cchValue + 3;
            }
        }
    } // for

    *pcchMax = cch;
    return (cch);
} // NAME_VALUE_CHUNK::PrintToBuffer()


BOOL
NAME_VALUE_CHUNK::AddEntry( IN const CHAR * pszHeader, IN DWORD cchHeader,
                            IN const CHAR * pszValue,  IN DWORD cchValue
                            )
{
    NAME_VALUE_PAIR  * pnp;

    DBG_ASSERT( IsSpaceAvailable());


    // Walk the array and pick the first location that is free.
    for ( pnp = (NAME_VALUE_PAIR * ) m_rgNVP;
          pnp < ((NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs);
          pnp++) {

        if ( NULL == pnp->pchName) {

            // Found a blank one. Fill up the contents.
            // NOTE: We are not making copies of the contents,
            // We are just storing the pointers.
            pnp->pchName  = pszHeader;
            pnp->cchName  = cchHeader;
            pnp->pchValue = pszValue;
            pnp->cchValue = cchValue;

            return (TRUE);
        }
    } // for

    if ( m_nPairs < MAX_HEADERS_PER_CHUNK) {

        // store it at the next available location.
        pnp = (NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs;
        m_nPairs++;
        pnp->pchName  = pszHeader;
        pnp->cchName  = cchHeader;
        pnp->pchValue = pszValue;
        pnp->cchValue = cchValue;
        return ( TRUE);
    }

    SetLastError( ERROR_INSUFFICIENT_BUFFER);
    return (FALSE);
} // NAME_VALUE_CHUNK::AddEntry()




NAME_VALUE_PAIR *
NAME_VALUE_CHUNK::FindEntry( IN const CHAR * pszHeader, IN DWORD cchHeader)
{
    NAME_VALUE_PAIR  * pnp;

    // Walk the array and pick the first location that is free.
    for ( pnp = (NAME_VALUE_PAIR * ) m_rgNVP;
          pnp < ((NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs);
          pnp++) {

        DBG_ASSERT( (cchHeader != pnp->cchName) || (pnp->pchName != NULL) );

        if ( (cchHeader == pnp->cchName) &&
             !_strnicmp( pszHeader, pnp->pchName, cchHeader)
             ) {

            return ( pnp);
        }
    } // for

    SetLastError( ERROR_NO_MORE_ITEMS);
    return ( NULL);
} // NAME_VALUE_CHUNK::FindEntry()



NAME_VALUE_PAIR *
NAME_VALUE_CHUNK::FindMatchingOrFreeEntry( IN const CHAR * pszHeader,
                                           IN DWORD   cchHeader,
                                           IN LPBOOL  pfFound )
{
    NAME_VALUE_PAIR  * pnp;

    DBG_ASSERT( pszHeader != NULL);
    DBG_ASSERT( pfFound != NULL);

    // Walk the array and pick the first location that is free.
    for ( pnp = (NAME_VALUE_PAIR * ) m_rgNVP;
          pnp < ((NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs);
          pnp++) {

        DBG_ASSERT( (cchHeader != pnp->cchName) || (pnp->pchName != NULL) );

        if ( (cchHeader == pnp->cchName) &&
             !_strnicmp( pszHeader, pnp->pchName, cchHeader)
             ) {

            *pfFound = TRUE;
            return ( pnp);
        }
    } // for

    if ( m_nPairs < MAX_HEADERS_PER_CHUNK) {

        // return the free entry
        DBG_ASSERT(((NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs) == pnp);
        *pfFound = FALSE;
        return ( pnp);
    }

    SetLastError( ERROR_NO_MORE_ITEMS);
    return ( NULL);
} // NAME_VALUE_CHUNK::FindMatchingOrFreeEntry()


BOOL
NAME_VALUE_CHUNK::UpdatePointers(
    IN const CHAR * pchOld,
    IN DWORD cchLen,
    IN const CHAR * pchNew)
{
    if ( m_nPairs > 0) {

        NAME_VALUE_PAIR  * pnp;

        // Walk the array and pick the first location that is free.
        for ( pnp = (NAME_VALUE_PAIR * ) m_rgNVP;
              pnp < ((NAME_VALUE_PAIR * ) m_rgNVP + m_nPairs);
              pnp++) {

            UpdatePointer( &pnp->pchName, pchOld, cchLen, pchNew);
            UpdatePointer( &pnp->pchValue, pchOld, cchLen, pchNew);
        } // for
    }
    return (TRUE);
} // NAME_VALUE_CHUNK::UpdatePointers()




//
// Declare the header mapper. For the existing set of headers,
//  use of 14X14 hash bucket is sufficient.
//
HTTP_HEADER_MAPPER  HTTP_HEADERS::sm_hhm(14);

BOOL
HTTP_HEADERS::Initialize( VOID)
{
    sm_hhm.SetSigChars( 14);
    if ( !sm_hhm.Initialize()) {

        IF_DEBUG( ERROR) {
            DBGPRINTF(( DBG_CONTEXT,
                        " HTTP_HEADERS::Initialize() failed. \n"
                        ));
        }

        return ( FALSE);
    }

    return ( TRUE);
} // HTTP_HEADERS::Initialize()



VOID
HTTP_HEADERS::Cleanup( VOID)
{
    // Currently there is no function to cleanup sm_hmm :(

} // HTTP_HEADERS::Cleanup()



HTTP_HEADERS::HTTP_HEADERS(VOID)
    : m_chNull      ( '\0'),
      m_buffHeaders (),
      m_iMaxFastMapHeader ( 0),
      m_cchHeaders  ( 0),
      m_cchBuffHeaders  ( 0)
{
    InitializeListHead( &m_ActiveList);
    InitializeListHead( &m_FreeList);

    IF_DEBUG( INIT_CLEAN) {

        DBGPRINTF(( DBG_CONTEXT, "HTTP_HEADERS() => %08x\n", this));
    }

    Reset();

} // HTTP_HEADERS::HTTP_HEADERS()


HTTP_HEADERS::~HTTP_HEADERS( VOID)
{
    NAME_VALUE_CHUNK *      pNVC = NULL;
    
    while ( !IsListEmpty( &m_FreeList ) )
    {
        pNVC = CONTAINING_RECORD( m_FreeList.Flink,
                                  NAME_VALUE_CHUNK,
                                  m_listEntry );
        RemoveEntryList( &pNVC->m_listEntry );
        delete pNVC;
    }

    while ( !IsListEmpty( &m_ActiveList ) )
    {
        pNVC = CONTAINING_RECORD( m_ActiveList.Flink,
                                  NAME_VALUE_CHUNK,
                                  m_listEntry );
        RemoveEntryList( &pNVC->m_listEntry );
        delete pNVC;
    }

    IF_DEBUG( INIT_CLEAN) {

        DBGPRINTF(( DBG_CONTEXT, "deleted HTTP_HEADERS %08x\n", this));
    }

} // HTTP_HEADERS::~HTTP_HEADERS()


VOID
HTTP_HEADERS::Reset( VOID)
{
    m_cchHeaders = 0;
    m_rcInlinedHeader[0] = '\0';

    m_cchBuffHeaders = 0;
    m_buffHeaders.Resize( HH_MIN);

    m_iMaxFastMapHeader = 0;
    ZeroMemory( m_rgpszHeaders, sizeof( m_rgpszHeaders));
    // We will skip setting the m_rgpszHeaders to be NULL.
    // the iMaxFastMapHeader does the necessary job for the same

    //
    // Move the Name-Value chunks from active list to the free-list.
    //
    while ( !IsListEmpty( &m_ActiveList)) {

        PLIST_ENTRY pl = m_ActiveList.Flink;
        RemoveEntryList( pl);
        InsertTailList( &m_FreeList, pl);
    } // while

    DBG_ASSERT( IsListEmpty( &m_ActiveList));
    DBG_CODE( InitializeListHead( &m_ActiveList)); // just paranoid!

    return;
} // HTTP_HEADERS::Reset()

VOID
HTTP_HEADERS::CancelHeader( IN LPCSTR    pszName)
{
    HTTP_FAST_MAP_HEADERS iField;
    DWORD cchName = strlen( pszName);

    // Find and store the header and value
    if ( sm_hhm.FindOrdinal( pszName, cchName, (LPDWORD ) &iField ) ) {

        FastMapCancel( iField);
    }  else {
        CancelHeaderInChunks( pszName, cchName);
    }

} // HTTP_HEADERS::CancelHeader()



BOOL
HTTP_HEADERS::StoreHeader(IN const CHAR * pszHeader, IN DWORD cchHeader,
                          IN const CHAR * pszValue,  IN DWORD cchValue
                          )
/*++
  This function is used to copy the header values instead of just
  storing the pointer values. This function can be used by filters to set/reset
  headers.
--*/
{
    HTTP_FAST_MAP_HEADERS iField;

    // Find and store the header and value
    if ( sm_hhm.FindOrdinal( pszHeader, cchHeader, (LPDWORD ) &iField ) ) {

        return ( FastMapStoreWithConcat( iField, pszValue, cchValue) );
    }
    else
    {
    return ( AddEntryToChunks( pszHeader, cchHeader, pszValue,  cchValue, TRUE));
    }
} // HTTP_HEADERS::StoreHeader()

BOOL
HTTP_HEADERS::StoreHeader(IN const CHAR * pszHeader,
                          IN const CHAR * pszValue
                          )
{
    return ( StoreHeader( pszHeader, strlen( pszHeader),
                          pszValue,  strlen( pszValue)
                          )
             );
} // HTTP_HEADERS::StoreHeader()


BOOL
HTTP_HEADERS::FastMapStoreWithConcat( IN HTTP_FAST_MAP_HEADERS hfm,
                                      IN LPCSTR pszValue, IN DWORD cchValue)
{
    // NYI: Following storage introduces fragmentation,
    //  which we do not care about for now :(

    return (ConcatToHolder( m_rgpszHeaders + hfm, pszValue, cchValue));

} // FastMapStoreWithConcat()



VOID
HTTP_HEADERS::PrintToBuffer( IN CHAR * pchBuffer, IN OUT LPDWORD pcchMax) const
{
    DWORD cb;
    PLIST_ENTRY pl;

    DBG_ASSERT( pchBuffer != NULL);
    DBG_ASSERT( pcchMax != NULL);

    // 0. Print the summary of the object
    // 1. Print all the Fast Map headers
    // 2. Print the rest of the headers

    if( 100 < *pcchMax) {
        cb = wsprintfA( pchBuffer,
                        "\nHTTP_HEADERS (%08x). cchHeaders = %d (buff = %d/%d)\n"
                        " Fast-Map headers:  MaxFastMapHeaders = %d\n"
                        ,
                        this, m_cchHeaders,
                        m_cchBuffHeaders, m_buffHeaders.QuerySize(),
                        FastMapMaxIndex()
                        );
    } else {
        cb = 100;
    }


    for ( DWORD i = 0; i < FastMapMaxIndex(); i++) {

        if ( m_rgpszHeaders[i] != NULL) {
            if ( cb + 200 < *pcchMax) {
                cb += wsprintfA( pchBuffer + cb,
                                 "\t%s = %s\n",
                                 sm_hhm.FindName( i),
                                 m_rgpszHeaders[i]
                                 );
            } else {
                cb += 200;
            }
        }
    } // for

    // Print all other headers starting with the cached 1st chunk
    DWORD cb1 = (cb < *pcchMax) ? *pcchMax - cb : 0;

    for ( pl =  m_ActiveList.Flink; pl != &m_ActiveList; pl = pl->Flink) {

        NAME_VALUE_CHUNK * pnvc =
            CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        cb1 = (cb < *pcchMax) ? *pcchMax - cb : 0;
        cb += pnvc->PrintToBuffer ( pchBuffer + cb, &cb1);
    } // for

    pchBuffer[cb] = '\0';

    //
    // Print the Raw header from buffer ... NYI
    //

    if ( cb + 2 < *pcchMax ) {
        lstrcat( pchBuffer + cb, "\n\n");
        cb += 2;
    } else {
        cb += 2;
    }

    *pcchMax = cb;

    return;
} // HTTP_HEADERS::PrintToBuffer()


BOOL
HTTP_HEADERS::UpdatePointers(
    IN const CHAR * pchOld,
    IN DWORD cchLen,
    IN const CHAR * pchNew)
{

    // REMOVE
    IF_DEBUG( ERROR) {
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::UpdatePointers( %08x, %d, %08x) - is costly\n",
                    this, pchOld, cchLen, pchNew));
    }

    DBG_ASSERT( pchOld != pchNew); // if this is true why call this function?

    // 1. Update the fast map pointers.
    LPCSTR * ppsz;
    for ( ppsz = m_rgpszHeaders;
          ppsz < (m_rgpszHeaders +  MAX_HTTP_FAST_MAP_HEADERS);
          ppsz++) {

        UpdatePointer( ppsz, pchOld, cchLen, pchNew);
    } // for

    // 3. Update pointers in the name-value chunk list
    PLIST_ENTRY pl;
    for ( pl =  m_ActiveList.Flink; pl != &m_ActiveList; pl = pl->Flink) {

        NAME_VALUE_CHUNK * pnvc =
            CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        // REMOVE
        DBGPRINTF(( DBG_CONTEXT,
                    "HH(%08x)::UpdatePointers( %08x, %d, %08x)"
                    " for the NVC %08x (pl = %08x)\n",
                    this, pchOld, cchLen, pchNew, pnvc, pl));

        pnvc->UpdatePointers( pchOld, cchLen, pchNew);
    } // for

    return ( TRUE);
} // HTTP_HEADERS::UpdatePointers()


BOOL
HTTP_HEADERS::MakeRoomInBuffer( IN DWORD cchReqd, IN LPCSTR * ppszVal)
{

    // REMOVE
    DBGPRINTF(( DBG_CONTEXT, "%08x:: MakeRoomInBuffer( %d, %08x). buff=%08x. size=%d\n",
                this, cchReqd, ppszVal,&m_buffHeaders, m_buffHeaders.QuerySize()));

    //
    // Bug 136637 : Because of the way we move our headers around when we get a new header
    // value for an existing header, it's really easy to chew up lots of memory rather 
    // quickly, so we'll artificially limit the size of the buffer to avoid denial-of-service
    // attacks. 
    // 
    if ( cchReqd > HH_MAX )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Reached max buffer size (%d), refusing request to resize buffer to %d bytes\n",
                   HH_MAX,
                   cchReqd));
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    if ( cchReqd > m_buffHeaders.QuerySize()) {

        // cache old pointer to update the other pointers properly
        LPSTR pszOld = (LPSTR ) m_buffHeaders.QueryPtr();

        if ( !m_buffHeaders.Resize( cchReqd, HH_GROW_BY)) {

            IF_DEBUG( ERROR) {
                DBGPRINTF(( DBG_CONTEXT, "%08x::Unable to allocate %d bytes\n",
                            this, cchReqd));
            }
            return ( FALSE);
        }

        DBG_ASSERT( cchReqd <= m_buffHeaders.QuerySize());
        LPSTR pszNew = (LPSTR ) m_buffHeaders.QueryPtr();
        if ( pszNew != pszOld) {

            // Trouble starts.
            // I have to update all the guys pointing inside the old blob
            // especially the pointers in
            //   the range (pszOld  to pszOld + m_cchBuffHeaders)

            UpdatePointer(ppszVal, pszOld, m_cchBuffHeaders, pszNew);

            // REMOVE
            DBGPRINTF(( DBG_CONTEXT, "%08x:: MakeRoomInBuffer( %d, %08x). buff=%08x. size=%d\n",
                        this, cchReqd, ppszVal,&m_buffHeaders, m_buffHeaders.QuerySize()));

            return ( UpdatePointers( pszOld, m_cchBuffHeaders, pszNew));
        }

        // We are just lucky to be able to have reallocated at same place.
    }

    return ( TRUE);
} // HTTP_HEADERS::MakeRoomInBuffer()


VOID
HTTP_HEADERS::Print( VOID)  const
{
    CHAR  pchBuffer[ 20000];
    DWORD cchMax = sizeof( pchBuffer);

    PrintToBuffer( pchBuffer, &cchMax);

    DBGDUMP(( DBG_CONTEXT, pchBuffer));

} // HTTP_HEADERS::Print()


CHAR *
HTTP_HEADERS::FindValue( IN LPCSTR pszName, OUT LPDWORD pcchValue)
{
    DWORD cchName = strlen( pszName);
    HTTP_FAST_MAP_HEADERS iField;

    //
    //  1. Lookup in the fast map for this item
    //

    if ( sm_hhm.FindOrdinal( pszName, cchName, (LPDWORD ) &iField)) {

        // found in the fast-map.
        CHAR * pszValue = (CHAR * ) FastMapQueryValue( iField);

        if ( pcchValue != NULL) {
            *pcchValue = (( pszValue != NULL) ? strlen( pszValue) : 0);
        }

        return ( pszValue);
    }

    // 2. Search in the slow list - name-value-chunks
    NAME_VALUE_PAIR * pnp = FindValueInChunks( pszName, cchName);

    if ( pnp != NULL) {

        if ( pcchValue != NULL) {
            DBG_ASSERT( pnp->pchValue != NULL);
            *pcchValue = pnp->cchValue;
        }

        return ( (CHAR *) pnp->pchValue);
    }

    return ( NULL);
} // HTTP_HEADERS::FindValue()


NAME_VALUE_PAIR *
HTTP_HEADERS::FindValueInChunks( IN LPCSTR  pszName, IN DWORD cchName)
{
    PLIST_ENTRY pl;
    NAME_VALUE_PAIR * pnp = NULL;

    // find a Name-value-pair/chunk that holds this entry.
    for ( pl = m_ActiveList.Flink;
          (pl != &m_ActiveList);
          pl = pl->Flink) {

        NAME_VALUE_CHUNK *
            pnc = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        pnp = pnc->FindEntry( pszName, cchName);

        if ( NULL != pnp) {
            // we found the required name-value-pair.stop searching
            break;
        }
    } // for

    return ( pnp);
} // HTTP_HEADERS::FindValueInChunks()


VOID
HTTP_HEADERS::CancelHeaderInChunks( IN LPCSTR pszName, IN DWORD cchName)
{
    PLIST_ENTRY pl;
    NAME_VALUE_PAIR * pnp = NULL;
    NAME_VALUE_CHUNK * pnc;

    // NYI:  This function can benefit from better implementation
    //  instead of moving memory around.
    // Since the freq. of use of this func is less, we will not optimize :(

    // find the Name-value-pair/chunk that holds this entry.
    for ( pl = m_ActiveList.Flink;
          (pnp == NULL) && (pl != &m_ActiveList);
          pl = pl->Flink) {

            pnc = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        pnp = pnc->FindEntry( pszName, cchName);
    } // for

    if ( pnp != NULL) {

        // pnp - current item
        // pnc - the current chunk

        // to cancel the item, just left-shift the array of
        //  NAME_VALUE_PAIRS in the chunk and reset the m_nPairs value

        DBG_ASSERT( (pnp >= pnc->m_rgNVP) &&
                    (pnp < pnc->m_rgNVP + pnc->m_nPairs));

        DBG_ASSERT( (pnc->m_nPairs  - (pnp - pnc->m_rgNVP)) >= 1 );
        MoveMemory( pnp, (pnp + 1),
                    ((pnc->m_nPairs - 1 - (pnp - pnc->m_rgNVP)) *
                     sizeof( NAME_VALUE_PAIR))
                    );
        pnc->m_nPairs--;

        // NYI:  if pnc->m_nPairs == 0,
        // we can move this away from the active list
    }

    return;
} // CancelHeaderInChunks()



BOOL
HTTP_HEADERS::NextPair( IN OUT HH_ITERATOR *   phi,
                        OUT NAME_VALUE_PAIR ** ppnp
                        )
{
    DBG_ASSERT( phi );
    DBG_ASSERT( ppnp );

    if ( phi->dwOrdinal < FastMapMaxIndex()) {

        // Iterate over the FastMap headers ...
        for ( DWORD i = phi->dwOrdinal; i < FastMapMaxIndex(); i++ ) {
            if ( m_rgpszHeaders[i] != NULL) {

                NAME_VALUE_PAIR * pnp = &phi->np;
                // found a non-NULL value.

                pnp->pchValue = m_rgpszHeaders[i];
                pnp->pchName  = sm_hhm.FindName( i);

                // NYI: It will be nice to get the length directly :(
                pnp->cchName = strlen( pnp->pchName);
                pnp->cchValue= strlen( pnp->pchValue);
                phi->dwOrdinal = i + 1;
                *ppnp = pnp;
                return ( TRUE);
            }
        } // for

        // we exhausted the fast-map. Fall through after updating Ordinal
        phi->dwOrdinal = (i);
    }

    //
    // Find the pair in the chunk
    //

    return ( NextPairInChunks( phi, ppnp));
} // HTTP_HEADERS::NextPair()


BOOL
HTTP_HEADERS::NextPairInChunks( IN OUT HH_ITERATOR *   phi,
                                OUT NAME_VALUE_PAIR ** ppnp
                                )
{
    DBG_ASSERT( phi);
    DBG_ASSERT( ppnp);
    DBG_ASSERT( phi->dwOrdinal >= FastMapMaxIndex());
    PLIST_ENTRY pl;

    do {

        PLIST_ENTRY pl = (PLIST_ENTRY ) phi->pChunk;
        if ( pl == &m_ActiveList) {
            break;
        }

        NAME_VALUE_CHUNK * pnc =
            (NAME_VALUE_CHUNK *) CONTAINING_RECORD( pl, NAME_VALUE_CHUNK,
                                                    m_listEntry);
        while ( phi->dwPair < pnc->m_nPairs) {

            // extract the current pair, update pair pointer and return
            *ppnp = (NAME_VALUE_PAIR *) (pnc->m_rgNVP + phi->dwPair);
            phi->dwPair++;

            if ( (*ppnp)->pchName ) {
                return ( TRUE);
            }
        }

        // we could not find any in the current chunk. Move to next chunk.
        phi->pChunk = (PVOID)pnc->m_listEntry.Flink;
        phi->dwPair = 0;  // pair # within the chunk
    } while ( TRUE);

    SetLastError( ERROR_NO_MORE_ITEMS);
    return ( FALSE);
} // HTTP_HEADERS::NextPairInChunks()



BOOL
HTTP_HEADERS::AddEntryToChunks(
    IN const CHAR * pszHeader,
    IN DWORD        cchHeader,
    IN const CHAR * pszValue,
    IN DWORD        cchValue,
    BOOL            fCopyValue
    )
/*++
  This function stores the <header, value> pair for headers not found
  in the fast-map. It checks to see if the header already exists
  with some value. If it does, then the new value is just concatenated
  to the old one. Else the new value is stored separately in the first
  available free chunk.

  If there is no free chunk available, this function also allocates a free
  chunk and stores the data in the new chunk.
--*/
{
    // Store the header that is not part of the Fast Map

    PLIST_ENTRY pl;
    NAME_VALUE_CHUNK * pnc;
    NAME_VALUE_PAIR  * pnp;
    NAME_VALUE_CHUNK * pncFirst = NULL;
    NAME_VALUE_PAIR  * pnpFirst = NULL;
    BOOL fRet = FALSE;

    // find a Name-value-pair/chunk that can hold this entry.
    for ( pl = m_ActiveList.Flink;
          (pl != &m_ActiveList);
          pl = pl->Flink)
    {
        BOOL fFound = FALSE;

        pnc = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        pnp = pnc->FindMatchingOrFreeEntry( pszHeader, cchHeader, &fFound);

        //
        // Found a matching entry, so update
        //
    
        if ( fFound )
        {
            DBG_ASSERT( pnp != NULL);

            // pnc points to the chunk containing the matched item
            // pnp points to the exact pair that matched up

            DBG_ASSERT( (pnp->cchName == cchHeader) &&
                        (!_strnicmp( pnp->pchName, pszHeader, cchHeader))
                        );

            IF_DEBUG( ERROR)
            {
                DBGPRINTF(( DBG_CONTEXT, "Match For (%s) found at PNP=%08x\n",
                            pszHeader, pnp));
            }

            // Concat the given value to the existing value element.
            // Nothing more needs to be done
        
            fRet = ConcatToHolder( &pnp->pchValue, pszValue, cchValue);
            if  ( fRet)
            {
                // update the length of the datum.
                pnp->cchValue += (1 + cchValue);  // 1 for the ',' concat sign.
            }
            return ( fRet);
        }
        else if ( pnp != NULL && pncFirst == NULL)
        {
            // cache it for later use, if header is never found
            pncFirst = pnc;
            pnpFirst = pnp;
        }
    } // for

    if (pncFirst == NULL )
    {
        // No match found. No free chunk is available.
        // Pull a new one from free list or create one
        if ( IsListEmpty( &m_FreeList))
        {
            pncFirst = new NAME_VALUE_CHUNK();
            if ( NULL == pncFirst)
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
                return ( FALSE);
            }
        }
        else
        {
            // pull one from the free list and use it.
            pl = m_FreeList.Flink;
            RemoveEntryList( pl);
            pncFirst = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);
            pncFirst->Reset();
        }

        InsertTailList( &m_ActiveList, &pncFirst->m_listEntry);
        DBG_ASSERT( pncFirst->m_nPairs == 0);
        pnpFirst =  ((NAME_VALUE_PAIR * ) pncFirst->m_rgNVP);
    }

    //
    // At this point, we know it's a new header, so store the new <header, value> pair
    // in pnp and increment count of pairs.
    //

    DBG_ASSERT( NULL != pncFirst);
    DBG_ASSERT( NULL != pnpFirst);

    //
    // Sometimes, we need to make a copy of the header eg when the header to be added
    // comes from a filter. At other times, we can just store a copy of the pointer,
    // because we know it'll be valid for the duration of the use of the data structure
    //

    if (fCopyValue)
    {
        //
        // Copy actual values : ConcatToHolder assumes first parameter points to NULL
        // if it's a new value to be stored
        //

        //
        // Copy the header name
        //
        pnpFirst->pchName = NULL;
        fRet = ConcatToHolder(&pnpFirst->pchName, pszHeader, cchHeader);

        if (fRet)
        {
            pnpFirst->cchName  = cchHeader;
        }
        else
        {
            return FALSE;
        }

        //
        //Copy the header value
        //
        pnpFirst->pchValue = NULL;
        fRet = ConcatToHolder(&pnpFirst->pchValue, pszValue, cchValue);

        if (fRet)
        {
            pnpFirst->cchValue = cchValue;

            if ( pnpFirst == (NAME_VALUE_PAIR * ) pncFirst->m_rgNVP + pncFirst->m_nPairs )
            {
                pncFirst->m_nPairs++;
            }
        }
        else
        {
            pnpFirst->pchName = NULL;
            return FALSE;
        }
    }
    else
    {
        //
        // Just copy pointer to value
        //
        pnpFirst->pchName = pszHeader;
        pnpFirst->cchName = cchHeader;
        pnpFirst->pchValue = pszValue;
        pnpFirst->cchValue = cchValue;

        if ( pnpFirst == (NAME_VALUE_PAIR * ) pncFirst->m_rgNVP + pncFirst->m_nPairs )
        {
            pncFirst->m_nPairs++;
        }
        fRet = TRUE;
    }

    DBG_ASSERT( pncFirst->m_nPairs <= MAX_HEADERS_PER_CHUNK);

    return ( fRet );
} // HTTP_HEADERS::AddEntryToChunks()



BOOL
HTTP_HEADERS::ConcatToHolder( IN LPCSTR * ppsz,
                              IN LPCSTR pszNew,
                              IN DWORD  cchNew
                              )
/*++

  Given an internal pointer ppsz of the HTTP_HEADERS object,
   this function appends the new value to the old value present
   using ',' as the concatenation character.

  It automatically allocates room and grows buffers, updates pointers, etc
   if need be.

--*/
{
    BOOL fRet = TRUE;
    LPCSTR pszOld = *ppsz;
    DWORD  cchOld = pszOld ? strlen( pszOld) : 0;
    DWORD  cchReqd = cchOld + cchNew + 2;

    // Find if we have enough space in the inlined buffer
    if ( ( m_cchHeaders + cchReqd < sizeof( m_rcInlinedHeader))
         ) {

        // Aha we are lucky. Make a copy at the end and form concatenated result
        *ppsz = m_rcInlinedHeader + m_cchHeaders;
        m_cchHeaders += cchReqd;
    } else {

        // Clearly we do not have room in the Inlined Header,
        //  store the stuff in the aux buffer area.

        // Find if space is sufficient.
        //  This will automatically alloc and update pointers
        if ( MakeRoomInBuffer( (m_cchBuffHeaders + cchReqd), &pszNew)
             ){

            pszOld = *ppsz;  // get the new pointer (since it could have moved)
            LPSTR pszBuf = (LPSTR ) m_buffHeaders.QueryPtr();

            // we have space at the end of the buffer here. Use this space.
            *ppsz = pszBuf + m_cchBuffHeaders;
            m_cchBuffHeaders += cchReqd;
        } else {

            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create room for %d characters \n",
                        m_cchBuffHeaders + cchOld + cchNew + 3));
            return ( FALSE);
        }
    }

    if ( !cchOld )
    {
        CopyMemory( (PVOID) (*ppsz), pszNew, cchNew + 1 );
    }
    else
    {
        // Format the value as :=  <old> ',' <new>
        CopyMemory( (PVOID ) *ppsz, pszOld, cchOld);
        ((CHAR *) *ppsz)[cchOld] = ','; // concat character
        CopyMemory( (PVOID ) (*ppsz + cchOld + 1), pszNew, cchNew + 1);
    }

    DBG_ASSERT( fRet == TRUE);
    return ( fRet);
} // HTTP_HEADERS::ConcatToHolder()


/**************************************************
 *  PARSER for the HTTP_HEADERS
 **************************************************/

inline const CHAR *
SkipLeadingWhiteSpace( IN const CHAR * pchStart, IN DWORD cchLen)
{
    const CHAR * pchScan;

    for ( pchScan = pchStart;
          ((pchScan < (pchStart + cchLen)) && isspace( (UCHAR)(*pchScan)));
          pchScan++)
        ;

    return ( pchScan);
} // SkipLeadingWhiteSpace()

BOOL
HTTP_HEADERS::ParseHeaderFirstLine( IN const CHAR * pchFirstLine,
                                    IN CHAR * pchScan,
                                    IN DWORD cchFirstLine)
/*++
  Description:
    Extract the HTTP method, URL, & HTTP-version strings from the first
    line of header block.
    Input:  <Method> <URL> HTTP/<Version>
    Use <blank> or <tab> as the delimiter.
    NYI:  What about other delimiters?

    We will do only forward scans, because
     1) the header can be malformed
     2) HTTP/0.9 requests do not contain the version string
     3) there may be more than 3 parameters on the first line.
    In all the above cases reverse scans will cause trouble.

    Note that a line termination can be by using \r\n or just \n :(

  Arguments:
    pchFirstLine - pointer to character stream containing the
                   first char of the line
    pchScan      - points to the end of the first line.
    cchFirstLine - count of characters on the first line

  Returns:
    TRUE on success & FALSE for failure.
    Use GetLastError() to get correct Win32 error code on failure.
--*/
{
    LPSTR      pszScan2;
    pszScan2 = (LPSTR ) memchr ( pchFirstLine, ' ', cchFirstLine);

    if ( NULL != pszScan2) {

        LPSTR pszScan3;

        *pszScan2++ = '\0';  // replace the blank with a null char

        while ( _HTTP_IS_LINEAR_SPACE( *pszScan2 ) )
        {
            ++pszScan2;
        }

        //
        //  pszScan2 now points to the URL sent
        //

        DWORD cReq = DIFF(pchScan - pszScan2);
        pszScan3 = (LPSTR ) memchr( pszScan2, ' ', cReq);

        if ( NULL != pszScan3 ) {

            *pszScan3++ = '\0';

            while ( _HTTP_IS_LINEAR_SPACE( *pszScan3 ) )
            {
                ++pszScan3;
            }

            // pszScan3 should be now pointing to start of version info

            // Note that we are not removing spaces between the version
            // and the line delimiter

            pchScan[(( (pchScan > pszScan3) && (pchScan[-1] == '\r')) ?
                     -1: 0)] = '\0';
        } else {

            // only 2 parameters. No version is present.
            //  Point pszScan3 to the null-part of pszScan2)

            pszScan3 =
                pchScan + ((pchScan[-1] == '\r') ? -1 : 0);
            *pszScan3 = '\0';
        }

        //
        // We know that we are parsing a new request.
        // So we are not checking for concat during fast-map store here.
        //
        FastMapStore( HM_VER, pszScan3);
        FastMapStore( HM_URL, pszScan2 );
        FastMapStore( HM_MET, pchFirstLine);
    } else {

        IF_DEBUG( ERROR) {
            DBGPRINTF(( DBG_CONTEXT,
                        " The scan for fields where they are not separated "
                        " with space is intentionally left out!\n"
                        ));
        }
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // everything is happy here ... return success
    //
    return ( TRUE);

} // HTTP_HEADERS::ParseHeaderFirstLine()



BOOL
HTTP_HEADERS::ParseInput( IN const CHAR * pchHeaderBlob,
                          IN DWORD        cchLen,
                          OUT DWORD *     pcbExtraData
                          )
/*++
  Description:
    This function parses the input string and extracts the HTTP headers
    for storage inside the http header structure. Fast-map headers are stored
    in the dedicated fast-map storage area. Non-standard headers (that are
    not part of) fast-map are stored inside the Name-value chunks.

    The Grammar for incoming HTTP headers is:

       <HTTP-verb>  <URL>  <HTTP-version>
       {<Header-Name>:<Header-Value> { {\r\n} | {\n}}}*

     where,
       <HTTP-verb>     == A+
       <URL>           == /[A|D]*
       <HTTP-version>  == HTTP/D+.D+
       <Header-Name>   == A[A|D]*
       <Header-Value>  == [A|D]*
       <CRLF>          == \r\n
       A               == any ascii character except ' ' '\t' '\n' '\r'
       D               == 0-9

  Arguments:
    pchHeaderBlob - pointer to header containing the header blob (+ maybe
                      the body of the request).
    cchLen        - length of the header block alone.
    pcbExtraData  - pointer to a DWORD which on return will contain the
                      number of extra characters of data present in the
                      blob given.

  Returns:
    TRUE on successfully parsing and splitting the headers apart.
    FALSE if there is any failure.
--*/
{
    CHAR *    pchScan;
    CHAR *    pchRequest;
    DWORD     cReq;

    IF_DEBUG( INIT_CLEAN)
    {
        DBGPRINTF(( DBG_CONTEXT, "%08x::ParseInput( %08x:, %d) \n"
                    "Input Headers:\n%s\n",
                    this, pchHeaderBlob, cchLen, pchHeaderBlob));
    }

    //
    // 1. Skip all the leading spaces and ignore them all.
    //   We do not need these fields
    //

    pchScan = (CHAR *) SkipLeadingWhiteSpace( pchHeaderBlob, cchLen);
    cchLen -= DIFF(pchScan - pchHeaderBlob);

    //
    // 2. Make a copy of the incoming header blob so that we can own the
    //    input headers and munge it in our own fashion
    //  NYI: One can optimize this by selectively copying segments that
    //    are worth using (values), but that will be costly due to
    //    multiple small CopyMemory() operations.
    //
    if ( cchLen < sizeof( m_rcInlinedHeader)) {

        pchRequest = (CHAR * ) m_rcInlinedHeader;
        m_cchHeaders = cchLen;

    } else {

        if ( !m_buffHeaders.Resize( cchLen + 4, HH_GROW_BY)) {
            return ( FALSE);
        }

        pchRequest = (CHAR * ) m_buffHeaders.QueryPtr();
        m_cchBuffHeaders = cchLen;
    }

    // 2a. copy the header to the buffer
    CopyMemory( (PVOID ) pchRequest, pchScan, cchLen);

    //
    // pchRequest points to the local copy of the request headers
    //

    DBG_ASSERT( (pchRequest == m_rcInlinedHeader) ||
                (pchRequest == m_buffHeaders.QueryPtr())
                );

    //
    // 3. Get the first line and extract the method string
    //
    pchScan = (CHAR * ) memchr( pchRequest, '\n', cchLen);

    if ( pchScan == NULL ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // 4. Extract the Method, URL and Version Number
    //

    if ( !ParseHeaderFirstLine( pchRequest, pchScan, DIFF(pchScan - pchRequest))) {

        return ( FALSE);
    }

    //
    // 5. Extract all other headers
    //

    LPSTR pszHeader = pchScan + 1;
    cReq = DIFF(pchRequest + cchLen - pszHeader);
    LPSTR pchEnd = pszHeader + cReq;
    LPSTR pszEol, pszValue;

    //
    // pszHeader ( and thus pszEnd & pszEol ) are relative to pchRequest.
    // This needs to be preserved in this loop.
    //

    for ( ; (*pszHeader != '\r' || (cReq > 1 && *(pszHeader + 1) != '\n')) &&
            (*pszHeader != '\n') &&
            (pszValue = (LPSTR)memchr( pszHeader, ':', cReq ));
          pszHeader = (pszEol + 1), cReq = DIFF(pchEnd - pszHeader)
          )
    {
        UINT chN = (UINT)(*(PBYTE)++pszValue);

        //            *pszValue = '\0';
        int cchHeader = DIFF(pszValue - pszHeader);

        pszEol = (LPSTR ) memchr( pszValue, '\n', cReq - cchHeader);

        if ( NULL == pszEol ) {

            //
            // Aha! we found a completely malformed header block here.
            // Let us return a failure to the caller.
            //

            IF_DEBUG( ERROR) {
                DBGPRINTF(( DBG_CONTEXT,
                            " The scan for header-value blocks found a line"
                            " not properly terminated with \'\\n\'\n"
                            ));
            }
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        DBG_ASSERT( NULL != pszEol );

        DWORD  cchValue;
        DWORD  iField;

        // skip spaces if any.
        if ( _HTTP_IS_LINEAR_SPACE( (CHAR)chN ) )
        {
            while ( _HTTP_IS_LINEAR_SPACE( (CHAR)(*(PBYTE)++pszValue) ) )
                ;
        }

        // Terminate the value string
        if ( (pszEol > pszValue) && (pszEol[-1] == '\r') )
        {

            pszEol[-1] = '\0';
            cchValue = DIFF(pszEol - pszValue - 1);

        }
        else
        {

            pszEol[0] = '\0';
            cchValue = DIFF(pszEol - pszValue);
        }

        IF_DEBUG( INIT_CLEAN )
        {
            DBGPRINTF((DBG_CONTEXT, "\t[%s] = %s\n", pszHeader, pszValue ));
        }

        {  // Store the header - inline to reduce cost

            HTTP_FAST_MAP_HEADERS iField;
            BOOL  fRet = TRUE;

            // Find and store the header and value
            if ( sm_hhm.FindOrdinal( pszHeader, cchHeader,
                    (LPDWORD ) &iField ) )
            {

                if ( FastMapQueryValue(iField) == NULL )
                {

                // Store the item and continue scan for next header
                FastMapStore( iField, pszValue);
                continue;

                }
                else
                {
                    // FastMapStoreWithConcat can resize the header
                    // buffer. If the headers we're scanning are
                    // coming out of the header buffer, we'll need
                    // to update pszHeader later, so save the current
                    // pointer just in case.

                    CHAR        *pOldBuff = (CHAR *)m_buffHeaders.QueryPtr();

                    fRet =  FastMapStoreWithConcat( iField, pszValue,
                                                            cchValue);

                    if ( !fRet)
                    {

                        IF_DEBUG( ERROR)
                        {

                            DBGPRINTF(( DBG_CONTEXT, "Failed to StoreHeader %s"
                                "in fast map with concat\n",
                                pszHeader));
                        }

                        return ( FALSE);
                    }

                    // See if the buffer has changed. If it has,
                    // update the end pointer and the eol pointer. pszHeader
                    // gets updated at the end of the loop from pszEol. Be
                    // careful if you try and use any other pointers between
                    // here and the end of the loop.
                    // We update these pointers only if they were already pointing
                    // in alloced buffer space ( i.e. not using the m_rcInlinedHeader buffer )

                    if (pOldBuff != (CHAR *)m_buffHeaders.QueryPtr() &&
                        pOldBuff == pchRequest )
                    {
                        // Buffer got resized, fix up appropriate pointers.

                        pchEnd = (CHAR *)m_buffHeaders.QueryPtr() +
                                (pchEnd - pchRequest);
                        pszEol = (CHAR *)m_buffHeaders.QueryPtr() +
                                (pszEol - pchRequest);
                        pchRequest = (CHAR *)m_buffHeaders.QueryPtr();
                    }
                }
            }
            else
            {
                // AddEntry to chunks also has resizing buffer issues. See
                // comments above.

                CHAR        *pOldBuff = (CHAR *)m_buffHeaders.QueryPtr();

                fRet = AddEntryToChunks( pszHeader, cchHeader, pszValue,
                                            cchValue);
                if ( !fRet)
                {
                    IF_DEBUG( ERROR)
                    {

                    DBGPRINTF(( DBG_CONTEXT,
                        "Failed to StoreHeader %s in chunks\n",
                        pszHeader));
                    }
                    return ( FALSE);
                }

                if (pOldBuff != (CHAR *)m_buffHeaders.QueryPtr() &&
                    pOldBuff == pchRequest )
                {
                    // Buffer got resized, fix up appropriate pointers.

                    pchEnd = (CHAR *)m_buffHeaders.QueryPtr() +
                            (pchEnd - pchRequest);
                    pszEol = (CHAR *)m_buffHeaders.QueryPtr() +
                            (pszEol - pchRequest);
                    pchRequest = (CHAR *)m_buffHeaders.QueryPtr();
                }
            }
        }

    } // for()

    if ( (*pszHeader == '\r') || (*pszHeader == '\n') )
    {

        // blank header line - end of the parsing
        while ( cReq )
        {
            --cReq;
            if ( *pszHeader++ == '\n' )
            {
                break;
            }
        }
    }

    *pcbExtraData = DIFF(pchEnd - pszHeader);

    return ( TRUE);

} // HTTP_HEADERS::ParseInput()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\icrypt\lib\base.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    base.cxx

Abstract:

    This module implements the IIS_CRYPTO_BASE class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_CRYPTO_BASE::IIS_CRYPTO_BASE()

/*++

Routine Description:

    IIS_CRYPTO_BASE class constructor. Just sets the member variables
    to known values; does nothing that can actually fail. All of the
    hard work is in the Initialize() method.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Set the handles to known values so we know what to cleanup
    // in the destructor.
    //

    m_hProv = CRYPT_NULL;
    m_fCloseProv = FALSE;
    m_hKeyExchangeKey = CRYPT_NULL;
    m_hSignatureKey = CRYPT_NULL;

}   // IIS_CRYPTO_BASE::IIS_CRYPTO_BASE


IIS_CRYPTO_BASE::~IIS_CRYPTO_BASE()

/*++

Routine Description:

    IIS_CRYPTO_BASE class destructor. Performs any necessary cleanup.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Close any open keys.
    //

    CLOSE_KEY( m_hSignatureKey );
    CLOSE_KEY( m_hKeyExchangeKey );

    //
    // Close the container.
    //

    if( m_fCloseProv && m_hProv != CRYPT_NULL ) {
        (VOID)::IISCryptoCloseContainer( m_hProv );
        m_hProv = CRYPT_NULL;
    }

}   // IIS_CRYPTO_BASE::~IIS_CRYPTO_BASE


HRESULT
IIS_CRYPTO_BASE::GetCryptoContainerByName(
    OUT HCRYPTPROV * phProv,
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags,
    IN BOOL fApplyAcl
    )

/*++

Routine Description:

    Creates or opens the specified crypto container. This method plays
    games to ensure the container can be opened regardless of the
    current security impersonation context.

Arguments:

    phProv - Receives the handle to the provider.

    pszContainerName - The name of the container to open/create. 
                       (NULL means temporary container)

    dwAdditionalFlags - Flags to pass into IISCryptoGetStandardContainer().

    fApplyAcl - If TRUE, then an ACL is applied to the container.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    HANDLE token = NULL;
    BOOL resetToken = FALSE;

    //
    // Sanity check.
    //

    DBG_ASSERT( phProv != NULL );


    //
    // If the caller is not already asking for CRYPT_MACHINE_KEYSET
    // *and* the current process is running in the local system context,
    // then forcibly set CRYPT_MACHINE_KEYSET and note that we need to
    // apply an ACL to the container. This is to workaround an issue
    // with the NT5 Protected Storage service that causes the client-side
    // containers to fail after NT5 GUI Setup. Apparently, there is some
    // as-yet unidentified interaction between creating the client-side
    // container under NT5 GUI Setup (which runs in the Local System
    // security context) and later attempts to create containers in
    // lesser security contexts.
    //

    if( !( dwAdditionalFlags & CRYPT_MACHINE_KEYSET ) ) {
        if( AmIRunningInTheLocalSystemContext() ) {
            dwAdditionalFlags |= CRYPT_MACHINE_KEYSET;
            fApplyAcl = TRUE;
        }
    }

    //
    // Step 1: Just try to open/create the container.
    //

    result = ::IISCryptoGetContainerByName(
                   phProv,
                   pszContainerName,
                   dwAdditionalFlags,
                   fApplyAcl
                   );

    if( SUCCEEDED(result) ) {
        goto complete;
    }

    //
    // NTE_BAD_KEYSET is typically returned when the caller has
    // insufficient privilege to access the key container registry
    // tree. If we failed for any other reason, bail.
    //

    if( result != NTE_BAD_KEYSET ) {
        goto complete;
    }

    //
    // Step 2: If the caller didn't ask for CRYPT_MACHINE_KEYSET, then
    // retry the operation with this flag set.
    //

    if( ( dwAdditionalFlags & CRYPT_MACHINE_KEYSET ) == 0 ) {

        result = ::IISCryptoGetContainerByName(
                       phProv,
                       pszContainerName,
                       dwAdditionalFlags | CRYPT_MACHINE_KEYSET,
                       fApplyAcl
                       );

        if( SUCCEEDED(result) ) {
            goto complete;
        }

    }

    //
    // OK, now things get a bit complex.
    //
    // If the current thread has an impersonation token, then
    // (temporarily) remove it and retry the container operation.
    // This is mainly here so that ISAPI applications (like, say, ASP)
    // can access the DCOM interface while impersonating a non-privileged
    // security context.
    //
    // Note that, after we remove the impersonation token, we first try
    // the operation with CRYPT_MACHINE_KEYSET ORed in. We do this on
    // the assumption that, if the thread had an impersonation token,
    // then we're probably running in the context of a server process.
    // If this operation fails, we try again without forcing the flag.
    //

    result = GetThreadImpersonationToken( &token );

    if( FAILED(result) ) {
        goto complete;
    }

    if( token != NULL ) {

        result = SetThreadImpersonationToken( NULL );

        if( FAILED(result) ) {
            goto complete;
        }

        resetToken = TRUE;

        //
        // Step 3: With the token removed, retry the operation with the
        // CRYPT_MACHINE_KEYSET flag set if not already set.
        //

        if( ( dwAdditionalFlags & CRYPT_MACHINE_KEYSET ) == 0 ) {

            result = ::IISCryptoGetContainerByName(
                           phProv,
                           pszContainerName,
                           dwAdditionalFlags | CRYPT_MACHINE_KEYSET,
                           fApplyAcl
                           );

            if( SUCCEEDED(result) ) {
                goto complete;
            }

        }

        //
        // Step 4: With the token removed, try to open/create the container.
        //

        result = ::IISCryptoGetContainerByName(
                       phProv,
                       pszContainerName,
                       dwAdditionalFlags,
                       fApplyAcl
                       );

        if( SUCCEEDED(result) ) {
            goto complete;
        }

    }

    //
    // If we made it this far, then the container cannot be opened.
    //

    result = NTE_BAD_KEYSET;

complete:

    if( resetToken ) {

        HRESULT result2;

        DBG_ASSERT( token != NULL );
        result2 = SetThreadImpersonationToken( token );

        if( FAILED(result2) ) {

            //
            // This is really, really, really bad news. The current
            // thread, which does not have an impersonation token
            // (and is therefore running in the system context)
            // cannot reset its impersonation token to the original
            // value.
            //

            DBG_ASSERT( !"SetThreadImpersonationToken() failed!!!" );

        }

    }

    if( token != NULL ) {
        DBG_REQUIRE( CloseHandle( token ) );
    }

    return result;

}   // IIS_CRYPTO_BASE::GetCryptoContainerByName


HRESULT
IIS_CRYPTO_BASE::Initialize(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKeyExchangeKey,
    IN HCRYPTKEY hSignatureKey,
    IN BOOL fUseMachineKeyset
    )

/*++

Routine Description:

    Performs any complex initialization.

Arguments:

    hProv - Optional pre-opened handle to a crypto provider. If this
        is not present, then the standard container is opened. If this
        is present, then it is used and it is the responsibility of the
        caller to close the handle when no longer needed.

    hKeyExchangeKey - Optional pre-opened handle to a key exchange key. If
        this is not present, then the local key exchange key is used.

    hSignatureKey - Optional pre-opened handle to a signature key. If this
        is not present, then the local signature key is used.

    fUseMachineKeyset - TRUE if the per-machine keyset container should
        be used, as opposed to the per-user keyset container.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hProv == CRYPT_NULL );
    DBG_ASSERT( m_hKeyExchangeKey == CRYPT_NULL );
    DBG_ASSERT( m_hSignatureKey == CRYPT_NULL );

    IcpAcquireGlobalLock();

    if( hProv == CRYPT_NULL ) {

        //
        // Open the container.
        //

        result = ::IISCryptoGetStandardContainer(
                       &m_hProv,
                       fUseMachineKeyset
                           ? CRYPT_MACHINE_KEYSET
                           : 0
                       );

        m_fCloseProv = TRUE;

    } else {

        m_hProv = hProv;
        m_fCloseProv = FALSE;
        result = NO_ERROR;

    }

    if( SUCCEEDED(result) ) {

        if( hKeyExchangeKey == CRYPT_NULL ) {

            //
            // Get the key exchange key.
            //

            result = ::IISCryptoGetKeyExchangeKey(
                           &m_hKeyExchangeKey,
                           m_hProv
                           );

        } else {

            m_hKeyExchangeKey = hKeyExchangeKey;

        }

    }

    if( SUCCEEDED(result) ) {

        if( hSignatureKey == CRYPT_NULL ) {

            //
            // Get the signature key.
            //

            result = ::IISCryptoGetSignatureKey(
                           &m_hSignatureKey,
                           m_hProv
                           );

        } else {

            m_hSignatureKey = hSignatureKey;

        }

    }

    IcpReleaseGlobalLock();

    return result;

}   // IIS_CRYPTO_BASE::Initialize

HRESULT
IIS_CRYPTO_BASE::Initialize2(
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    Performs any complex initialization.

Arguments:

    hProv - Optional pre-opened handle to a crypto provider. If this
        is not present, then the standard container is opened. If this
        is present, then it is used and it is the responsibility of the
        caller to close the handle when no longer needed.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hProv == CRYPT_NULL );
    DBG_ASSERT( m_hKeyExchangeKey == CRYPT_NULL );
    DBG_ASSERT( m_hSignatureKey == CRYPT_NULL );

    IcpAcquireGlobalLock();

    if( hProv == CRYPT_NULL ) {

        //
        // Open the container.
        //

        result = ::IISCryptoGetStandardContainer2(
                       &m_hProv
                       );

        m_fCloseProv = TRUE;

    } else {

        m_hProv = hProv;
        m_fCloseProv = FALSE;
        result = NO_ERROR;

    }

    IcpReleaseGlobalLock();

    return result;

}   // IIS_CRYPTO_BASE::Initialize2


HRESULT
IIS_CRYPTO_BASE::GetKeyExchangeKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppKeyExchangeKeyBlob
    )

/*++

Routine Description:

    Exports the key exchange key as a public blob.

Arguments:

    ppKeyExchangeKeyBlob - Receives a pointer to the key exchange key
        public blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppKeyExchangeKeyBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                   ppKeyExchangeKeyBlob,
                   m_hProv,
                   m_hKeyExchangeKey
                   );

    return result;

}   // IIS_CRYPTO_BASE::GetKeyExchangeKeyBlob


HRESULT
IIS_CRYPTO_BASE::GetSignatureKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppSignatureKeyBlob
    )

/*++

Routine Description:

    Exports the signature key as a public blob.

Arguments:

    ppSignatureKeyBlob - Receives a pointer to the signature key
        public blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppSignatureKeyBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                   ppSignatureKeyBlob,
                   m_hProv,
                   m_hSignatureKey
                   );

    return result;

}   // IIS_CRYPTO_BASE::GetSignatureKeyBlob


//
// Private functions.
//


#if DBG

BOOL
IIS_CRYPTO_BASE::ValidateState()

/*++

Routine Description:

    This debug-only routine validates the current object state.

Arguments:

    None.

Return Value:

    BOOL - TRUE if state is valid, FALSE otherwise.

--*/

{

    if( m_hProv != CRYPT_NULL &&
        m_hKeyExchangeKey != CRYPT_NULL &&
        m_hSignatureKey != CRYPT_NULL ) {

        return TRUE;

    }

    return FALSE;

}   // IIS_CRYPTO_BASE::ValidateState

BOOL
IIS_CRYPTO_BASE::ValidateState2()

/*++

Routine Description:

    This debug-only routine validates the current object state.

Arguments:

    None.

Return Value:

    BOOL - TRUE if state is valid, FALSE otherwise.

--*/

{

    if( m_hProv != CRYPT_NULL )
    {
        return TRUE;
    }

    return FALSE;

}   // IIS_CRYPTO_BASE::ValidateState2

#endif  // DBG


HRESULT
IIS_CRYPTO_BASE::SafeImportSessionKeyBlob(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSignatureKey
    )

/*++

Routine Description:

    This routine takes the specified session key blob and creates the
    corresponding session key, iff the encrypted session key can be
    decrypted and the digital signature can be validated.

Arguments:

    phSessionKey - Receives a pointer to the newly created session key
        if successful.

    pSessionKeyBlob - Pointer to a key blob created with
        IISCryptoExportSessionKeyBlob().

    hProv - A handle to a crypto service provider.

    hSignatureKey - Handle to the encryption key to use when validating
        the digital signature.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTKEY sessionKey = CRYPT_NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoImportSessionKeyBlob(
                 &sessionKey,
                 pSessionKeyBlob,
                 hProv,
                 hSignatureKey
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoImportSessionKeyBlob(
                              &sessionKey,
                              pSessionKeyBlob,
                              hProv,
                              hSignatureKey
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( sessionKey != NULL );
        *phSessionKey = sessionKey;
    }

    return result;

}   // IIS_CRYPTO_BASE::SafeImportSessionKeyBlob

HRESULT
IIS_CRYPTO_BASE::SafeImportSessionKeyBlob2(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN LPSTR pszPasswd
    )

/*++

Routine Description:

    This routine takes the specified session key blob and creates the
    corresponding session key, iff the encrypted session key can be
    decrypted.

Arguments:

    phSessionKey - Receives a pointer to the newly created session key
        if successful.

    pSessionKeyBlob - Pointer to a key blob created with
        IISCryptoExportSessionKeyBlob().

    hProv - A handle to a crypto service provider.

    pszPasswd - The password to use to encrypt the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTKEY sessionKey = CRYPT_NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoImportSessionKeyBlob2(
                 &sessionKey,
                 pSessionKeyBlob,
                 hProv,
                 pszPasswd
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoImportSessionKeyBlob2(
                              &sessionKey,
                              pSessionKeyBlob,
                              hProv,
                              pszPasswd
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( sessionKey != NULL );
        *phSessionKey = sessionKey;
    }

    return result;

}   // IIS_CRYPTO_BASE::SafeImportSessionKeyBlob2


HRESULT
IIS_CRYPTO_BASE::SafeExportSessionKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hKeyExchangeKey
    )

/*++

Routine Description:

    This routine exports a session key into a secure session key blob.
    The blob contains the session key (encrypted with the specified
    private key exchange key) and a digital signature (also encrypted).

Arguments:

    ppSessionKeyBlob - Will receive a pointer to the newly created
        session key blob if successful.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key to export.

    hKeyExchangeKey - The key to use when encrypting the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB sessionKeyBlob = NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoExportSessionKeyBlob(
                 &sessionKeyBlob,
                 hProv,
                 hSessionKey,
                 hKeyExchangeKey
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoExportSessionKeyBlob(
                              &sessionKeyBlob,
                              hProv,
                              hSessionKey,
                              hKeyExchangeKey
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( sessionKeyBlob != NULL );
        *ppSessionKeyBlob = sessionKeyBlob;
    }

    return result;

}       // IIS_CRYPTO_BASE::SafeExportSessionKeyBlob

HRESULT
IIS_CRYPTO_BASE::SafeExportSessionKeyBlob2(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN LPSTR pszPasswd
    )

/*++

Routine Description:

    This routine exports a session key into a secure session key blob.
    The blob contains the session key (encrypted with the specified
    private key exchange key) and a digital signature (also encrypted).

Arguments:

    ppSessionKeyBlob - Will receive a pointer to the newly created
        session key blob if successful.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key to export.

    pszPasswd - The password to use to encrypt the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB sessionKeyBlob = NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoExportSessionKeyBlob2(
                 &sessionKeyBlob,
                 hProv,
                 hSessionKey,
                 pszPasswd
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoExportSessionKeyBlob2(
                              &sessionKeyBlob,
                              hProv,
                              hSessionKey,
                              pszPasswd
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( sessionKeyBlob != NULL );
        *ppSessionKeyBlob = sessionKeyBlob;
    }

    return result;

}       // IIS_CRYPTO_BASE::SafeExportSessionKeyBlob

HRESULT
IIS_CRYPTO_BASE::SafeEncryptDataBlob(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine encrypts a block of data, resulting in a data blob.
    The data blob contains the encrypted data and a digital signature
    validating the data.

Arguments:

    ppDataBlob - Receives a pointer to the newly created data blob if
        successful.

    pBuffer - The buffer to encrypt.

    dwBufferLength - The length of the buffer.

    dwRegType - The REG_* type to associate with this data.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to encrypt the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB dataBlob = NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoEncryptDataBlob(
                 &dataBlob,
                 pBuffer,
                 dwBufferLength,
                 dwRegType,
                 hProv,
                 hSessionKey
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoEncryptDataBlob(
                              &dataBlob,
                              pBuffer,
                              dwBufferLength,
                              dwRegType,
                              hProv,
                              hSessionKey
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( dataBlob != NULL );
        *ppDataBlob = dataBlob;
    }

    return result;

}   // IIS_CRYPTO_BASE::SafeEncryptDataBlob

HRESULT
IIS_CRYPTO_BASE::SafeEncryptDataBlob2(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine encrypts a block of data, resulting in a data blob.
    The data blob contains the encrypted data and a digital signature
    validating the data.

Arguments:

    ppDataBlob - Receives a pointer to the newly created data blob if
        successful.

    pBuffer - The buffer to encrypt.

    dwBufferLength - The length of the buffer.

    dwRegType - The REG_* type to associate with this data.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to encrypt the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB dataBlob = NULL;
    HANDLE token = NULL;

    //
    // First, just call through to wrapper function. If it succeeds, cool.
    //

    result = ::IISCryptoEncryptDataBlob2(
                 &dataBlob,
                 pBuffer,
                 dwBufferLength,
                 dwRegType,
                 hProv,
                 hSessionKey
                 );

    if( FAILED(result) ) {

        HRESULT result2;

        //
        // Bummer. If the current thread has an impersonation token, then
        // temporarily remove it and retry the operation.
        //

        result2 = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result2) && token != NULL ) {

            result2 = SetThreadImpersonationToken( NULL );

            if( SUCCEEDED(result2) ) {

                result2 = ::IISCryptoEncryptDataBlob2(
                              &dataBlob,
                              pBuffer,
                              dwBufferLength,
                              dwRegType,
                              hProv,
                              hSessionKey
                              );

                if( SUCCEEDED(result2) ) {
                    result = result2;
                }

                //
                // Restore the original impersonation token.
                //

                result2 = SetThreadImpersonationToken( token );
                DBG_ASSERT( SUCCEEDED(result2) );

            }

            //
            // Close the token handle.
            //

            DBG_REQUIRE( CloseHandle( token ) );

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( dataBlob != NULL );
        *ppDataBlob = dataBlob;
    }

    return result;

}   // IIS_CRYPTO_BASE::SafeEncryptDataBlob2

HRESULT
IIS_CRYPTO_BASE::GetThreadImpersonationToken(
    OUT HANDLE * Token
    )
/*++

Routine Description:

    Gets the impersonation token for the current thread.

Arguments:

    Token - Receives a handle to the impersonation token if successful.
        If successful, it is the caller's responsibility to CloseHandle()
        the token when no longer needed.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;

    DBG_ASSERT( Token != NULL );

    //
    // Open the token.
    //

    if( !OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ALL_ACCESS,
            TRUE,
            Token
            ) ) {

        DWORD err = GetLastError();

        //
        // There are a couple of "expected" errors here:
        //
        //     ERROR_NO_TOKEN - The thread has no impersonation token.
        //     ERROR_CALL_NOT_IMPLEMENTED - We're probably on Win9x.
        //     ERROR_NOT_SUPPORTED - Ditto.
        //
        // If OpenThreadToken() failed with any of the above error codes,
        // then succeed the call, but return a NULL token handle.
        //

        if( err != ERROR_NO_TOKEN &&
            err != ERROR_CALL_NOT_IMPLEMENTED &&
            err != ERROR_NOT_SUPPORTED ) {

            result = HRESULT_FROM_WIN32(err);

        }

        *Token = NULL;
    }

    return result;

}   // IIS_CRYPTO_BASE::GetThreadImpersonationToken


HRESULT
IIS_CRYPTO_BASE::SetThreadImpersonationToken(
    IN HANDLE Token
    )
/*++

Routine Description:

    Sets the impersonation token for the current thread.

Arguments:

    Token - A handle to the impersonation token.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;

    //
    // Set it.
    //

    if( !SetThreadToken(
            NULL,
            Token
            ) ) {
        DWORD err = GetLastError();
        result = HRESULT_FROM_WIN32(err);
    }

    return result;

}   // IIS_CRYPTO_BASE::SetThreadImpersonationToken


BOOL
IIS_CRYPTO_BASE::AmIRunningInTheLocalSystemContext(
    VOID
    )
/*++

Routine Description:

    Determines if the current process is running in the local system
    security context.

Arguments:

    None.

Return Value:

    BOOL - TRUE if we're running in the local system context, FALSE
        otherwise.

--*/
{

    BOOL result;
    HANDLE token;
    DWORD lengthRequired;
    PTOKEN_USER tokenInfo;
    PSID systemSid;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

    //
    // Setup local so we know how to cleanup on exit.
    //

    result = FALSE;     // until proven otherwise...
    token = NULL;
    tokenInfo = NULL;
    systemSid = NULL;

    //
    // Get a handle to the current process token.
    //

    if( !OpenProcessToken(
            GetCurrentProcess(),                // ProcessHandle
            TOKEN_READ,                         // DesiredAccess
            &token                              // TokenHandle
            ) ) {
        goto cleanup;
    }

    //
    // Determine the length of the token information, then allocate
    // a buffer and read the info.
    //

    GetTokenInformation(
        token,                                  // TokenHandle
        TokenUser,                              // TokenInformationClass
        NULL,                                   // TokenInformation
        0,                                      // TokenInformationLength
        &lengthRequired                         // ReturnLength
        );

    tokenInfo = (PTOKEN_USER)new char[lengthRequired];

    if( tokenInfo == NULL ) {
        goto cleanup;
    }

    if( !GetTokenInformation(
            token,                              // TokenHandle
            TokenUser,                          // TokenInformationClass
            tokenInfo,                          // TokenInformation
            lengthRequired,                     // TokenInformationLength
            &lengthRequired                     // ReturnLength
            ) ) {
        goto cleanup;
    }

    //
    // OK, we have the token. Now build the system SID so we can compare
    // it with the one stored in the token.
    //

    if( !AllocateAndInitializeSid(
            &ntAuthority,                       // pIdentifierAuthority
            1,                                  // nSubAuthorityCount
            SECURITY_LOCAL_SYSTEM_RID,          // nSubAuthority0
            0,                                  // nSubAuthority1
            0,                                  // nSubAuthority2
            0,                                  // nSubAuthority3
            0,                                  // nSubAuthority4
            0,                                  // nSubAuthority5
            0,                                  // nSubAuthority6
            0,                                  // nSubAuthority7
            &systemSid                          // pSid
            ) ) {
        goto cleanup;
    }

    //
    // Now that we have the SID from the token and our hand-built
    // local system SID, we can compare them.
    //

    result = EqualSid(
                 tokenInfo->User.Sid,           // pSid1
                 systemSid                      // pSid2
                 );

cleanup:

    if( systemSid != NULL ) {
        FreeSid( systemSid );
    }

    if( tokenInfo != NULL ) {
        delete tokenInfo;
    }

    if( token != NULL ) {
        CloseHandle( token );
    }

    return result;

}   // IIS_CRYPTO_BASE::AmIRunningInTheLocalSystemContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\httphdr\tdict.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      tdict.cxx

   Abstract:
      This is a test module for the dictionary objects
      
   Author:

       Murali R. Krishnan    ( MuraliK )     8-Nov-1996 

   Environment:
    
       User Mode - Win32 

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "httphdr.hxx"

#define DEFAULT_TRACE_FLAGS     ((DEBUG_ERROR | DEBUG_PARSING | DEBUG_INIT_CLEAN)

# include "dbgutil.h"
# include <stdio.h>
# include <stdlib.h>

/************************************************************
 *    Functions 
 ************************************************************/

# define INPUT_HEADER_LENGTH_LIMIT   (100000)

DECLARE_DEBUG_PRINTS_OBJECT();
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisTDictGuid, 
0x784d8926, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();    
#endif

CHAR  g_rgchUsage[] = 
" Usage:  %s  [header <header-sequence> | mapper]\n"
"   mapper tests the HTTP_HEADER_MAPPER object which maps HTTP headers\n"
"            to the ordinals\n"
"   header   loads headers and tests the dictionary functions (HTTP_HEADERS)\n"
"          input headers are limited to 100K characters\n"
"   <header-sequence> is a sequence of test vector numbers [0..6] of standard\n"
"            headers built in. Use \'-\' to make it read headers from stdin\n"
"\n"
;

CHAR * g_pszHttpHeader1 = 
"GET / HTTP/1.0\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Accept-Language: en\r\n"
"UA-pixels: 1152x882\r\n"
"UA-color: color8\r\n"
"UA-OS: Windows NT\r\n"
"UA-CPU: x86\r\n"
"If-Modified-Since: Fri, 20 Sep 1996 23:36:42 GMT; length=4051\r\n"
"User-Agent: Mozilla/2.0 (compatible; MSIE 3.0; AK; Windows.NT\r\n"
"Host: muralik\r\n"
"Connection: Keep-Alive\r\n"
"\r\n"
;

// check if and non-fast map header works
CHAR * g_pszHttpHeader2 = 
"GET /samples/images/background.gif HTTP/1.0\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Referer: http://muralik0/\r\n"
"Accept-Language: en\r\n"
"UA-pixels: 1152x882\r\n"
"UA-color: color8\r\n"
"UA-OS: Windows NT\r\n"
"UA-CPU: x86\r\n"
"If-Modified-Since: Fri, 20 Sep 1996 23:36:47 GMT; length=10282\r\n"
"User-Agent: Mozilla/2.0 (compatible; MSIE 3.0; AK; Windows.NT\r\n"
"Host: muralik\r\n"
"Connection: Keep-Alive\r\n"
"MyHeader1: MyValue1\r\n"
"MyHeader2: MyValue2\r\n"
"\r\n"
;


// Checks if concatenation of headers work
CHAR * g_pszHttpHeader3 = 
"GET / HTTP/1.0\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Accept-Language: en\r\n"
"Accept-Language: es\r\n"
"UA-pixels: 1152x882\r\n"
"UA-color: color8\r\n"
"UA-OS: Windows NT\r\n"
"UA-CPU: x86\r\n"
"If-Modified-Since: Fri, 20 Sep 1996 23:36:42 GMT; length=4051\r\n"
"User-Agent: Mozilla/2.0 (compatible; MSIE 3.0; AK; Windows.NT\r\n"
"Host: muralik\r\n"
"Connection: Keep-Alive\r\n"
"Connection: 5m\r\n"
"Accept: Testing it \r\n"
"\r\n"
;

// check if and non-fast map header works with concatenation
CHAR * g_pszHttpHeader4 = 
"GET /samples/images/background.gif HTTP/1.0\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Referer: http://muralik0/\r\n"
"Accept-Language: en\r\n"
"UA-pixels: 1152x882\r\n"
"UA-color: color8\r\n"
"UA-OS: Windows NT\r\n"
"UA-CPU: x86\r\n"
"If-Modified-Since: Fri, 20 Sep 1996 23:36:47 GMT; length=10282\r\n"
"User-Agent: Mozilla/2.0 (compatible; MSIE 3.0; AK; Windows.NT\r\n"
"Host: muralik\r\n"
"Connection: Keep-Alive\r\n"
"MyHeader1: MyValue1\r\n"
"MyHeader2: MyValue2\r\n"
"MyHeader1: MyValue1_2\r\n"
"\r\n"
;
// check if and non-fast map header works with concatenation and
//  different length aux headers
CHAR * g_pszHttpHeader5 = 
"GET /samples/images/background.gif HTTP/1.0\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Referer: http://muralik0/\r\n"
"Accept-Language: en\r\n"
"UA-pixels: 1152x882\r\n"
"UA-color: color8\r\n"
"UA-OS: Windows NT\r\n"
"UA-CPU: x86\r\n"
"If-Modified-Since: Fri, 20 Sep 1996 23:36:47 GMT; length=10282\r\n"
"User-Agent: Mozilla/2.0 (compatible; MSIE 3.0; AK; Windows.NT\r\n"
"Host: muralik\r\n"
"Connection: Keep-Alive\r\n"
"MyHead2: MyValue2\r\n"
"MyHeader1: MyValue1\r\n"
"MyHeader1: MyValue1_2\r\n"
"\r\n"
;

/*
  Headers Sent by Netscape 3.0 client  -- 
  note No CACHE because of this being the first-request :(
 */
CHAR * g_pszHttpHeader6 = 
"GET /scripts/asp/test.asp HTTP/1.0\r\n"
"Connection: Keep-Alive\r\n"
"User-Agent: Mozilla/3.0.(WinNT; I)\r\n"
"Pragma: no-cache\r\n"
"Host: phillich1\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"\r\n";

/*
  Headers Sent by Netscape 3.0 client  -- 
  note No CACHE because of this being the first-request :(
 */
CHAR * g_pszHttpHeader7 = 
"GET /scripts/asp/test.asp HTTP/1.0\r\n"
"Connection: Keep-Alive\r\n"
"User-Agent: Mozilla/3.0 (WinNT; I)\r\n"
"Pragma: no-cache\r\n"
"Host: phillich1\r\n"
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n"
"Cookie: ASPSESSIONID=PVZQGHUMEAYFNRFK\r\n"
"\r\n";


CHAR * g_ppHeaders[] = {
  g_pszHttpHeader1,
  g_pszHttpHeader2,
  g_pszHttpHeader3,
  g_pszHttpHeader4,
  g_pszHttpHeader5,
  g_pszHttpHeader6,
  g_pszHttpHeader7

};

# define MAX_TEST_HEADERS   ( sizeof( g_ppHeaders) / sizeof( g_ppHeaders[0]))


/************************************************************
 *  Functions
 ************************************************************/

VOID PrintUsage( char * pszProgram) 
{
    fprintf( stderr, g_rgchUsage, pszProgram);
    return;
} // PrintUsage()


VOID
TestMapper( int argc, char * argv[]) 
{
    int argSeen;

    const DICTIONARY_MAPPER * pdm = HTTP_HEADERS::QueryHHMapper();

    for( argSeen = 0; argSeen < argc; argSeen++) {
        DWORD dwOrdinal = 0;
        
        if ( pdm->FindOrdinal( argv[argSeen], strlen( argv[argSeen]),
                               & dwOrdinal)
             ) {
            
            DBGPRINTF(( DBG_CONTEXT, "\nFindOrdinal(%d, %s) => %d\n",
                        argSeen, argv[argSeen], dwOrdinal));
            
            LPCSTR pszHeader = pdm->FindName( dwOrdinal);
            
            DBGPRINTF(( DBG_CONTEXT, "FindOrdinal( %d) => %s\n",
                        dwOrdinal, 
                        ( NULL == pszHeader) ? "not found" : pszHeader
                        ));
        } else {

            DBGPRINTF(( DBG_CONTEXT, "\nFindOrdinal( %d, %s) returns failure\n",
                        argSeen, argv[argSeen]));
        }
    } // for

    CHAR pchBuffer[20000];
    DWORD cch = sizeof( pchBuffer);
    pdm->PrintToBuffer( pchBuffer, &cch);
    DBG_ASSERT( cch < sizeof(pchBuffer));

    fprintf( stdout, "Header Mapper is: size=%d\n", cch);
    fwrite( pchBuffer, 1, cch,  stdout);
    
    return;
} // TestMapper()



VOID
ThPrint( IN HTTP_HEADERS * phd) 
{
    // Test Header PrintToBuffer() 

    CHAR pchBuffer[20000];
    DWORD cch;
        
    cch = sizeof( pchBuffer);
    phd->PrintToBuffer( pchBuffer, &cch);
    DBG_ASSERT( cch < sizeof(pchBuffer));
    
    fwrite( pchBuffer, 1, cch,  stdout);
    
    return;
} // ThPrint()


VOID
ThIterator( IN HTTP_HEADERS * phd)
{
    HH_ITERATOR  hhi;
    NAME_VALUE_PAIR * pnp;
    int i;
    
    printf( "\t---- Test Iterator on all headers\n");
    
    phd->InitIterator( &hhi);
    
    for( i = 0; phd->NextPair( &hhi, &pnp); i++) {
        
        // dump the header-value pairs
        printf( "\n   [%d] ", i);
        fwrite( pnp->pchName, 1, pnp->cchName, stdout);
        fputc('\t', stdout);
        fwrite( pnp->pchValue, 1, pnp->cchValue, stdout);
    } // for
    
    printf( "\nTotal of %d headers found. Error = %d\n", i, GetLastError());
    return;
} // ThIterator()


CHAR * pTh1 = "TestHeader1";
CHAR * pTv1 = "TestVal1";
CHAR * pTh2 = "Accept:";
CHAR * pTv2 = "TestVal2";

VOID ThStoreHeader( IN HTTP_HEADERS * phd)
{
    BOOL fRet;

    
    printf( "\n\t---- Test StoreHeader \n");

    fRet = phd->StoreHeader( pTh1, strlen( pTh1),
                             pTv1, strlen( pTv1)
                             );

    printf( "%08x::StoreHeader( %s, %s) return %d\n",
            phd, pTh1, pTv1, fRet);

    fRet = phd->StoreHeader( pTh2, strlen( pTh2),
                             pTv2, strlen( pTv2)
                             );

    printf( "%08x::StoreHeader( %s, %s) return %d\n",
            phd, pTh2, pTv2, fRet);

    // print the headers to test this out.
    ThPrint( phd);

    return;
} // ThStoreHeader()


VOID ThFindValue( IN HTTP_HEADERS * phd)
{
    LPCSTR pszVal;
    DWORD  cchVal;

    printf( "\n\t---- Test FindHeader \n");

    pszVal = phd->FindValue( pTh1, &cchVal);

    printf( "%08x::FindValue( %s, %08x) returns %08x [size=%d] %s\n",
            phd, pTh1, &cchVal, pszVal, cchVal, pszVal);

    cchVal = 0;
    pszVal = phd->FindValue( pTh2);

    printf( "%08x::FindValue( %s, NULL) returns %08x [size=%d] %s\n",
            phd, pTh2, pszVal, cchVal, pszVal);

    // Ask non-existent header
    cchVal = 10000;
    pszVal = phd->FindValue( "random", &cchVal);

    printf( "%08x::FindValue( %s, %08x) returns %08x [size=%d] %s\n",
            phd, "random", &cchVal, pszVal, cchVal, pszVal);

    return;
} // ThFindValue()


VOID ThCancelHeader( IN HTTP_HEADERS * phd)
{
    LPCSTR pszVal;

    printf( "\n\t---- Test CancelHeader \n");

    phd->CancelHeader( pTh1);
    printf( "%08x::CancelHeader( %s) done \n", phd, pTh1);

    phd->CancelHeader( pTh2);
    printf( "%08x::CancelHeader( %s) done \n", phd, pTh2);

    ThPrint( phd);
    return;
} // ThCancelHeader()


VOID ThFmStore( IN HTTP_HEADERS * phd)
{
    BOOL fRet;

    printf( "\n\t---- Test FastMap Store \n");
    phd->FastMapStore( HM_ACC, "text/plain");
    printf( "%08x::FastMapStore( %d, %s) done\n",
            phd, HM_ACC, "text/plain");

    fRet = phd->FastMapStoreWithConcat( HM_ACC, "*/*", 3);
    printf( "%08x::FastMapStoreWithConcat( %d, %s) returns %d\n",
            phd, HM_ACC, "*/*", fRet);
    
    ThPrint( phd);

} // ThFmStore()


BOOL
TestHeaderFuncs( IN HTTP_HEADERS * phd) 
{
    
    DBG_ASSERT( phd);

    ThPrint( phd);
    ThIterator(phd);
    ThStoreHeader( phd);
    ThFindValue( phd);
    ThCancelHeader( phd);
    ThFmStore(phd);
    ThIterator(phd);

    return ( TRUE);
} // TestHeaderFuncs()


BOOL
TestHeader( IN HTTP_HEADERS * phd, 
            IN const CHAR * pszHeader, 
            IN DWORD cchHeader)
{
    DWORD cbExtra = 0;

    phd->Reset();
    
    phd->Print();
    if ( phd->ParseInput( pszHeader, cchHeader, &cbExtra)) {
        
        DBGPRINTF(( DBG_CONTEXT, " Parsed Header \n%s\n was successful. "
                    " Extra bytes = %d\n",
                    pszHeader, cbExtra));

        fprintf( stdout, "Successfully parsed Header @ %08x (size=%d)\n", 
                 pszHeader, cchHeader);

        return ( TestHeaderFuncs( phd));

    } else {

        fprintf( stderr, " Parsing Header \n%s\n failed. Error = %d\n",
                 pszHeader, GetLastError());
        return ( FALSE);
    }

    return (FALSE);
} // TestHeader()


BOOL
GetInputHeader(IN CHAR * pchBuffer, IN OUT LPDWORD pcbHeader)
{
    DWORD cb, cbRead;

    // read the header given in the input - one line at a time

    for ( cb = 0, cbRead = 0; 
          (fgets( pchBuffer + cb, *pcbHeader - cb, stdin) != NULL);
          cb += cbRead
          ){

        if ( pchBuffer[cb] == ';') {

            // This is a comment line. Skip and continue.
            cbRead = 0;
            continue;
        }

        cbRead = strlen( pchBuffer + cb);

        // check for endof line marker
        if ( !strcmp( pchBuffer + cb, "\r\n") ||
             !strcmp( pchBuffer + cb, "\n")
             ){
         
            // we are done. exit now.
            *pcbHeader = (cb + cbRead);
            pchBuffer[ cb + cbRead] = '\0';
            return ( TRUE);
        }
        
    } // for

    return ( FALSE);
} // GetInputHeader()


VOID
TestDictionary( int argc, char * argv[]) 
{
    HTTP_HEADERS  * phd; 

    phd = new HTTP_HEADERS();
    if ( NULL == phd) {
        
        fprintf( stderr, " Unable to create the dictionary. \n");
        exit( 1);
    }

    for ( int i = 0; i < argc; i++) {

        if ( argv[i][0] == '-') {
            
            CHAR pchBuffer[INPUT_HEADER_LENGTH_LIMIT + 2];

            for ( ; ; ) {
                DWORD cchBuffer = sizeof( pchBuffer);
                
                if (!GetInputHeader( pchBuffer, &cchBuffer)) {
                    
                    break;
                }
                
                fprintf( stdout, 
                         "\n ------------  Header from input -----------\n"
                         );
                
                TestHeader( phd, pchBuffer, cchBuffer);
            
                fprintf( stdout,
                         "\n --------------------------------------------\n");
            } // for - as long as there is input
            
        } else { 
            int iHeader = atoi( argv[i]);
            
            if ( iHeader < MAX_TEST_HEADERS) { 
                fprintf( stdout, 
                         "\n ------------  [%4d] =  Header %4d -----------\n",
                         i, iHeader);
                
                TestHeader( phd, g_ppHeaders[iHeader],
                            strlen( g_ppHeaders[iHeader]));
                
                fprintf( stdout,
                     "\n --------------------------------------------\n");
            }
        }
    } // for
    
    delete phd;

    return;
} // TestDictionary()



int __cdecl
main(int argc, char * argv[])
{
    int argSeen = 1;

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( argv[0], IisTDictGuid);
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( argv[0]);
    SET_DEBUG_FLAGS( DEBUG_ERROR | DEBUG_PARSING | DEBUG_INIT_CLEAN);
#endif

    if ( argc < 2) {

        PrintUsage( argv[0]);
        exit(1);
    }

    fprintf( stdout,
             " sizeof( HTTP_HEADERS) = %d\t sizeof(HTTP_HEADER_MAPPER) = %d\n",
             sizeof( HTTP_HEADERS),  sizeof(HTTP_HEADER_MAPPER));
    
    if (  !HTTP_HEADERS::Initialize()) {
        fprintf( stderr, " Initialization failed\n");
        exit (1);
    }
    
    if ( !strcmp( argv[1], "mapper") ) {
        TestMapper( argc-2, argv+2);
    } else if ( !strcmp( argv[1], "header")) {
        TestDictionary( argc-2, argv+2);
    } else {

        PrintUsage( argv[0]);
    }
    
    HTTP_HEADERS::Cleanup();
    
    DELETE_DEBUG_PRINT_OBJECT();

    return (1);
} // main()




/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\icrypt\lib\exchbase.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    exchange.cxx

Abstract:

    This module implements the IIS_CRYPTO_EXCHANGE_BASE class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_CRYPTO_EXCHANGE_BASE::IIS_CRYPTO_EXCHANGE_BASE()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_BASE class constructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Just put the member variables into known states.
    //

    m_hServerSessionKey = CRYPT_NULL;
    m_hClientSessionKey = CRYPT_NULL;

}   // IIS_CRYPTO_EXCHANGE_BASE::IIS_CRYPTO_EXCHANGE_BASE


IIS_CRYPTO_EXCHANGE_BASE::~IIS_CRYPTO_EXCHANGE_BASE()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_BASE class destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Close any open keys.
    //

    CLOSE_KEY( m_hServerSessionKey );
    CLOSE_KEY( m_hClientSessionKey );

}   // IIS_CRYPTO_EXCHANGE_BASE::~IIS_CRYPTO_EXCHANGE_BASE


HRESULT
IIS_CRYPTO_EXCHANGE_BASE::CreatePhase3Hash(
    OUT PIIS_CRYPTO_BLOB * ppHashBlob
    )

/*++

Routine Description:

    Creates the hash value used by phase 3 of the exchange protocol.

Arguments:

    ppHashBlob - Receives a pointer to the hash blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Let the worker function do the dirty work.
    //

    return CreateHashWorker(
               ppHashBlob,
               TRUE         // fPhase3
               );

}   // IIS_CRYPTO_EXCHANGE_BASE::CreatePhase3Hash


HRESULT
IIS_CRYPTO_EXCHANGE_BASE::CreatePhase4Hash(
    OUT PIIS_CRYPTO_BLOB * ppHashBlob
    )

/*++

Routine Description:

    Creates the hash value used by phase 4 of the exchange protocol.

Arguments:

    ppHashBlob - Receives a pointer to the hash blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0
        otherwise.

--*/

{

    //
    // Let the worker function do the dirty work.
    //

    return CreateHashWorker(
               ppHashBlob,
               FALSE        // fPhase3
               );

}   // IIS_CRYPTO_EXCHANGE_BASE::CreatePhase4Hash


//
// Private functions.
//


HRESULT
IIS_CRYPTO_EXCHANGE_BASE::CreateHashWorker(
    OUT PIIS_CRYPTO_BLOB * ppHashBlob,
    IN BOOL fPhase3
    )

/*++

Routine Description:

    Creates the hash value used by the exchange protocol.

Arguments:

    ppHashBlob - Receives a pointer to the hash blob if successful.

    fPhase3 - TRUE if this is the phase 3 hash.

Return Value:

    HRESULT - Completion status, 0 if successful, !0
        otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;
    PIIS_CRYPTO_BLOB hashBlob;
    PVOID hashData;
    DWORD hashDataLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( m_hServerSessionKey != CRYPT_NULL );
    DBG_ASSERT( m_hClientSessionKey != CRYPT_NULL );
    DBG_ASSERT( ppHashBlob != NULL );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;
    hashBlob = NULL;

    //
    // Create the hash object.
    //

    result = ::IISCryptoCreateHash(
                  &hash,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Hash in the session keys and the constant string.
    //

    result = ::IISCryptoHashSessionKey(
                  hash,
                  m_hClientSessionKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    if( fPhase3 ) {

        result = ::IISCryptoHashSessionKey(
                      hash,
                      m_hServerSessionKey
                      );

        if( FAILED(result) ) {
            goto fatal;
        }

        hashData = (PVOID)HASH_TEXT_STRING_1;
        hashDataLength = sizeof(HASH_TEXT_STRING_1);

    } else {

        hashData = (PVOID)HASH_TEXT_STRING_2;
        hashDataLength = sizeof(HASH_TEXT_STRING_2);

    }

    result = ::IISCryptoHashData(
                  hash,
                  hashData,
                  hashDataLength
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Create the blob.
    //

    result = ::IISCryptoExportHashBlob(
                  &hashBlob,
                  hash
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    DESTROY_HASH(hash);
    *ppHashBlob = hashBlob;

    return NO_ERROR;

fatal:

    FREE_BLOB(hashBlob);
    DESTROY_HASH(hash);

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_BASE::CreatePhase4Hash
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\icrypt\lib\exchcli.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    exchange.cxx

Abstract:

    This module implements the IIS_CRYPTO_EXCHANGE_CLIENT class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_CRYPTO_EXCHANGE_CLIENT::IIS_CRYPTO_EXCHANGE_CLIENT()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_CLIENT class constructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Just put the member variables into known states.
    //

    m_hServerKeyExchangeKey = CRYPT_NULL;
    m_hServerSignatureKey = CRYPT_NULL;

}   // IIS_CRYPTO_EXCHANGE_CLIENT::IIS_CRYPTO_EXCHANGE_CLIENT


IIS_CRYPTO_EXCHANGE_CLIENT::~IIS_CRYPTO_EXCHANGE_CLIENT()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_CLIENT class destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Close any open keys.
    //

    CLOSE_KEY( m_hServerKeyExchangeKey );
    CLOSE_KEY( m_hServerSignatureKey );

}   // IIS_CRYPTO_EXCHANGE_CLIENT::~IIS_CRYPTO_EXCHANGE_CLIENT


HRESULT
IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase1(
    OUT PIIS_CRYPTO_BLOB * ppClientKeyExchangeKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppClientSignatureKeyBlob
    )

/*++

Routine Description:

    Performs client-side phase 1 of the multi-phase key exchange protocol.

Arguments:

    ppClientKeyExchangeKeyBlob - Receives a pointer to the client's key
        exchange key public blob if successful. It is the client's
        responsibility to (somehow) transmit this to the server.

    ppClientSignatureKeyBlob - Receives a pointer to the client's signature
        public blob if successful. It is the client's responsibility to
        (somehow) transmit this to the server.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB keyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB signatureKeyBlob;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppClientKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( ppClientSignatureKeyBlob != NULL );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    keyExchangeKeyBlob = NULL;
    signatureKeyBlob = NULL;

    //
    // Export the key exchange key blob.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                   &keyExchangeKeyBlob,
                   m_hProv,
                   m_hKeyExchangeKey
                   );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Export the signature key blob.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                  &signatureKeyBlob,
                  m_hProv,
                  m_hSignatureKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    DBG_ASSERT( keyExchangeKeyBlob != NULL );
    DBG_ASSERT( signatureKeyBlob != NULL );

    *ppClientKeyExchangeKeyBlob = keyExchangeKeyBlob;
    *ppClientSignatureKeyBlob = signatureKeyBlob;

    return NO_ERROR;

fatal:

    FREE_BLOB( keyExchangeKeyBlob );
    FREE_BLOB( signatureKeyBlob );

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase1


HRESULT
IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase2(
    IN PIIS_CRYPTO_BLOB pServerKeyExchangeKeyBlob,
    IN PIIS_CRYPTO_BLOB pServerSignatureKeyBlob,
    IN PIIS_CRYPTO_BLOB pServerSessionKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppClientSessionKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppClientHashBlob
    )

/*++

Routine Description:

    Performs client-side phase 2 of the multi-phase key exchange protocol.

Arguments:

    pServerKeyExchangeKeyBlob - Pointer to the server's key exchange
        public key blob.

    pServerSignatureKeyBlob - Pointer to the server's signature public
        key blob.

    pServerSessionKeyBlob - Pointer to the server's session key
        blob.

    ppClientSessionKeyBlob - Receives a pointer to the client's
        session key blob if successful.

    ppClientHashBlob - Receives a pointer to the client's hash
        blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB sessionKeyBlob;
    PIIS_CRYPTO_BLOB hashBlob;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( pServerKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pServerKeyExchangeKeyBlob ) );
    DBG_ASSERT( pServerSignatureKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pServerSignatureKeyBlob ) );
    DBG_ASSERT( pServerSessionKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pServerSessionKeyBlob ) );
    DBG_ASSERT( ppClientSessionKeyBlob != NULL );
    DBG_ASSERT( ppClientHashBlob != NULL );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    sessionKeyBlob = NULL;
    hashBlob = NULL;

    //
    // Import the server's keys.
    //

    DBG_ASSERT( m_hServerKeyExchangeKey == CRYPT_NULL );
    result = ::IISCryptoImportPublicKeyBlob(
                  &m_hServerKeyExchangeKey,
                  pServerKeyExchangeKeyBlob,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    DBG_ASSERT( m_hServerSignatureKey == CRYPT_NULL );
    result = ::IISCryptoImportPublicKeyBlob(
                  &m_hServerSignatureKey,
                  pServerSignatureKeyBlob,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    DBG_ASSERT( m_hServerSessionKey == CRYPT_NULL );
    result = SafeImportSessionKeyBlob(
                  &m_hServerSessionKey,
                  pServerSessionKeyBlob,
                  m_hProv,
                  m_hServerSignatureKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Generate our local session key.
    //

    DBG_ASSERT( m_hClientSessionKey == CRYPT_NULL );
    result = ::IISCryptoGenerateSessionKey(
                  &m_hClientSessionKey,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Export it.
    //

    result = SafeExportSessionKeyBlob(
                  &sessionKeyBlob,
                  m_hProv,
                  m_hClientSessionKey,
                  m_hServerKeyExchangeKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Create the phase 3 hash blob.
    //

    result = CreatePhase3Hash(
                  &hashBlob
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    *ppClientSessionKeyBlob = sessionKeyBlob;
    *ppClientHashBlob = hashBlob;

    return NO_ERROR;

fatal:

    FREE_BLOB( sessionKeyBlob );
    FREE_BLOB( hashBlob );

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase2


HRESULT
IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase3(
    IN PIIS_CRYPTO_BLOB pServerHashBlob
    )

/*++

Routine Description:

    Performs client-side phase 3 of the multi-phase key exchange protocol.

Arguments:

    pServerHashBlob - Pointer to the server's hash blob.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB hashBlob;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( pServerHashBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pServerHashBlob ) );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hashBlob = NULL;

    //
    // Create the phase 4 hash blob.
    //

    result = CreatePhase4Hash(
                 &hashBlob
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Compare this blob with the one we got from the server.
    // If they match, then the exchange is complete.
    //

    if( !::IISCryptoCompareBlobs(
              pServerHashBlob,
              hashBlob
              ) ) {

        result = ERROR_INVALID_DATA;
        goto fatal;

    }

    //
    // Success!
    //

    FREE_BLOB(hashBlob);

    return NO_ERROR;

fatal:

    FREE_BLOB(hashBlob);

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_CLIENT::ClientPhase3


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\icrypt\lib\storage.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    storage.cxx

Abstract:

    This module implements the IIS_CRYPTO_STORAGE class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_CRYPTO_STORAGE::IIS_CRYPTO_STORAGE()

/*++

Routine Description:

    IIS_CRYPTO_STORAGE class constructor. Just sets the member variables
    to known values; does nothing that can actually fail. All of the
    hard work is in the Initialize() methods.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Set the handles to known values so we know what to cleanup
    // in the destructor.
    //

    m_hSessionKey = CRYPT_NULL;

}   // IIS_CRYPTO_STORAGE::IIS_CRYPTO_STORAGE


IIS_CRYPTO_STORAGE::~IIS_CRYPTO_STORAGE()

/*++

Routine Description:

    IIS_CRYPTO_STORAGE class destructor. Performs any necessary cleanup.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Close any open keys.
    //

    CLOSE_KEY( m_hSessionKey );

}   // IIS_CRYPTO_STORAGE::~IIS_CRYPTO_STORAGE


HRESULT
IIS_CRYPTO_STORAGE::Initialize(
    IN BOOL fUseMachineKeyset,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    Generates a new (random) session key.

Arguments:

    fUseMachineKeyset - TRUE if the per-machine keyset container should
        be used, as opposed to the per-user keyset container.

    hProv - Optional handle to a pre-opened crypto provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hSessionKey == CRYPT_NULL );

    //
    // Initialize the base class.
    //

    result = IIS_CRYPTO_BASE::Initialize(
                 hProv,
                 CRYPT_NULL,
                 CRYPT_NULL,
                 fUseMachineKeyset
                 );

    if( SUCCEEDED(result) ) {

        //
        // Generate the session key.
        //

        result = ::IISCryptoGenerateSessionKey(
                       &m_hSessionKey,
                       m_hProv
                       );
        if( FAILED(result) ) {
            DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize IISCryptoGenerateSessionKey err=0x%x.\n",result));
        }

    }
    else
    {
        // something failed.
        DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize:IIS_CRYPTO_BASE::Initialize Failed err=0x%x.\n",result));
    }

    return result;

}   // IIS_CRYPTO_STORAGE::Initialize

HRESULT
IIS_CRYPTO_STORAGE2::Initialize(
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    Generates a new (random) session key.

Arguments:

    hProv - Optional handle to a pre-opened crypto provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hSessionKey == CRYPT_NULL );

    //
    // Initialize the base class.
    //

    result = Initialize2( hProv );

    if( SUCCEEDED(result) ) {

        //
        // Generate the session key.
        //

        result = ::IISCryptoGenerateSessionKey(
                       &m_hSessionKey,
                       m_hProv
                       );
        if( FAILED(result) ) {
            DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize IISCryptoGenerateSessionKey err=0x%x.\n",result));
        }

    }
    else
    {
        // something failed.
        DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize:IIS_CRYPTO_BASE::Initialize Failed err=0x%x.\n",result));
    }

    return result;

}   // IIS_CRYPTO_STORAGE2::Initialize


HRESULT
IIS_CRYPTO_STORAGE::Initialize(
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN BOOL fUseMachineKeyset,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    Imports the specified session key blob.

Arguments:

    pSessionKeyBlob - Points to the secure key blob to import.

    fUseMachineKeyset - TRUE if the per-machine keyset container should
        be used, as opposed to the per-user keyset container.

    hProv - Optional handle to a pre-opened crypto provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hSessionKey == CRYPT_NULL );
    DBG_ASSERT( pSessionKeyBlob != NULL );

    //
    // Initialize the base class.
    //

    result = IIS_CRYPTO_BASE::Initialize(
                 hProv,
                 CRYPT_NULL,
                 CRYPT_NULL,
                 fUseMachineKeyset
                 );

    if( SUCCEEDED(result) ) {

        //
        // Import the session key blob.
        //

        result = SafeImportSessionKeyBlob(
                       &m_hSessionKey,
                       pSessionKeyBlob,
                       m_hProv,
                       m_hSignatureKey
                       );
        if( FAILED(result) ) {
            DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize SafeImportSessionKeyBlob failed err=0x%x.\n",result));
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize IIS_CRYPTO_BASE::Initialize failed err=0x%x.\n",result));
    }

    return result;

}   // IIS_CRYPTO_STORAGE::Initialize

HRESULT
IIS_CRYPTO_STORAGE2::Initialize(
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN LPSTR pszPasswd,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    Imports the specified session key blob.

Arguments:

    pSessionKeyBlob - Points to the secure key blob to import.

    hProv - Optional handle to a pre-opened crypto provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hSessionKey == CRYPT_NULL );
    DBG_ASSERT( pszPasswd != NULL );
    DBG_ASSERT( pSessionKeyBlob != NULL );

    //
    // Initialize the base class.
    //

    result = IIS_CRYPTO_BASE::Initialize( hProv );

    if( SUCCEEDED(result) ) {

        //
        // Import the session key blob.
        //

        result = SafeImportSessionKeyBlob2(
                       &m_hSessionKey,
                       pSessionKeyBlob,
                       m_hProv,
                       pszPasswd
                       );
        if( FAILED(result) ) {
            DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize SafeImportSessionKeyBlob failed err=0x%x.\n",result));
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize IIS_CRYPTO_BASE::Initialize failed err=0x%x.\n",result));
    }

    return result;

}   // IIS_CRYPTO_STORAGE2::Initialize


HRESULT
IIS_CRYPTO_STORAGE::Initialize(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hKeyExchangeKey,
    IN HCRYPTKEY hSignatureKey,
    IN BOOL fUseMachineKeyset
    )

/*++

Routine Description:

    Initializes the object using pre-created provider and session key.

Arguments:

    hProv - An open handle to a crypto provider.

    hSessionKey - The session key for the object.

    hKeyExchangeKey - A pre-opened key exchange key.

    hSignatureKey - A pre-opened signature key.

    fUseMachineKeyset - TRUE if the per-machine keyset container should
        be used, as opposed to the per-user keyset container.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_hSessionKey == CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Initialize the base class.
    //

    result = IIS_CRYPTO_BASE::Initialize(
                 hProv,
                 hKeyExchangeKey,
                 hSignatureKey,
                 fUseMachineKeyset
                 );

    if( SUCCEEDED(result) ) {

        //
        // Save the session key.
        //

        m_hSessionKey = hSessionKey;
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,"IIS_CRYPTO_STORAGE::Initialize IIS_CRYPTO_BASE::Initialize failed err=0x%x.\n",result));
    }

    return result;

}   // IIS_CRYPTO_STORAGE::Initialize


HRESULT
IIS_CRYPTO_STORAGE::GetSessionKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob
    )

/*++

Routine Description:

    Exports the session key as a secure key blob.

Arguments:

    ppSessionKeyBlob - Receives a pointer to the session key secure
        blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppSessionKeyBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = SafeExportSessionKeyBlob(
                   ppSessionKeyBlob,
                   m_hProv,
                   m_hSessionKey,
                   m_hKeyExchangeKey
                   );

    return result;

}   // IIS_CRYPTO_STORAGE::GetSessionKeyBlob

HRESULT
IIS_CRYPTO_STORAGE2::GetSessionKeyBlob(
    IN LPSTR pszPasswd,
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob
    )

/*++

Routine Description:

    Exports the session key as a secure key blob.

Arguments:

    ppSessionKeyBlob - Receives a pointer to the session key secure
        blob if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppSessionKeyBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = SafeExportSessionKeyBlob2(
                   ppSessionKeyBlob,
                   m_hProv,
                   m_hSessionKey,
                   pszPasswd
                   );

    return result;

}   // IIS_CRYPTO_STORAGE2::GetSessionKeyBlob


HRESULT
IIS_CRYPTO_STORAGE::EncryptData(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType
    )

/*++

Routine Description:

    Encrypts a block of data and produces a secure data blob.

Arguments:

    ppDataBlob - Receives a pointer to the secure data blob if
        successful.

    pBuffer - Pointer to the buffer to encrypt.

    dwBufferLength - The length of the data buffer.

    dwRegType - The REG_* type for the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppDataBlob != NULL );
    DBG_ASSERT( pBuffer != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = SafeEncryptDataBlob(
                   ppDataBlob,
                   pBuffer,
                   dwBufferLength,
                   dwRegType,
                   m_hProv,
                   m_hSessionKey
                   );

    return result;

}   // IIS_CRYPTO_STORAGE::EncryptData

HRESULT
IIS_CRYPTO_STORAGE2::EncryptData(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType
    )

/*++

Routine Description:

    Encrypts a block of data and produces a secure data blob.

Arguments:

    ppDataBlob - Receives a pointer to the secure data blob if
        successful.

    pBuffer - Pointer to the buffer to encrypt.

    dwBufferLength - The length of the data buffer.

    dwRegType - The REG_* type for the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppDataBlob != NULL );
    DBG_ASSERT( pBuffer != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = SafeEncryptDataBlob2(
                   ppDataBlob,
                   pBuffer,
                   dwBufferLength,
                   dwRegType,
                   m_hProv,
                   m_hSessionKey
                   );

    return result;

}   // IIS_CRYPTO_STORAGE2::EncryptData


HRESULT
IIS_CRYPTO_STORAGE::DecryptData(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob
    )

/*++

Routine Description:

    Decrypts a secure data blob, producing a data pointer and data
    length.

Arguments:

    ppBuffer - Receives a pointer to the decrypted data if succesful.

    pdwBufferLength - Receives the length of the data buffer.

    pdwRegType - Receives the REG_* type of the data.

    pDataBlob - A pointer to the data blob to decrypt.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppBuffer != NULL );
    DBG_ASSERT( pdwBufferLength != NULL );
    DBG_ASSERT( pdwRegType != NULL );
    DBG_ASSERT( pDataBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = ::IISCryptoDecryptDataBlob(
                   ppBuffer,
                   pdwBufferLength,
                   pdwRegType,
                   pDataBlob,
                   m_hProv,
                   m_hSessionKey,
                   m_hSignatureKey
                   );

    return result;

}   // IIS_CRYPTO_STORAGE::DecryptData

HRESULT
IIS_CRYPTO_STORAGE2::DecryptData(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob
    )

/*++

Routine Description:

    Decrypts a secure data blob, producing a data pointer and data
    length.

Arguments:

    ppBuffer - Receives a pointer to the decrypted data if succesful.

    pdwBufferLength - Receives the length of the data buffer.

    pdwRegType - Receives the REG_* type of the data.

    pDataBlob - A pointer to the data blob to decrypt.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( ppBuffer != NULL );
    DBG_ASSERT( pdwBufferLength != NULL );
    DBG_ASSERT( pdwRegType != NULL );
    DBG_ASSERT( pDataBlob != NULL );

    //
    // Let the IIS Crypto APIs do the dirty work.
    //

    result = ::IISCryptoDecryptDataBlob2(
                   ppBuffer,
                   pdwBufferLength,
                   pdwRegType,
                   pDataBlob,
                   m_hProv,
                   m_hSessionKey
                   );

    return result;

}   // IIS_CRYPTO_STORAGE2::DecryptData


//
// Private functions.
//


#if DBG

BOOL
IIS_CRYPTO_STORAGE::ValidateState()

/*++

Routine Description:

    This debug-only routine validates the current object state.

Arguments:

    None.

Return Value:

    BOOL - TRUE if state is valid, FALSE otherwise.

--*/

{

    if( m_hSessionKey != CRYPT_NULL ) {

        return IIS_CRYPTO_BASE::ValidateState();

    }

    return FALSE;

}   // IIS_CRYPTO_STORAGE::ValidateState

BOOL
IIS_CRYPTO_STORAGE2::ValidateState()

/*++

Routine Description:

    This debug-only routine validates the current object state.

Arguments:

    None.

Return Value:

    BOOL - TRUE if state is valid, FALSE otherwise.

--*/

{

    if( m_hSessionKey != CRYPT_NULL ) {

        return IIS_CRYPTO_BASE::ValidateState2();

    }

    return FALSE;

}   // IIS_CRYPTO_STORAGE::ValidateState

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\icrypt\test\keyexch\client\exchcli.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    exchcli.cxx

Abstract:

    IIS Crypto client-side key exchange test.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define TEST_SOCKERR(api)                                                   \
            if( sockerr != NO_ERROR ) {                                     \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %d\n",                            \
                    api,                                                    \
                    __LINE__,                                               \
                    sockerr                                                 \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define FREE_BLOB(b)                                                        \
            if( b != NULL ) {                                               \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoFreeBlob( b );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoFreeBlob( %08lx ):%lu failed, error %08lx\n", \
                        b,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
                (b) = NULL;                                                 \
                                                                            \
            }


//
// Private types.
//


//
// Private globals.
//

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisCryptGuid, 
0x784d8927, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

CHAR ClientPlainText[] = "Client Client Client Client Client Client";


//
// Private prototypes.
//


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    INT sockerr;
    HRESULT result;
    IIS_CRYPTO_EXCHANGE_CLIENT * pclient;
    BUFFERED_SOCKET * psocket;
    PIIS_CRYPTO_BLOB clientKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB clientSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB serverSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientHashBlob;
    PIIS_CRYPTO_BLOB serverHashBlob;
    PIIS_CRYPTO_BLOB dataBlob;
    IIS_CRYPTO_STORAGE * clientStorage;
    IIS_CRYPTO_STORAGE * serverStorage;
    PVOID buffer;
    DWORD bufferLength;
    DWORD bufferType;

    if( argc != 2 ) {

        printf(
            "use: exchcli target_server\n"
            );

        return 1;

    }

    //
    // Initialize debug stuff.
    //

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt", IisCryptGuid );
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt" );
#endif

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    pclient = NULL;
    psocket = NULL;
    clientKeyExchangeKeyBlob = NULL;
    clientSignatureKeyBlob = NULL;
    serverKeyExchangeKeyBlob = NULL;
    serverSignatureKeyBlob = NULL;
    serverSessionKeyBlob = NULL;
    clientSessionKeyBlob = NULL;
    clientHashBlob = NULL;
    serverHashBlob = NULL;
    dataBlob = NULL;
    clientStorage = NULL;
    serverStorage = NULL;

    //
    // Initialize the crypto package.
    //

    printf( "exchcli: Initializing...\n" );

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Create & initialize the client-side key exchange object.
    //

    pclient = new IIS_CRYPTO_EXCHANGE_CLIENT;

    if( pclient == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = pclient->Initialize(
                 CRYPT_NULL,
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );

    TEST_HRESULT( "pclient->Initialize()" );

    //
    // Create & initialize the buffered socket object.
    //

    psocket = new BUFFERED_SOCKET;

    if( psocket == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = psocket->InitializeClient( argv[1], SERVER_PORT );

    TEST_HRESULT( "psocket->Initialize()" );

    //
    // 1. CLIENT(1)
    //

    printf( "exchcli: Phase 1...\n" );

    result = pclient->ClientPhase1(
                 &clientKeyExchangeKeyBlob,
                 &clientSignatureKeyBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase1()" );

    sockerr = psocket->SendBlob( clientKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( clientSignatureKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // 3. CLIENT(2)
    //

    printf( "exchcli: Phase 2...\n" );

    sockerr = psocket->RecvBlob( &serverKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &serverSignatureKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &serverSessionKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pclient->ClientPhase2(
                 serverKeyExchangeKeyBlob,
                 serverSignatureKeyBlob,
                 serverSessionKeyBlob,
                 &clientSessionKeyBlob,
                 &clientHashBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase2()" );

    sockerr = psocket->SendBlob( clientSessionKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( clientHashBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // 5. CLIENT(3)
    //

    printf( "exchcli: Phase 3...\n" );

    sockerr = psocket->RecvBlob( &serverHashBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pclient->ClientPhase3(
                 serverHashBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase3()" );

    //
    // Create the storage objects.
    //

    printf( "exchcli: Creating storage objects...\n" );

    clientStorage = new IIS_CRYPTO_STORAGE;

    if( clientStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = clientStorage->Initialize(
                 pclient->QueryProviderHandle(),
                 pclient->AssumeClientSessionKey(),
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );
    TEST_HRESULT( "clientStorage->Initialize()" );

    serverStorage = new IIS_CRYPTO_STORAGE;

    if( serverStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = serverStorage->Initialize(
                 pclient->QueryProviderHandle(),
                 pclient->AssumeServerSessionKey(),
                 CRYPT_NULL,
                 pclient->AssumeServerSignatureKey(),
                 TRUE
                 );
    TEST_HRESULT( "serverStorage->Initialize()" );

    //
    // Send some encrypted data.
    //

    printf( "exchcli: Encrypting '%s'...\n", ClientPlainText );

    result = clientStorage->EncryptData(
                 &dataBlob,
                 ClientPlainText,
                 sizeof(ClientPlainText),
                 REG_SZ
                 );
    TEST_HRESULT( "clientStorage->EncryptData()" );

    printf( "exchcli: Sending encrypted data...\n" );

    sockerr = psocket->SendBlob( dataBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    FREE_BLOB( dataBlob );

    //
    // Receive some encrypted data.
    //

    printf( "exchcli: Receiving encrypted data...\n" );

    sockerr = psocket->RecvBlob( &dataBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = serverStorage->DecryptData(
                 &buffer,
                 &bufferLength,
                 &bufferType,
                 dataBlob
                 );
    TEST_HRESULT( "serverStorage->DecryptData()" );

    printf( "exchcli: Received data[%lu] = '%s'\n", bufferLength, buffer );

    //
    // Tests complete.
    //

    printf( "exchcli: Done!\n" );

cleanup:

    FREE_BLOB( dataBlob );
    FREE_BLOB( serverHashBlob );
    FREE_BLOB( clientHashBlob );
    FREE_BLOB( clientSessionKeyBlob );
    FREE_BLOB( serverSessionKeyBlob );
    FREE_BLOB( serverSignatureKeyBlob );
    FREE_BLOB( serverKeyExchangeKeyBlob );
    FREE_BLOB( clientSignatureKeyBlob );
    FREE_BLOB( clientKeyExchangeKeyBlob );

    delete psocket;
    delete clientStorage;
    delete serverStorage;
    delete pclient;

    (VOID)IISCryptoTerminate();

    DELETE_DEBUG_PRINT_OBJECT();

    return 0;

}   // main


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\icrypt\lib\exchsrv.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    exchange.cxx

Abstract:

    This module implements the IIS_CRYPTO_EXCHANGE_SERVER class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_CRYPTO_EXCHANGE_SERVER::IIS_CRYPTO_EXCHANGE_SERVER()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_SERVER class constructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Just put the member variables into known states.
    //

    m_hClientKeyExchangeKey = CRYPT_NULL;
    m_hClientSignatureKey = CRYPT_NULL;

}   // IIS_CRYPTO_EXCHANGE_SERVER::IIS_CRYPTO_EXCHANGE_SERVER


IIS_CRYPTO_EXCHANGE_SERVER::~IIS_CRYPTO_EXCHANGE_SERVER()

/*++

Routine Description:

    IIS_CRYPTO_EXCHANGE_SERVER class destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Close any open keys.
    //

    CLOSE_KEY( m_hClientKeyExchangeKey );
    CLOSE_KEY( m_hClientSignatureKey );

}   // IIS_CRYPTO_EXCHANGE_SERVER::~IIS_CRYPTO_EXCHANGE_SERVER


HRESULT
IIS_CRYPTO_EXCHANGE_SERVER::ServerPhase1(
    IN PIIS_CRYPTO_BLOB pClientKeyExchangeKeyBlob,
    IN PIIS_CRYPTO_BLOB pClientSignatureKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerKeyExchangeKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerSignatureKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerSessionKeyBlob
    )

/*++

Routine Description:

    Performs server-side phase 1 of the multi-phase key exchange protocol.

Arguments:

    pClientKeyExchangeKeyBlob - Pointer to the client's key exchange key
        public blob.

    pClientSignatureKeyBlob - Pointer to the client's signature public
        blob.

    ppServerKeyExchangeKeyBlob - Receives a pointer to the server's key
        exchange key public blob if successful. It is the server's
        responsibility to (somehow) transmit this to the client.

    ppServerSignatureKeyBlob - Receives a pointer to the server's signature
        public blob if successful. It is the server's responsibility to
        (somehow) transmit this to the client.

    ppServerSessionKeyBlob - Receives a pointer to the server's
        session key blob if successful. It is the server's responsibility
        to (somehow) transmit this to the client.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB keyExchangeKeyBlob = NULL;
    PIIS_CRYPTO_BLOB signatureKeyBlob = NULL;
    PIIS_CRYPTO_BLOB sessionKeyBlob = NULL;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( pClientKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( ::IISCryptoIsValidBlob( pClientKeyExchangeKeyBlob ) );
    DBG_ASSERT( pClientSignatureKeyBlob != NULL );
    DBG_ASSERT( ::IISCryptoIsValidBlob( pClientSignatureKeyBlob ) );
    DBG_ASSERT( ppServerKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( ppServerSessionKeyBlob != NULL );

    //
    // Import the client's keys.
    //

    DBG_ASSERT( m_hClientKeyExchangeKey == CRYPT_NULL );
    result = ::IISCryptoImportPublicKeyBlob(
                  &m_hClientKeyExchangeKey,
                  pClientKeyExchangeKeyBlob,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    DBG_ASSERT( m_hClientSignatureKey == CRYPT_NULL );
    result = ::IISCryptoImportPublicKeyBlob(
                  &m_hClientSignatureKey,
                  pClientSignatureKeyBlob,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Export the key exchange key blob.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                   &keyExchangeKeyBlob,
                   m_hProv,
                   m_hKeyExchangeKey
                   );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Export the signature key blob.
    //

    result = ::IISCryptoExportPublicKeyBlob(
                  &signatureKeyBlob,
                  m_hProv,
                  m_hSignatureKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Generate our local session key.
    //

    DBG_ASSERT( m_hServerSessionKey == CRYPT_NULL );
    result = ::IISCryptoGenerateSessionKey(
                  &m_hServerSessionKey,
                  m_hProv
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Export it.
    //

    result = SafeExportSessionKeyBlob(
                  &sessionKeyBlob,
                  m_hProv,
                  m_hServerSessionKey,
                  m_hClientKeyExchangeKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    *ppServerKeyExchangeKeyBlob = keyExchangeKeyBlob;
    *ppServerSignatureKeyBlob = signatureKeyBlob;
    *ppServerSessionKeyBlob = sessionKeyBlob;

    return NO_ERROR;

fatal:

    FREE_BLOB(sessionKeyBlob);
    FREE_BLOB(signatureKeyBlob);
    FREE_BLOB(keyExchangeKeyBlob);

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_SERVER::ServerPhase1


HRESULT
IIS_CRYPTO_EXCHANGE_SERVER::ServerPhase2(
    IN PIIS_CRYPTO_BLOB pClientSessionKeyBlob,
    IN PIIS_CRYPTO_BLOB pClientHashBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerHashBlob
    )

/*++

Routine Description:

    Performs server-side phase 2 of the multi-phase key exchange protocol.

Arguments:

    pClientSessionKeyBlob - Pointer to the client's session key blob.

    pClientHashBlob - Pointer to the client's hash blob.

    ppServerHashBlob - Receives a pointer to the server's hash blob
        if successful.


Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB phase3HashBlob;
    PIIS_CRYPTO_BLOB phase4HashBlob;

    //
    // Sanity check.
    //

    DBG_ASSERT( ValidateState() );
    DBG_ASSERT( pClientSessionKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pClientSessionKeyBlob ) );
    DBG_ASSERT( pClientHashBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pClientHashBlob ) );
    DBG_ASSERT( ppServerHashBlob != NULL );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    phase3HashBlob = NULL;
    phase4HashBlob = NULL;

    //
    // Import the client's session key.
    //

    DBG_ASSERT( m_hClientSessionKey == CRYPT_NULL );
    result = SafeImportSessionKeyBlob(
                  &m_hClientSessionKey,
                  pClientSessionKeyBlob,
                  m_hProv,
                  m_hClientSignatureKey
                  );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Create the phase 3 hash and compare it with the incoming hash.
    //

    result = CreatePhase3Hash(
                 &phase3HashBlob
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    if( !::IISCryptoCompareBlobs(
              pClientHashBlob,
              phase3HashBlob
              ) ) {

        result = ERROR_INVALID_DATA;
        goto fatal;

    }

    //
    // Create the phase 4 hash to return to the client.
    //

    result = CreatePhase4Hash(
                 &phase4HashBlob
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    *ppServerHashBlob = phase4HashBlob;
    FREE_BLOB( phase3HashBlob );

    return NO_ERROR;

fatal:

    FREE_BLOB( phase3HashBlob );
    FREE_BLOB( phase4HashBlob );

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IIS_CRYPTO_EXCHANGE_SERVER::ServerPhase2


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\icrypt\test\keyexch\client\makefile.inc ===
obj\$(TARGET_DIRECTORY)\exchcli.res: exchcli.rc

obj\$(TARGET_DIRECTORY)\exchcli2.res: exchcli2.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\icrypt\test\keyexch\server\exchsrv.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    exchsrv.cxx

Abstract:

    IIS Crypto server-side key exchange test.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define TEST_SOCKERR(api)                                                   \
            if( sockerr != NO_ERROR ) {                                     \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %d\n",                            \
                    api,                                                    \
                    __LINE__,                                               \
                    sockerr                                                 \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define FREE_BLOB(b)                                                        \
            if( b != NULL ) {                                               \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoFreeBlob( b );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoFreeBlob( %08lx ):%lu failed, error %08lx\n", \
                        b,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
                (b) = NULL;                                                 \
                                                                            \
            }


//
// Private types.
//


//
// Private globals.
//

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisKeySrvGuid, 
0x784d8929, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

CHAR ServerPlainText[] = "Server Server Server Server Server Server";


//
// Private prototypes.
//


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    INT sockerr;
    HRESULT result;
    IIS_CRYPTO_EXCHANGE_SERVER * pserver;
    BUFFERED_SOCKET * psocket;
    PIIS_CRYPTO_BLOB clientKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB clientSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB serverSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientHashBlob;
    PIIS_CRYPTO_BLOB serverHashBlob;
    PIIS_CRYPTO_BLOB dataBlob;
    IIS_CRYPTO_STORAGE * clientStorage;
    IIS_CRYPTO_STORAGE * serverStorage;
    PVOID buffer;
    DWORD bufferLength;
    DWORD bufferType;

    if( argc != 1 ) {

        printf(
            "use: exchsrv\n"
            );

        return 1;

    }

    //
    // Initialize debug stuff.
    //

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt", IisKeySrvGuid );
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt" );
#endif

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    pserver = NULL;
    psocket = NULL;
    clientKeyExchangeKeyBlob = NULL;
    clientSignatureKeyBlob = NULL;
    serverKeyExchangeKeyBlob = NULL;
    serverSignatureKeyBlob = NULL;
    serverSessionKeyBlob = NULL;
    clientSessionKeyBlob = NULL;
    clientHashBlob = NULL;
    serverHashBlob = NULL;
    dataBlob = NULL;
    clientStorage = NULL;
    serverStorage = NULL;

    //
    // Initialize the crypto package.
    //

    printf( "exchsrv: Initializing...\n" );

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Create & initialize the server-side key exchange object.
    //

    pserver = new IIS_CRYPTO_EXCHANGE_SERVER;

    if( pserver == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = pserver->Initialize(
                 CRYPT_NULL,
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );

    TEST_HRESULT( "pserver->Initialize()" );

    //
    // Create & initialize the buffered socket object.
    //

    psocket = new BUFFERED_SOCKET;

    if( psocket == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = psocket->InitializeServer( SERVER_PORT );

    TEST_HRESULT( "psocket->Initialize()" );

    //
    // 2. SERVER(1)
    //

    printf( "exchsrv: Phase 1...\n" );

    sockerr = psocket->RecvBlob( &clientKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &clientSignatureKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pserver->ServerPhase1(
                 clientKeyExchangeKeyBlob,
                 clientSignatureKeyBlob,
                 &serverKeyExchangeKeyBlob,
                 &serverSignatureKeyBlob,
                 &serverSessionKeyBlob
                 );
    TEST_HRESULT( "pserver->ServerPhase1()" );

    sockerr = psocket->SendBlob( serverKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( serverSignatureKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( serverSessionKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // 4. SERVER(2)
    //

    printf( "exchsrv: Phase 2...\n" );

    sockerr = psocket->RecvBlob( &clientSessionKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &clientHashBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pserver->ServerPhase2(
                 clientSessionKeyBlob,
                 clientHashBlob,
                 &serverHashBlob
                 );
    TEST_HRESULT( "pserver->ServerPhase2()" );

    sockerr = psocket->SendBlob( serverHashBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // Create the storage objects.
    //

    printf( "exchsrv: Creating storage objects...\n" );

    clientStorage = new IIS_CRYPTO_STORAGE;

    if( clientStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = clientStorage->Initialize(
                 pserver->QueryProviderHandle(),
                 pserver->AssumeClientSessionKey(),
                 CRYPT_NULL,
                 pserver->AssumeClientSignatureKey(),
                 TRUE
                 );
    TEST_HRESULT( "clientStorage->Initialize()" );

    serverStorage = new IIS_CRYPTO_STORAGE;

    if( serverStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = serverStorage->Initialize(
                 pserver->QueryProviderHandle(),
                 pserver->AssumeServerSessionKey(),
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );
    TEST_HRESULT( "serverStorage->Initialize()" );

    //
    // Receive some encrypted data.
    //

    printf( "exchsrv: Receiving encrypted data...\n" );

    sockerr = psocket->RecvBlob( &dataBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = clientStorage->DecryptData(
                 &buffer,
                 &bufferLength,
                 &bufferType,
                 dataBlob
                 );
    TEST_HRESULT( "clientStorage->DecryptData()" );

    printf( "exchsrv: Received data[%lu] = '%s'\n", bufferLength, buffer );

    FREE_BLOB( dataBlob );

    //
    // Send some encrypted data.
    //

    printf( "exchsrv: Encrypting '%s'...\n", ServerPlainText );

    result = serverStorage->EncryptData(
                 &dataBlob,
                 ServerPlainText,
                 sizeof(ServerPlainText),
                 REG_SZ
                 );
    TEST_HRESULT( "serverStorage->EncryptData()" );

    printf( "exchsrv: Sending encrypted data...\n" );

    sockerr = psocket->SendBlob( dataBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // Tests complete.
    //

    printf( "exchsrv: Done!\n" );

cleanup:

    FREE_BLOB( dataBlob );
    FREE_BLOB( serverHashBlob );
    FREE_BLOB( clientHashBlob );
    FREE_BLOB( clientSessionKeyBlob );
    FREE_BLOB( serverSessionKeyBlob );
    FREE_BLOB( serverSignatureKeyBlob );
    FREE_BLOB( serverKeyExchangeKeyBlob );
    FREE_BLOB( clientSignatureKeyBlob );
    FREE_BLOB( clientKeyExchangeKeyBlob );

    delete psocket;
    delete clientStorage;
    delete serverStorage;
    delete pserver;

    (VOID)IISCryptoTerminate();

    DELETE_DEBUG_PRINT_OBJECT();

    return 0;

}   // main


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\icrypt\test\keyexch\client\exchcli2.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    exchcli2.cxx

Abstract:

    IIS Crypto client-side key exchange test with security impersonation.

Author:

    Keith Moore (keithmo)        14-Oct-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define TEST_SOCKERR(api)                                                   \
            if( sockerr != NO_ERROR ) {                                     \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %d\n",                            \
                    api,                                                    \
                    __LINE__,                                               \
                    sockerr                                                 \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define FREE_BLOB(b)                                                        \
            if( b != NULL ) {                                               \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoFreeBlob( b );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoFreeBlob( %08lx ):%lu failed, error %08lx\n", \
                        b,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
                (b) = NULL;                                                 \
                                                                            \
            }

#define PACKAGE_NAME    L"NTLM"

#define KEY_CTRL_C      '\x03'
#define KEY_BACKSPACE   '\x08'
#define KEY_ENTER       '\x0d'
#define KEY_EOF         '\x1a'
#define KEY_ESCAPE      '\x1b'

#define STR_BEEP        "\x07"
#define STR_HIDDEN      "*"
#define STR_BACKSPACE   "\x08 \x08"

#define ALLOC_MEM(cb)   (PVOID)LocalAlloc( LPTR, (cb) )
#define FREE_MEM(p)     (VOID)LocalFree( (HLOCAL)(p) )

#define DIM(x)          (sizeof(x) / sizeof(x[0]))


//
// Private types.
//


//
// Private globals.
//

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisCrypt2Guid, 
0x784d8928, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

CHAR ClientPlainText[] = "Client Client Client Client Client Client";


//
// Private prototypes.
//

SECURITY_STATUS
MyLogonUser(
    IN LPWSTR UserName,
    IN LPWSTR UserDomain,
    IN LPWSTR UserPassword,
    OUT PCtxtHandle ServerContext,
    OUT PCredHandle ServerCredential
    );

BOOL
GetStringFromUser(
    LPSTR Prompt,
    LPWSTR String,
    ULONG MaxLength,
    BOOL Echo
    );


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    INT sockerr;
    HRESULT result;
    IIS_CRYPTO_EXCHANGE_CLIENT * pclient;
    BUFFERED_SOCKET * psocket;
    PIIS_CRYPTO_BLOB clientKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB clientSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB serverSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientHashBlob;
    PIIS_CRYPTO_BLOB serverHashBlob;
    PIIS_CRYPTO_BLOB dataBlob;
    IIS_CRYPTO_STORAGE * clientStorage;
    IIS_CRYPTO_STORAGE * serverStorage;
    PVOID buffer;
    DWORD bufferLength;
    DWORD bufferType;
    PSecurityFunctionTable ftab;
    CtxtHandle serverContext;
    CredHandle serverCredential;
    WCHAR name[128];
    WCHAR domain[128];
    WCHAR password[128];

    if( argc != 2 ) {

        printf(
            "use: exchcli2 target_server\n"
            );

        return 1;

    }

    //
    // Initialize debug stuff.
    //

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt", IisCrypt2Guid );
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt" );
#endif

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    pclient = NULL;
    psocket = NULL;
    clientKeyExchangeKeyBlob = NULL;
    clientSignatureKeyBlob = NULL;
    serverKeyExchangeKeyBlob = NULL;
    serverSignatureKeyBlob = NULL;
    serverSessionKeyBlob = NULL;
    clientSessionKeyBlob = NULL;
    clientHashBlob = NULL;
    serverHashBlob = NULL;
    dataBlob = NULL;
    clientStorage = NULL;
    serverStorage = NULL;

    //
    // Initialize SSPI.
    //

    ftab = InitSecurityInterface();

    if( ftab == NULL ) {
        sockerr = GetLastError();
        TEST_SOCKERR( "InitSecurityInterface()" );
    }

    //
    // Prompt for the user name, domain, and password.
    //

    if( !GetStringFromUser( "name: ", name, DIM(name), TRUE ) ||
        !GetStringFromUser( "domain: ", domain, DIM(domain), TRUE ) ||
        !GetStringFromUser( "password: ", password, DIM(password), FALSE ) ) {
        goto cleanup;
    }

    //
    // Logon.
    //

    result = MyLogonUser(
                 name,
                 domain,
                 password,
                 &serverContext,
                 &serverCredential
                 );

    RtlZeroMemory(
        password,
        sizeof(password)
        );

    TEST_HRESULT( "MyLogonUser" );

    result = ImpersonateSecurityContext( &serverContext );
    TEST_HRESULT( "ImpersonateSecurityContext" );

    //
    // Initialize the crypto package.
    //

    printf( "exchcli2: Initializing...\n" );

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Create & initialize the client-side key exchange object.
    //

    pclient = new IIS_CRYPTO_EXCHANGE_CLIENT;

    if( pclient == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = pclient->Initialize(
                 CRYPT_NULL,
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );

    TEST_HRESULT( "pclient->Initialize()" );

    //
    // Create & initialize the buffered socket object.
    //

    psocket = new BUFFERED_SOCKET;

    if( psocket == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = psocket->InitializeClient( argv[1], SERVER_PORT );

    TEST_HRESULT( "psocket->Initialize()" );

    //
    // 1. CLIENT(1)
    //

    printf( "exchcli2: Phase 1...\n" );

    result = pclient->ClientPhase1(
                 &clientKeyExchangeKeyBlob,
                 &clientSignatureKeyBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase1()" );

    sockerr = psocket->SendBlob( clientKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( clientSignatureKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // 3. CLIENT(2)
    //

    printf( "exchcli2: Phase 2...\n" );

    sockerr = psocket->RecvBlob( &serverKeyExchangeKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &serverSignatureKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    sockerr = psocket->RecvBlob( &serverSessionKeyBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pclient->ClientPhase2(
                 serverKeyExchangeKeyBlob,
                 serverSignatureKeyBlob,
                 serverSessionKeyBlob,
                 &clientSessionKeyBlob,
                 &clientHashBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase2()" );

    sockerr = psocket->SendBlob( clientSessionKeyBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    sockerr = psocket->SendBlob( clientHashBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    //
    // 5. CLIENT(3)
    //

    printf( "exchcli2: Phase 3...\n" );

    sockerr = psocket->RecvBlob( &serverHashBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = pclient->ClientPhase3(
                 serverHashBlob
                 );
    TEST_HRESULT( "pclient->ClientPhase3()" );

    //
    // Create the storage objects.
    //

    printf( "exchcli2: Creating storage objects...\n" );

    clientStorage = new IIS_CRYPTO_STORAGE;

    if( clientStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = clientStorage->Initialize(
                 pclient->QueryProviderHandle(),
                 pclient->AssumeClientSessionKey(),
                 CRYPT_NULL,
                 CRYPT_NULL,
                 TRUE
                 );
    TEST_HRESULT( "clientStorage->Initialize()" );

    serverStorage = new IIS_CRYPTO_STORAGE;

    if( serverStorage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    result = serverStorage->Initialize(
                 pclient->QueryProviderHandle(),
                 pclient->AssumeServerSessionKey(),
                 CRYPT_NULL,
                 pclient->AssumeServerSignatureKey(),
                 TRUE
                 );
    TEST_HRESULT( "serverStorage->Initialize()" );

    //
    // Send some encrypted data.
    //

    printf(
        "exchcli2: Encrypting '%s'...\n",
        ClientPlainText
        );

    result = clientStorage->EncryptData(
                 &dataBlob,
                 ClientPlainText,
                 sizeof(ClientPlainText),
                 REG_SZ
                 );
    TEST_HRESULT( "clientStorage->EncryptData()" );

    printf( "exchcli2: Sending encrypted data...\n" );

    sockerr = psocket->SendBlob( dataBlob );
    TEST_SOCKERR( "psocket->SendBlob()" );

    FREE_BLOB( dataBlob );

    //
    // Receive some encrypted data.
    //

    printf( "exchcli2: Receiving encrypted data...\n" );

    sockerr = psocket->RecvBlob( &dataBlob );
    TEST_SOCKERR( "psocket->RecvBlob()" );

    result = serverStorage->DecryptData(
                 &buffer,
                 &bufferLength,
                 &bufferType,
                 dataBlob
                 );
    TEST_HRESULT( "serverStorage->DecryptData()" );

    printf(
        "exchcli2: Received data[%lu] = '%s'\n",
        bufferLength,
        buffer
        );

    //
    // Tests complete.
    //

    printf( "exchcli2: Done!\n" );

cleanup:

    FREE_BLOB( dataBlob );
    FREE_BLOB( serverHashBlob );
    FREE_BLOB( clientHashBlob );
    FREE_BLOB( clientSessionKeyBlob );
    FREE_BLOB( serverSessionKeyBlob );
    FREE_BLOB( serverSignatureKeyBlob );
    FREE_BLOB( serverKeyExchangeKeyBlob );
    FREE_BLOB( clientSignatureKeyBlob );
    FREE_BLOB( clientKeyExchangeKeyBlob );

    delete psocket;
    delete clientStorage;
    delete serverStorage;
    delete pclient;

    (VOID)IISCryptoTerminate();

    DELETE_DEBUG_PRINT_OBJECT();

    return 0;

}   // main


//
// Private functions.
//

SECURITY_STATUS
MyLogonUser(
    IN LPWSTR UserName,
    IN LPWSTR UserDomain,
    IN LPWSTR UserPassword,
    OUT PCtxtHandle ServerContext,
    OUT PCredHandle ServerCredential
    )
{

    SECURITY_STATUS status;
    PSecPkgInfoW packageInfo;
    PSEC_WINNT_AUTH_IDENTITY_W additionalCredentials;
    ULONG additionalCredentialsLength;
    LPWSTR next;
    CredHandle clientCredential;
    TimeStamp expiration;
    SecBufferDesc tokenBuffer1Desc;
    SecBuffer tokenBuffer1;
    SecBufferDesc tokenBuffer2Desc;
    SecBuffer tokenBuffer2;
    ULONG contextAttributes;
    CtxtHandle clientContext;
    PVOID rawTokenBuffer1;
    PVOID rawTokenBuffer2;
    BOOL haveClientCredential;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    packageInfo = NULL;
    additionalCredentials = NULL;
    rawTokenBuffer1 = NULL;
    rawTokenBuffer2 = NULL;
    haveClientCredential = FALSE;

    //
    // Get the package info. We must do this to get the maximum
    // token length.
    //

    status = QuerySecurityPackageInfoW(
                 PACKAGE_NAME,                  // pszPackageName
                 &packageInfo                   // ppPackageInfo
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    //
    // Allocate the token buffers.
    //

    rawTokenBuffer1 = ALLOC_MEM( packageInfo->cbMaxToken );
    rawTokenBuffer2 = ALLOC_MEM( packageInfo->cbMaxToken );

    if( rawTokenBuffer1 == NULL ||
        rawTokenBuffer2 == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Build the credential info containing the cleartext user name,
    // domain name, and password.
    //

    additionalCredentialsLength = sizeof(*additionalCredentials);

    if( UserName != NULL ) {
        additionalCredentialsLength += ( wcslen( UserName ) + 1 ) * sizeof(WCHAR);
    }

    if( UserDomain != NULL ) {
        additionalCredentialsLength += ( wcslen( UserDomain ) + 1 ) * sizeof(WCHAR);
    }

    if( UserPassword != NULL ) {
        additionalCredentialsLength += ( wcslen( UserPassword ) + 1 ) * sizeof(WCHAR);
    }

    additionalCredentials = (PSEC_WINNT_AUTH_IDENTITY_W)ALLOC_MEM( additionalCredentialsLength );

    if( additionalCredentials == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(
        additionalCredentials,
        additionalCredentialsLength
        );

    next = (LPWSTR)( additionalCredentials + 1 );

    additionalCredentials->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    if( UserName != NULL ) {
        additionalCredentials->User = (unsigned short *)next;
        additionalCredentials->UserLength = wcslen( UserName );
        wcscpy( next, UserName );
        next += additionalCredentials->UserLength + 1;
    }

    if( UserDomain != NULL ) {
        additionalCredentials->Domain = (unsigned short *)next;
        additionalCredentials->DomainLength = wcslen( UserDomain );
        wcscpy( next, UserDomain );
        next += additionalCredentials->DomainLength + 1;
    }

    if( UserPassword != NULL ) {
        additionalCredentials->Password = (unsigned short *)next;
        additionalCredentials->PasswordLength = wcslen( UserPassword );
        wcscpy( next, UserPassword );
        next += additionalCredentials->PasswordLength + 1;
    }

    //
    // Get the client-side credentials.
    //

    status = AcquireCredentialsHandleW(
                 NULL,                          // pszPrincipal
                 PACKAGE_NAME,                  // pszPackage
                 SECPKG_CRED_OUTBOUND,          // fCredentialUse
                 NULL,                          // pvLogonID
                 additionalCredentials,         // pAuthData
                 NULL,                          // pGetKeyFn
                 NULL,                          // pvGetKeyArgument
                 &clientCredential,             // phCredential
                 &expiration                    // ptsExpiry
                 );

    RtlZeroMemory(
        additionalCredentials->Password,
        additionalCredentials->PasswordLength
        );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    haveClientCredential = TRUE;

    //
    // Get the server-side credentials.
    //

    status = AcquireCredentialsHandleW(
                 NULL,                          // pszPrincipal
                 PACKAGE_NAME,                  // pszPackage
                 SECPKG_CRED_INBOUND,           // fCredentialUse
                 NULL,                          // pvLogonID
                 NULL,                          // pAuthData
                 NULL,                          // pGetKeyFn
                 NULL,                          // pvGetKeyArgument
                 ServerCredential,              // phCredential
                 &expiration                    // ptsExpiry
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    //
    // Initialize the client-side security context.
    //

    tokenBuffer1Desc.cBuffers = 1;
    tokenBuffer1Desc.pBuffers = &tokenBuffer1;
    tokenBuffer1Desc.ulVersion = SECBUFFER_VERSION;

    tokenBuffer1.BufferType = SECBUFFER_TOKEN;
    tokenBuffer1.cbBuffer = packageInfo->cbMaxToken;
    tokenBuffer1.pvBuffer = rawTokenBuffer1;

    status = InitializeSecurityContext(
                 &clientCredential,             // phCredential
                 NULL,                          // phContext
                 NULL,                          // pszTargetName
                 ISC_REQ_REPLAY_DETECT,         // fContextReq
                 0,                             // Reserved1
                 SECURITY_NATIVE_DREP,          // TargetDataRep,
                 NULL,                          // pInput
                 0,                             // Reserved2
                 &clientContext,                // phNewContext
                 &tokenBuffer1Desc,             // pOutput,
                 &contextAttributes,            // pfContextAttr,
                 &expiration                    // ptsExpiry
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    //
    // Import the client-side context into the server side.
    //

    tokenBuffer2Desc.cBuffers = 1;
    tokenBuffer2Desc.pBuffers = &tokenBuffer2;
    tokenBuffer2Desc.ulVersion = SECBUFFER_VERSION;

    tokenBuffer2.BufferType = SECBUFFER_TOKEN;
    tokenBuffer2.cbBuffer = packageInfo->cbMaxToken;
    tokenBuffer2.pvBuffer = rawTokenBuffer2;

    status = AcceptSecurityContext(
                 ServerCredential,              // phCredential
                 NULL,                          // phContext
                 &tokenBuffer1Desc,             // pInput
                 0,                             // fContextReq
                 SECURITY_NATIVE_DREP,          // TargetDataRep
                 ServerContext,                 // phNewContext
                 &tokenBuffer2Desc,             // pOutput
                 &contextAttributes,            // pfContextAttr
                 &expiration                    // ptsExpiry
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    //
    // Pass it back into the client.
    //

    tokenBuffer1Desc.cBuffers = 1;
    tokenBuffer1Desc.pBuffers = &tokenBuffer1;
    tokenBuffer1Desc.ulVersion = SECBUFFER_VERSION;

    tokenBuffer1.BufferType = SECBUFFER_TOKEN;
    tokenBuffer1.cbBuffer = packageInfo->cbMaxToken;
    tokenBuffer1.pvBuffer = rawTokenBuffer1;

    status = InitializeSecurityContext(
                 &clientCredential,             // phCredential
                 &clientContext,                // phContext
                 NULL,                          // pszTargetName
                 0,                             // fContextReq
                 0,                             // Reserved1
                 SECURITY_NATIVE_DREP,          // TargetDataRep,
                 &tokenBuffer2Desc,             // pInput
                 0,                             // Reserved2
                 &clientContext,                // phNewContext
                 &tokenBuffer1Desc,             // pOutput,
                 &contextAttributes,            // pfContextAttr,
                 &expiration                    // ptsExpiry
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

    //
    // And one last time back into the server.
    //

    tokenBuffer2Desc.cBuffers = 1;
    tokenBuffer2Desc.pBuffers = &tokenBuffer2;
    tokenBuffer2Desc.ulVersion = SECBUFFER_VERSION;

    tokenBuffer2.BufferType = SECBUFFER_TOKEN;
    tokenBuffer2.cbBuffer = packageInfo->cbMaxToken;
    tokenBuffer2.pvBuffer = rawTokenBuffer2;

    status = AcceptSecurityContext(
                 ServerCredential,              // phCredential
                 ServerContext,                 // phContext
                 &tokenBuffer1Desc,             // pInput
                 0,                             // fContextReq
                 SECURITY_NATIVE_DREP,          // TargetDataRep
                 ServerContext,                 // phNewContext
                 NULL,                          // pOutput
                 &contextAttributes,            // pfContextAttr
                 &expiration                    // ptsExpiry
                 );

    if( FAILED(status) ) {
        goto Cleanup;
    }

Cleanup:

    if( haveClientCredential ) {
        FreeCredentialsHandle( &clientCredential );
    }

    if( rawTokenBuffer2 != NULL ) {
        FREE_MEM( rawTokenBuffer2 );
    }

    if( rawTokenBuffer1 != NULL ) {
        FREE_MEM( rawTokenBuffer1 );
    }

    if( additionalCredentials != NULL ) {
        FREE_MEM( additionalCredentials );
    }

    if( packageInfo != NULL ) {
        FreeContextBuffer( packageInfo );
    }

    return status;

}   // MyLogonUser

BOOL
GetStringFromUser(
    LPSTR Prompt,
    LPWSTR String,
    ULONG MaxLength,
    BOOL Echo
    )
{

    ULONG length;
    INT ch;

    printf( "%s", Prompt );

    length = 0;

    for( ; ; ) {

        ch = _getch();

        switch( ch ) {

        case KEY_CTRL_C :
            return FALSE;

        case KEY_BACKSPACE :
            if( length == 0 ) {

                printf( STR_BEEP );

            } else {

                length--;
                printf( STR_BACKSPACE );

            }
            break;

        case KEY_ENTER :
        case KEY_EOF :
            String[length] = L'\0';
            printf( "\n" );
            return TRUE;

        case KEY_ESCAPE :
            while( length > 0 ) {

                length--;
                printf( STR_BACKSPACE );

            }
            break;

        default :
            if( length < MaxLength ) {

                String[length++] = (WCHAR)ch;

                if( Echo ) {
                    printf( "%c", ch );
                } else {
                    printf( STR_HIDDEN );
                }

            } else {

                printf( STR_BEEP );

            }
            break;

        }

    }

    return TRUE;

}   // GetStringFromUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\icrypt\test\lib\buffsock.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    buffsock.cxx

Abstract:

    Implements the BUFFERED_SOCKET class.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define BUFFER_LENGTH   4096    // bytes

#define ALLOC_MEM(cb) (PVOID)::LocalAlloc(LPTR, (cb))
#define FREE_MEM(p) (VOID)::LocalFree((HLOCAL)(p))


//
// Private types.
//


//
// Private globals.
//

LONG BUFFERED_SOCKET::m_InitCount = -1;


//
// Private prototypes.
//


//
// Public functions.
//


BUFFERED_SOCKET::BUFFERED_SOCKET()
{

    m_Socket = INVALID_SOCKET;
    m_Buffer = NULL;
    m_BufferLength = 0;
    m_BytesAvailable = NULL;
    m_Offset = 0;
    m_Initialized = FALSE;

}   // BUFFERED_SOCKET::BUFFERED_SOCKET()


BUFFERED_SOCKET::~BUFFERED_SOCKET()
{

    if( m_Socket != INVALID_SOCKET ) {

        ::closesocket( m_Socket );

    }

    if( m_Buffer != NULL ) {

        FREE_MEM( m_Buffer );

    }

    if( ::InterlockedDecrement( &BUFFERED_SOCKET::m_InitCount ) == -1 ) {

        ::WSACleanup();

    }

}   // BUFFERED_SOCKET::~BUFFERED_SOCKET()


INT
BUFFERED_SOCKET::InitializeClient(
    LPSTR HostName,
    USHORT Port
    )
{

    LPHOSTENT hostent;
    INT result;
    SOCKADDR_IN addr;

    result = CommonInitialize();

    if( result != 0 ) {

        return result;

    }

    addr.sin_family = AF_INET;
    addr.sin_port = htons( Port );
    addr.sin_addr.s_addr = ::inet_addr( HostName );

    if( addr.sin_addr.s_addr == INADDR_NONE ) {

        hostent = ::gethostbyname( HostName );

        if( hostent == NULL ) {

            return ::WSAGetLastError();

        }

        addr.sin_addr.s_addr = *(PULONG)hostent->h_addr_list[0];

    }

    return InitializeClient( &addr );

}   // BUFFERED_SOCKET::InitializeClient


INT
BUFFERED_SOCKET::InitializeClient(
    LPSOCKADDR_IN HostAddress
    )
{

    INT result;

    result = CommonInitialize();

    if( result != 0 ) {

        return result;

    }

    if( m_Socket == INVALID_SOCKET ) {

        m_Socket = ::socket(
                        AF_INET,
                        SOCK_STREAM,
                        0
                        );

        if( m_Socket == INVALID_SOCKET ) {

            return ::WSAGetLastError();

        }

    }

    if( ::connect(
            m_Socket,
            (SOCKADDR *)HostAddress,
            sizeof(*HostAddress)
            ) == SOCKET_ERROR ) {

        return ::WSAGetLastError();

    }

    return InitializeClient( m_Socket );

}   // BUFFERED_SOCKET::InitializeClient


INT
BUFFERED_SOCKET::InitializeClient(
    SOCKET Socket
    )
{

    INT result;

    result = CommonInitialize();

    if( result != 0 ) {

        return result;

    }

    m_Socket = Socket;

    return 0;

}   // BUFFERED_SOCKET::InitializeClient


INT
BUFFERED_SOCKET::InitializeServer(
    USHORT Port
    )
{

    INT result;
    SOCKET tmpSocket;
    SOCKADDR_IN addr;

    result = CommonInitialize();

    if( result != 0 ) {

        return result;

    }

    tmpSocket = ::socket(
                     AF_INET,
                     SOCK_STREAM,
                     0
                     );

    if( tmpSocket == INVALID_SOCKET ) {

        return ::WSAGetLastError();

    }

    addr.sin_family = AF_INET;
    addr.sin_port = htons( Port );
    addr.sin_addr.s_addr = INADDR_ANY;

    result = ::bind(
                 tmpSocket,
                 (SOCKADDR *)&addr,
                 sizeof(addr)
                 );

    if( result == SOCKET_ERROR ) {

        result = ::WSAGetLastError();
        ::closesocket( tmpSocket );
        return result;

    }

    result = ::listen(
                 tmpSocket,
                 1
                 );

    if( result == SOCKET_ERROR ) {

        result = ::WSAGetLastError();
        ::closesocket( tmpSocket );
        return result;

    }

    m_Socket = ::accept(
                    tmpSocket,
                    NULL,
                    NULL
                    );

    if( m_Socket == INVALID_SOCKET ) {

        result = ::WSAGetLastError();
        ::closesocket( tmpSocket );
        return result;

    }

    ::closesocket( tmpSocket );
    return 0;

}   // BUFFERED_SOCKET::InitializeClient


INT
BUFFERED_SOCKET::Send(
    PVOID Buffer,
    LPDWORD BufferLength
    )
{

    INT result;

    result = ::send(
                  m_Socket,
                  (CHAR *)Buffer,
                  (INT)*BufferLength,
                  0
                  );

    if( result == SOCKET_ERROR ) {

        return ::WSAGetLastError();

    }

    *BufferLength = (DWORD)result;
    return 0;

}   // BUFFERED_SOCKET::Send


INT
BUFFERED_SOCKET::Recv(
    PVOID Buffer,
    LPDWORD BufferLength
    )
{

    INT result;

    result = ::recv(
                  m_Socket,
                  (CHAR *)Buffer,
                  (INT)*BufferLength,
                  0
                  );

    if( result == SOCKET_ERROR ) {

        return ::WSAGetLastError();

    }

    *BufferLength = (DWORD)result;
    return 0;

}   // BUFFERED_SOCKET::Recv


INT
BUFFERED_SOCKET::SendFrame(
    PVOID Buffer,
    LPDWORD BufferLength
    )
{

    INT result;
    WSABUF buffers[2];

    buffers[0].len = sizeof(DWORD);
    buffers[0].buf = (CHAR *)BufferLength;
    buffers[1].len = *BufferLength;
    buffers[1].buf = (CHAR *)Buffer;

    result = ::WSASend(
                  m_Socket,
                  buffers,
                  2,
                  BufferLength,
                  0,
                  NULL,
                  NULL
                  );

    if( result == SOCKET_ERROR ) {

        return ::WSAGetLastError();

    }

    *BufferLength -= sizeof(DWORD);
    return 0;

}   // BUFFERED_SOCKET::SendFrame


INT
BUFFERED_SOCKET::RecvFrame(
    PVOID Buffer,
    LPDWORD BufferLength
    )
{

    INT result;
    DWORD frameLength;

    result = BufferedRecv( &frameLength, sizeof(frameLength) );

    if( result != 0 ) {

        return result;

    }

    if( frameLength > *BufferLength ) {

        return WSAEMSGSIZE;

    }

    result = BufferedRecv( Buffer, frameLength );

    if( result != 0 ) {

        return result;

    }

    *BufferLength = frameLength;
    return 0;

}   // BUFFERED_SOCKET::RecvFrom


INT
BUFFERED_SOCKET::SendBlob(
    PIIS_CRYPTO_BLOB Blob
    )
{

    DWORD length;

    length = IISCryptoGetBlobLength( Blob );

    return SendFrame(
               (PVOID)Blob,
               &length
               );

}   // BUFFERED_SOCKET::SendFrame


INT
BUFFERED_SOCKET::RecvBlob(
    PIIS_CRYPTO_BLOB * ppBlob
    )
{

    INT result;
    DWORD blobLength;
    PIIS_CRYPTO_BLOB blob;

    result = BufferedRecv( &blobLength, sizeof(blobLength) );

    if( result != 0 ) {

        return result;

    }

    blob = (PIIS_CRYPTO_BLOB)ALLOC_MEM(blobLength);

    if( blob == NULL ) {

        return WSAENOBUFS;

    }

    result = BufferedRecv( blob, blobLength );

    if( result != 0 ) {

        return result;

    }

    *ppBlob = blob;
    return 0;

}   // BUFFERED_SOCKET::RecvFrom


//
// Private functions.
//


INT
BUFFERED_SOCKET::BufferedRecv(
    PVOID Buffer,
    DWORD BufferLength
    )
{

    PCHAR buffer = (PCHAR)Buffer;
    DWORD bytesToCopy;
    INT result;

    while( BufferLength > 0 ) {

        if( m_BytesAvailable == 0 ) {

            m_BytesAvailable = m_BufferLength;
            result = Recv( m_Buffer, &m_BytesAvailable );

            if( result != 0 ) {

                return result;

            }

            if( m_BytesAvailable == 0 ) {

                return WSAEMSGSIZE;

            }

            m_Offset = 0;

        }

        bytesToCopy = min( m_BytesAvailable, BufferLength );

        memcpy(
            buffer,
            (PCHAR)m_Buffer + m_Offset,
            bytesToCopy
            );

        m_Offset += bytesToCopy;
        m_BytesAvailable -= bytesToCopy;
        BufferLength -= bytesToCopy;

    }

    return 0;

}   // BUFFERED_SOCKET::BufferedRecv


INT
BUFFERED_SOCKET::CommonInitialize()
{

    INT result = 0;
    WSADATA data;

    if( m_Initialized ) {

        return 0;

    }

    if( m_Buffer == NULL ) {

        m_Buffer = ALLOC_MEM( BUFFER_LENGTH );

        if( m_Buffer == NULL ) {

            return WSAENOBUFS;

        }

    }

    m_BufferLength = BUFFER_LENGTH;
    m_BytesAvailable = 0;
    m_Offset = 0;

    if( ::InterlockedIncrement( &BUFFERED_SOCKET::m_InitCount ) == 0 ) {

        result = ::WSAStartup( 0x0202, &data );

    }

    m_Initialized = ( result == 0 );

    return result;

}   // BUFFERED_SOCKET::CommonInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\icrypt\test\simple\icrypt.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    icrypt.cxx

Abstract:

    IIS Crypto test app.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define CLOSE_KEY(h)                                                        \
            if( h != CRYPT_NULL ) {                                         \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoCloseKey( h );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoCloseKey( %08lx ):%lu failed, error %08lx\n", \
                        h,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }

#define DESTROY_HASH(h)                                                     \
            if( h != CRYPT_NULL ) {                                         \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoDestroyHash( h );                        \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoDestroyHash( %08lx ):%lu failed, error %08lx\n", \
                        h,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }

#define FREE_BLOB(b)                                                        \
            if( b != NULL ) {                                               \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoFreeBlob( b );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoFreeBlob( %08lx ):%lu failed, error %08lx\n", \
                        b,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }


//
// Private types.
//


//
// Private globals.
//

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisICryptGuid, 
0x784d892A, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

CHAR PlainText[] = "This is our sample plaintext that we'll encrypt.";


//
// Private prototypes.
//


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    HRESULT result;
    IIS_CRYPTO_STORAGE * storage;
    PVOID buffer;
    DWORD bufferLength;
    DWORD type;
    PIIS_CRYPTO_BLOB dataBlob;

    //
    // Initialize debug stuff.
    //

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt", IisICryptGuid );
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt" );
#endif

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    storage = NULL;
    dataBlob = NULL;

    //
    // Initialize the crypto package.
    //

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Create the crypto storage object.
    //

    storage = new(IIS_CRYPTO_STORAGE);

    if( storage == NULL ) {

        printf( "out of memory\n" );
        goto cleanup;

    }

    //
    // Initialize with a new session key.
    //

    result = storage->Initialize();
    TEST_HRESULT( "storage->Initialize()" );

    //
    // Create an encrypted data blob.
    //

    printf( "PlainText[%lu] = %s\n", sizeof(PlainText), PlainText );

    result = storage->EncryptData(
                 &dataBlob,
                 PlainText,
                 sizeof(PlainText),
                 REG_SZ
                 );

    TEST_HRESULT( "storage->EncryptData()" );
    printf( "dataBlob = %08lx\n", dataBlob );

    //
    // Decrypt the data blob.
    //

    result = storage->DecryptData(
                 &buffer,
                 &bufferLength,
                 &type,
                 dataBlob
                 );

    TEST_HRESULT( "storage->DecryptData()" );
    printf( "decrypted data[%lu] = %s\n", bufferLength, buffer );

cleanup:

    FREE_BLOB( dataBlob );
    delete storage;

    (VOID)IISCryptoTerminate();

    DELETE_DEBUG_PRINT_OBJECT();

    return 0;

}   // main


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\contain.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    contain.c

Abstract:

    Container manipulators for the IIS cryptographic package.

    The following routines are exported by this module:

        IISCryptoGetStandardContainer
        IISCryptoGetStandardContainer2
        IISCryptoGetContainerByName
        IISCryptoDeleteContainer
        IISCryptoCloseContainer

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//

HRESULT
IcpGetContainerHelper(
    OUT HCRYPTPROV * phProv,
    IN LPCTSTR pszContainer,
    IN LPCTSTR pszProvider,
    IN DWORD dwProvType,
    IN DWORD dwAdditionalFlags,
    IN BOOL fApplyAcl
    );


//
// Public functions.
//


HRESULT
WINAPI
IISCryptoGetStandardContainer(
    OUT HCRYPTPROV * phProv,
    IN DWORD dwAdditionalFlags
    )

/*++

Routine Description:

    This routine attempts to open the crypto key container. If the
    container does not yet exist, this routine will attempt to create
    it.

Arguments:

    phProv - Receives the provider handle if successful.

    dwAdditionalFlags - Any additional flags that should be passed to
        the CryptAcquireContext() API. This is typically used by server
        processes that pass in the CRYPT_MACHINE_KEYSET flag.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phProv != NULL );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_NEWKEYSET ) == 0 );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_DELETEKEYSET ) == 0 );

    //
    // Let IcpGetContainerHelper() do the dirty work.
    //

    result = IcpGetContainerHelper(
                 phProv,
                 IC_CONTAINER,
                 IC_PROVIDER,
                 IC_PROVTYPE,
                 dwAdditionalFlags,
                 ( dwAdditionalFlags & CRYPT_MACHINE_KEYSET ) != 0
                 );

    return result;

}   // IISCryptoGetStandardContainer

HRESULT
WINAPI
IISCryptoGetStandardContainer2(
    OUT HCRYPTPROV * phProv
    )

/*++

Routine Description:

    This routine attempts to open the crypto key container. If the
    container does not yet exist, this routine will attempt to create
    it.

Arguments:

    phProv - Receives the provider handle if successful.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phProv != NULL );

    //
    // Let IcpGetContainerHelper() do the dirty work.
    //

    result = IcpGetContainerHelper(
                 phProv,
                 NULL,
                 NULL,
                 IC_PROVTYPE,
                 CRYPT_VERIFYCONTEXT,
                 FALSE
                 );

    return result;

}   // IISCryptoGetStandardContainer2

HRESULT
WINAPI
IISCryptoGetContainerByName(
    OUT HCRYPTPROV * phProv,
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags,
    IN BOOL fApplyAcl
    )

/*++

Routine Description:

    This routine attempts to open a specific named crypto key container.
    If the container does not yet exist, this routine will attempt to
    create it and (optionally) apply an ACL to the container.

Arguments:

    phProv - Receives the provider handle if successful.

    pszContainerName - The name of the container to open/create.
                       NULL means temporary container  

    dwAdditionalFlags - Any additional flags that should be passed to
        the CryptAcquireContext() API. This is typically used by server
        processes that pass in the CRYPT_MACHINE_KEYSET flag.

    fApplyAcl - If TRUE, then an ACL is applied to the container.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phProv != NULL );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_NEWKEYSET ) == 0 );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_DELETEKEYSET ) == 0 );

    //
    // Let IcpGetContainerHelper() do the dirty work.
    //

    result = IcpGetContainerHelper(
                 phProv,
                 pszContainerName,
                 IC_PROVIDER,
                 IC_PROVTYPE,
                 dwAdditionalFlags,
                 fApplyAcl
                 );

    return result;

}   // IISCryptoGetContainerByName


HRESULT
WINAPI
IISCryptoDeleteStandardContainer(
    IN DWORD dwAdditionalFlags
    )

/*++

Routine Description:

    This routine deletes the standard crypto key container.

Arguments:

    dwAdditionalFlags - Any additional flags that should be passed to
        the CryptAcquireContext() API. This is typically used by server
        processes that pass in the CRYPT_MACHINE_KEYSET flag.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    HCRYPTPROV cryptProv;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_NEWKEYSET ) == 0 );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_DELETEKEYSET ) == 0 );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        return NO_ERROR;
    }

    //
    // Delete the container.
    //

    status = CryptAcquireContext(
                &cryptProv,
                IC_CONTAINER,
                IC_PROVIDER,
                IC_PROVTYPE,
                CRYPT_DELETEKEYSET | dwAdditionalFlags
                );

    if( !status ) {
        result = IcpGetLastError();
    }

    return result;

}   // IISCryptoDeleteStandardContainer


HRESULT
WINAPI
IISCryptoDeleteContainerByName(
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags
    )

/*++

Routine Description:

    This routine deletes the specified crypto key container.

Arguments:

    pszContainerName - The name of the container to delete.

    dwAdditionalFlags - Any additional flags that should be passed to
        the CryptAcquireContext() API. This is typically used by server
        processes that pass in the CRYPT_MACHINE_KEYSET flag.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    HCRYPTPROV cryptProv;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_NEWKEYSET ) == 0 );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_DELETEKEYSET ) == 0 );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        return NO_ERROR;
    }

    //
    // Delete the container.
    //

    status = CryptAcquireContext(
                &cryptProv,
                pszContainerName,
                IC_PROVIDER,
                IC_PROVTYPE,
                CRYPT_DELETEKEYSET | dwAdditionalFlags
                );

    if( !status ) {
        result = IcpGetLastError();
    }

    return result;

}   // IISCryptoDeleteContainerByName


HRESULT
WINAPI
IISCryptoCloseContainer(
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine closes the container associated with the specified
    provider handle.

Arguments:

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    BOOL status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV ) {
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Close the provider.
    //

    status = CryptReleaseContext(
                 hProv,
                 0
                 );

    if( status ) {

        UpdateContainersClosed();
        return NO_ERROR;

    }

    return IcpGetLastError();

}   // IISCryptoCloseContainer


//
// Private functions.
//


HRESULT
IcpGetContainerHelper(
    OUT HCRYPTPROV * phProv,
    IN LPCTSTR pszContainer,
    IN LPCTSTR pszProvider,
    IN DWORD dwProvType,
    IN DWORD dwAdditionalFlags,
    IN BOOL fApplyAcl
    )

/*++

Routine Description:

    This is a helper routine for IISCryptoGetContainer. It tries
    to open/create the specified container in the specified provider.

Arguments:

    phProv - Receives the provider handle if successful.

    pszContainer - The key container name.

    pszProvider - The provider name.

    dwProvType - The type of provider to acquire.

    dwAdditionalFlags - Any additional flags that should be passed to
        the CryptAcquireContext() API. This is typically used by server
        processes that pass in the CRYPT_MACHINE_KEYSET flag.

    fApplyAcl - If TRUE, then an ACL is applied to the container.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    HCRYPTPROV hProv;
    BOOL status;
    PSID systemSid;
    PSID adminSid;
    PACL dacl;
    DWORD daclSize;
    SECURITY_DESCRIPTOR securityDescriptor;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    BOOL isNt = FALSE;
    OSVERSIONINFO osInfo;

    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phProv != NULL );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_NEWKEYSET ) == 0 );
    DBG_ASSERT( ( dwAdditionalFlags & CRYPT_DELETEKEYSET ) == 0 );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        *phProv = DUMMY_HPROV;
        return NO_ERROR;
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hProv = CRYPT_NULL;
    systemSid = NULL;
    adminSid = NULL;
    dacl = NULL;

    //
    // Grab the lock protecting the container code. This is always
    // necessary to prevent race conditions between this code and
    // the code below that creates the container & adds a security
    // descriptor.
    //

    IcpAcquireGlobalLock();

    //
    // Try to open an existing container.
    //
    
    if ( pszContainer == NULL )
    {
        //
        // if container is NULL it means that temporary (ephemeral)
        // keys will be used
        // CRYPT_VERIFYCONTEXT must be used in this case
        // keys used for DCOM traffic encryption will be using 
        // NULL containers
        //

        status = CryptAcquireContext(
                     &hProv,
                     pszContainer,
                     pszProvider,
                     dwProvType,
                     CRYPT_VERIFYCONTEXT
                     );
        if( !status ) 
        {
            result = IcpGetLastError();
            DBGPRINTF(( DBG_CONTEXT,"IcpGetContainerHelper. CryptAcquireContext(advapi32.dll) with CRYPT_VERIFYCONTEXT failed err=0x%x\n",result));
            DBGPRINTF(( DBG_CONTEXT,"args for CryptAcquireContext(%p,%p,%p,%d,%d)\n",&hProv,pszContainer,pszProvider,dwProvType, CRYPT_VERIFYCONTEXT));

            goto fatal;
        }
        else
        {
            goto success;
        }
        
    }

    status = CryptAcquireContext(
                 &hProv,
                 pszContainer,
                 pszProvider,
                 dwProvType,
                 0 | dwAdditionalFlags
                 );

    if( !status ) {
        result = IcpGetLastError();
    }

    if( SUCCEEDED(result) ) {

        DBG_ASSERT( hProv != CRYPT_NULL );
        *phProv = hProv;

        IcpReleaseGlobalLock();

        UpdateContainersOpened();
        return NO_ERROR;

    }

    //
    // Could not open the container. If the failure was anything
    // other than NTE_BAD_KEYSET, then we're toast.
    //

    if( result != NTE_BAD_KEYSET ) {
        DBGPRINTF(( DBG_CONTEXT,"IcpGetContainerHelper. CryptAcquireContext(advapi32.dll) failed err=0x%x.toast.\n",result));
        DBGPRINTF(( DBG_CONTEXT,"args for CryptAcquireContext(%p,%p,%p,%d,%d)\n",&hProv,pszContainer,pszProvider,dwProvType,CRYPT_NEWKEYSET | dwAdditionalFlags));
        hProv = CRYPT_NULL;
        goto fatal;
    }

    if(result == NTE_BAD_KEYSET) 
    {
        DBGPRINTF(( DBG_CONTEXT,"CryptAcquireContext(%p,%p,%p,%d,%d) returned NTE_BAD_KEYSET, so lets create a keyset now...\n",&hProv,pszContainer,pszProvider,dwProvType,0 | dwAdditionalFlags));
    }

    //
    // OK, CryptAcquireContext() failed with NTE_BAD_KEYSET, meaning
    // that the container does not yet exist, so create it now.
    //

    status = CryptAcquireContext(
                 &hProv,
                 pszContainer,
                 pszProvider,
                 dwProvType,
                 CRYPT_NEWKEYSET | dwAdditionalFlags
                 );

    if( status ) {
        result = NO_ERROR;
    } else {
        result = IcpGetLastError();
    }

    if( FAILED(result) ) {
        DBGPRINTF(( DBG_CONTEXT,"IcpGetContainerHelper. CryptAcquireContext(advapi32.dll) failed err=0x%x.\n",result));
        DBGPRINTF(( DBG_CONTEXT,"args for CryptAcquireContext(%p,%p,%p,%d,%d)\n",&hProv,pszContainer,pszProvider,dwProvType,CRYPT_NEWKEYSET | dwAdditionalFlags));
        hProv = CRYPT_NULL;
        goto fatal;
    }

    //
    // We've created the container. If requested, then we must create
    // a security descriptor for the container. This security descriptor
    // allows full access to the the container by the local system and
    // the local administrators group. Other login contexts may not
    // access the container.
    //
    // Of course, we only need to do this under NT...
    //


    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } 

    if( fApplyAcl && isNt ) {

        //
        // Initialize the security descriptor.
        //

        status = InitializeSecurityDescriptor(
                     &securityDescriptor,
                     SECURITY_DESCRIPTOR_REVISION
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        //
        // Create the SIDs for the local system and admin group.
        //

        status = AllocateAndInitializeSid(
                     &ntAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &systemSid
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        status=  AllocateAndInitializeSid(
                     &ntAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &adminSid
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        //
        // Create the DACL containing an access-allowed ACE
        // for the local system and admin SIDs.
        //

        daclSize = sizeof(ACL)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(adminSid)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(systemSid)
                       - sizeof(DWORD);

        dacl = (PACL)IcpAllocMemory( daclSize );

        if( dacl == NULL ) {
            result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto fatal;
        }

        status = InitializeAcl(
                     dacl,
                     daclSize,
                     ACL_REVISION
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     dacl,
                     ACL_REVISION,
                     KEY_ALL_ACCESS,
                     systemSid
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     dacl,
                     ACL_REVISION,
                     KEY_ALL_ACCESS,
                     adminSid
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        //
        // Set the DACL into the security descriptor.
        //

        status = SetSecurityDescriptorDacl(
                     &securityDescriptor,
                     TRUE,
                     dacl,
                     FALSE
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

        //
        // And (finally!) set the security descriptor on the
        // container.
        //

        status = CryptSetProvParam(
                     hProv,
                     PP_KEYSET_SEC_DESCR,
                     (BYTE *)&securityDescriptor,
                     DACL_SECURITY_INFORMATION
                     );

        if( !status ) {
            result = IcpGetLastError();
            goto fatal;
        }

    }

success:
    //
    // Success!
    //

    DBG_ASSERT( hProv != CRYPT_NULL );
    *phProv = hProv;

    UpdateContainersOpened();
    result = NO_ERROR;

fatal:

    if( dacl != NULL ) {
        IcpFreeMemory( dacl );
    }

    if( adminSid != NULL ) {
        FreeSid( adminSid );
    }

    if( systemSid != NULL ) {
        FreeSid( systemSid );
    }

    if( hProv != CRYPT_NULL && FAILED(result) ) {
        DBG_REQUIRE( CryptReleaseContext(
                         hProv,
                         0
                         ) );
    }

    IcpReleaseGlobalLock();
    return result;

}   // IcpGetContainerHelper
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\data.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    data.c

Abstract:

    Data encryption/decryption routines for the IIS cryptographic
    package.

    The following routines are exported by this module:

        IISCryptoEncryptDataBlob
        IISCryptoDecryptDataBlob

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//

//
// The IC_DATA structure allows us to store our own private data
// along with the data we're encrypting for the application.
//

typedef struct _IC_DATA {

    DWORD RegType;
    // BYTE Data[];

} IC_DATA; 

typedef UNALIGNED64 IC_DATA *PIC_DATA;


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


HRESULT
WINAPI
IISCryptoEncryptDataBlob(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine encrypts a block of data, resulting in a data blob.
    The data blob contains the encrypted data and a digital signature
    validating the data.

Arguments:

    ppDataBlob - Receives a pointer to the newly created data blob if
        successful.

    pBuffer - The buffer to encrypt.

    dwBufferLength - The length of the buffer.

    dwRegType - The REG_* type to associate with this data.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to encrypt the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;
    PIC_BLOB blob;
    PIC_DATA data;
    DWORD dataLength;
    DWORD hashLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppDataBlob != NULL );
    DBG_ASSERT( pBuffer != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY ) {

            return IISCryptoCreateCleartextBlob(
                       ppDataBlob,
                       pBuffer,
                       dwBufferLength
                       );

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;
    hash = CRYPT_NULL;

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Determine the hash data length.
    //

    result = IcpGetHashLength(
                 &hashLength,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Determine the required size of the encrypted data.
    //

    dwBufferLength += sizeof(*data);
    dataLength = dwBufferLength;

	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();

    if( !CryptEncrypt(
            hSessionKey,
            CRYPT_NULL,
            TRUE,
            0,
            NULL,
            &dataLength,
            dwBufferLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;

    }
    
    IcpReleaseGlobalLock();

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob(
               DATA_BLOB_SIGNATURE,
               dataLength,
               hashLength
               );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Copy the data into the blob, then encrypt it.
    //

    data = (PIC_DATA)BLOB_TO_DATA(blob);
    data->RegType = dwRegType;

    RtlCopyMemory(
        data + 1,
        pBuffer,
        dwBufferLength - sizeof(*data)
        );

	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();
	
    if( !CryptEncrypt(
            hSessionKey,
            hash,
            TRUE,
            0,
            BLOB_TO_DATA(blob),
            &dwBufferLength,
            dataLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;
    }

    IcpReleaseGlobalLock();


    DBG_ASSERT( dataLength == blob->DataLength );

    //
    // Generate the signature.
    //

    if( !CryptSignHash(
            hash,
            AT_SIGNATURE,
            NULL,
            0,
            BLOB_TO_SIGNATURE(blob),
            &hashLength
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    DBG_ASSERT( hashLength == blob->SignatureLength );

    //
    // Success!
    //

    DBG_ASSERT( IISCryptoIsValidBlob( (PIIS_CRYPTO_BLOB)blob ) );
    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    *ppDataBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoEncryptDataBlob

HRESULT
WINAPI
IISCryptoEncryptDataBlob2(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine encrypts a block of data, resulting in a data blob.
    The data blob contains the encrypted data and a digital signature
    validating the data.

Arguments:

    ppDataBlob - Receives a pointer to the newly created data blob if
        successful.

    pBuffer - The buffer to encrypt.

    dwBufferLength - The length of the buffer.

    dwRegType - The REG_* type to associate with this data.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to encrypt the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;
    PIC_BLOB blob;
    PIC_DATA data;
    DWORD dataLength;
    DWORD hashLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppDataBlob != NULL );
    DBG_ASSERT( pBuffer != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY ) {

            return IISCryptoCreateCleartextBlob(
                       ppDataBlob,
                       pBuffer,
                       dwBufferLength
                       );

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;
    hash = CRYPT_NULL;

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Determine the hash data length.
    //

    result = IcpGetHashLength(
                 &hashLength,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Determine the required size of the encrypted data.
    //

    dwBufferLength += sizeof(*data);
    dataLength = dwBufferLength;


	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();
	
    if( !CryptEncrypt(
            hSessionKey,
            CRYPT_NULL,
            TRUE,
            0,
            NULL,
            &dataLength,
            dwBufferLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;
    }
	IcpReleaseGlobalLock();

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob(
               DATA_BLOB_SIGNATURE,
               dataLength,
               hashLength
               );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Copy the data into the blob, then encrypt it.
    //

    data = (PIC_DATA)BLOB_TO_DATA(blob);
    data->RegType = dwRegType;

    RtlCopyMemory(
        data + 1,
        pBuffer,
        dwBufferLength - sizeof(*data)
        );

	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();
	
    if( !CryptEncrypt(
            hSessionKey,
            hash,
            TRUE,
            0,
            BLOB_TO_DATA(blob),
            &dwBufferLength,
            dataLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;
    }
    IcpReleaseGlobalLock();


    DBG_ASSERT( dataLength == blob->DataLength );

    //
    // Success!
    //

    DBG_ASSERT( IISCryptoIsValidBlob( (PIIS_CRYPTO_BLOB)blob ) );
    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    *ppDataBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoEncryptDataBlob2


HRESULT
WINAPI
IISCryptoDecryptDataBlob(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hSignatureKey
    )

/*++

Routine Description:

    This routine validates and decrypts a data blob, resulting in a
    buffer containing plaintext.

    N.B. This routine effectively destroys the blob; once the data
    is decrypted, it cannot be decrypted again, as the data is
    decrypted "in place".

    N.B. The pointer returned in *ppBuffer points within the blob.
    This pointer will become invalid when the blob is freed. Note also
    that the calling application is still responsible for calling
    IISCryptoFreeBlob() on the data blob.

Arguments:

    ppBuffer - Receives a pointer to the data buffer if successful.

    pdwBufferLength - Receives the length of the data buffer.

    pdwRegType - Receives the REG_* type of the data.

    pDataBlob - The data blob to decrypt.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to decrypt the data.

    hSignatureKey - Handle to the encryption key to use when validating
        the digital signature.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;
    PIC_BLOB blob;
    PIC_DATA data;
    DWORD dataLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppBuffer != NULL );
    DBG_ASSERT( pdwBufferLength != NULL );
    DBG_ASSERT( pdwRegType != NULL );
    DBG_ASSERT( pDataBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pDataBlob ) );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );
    DBG_ASSERT( hSignatureKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY &&
            hSignatureKey == DUMMY_HSIGNATUREKEY &&
            pDataBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE
            ) {

            *ppBuffer = (PVOID)( pDataBlob + 1 );
            *pdwBufferLength = pDataBlob->BlobDataLength;
            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Short-circuit for cleartext blobs.
    //

    if( pDataBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE ) {
        *ppBuffer = (PVOID)( pDataBlob + 1 );
        *pdwBufferLength = pDataBlob->BlobDataLength;
        return NO_ERROR;
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;
    blob = (PIC_BLOB)pDataBlob;

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Decrypt the data.
    //

    dataLength = blob->DataLength;

	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();
	
    if( !CryptDecrypt(
            hSessionKey,
            hash,
            TRUE,
            0,
            BLOB_TO_DATA(blob),
            &dataLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;
    }
    
    IcpReleaseGlobalLock();


    //
    // Verify the signature.
    //

    if( !CryptVerifySignature(
            hash,
            BLOB_TO_SIGNATURE(blob),
            blob->SignatureLength,
            hSignatureKey,
            NULL,
            0
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    //
    // Success!
    //

    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    data = (PIC_DATA)BLOB_TO_DATA(blob);
    *ppBuffer = data + 1;
    *pdwBufferLength = dataLength - sizeof(*data);
    *pdwRegType = data->RegType;

    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoDecryptDataBlob

HRESULT
WINAPI
IISCryptoDecryptDataBlob2(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine validates and decrypts a data blob, resulting in a
    buffer containing plaintext.

    N.B. This routine effectively destroys the blob; once the data
    is decrypted, it cannot be decrypted again, as the data is
    decrypted "in place".

    N.B. The pointer returned in *ppBuffer points within the blob.
    This pointer will become invalid when the blob is freed. Note also
    that the calling application is still responsible for calling
    IISCryptoFreeBlob() on the data blob.

Arguments:

    ppBuffer - Receives a pointer to the data buffer if successful.

    pdwBufferLength - Receives the length of the data buffer.

    pdwRegType - Receives the REG_* type of the data.

    pDataBlob - The data blob to decrypt.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key used to decrypt the data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;
    PIC_BLOB blob;
    PIC_DATA data;
    DWORD dataLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppBuffer != NULL );
    DBG_ASSERT( pdwBufferLength != NULL );
    DBG_ASSERT( pdwRegType != NULL );
    DBG_ASSERT( pDataBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pDataBlob ) );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY &&
            pDataBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE
            ) {

            *ppBuffer = (PVOID)( pDataBlob + 1 );
            *pdwBufferLength = pDataBlob->BlobDataLength;
            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Short-circuit for cleartext blobs.
    //

    if( pDataBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE ) {
        *ppBuffer = (PVOID)( pDataBlob + 1 );
        *pdwBufferLength = pDataBlob->BlobDataLength;
        return NO_ERROR;
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;
    blob = (PIC_BLOB)pDataBlob;

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Decrypt the data.
    //

    dataLength = blob->DataLength;


	//
	// session key should not be used concurrently by multiple threads
	//

    IcpAcquireGlobalLock();
	
    if( !CryptDecrypt(
            hSessionKey,
            hash,
            TRUE,
            0,
            BLOB_TO_DATA(blob),
            &dataLength
            ) ) {

        result = IcpGetLastError();
        IcpReleaseGlobalLock();
        goto fatal;
    }
    IcpReleaseGlobalLock();

    //
    // Success!
    //

    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    data = (PIC_DATA)BLOB_TO_DATA(blob);
    *ppBuffer = data + 1;
    *pdwBufferLength = dataLength - sizeof(*data);
    *pdwRegType = data->RegType;

    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoDecryptDataBlob2


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\blob.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    blob.c

Abstract:

    Generic blob manipulators for the IIS cryptographic package.

    The following routines are exported by this module:

        IISCryptoReadBlobFromRegistry
        IISCryptoWriteBlobToRegistry
        IISCryptoIsValidBlob
        IISCryptoFreeBlob
        IISCryptoCompareBlobs
        IISCryptoCloneBlobFromRawData
        IISCryptoCreateCleartextBlob
        IcpCreateBlob

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


HRESULT
WINAPI
IISCryptoReadBlobFromRegistry(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN HKEY hRegistryKey,
    IN LPCTSTR pszRegistryValueName
    )

/*++

Routine Description:

    This routine creates a new blob, reading the blob out of the
    registry.

Arguments:

    ppBlob - Receives a pointer to the newly created blob if successful.

    hRegistryKey - An open handle to a registry key.

    pszRegistryValueName - The name of the REG_BINARY registry value
        containing the blob.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    PIIS_CRYPTO_BLOB blob;
    long status;
    unsigned long type;
    long length;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppBlob != NULL );
    DBG_ASSERT( hRegistryKey != NULL );
    DBG_ASSERT( pszRegistryValueName != NULL );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;

    //
    // Determine the size of the blob.
    //

    length = 0;

    status = RegQueryValueEx(
                 hRegistryKey,
                 pszRegistryValueName,
                 NULL,
                 &type,
                 NULL,
                 &length
                 );

    if( status != NO_ERROR ) {
        result = RETURNCODETOHRESULT(status);
        goto fatal;
    }

    //
    // Allocate a new blob.
    //

    blob = IcpAllocMemory( length );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Read the blob.
    //

    status = RegQueryValueEx(
                 hRegistryKey,
                 pszRegistryValueName,
                 NULL,
                 &type,
                 (LPBYTE)blob,
                 &length
                 );

    if( status != NO_ERROR ) {
        result = RETURNCODETOHRESULT(status);
        goto fatal;
    }

    //
    // Validate the blob.
    //

    if( !IISCryptoIsValidBlob( blob ) ) {
        result = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto fatal;
    }

    //
    // Success!
    //

    *ppBlob = blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoReadBlobFromRegistry


HRESULT
WINAPI
IISCryptoWriteBlobToRegistry(
    IN PIIS_CRYPTO_BLOB pBlob,
    IN HKEY hRegistryKey,
    IN LPCTSTR pszRegistryValueName
    )

/*++

Routine Description:

    This routine writes the given blob to the given registry location.

Arguments:

    pBlob - A pointer to the blob to write.

    hRegistryKey - An open handle to a registry key.

    pszRegistryValueName - The name of the REG_BINARY registry value
        that will receive the blob.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    long status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pBlob ) );
    DBG_ASSERT( hRegistryKey != NULL );
    DBG_ASSERT( pszRegistryValueName != NULL );

    //
    // Write the blob.
    //

    status = RegSetValueEx(
                 hRegistryKey,
                 pszRegistryValueName,
                 0,
                 REG_BINARY,
                 (LPBYTE)pBlob,
                 IISCryptoGetBlobLength( pBlob )
                 );

    return RETURNCODETOHRESULT(status);

}   // IISCryptoWriteBlobToRegistry


BOOL
WINAPI
IISCryptoIsValidBlob(
    IN PIIS_CRYPTO_BLOB pBlob
    )

/*++

Routine Description:

    This routine determines if the specified blob is indeed a valid
    blob.

Arguments:

    pBlob - The blob to validate.

Return Value:

    BOOL - TRUE if the blob is valid, FALSE otherwise.

--*/

{

    PIC_BLOB blob;
    BOOL result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob != NULL );

    //
    // Validate the signature.
    //

    blob = (PIC_BLOB)pBlob;

    switch( blob->Header.BlobSignature ) {

    case KEY_BLOB_SIGNATURE :
    case PUBLIC_KEY_BLOB_SIGNATURE :
    case DATA_BLOB_SIGNATURE :
    case HASH_BLOB_SIGNATURE :
    case CLEARTEXT_BLOB_SIGNATURE :
        result = TRUE;
        break;

    default :
        result = FALSE;
        break;

    }

    if( result &&
        blob->Header.BlobSignature != CLEARTEXT_BLOB_SIGNATURE ) {

        //
        // Validate some of the blob internal structure. Note that we
        // don't validate the internal structure of the cleartext blobs,
        // as they do not conform to the normal IC_BLOB structure.
        //

        if( blob->DataLength == 0 ||
            blob->Header.BlobDataLength !=
                CALC_BLOB_DATA_LENGTH( blob->DataLength, blob->SignatureLength ) ) {

            result = FALSE;

        }

    }

    return result;

}   // IISCryptoIsValidBlob

BOOL
WINAPI
IISCryptoIsValidBlob2(
    IN PIIS_CRYPTO_BLOB pBlob
    )

/*++

Routine Description:

    This routine determines if the specified blob is indeed a valid
    blob.

Arguments:

    pBlob - The blob to validate.

Return Value:

    BOOL - TRUE if the blob is valid, FALSE otherwise.

--*/

{

    PIC_BLOB2 blob;
    BOOL      result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob != NULL );

    //
    // Validate the signature.
    //

    blob = (PIC_BLOB2)pBlob;

    switch( blob->Header.BlobSignature ) {

    case SALT_BLOB_SIGNATURE :
        result = TRUE;
        break;

    default :
        result = FALSE;
        break;

    }

    if( result ) {

        //
        // Validate some of the blob internal structure. Note that we
        // don't validate the internal structure of the cleartext blobs,
        // as they do not conform to the normal IC_BLOB structure.
        //

        if( blob->DataLength == 0 ||
            blob->Header.BlobDataLength !=
                CALC_BLOB_DATA_LENGTH2( blob->DataLength, blob->SaltLength ) ) {

            result = FALSE;

        }

    }

    return result;

}   // IISCryptoIsValidBlob2


HRESULT
WINAPI
IISCryptoFreeBlob(
    IN PIIS_CRYPTO_BLOB pBlob
    )

/*++

Routine Description:

    This routine frees all resources associated with the given blob.
    After this routine completes, the blob is unusable.

Arguments:

    pBlob - The blob to free.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pBlob ) );

    //
    // Corrupt the structure signature before freeing the blob.
    //

    *(PCHAR)(&pBlob->BlobSignature) = 'X';

    //
    // Free the resources.
    //

    IcpFreeMemory( pBlob );

    //
    // Success!
    //

    UpdateBlobsFreed();
    return NO_ERROR;

}   // IISCryptoFreeBlob

HRESULT
WINAPI
IISCryptoFreeBlob2(
    IN PIIS_CRYPTO_BLOB pBlob
    )

/*++

Routine Description:

    This routine frees all resources associated with the given blob.
    After this routine completes, the blob is unusable.

Arguments:

    pBlob - The blob to free.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob2( pBlob ) );

    //
    // Corrupt the structure signature before freeing the blob.
    //

    *(PCHAR)(&pBlob->BlobSignature) = 'X';

    //
    // Free the resources.
    //

    IcpFreeMemory( pBlob );

    //
    // Success!
    //

    UpdateBlobsFreed();
    return NO_ERROR;

}   // IISCryptoFreeBlob2


BOOL
WINAPI
IISCryptoCompareBlobs(
    IN PIIS_CRYPTO_BLOB pBlob1,
    IN PIIS_CRYPTO_BLOB pBlob2
    )

/*++

Routine Description:

    This routine compares two blobs to determine if they are identical.

Arguments:

    pBlob1 - Pointer to a blob.

    pBlob2 - Pointer to another blob.

Return Value:

    BOOL - TRUE if the blobs match, FALSE otherwise, or if the blobs
        are invalid.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( pBlob1 != NULL );
    DBG_ASSERT( pBlob2 != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pBlob1 ) );
    DBG_ASSERT( IISCryptoIsValidBlob( pBlob2 ) );

    //
    // Just do a straight memory compare of the two blobs.
    //

    if( memcmp( pBlob1, pBlob2, sizeof(*pBlob1) ) == 0 ) {
        return TRUE;
    }

    //
    // No match.
    //

    return FALSE;

}   // IISCryptoCompareBlobs


HRESULT
WINAPI
IISCryptoCloneBlobFromRawData(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pRawBlob,
    IN DWORD dwRawBlobLength
    )

/*++

Routine Description:

    This routine makes a copy of a blob from raw data. The raw data
    buffer may be unaligned.

Arguments:

    ppBlob - Receives a pointer to the newly created blob if successful.

    pRawBlob - Pointer to the raw blob data.

    dwRawBlobLength - Length of the raw blob data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    PIIS_CRYPTO_BLOB newBlob;
    IIS_CRYPTO_BLOB UNALIGNED *unalignedBlob;
    DWORD blobLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( ppBlob != NULL );
    DBG_ASSERT( pRawBlob != NULL );

    //
    // Allocate space for the new blob.
    //

    unalignedBlob = (IIS_CRYPTO_BLOB UNALIGNED *)pRawBlob;
    blobLength = IISCryptoGetBlobLength( unalignedBlob );

    if( blobLength != dwRawBlobLength ) {
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }

    newBlob = IcpAllocMemory( blobLength );
    if( newBlob != NULL ) {

        //
        // Clone it. The (PCHAR) casts are necessary to force the compiler
        // to copy BYTE-wise.
        //

        RtlCopyMemory(
            (PCHAR)newBlob,
            (PCHAR)unalignedBlob,
            blobLength
            );

        //
        // Validate its contents.
        //

        if( IISCryptoIsValidBlob( newBlob ) ) {

            *ppBlob = newBlob;

            UpdateBlobsCreated();
            return NO_ERROR;

        }

        IcpFreeMemory( newBlob );
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

    }

    return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

}   // IISCryptoCloneBlobFromRawData

HRESULT
WINAPI
IISCryptoCloneBlobFromRawData2(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pRawBlob,
    IN DWORD dwRawBlobLength
    )

/*++

Routine Description:

    This routine makes a copy of a blob from raw data. The raw data
    buffer may be unaligned.

Arguments:

    ppBlob - Receives a pointer to the newly created blob if successful.

    pRawBlob - Pointer to the raw blob data.

    dwRawBlobLength - Length of the raw blob data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    PIIS_CRYPTO_BLOB newBlob;
    IIS_CRYPTO_BLOB UNALIGNED *unalignedBlob;
    DWORD blobLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( ppBlob != NULL );
    DBG_ASSERT( pRawBlob != NULL );

    //
    // Allocate space for the new blob.
    //

    unalignedBlob = (IIS_CRYPTO_BLOB UNALIGNED *)pRawBlob;
    blobLength = IISCryptoGetBlobLength( unalignedBlob );

    if( blobLength != dwRawBlobLength ) {
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }

    newBlob = IcpAllocMemory( blobLength );
    if( newBlob != NULL ) {

        //
        // Clone it. The (PCHAR) casts are necessary to force the compiler
        // to copy BYTE-wise.
        //

        RtlCopyMemory(
            (PCHAR)newBlob,
            (PCHAR)unalignedBlob,
            blobLength
            );

        //
        // Validate its contents.
        //

        if( IISCryptoIsValidBlob2( newBlob ) ) {

            *ppBlob = newBlob;

            UpdateBlobsCreated();
            return NO_ERROR;

        }

        IcpFreeMemory( newBlob );
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

    }

    return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

}   // IISCryptoCloneBlobFromRawData2


HRESULT
WINAPI
IISCryptoCreateCleartextBlob(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pBlobData,
    IN DWORD dwBlobDataLength
    )

/*++

Routine Description:

    This routine creates a cleartext blob containing the specified
    data.

Arguments:

    ppBlob - Receives a pointer to the newly created blob if successful.

    pBlobData - Pointer to the blob data.

    dwBlobDataLength - Length of the blob data.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    PIIS_CRYPTO_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( ppBlob != NULL );
    DBG_ASSERT( pBlobData != NULL );

    //
    // Allocate space for the new blob.
    //

    blob = IcpAllocMemory( dwBlobDataLength + sizeof(*blob) );

    if( blob != NULL ) {

        //
        // Initialize the blob.
        //

        blob->BlobSignature = CLEARTEXT_BLOB_SIGNATURE;
        blob->BlobDataLength = dwBlobDataLength;

        RtlCopyMemory(
            blob + 1,
            pBlobData,
            dwBlobDataLength
            );

        *ppBlob = blob;

        UpdateBlobsCreated();
        return NO_ERROR;

    }

    return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

}   // IISCryptoCreateCleartextBlob


PIC_BLOB
IcpCreateBlob(
    IN DWORD dwBlobSignature,
    IN DWORD dwDataLength,
    IN DWORD dwSignatureLength OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new blob.

Arguments:

    dwBlobSignature - The structure signature for the new blob.

    dwDataLength - The data length for the blob.

    dwSignatureLength - The length of the digital signature, 0 if
        there is no signature for this blob. This value cannot be
        CLEARTEXT_BLOB_SIGNATURE; cleartext blobs are "special".

Return Value:

    PIC_BLOB - Pointer to the newly created blob if successful,
        NULL otherwise.

--*/

{

    PIC_BLOB blob;
    DWORD blobDataLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( dwBlobSignature == KEY_BLOB_SIGNATURE ||
                dwBlobSignature == PUBLIC_KEY_BLOB_SIGNATURE ||
                dwBlobSignature == DATA_BLOB_SIGNATURE ||
                dwBlobSignature == HASH_BLOB_SIGNATURE );

    //
    // Allocate storage for the blob.
    //

    blobDataLength = CALC_BLOB_DATA_LENGTH( dwDataLength, dwSignatureLength );
    blob = IcpAllocMemory( blobDataLength + sizeof(IIS_CRYPTO_BLOB) );

    if( blob != NULL ) {

        //
        // Initialize the blob.
        //

        blob->Header.BlobSignature = dwBlobSignature;
        blob->Header.BlobDataLength = blobDataLength;

        blob->DataLength = dwDataLength;
        blob->SignatureLength = dwSignatureLength;

    }

    return blob;

}   // IcpCreateBlob

PIC_BLOB2
IcpCreateBlob2(
    IN DWORD dwBlobSignature,
    IN DWORD dwDataLength,
    IN DWORD dwSaltLength OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new blob.

Arguments:

    dwBlobSignature - The structure signature for the new blob.

    dwDataLength - The data length for the blob.

    dwSaltLength - The length of the random salt

Return Value:

    PIC_BLOB2 - Pointer to the newly created blob if successful,
        NULL otherwise.

--*/

{

    PIC_BLOB2 blob;
    DWORD blobDataLength;

    //
    // Sanity check.
    //

    DBG_ASSERT( dwBlobSignature == SALT_BLOB_SIGNATURE );

    //
    // Allocate storage for the blob.
    //

    blobDataLength = CALC_BLOB_DATA_LENGTH( dwDataLength, dwSaltLength );
    blob = IcpAllocMemory( blobDataLength + sizeof(IIS_CRYPTO_BLOB) );

    if( blob != NULL ) {

        //
        // Initialize the blob.
        //

        blob->Header.BlobSignature = dwBlobSignature;
        blob->Header.BlobDataLength = blobDataLength;

        blob->DataLength = dwDataLength;
        blob->SaltLength = dwSaltLength;

    }

    return blob;

}   // IcpCreateBlob2


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\hash.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Hash manipulators for the IIS cryptographic package.

    The following routines are exported by this module:

        IISCryptoCreateHash
        IISCryptoDestroyHash
        IISCryptoHashData
        IISCryptoHashSessionKey
        IISCryptoExportHashBlob
        IcpGetHashLength

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


HRESULT
WINAPI
IISCryptoCreateHash(
    OUT HCRYPTHASH * phHash,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine creates a new hash object.

Arguments:

    phHash - Receives the hash handle if successful.

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phHash != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV ) {
            *phHash = DUMMY_HHASH;
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Create the hash object.
    //

    if( CryptCreateHash(
            hProv,
            IC_HASH_ALG,
            CRYPT_NULL,
            0,
            phHash
            ) ) {

        UpdateHashCreated();
        return NO_ERROR;

    }

    return IcpGetLastError();

}   // IISCryptoCreateHash


HRESULT
WINAPI
IISCryptoDestroyHash(
    IN HCRYPTHASH hHash
    )

/*++

Routine Description:

    This routine destroys the specified hash object.

Arguments:

    hHash - The hash object to destroy.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( hHash != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hHash == DUMMY_HHASH ) {
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Destroy it.
    //

    if( CryptDestroyHash(
            hHash
            ) ) {

        UpdateHashDestroyed();
        return NO_ERROR;

    }

    return IcpGetLastError();

}   // IISCryptoDestroyHash


HRESULT
WINAPI
IISCryptoHashData(
    IN HCRYPTHASH hHash,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    This routine adds the specified data to the hash.

Arguments:

    hHash - A hash object handle.

    pBuffer - Pointer to the buffer to add to the hash.

    dwBufferLength - The buffer length.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( hHash != CRYPT_NULL );
    DBG_ASSERT( pBuffer != NULL );
    DBG_ASSERT( dwBufferLength > 0 );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hHash == DUMMY_HHASH ) {
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Hash it.
    //

    if( CryptHashData(
            hHash,
            (BYTE *)pBuffer,
            dwBufferLength,
            0
            ) ) {

        return NO_ERROR;

    }

    return IcpGetLastError();

}   // IISCryptoHashData


HRESULT
WINAPI
IISCryptoHashSessionKey(
    IN HCRYPTHASH hHash,
    IN HCRYPTKEY hSessionKey
    )

/*++

Routine Description:

    This routine adds the given key object to the hash.

Arguments:

    hHash - A hash object handle.

    hSessionKey - The session key to add to the hash.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( hHash != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hHash == DUMMY_HHASH &&
            hSessionKey == DUMMY_HSESSIONKEY ) {
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Hash it.
    //

    if( CryptHashSessionKey(
            hHash,
            hSessionKey,
            0
            ) ) {

        return NO_ERROR;

    }

    return IcpGetLastError();

}   // IISCryptoHashSessionKey


HRESULT
WINAPI
IISCryptoExportHashBlob(
    OUT PIIS_CRYPTO_BLOB * ppHashBlob,
    IN HCRYPTHASH hHash
    )

/*++

Routine Description:

    This routine exports a hash object into a hash blob. Note that unlike
    the other blobs created by this package, hash blobs are not encrypted,
    nor do they have corresponding digital signatures.

Arguments:

    ppHashBlob - Will receive a pointer to the newly created hash blob
        if successful.

    hHash - The hash object to export.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    DWORD hashLength;
    DWORD hashLengthLength;
    PIC_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppHashBlob != NULL );
    DBG_ASSERT( hHash != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hHash == DUMMY_HHASH ) {
            return IISCryptoCreateCleartextBlob(
                       ppHashBlob,
                       (PVOID)"",
                       1
                       );
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;

    //
    // Determine the length of the hash.
    //

    hashLengthLength = sizeof(hashLength);

    if( !CryptGetHashParam(
            hHash,
            HP_HASHSIZE,
            (BYTE *)&hashLength,
            &hashLengthLength,
            0
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob(
               HASH_BLOB_SIGNATURE,
               hashLength,
               0
               );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Get the hash data.
    //

    if( !CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            BLOB_TO_DATA(blob),
            &hashLength,
            0
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    DBG_ASSERT( hashLength == blob->DataLength );

    //
    // Success!
    //

    DBG_ASSERT( IISCryptoIsValidBlob( (PIIS_CRYPTO_BLOB)blob ) );
    *ppHashBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoExportHashBlob


HRESULT
IcpGetHashLength(
    OUT LPDWORD pdwHashLength,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine determines the digital signature length used by the
    given provider. Since we always use the default provider, and
    we always use the same hash algorithm, we can retrieve this once,
    store it globally, then use that value.

Arguments:

    pdwHashLength - Receives the hash length if successful.

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;
    HCRYPTHASH hash;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( IcpGlobals.EnableCryptography );
    DBG_ASSERT( pdwHashLength != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // If the hash length has already been calculated, just use it.
    //

    if( IcpGlobals.HashLength > 0 ) {
        *pdwHashLength = IcpGlobals.HashLength;
        return NO_ERROR;
    }

    //
    // Grab the global lock, then check again, just in case another
    // thread has already done it.
    //

    IcpAcquireGlobalLock();

    if( IcpGlobals.HashLength > 0 ) {
        *pdwHashLength = IcpGlobals.HashLength;
        IcpReleaseGlobalLock();
        return NO_ERROR;
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Hash some random data.
    //

    if( !CryptHashData(
            hash,
            (BYTE *)"IIS",
            4,
            0
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    //
    // Attempt to sign the hash to get its length.
    //

    if( !CryptSignHash(
            hash,
            AT_SIGNATURE,
            NULL,
            0,
            NULL,
            &IcpGlobals.HashLength
            ) ) {

        result = IcpGetLastError();
        goto fatal;

    }

    //
    // Success!
    //

    *pdwHashLength = IcpGlobals.HashLength;
    IcpReleaseGlobalLock();

    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    IcpReleaseGlobalLock();

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IcpGetHashLength

//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\generic.c ===
HRESULT
WINAPI
IISCrypto xxx(
    IN xxx
    )

/*++

Routine Description:

    This routine xxx

Arguments:

    xxx

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );

    //
    // Success!
    //

    return NO_ERROR;

}   // IISCrypto xxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\globals.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    globals.c

Abstract:

    Global definitions and initialization routines for the IIS
    cryptographic package.

    The following routines are exported by this module:

        IISCryptoInitialize
        IISCryptoTerminate
        IcpGetLastError

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Public globals.
//

IC_GLOBALS IcpGlobals;

#if IC_ENABLE_COUNTERS
IC_COUNTERS IcpCounters;
#endif  // IC_ENABLE_COUNTERS


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


// these flags are used for programatic override of encryption presnece/absence
// and are used for the case when on French machine  without encryption locale becomes
// changed and encryption becomes available

// in NT5 RC3 French encryption was enabled, so French now has encryption!
BOOL  fCryptoSettingsDoOverrride = FALSE;
BOOL  fCryptoSettingsOverrideFlag = FALSE;



//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
WINAPI
IISCryptoInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the IIS crypto package.

    N.B. This routine may only be called via a single thread of
    execution; it is not necessarily multi-thread safe.

Arguments:

    None.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    BOOL isNt = FALSE;
    OSVERSIONINFO osInfo;

    if( !IcpGlobals.Initialized ) {

        //
        // Initialize our critical section.
        //

        INITIALIZE_CRITICAL_SECTION(
            &IcpGlobals.GlobalLock
            );

#if IC_ENABLE_COUNTERS
        //
        // Initialize our object counters.
        //

        RtlZeroMemory(
            &IcpCounters,
            sizeof(IcpCounters)
            );
#endif  // IC_ENABLE_COUNTERS

        //
        // The hash length will get initialized the first time
        // it's needed.
        //

        IcpGlobals.HashLength = 0;

        //
        // Determine if cryptography should be enabled.
        //

        osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if ( GetVersionEx( &osInfo ) ) {
            isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
        } 

        if( isNt &&
            (IcpIsEncryptionPermitted())) {
            IcpGlobals.EnableCryptography = TRUE;
        } else {
            IcpGlobals.EnableCryptography = FALSE;
        }

#ifdef _WIN64
//      64 bit hack... 64 bit crypto should be working now, so no need to do this anymore.
//	IcpGlobals.EnableCryptography = FALSE;
#endif


#if DBG
        {

            //
            // On checked builds, you can override the default
            // EnableCryptography flag via a registry parameter.
            //

            HKEY key;
            LONG err;
            LONG flag;
            DWORD type;
            DWORD length;

            err = RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Microsoft\\K2"),
                      0,
                      KEY_ALL_ACCESS,
                      &key
                      );

            if( err == NO_ERROR ) {

                length = sizeof(flag);

                err = RegQueryValueEx(
                          key,
                          TEXT("EnableCryptography"),
                          NULL,
                          &type,
                          (LPBYTE)&flag,
                          &length
                          );

                if( err == NO_ERROR && type == REG_DWORD ) {
                    IcpGlobals.EnableCryptography = ( flag != 0 );
                }

                RegCloseKey( key );

            }

        }
#endif  // DBG

        //
        // Remember that we're successfully initialized.
        //

        IcpGlobals.Initialized = TRUE;

    }


    // that's a special case for handling for override of encryption presense
    // will be called only on French machines with english locale
    if (fCryptoSettingsDoOverrride)
    {
        IcpGlobals.EnableCryptography = fCryptoSettingsOverrideFlag;
    }
    

    //
    // Success!
    //

    return NO_ERROR;

}   // IISCryptoInitialize


HRESULT
WINAPI
IISCryptoTerminate(
    VOID
    )

/*++

Routine Description:

    This routine terminates the IIS crypto package.

    N.B. This routine may only be called via a single thread of
    execution; it is not necessarily multi-thread safe.

Arguments:

    None.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    if( IcpGlobals.Initialized ) {

        //
        // Nuke our critical section.
        //

        DeleteCriticalSection( &IcpGlobals.GlobalLock );

        //
        // Remember that we're successfully terminated.
        //

        IcpGlobals.Initialized = FALSE;

    }

    //
    // Success!
    //

    return NO_ERROR;

}   // IISCryptoTerminate


VOID 
WINAPI
IISCryptoInitializeOverride(BOOL flag) 
/*++

Routine Description:

    This routine overides global flag about presence of encryption
    functions. It should be used only in one case, when French machine 
    without encryption, has locale changed to US and then gets encryption
    capability what breaks a lot of code where attemt to decrypt is made on
    non encrypted data

Arguments:

    BOOL flag indicating how to override encryption presence. Only False suppose
    to be used.


Return Value:

    None

--*/

{
	IcpGlobals.EnableCryptography = flag;
	fCryptoSettingsDoOverrride = TRUE;
	fCryptoSettingsOverrideFlag = flag;
	
}   //IISCryptoInitializeOverride



BOOL
IcpIsEncryptionPermitted(
    VOID
    )
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

    This code was received from Jeff Spelman, and is the same
    code the crypto API's use do determine if encryption is
    allowed.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/

{
    // in NT5 RC3 French encryption was enabled, so French now has encryption!
    // since French was the only special case for encryption, just return TRUE all the time.

/*
    LCID DefaultLcid;
    CHAR CountryCode[10];
    ULONG CountryValue;
    DefaultLcid = GetSystemDefaultLCID();
    //
    // Check if the default language is Standard French
    //
    if (LANGIDFROMLCID(DefaultLcid) == 0x40c) {
        return(FALSE);
    }

    //
    // Check if the users's country is set to FRANCE
    //
    if (GetLocaleInfoA(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0) {
        return(FALSE);
    }
    CountryValue = (ULONG) atol(CountryCode);
    if (CountryValue == CTRY_FRANCE) {
        return(FALSE);
    }
    //
    // and it still we think that encryption is permited thetre it comes a special hack for that
    // setup case where english or whatever install is installed with France locality from the begining and setup
    // thread still thinks that it is not in France. 
    // Setup in  iis.dll sets SetThreadLocale to the correct one
    //
    DefaultLcid = GetThreadLocale();
    //
    // Check if the default language is Standard French
    //
    if (LANGIDFROMLCID(DefaultLcid) == 0x40c) {
        return(FALSE);
    }
*/

    return(TRUE);
}


VOID
WINAPI
IcpAcquireGlobalLock(
    VOID
    )

/*++

Routine Description:

    This routine acquires the global IIS crypto lock.

    N.B. This routine is "semi-private"; it is only used by IISCRYPT.LIB
         and ICRYPT.LIB, not by "normal" code.

Arguments:

    None.

Return Value:

    None.

--*/

{

    EnterCriticalSection( &IcpGlobals.GlobalLock );

}   // IcpAcquireGlobalLock


VOID
WINAPI
IcpReleaseGlobalLock(
    VOID
    )

/*++

Routine Description:

    This routine releases the global IIS crypto lock.

    N.B. This routine is "semi-private"; it is only used by IISCRYPT.LIB
         and ICRYPT.LIB, not by "normal" code.

Arguments:

    None.

Return Value:

    None.

--*/

{

    LeaveCriticalSection( &IcpGlobals.GlobalLock );

}   // IcpReleaseGlobalLock


HRESULT
IcpGetLastError(
    VOID
    )

/*++

Routine Description:

    Returns the last error, mapped to an HRESULT.

Arguments:

    None.

Return Value:

    HRESULT - Last error.

--*/

{

    DWORD lastErr;

    lastErr = GetLastError();
    return RETURNCODETOHRESULT(lastErr);

}   // IcpGetLastError


//
// Private functions.
//

#if IC_ENABLE_COUNTERS

PVOID
WINAPI
IcpAllocMemory(
    IN DWORD Size
    )
{

    PVOID buffer;

    buffer = IISCryptoAllocMemory( Size );

    if( buffer != NULL ) {
        UpdateAllocs();
    }

    return buffer;

}   // IcpAllocMemory

VOID
WINAPI
IcpFreeMemory(
    IN PVOID Buffer
    )
{

    UpdateFrees();
    IISCryptoFreeMemory( Buffer );

}   // IcpFreeMemory

#endif  // IC_ENABLE_COUNTERS




BOOL
WINAPI
IISCryptoIsClearTextSignature (
    IIS_CRYPTO_BLOB UNALIGNED *pBlob
    )

/*++

Routine Description:

    Returns TRUE if blob is clear text

Arguments:

    Ptr to blob

Return Value:

    BOOL 

--*/

{
    return (pBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\icryptp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    icryptp.h

Abstract:

    This include file contains private constants, type definitions, and
    function prototypes for the IIS cryptographic routines.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#ifndef _ICRYPTP_H_
#define _ICRYPTP_H_


//
// Set this to a non-zero value to enable various object counters.
//

#if DBG
#define IC_ENABLE_COUNTERS 1
#else
#define IC_ENABLE_COUNTERS 0
#endif


//
// Constants defining our target crypto provider.
//

#define IC_CONTAINER TEXT("Microsoft Internet Information Server")
#define IC_PROVIDER  MS_DEF_PROV
#define IC_PROVTYPE  PROV_RSA_FULL

#define IC_HASH_ALG CALG_MD5


//
// Alignment macros.
//

#define ALIGN_DOWN(count,size) \
            ((ULONG)(count) & ~((ULONG)(size) - 1))

#define ALIGN_UP(count,size) \
            (ALIGN_DOWN( (ULONG)(count)+(ULONG)(size)-1, (ULONG)(size) ))

#define ALIGN_8(count) \
            (ALIGN_UP( (ULONG)(count), 8 ))


//
// A blob. Note that we use these blobs for storing exported keys,
// encrypted data, and hash results. Outside of this package, only
// the IIS_CRYPTO_BLOB header is exposed; the blob internals are kept
// private.
//

typedef struct _IC_BLOB {

    //
    // The standard header.
    //

    IIS_CRYPTO_BLOB Header;

    //
    // The data length. This will always be >0.
    //

    DWORD DataLength;

    //
    // The digital signature length. This may be 0 if no digital
    // signature is present.
    //

    DWORD SignatureLength;

    //
    // The actual data and digital signature go here, at the end
    // of the structure, but part of the same memory allocation
    // block. Use the following macros to access these fields.
    //
    // UCHAR Data[];
    // UCHAR Signature[];
    //

} IC_BLOB;

typedef UNALIGNED64 IC_BLOB *PIC_BLOB;

#define BLOB_TO_DATA(p) \
            ((BYTE *)(((PIC_BLOB)(p)) + 1))

#define BLOB_TO_SIGNATURE(p) \
            ((BYTE *)(((PCHAR)(((PIC_BLOB)(p)) + 1)) + \
                ALIGN_8(((PIC_BLOB)(p))->DataLength)))

//
// The following data structure is for specific metabase Backup/Restore
//
typedef struct _IC_BLOB2 {

    //
    // The standard header.
    //

    IIS_CRYPTO_BLOB Header;

    //
    // The data length. This will always be >0.
    //

    DWORD DataLength;

    //
    // The random salt length. At least 80 bits( 8 bytes ) long
    //

    DWORD SaltLength;

    //
    // The actual data and random salt go here, at the end
    // of the structure, but part of the same memory allocation
    // block. Use the following macros to access these fields.
    //
    // UCHAR Data[];
    // UCHAR Salt[];
    //

} IC_BLOB2, *PIC_BLOB2;

#define RANDOM_SALT_LENGTH       16

#define BLOB_TO_DATA2(p) \
            ((BYTE *)(((PIC_BLOB2)(p)) + 1))

#define BLOB_TO_SALT2(p) \
            ((BYTE *)(((PCHAR)(((PIC_BLOB2)(p)) + 1)) + \
                ALIGN_8(((PIC_BLOB2)(p))->DataLength)))

//
// Macro to calculate the data length of a blob, given the data and
// signature lengths. To ensure natural alignment of the signature, we
// quad-word align the data length if a signature is present.
//

#define CALC_BLOB_DATA_LENGTH(datalen,siglen) \
            ((sizeof(IC_BLOB) - sizeof(IIS_CRYPTO_BLOB)) + \
                ((siglen) + ( (siglen) ? ALIGN_8(datalen) : (datalen) )))

//
// Macro to calculate the data length of a blob, given the data and
// salt lengths. To ensure natural alignment of the signature, we
// quad-word align the data length if a signature is present.
//

#define CALC_BLOB_DATA_LENGTH2(datalen,saltlen) \
            ((sizeof(IC_BLOB2) - sizeof(IIS_CRYPTO_BLOB)) + \
                (saltlen) + (ALIGN_8(datalen)))


//
// Globals defined in globals.c.
//

typedef struct _IC_GLOBALS {

    //
    // Global synchronization lock (used sparingly).
    //

    CRITICAL_SECTION GlobalLock;

    //
    // Hash length for digital signatures. Since we always use the
    // same crypto provider & signature algorithm, we can retrieve
    // this once up front, and save some cycles later on.
    //

    DWORD HashLength;

    //
    // Set to TRUE if cryptography is enabled, FALSE if disabled.
    //

    BOOL EnableCryptography;

    //
    // Set to TRUE if we've been succesfully initialized.
    //

    BOOL Initialized;

} IC_GLOBALS, *PIC_GLOBALS;

extern IC_GLOBALS IcpGlobals;


//
// Private functions.
//

BOOL
IcpIsEncryptionPermitted(
    VOID
    );

HRESULT
IcpGetLastError(
    VOID
    );

HRESULT
IcpGetHashLength(
    OUT LPDWORD pdwHashLength,
    IN HCRYPTPROV hProv
    );

PIC_BLOB
IcpCreateBlob(
    IN DWORD dwBlobSignature,
    IN DWORD dwDataLength,
    IN DWORD dwSignatureLength OPTIONAL
    );

PIC_BLOB2
IcpCreateBlob2(
    IN DWORD dwBlobSignature,
    IN DWORD dwDataLength,
    IN DWORD dwSaltLength OPTIONAL
    );


#if IC_ENABLE_COUNTERS

//
// Object counters.
//

typedef struct _IC_COUNTERS {

    LONG ContainersOpened;
    LONG ContainersClosed;
    LONG KeysOpened;
    LONG KeysClosed;
    LONG HashCreated;
    LONG HashDestroyed;
    LONG BlobsCreated;
    LONG BlobsFreed;
    LONG Allocs;
    LONG Frees;

} IC_COUNTERS, *PIC_COUNTERS;

extern IC_COUNTERS IcpCounters;

#define UpdateContainersOpened() InterlockedIncrement( &IcpCounters.ContainersOpened )
#define UpdateContainersClosed() InterlockedIncrement( &IcpCounters.ContainersClosed )
#define UpdateKeysOpened() InterlockedIncrement( &IcpCounters.KeysOpened )
#define UpdateKeysClosed() InterlockedIncrement( &IcpCounters.KeysClosed )
#define UpdateHashCreated() InterlockedIncrement( &IcpCounters.HashCreated )
#define UpdateHashDestroyed() InterlockedIncrement( &IcpCounters.HashDestroyed )
#define UpdateBlobsCreated() InterlockedIncrement( &IcpCounters.BlobsCreated )
#define UpdateBlobsFreed() InterlockedIncrement( &IcpCounters.BlobsFreed )
#define UpdateAllocs() InterlockedIncrement( &IcpCounters.Allocs )
#define UpdateFrees() InterlockedIncrement( &IcpCounters.Frees )

PVOID
WINAPI
IcpAllocMemory(
    IN DWORD Size
    );

VOID
WINAPI
IcpFreeMemory(
    IN PVOID Buffer
    );

#else   // !IC_ENABLE_COUNTERS

#define UpdateContainersOpened()
#define UpdateContainersClosed()
#define UpdateKeysOpened()
#define UpdateKeysClosed()
#define UpdateHashCreated()
#define UpdateHashDestroyed()
#define UpdateBlobsCreated()
#define UpdateBlobsFreed()
#define UpdateAllocs()
#define UpdateFrees()

#define IcpAllocMemory(cb) IISCryptoAllocMemory(cb)
#define IcpFreeMemory(p) IISCryptoFreeMemory(p)

#endif  // IC_ENABLE_COUNTERS


//
// Dummy crypto handles returned in cryptography is disabled.
//

#define DUMMY_HPROV             ((HCRYPTPROV)'vOrP')
#define DUMMY_HHASH             ((HCRYPTHASH)'hSaH')
#define DUMMY_HSESSIONKEY       ((HCRYPTKEY)'kSeS')
#define DUMMY_HSIGNATUREKEY     ((HCRYPTKEY)'kGiS')
#define DUMMY_HKEYEXCHANGEKEY   ((HCRYPTKEY)'kYeK')


#endif  // _ICRYPTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\key.c ===
/*++


Copyright (c) 1997 Microsoft Corporation

Module Name:

    key.c

Abstract:

    Key manpulators for the IIS cryptographic package.

    The following routines are exported by this module:

        IISCryptoGetKeyDeriveKey
        IISCryptoGetKeyExchangeKey
        IISCryptoGetSignatureKey
        IISCryptoGenerateSessionKey
        IISCryptoCloseKey
        IISCryptoExportSessionKeyBlob
        IISCryptoExportSessionKeyBlob2
        IISCryptoImportSessionKeyBlob
        IISCryptoImportSessionKeyBlob2
        IISCryptoExportPublicKeyBlob
        IISCryptoImportPublicKeyBlob

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//

HRESULT
IcpGetKeyHelper(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec
    );

//
// Public functions.
//
HRESULT
WINAPI
IISCryptoGetKeyDeriveKey2(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash
    )
/*++

Routine Description:

    This routine attempts to derive a key from a password in the given
    provider. 

Arguments:

    phKey - Receives the key handle if successful.

    hProv - A handle to a crypto service provider.

    hHash - A hash object from which the key will be derived 

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{
    HRESULT      hr;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phKey != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hHash != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV ) 
        {
            return NO_ERROR;
        } 
        else 
        {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Create a key based on the hash of the password.
    //
    IcpAcquireGlobalLock();

    if( !CryptDeriveKey(
                hProv, 
                CALG_RC4, 
                hHash, 
                CRYPT_EXPORTABLE, 
                phKey ) )
    {
        hr = IcpGetLastError();
        IcpReleaseGlobalLock();
        DBG_ASSERT( FAILED( hr ) );
        return hr;
    } 

    IcpReleaseGlobalLock();
    
    return NO_ERROR;
}

HRESULT
WINAPI
IISCryptoGetKeyExchangeKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine attempts to open the key exchange key in the given
    provider. If the key does not yet exist, this routine will attempt
    to create it.

Arguments:

    phKey - Receives the key handle if successful.

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phKey != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Let IcpGetKeyHelper() do the dirty work.
    //

    result = IcpGetKeyHelper(
                 phKey,
                 hProv,
                 AT_KEYEXCHANGE
                 );

    return result;

}   // IISCryptoGetKeyExchangeKey


HRESULT
WINAPI
IISCryptoGetSignatureKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine attempts to open the signature key in the given provider.
    If the key does not yet exist, this routine will attempt to create it.

Arguments:

    phKey - Receives the key handle if successful.

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phKey != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Let IcpGetKeyHelper() do the dirty work.
    //

    result = IcpGetKeyHelper(
                 phKey,
                 hProv,
                 AT_SIGNATURE
                 );

    return result;

}   // IISCryptoGetSignatureKey


HRESULT
WINAPI
IISCryptoGenerateSessionKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine generates a random session key.

Arguments:

    phKey - Receives the key handle if successful.

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{
    HRESULT result = NO_ERROR;
    BOOL status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phKey != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV ) {
            *phKey = DUMMY_HSESSIONKEY;
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Generate the key.
    //

    status = CryptGenKey(
                 hProv,
                 CALG_RC4,
                 CRYPT_EXPORTABLE,
                 phKey
                 );

    if( !status ) {
        result = IcpGetLastError();
    }

    if( SUCCEEDED(result) ) 
    {
        UpdateKeysOpened();
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoGenerateSessionKey.CryptGenKey (advapi32.dll) failed err=0x%x.\n",result));
        *phKey = CRYPT_NULL;
       
    }

    return result;

}   // IISCryptoGenerateSessionKey


HRESULT
WINAPI
IISCryptoCloseKey(
    IN HCRYPTKEY hKey
    )

/*++

Routine Description:

    This routine closes the specified key.

Arguments:

    hKey - A key handle.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    BOOL status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( hKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hKey == DUMMY_HSESSIONKEY ||
            hKey == DUMMY_HSIGNATUREKEY ||
            hKey == DUMMY_HKEYEXCHANGEKEY ) {
            return NO_ERROR;
        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Close the key.
    //

    status = CryptDestroyKey(
                 hKey
                 );

    if( status ) {
        UpdateKeysClosed();
        return NO_ERROR;
    }

    return IcpGetLastError();

}   // IISCryptoCloseKey


HRESULT
WINAPI
IISCryptoExportSessionKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hKeyExchangeKey
    )

/*++

Routine Description:

    This routine exports a session key into a secure session key blob.
    The blob contains the session key (encrypted with the specified
    private key exchange key) and a digital signature (also encrypted).

Arguments:

    ppSessionKeyBlob - Will receive a pointer to the newly created
        session key blob if successful.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key to export.

    hKeyExchangeKey - The key to use when encrypting the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    HCRYPTHASH hash;
    DWORD keyLength;
    DWORD hashLength;
    PIC_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppSessionKeyBlob != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );
    DBG_ASSERT( hKeyExchangeKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY &&
            hKeyExchangeKey == DUMMY_HKEYEXCHANGEKEY ) {

            return IISCryptoCreateCleartextBlob(
                       ppSessionKeyBlob,
                       (PVOID)"",
                       1
                       );

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;
    hash = CRYPT_NULL;

    //
    // Determine the required size of the key data.
    //

    status = CryptExportKey(
                 hSessionKey,
                 hKeyExchangeKey,
                 SIMPLEBLOB,
                 0,
                 NULL,
                 &keyLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.CryptExportKey (advapi32.dll) failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Determine the hash data length.
    //

    result = IcpGetHashLength(
                 &hashLength,
                 hProv
                 );

    if( FAILED(result) ) {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.IcpGetHashLength failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob(
               KEY_BLOB_SIGNATURE,
               keyLength,
               hashLength
               );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Export the key.
    //

    status = CryptExportKey(
                 hSessionKey,
                 hKeyExchangeKey,
                 SIMPLEBLOB,
                 0,
                 BLOB_TO_DATA(blob),
                 &keyLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.CryptExportKey failed err=0x%x.\n",result));
        goto fatal;
    }

    DBG_ASSERT( keyLength == blob->DataLength );

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.IISCryptoCreateHash failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Hash the key and generate the signature.
    //

    status = CryptHashData(
                 hash,
                 BLOB_TO_DATA(blob),
                 keyLength,
                 0
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    status = CryptSignHash(
                 hash,
                 AT_SIGNATURE,
                 NULL,
                 0,
                 BLOB_TO_SIGNATURE(blob),
                 &hashLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.CryptSignHash failed err=0x%x.\n",result));
        goto fatal;
    }

    DBG_ASSERT( hashLength == blob->SignatureLength );

    //
    // Success!
    //

    DBG_ASSERT( IISCryptoIsValidBlob( (PIIS_CRYPTO_BLOB)blob ) );
    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    *ppSessionKeyBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoExportSessionKeyBlob


HRESULT
WINAPI
IISCryptoImportSessionKeyBlob(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSignatureKey
    )

/*++

Routine Description:

    This routine takes the specified session key blob and creates the
    corresponding session key, iff the encrypted session key can be
    decrypted and the digital signature can be validated.

Arguments:

    phSessionKey - Receives a pointer to the newly created session key
        if successful.

    pSessionKeyBlob - Pointer to a key blob created with
        IISCryptoExportSessionKeyBlob().

    hProv - A handle to a crypto service provider.

    hSignatureKey - Handle to the encryption key to use when validating
        the digital signature.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    HCRYPTHASH hash;
    PIC_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phSessionKey != NULL );
    DBG_ASSERT( pSessionKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pSessionKeyBlob ) );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSignatureKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSignatureKey == DUMMY_HSIGNATUREKEY &&
            pSessionKeyBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE
            ) {

            *phSessionKey = DUMMY_HSESSIONKEY;
            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    DBG_ASSERT( pSessionKeyBlob->BlobSignature == KEY_BLOB_SIGNATURE );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;
    blob = (PIC_BLOB)pSessionKeyBlob;

    //
    // Validate the signature.
    //

    result = IISCryptoCreateHash(
                 &hash,
                 hProv
                 );

    if( FAILED(result) ) {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlob.IISCryptoCreateHash failed err=0x%x.\n",result));
        goto fatal;
    }

    status = CryptHashData(
                 hash,
                 BLOB_TO_DATA(blob),
                 blob->DataLength,
                 0
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlob.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    status = CryptVerifySignature(
                 hash,
                 BLOB_TO_SIGNATURE(blob),
                 blob->SignatureLength,
                 hSignatureKey,
                 NULL,
                 0
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlob.CryptVerifySignature failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // OK, the signature looks good. Import the key into our CSP.
    //

    status = CryptImportKey(
                 hProv,
                 BLOB_TO_DATA(blob),
                 blob->DataLength,
                 CRYPT_NULL,
                 0,
                 phSessionKey
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlob.CryptImportKey failed err=0x%x.\n",result));
    }

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    DBG_ASSERT( *phSessionKey != CRYPT_NULL );
    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );

    UpdateKeysOpened();
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoImportSessionKeyBlob

HRESULT
WINAPI
IISCryptoExportSessionKeyBlob2(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN LPSTR pszPasswd
    )

/*++

Routine Description:

    This routine exports a session key into a secure session key blob.
    The blob contains the session key (encrypted with the specified
    private key exchange key) and a digital signature (also encrypted).

Arguments:

    ppSessionKeyBlob - Will receive a pointer to the newly created
        session key blob if successful.

    hProv - A handle to a crypto service provider.

    hSessionKey - The key to export.

    pszPasswd - The password to use to encrypt the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    BYTE salt[ RANDOM_SALT_LENGTH ];
    HCRYPTHASH hash;
    DWORD keyLength;
    DWORD hashLength;
    PIC_BLOB2 blob;
    HCRYPTKEY hKeyDerivedKey = CRYPT_NULL;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppSessionKeyBlob != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hSessionKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            hSessionKey == DUMMY_HSESSIONKEY ) {

            return IISCryptoCreateCleartextBlob(
                       ppSessionKeyBlob,
                       (PVOID)"",
                       1
                       );

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;
    hash = CRYPT_NULL;

    //
    // Generate a random salt of at least 80 bits
    //
    
    if( !CryptGenRandom( hProv, RANDOM_SALT_LENGTH, salt ) )
    {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.CryptGenRandom (advapi32.dll) failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash( &hash, hProv );
    if( FAILED(result) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.IISCryptoCreateHash failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Hash the random salt
    
    if( !CryptHashData( hash, salt, RANDOM_SALT_LENGTH, 0 ) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Hash the password string
    //

    if( !CryptHashData( hash, ( BYTE * )pszPasswd, strlen( pszPasswd ), 0 ) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Derive a key from the supplied passwd
    //
    result = IISCryptoGetKeyDeriveKey2( &hKeyDerivedKey,
                                        hProv,
                                        hash
                                        );
    if( FAILED( result ) )
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.IISCryptoGetKeyDeriveKey2 failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Determine the required size of the key data.
    //

    status = CryptExportKey(
                 hSessionKey,
                 hKeyDerivedKey,
                 SYMMETRICWRAPKEYBLOB,
                 0,
                 NULL,
                 &keyLength
                 );
    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.CryptExportKey (advapi32.dll) failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob2(
               SALT_BLOB_SIGNATURE,
               keyLength,
               RANDOM_SALT_LENGTH
               );

    if( blob == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto fatal;
    }

    //
    // Export the key.
    //

    status = CryptExportKey(
                 hSessionKey,
                 hKeyDerivedKey,
                 SYMMETRICWRAPKEYBLOB,
                 0,
                 BLOB_TO_DATA2(blob),
                 &keyLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlob.CryptExportKey failed err=0x%x.\n",result));
        goto fatal;
    }

    status = CryptDestroyKey( hKeyDerivedKey );
    if( !status )
    {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportSessionKeyBlobWithPasswd.CryptDestroyKey (advapi32.dll) failed err=0x%x.\n",result));
        goto fatal;
    }

    DBG_ASSERT( keyLength == blob->DataLength );

    memcpy( BLOB_TO_SALT2( blob ), salt, RANDOM_SALT_LENGTH );

    //
    // Success!
    //

    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    *ppSessionKeyBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    

    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoExportSessionKeyBlob2


HRESULT
WINAPI
IISCryptoImportSessionKeyBlob2(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN LPSTR pszPasswd
    )

/*++

Routine Description:

    This routine takes the specified session key blob and creates the
    corresponding session key, iff the encrypted session key can be
    decrypted and the digital signature can be validated.

Arguments:

    phSessionKey - Receives a pointer to the newly created session key
        if successful.

    pSessionKeyBlob - Pointer to a key blob created with
        IISCryptoExportSessionKeyBlob().

    hProv - A handle to a crypto service provider.

    pszPasswd - The password to use to encrypt the session key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT    result = NO_ERROR;
    BOOL       status;
    BYTE       salt[ RANDOM_SALT_LENGTH ];
    HCRYPTKEY  hKeyDerivedKey;
    HCRYPTHASH hash;
    PIC_BLOB2  blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phSessionKey != NULL );
    DBG_ASSERT( pSessionKeyBlob != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( pszPasswd != NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            pSessionKeyBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE
            ) {

            *phSessionKey = DUMMY_HSESSIONKEY;
            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    DBG_ASSERT( pSessionKeyBlob->BlobSignature == SALT_BLOB_SIGNATURE );

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hash = CRYPT_NULL;
    blob = (PIC_BLOB2)pSessionKeyBlob;

    //
    // Get the random salt
    //

    memcpy( salt, BLOB_TO_SALT2( blob ), RANDOM_SALT_LENGTH );

    //
    // Create a hash object.
    //

    result = IISCryptoCreateHash( &hash, hProv );
    if( FAILED(result) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlobWithPasswd.IISCryptoCreateHash failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Hash the random salt

    if( !CryptHashData( hash, salt, RANDOM_SALT_LENGTH, 0 ) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlobWithPasswd.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Hash the password string
    //

    if( !CryptHashData( hash, ( BYTE * )pszPasswd, strlen( pszPasswd ), 0 ) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlobWithPasswd.CryptHashData failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Derive a key from the supplied passwd
    //
    result = IISCryptoGetKeyDeriveKey2( &hKeyDerivedKey,
                                        hProv,
                                        hash
                                        );
    if( FAILED( result ) )
    {
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlobWithPasswd.IISCryptoGetKeyDeriveKey2 failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // OK, import the key into our CSP.
    //

    status = CryptImportKey(
                 hProv,
                 BLOB_TO_DATA2(blob),
                 blob->DataLength,
                 hKeyDerivedKey,
                 0,
                 phSessionKey
                 );

    if( !status ) {
        //result = IcpGetLastError();
        result = HRESULT_FROM_WIN32( ERROR_WRONG_PASSWORD );
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportSessionKeyBlob.CryptImportKey failed err=0x%x.\n",result));
    }

    if( FAILED(result) ) {
        goto fatal;
    }

    //
    // Success!
    //

    DBG_ASSERT( *phSessionKey != CRYPT_NULL );
    DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );

    UpdateKeysOpened();
    return NO_ERROR;

fatal:

    if( hash != CRYPT_NULL ) {
        DBG_REQUIRE( SUCCEEDED( IISCryptoDestroyHash( hash ) ) );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoImportSessionKeyBlob2


HRESULT
WINAPI
IISCryptoExportPublicKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppPublicKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hPublicKey
    )

/*++

Routine Description:

    This routine exports a key into a public key blob. Note that since
    public keys are, well, public, then the data in the blob is neither
    encrypted nor signed.

Arguments:

    ppPublicKeyBlob - Will receive a pointer to the newly created public
        key blob if successful.

    hProv - A handle to a crypto service provider.

    hPublicKey - The public key to export. This should identify either a
        key exchange key or a signature key.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    DWORD keyLength;
    PIC_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( ppPublicKeyBlob != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );
    DBG_ASSERT( hPublicKey != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            ( hPublicKey == DUMMY_HKEYEXCHANGEKEY ||
              hPublicKey == DUMMY_HSIGNATUREKEY ) ) {

            return IISCryptoCreateCleartextBlob(
                       ppPublicKeyBlob,
                       (PVOID)&hPublicKey,
                       sizeof(hPublicKey)
                       );

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    blob = NULL;

    //
    // Determine the required size of the key data.
    //

    status = CryptExportKey(
                 hPublicKey,
                 CRYPT_NULL,
                 PUBLICKEYBLOB,
                 0,
                 NULL,
                 &keyLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportPublicKeyBlob.CryptExportKey failed err=0x%x.\n",result));
        goto fatal;
    }

    //
    // Create a new blob.
    //

    blob = IcpCreateBlob(
               PUBLIC_KEY_BLOB_SIGNATURE,
               keyLength,
               0
               );

    if( blob == NULL ) {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto fatal;
    }

    //
    // Export the key.
    //

    status = CryptExportKey(
                 hPublicKey,
                 CRYPT_NULL,
                 PUBLICKEYBLOB,
                 0,
                 BLOB_TO_DATA(blob),
                 &keyLength
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoExportPublicKeyBlob.CryptExportKey failed err=0x%x.\n",result));
        goto fatal;
    }

    DBG_ASSERT( keyLength == blob->DataLength );

    //
    // Success!
    //

    DBG_ASSERT( IISCryptoIsValidBlob( (PIIS_CRYPTO_BLOB)blob ) );
    *ppPublicKeyBlob = (PIIS_CRYPTO_BLOB)blob;

    UpdateBlobsCreated();
    return NO_ERROR;

fatal:

    if( blob != NULL ) {
        IcpFreeMemory( blob );
    }

    DBG_ASSERT( FAILED(result) );
    return result;

}   // IISCryptoExportPublicKeyBlob


HRESULT
WINAPI
IISCryptoImportPublicKeyBlob(
    OUT HCRYPTKEY * phPublicKey,
    IN PIIS_CRYPTO_BLOB pPublicKeyBlob,
    IN HCRYPTPROV hProv
    )

/*++

Routine Description:

    This routine takes the specified public key blob and creates the
    corresponding key.

Arguments:

    phPublicKey - Receives a pointer to the newly created public key if
        successful.

    pPublicKeyBlob - Pointer to a public key blob created with
        IISCryptoExportPublicKeyBlob().

    hProv - A handle to a crypto service provider.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;
    PIC_BLOB blob;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phPublicKey != NULL );
    DBG_ASSERT( pPublicKeyBlob != NULL );
    DBG_ASSERT( IISCryptoIsValidBlob( pPublicKeyBlob ) );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV &&
            pPublicKeyBlob->BlobSignature == CLEARTEXT_BLOB_SIGNATURE
            ) {

            *phPublicKey = *(HCRYPTKEY *)( pPublicKeyBlob + 1 );
            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    DBG_ASSERT( pPublicKeyBlob->BlobSignature == PUBLIC_KEY_BLOB_SIGNATURE );

    //
    // Import the key into our CSP.
    //

    blob = (PIC_BLOB)pPublicKeyBlob;

    status = CryptImportKey(
                 hProv,
                 BLOB_TO_DATA(blob),
                 blob->DataLength,
                 CRYPT_NULL,
                 0,
                 phPublicKey
                 );

    if( !status ) {
        result = IcpGetLastError();
        DBGPRINTF(( DBG_CONTEXT,"IISCryptoImportPublicKeyBlob.CryptImportKey failed err=0x%x.\n",result));
    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( *phPublicKey != CRYPT_NULL );
        UpdateKeysOpened();
    }

    return result;

}   // IISCryptoImportPublicKeyBlob


//
// Private functions.
//


HRESULT
IcpGetKeyHelper(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec
    )

/*++

Routine Description:

    This is a helper routine for IISCryptoGetKeyExchangeKey() and
    IISCryptoGetSignatureKey(). It tries to get/generate the specific
    key type within the given provider.

Arguments:

    phKey - Receives the key handle if successful.

    hProv - A handle to a crypto service provider.

    dwKeySpec - The specification of the key to open/create.

Return Value:

    HRESULT - Completion status, 0 if successful, !0 otherwise.

--*/

{

    HRESULT result = NO_ERROR;
    BOOL status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IcpGlobals.Initialized );
    DBG_ASSERT( phKey != NULL );
    DBG_ASSERT( hProv != CRYPT_NULL );

    //
    // Short-circuit if cryptography is disabled.
    //

    if( !IcpGlobals.EnableCryptography ) {
        if( hProv == DUMMY_HPROV ) {

            if( dwKeySpec == AT_KEYEXCHANGE ) {
                *phKey = DUMMY_HKEYEXCHANGEKEY;
            } else {
                ASSERT( dwKeySpec == AT_SIGNATURE );
                *phKey = DUMMY_HSIGNATUREKEY;
            }

            return NO_ERROR;

        } else {
            return RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Try to retrieve the key.
    //

    status = CryptGetUserKey(
                 hProv,
                 dwKeySpec,
                 phKey
                 );

    if( status ) {
        DBG_ASSERT( *phKey != CRYPT_NULL );
        UpdateKeysOpened();
        return NO_ERROR;
    }

    //
    // Could not get the key. If the failure was anything other than
    // NTE_NO_KEY, then we're toast.
    //

    result = IcpGetLastError();

    if( result != NTE_NO_KEY ) {
        DBGPRINTF(( DBG_CONTEXT,"IcpGetKeyHelper.CryptGetUserKey (advapi32.dll) failed err=0x%x.toast.\n",result));
        return result;
    }

    //
    // OK, CryptGetUserKey() failed with NTE_NO_KEY, meaning
    // that the key does not yet exist, so generate it now.
    //
    // Note that we must be careful to handle the inevitable race
    // conditions that can occur when multiple threads execute this
    // code and each thinks they need to generate the key. We handle
    // this by acquiring the global lock, then reattempting to get
    // the key. If we still cannot get the key, only then do we attempt
    // to generate one.
    //

    result = NO_ERROR;  // until proven otherwise...

    IcpAcquireGlobalLock();

    status = CryptGetUserKey(
                 hProv,
                 dwKeySpec,
                 phKey
                 );

    if( !status ) 
    {
        //
        // We still cannot get the key, so try to generate one.
        //
        DBGPRINTF(( DBG_CONTEXT,"IcpGetKeyHelper.CryptGetUserKey:failed, lets try to generate another key.\n"));
        status = CryptGenKey(
                     hProv,
                     dwKeySpec,
                     0,
                     phKey
                     );

        if( !status ) {
            result = IcpGetLastError();
            DBGPRINTF(( DBG_CONTEXT,"IcpGetKeyHelper.CryptGenKey (advapi32.dll) failed err=0x%x.\n",result));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,"IcpGetKeyHelper.CryptGenKey:key generated.\n"));
        }

    }

    if( SUCCEEDED(result) ) 
    {
        UpdateKeysOpened();
    }
    else
    {
        *phKey = CRYPT_NULL;
    }

    IcpReleaseGlobalLock();
    return result;

}   // IcpGetKeyHelper
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\precomp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


//
// System include files.
//

#include <windows.h>
#include <wincrypt.h>
#include <objbase.h>


//
// Project include files.
//

#include <dbgutil.h>
#include <iiscryptp.h>
#include <isplat.h>
#include <mdcommsg.h>


//
// Private include files.
//

#include <icryptp.h>


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\lib\memalloc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    memalloc.c

Abstract:

    Memory allocator for the crypto routines.

        IISCryptoAllocMemory
        IISCryptoFreeMemory

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


PVOID
WINAPI
IISCryptoAllocMemory(
    IN DWORD Size
    )
{

    return CoTaskMemAlloc( Size );

}   // IISCryptoAllocateMemory


VOID
WINAPI
IISCryptoFreeMemory(
    IN PVOID Buffer
    )
{

    CoTaskMemFree( Buffer );

}   // IISCryptoFreeMemory


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\test\delcont\precomp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


//
// System include files.
//

#include <windows.h>
#include <wincrypt.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//
// Project include files.
//

#include <dbgutil.h>
#include <iiscrypt.h>


//
// Local prototypes.
//

INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    );


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\test\delcont\delcont.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    delcont.c

Abstract:

    Delete Win32 Crypto Container.

Author:

    Keith Moore (keithmo)        19-Feb-1998

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else


//
// Private types.
//


//
// Private globals.
//

#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT()
#endif

//
// Private prototypes.
//


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    HRESULT result;
    DWORD flags;
    PSTR container;

    //
    // Initialize debug stuff.
    //

#ifdef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "delcont" );
#endif

    //
    // Validate the arguments.
    //

    flags = 0;
    container = argv[1];

    if( container != NULL ) {
        if( _stricmp( container, "-m" ) == 0 ) {
            flags = CRYPT_MACHINE_KEYSET;
            container = argv[2];
        }
    }

    if( !container ){
        printf(
            "use: delcont [-m] container_name\n"
            "\n"
            "    -m : Delete a machine keyset. Note: This is a very dangerous\n"
            "         option that can leave IIS in an unusable state requiring\n"
            "         reinstallation. Use at your own risk.\n"
            );
        return 1;
    }

    //
    // Initialize the crypto package.
    //

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Delete the container.
    //

    result = IISCryptoDeleteContainerByName(
                 container,
                 flags
                 );

    TEST_HRESULT( "IISDeleteContainerByName()" );

cleanup:

    (VOID)IISCryptoTerminate();
    return 0;

}   // main


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\test\simple\iiscrypt.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    iiscrypt.c

Abstract:

    IIS Crypto test app.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api)                                                   \
            if( FAILED(result) ) {                                          \
                                                                            \
                printf(                                                     \
                    "%s:%lu failed, error %08lx\n",                         \
                    api,                                                    \
                    __LINE__,                                               \
                    result                                                  \
                    );                                                      \
                                                                            \
                goto cleanup;                                               \
                                                                            \
            } else

#define CLOSE_KEY(h)                                                        \
            if( h != CRYPT_NULL ) {                                         \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoCloseKey( h );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoCloseKey( %08lx ):%lu failed, error %08lx\n", \
                        h,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }

#define DESTROY_HASH(h)                                                     \
            if( h != CRYPT_NULL ) {                                         \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoDestroyHash( h );                        \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoDestroyHash( %08lx ):%lu failed, error %08lx\n", \
                        h,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }

#define FREE_BLOB(b)                                                        \
            if( b != NULL ) {                                               \
                                                                            \
                HRESULT _result;                                            \
                                                                            \
                _result = IISCryptoFreeBlob( b );                           \
                                                                            \
                if( FAILED(_result) ) {                                     \
                                                                            \
                    printf(                                                 \
                        "IISCryptoFreeBlob( %08lx ):%lu failed, error %08lx\n", \
                        b,                                                  \
                        __LINE__,                                           \
                        _result                                             \
                        );                                                  \
                                                                            \
                }                                                           \
                                                                            \
            }


//
// Private types.
//


//
// Private globals.
//

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisCryptSimpleGuid, 
0x784d892C, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

CHAR PlainText[] = "This is our sample plaintext that we'll encrypt.";


//
// Private prototypes.
//


//
// Public functions.
//


INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    )
{

    HRESULT result;
    PVOID buffer;
    DWORD bufferLength;
    DWORD type;
    HCRYPTPROV hProv;
    HCRYPTKEY hKeyExchangeKey;
    HCRYPTKEY hKeyExchangeKey2;
    HCRYPTKEY hSignatureKey;
    HCRYPTKEY hSignatureKey2;
    HCRYPTKEY hSessionKey;
    HCRYPTKEY hSessionKey2;
    HCRYPTHASH hHash1;
    HCRYPTHASH hHash2;
    PIIS_CRYPTO_BLOB keyExchangePublicKeyBlob;
    PIIS_CRYPTO_BLOB signaturePublicKeyBlob;
    PIIS_CRYPTO_BLOB sessionKeyBlob;
    PIIS_CRYPTO_BLOB dataBlob;
    PIIS_CRYPTO_BLOB hashBlob1;
    PIIS_CRYPTO_BLOB hashBlob2;

    //
    // Initialize debug stuff.
    //

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt", IisCryptSimpleGuid );
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( "iiscrypt" );
#endif

    //
    // Setup our locals so we know how to cleanup on exit.
    //

    hProv = CRYPT_NULL;

    hKeyExchangeKey = CRYPT_NULL;
    hKeyExchangeKey2 = CRYPT_NULL;
    hSignatureKey = CRYPT_NULL;
    hSignatureKey2 = CRYPT_NULL;
    hSessionKey = CRYPT_NULL;
    hSessionKey2 = CRYPT_NULL;

    hHash1 = CRYPT_NULL;
    hHash2 = CRYPT_NULL;

    keyExchangePublicKeyBlob = NULL;
    signaturePublicKeyBlob = NULL;
    sessionKeyBlob = NULL;
    dataBlob = NULL;
    hashBlob1 = NULL;
    hashBlob2 = NULL;

    //
    // Initialize the crypto package.
    //

    result = IISCryptoInitialize();

    TEST_HRESULT( "IISCryptoInitialize()" );

    //
    // Open the container.
    //

    result = IISCryptoGetStandardContainer(
                 &hProv,
                 0
                 );

    TEST_HRESULT( "IISCryptoGetStandardContainer()" );
    printf( "hProv = %08lx\n", hProv );

    //
    // Get some keys.
    //

    result = IISCryptoGetKeyExchangeKey(
                 &hKeyExchangeKey,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoGetKeyExchangeKey()" );
    printf( "hKeyExchangeKey = %08lx\n", hKeyExchangeKey );

    result = IISCryptoGetSignatureKey(
                 &hSignatureKey,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoGetSignatureKey()" );
    printf( "hSignatureKey = %08lx\n", hSignatureKey );

    result = IISCryptoGenerateSessionKey(
                 &hSessionKey,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoGenerateSessionKey()" );
    printf( "hSessionKey = %08lx\n", hSessionKey );

    //
    // Create a couple of public key blobs.
    //

    result = IISCryptoExportPublicKeyBlob(
                 &keyExchangePublicKeyBlob,
                 hProv,
                 hKeyExchangeKey
                 );

    TEST_HRESULT( "IISCryptoExportPublicKeyBlob()" );
    printf( "keyExchangePublicKeyBlob = %p\n", keyExchangePublicKeyBlob );

    result = IISCryptoExportPublicKeyBlob(
                 &signaturePublicKeyBlob,
                 hProv,
                 hSignatureKey
                 );

    TEST_HRESULT( "IISCryptoExportPublicKeyBlob()" );
    printf( "signaturePublicKeyBlob = %p\n", signaturePublicKeyBlob );

    //
    // Now try to import them.
    //

    result = IISCryptoImportPublicKeyBlob(
                 &hKeyExchangeKey2,
                 keyExchangePublicKeyBlob,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoImportPublicKeyBlob()" );
    printf( "hKeyExchangeKey2 = %08lx\n", hKeyExchangeKey2 );

    result = IISCryptoImportPublicKeyBlob(
                 &hSignatureKey2,
                 signaturePublicKeyBlob,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoImportPublicKeyBlob()" );
    printf( "hSignatureKey2 = %08lx\n", hSignatureKey2 );

    //
    // Create a session key blob.
    //

    result = IISCryptoExportSessionKeyBlob(
                 &sessionKeyBlob,
                 hProv,
                 hSessionKey,
                 hKeyExchangeKey
                 );

    TEST_HRESULT( "IISCryptoExportSessionKeyBlob()" );
    printf( "sessionKeyBlob = %p\n", sessionKeyBlob );

    //
    // Now try to import it back, using the imported signature key.
    //

    result = IISCryptoImportSessionKeyBlob(
                 &hSessionKey2,
                 sessionKeyBlob,
                 hProv,
                 hSignatureKey2
                 );

    TEST_HRESULT( "IISCryptoImportKeyBlob()" );
    printf( "hSessionKey2 = %08lx\n", hSessionKey2 );

    //
    // Create an encrypted data blob using the original session key.
    //

    printf( "PlainText[%lu:%lu] = %s\n", sizeof(PlainText), REG_SZ, PlainText );

    result = IISCryptoEncryptDataBlob(
                 &dataBlob,
                 PlainText,
                 sizeof(PlainText),
                 REG_SZ,
                 hProv,
                 hSessionKey
                 );

    TEST_HRESULT( "IISCryptoEncryptDataBlob()" );
    printf( "dataBlob = %p\n", dataBlob );

    //
    // Decrypt the data blob using the imported session and signature keys.
    //

    result = IISCryptoDecryptDataBlob(
                 &buffer,
                 &bufferLength,
                 &type,
                 dataBlob,
                 hProv,
                 hSessionKey2,
                 hSignatureKey2
                 );

    TEST_HRESULT( "IISCryptoDecryptDataBlob()" );
    printf( "decrypted data[%lu:%lu] = %s\n", bufferLength, type, buffer );

    //
    // Create a hash object number 1 containing the plaintext data
    // and the original session key, then export it as a hash blob.
    //

    result = IISCryptoCreateHash(
                 &hHash1,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoCreateHash()" );
    printf( "hHash1 = %08lx\n", hHash1 );

    result = IISCryptoHashData(
                 hHash1,
                 PlainText,
                 sizeof(PlainText)
                 );

    TEST_HRESULT( "IISCryptoHashData()" );

    result = IISCryptoHashSessionKey(
                 hHash1,
                 hSessionKey
                 );

    TEST_HRESULT( "IISCryptoHashSessionKey()" );

    result = IISCryptoExportHashBlob(
                 &hashBlob1,
                 hHash1
                 );

    TEST_HRESULT( "IISCryptoExportHashBlob()" );
    printf( "hashBlob1 = %p\n", hashBlob1 );

    //
    // Now do the same with the decrypted data and the imported key.
    //

    result = IISCryptoCreateHash(
                 &hHash2,
                 hProv
                 );

    TEST_HRESULT( "IISCryptoCreateHash()" );
    printf( "hHash2 = %08lx\n", hHash2 );

    result = IISCryptoHashData(
                 hHash2,
                 buffer,
                 bufferLength
                 );

    TEST_HRESULT( "IISCryptoHashData()" );

    result = IISCryptoHashSessionKey(
                 hHash2,
                 hSessionKey2
                 );

    TEST_HRESULT( "IISCryptoHashSessionKey()" );

    result = IISCryptoExportHashBlob(
                 &hashBlob2,
                 hHash2
                 );

    TEST_HRESULT( "IISCryptoExportHashBlob()" );
    printf( "hashBlob2 = %p\n", hashBlob2 );

    //
    // Now compare the hash blobs. They had better match.
    //

    if( IISCryptoCompareBlobs( hashBlob1, hashBlob2 ) ) {

        printf( "hashBlob1 == hashBlob2\n" );

    } else {

        printf( "HASH BLOBS DON'T MATCH!!\n" );

    }

cleanup:

    FREE_BLOB( hashBlob2);
    FREE_BLOB( hashBlob1);
    FREE_BLOB( dataBlob );
    FREE_BLOB( sessionKeyBlob );
    FREE_BLOB( signaturePublicKeyBlob );
    FREE_BLOB( keyExchangePublicKeyBlob );

    DESTROY_HASH( hHash2 );
    DESTROY_HASH( hHash1 );

    CLOSE_KEY( hSessionKey2 );
    CLOSE_KEY( hSessionKey );
    CLOSE_KEY( hSignatureKey2 );
    CLOSE_KEY( hSignatureKey );
    CLOSE_KEY( hKeyExchangeKey2 );
    CLOSE_KEY( hKeyExchangeKey );

    if( hProv != CRYPT_NULL ) {

        (VOID)IISCryptoCloseContainer( hProv );

    }

    (VOID)IISCryptoTerminate();

    DELETE_DEBUG_PRINT_OBJECT();

    return 0;

}   // main


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\alloc.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\alloc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\aucommon.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\aucommon.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\isplat\isplat.cxx ===
/*++

    Copyright (c) 1996  Microsoft Corporation

    Module  Name :
        isplat.cxx

    Abstract:

        This module defines functions for determining platform types

    Author:

        Johnson Apacible    (johnsona)      19-Nov-1996
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <isplat.h>
#include <inetsvcs.h>

PLATFORM_TYPE TsPlatformType = PtInvalid;

typedef
BOOLEAN
(NTAPI *GET_PRODUCT_TYPE)(
            PNT_PRODUCT_TYPE
            );

PLATFORM_TYPE
IISGetPlatformType(
        VOID
        )
/*++

  This function consults the registry and determines the platform type
   for this machine.

  Arguments:

    None

  Returns:
    Platform type

--*/
{
    PLATFORM_TYPE pt;
    LONG result;
    HKEY keyHandle;
    WCHAR productType[30];
    DWORD type;
    BOOL isNt = TRUE;

    OSVERSIONINFO osInfo;

    //
    // See if the platform type has already been discovered.
    //

    if ( TsPlatformType != PtInvalid ) {
        return(TsPlatformType);
    }

    //
    // see if this is win95
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } else {
        IIS_PRINTF((buff,"GetVersionEx failed with %d\n",
            GetLastError()));
    }

    if ( isNt ) {

        HINSTANCE hNtdll;
        NT_PRODUCT_TYPE ntType;
        GET_PRODUCT_TYPE pfnGetProductType;

        //
        // Get the product type from the system
        //

        pt = PtNtWorkstation;
        hNtdll = LoadLibrary("ntdll.dll");
        if ( hNtdll != NULL ) {

            pfnGetProductType = (GET_PRODUCT_TYPE)
                GetProcAddress(hNtdll, "RtlGetNtProductType");

            if ( (pfnGetProductType != NULL) &&
                  pfnGetProductType( &ntType ) ) {

                if ( (ntType == NtProductLanManNt) ||
                     (ntType == NtProductServer) ) {

                    pt = PtNtServer;
                }
            }

            FreeLibrary( hNtdll );
        }

    } else {
        pt = PtWindows95;
    }

    TsPlatformType = pt;
    return(pt);

} // IISGetPlatformType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\iiscrypt\test\simple\precomp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


//
// System include files.
//

#include <windows.h>
#include <wincrypt.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//
// Project include files.
//

#include <dbgutil.h>
#include <iiscrypt.h>


//
// Local prototypes.
//

INT
__cdecl
main(
    INT argc,
    CHAR * argv[]
    );


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\buffer.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\buffer.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\acache.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\acache.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\eventlog.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\eventlog.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\inetmisc\mb.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mb.cxx

Abstract:

    This module implements the MB class.

Author:

    Keith Moore (keithmo)        05-Feb-1997
        Moved from "inlines" in MB.HXX.

Revision History:

--*/


#include "imiscp.hxx"


//
//  Default timeout
//

#define MB_TIMEOUT           (30 * 1000)

//
//  Default timeout for SaveData
//

#define MB_SAVE_TIMEOUT      (10 * 1000)        // milliseconds

MB::MB( IMDCOM * pMBCom )
    : _pMBCom( pMBCom ),
      _hMB   ( NULL )
{
    DBG_ASSERT( _pMBCom );
}

MB::~MB( VOID )
{
    Close();
    _pMBCom = NULL;
}

BOOL MB::EnumObjects( const CHAR * pszPath,
                      CHAR *       Name,
                      DWORD        Index )
{
    HRESULT hRes = _pMBCom->ComMDEnumMetaObjects( _hMB,
                                                  (BYTE *)pszPath,
                                                  (BYTE *)Name,
                                                  Index );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::AddObject( const CHAR * pszPath )
{
    HRESULT hRes = _pMBCom->ComMDAddMetaObject( _hMB,
                                                (BYTE *)pszPath );
    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::DeleteObject( const CHAR * pszPath )
{
    HRESULT hRes = _pMBCom->ComMDDeleteMetaObject( _hMB,
                                                   (BYTE *)pszPath );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::ReleaseReferenceData( DWORD dwTag )
{
    HRESULT hRes = _pMBCom->ComMDReleaseReferenceData( dwTag );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::Save( VOID )
{
    HRESULT hRes;
    METADATA_HANDLE mdhRoot;


    //
    // First try to lock the tree
    //

    hRes = _pMBCom->ComMDOpenMetaObjectW(METADATA_MASTER_ROOT_HANDLE,
                                            NULL,
                                            METADATA_PERMISSION_READ,
                                            MB_SAVE_TIMEOUT,
                                            &mdhRoot);

    //
    // If failed, then someone has a write handle open,
    // and there might be an inconsistent data state, so don't save.
    //

    if (SUCCEEDED(hRes)) {
        //
        // call metadata com api
        //

        hRes = _pMBCom->ComMDSaveData(mdhRoot);


        _pMBCom->ComMDCloseMetaObject(mdhRoot);

    }

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::GetSystemChangeNumber( DWORD *pdwChangeNumber )
{
    HRESULT hRes = _pMBCom->ComMDGetSystemChangeNumber(pdwChangeNumber);

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
}

BOOL MB::DeleteData(const CHAR *  pszPath,
                    DWORD         dwPropID,
                    DWORD         dwUserType,
                    DWORD         dwDataType )
{
    HRESULT hRes = _pMBCom->ComMDDeleteMetaData( _hMB,
                                                (LPBYTE) pszPath,
                                                dwPropID,
                                                dwDataType );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }
    SetLastError( HRESULTTOWIN32( hRes ));
    return(FALSE);
}

BOOL MB::Close( VOID )
{
    if ( _hMB )
    {
        DBG_REQUIRE( SUCCEEDED(_pMBCom->ComMDCloseMetaObject( _hMB )) );
        _hMB = NULL;
    }

    return TRUE;
}

BOOL
MB::Open(
    METADATA_HANDLE hOpenRoot,
    const CHAR *    pszPath,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Opens the metabase

Arguments:

    hOpenRoot - Relative root or METADATA_MASTER_ROOT_HANDLE
    pszPath - Path to open
    dwFlags - Open flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    HRESULT hRes;

    DBG_ASSERT(_hMB == NULL);

    hRes = _pMBCom->ComMDOpenMetaObject( hOpenRoot,
                                         (BYTE *) pszPath,
                                         dwFlags,
                                         MB_TIMEOUT,
                                         &_hMB );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT,
                "[MB::Open] Failed to open %s, error %x (%d)\n",
                pszPath,
                hRes,
                HRESULTTOWIN32( hRes ) ));

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

BOOL
MB::SetData(
    const CHAR * pszPath,
    DWORD        dwPropID,
    DWORD        dwUserType,
    DWORD        dwDataType,
    VOID *       pvData,
    DWORD        cbData,
    DWORD        dwFlags
    )
/*++

Routine Description:

    Sets a metadata property on an openned metabase

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    cbData - Size of data
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;

    DBG_ASSERT( _hMB );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = _pMBCom->ComMDSetMetaData( _hMB,
                                      (LPBYTE) pszPath,
                                      &mdRecord );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT,
                "[MB::SetData] Failed to open %s, error %x (%d)\n",
                pszPath,
                hRes,
                HRESULTTOWIN32( hRes ) ));

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

BOOL
MB::GetData(
    const CHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    DWORD         dwDataType,
    VOID *        pvData,
    DWORD *       pcbData,
    DWORD         dwFlags
    )
/*++

Routine Description:

    Retrieves a metadata property on an openned metabase

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    pcbData - Size of pvData, receives size of object
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DBG_ASSERT( _hMB );
    DBG_ASSERT(pcbData);

    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen = *pcbData;

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = _pMBCom->ComMDGetMetaData( _hMB,
                                      (LPBYTE) pszPath,
                                      &mdRecord,
                                      &dwRequiredLen );

    if ( SUCCEEDED( hRes ))
    {
        *pcbData = mdRecord.dwMDDataLen;
        return TRUE;
    }

    *pcbData = dwRequiredLen;

#if 0
    DBGPRINTF(( DBG_CONTEXT,
                "[MB::GetData] Failed, PropID(%d), UserType(%d) Flags(%d) on %s, hRes = 0x%08x (%d)\n",
                dwPropID,
                dwUserType,
                dwFlags,
                pszPath,
                hRes,
                HRESULTTOWIN32( hRes ) ));
#endif

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

BOOL
MB::ReferenceData(
    const CHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    DWORD         dwDataType,
    VOID * *      ppvData,
    DWORD *       pcbData,
    DWORD *       pdwTag,
    DWORD         dwFlags
    )
/*++

Routine Description:

    References a metadata property item

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    ppvData - Receives pointer to referenced data
    pdwTag - Receives dword tag for releasing this reference
    dwFlags - flags (must have METADATA_REFERENCE)

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

    DBG_ASSERT( _hMB );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = 0;
    mdRecord.pbMDData        = NULL;

    hRes = _pMBCom->ComMDGetMetaData( _hMB,
                                      (LPBYTE) pszPath,
                                      &mdRecord,
                                      &dwRequiredLen );

    if ( SUCCEEDED( hRes ))
    {
        *ppvData = mdRecord.pbMDData;
        *pcbData = mdRecord.dwMDDataLen;
        *pdwTag  = mdRecord.dwMDDataTag;

        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

BOOL MB::GetAll(
    const CHAR *   pszPath,
    DWORD          dwFlags,
    DWORD          dwUserType,
    BUFFER *       pBuff,
    DWORD *        pcRecords,
    DWORD *        pdwDataSetNumber
    )
/*++

Routine Description:

    Retrieves all the metabase properties on this path of the request type

Arguments:

    pszPath - Path to set data on
    dwFlags - Inerhitance flags
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    pcbData - Size of pvData, receives size of object
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD   RequiredSize;
    HRESULT hRes;

    DBG_ASSERT( _hMB );

TryAgain:

    hRes = _pMBCom->ComMDGetAllMetaData( _hMB,
                            (unsigned char *)pszPath,
                            dwFlags,
                            dwUserType,
                            ALL_METADATA,
                            pcRecords,
                            pdwDataSetNumber,
                            pBuff->QuerySize(),
                            (PBYTE)pBuff->QueryPtr(),
                            &RequiredSize
                            );

    // See if we got it, and if we failed because of lack of buffer space
    // try again.

    if ( SUCCEEDED(hRes) )
    {
        return TRUE;
    }

    // Some sort of error, most likely not enough buffer space. Keep
    // trying until we get a non-fatal error.

    if (HRESULT_FACILITY(hRes) == FACILITY_WIN32 &&
        HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER) {

        // Not enough buffer space. RequiredSize contains the amount
        // the metabase thinks we need.

        if ( !pBuff->Resize(RequiredSize) ) {

            // Not enough memory to resize.
            return FALSE;
        }

        goto TryAgain;

    }

    return FALSE;
}

BOOL MB::GetDataSetNumber(
    const CHAR *   pszPath,
    DWORD *        pdwDataSetNumber
    )
/*++

Routine Description:

    Retrieves the data set number and size of the data from the
    metabase.

Arguments:

    pszPath - Path to set data on
    pdwDataSetNumber - Where to return the data set number.

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    HRESULT hRes;

    //
    //  We allow _hMB to be null (root handle) for this API (though technically
    //  all the APIs allow the metabase handle to be null)
    //

    hRes = _pMBCom->ComMDGetDataSetNumber( _hMB,
                                           (unsigned char *)pszPath,
                                           pdwDataSetNumber );

    return SUCCEEDED(hRes);
}

BOOL
MB::GetStr(
    const CHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    STR *         pstrValue,
    DWORD         dwFlags,
    const CHAR *  pszDefault
    )
/*++

Routine Description:

    Retrieves the string from the metabase.  If the value wasn't found and
    a default is supplied, then the default value is copied to the string.

Arguments:

    pszPath - Path to get data on
    dwPropID - property id to retrieve
    dwUserType - User type for this property
    pstrValue - string that receives the value
    dwFlags - Metabase flags
    pszDefault - Default value to use if the string isn't found, NULL
        for no default value (i.e., will return an error).

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD cbSize = pstrValue->QuerySize();

TryAgain:

    if ( !GetData( pszPath,
                   dwPropID,
                   dwUserType,
                   STRING_METADATA,
                   pstrValue->QueryStr(),
                   &cbSize,
                   dwFlags ))
    {
        if ( GetLastError() == MD_ERROR_DATA_NOT_FOUND )
        {
            if ( pszDefault != NULL )
            {
                return pstrValue->Copy( pszDefault );
            }

            return FALSE;
        }
        else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                  pstrValue->Resize( cbSize ) )
        {
            goto TryAgain;
        }

        return FALSE;
    }

    DBG_REQUIRE( pstrValue->SetLen( cbSize ? (cbSize - 1) : 0  ));

    return TRUE;
}

BOOL
MB::GetMultisz(
    const CHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    MULTISZ *     multiszValue,
    DWORD         dwFlags
    )
/*++

Routine Description:

    Retrieves the string from the metabase.  If the value wasn't found and
    a default is supplied, then the default value is copied to the string.

Arguments:

    pszPath - Path to get data on
    dwPropID - property id to retrieve
    dwUserType - User type for this property
    multiszValue - multi-string that receives the value
    dwFlags - Metabase flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD cbSize = multiszValue->QuerySize();

TryAgain:

    if ( !GetData( pszPath,
                   dwPropID,
                   dwUserType,
                   MULTISZ_METADATA,
                   multiszValue->QueryStr(),
                   &cbSize,
                   dwFlags ))
    {
        if ( GetLastError() == MD_ERROR_DATA_NOT_FOUND )
        {
            return FALSE;
        }
        else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                  multiszValue->Resize( cbSize ) )
        {
            goto TryAgain;
        }

        return FALSE;
    }

    //
    //  Value was read directly into the buffer so update the member
    //  variables
    //

    multiszValue->RecalcLen();

    return TRUE;
}


BOOL MB::GetDataPaths(
    const CHAR *   pszPath,
    DWORD          dwPropID,
    DWORD          dwDataType,
    BUFFER *       pBuff
    )
/*++

Routine Description:

    Retrieves all the metabase properties on this path of the request type

Arguments:

    pszPath - Path to set data on
    dwFlags - Inerhitance flags
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    pcbData - Size of pvData, receives size of object
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD   RequiredSize;
    HRESULT hRes;

    DBG_ASSERT( _hMB );
    DBG_ASSERT( pBuff != NULL );

TryAgain:

    hRes = _pMBCom->ComMDGetMetaDataPaths( _hMB,
                                           (unsigned char *)pszPath,
                                           dwPropID,
                                           dwDataType,
                                           pBuff->QuerySize(),
                                           (PBYTE)pBuff->QueryPtr(),
                                            &RequiredSize
                                           );

    // See if we got it, and if we failed because of lack of buffer space
    // try again.

    if ( SUCCEEDED(hRes) )
    {
        return TRUE;
    }

    // Some sort of error, most likely not enough buffer space. Keep
    // trying until we get a non-fatal error.

    if (HRESULT_FACILITY(hRes) == FACILITY_WIN32 &&
        HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER) {

        // Not enough buffer space. RequiredSize contains the amount
        // the metabase thinks we need.

        if ( !pBuff->Resize(RequiredSize) ) {

            // Not enough memory to resize.
            return FALSE;
        }

        goto TryAgain;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\svmap\svmap.cpp ===
/*++

    Copyright    (c)    1995-1996    Microsoft Corporation

    Module  Name :
        
        svmap.cpp

    Abstract:
        
        Provides name/id mapping for server variables. Used
        to allow server variable values to be cached by out
        of process applications.   

    Author:

        Taylor Weiss    ( TaylorW )     19-Apr-1999

    Environment:


    Project:

        w3svc.dll       private\inet\iis\svcs\w3\server
        wam.dll         private\inet\iis\svcs\wam\object

    Functions Exported:


    Revision History:

--*/

#include <windows.h>
#include <dbgutil.h>

#include <svmap.h>

// Define a table of name, len pairs for each cachable server variable

#define DEFINE_SV( token ) { #token, sizeof(#token) - 1 },

SV_CACHE_MAP::SV_NAME 
SV_CACHE_MAP::sm_rgNames[] =
{
    ALL_SERVER_VARIABLES()
};

#undef DEFINE_SV

BOOL 
SV_CACHE_MAP::Initialize( VOID )
/*++

Routine Description:

    Fills our hash table with name, id pairs.

--*/
{
    BOOL    fInitialized = TRUE;
    DWORD   dwHashValue;

    for( int i = 0; i < SV_COUNT; ++i )
    {
        dwHashValue = HashString( FindName(i) );
        DBG_ASSERT( dwHashValue < TABLE_SIZE );
        
        // It really isn't bad if we collide, it just means that
        // this particular server variable will not be cachable

        DBG_REQUIRE( m_rgHashTable[dwHashValue].InsertValue( i ) );
    }
   
    return fInitialized;
}

BOOL 
SV_CACHE_MAP::FindOrdinal( 
    IN LPCSTR pszName,
    IN INT    cchName,
    OUT DWORD * pdwOrdinal
    ) const
/*++

Routine Description:

    Lookup the server variable specified by name and return it's
    ordinal if found.

    NOTE - We should provide method that doesn't require the 
    length!

Return Value
    
    FALSE == Not found
    TRUE == Found - pdwOrdinal contains the server variable id.

--*/
{
    BOOL    fFoundIt = FALSE;

    DBG_ASSERT( pdwOrdinal );
    
    DWORD                   dwHashValue  = HashString(pszName);
    const HASH_TABLE_ENTRY  &hte         = m_rgHashTable[dwHashValue];
    
    if( !hte.IsSlotEmpty(0) )
    {
        // Hashed to a non empty entry
        
        if( hte.IsSlotEmpty(1) )
        {
            // It's the only one.
            *pdwOrdinal = hte.GetSlotValue(0);
            fFoundIt = StringMatches( pszName, cchName, *pdwOrdinal );
        }
        else
        {
            // Collision, need to compare strings with all
            // the non empty slots or until we get a hit

            DBG_ASSERT( !hte.IsSlotEmpty(0) );
            DBG_ASSERT( !hte.IsSlotEmpty(1) );

            if( StringMatches(pszName, cchName, hte.GetSlotValue(0)) )
            {
                *pdwOrdinal = hte.GetSlotValue(0);
                fFoundIt = TRUE;
            }
            else if( StringMatches(pszName, cchName, hte.GetSlotValue(1)) )
            {
                *pdwOrdinal = hte.GetSlotValue(1);
                fFoundIt = TRUE;
            }
            else if( !hte.IsSlotEmpty(2) &&
                     StringMatches( pszName, cchName, hte.GetSlotValue(2) )
                     )
            {
                *pdwOrdinal = hte.GetSlotValue(2);
                fFoundIt = TRUE;
            }
            else if( !hte.IsSlotEmpty(3) &&
                     StringMatches( pszName, cchName, hte.GetSlotValue(3) )
                     )
            {
                *pdwOrdinal = hte.GetSlotValue(3);
                fFoundIt = TRUE;
            }
        }
    }
    return fFoundIt;
}

VOID 
SV_CACHE_MAP::PrintToBuffer( 
    IN CHAR *       pchBuffer,
    IN OUT LPDWORD  pcch
    ) const
/*++

Routine Description:

    Dump the hash table to pchBuffer.

    Note: We really aren't checking pcch as an in parameter. If
    the buffer is too small we will overwrite it.

--*/
{
    DWORD cb = 0;

    DBG_ASSERT( NULL != pchBuffer);

    cb += wsprintfA( pchBuffer + cb, 
                     "SV_CACHE_MAP(%p): sizeof(SV_CACHE_MAP)=%08x\n",
                     this,
                     sizeof(SV_CACHE_MAP)
                     );
    DBG_ASSERT( cb < *pcch );

    // Gather some stats on the hash table

    DWORD dwEmptyEntries = 0;
    DWORD dwFilledEntries = 0;
    DWORD dwCollisions = 0;

    for( int i = 0; i < TABLE_SIZE; ++i )
    {
        if( m_rgHashTable[i].IsSlotEmpty(0) )
        {
            ++dwEmptyEntries;
        }
        else
        {
            ++dwFilledEntries;
            if( !m_rgHashTable[i].IsSlotEmpty(1) )
            {
                ++dwCollisions;
            }
            if( !m_rgHashTable[i].IsSlotEmpty(2) )
            {
                ++dwCollisions;
            }
            if( !m_rgHashTable[i].IsSlotEmpty(3) )
            {
                ++dwCollisions;
            }
        }
    }

    cb += wsprintfA( pchBuffer + cb,
                     "Table Size = %d; Hashed Items = %d; Empty Entries = %d; "
                     "Filled Entries = %d; Collisions = %d;\n",
                     TABLE_SIZE, SV_COUNT, dwEmptyEntries, dwFilledEntries,
                     dwCollisions
                     );

    DBG_ASSERT( cb < *pcch );

    for( int j = 0; j < TABLE_SIZE; ++j )
    {
        if( !m_rgHashTable[j].IsSlotEmpty(0) )
        {
            cb += wsprintfA( pchBuffer + cb, "%03d", j );
            DBG_ASSERT( cb < *pcch );

            int k = 0;
            while( k < HASH_TABLE_ENTRY::MAX_ITEMS && !m_rgHashTable[j].IsSlotEmpty(k) )
            {
                cb += wsprintfA( pchBuffer + cb,
                                 " - %d (%s)",
                                 m_rgHashTable[j].GetSlotValue(k),
                                 sm_rgNames[m_rgHashTable[j].GetSlotValue(k)]
                                 );
                DBG_ASSERT( cb < *pcch );
                
                k++;
            }

            cb += wsprintfA( pchBuffer + cb, "\n" );
            DBG_ASSERT( cb < *pcch );
        }
    }

    *pcch = cb;
    return;
}

VOID 
SV_CACHE_MAP::Print( VOID ) const
/*++

Routine Description:


--*/
{
    // DANGER - This buffer size is much larger then necessary, but
    // changes to the PrintToBuffer or the underlying size of the
    // SV_CACHE_MAP may make this buffer insufficient.

    CHAR  pchBuffer[ 10000 ];
    DWORD cb = sizeof( pchBuffer );

    PrintToBuffer( pchBuffer, &cb );
    DBG_ASSERT( cb < sizeof(pchBuffer) );

    DBGDUMP(( DBG_CONTEXT, pchBuffer ));
}

VOID 
SV_CACHE_LIST::GetBufferItems
( 
    IN OUT BUFFER_ITEM *    pBufferItems,
    IN OUT DWORD *          pdwBufferItemCount
)
/*++

Routine Description:

    Initialize pBufferItems with the server variable ids that
    should be cached.

--*/
{
    DBG_ASSERT( pdwBufferItemCount && *pdwBufferItemCount >= SVID_COUNT );

    DWORD   dwCount = 0;

    for( DWORD svid = 0; svid < SVID_COUNT; ++svid )
    {
        if( m_rgItems[svid].fCached )
        {
            if( dwCount < *pdwBufferItemCount )
            {
                pBufferItems[dwCount].svid = svid;
                pBufferItems[dwCount].dwOffset = 0;
            }
            ++dwCount;
        }
    }
    *pdwBufferItemCount = dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\svmap\tsvmap.cpp ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
      tsvmap.cxx

   Abstract:
      This is a test module for the server variable map
      
   Author:

       Taylor Weiss    ( TaylorW )     19-Apr-1999

   Environment:
    
       User Mode - Win32 

   Project:

       Internet Information Services

   Functions Exported:


   Revision History:

--*/

#include <windows.h>

#include <dbgutil.h>

#include <svmap.h>
#include <stdio.h>
#include <stdlib.h>

DECLARE_DEBUG_PRINTS_OBJECT();
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisTSvMapGuid, 
0x784d8939, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();    
#endif

#define DEFINE_SV( token ) #token,

LPCSTR rgValidNames[] =
{
    ALL_SERVER_VARIABLES()
};

#undef DEFINE_SV

int cValidNames = sizeof(rgValidNames)/sizeof(rgValidNames[0]);

LPCSTR rgInvalidNames[] =
{
    "HTTP_BOGUS",
    "_HTTP_",
    "47",
    "",
    "Hello, There!",
    "0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz"
};

int cInvalidNames = sizeof(rgInvalidNames)/sizeof(rgInvalidNames[0]);

int __cdecl
main(int argc, char * argv[])
{
    int argSeen = 1;

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( argv[0], IisTSvMapGuid);
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( argv[0]);
    SET_DEBUG_FLAGS( DEBUG_ERROR | DEBUG_INIT_CLEAN);
#endif
    
    SV_CACHE_MAP    map;

    DBG_REQUIRE( map.Initialize() );

    // Dump the table
    
    // This should be more than enough space, see
    // SV_CACHE_MAP::Print if this asserts.

    CHAR  pchBuffer[ 5000 ];
    DWORD cb = sizeof( pchBuffer );

    map.PrintToBuffer( pchBuffer, &cb );
    DBG_ASSERT( cb < sizeof(pchBuffer) );

    printf( pchBuffer );

    DWORD dwId = 0;

    // Do lookups for all valid names

    for( int i = 0; i < cValidNames; ++i )
    {
        DBG_REQUIRE( map.FindOrdinal( rgValidNames[i], 
                                      strlen( rgValidNames[i] ), 
                                      &dwId 
                                      ) );
        
        DBG_REQUIRE( strcmp( rgValidNames[i], map.FindName( dwId ) ) == 0 );
    }

    // Do lookups for invalid names

    for( int j = 0; j < cInvalidNames; ++j )
    {
        DBG_REQUIRE( map.FindOrdinal( rgInvalidNames[j],
                                      strlen( rgInvalidNames[j] ),
                                      &dwId 
                                      ) == FALSE );
    }
   
    DELETE_DEBUG_PRINT_OBJECT();

    return 1;
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\irtl\pwssvcs\pwsctrl.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pwsctrl.cpp

Abstract:

    This is the main routine for the Internet Services suite.

Author:

    Johnson Apacible    (JohnsonA)  29-Apr-1997
    Boyd Multerer       (BoydM)     29-Apr-1997

--*/

//#include "stdafx.h"

//#include "resource.h"

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
//#include <coiadm.hxx>
//#include <admacl.hxx>
#include <iiscnfg.h>
//#include <secpriv.h>
//#include <globlist.hxx>
#include <buffer.hxx>
#include <string.hxx>
#include <pwsctrl.h>
#include <shellapi.h>
#include <pwsdata.hxx>
#include <inetsvcs.h>


#define REGKEY_STP          TEXT("SOFTWARE\\Microsoft\\INetStp")
#define REGKEY_INSTALLKEY   TEXT("InstallPath")

//------------------------------------------------------------------------
//BOOL W95StartW3SVC( LPCSTR pszPath, LPCSTR pszPathDir, PCHAR pszParams )
BOOL W95StartW3SVC( void )
    {
    HKEY                hKey;
    TCHAR               chPath[MAX_PATH+1];
    DWORD       cbPath;
    DWORD       err, type;
    STR         strPath;

    // get the server install path from the registry
    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle of open key
            REGKEY_STP,             // address of name of subkey to open
            0,                                  // reserved
            KEY_READ,                   // security access mask
            &hKey                               // address of handle of open key
            );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
    return FALSE;

    cbPath = sizeof(chPath);
    type = REG_SZ;
    err = RegQueryValueEx(
            hKey,                   // handle of key to query
            REGKEY_INSTALLKEY,  // address of name of value to query
            NULL,                   // reserved
            &type,                  // address of buffer for value type
            (PUCHAR)chPath,         // address of data buffer
            &cbPath             // address of data buffer size
            );

    // close the key
    RegCloseKey( hKey );

    // if we did get the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // add on the file name
    if (strPath.Copy(chPath)) {
        if (strPath.Append("\\inetinfo.exe")) {
            // and do it to it!
            ULONG_PTR res = (ULONG_PTR)ShellExecute(
                NULL,           // handle to parent window
                NULL,           // pointer to string that specifies operation to perform
                strPath.QueryStr(),                 // pointer to filename or folder name string
                "-e w3svc", // pointer to string that specifies executable-file parameters
                NULL,           // pointer to string that specifies default directory
                SW_HIDE             // whether file is shown when opened
               );

            return ( res > 32 );
        }
    }

    return FALSE;
}

//------------------------------------------------------------------------
BOOL
W95ShutdownW3SVC(
    VOID
    )
{
    HANDLE hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, "Inet_shutdown");

    if ( hEvent == NULL ) {
        return TRUE;    // not there
    }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
        SetEvent( hEvent );
    }

    CloseHandle(hEvent);
    return TRUE;
}

//------------------------------------------------------------------------
BOOL
W95ShutdownIISADMIN(
    VOID
    )
{
    DWORD i;
    HANDLE hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, IIS_AS_EXE_OBJECT_NAME);

    if ( hEvent == NULL ) {
        return(TRUE);
    }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
        SetEvent( hEvent );
    }

    CloseHandle(hEvent);

    for (i=0; i < 20; i++) {

        hEvent = CreateEvent(NULL, TRUE, FALSE, IIS_AS_EXE_OBJECT_NAME);
        if ( hEvent != NULL ) {
            DWORD err = GetLastError();
            CloseHandle(hEvent);

            if ( err == ERROR_ALREADY_EXISTS ) {
                Sleep(500);
                continue;
            }
        }

        break;
    }

    return(TRUE);
}

//------------------------------------------------------------------------
BOOL
IsIISAdminRunning(
    VOID
    )
{
    HANDLE hEvent;
    BOOL fFound = FALSE;

    hEvent = CreateEvent(NULL, TRUE, FALSE, IIS_AS_EXE_OBJECT_NAME);

    if ( hEvent != NULL ) {
        fFound = (GetLastError() == ERROR_ALREADY_EXISTS);
        CloseHandle(hEvent);
    }

    return(fFound);
}

//------------------------------------------------------------------------
BOOL
IsInetinfoRunning(
    VOID
    )
{
    HANDLE hEvent;
    BOOL fFound = FALSE;

    hEvent = CreateEvent(NULL, TRUE, FALSE, PWS_SHUTDOWN_EVENT);

    if ( hEvent != NULL ) {
        fFound = (GetLastError() == ERROR_ALREADY_EXISTS);
        CloseHandle(hEvent);
    }
    return(fFound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\dllmain.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\dllmain.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\gip.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\gip.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\datetime.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\datetime.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\irtldbg.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\irtldbg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\ipsupp.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\ipsupp.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\hashtab.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\hashtab.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\mlszau.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\mlszau.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\multisz.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\multisz.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\isplat.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\isplat.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\lkrhash.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\lkrhash.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\isutils.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\isutils.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\reftrace.c ===
#include "..\iisrtl\reftrace.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\pudebug.c ===
#include "..\iisrtl\pudebug.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\locks.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\locks.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\misc.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\misc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\madel.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\madel.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\stktrace.c ===
#include "..\iisrtl\stktrace.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\string.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\string.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\manodel.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\manodel.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\stringau.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\stringau.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\perfutil.c ===
#include "..\iisrtl\perfutil.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\resource.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\resource.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\tracelog.c ===
#include "..\iisrtl\tracelog.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\rpcutil.c ===
#include "..\iisrtl\rpcutil.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\sched.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\sched.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\strlog.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\strlog.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\swmrg.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\swmrg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\sharelok.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\sharelok.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\win32obj.c ===
#include "..\iisrtl\win32obj.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\i386\xcptmisc.asm ===
include ..\iisrtl\i386\xcptmisc.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\timer.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\timer.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\kisrtl\strings.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\strings.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\cmdline\dcomperm.cpp ===
#include "..\serv\dcomperm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\cmdline\lbhlp.cxx ===
#include "..\serv\boot.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\driver\iisnatio.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    iisnatio.h

Abstract:

    This module declare IIS NAT IOCTL

Author:

    Philippe Choquier ( phillich )

--*/

#if !defined(_IISNATIO_INCLUDED)

#define IOCTL_IISNATIO_SET_CONFIG CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0800, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\cmdline\iisrc.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    iisrc.h

Abstract:

    Resource declaration for iislbc

Author:

    Philippe Choquier (phillich)

--*/

#if !defined(_IICRC_DEFINED)
#define _IICRC_DEFINED

#define IDS_LBC_COPYRIGHT	100
#define IDS_LBC_HELP		101
#define IDS_LBC_IPE         102
#define IDS_LBC_IPM         103
#define IDS_LBC_PM          104
#define IDS_LBC_ST          105
#define IDS_LBC_SP          106

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\cmdline\iislbc.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    iislbc.cxx

Abstract:

    Command line utility to set/get IIS load balancing configuration

Author:

    Philippe Choquier (phillich)

--*/

//#define INITGUID
extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

#include <windows.h>
#include <winsock2.h>
#include <stdlib.h>
#include <time.h>

#include <ipnat.h>

#if 0
typedef NTSTATUS
(*PNAT_REGISTER_SESSION_CONTROL)(
    IN  ULONG   Version
    );

typedef NTSTATUS
(*PNAT_IOCTL_SESSION_CONTROL)(
    IN  PIRP    Irp
    );
#endif

}

#include    <stdio.h>
#include    <ole2.h>
#include    <pdh.h>

#include <IisLb.h>
#include <lbxbf.hxx>
#include <lbcnfg.hxx>
#include <IisLbs.hxx>
#include <bootexp.hxx>

#include "iisrc.h"

//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))


#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))

enum LB_CMD {
    CMD_NONE,
    CMD_ADD_SERVER,
    CMD_ADD_IP,
    CMD_ADD_PERFMON,
    CMD_DEL_SERVER,
    CMD_DEL_IP,
    CMD_DEL_PERFMON,
#if 0
    CMD_SET_STICKY,
#endif
    CMD_SET_IP,
    CMD_LIST,
    CMD_LIST_IP_ENDPOINTS,
    CMD_START_DRIVER,
    CMD_STOP_DRIVER,
} ;

#define LEN_SERVER_NAME     16
#define LEN_IP              (4*3+3+1+3)
#define LEN_PERF            40

extern CKernelIpMapHelper       g_KernelIpMap;
extern WSADATA                  g_WSAData;

BOOL
LocatePerfCounter( 
    CComputerPerfCounters*  pPerfCounters, 
    LPWSTR                  pszSrv, 
    LPWSTR                  pszParam, 
    UINT*                   piPerfCounter
    )
{
    UINT    i;
    LPWSTR  pszS;
    LPWSTR  psz;
    DWORD   dw;

    if ( pszSrv && (*pszSrv == L'\0' || !wcscmp(pszSrv,L"*")) )
    {
        pszSrv = NULL;
    }

    for ( i = 0 ;
          pPerfCounters->EnumPerfCounter( i, &pszS, &psz, &dw ) ;
          ++i )
    {
        if ( ((pszS == NULL) == (pszSrv==NULL)) &&
             !_wcsicmp( psz, pszParam ) )
        {
            *piPerfCounter = i;
            return TRUE;
        }
    }

    SetLastError( ERROR_INVALID_PARAMETER );

    return FALSE;    
}


BOOL
LocateServer( 
    CIPMap*     IpMap, 
    LPWSTR      pszParam, 
    UINT*       piServer 
    )
{
    UINT    i;
    LPWSTR  psz;


    for ( i = 0 ;
          IpMap->EnumComputer( i, &psz ) ;
          ++ i )
    {
        if ( !_wcsicmp( psz, pszParam ) )
        {
            *piServer = i;
            return TRUE;
        }
    }

    SetLastError( ERROR_INVALID_PARAMETER );

    return FALSE;    
}


BOOL
LocatePublicIp( 
    CIPMap*     IpMap, 
    LPWSTR      pszParam, 
    UINT*       piRes 
    )
{
    UINT    i;
    LPWSTR  psz;
    LPWSTR  pszName;
    DWORD   dwSticky;
    DWORD   dwAttr;


    for ( i = 0 ;
          IpMap->EnumIpPublic( i, &psz, &pszName, &dwSticky, &dwAttr ) ;
          ++i )
    {
        if ( !_wcsicmp( psz, pszParam ) )
        {
            *piRes = i;
            return TRUE;
        }
    }

    SetLastError( ERROR_INVALID_PARAMETER );

    return FALSE;    
}


VOID
DisplayErrorMessage(
    DWORD   dwErr
    )
{
    LPWSTR   pErr;

    if ( FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPWSTR)&pErr,
            0,
            NULL ) )
    {
        LPWSTR   p;

        if ( p = wcschr( pErr, L'\r' ) )
        {
            *p = L'\0';
        }
        fputws( pErr, stdout );

        LocalFree( pErr );
    }
}


BOOL
ChooseCounter(
    LPWSTR  pszCounterBuffer
    )
{
    PDH_BROWSE_DLG_CONFIG_W BrowseInfo;
    PDH_STATUS              pdhStatus;
    LPWSTR                  pszPostServerName;
    WCHAR                   achSelect[128];

    if ( !LoadStringW( NULL, IDS_LBC_SP, achSelect, sizeof(achSelect) ) )
    {
        achSelect[0] = L'\0';
    }

#if defined(_X86_) && 0
    __asm int 3
#endif

    BrowseInfo.bIncludeInstanceIndex = FALSE;
    BrowseInfo.bSingleCounterPerAdd = TRUE;
    BrowseInfo.bSingleCounterPerDialog = TRUE;
    BrowseInfo.bLocalCountersOnly = FALSE;
    BrowseInfo.bWildCardInstances = FALSE;
    BrowseInfo.bHideDetailBox = FALSE;
    BrowseInfo.bInitializePath = FALSE;
    BrowseInfo.bDisableMachineSelection = FALSE;
    BrowseInfo.bIncludeCostlyObjects = TRUE;

    BrowseInfo.hWndOwner = GetActiveWindow();
    BrowseInfo.szDataSource = NULL;
    BrowseInfo.szReturnPathBuffer = pszCounterBuffer;
    BrowseInfo.cchReturnPathLength = MAX_PATH;
    BrowseInfo.pCallBack = NULL;
    BrowseInfo.dwCallBackArg = 0;
    BrowseInfo.CallBackStatus = ERROR_SUCCESS;
    BrowseInfo.dwDefaultDetailLevel = PERF_DETAIL_WIZARD;
    BrowseInfo.szDialogBoxCaption = achSelect;

    if ( PdhBrowseCountersW (&BrowseInfo) == ERROR_SUCCESS )
    {
        if ( !memcmp( pszCounterBuffer, L"\\\\", 2*sizeof(WCHAR) ) &&
             (pszPostServerName = wcschr( pszCounterBuffer+2, L'\\' )) )
        {
            memmove( pszCounterBuffer, pszPostServerName, (wcslen(pszPostServerName)+1)*sizeof(WCHAR) );
        }

        return TRUE;
    }

    return FALSE;
}

#if 0

VOID
TestDriver(
    )
{
    HMODULE                         hMod;
    PNAT_REGISTER_SESSION_CONTROL   pfnNatRegisterSessionControl;
    PNAT_IOCTL_SESSION_CONTROL      pfnNatIoctlSessionControl;
    PNAT_DIRECTOR_QUERY_SESSION     pfnNatQuerySessionControl;
    IRP                             Irp;
    ULONG                           PrivateAddr;
    USHORT                          PrivatePort;
    ULONG                           PublicAddr;
    USHORT                          PublicPort;
    ULONG                           RemoteAddr;
    USHORT                          RemotePort;
    CKernelServerDescription*       pS;
    UINT                            iS;
    UINT                            iP;
    IO_STACK_LOCATION               IrpSp;
    LPVOID                          pv;

#if 0    
    UINT    x;
    UINT    c;
    UINT    f;
    UINT    y;

    for ( c = 0, x = 2 ; x < 1000 ; ++x )
    {
        f = TRUE;
        for ( y = 2 ; y * y < x ; ++y )
        {
            if ( x % y == 0 )
            {
                f = FALSE;
                break;
            }
        }
        if ( f )
        {
            wprintf( L"%d\t", x );
            if ( (++c & 7) == 7 )
            {
                wprintf(L"\n");
            }
        }
    }
#endif

    if ( (hMod = LoadLibraryW( L"iislbdr.dll" )) )
    {
        pfnNatRegisterSessionControl = (PNAT_REGISTER_SESSION_CONTROL)GetProcAddress( hMod, 
                "NatRegisterSessionControl" );
        pfnNatIoctlSessionControl = (PNAT_IOCTL_SESSION_CONTROL)GetProcAddress( hMod, 
                "NatIoctlSessionControl" );
        pfnNatQuerySessionControl = (PNAT_DIRECTOR_QUERY_SESSION)GetProcAddress( hMod, 
                "NatQuerySessionControl" );

        if ( pfnNatRegisterSessionControl &&
             pfnNatIoctlSessionControl &&
             pfnNatQuerySessionControl )
        {
            if ( WSAStartup( MAKEWORD( 2, 0), &g_WSAData ) == 0 &&
                 InitGlobals() )
            {
                PublicAddr = 0x04030201;
                PublicPort = 0x5000;
                RemoteAddr = 0x0f0f0f0f;
                RemotePort = 0xf000;

                pfnNatRegisterSessionControl( 1 );

                for ( iS = 0;
                      iS < g_KernelIpMap.ServerCount() ;
                      ++iS )
                {
                    pS = g_KernelIpMap.GetServerPtr( iS );
                    pS->m_dwLoadAvail = 100;
                    pS->m_LoadbalancedLoadAvail = pS->m_dwLoadAvail;
                }

                // refcount set to != 0

                for ( iP = 0;
                      iP < g_KernelIpMap.PrivateIpCount() ;
                      ++iP )
                {
                    g_KernelIpMap.GetPrivateIpEndpoint( iP )->m_dwIndex = 1;
                }

#if defined(_X86_)
    __asm int 3
#endif
                g_KernelIpMap.GetPublicIpPtr( 0 )->m_dwNotifyPort = 0x5000;
                g_KernelIpMap.GetPublicIpPtr( 0 )->m_usUniquePort = 0x5000;
                IoGetCurrentIrpStackLocation( &Irp ) = &IrpSp;
                IrpSp.Parameters.DeviceIoControl.InputBufferLength = g_KernelIpMap.GetSize();
                Irp.AssociatedIrp.SystemBuffer = g_KernelIpMap.GetBuffer();
                pfnNatIoctlSessionControl( &Irp );
                pfnNatIoctlSessionControl( &Irp );

                pfnNatQuerySessionControl( NULL, NAT_PROTOCOL_TCP,
                    PublicAddr, PublicPort,
                    RemoteAddr, RemotePort,
                    &PrivateAddr, &PrivatePort,
                    &pv  );

                // test cache

                pfnNatQuerySessionControl( NULL, NAT_PROTOCOL_TCP,
                    PublicAddr, PublicPort,
                    RemoteAddr, RemotePort,
                    &PrivateAddr, &PrivatePort,
                    &pv );

                // test new public IP addr

                PublicAddr = 0x05030201;
                PublicPort = 0x5000;
                pfnNatQuerySessionControl( NULL, NAT_PROTOCOL_TCP,
                    PublicAddr, PublicPort,
                    RemoteAddr, RemotePort,
                    &PrivateAddr, &PrivatePort,
                    &pv );

                // test invalid public IP addr

                PublicAddr = 0xff030201;
                PublicPort = 0x5000;
                pfnNatQuerySessionControl( NULL, NAT_PROTOCOL_TCP,
                    PublicAddr, PublicPort,
                    RemoteAddr, RemotePort,
                    &PrivateAddr, &PrivatePort,
                    &pv );

                pfnNatIoctlSessionControl( &Irp );
            }

            TerminateGlobals();
        }
        else 
        {
            DisplayErrorMessage( GetLastError() );
        }

        FreeLibrary( hMod );
    }
    else 
    {
        DisplayErrorMessage( GetLastError() );
    }
}

#endif

BYTE    abSerialized[32768];

#define RC_BUFF achMsg
#define RC_PRINTF(a,b) if ( LoadStringW( NULL, a, achMsg, sizeof(achMsg) ) ) wprintf b;

LPWSTR
ToUnicode(
    LPSTR   psz
    )
{
    LPWSTR   ps = (LPWSTR)LocalAlloc( LMEM_FIXED, (strlen(psz)+1)*sizeof(WCHAR) );

    if ( ps )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   psz,
                                   -1,
                                   ps,
                                   (strlen(psz)+1) ) )
        {
            *ps = L'\0';
        }

        return ps;
    }

    return L"";
}


int __cdecl main( 
    int     argc, 
    CHAR*   argv[] 
    )
{
    int                     Status = 0;
    HRESULT                 hRes;
    LPSTR                   pszMachineName = NULL;
    COSERVERINFO            csiMachineName;
    MULTI_QI                rgmq;
    IClassFactory*          pcsfFactory = NULL;
    IMSIisLb*               pIisLb = NULL;
    WCHAR                   awchComputer[64];
    CIPMap                  IpMap;
    CComputerPerfCounters   PerfCounters;
    CIpEndpointList         IpEndpoints;
    DWORD                   dwSticky;
    DWORD                   dwReq;
    LPBYTE                  pbSerialized;
    int                     arg;
    int                     cParam;
    LPWSTR                  apszParam[16];
    LB_CMD                  iCmd = CMD_NONE;
    BOOL                    fUpdateIpMap = FALSE;
    BOOL                    fUpdatePerfCounters = FALSE;
    BOOL                    fUpdateSticky = FALSE;
    UINT                    iServer;
    UINT                    iPublicIp;
    UINT                    iPerfCounter;
    XBF                     xbf;
    LPWSTR                  pszPublicIp;
    LPWSTR                  pszPrivateIp;
    LPWSTR                  pszServer;
    LPWSTR                  pszName;
    LPWSTR                  pszPerfCounter;
    DWORD                   dwWeight;
    WCHAR                   achCounterBuffer[MAX_PATH];
    WCHAR                   achMsg[1024];
    DWORD                   dwAttr;

    if ( argc < 2 )
    {
        RC_PRINTF( IDS_LBC_HELP, (RC_BUFF) );

        return 3;
    }
    else
    {
        RC_PRINTF( IDS_LBC_COPYRIGHT, (RC_BUFF) );
    }

    cParam = 0;

    for ( arg = 1 ; arg < argc ; ++arg )
    {
        if ( argv[arg][0] == '-' )
        {
            switch ( argv[arg][1] )
            {
                case 'm':
                    pszMachineName = argv[arg]+2;
                    break;

                case 'a':
                    switch ( argv[arg][2] )
                    {
                        case 's':
                            iCmd = CMD_ADD_SERVER; break;
                        case 'i':
                            iCmd = CMD_ADD_IP; break;
                        case 'p':
                            iCmd = CMD_ADD_PERFMON; break;
                    }
                    break;

                case 'd':
                    switch ( argv[arg][2] )
                    {
                        case 's':
                            iCmd = CMD_DEL_SERVER; break;
                        case 'i':
                            iCmd = CMD_DEL_IP; break;
                        case 'p':
                            iCmd = CMD_DEL_PERFMON; break;
                    }
                    break;

                case 's':
                    switch ( argv[arg][2] )
                    {
#if 0
                        case 's':
                            iCmd = CMD_SET_STICKY; break;
#endif
                        case 'i':
                            iCmd = CMD_SET_IP; break;
                    }
                    break;

                case 'l':
                    switch ( argv[arg][2] )
                    {
                        case 'e':
                            iCmd = CMD_LIST_IP_ENDPOINTS; break;
                        case 'c':
                            iCmd = CMD_LIST;
                    }
                    break;

#if 0
                case 't':
                    TestDriver();
                    return 0;
#endif

                case '0':
                    iCmd = CMD_STOP_DRIVER;
                    break;

                case '1':
                    iCmd = CMD_START_DRIVER;
                    break;
            }
        }
        else if ( cParam < sizeof(apszParam)/sizeof(LPWSTR) )
        {
            apszParam[cParam++] = ToUnicode( argv[arg] );
        }
    }

    //fill the structure for CoCreateInstanceEx
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );

    if ( pszMachineName )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   pszMachineName,
                                   -1,
                                   awchComputer,
                                   sizeof(awchComputer) ) )
        {
            return FALSE;
        }

        csiMachineName.pwszName =  awchComputer;
    }
    else
    {
        csiMachineName.pwszName =  NULL;
    }

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

#if 0
    hRes = CoGetClassObject(CLSID_MSIisLb, CLSCTX_SERVER, &csiMachineName,
                            IID_IClassFactory, (void**) &pcsfFactory);

    if ( SUCCEEDED( hRes ) )
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSIisLb, (void **) &rgmq.pItf);

        if ( SUCCEEDED( hRes ) )
#else
    if ( 1 )
    {
        rgmq.pIID = &IID_IMSIisLb;
        rgmq.hr = 0;
        rgmq.pItf = NULL;
        hRes = CoCreateInstanceEx( CLSID_MSIisLb, NULL, CLSCTX_SERVER, &csiMachineName, 1, &rgmq );

        if ( SUCCEEDED( hRes ) && SUCCEEDED( rgmq.hr ) )
#endif
        {
            pIisLb = (IMSIisLb*)rgmq.pItf;

            // get current configuration

            if ( SUCCEEDED( hRes = pIisLb->GetIpList( sizeof(abSerialized), abSerialized, &dwReq ) ) )
            {
                pbSerialized = abSerialized;
                hRes = IpMap.Unserialize( &pbSerialized, &dwReq ) ? S_OK : RETURNCODETOHRESULT(ERROR_BAD_CONFIGURATION);
            }

            if ( SUCCEEDED( hRes ) &&
                 SUCCEEDED( hRes = pIisLb->GetPerfmonCounters( sizeof(abSerialized), abSerialized, &dwReq ) ) )
            {
                pbSerialized = abSerialized;
                hRes = PerfCounters.Unserialize( &pbSerialized, &dwReq ) ? S_OK : RETURNCODETOHRESULT(ERROR_BAD_CONFIGURATION);
            }

#if 0
            if ( SUCCEEDED( hRes ) )
            {
                hRes = pIisLb->GetStickyDuration( &dwSticky );
            }
#endif

            if ( SUCCEEDED( hRes ) &&
                 SUCCEEDED( hRes = pIisLb->GetIpEndpointList( sizeof(abSerialized), abSerialized, &dwReq ) ) )
            {
                pbSerialized = abSerialized;
                hRes = IpEndpoints.Unserialize( &pbSerialized, &dwReq ) ? S_OK : RETURNCODETOHRESULT(ERROR_BAD_CONFIGURATION);
            }

            if ( FAILED(hRes) )
            {
                pIisLb->Release();
            }
        }
#if 0
        pcsfFactory->Release();
#endif
    }

    if ( SUCCEEDED( hRes ) )
    {
        switch ( iCmd )
        {
            case CMD_START_DRIVER:
                hRes = pIisLb->SetDriverState( SERVICE_RUNNING );
                break;

            case CMD_STOP_DRIVER:
                hRes = pIisLb->SetDriverState( SERVICE_STOPPED );
                break;

            case CMD_ADD_SERVER:
                if ( cParam == 1 &&
                     IpMap.AddComputer( apszParam[0] ) )
                {
                    fUpdateIpMap = TRUE;
                }
                else
                {
                    hRes = RETURNCODETOHRESULT(GetLastError());
                }
                break;

            case CMD_ADD_IP:
                if ( cParam == 3 &&
                     IpMap.AddIpPublic( apszParam[0], apszParam[1], _wtoi(apszParam[2]), 0 ) )
                {
                    fUpdateIpMap = TRUE;
                }
                else
                {
                    hRes = RETURNCODETOHRESULT(GetLastError());
                }
                break;

            case CMD_ADD_PERFMON:
                if ( cParam >= 2 &&
                    !wcscmp( apszParam[1], L"*" ) )
                {
                    if ( ChooseCounter( achCounterBuffer ) )
                    {
                        apszParam[1] = achCounterBuffer;
                    }
                    else
                    {
                        cParam = 0;
                    }
                }
                // server name : * for all
                if ( cParam >= 1 &&
                    !wcscmp( apszParam[0], L"*" ) )
                {
                    apszParam[0] = NULL;
                }
                if ( cParam == 3 &&
                     PerfCounters.AddPerfCounter( apszParam[0], apszParam[1], _wtoi(apszParam[2]) ) )
                {
                    fUpdatePerfCounters = TRUE;
                }
                else
                {
                    hRes = RETURNCODETOHRESULT(GetLastError());
                }
                break;

            case CMD_DEL_SERVER:
                if ( cParam == 1 &&
                     LocateServer( &IpMap, apszParam[0], &iServer ) )
                {
                    if ( IpMap.DeleteComputer( iServer ) )
                    {
                        fUpdateIpMap = TRUE;
                    }
                    else
                    {
                        hRes = RETURNCODETOHRESULT( GetLastError() );
                    }
                }
                else
                {
                    hRes = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
                }
                break;

            case CMD_DEL_IP:
                if ( cParam == 1 &&
                     LocatePublicIp( &IpMap, apszParam[0], &iPublicIp ) )
                {
                    if ( IpMap.DeleteIpPublic( iPublicIp ) )
                    {
                        fUpdateIpMap = TRUE;
                    }
                    else
                    {
                        hRes = RETURNCODETOHRESULT( GetLastError() );
                    }
                }
                else
                {
                    hRes = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
                }
                break;

            case CMD_DEL_PERFMON:
                if ( cParam == 2 &&
                     LocatePerfCounter( &PerfCounters, apszParam[0], apszParam[1], &iPerfCounter ) )
                {
                    if ( PerfCounters.DeletePerfCounter( iPerfCounter ) )
                    {
                        fUpdatePerfCounters = TRUE;
                    }
                    else
                    {
                        hRes = RETURNCODETOHRESULT( GetLastError() );
                    }
                }
                else
                {
                    hRes = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
                }
                break;

#if 0
            case CMD_SET_STICKY:
                if ( cParam == 1 )
                {
                    dwSticky = _wtoi( apszParam[0] );
                    fUpdateSticky = TRUE;
                }
                else
                {
                    hRes = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
                }
                break;
#endif

            case CMD_SET_IP:
                if ( cParam == 4 &&
                     LocateServer( &IpMap, apszParam[0], &iServer ) &&
                     LocatePublicIp( &IpMap, apszParam[1], &iPublicIp ) )
                {
                    if ( IpMap.SetIpPrivate( iServer, iPublicIp, apszParam[2], apszParam[3] ) )
                    {
                        fUpdateIpMap = TRUE;
                    }
                    else
                    {
                        hRes = RETURNCODETOHRESULT( GetLastError() );
                    }
                }
                else
                {
                    hRes = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
                }
                break;

            case CMD_LIST_IP_ENDPOINTS:
                RC_PRINTF( IDS_LBC_IPE, (RC_BUFF) );
                for ( iPublicIp = 0 ;
                      IpEndpoints.EnumIpEndpoint( iPublicIp, &pszPublicIp ) ;
                      ++iPublicIp )
                {
                    wprintf( L"%-*.*s\t", LEN_IP, LEN_IP, pszPublicIp );
                }
                wprintf( L"\n");
                break;

            case CMD_LIST:
                RC_PRINTF( IDS_LBC_IPM, (RC_BUFF, LEN_SERVER_NAME, LEN_SERVER_NAME, "") );
                for ( iPublicIp = 0 ;
                      IpMap.EnumIpPublic( iPublicIp, &pszPublicIp, &pszName, &dwSticky, &dwAttr ) ;
                      ++iPublicIp )
                {
                    wprintf( L"%-*.*s\t", LEN_IP, LEN_IP, pszPublicIp );
                }
                wprintf( L"\n");

                for ( iServer = 0 ;
                      IpMap.EnumComputer( iServer, &pszServer ) ;
                      ++iServer )
                {
                    wprintf( L"%-*.*s\t", LEN_SERVER_NAME, LEN_SERVER_NAME, pszServer );
                    for ( iPublicIp = 0 ;
                          IpMap.EnumIpPublic( iPublicIp, &pszPublicIp, &pszName, &dwSticky, &dwAttr ) ;
                          ++iPublicIp )
                    {
                        IpMap.GetIpPrivate( iServer, iPublicIp, &pszPrivateIp, &pszName );
                        wprintf( L"%-*.*s\t", LEN_IP, LEN_IP, pszPrivateIp );
                    }
                    wprintf( L"\n");
                }
                wprintf( L"\n");

                RC_PRINTF( IDS_LBC_PM, (RC_BUFF) );
                for ( iPerfCounter = 0 ;
                      PerfCounters.EnumPerfCounter( iPerfCounter, &pszServer, &pszPerfCounter, &dwWeight ) ;
                      ++iPerfCounter )
                {
                    wprintf( L"%-*.*s%-*.*s\t%u\n", 
                            LEN_SERVER_NAME, LEN_SERVER_NAME, pszServer ? pszServer : L"*", 
                            LEN_PERF, LEN_PERF, pszPerfCounter, 
                            dwWeight );
                }
                wprintf( L"\n");
#if 0
                RC_PRINTF( IDS_LBC_ST, (RC_BUFF, dwSticky) );
#endif
                break;
        }

        // update configuration

        if ( SUCCEEDED( hRes ) &&
             fUpdateIpMap &&
             (xbf.Reset, IpMap.Serialize( &xbf )) )
        {
            hRes = pIisLb->SetIpList( xbf.GetUsed(), xbf.GetBuff() );
        }

        if ( SUCCEEDED( hRes ) &&
             fUpdatePerfCounters &&
             (xbf.Reset, PerfCounters.Serialize( &xbf )) )
        {
            hRes = pIisLb->SetPerfmonCounters( xbf.GetUsed(), xbf.GetBuff() );
        }

#if 0
        if ( SUCCEEDED( hRes ) &&
             fUpdateSticky )
        {
            hRes = pIisLb->SetStickyDuration( dwSticky );
        }
#endif

        pIisLb->Release();
    }

    if ( FAILED( hRes ) )
    {
        DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
    }

    CoUninitialize();

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\cnfg\xbf.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    xbf.cxx

Abstract:

    Classes to handle extensible buffers

Author:

    Philippe Choquier (phillich)    17-oct-1996

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <mbstring.h>

#include "lbxbf.hxx"

//
// Global functions
//

BOOL 
Unserialize( 
    LPBYTE* ppB, 
    LPDWORD pC, 
    LPDWORD pU 
    )
/*++

Routine Description:

    Unserialize a DWORD
    pU is updated with DWORD from *ppB, ppB & pC are updated

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer
    pU - ptr to DWORD where to unserialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( *pC >= sizeof( DWORD ) )
    {
        *pU = *(DWORD UNALIGNED*)*ppB;
        *ppB += sizeof(DWORD);
        *pC -= sizeof(DWORD);
        return TRUE;
    }

    return FALSE;
}


BOOL 
Unserialize( 
    LPBYTE* ppB, 
    LPDWORD pC, 
    LPBOOL pU 
    )
/*++

Routine Description:

    Unserialize a BOOL
    pU is updated with BOOL from *ppB, ppB & pC are updated

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer
    pU - ptr to BOOL where to unserialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( *pC >= sizeof( BOOL ) )
    {
        *pU = *(BOOL UNALIGNED*)*ppB;
        *ppB += sizeof(BOOL);
        *pC -= sizeof(BOOL);
        return TRUE;
    }

    return FALSE;
}


//
// Extensible buffer class
//

BOOL 
CStoreXBF::Need( 
    DWORD dwNeed 
    )
/*++

Routine Description:

    Insure that CStoreXBF can store at least dwNeed bytes
    including bytes already stored.

Arguments:

    dwNeed - minimum of bytes available for storage

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( dwNeed > m_cAllocBuff )
    {
        dwNeed = ((dwNeed + m_cGrain)/m_cGrain)*m_cGrain;
        LPBYTE pN = (LPBYTE)LocalAlloc( LMEM_FIXED, dwNeed );
        if ( pN == NULL )
        {
            return FALSE;
        }
        if ( m_cUsedBuff )
        {
            memcpy( pN, m_pBuff, m_cUsedBuff );
        }
        m_cAllocBuff = dwNeed;
        LocalFree( m_pBuff );
        m_pBuff = pN;
    }
    return TRUE;
}

BOOL 
CStoreXBF::Save( 
    HANDLE hFile 
    )
/*++

Routine Description:

    Save to file

Arguments:

    hFile - file handle

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD dwWritten;

    return WriteFile( hFile, GetBuff(), GetUsed(), &dwWritten, NULL ) &&
           dwWritten == GetUsed();
}


BOOL 
CStoreXBF::Load( 
    HANDLE hFile 
    )
/*++

Routine Description:

    Load from file

Arguments:

    hFile - file handle

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD   dwS = GetFileSize( hFile, NULL );
    DWORD   dwRead;

    if ( dwS != 0xffffffff &&
         Need( dwS ) &&
         ReadFile( hFile, GetBuff(), dwS, &dwRead, NULL ) &&
         dwRead == dwS )
    {
        m_cUsedBuff = dwRead;

        return TRUE;
    }

    m_cUsedBuff = 0;

    return FALSE;
}



BOOL 
Serialize( 
    CStoreXBF* pX, 
    DWORD dw 
    )
/*++

Routine Description:

    Serialize a DWORD in CStoreXBF

Arguments:

    pX - ptr to CStoreXBF where to add serialized DWORD
    dw - DWORD to serialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    return pX->Append( (LPBYTE)&dw, sizeof(dw) );
}


BOOL 
Serialize( 
    CStoreXBF* pX, 
    BOOL f 
    )
/*++

Routine Description:

    Serialize a BOOL in CStoreXBF

Arguments:

    pX - ptr to CStoreXBF where to add serialized BOOL
    f - BOOL to serialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    return pX->Append( (LPBYTE)&f, sizeof(f) );
}


DWORD 
CPtrXBF::AddPtr( 
    LPVOID pV
    )
/*++

Routine Description:

    Add a ptr to array

Arguments:

    pV - ptr to be added at end of array

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{ 
    DWORD i = GetNbPtr();
    if ( Append( (LPBYTE)&pV, sizeof(pV)) )
    {
        return i;
    }
    return INDEX_ERROR;
}


DWORD 
CPtrXBF::InsertPtr( 
    DWORD iBefore, 
    LPVOID pV 
    )
/*++

Routine Description:

    Insert a ptr to array

Arguments:

    iBefore - index where to insert entry, or 0xffffffff if add to array
    pV - ptr to be inserted

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    if ( iBefore == INDEX_ERROR || iBefore >= GetNbPtr() )
    {
        return AddPtr( pV );
    }
    if ( AddPtr( NULL ) != INDEX_ERROR )
    {
        memmove( GetBuff()+(iBefore+1)*sizeof(LPVOID), 
                 GetBuff()+iBefore*sizeof(LPVOID),
                 GetUsed()-(iBefore+1)*sizeof(LPVOID) );

        SetPtr( iBefore, pV );

        return iBefore;
    }
    return INDEX_ERROR;
}


BOOL 
CPtrXBF::DeletePtr( 
    DWORD i 
    )
/*++

Routine Description:

    Delete a ptr from array

Arguments:

    i - index of ptr to delete

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    memmove( GetBuff()+i*sizeof(LPVOID), 
             GetBuff()+(i+1)*sizeof(LPVOID),
             GetUsed()-(i+1)*sizeof(LPVOID) );

    DecreaseUse( sizeof(LPVOID) );

    return TRUE;
}


BOOL 
CPtrXBF::Unserialize( 
    LPBYTE* ppB, 
    LPDWORD pC, 
    DWORD cNbEntry 
    )
/*++

Routine Description:

    Unserialize a ptr array

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer
    cNbEntry - # of ptr to unserialize from buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    Reset();
    if ( *pC >= cNbEntry * sizeof(LPVOID) &&
         Append( *ppB, cNbEntry * sizeof(LPVOID) ) )
    {
        *ppB += cNbEntry * sizeof(LPVOID);
        *pC -= cNbEntry * sizeof(LPVOID);

        return TRUE;
    }

    return FALSE;
}


BOOL 
CPtrXBF::Serialize( 
    CStoreXBF* pX 
    )
/*++

Routine Description:

    Serialize a ptr array

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return pX->Append( (LPBYTE)GetBuff(), (DWORD)GetUsed() );
}


BOOL 
CAllocString::Set( 
    LPWSTR pS 
    )
/*++

Routine Description:

    Set a string content, freeing prior content if any

Arguments:

    pS - string to copy

Return Value:

    TRUE if successful, FALSE on error

--*/
{ 
    size_t l;
    Reset(); 
    if ( m_pStr = (LPWSTR)LocalAlloc( LMEM_FIXED, l = (wcslen(pS)+1)*sizeof(WCHAR) ) )
    {
        memcpy( m_pStr, pS, l );

        return TRUE;
    }
    return FALSE;
}


BOOL 
CAllocString::Append( 
    LPWSTR pS 
    )
/*++

Routine Description:

    Append a string content

Arguments:

    pS - string to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{ 
    size_t l = m_pStr ? wcslen(m_pStr )*sizeof(WCHAR) : 0;
    size_t nl;
    LPWSTR pStr;

    if ( pStr = (LPWSTR)LocalAlloc( LMEM_FIXED, l + (nl = (wcslen(pS)+1)*sizeof(WCHAR) )) )
    {
        memcpy( pStr, m_pStr, l );
        memcpy( pStr+l/sizeof(WCHAR), pS, nl );

        m_pStr = pStr;

        return TRUE;
    }
    return FALSE;
}


BOOL 
CAllocString::Unserialize( 
    LPBYTE* ppb, 
    LPDWORD pc 
    )
/*++

Routine Description:

    Unserialize a string

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD   dwL;

    if ( ::Unserialize( ppb, pc, &dwL ) &&
         (m_pStr = (LPWSTR)LocalAlloc( LMEM_FIXED, (dwL + 1) * sizeof(WCHAR))) )
    {
        memcpy( m_pStr, *ppb, dwL*sizeof(WCHAR) );
        m_pStr[dwL] = L'\0';

        *ppb += dwL*sizeof(WCHAR);
        *pc -= dwL*sizeof(WCHAR);

        return TRUE;
    }
    return FALSE;
}


BOOL 
CAllocString::Serialize( 
    CStoreXBF* pX 
    )
/*++

Routine Description:

    Serialize a string

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPWSTR pS = m_pStr ? m_pStr : L"";

    return ::Serialize( pX, (DWORD)wcslen(pS) ) && pX->Append( pS );
}


BOOL 
CBlob::Set( 
    LPBYTE pStr, 
    DWORD cStr 
    )
/*++

Routine Description:

    Store a buffer in a blob object
    buffer is copied inside blob
    blob is reset before copy

Arguments:

    pStr - ptr to buffer to copy
    cStr - length of buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{ 
    Reset(); 

    return InitSet( pStr, cStr);
}


BOOL 
CBlob::InitSet( 
    LPBYTE pStr, 
    DWORD cStr 
    )
/*++

Routine Description:

    Store a buffer in a blob object
    buffer is copied inside blob
    blob is not reset before copy, initial blob content ignored

Arguments:

    pStr - ptr to buffer to copy
    cStr - length of buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_pStr = (LPBYTE)LocalAlloc( LMEM_FIXED, cStr ) )
    {
        memcpy( m_pStr, pStr, cStr );
        m_cStr = cStr;

        return TRUE;
    }
    return FALSE;
}


BOOL 
CBlob::Unserialize( 
    LPBYTE* ppB, 
    LPDWORD pC 
    )
/*++

Routine Description:

    Unserialize a blob

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    Reset();

    if ( ::Unserialize( ppB, pC, &m_cStr ) &&
         *pC >= m_cStr &&
         ( m_pStr = (LPBYTE)LocalAlloc( LMEM_FIXED, m_cStr ) ) )
    {
        memcpy( m_pStr, *ppB, m_cStr );

        *ppB += m_cStr;
        *pC -= m_cStr;
    }
    else
    {
        m_cStr = 0;
        return FALSE;
    }

    return TRUE;
}


BOOL 
CBlob::Serialize( 
    CStoreXBF* pX 
    )
/*++

Routine Description:

    Serialize a blob

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return ::Serialize( pX, m_cStr ) &&
           pX->Append( m_pStr, m_cStr );
}


CStrPtrXBF::~CStrPtrXBF(
    )
/*++

Routine Description:

    CStrPtrXBF destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DWORD iM = GetNbPtr();
    UINT i;
    for ( i = 0 ; i < iM ; ++i )
    {
        ((CAllocString*)GetPtrAddr(i))->Reset();
    }
}


DWORD 
CStrPtrXBF::AddEntry( 
    LPWSTR pS 
    )
/*++

Routine Description:

    Add a string to array
    string content is copied in array

Arguments:

    pS - string to be added at end of array

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i;

    if ( (i = AddPtr( NULL )) != INDEX_ERROR )
    {
        return ((CAllocString*)GetPtrAddr(i))->Set( pS ) ? i : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


DWORD 
CStrPtrXBF::InsertEntry( 
    DWORD iBefore, 
    LPWSTR pS 
    )
/*++

Routine Description:

    Insert a string in array
    string content is copied in array

Arguments:

    iBefore - index where to insert entry, or 0xffffffff if add to array
    pS - string to be inserted in array

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i;

    if ( (i = InsertPtr( iBefore, NULL )) != INDEX_ERROR )
    {
        return ((CAllocString*)GetPtrAddr(i))->Set( pS ) ? i : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


BOOL 
CStrPtrXBF::DeleteEntry( 
    DWORD i 
    )
/*++

Routine Description:

    Delete a string from array

Arguments:

    i - index of string to delete

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( i < GetNbPtr() )
    {
        ((CAllocString*)GetPtrAddr(i))->Reset();
        DeletePtr( i );

        return TRUE;
    }
    return FALSE;
}


BOOL 
CStrPtrXBF::Unserialize( 
    LPBYTE* ppB, 
    LPDWORD pC, 
    DWORD cNbEntry 
    )
/*++

Routine Description:

    Unserialize a string array

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer
    cNbEntry - # of entry to unserialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    UINT i;

    Reset();

    CAllocString empty;
    for ( i = 0 ; i < cNbEntry ; ++i )
    {
        if ( !Append( (LPBYTE)&empty, sizeof(empty)) ||
             !((CAllocString*)GetPtrAddr(i))->Unserialize( ppB, pC ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


BOOL 
CStrPtrXBF::Serialize( 
    CStoreXBF* pX 
    )
/*++

Routine Description:

    Serialize a string array

Arguments:

    pX - ptr to CStoreXBF where to add serialized DWORD

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    UINT i;

    for ( i = 0 ; i < GetNbEntry() ; ++i )
    {
        if ( !((CAllocString*)GetPtrAddr(i))->Serialize( pX ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


CBlobXBF::~CBlobXBF(
    )
/*++

Routine Description:

    CBlobXBF destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DWORD iM = GetUsed()/sizeof(CBlob);
    UINT i;
    for ( i = 0 ; i < iM ; ++i )
    {
        GetBlob(i)->Reset();
    }
}


VOID CBlobXBF::Reset(
    )
/*++

Routine Description:

    Reset the blob content to NULL

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DWORD iM = GetUsed()/sizeof(CBlob);
    UINT i;
    for ( i = 0 ; i < iM ; ++i )
    {
        GetBlob(i)->Reset();
    }
    CStoreXBF::Reset();
}


DWORD 
CBlobXBF::AddEntry( 
    LPBYTE pS, 
    DWORD cS 
    )
/*++

Routine Description:

    Add a buffer to blob array
    buffer content is copied in array

Arguments:

    pS - buffer to be added at end of array
    cS - length of buffer

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i = GetNbEntry();

    if ( Append( (LPBYTE)&pS, sizeof(CBlob) ) )
    {
        return GetBlob(i)->InitSet( pS, cS ) ? i : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


DWORD 
CBlobXBF::InsertEntry( 
    DWORD   iBefore, 
    LPBYTE  pS, 
    DWORD   cS 
    )
/*++

Routine Description:

    Insert a buffer in blob array
    buffer content is copied in array

Arguments:

    iBefore - index where to insert entry, or 0xffffffff if add to array
    pS - buffer to be inserted in array
    cS - length of buffer

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i;

    if ( iBefore == INDEX_ERROR || iBefore >= GetNbEntry() )
    {
        return AddEntry( (LPBYTE)pS, cS );
    }

    if ( iBefore < GetNbEntry() && Append( (LPBYTE)&pS, sizeof(CBlob) ) )
    {
        memmove( GetBuff()+(iBefore+1)*sizeof(CBlob), 
                 GetBuff()+iBefore*sizeof(CBlob),
                 GetUsed()-(iBefore+1)*sizeof(CBlob) );

        return GetBlob(iBefore)->InitSet( (LPBYTE)pS, cS ) ? iBefore : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


BOOL 
CBlobXBF::DeleteEntry( 
    DWORD i 
    )
/*++

Routine Description:

    Delete a entry from blob array

Arguments:

    i - index of string to delete

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( i < GetNbEntry() )
    {
        GetBlob(i)->Reset();

        memmove( GetBuff()+i*sizeof(CBlob), 
                 GetBuff()+(i+1)*sizeof(CBlob),
                 GetUsed()-(i+1)*sizeof(CBlob) );

        DecreaseUse( sizeof(CBlob) );

        return TRUE;
    }
    return FALSE;
}


BOOL 
CBlobXBF::Unserialize( 
    LPBYTE* ppB, 
    LPDWORD pC, 
    DWORD cNbEntry )
/*++

Routine Description:

    Unserialize a blob array

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer
    cNbEntry - # of ptr to unserialize from buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    UINT i;

    Reset();

    CBlob empty;
    for ( i = 0 ; i < cNbEntry ; ++i )
    {
        if ( !Append( (LPBYTE)&empty, sizeof(empty) ) ||
             !GetBlob(i)->Unserialize( ppB, pC ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


BOOL 
CBlobXBF::Serialize( 
    CStoreXBF* pX 
    )
/*++

Routine Description:

    Serialize a blob array

Arguments:

    pX - ptr to CStoreXBF where to add serialized blob

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    UINT i;

    for ( i = 0 ; i < GetNbEntry() ; ++i )
    {
        if ( !GetBlob(i)->Serialize( pX ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\cnfg\lbcnfg.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    lbcnfg.cxx

Abstract:

    Classes to handle IIS load balancing configuration

Author:

    Philippe Choquier (phillich)

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <mbstring.h>

#include <winsock2.h>

#include "lbxbf.hxx"
#include "lbcnfg.hxx"

#if defined(_NOISY_DEBUG)
#define DEBUG_BUFFER    char    achE[128]
#define DBG_PRINTF(a)   wsprintf a; OutputDebugString( achE )
#define DBG_PUTS(a)     OutputDebugString(a)
#else
#define DEBUG_BUFFER
#define DBG_PRINTF(a)
#define DBG_PUTS(a)
#endif

CIPMap::CIPMap(
    )
/*++

Routine Description:

    CIPMap constructor

Arguments:

    none

Return Value:

    nothing

--*/
{
}


CIPMap::~CIPMap(
    )
/*++

Routine Description:

    CIPMap destructor

Arguments:

    none

Return Value:

    nothing

--*/
{
    Reset();
}


VOID
CIPMap::Reset(
    )
/*++

Routine Description:

    Reset a CIPMap to empty content

Arguments:

    none

Return Value:

    nothing

--*/
{
    UINT    iComp;

    for ( iComp = 0 ; 
          iComp < m_Servers.GetNbPtr() ; 
          ++iComp )
    {
        delete (CComputerBalanceCnfg*)m_Servers.GetPtr( iComp );
    }
    m_Servers.Reset();
    m_IpPublic.Reset();
    m_Sticky.Reset();
    m_Attr.Reset();
}


BOOL 
CIPMap::Serialize( 
    CStoreXBF* pX 
    )
/*++

Routine Description:

    serialize a CIPMap to buffer

Arguments:

    buffer where to serialize

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    iComp;

    if ( !::Serialize( pX, (DWORD)IPLIST_VERSION ) )
    {
        return FALSE;
    }

    if ( !::Serialize( pX, (DWORD)m_Servers.GetNbPtr() ) )
    {
        return FALSE;
    }

    if ( !::Serialize( pX, (DWORD)m_IpPublic.GetNbEntry() ) )
    {
        return FALSE;
    }

    for ( iComp = 0 ; 
          iComp < m_Servers.GetNbPtr() ; 
          ++iComp )
    {
        if ( !((CComputerBalanceCnfg*)m_Servers.GetPtr(iComp))->Serialize( pX ) )
        {
            return FALSE;
        }
    } 

    if ( !m_IpPublic.Serialize( pX ) ||
         !m_Name.Serialize( pX ) ||
         !m_Sticky.Serialize( pX ) ||
         !m_Attr.Serialize( pX ) )
    {
        return FALSE;
    }

    return TRUE;
}


BOOL 
CIPMap::Unserialize( 
    CStoreXBF* pX 
    )
/*++

Routine Description:

    Unserialize a CIPMap

Arguments:

    pX - ptr to buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE pb = pX->GetBuff();
    DWORD  dw = pX->GetUsed();

    return Unserialize( &pb, &dw );
}


BOOL 
CIPMap::Unserialize( 
    LPBYTE* ppb, 
    LPDWORD pc 
    )
/*++

Routine Description:

    Unserialize IP Map

Arguments:

    ppb - ptr to addr of buffer to unserialize from
    pc - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD                   dwComp;
    UINT                    iComp;
    DWORD                   dwPublicIp;
    UINT                    iPublicIp;
    CComputerBalanceCnfg*   pComp;
    DWORD                   dwVersion;
    DEBUG_BUFFER;

    Reset();

    if ( !::Unserialize( ppb, pc, &dwVersion ) )
    {
        return FALSE;
    }

    if ( !::Unserialize( ppb, pc, &dwComp ) ||
         !::Unserialize( ppb, pc, &dwPublicIp ) )
    {
        DBG_PRINTF(( achE, "CIPMap::Unserialize error 1, pb=%08x c=%d\n", *ppb, *pc));
        return FALSE;
    }

    for ( iComp = 0 ; 
          iComp < dwComp ; 
          ++iComp )
    {
        if ( !(pComp = new CComputerBalanceCnfg) ||
             m_Servers.AddPtr( pComp ) == INDEX_ERROR ||
             !pComp->Unserialize( ppb, pc, dwPublicIp ) )
        {
            DBG_PUTS("CIPMap::Unserialize error 2\n" );
            return FALSE;
        }
    }

    if ( !m_IpPublic.Unserialize( ppb, pc, dwPublicIp ) ||
         !m_Name.Unserialize( ppb, pc, dwPublicIp ) ||
         !m_Sticky.Unserialize( ppb, pc, dwPublicIp ) ||
         !m_Attr.Unserialize( ppb, pc, dwPublicIp ) )
    {
        DBG_PUTS("CIPMap::Unserialize error 3\n" );
        return FALSE;
    }

    return TRUE;
}


BOOL
LoadBlobFromReg(
    HKEY        hKey,
    LPSTR       pszRegKey,
    LPSTR       pszRegValue,
    CStoreXBF*  pX
    )
/*++

Routine Description:

    Load a buffer from registry

Arguments:

    hKey - registry handle where to open key to read value
    pszRegKey - key where to read value
    pszRegValue - value name
    pX - ptr to buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL        fSt = FALSE;
    HKEY        hK;
    DWORD       dwNeed;
    DWORD       dwType;
    DWORD       dwStatus;
    CHAR        achE[128];


    if ( (dwStatus = RegOpenKeyEx( hKey,
                                   pszRegKey,
                                   0,
                                   KEY_READ,
                                   &hK )) == ERROR_SUCCESS )
    {
        dwNeed = 0;

        if ( (dwStatus = RegQueryValueEx( hK,
                              pszRegValue,
                              0,
                              &dwType,
                              NULL,
                              &dwNeed )) == ERROR_SUCCESS &&
             dwType == REG_BINARY &&
             pX->Need( dwNeed ) &&
             (dwStatus = RegQueryValueEx( hK,
                              pszRegValue,
                              0,
                              &dwType,
                              pX->GetBuff(),
                              &dwNeed )) == ERROR_SUCCESS )
        {
            pX->SetUsed( dwNeed );
            fSt = TRUE;
        }

        RegCloseKey( hK );
    }

    if ( !fSt )
    {
        SetLastError( dwStatus );
        DBG_PUTS( "Error LoadBlobFromReg\n" );
    }

    return fSt;
}


BOOL 
CIPMap::Load( 
    HKEY hKey, 
    LPSTR pszRegKey, 
    LPSTR pszRegValue 
    )
/*++

Routine Description:

    Load a CIPMap from registry

Arguments:

    hKey - registry handle where to open key to read value
    pszRegKey - key where to read value
    pszRegValue - value name

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CStoreXBF   xbf;


    return LoadBlobFromReg( hKey,
                            pszRegKey,
                            pszRegValue,
                            &xbf ) &&
           Unserialize( &xbf );
}


BOOL
SaveBlobToReg(
    HKEY        hKey,
    LPSTR       pszRegKey,
    LPSTR       pszRegValue,
    CStoreXBF*  pX
    )
/*++

Routine Description:

    Save a buffer to registry

Arguments:

    hKey - registry handle where to open key to write value
    pszRegKey - key where to write value
    pszRegValue - value name
    pX - ptr to buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL        fSt = FALSE;
    HKEY        hK;
    DWORD       dwDisposition;
    DWORD       dwStatus;


    if ( (dwStatus = RegCreateKeyEx( hKey,
                         pszRegKey,
                         0,
                         "",
                         REG_OPTION_NON_VOLATILE,
                         KEY_WRITE,
                         NULL,
                         &hK,
                         &dwDisposition )) == ERROR_SUCCESS )
    {
        if ( (dwStatus = RegSetValueEx( hK,
                            pszRegValue,
                            0,
                            REG_BINARY,
                            pX->GetBuff(),
                            pX->GetUsed() )) == ERROR_SUCCESS )
        {
            fSt = TRUE;
        }

        RegCloseKey( hK );
    }

    if ( !fSt )
    {
        SetLastError( dwStatus );
    }

    return fSt;
}


BOOL 
CIPMap::Save( 
    HKEY hKey, 
    LPSTR pszRegKey, 
    LPSTR pszRegValue 
    )
/*++

Routine Description:

    Save a CIPMap to registry

Arguments:

    hKey - registry handle where to open key to write value
    pszRegKey - key where to write value
    pszRegValue - value name

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CStoreXBF   xbf;

    return Serialize( &xbf ) &&
           SaveBlobToReg( hKey, pszRegKey, pszRegValue, &xbf );
}


BOOL 
CIPMap::AddComputer( 
    LPWSTR pszName 
    )
/*++

Routine Description:

    Add a computer in CIPMap

Arguments:

    pszName - computer name to be added at the end of computer list

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CComputerBalanceCnfg*   pComp;
    UINT                    iComp;
    LPWSTR                  pszCheckName;

    for ( iComp = 0 ;
          iComp < m_Servers.GetNbPtr() ;
          ++iComp )
    {
        if ( ((CComputerBalanceCnfg*)m_Servers.GetPtr( iComp ))->GetName( &pszCheckName ) &&
             !_wcsicmp( pszCheckName, pszName ) )
        {
            SetLastError( ERROR_ALREADY_EXISTS );
            return FALSE;
        }
    }

    if ( (pComp = new CComputerBalanceCnfg) &&
         m_Servers.AddPtr( (LPVOID)pComp ) != INDEX_ERROR &&
         pComp->Init( pszName, m_IpPublic.GetNbEntry() ) )
    {
        return TRUE;
    }

    delete pComp;

    return FALSE;
}


BOOL 
CIPMap::EnumComputer( 
    UINT    iComp, 
    LPWSTR* ppszName 
    )
/*++

Routine Description:

    Enumerate computers in CIPMap

Arguments:

    iComp - computer index ( 0-based )
    ppszName - updated with read-only computer name on success

Return Value:

    TRUE if success, otherwise FALSE
    LastError will be set to ERROR_NO_MORE_ITEMS if index out of range

--*/
{
    if ( iComp >= m_Servers.GetNbPtr() )
    {
        SetLastError( ERROR_NO_MORE_ITEMS );
        return FALSE;
    }

    return ((CComputerBalanceCnfg*)m_Servers.GetPtr( iComp ))->GetName( ppszName );
}


BOOL 
CIPMap::DeleteComputer( 
    UINT iComp 
    )
/*++

Routine Description:

    Delete a computer in CIPMap

Arguments:

    iComp - computer index ( 0-based )

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( iComp >= m_Servers.GetNbPtr() )
    {
        return FALSE;
    }

    delete ((CComputerBalanceCnfg*)m_Servers.GetPtr( iComp ));

    return m_Servers.DeletePtr( iComp );
}


BOOL 
CIPMap::AddIpPublic( 
    LPWSTR  pszIpPublic,
    LPWSTR  pszName,
    DWORD   dwSticky,
    DWORD   dwAttr
    )
/*++

Routine Description:

    Add a public IP address in CIPMap

Arguments:

    pszIpPublic - public IP address to be added at the end of public IP address list
    pszName - name associated with IP address
    dwSticky - sticky duration ( in seconds )
    dwAttr - user defined param

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    iComp;
    UINT    iIp;


    for ( iIp = 0 ;
          iIp < m_IpPublic.GetNbPtr() ;
          ++iIp )
    {
        if ( !_wcsicmp( m_IpPublic.GetEntry( iIp ), pszIpPublic ) )
        {
            SetLastError( ERROR_ALREADY_EXISTS );
            return FALSE;
        }
    }

    if ( m_IpPublic.AddEntry( pszIpPublic ) == INDEX_ERROR ||
         m_Name.AddEntry( pszName ) == INDEX_ERROR ||
         m_Sticky.AddPtr( (LPVOID)dwSticky) == INDEX_ERROR ||
         m_Attr.AddPtr( (LPVOID)dwAttr) == INDEX_ERROR )
    {
        return FALSE;
    }

    for ( iComp = 0 ; 
          iComp < m_Servers.GetNbPtr() ; 
          ++iComp )
    {
        if ( ((CComputerBalanceCnfg*)m_Servers.GetPtr(iComp))->AddIpPublic() == INDEX_ERROR )
        {
            return FALSE;
        }
    } 

    return TRUE;
}


BOOL 
CIPMap::EnumIpPublic( 
    UINT    iIpPublic, 
    LPWSTR* ppszIpPublic,
    LPWSTR* ppszName,
    LPDWORD pdwSticky,
    LPDWORD pdwAttr
    )
/*++

Routine Description:

    Enumerate public IP addresses in CIPMap

Arguments:

    iIpPublic - public IP address index ( 0-based )
    ppszIpPublic - updated with read-only public IP address on success
    ppszName - associated name
    pdwSticky - associated sticky duration
    pdwAttr - associated user attr

Return Value:

    TRUE if success, otherwise FALSE
    LastError will be set to ERROR_NO_MORE_ITEMS if index out of range

--*/
{
    if ( iIpPublic >= m_IpPublic.GetNbEntry() )
    {
        SetLastError( ERROR_NO_MORE_ITEMS );
        return FALSE;
    }

    *ppszIpPublic = m_IpPublic.GetEntry( iIpPublic );
    *ppszName = m_Name.GetEntry( iIpPublic );
    *pdwSticky = (DWORD)m_Sticky.GetPtr( iIpPublic );   // BUGBUG64
    *pdwAttr = (DWORD)m_Attr.GetPtr( iIpPublic );       // BUGBUG64

    return TRUE;
}


BOOL 
CIPMap::DeleteIpPublic( 
    UINT iIpPublic 
    )
/*++

Routine Description:

    Delete a public IP address in CIPMap

Arguments:

    iIpPublic - public IP address index ( 0-based )

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    iComp;


    if ( !m_IpPublic.DeleteEntry( iIpPublic ) ||
         !m_Name.DeleteEntry( iIpPublic ) ||
         !m_Sticky.DeletePtr( iIpPublic ) ||
         !m_Attr.DeletePtr( iIpPublic ) )
    {
        return FALSE;
    }

    for ( iComp = 0 ; 
          iComp < m_Servers.GetNbPtr() ; 
          ++iComp )
    {
        if ( !((CComputerBalanceCnfg*)m_Servers.GetPtr(iComp))->DeleteIpPublic(iIpPublic) )
        {
            return FALSE;
        }
    } 

    return TRUE;
}


BOOL 
CIPMap::SetIpPrivate( 
    UINT    iComp, 
    UINT    iIpPublic, 
    LPWSTR  pszIpPrivate,
    LPWSTR  pszName
    )
/*++

Routine Description:

    Set a private IP address in CIPMap

Arguments:

    iComp - computer index
    iIpPublic - public IP address index
    pszIpPrivate - private IP addresse to associate with iComp & iIpPublic
    pszName - name associated with private IP address

Return Value:

    TRUE if success, otherwise FALSE
    LastError will be set to ERROR_INVALID_PARAMETER if indexes out of range

--*/
{
    if ( iIpPublic >= m_IpPublic.GetNbEntry() ||
         iComp >= m_Servers.GetNbPtr() ) 
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    return ((CComputerBalanceCnfg*)m_Servers.GetPtr(iComp))->
        SetIpPrivate( iIpPublic, pszIpPrivate, pszName);
}


BOOL 
CIPMap::GetIpPrivate( 
    UINT    iComp, 
    UINT    iIpPublic, 
    LPWSTR* ppszIpPrivate,
    LPWSTR* ppszName
    )
/*++

Routine Description:

    Get a private IP address in CIPMap

Arguments:

    iComp - computer index
    iIpPublic - public IP address index
    ppszIpPrivate - updated with read-only private IP addresse associated with iComp & iIpPublic
    ppszName - updated with read-pnly name associated with iComp & iIpPublic

Return Value:

    TRUE if success, otherwise FALSE
    LastError will be set to ERROR_INVALID_PARAMETER if indexes out of range

--*/
{
    if ( iIpPublic >= m_IpPublic.GetNbEntry() ||
         iComp >= m_Servers.GetNbPtr() ) 
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    return ((CComputerBalanceCnfg*)m_Servers.GetPtr(iComp))->GetIpPrivate(iIpPublic,ppszIpPrivate,ppszName);
}


BOOL 
CComputerBalanceCnfg::Init( 
    LPWSTR  pszName, 
    UINT    cIpPublic 
    )
/*++

Routine Description:

    Initialize a CComputerBalanceCnfg with computer name, creating cIpPublic entries
    in private IP addresses list

Arguments:

    pszName - computer name
    cIpPublic - count of current public IP addresses

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( !m_ComputerName.Set( pszName ) )
    {
        return FALSE;
    }

    while ( cIpPublic-- )
    {
        if ( m_IpPrivate.AddEntry(L"") == INDEX_ERROR ||
             m_Name.AddEntry(L"") == INDEX_ERROR )
        {
            return FALSE;
        }
    }

    return TRUE;
}


CComputerPerfCounters::CComputerPerfCounters()
/*++

Routine Description:

    CComputerPerfCounters constructor

Arguments:

    none

Return Value:

    nothing

--*/
{
}


CComputerPerfCounters::~CComputerPerfCounters()
/*++

Routine Description:

    CComputerPerfCounters destructor

Arguments:

    none

Return Value:

    nothing

--*/
{
    Reset();
}


VOID 
CComputerPerfCounters::Reset(
    )
/*++

Routine Description:

    Reset a CIPMap to empty content

Arguments:

    none

Return Value:

    nothing

--*/
{
    m_PerfCounters.Reset();
    m_Weight.Reset();
}


BOOL 
CComputerPerfCounters::Serialize( 
    CStoreXBF* pX 
    )
/*++

Routine Description:

    serialize a CComputerPerfCounters to buffer

Arguments:

    buffer where to serialize

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( !::Serialize( pX, (DWORD)PERFLIST_VERSION ) )
    {
        return FALSE;
    }

    return ::Serialize( pX, (DWORD)m_PerfCounters.GetNbEntry() ) &&
           m_PerfCounterServers.Serialize( pX ) &&
           m_PerfCounters.Serialize( pX ) &&
           m_Weight.Serialize( pX );
}


BOOL 
CComputerPerfCounters::Unserialize( 
    CStoreXBF* pX 
    )
/*++

Routine Description:

    Unserialize a CComputerPerfCounters

Arguments:

    pX - ptr to buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE pb = pX->GetBuff();
    DWORD  dw = pX->GetUsed();

    return Unserialize( &pb, &dw );
}


BOOL 
CComputerPerfCounters::Unserialize( 
    LPBYTE* ppb, 
    LPDWORD pdw
    )
/*++

Routine Description:

    Unserialize a CComputerPerfCounters

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD   dwP;
    DWORD   dwVersion;


    if ( !::Unserialize( ppb, pdw, &dwVersion ) )
    {
        return FALSE;
    }

    return ::Unserialize( ppb, pdw, &dwP ) &&
           m_PerfCounterServers.Unserialize( ppb, pdw, dwP ) &&
           m_PerfCounters.Unserialize( ppb, pdw, dwP ) &&
           m_Weight.Unserialize( ppb, pdw, dwP );
}


BOOL 
CComputerPerfCounters::Load( 
    HKEY hKey, 
    LPSTR pszRegKey, 
    LPSTR pszRegValue 
    )
/*++

Routine Description:

    Load a CComputerPerfCounters from registry

Arguments:

    hKey - registry handle where to open key to read value
    pszRegKey - key where to read value
    pszRegValue - value name

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CStoreXBF   xbf;


    return LoadBlobFromReg( hKey,
                            pszRegKey,
                            pszRegValue,
                            &xbf ) &&
           Unserialize( &xbf );
}


BOOL 
CComputerPerfCounters::Save( 
    HKEY hKey, 
    LPSTR pszRegKey, 
    LPSTR pszRegValue 
    )
/*++

Routine Description:

    Save a CComputerPerfCounters to registry

Arguments:

    hKey - registry handle where to open key to write value
    pszRegKey - key where to write value
    pszRegValue - value name

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CStoreXBF   xbf;


    return Serialize( &xbf ) &&
           SaveBlobToReg( hKey, pszRegKey, pszRegValue, &xbf );
}


BOOL 
CComputerPerfCounters::AddPerfCounter( 
    LPWSTR  pszServerName,
    LPWSTR  pszPerfCounter, 
    DWORD   dwWeight 
    )
/*++

Routine Description:

    Add a performance counter in CIPMap

Arguments:

    pszServerName - optional server name ( can be NULL )
    pszIpPublic - performance counter to be added at the end of performance counter list
    dwWeight - weight associated with perf counter to add

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    iPerf;

    //
    // Check if specify normalized flag then to other counter exist.
    // if not normalized then existing counter should not be normalized.
    //

    if ( dwWeight == LB_WEIGHT_NORMALIZED_FLAG &&
         m_PerfCounterServers.GetNbEntry() )
    {
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE;
    }
    else if ( dwWeight != LB_WEIGHT_NORMALIZED_FLAG )
    {
        for ( iPerf = 0 ; 
              iPerf < m_PerfCounters.GetNbEntry() ;
              ++iPerf )
        {
            if ( (DWORD)m_Weight.GetPtr( iPerf ) == LB_WEIGHT_NORMALIZED_FLAG ) // BUGBUG64
            {
                SetLastError( ERROR_INVALID_PARAMETER );

                return FALSE;
            }
        }
    }

    return m_PerfCounterServers.AddEntry( pszServerName ? pszServerName : L"") != INDEX_ERROR &&
           m_PerfCounters.AddEntry( pszPerfCounter ) != INDEX_ERROR &&
           m_Weight.AddPtr( (LPVOID)dwWeight ) != INDEX_ERROR;
}


BOOL 
CComputerPerfCounters::EnumPerfCounter( 
    UINT    iPerfCounter, 
    LPWSTR* ppszPerfCounterServer, 
    LPWSTR* ppszPerfCounter, 
    DWORD*  pdwWeight 
    )
/*++

Routine Description:

    Enumerate performance counters in CComputerPerfCounters

Arguments:

    iPerfCounter - public IP address index ( 0-based )
    ppszServerName - updated with read-only server name ( can be NULL )
    ppszPerfCounter - updated with read-only performance counter on success
    pdwWeight - updated with read-only perf counter weight on success

Return Value:

    TRUE if success, otherwise FALSE
    LastError will be set to ERROR_NO_MORE_ITEMS if index out of range

--*/
{
    if ( iPerfCounter >= m_PerfCounters.GetNbEntry() )
    {
        SetLastError( ERROR_NO_MORE_ITEMS );
        return FALSE;
    }

    *ppszPerfCounterServer = *m_PerfCounterServers.GetEntry( iPerfCounter ) ?
                             m_PerfCounterServers.GetEntry( iPerfCounter ) :
                             NULL;
    *ppszPerfCounter = m_PerfCounters.GetEntry( iPerfCounter );
    *pdwWeight = (DWORD)m_Weight.GetPtr( iPerfCounter );    // BUGBUG64

    return TRUE;
}


BOOL 
CComputerPerfCounters::DeletePerfCounter( 
    UINT iPerfCounter 
    )
/*++

Routine Description:

    Delete a performance counter in CComputerPerfCounters

Arguments:

    iPerfCounter - performance counter index ( 0-based )

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return m_PerfCounterServers.DeleteEntry( iPerfCounter ) &&
           m_PerfCounters.DeleteEntry( iPerfCounter ) &&
           m_Weight.DeletePtr( iPerfCounter );
}


BOOL
CComputerPerfCounters::SetPerfCounterWeight( 
    UINT iPerfCounter, 
    DWORD dwWeight 
    )
/*++

Routine Description:

    Set a performance counter weight in CIPMap

Arguments:

    iPerfCounter - performance counter index
    dwWeight - weight to associate with performance counter indexed by iPerfCounter 

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return m_Weight.SetPtr( iPerfCounter, (LPVOID)dwWeight );
}

/////////////////

CIpEndpointList::CIpEndpointList(
    )
/*++

Routine Description:

    CIpEndpointList constructor

Arguments:

    none

Return Value:

    nothing

--*/
{
}


CIpEndpointList::~CIpEndpointList(
    )
/*++

Routine Description:

    CIpEndpointList destructor

Arguments:

    none

Return Value:

    nothing

--*/
{
    Reset();
}


VOID
CIpEndpointList::Reset(
    )
/*++

Routine Description:

    Reset a CIpEndpointList to empty content

Arguments:

    none

Return Value:

    nothing

--*/
{
    UINT    iComp;

    m_IpEndpoint.Reset();
}


BOOL 
CIpEndpointList::Serialize( 
    CStoreXBF* pX 
    )
/*++

Routine Description:

    serialize a CIpEndpointList to buffer

Arguments:

    buffer where to serialize

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( !::Serialize( pX, (DWORD)m_IpEndpoint.GetNbEntry() ) )
    {
        return FALSE;
    }

    if ( !m_IpEndpoint.Serialize( pX ) )
    {
        return FALSE;
    }

    return TRUE;
}


BOOL 
CIpEndpointList::Unserialize( 
    CStoreXBF* pX 
    )
/*++

Routine Description:

    Unserialize a CIpEndpointList

Arguments:

    pX - ptr to buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE pb = pX->GetBuff();
    DWORD  dw = pX->GetUsed();

    return Unserialize( &pb, &dw );
}


BOOL 
CIpEndpointList::Unserialize( 
    LPBYTE* ppb, 
    LPDWORD pc 
    )
/*++

Routine Description:

    Unserialize CIpEndpointList

Arguments:

    ppb - ptr to addr of buffer to unserialize from
    pc - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD                   dwIp;

    Reset();

    if ( !::Unserialize( ppb, pc, &dwIp ) )
    {
        return FALSE;
    }

    if ( !m_IpEndpoint.Unserialize( ppb, pc, dwIp ) )
    {
        return FALSE;
    }

    return TRUE;
}


BOOL 
CIpEndpointList::EnumIpEndpoint( 
    UINT    iIp, 
    LPWSTR* ppszIp 
    )
/*++

Routine Description:

    Enumerate IP endpoints

Arguments:

    iIp - IP index ( 0-based )
    ppszName - updated with read-only IP addr ( as string ) on success

Return Value:

    TRUE if success, otherwise FALSE
    LastError will be set to ERROR_NO_MORE_ITEMS if index out of range

--*/
{
    if ( iIp >= m_IpEndpoint.GetNbEntry() )
    {
        SetLastError( ERROR_NO_MORE_ITEMS );
        return FALSE;
    }

    *ppszIp = m_IpEndpoint.GetEntry( iIp );

    return TRUE;
}


BOOL 
CIpEndpointList::BuildListFromLocalhost(
    )
/*++

Routine Description:

    Build list of local IP endpoints

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    char**          pAddr;
    sockaddr_in     SockAddr;
    struct hostent* pH;
    WCHAR           achAddr[128];
    DWORD           cAddr;

    Reset();

    if ( pH = gethostbyname( NULL ) )
    {
        if ( pH->h_addrtype == AF_INET )
        {
            for ( pAddr = pH->h_addr_list; 
                  *pAddr ; 
                  ++pAddr )
            {
                memcpy( &SockAddr.sin_addr, *pAddr, 4 );
                SockAddr.sin_family = AF_INET;
                SockAddr.sin_port = 0;

                cAddr = sizeof( achAddr ) / sizeof(WCHAR);

                if ( WSAAddressToStringW( (struct sockaddr *)&SockAddr, 
                                          sizeof(SockAddr), 
                                          NULL, 
                                          achAddr,
                                          &cAddr ) != 0 ||
                     m_IpEndpoint.AddEntry( achAddr ) == INDEX_ERROR )
                {
                    return FALSE;
                }
            }

            return TRUE;
        }
        else
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\driver\iislbdr.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    iislbdr.cxx

Abstract:

    This module implements NAT entry points

Author:

    Philippe Choquier ( phillich )

--*/

extern "C" {

//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <ntsecapi.h>
//#include <ntddnetd.h>

//#include <ntverp.h>

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#if defined(KERNEL_MODE)
#define NOUSER
#endif
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOSCROLL
#define NOSERVICE
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS


#if defined(KERNEL_MODE)
#include <strmini.h>
#else
#include <windows.h>
#include <wdbgexts.h>
#endif


#include <stdlib.h>

#include <ipnat.h>
#include "iisnatio.h"
#include <bootexp.hxx>

}

#pragma intrinsic(memcmp)

#include <iislbh.hxx>

#if DBG
#define NOISY_DBG   1
#else
#define NOISY_DBG   0
#endif

//
// Private strutures
//

#pragma pack(1)

typedef struct _HASH_BUCKET
{
    ULONG   m_HashEntry;
    ULONG   m_CheckExpiry;
} HASH_BUCKET ;

typedef struct _HASH_ENTRY
{
    ULONG   m_RemoteAddress;
    USHORT  m_PublicRef;
    USHORT  m_PrivateRef;
    ULONG   m_NextHashEntry;
    ULONG   m_Expiry;
} HASH_ENTRY;

#pragma pack()

#define NB_BUCKETS          251
#define HASH_ALLOC_GRAIN    64
#define EOCHAIN             0xffff
#define CHECK_EXPIRY        30      // in seconds

//
// Define macros allowing common source code for user & kernel mode
// This allows the mapping to be tested in user mode
//

#if defined(KERNEL_MODE)
#define DECLARE_LOCK_OBJECT(a) KSPIN_LOCK   a
#define INIT_LOCK_OBJECT(a) KeInitializeSpinLock(a)
#define TERMINATE_LOCK_OBJECT(a)
#define LockIpMap() KeAcquireSpinLock(&IpMapLock, &oldIrql )
#define UnlockIpMap() KeReleaseSpinLock(&IpMapLock, oldIrql )
#define LockIpMapAtDpcLevel() KeAcquireSpinLock(&IpMapLock, &oldIrql)
#define UnlockIpMapFromDpcLevel() KeReleaseSpinLock(&IpMapLock, oldIrql)
//#define LockIpMapAtDpcLevel() KeAcquireSpinLockAtDpcLevel(&IpMapLock)
//#define UnlockIpMapFromDpcLevel() KeReleaseSpinLockFromDpcLevel(&IpMapLock)
#define AllocBuffer(a)      ExAllocatePool( NonPagedPool, a )
#define FreeBuffer(a)       ExFreePool( a )
#define Copy_Memory(a,b,c)   RtlCopyBytes(a,b,c)
#define Equal_Memory(a,b,c)   RtlEqualMemory(a,b,c)
#define DeclareTimeObject(a)    ULONGLONG    a
#define GetTime(a,b)        KeQuerySystemTime( (PLARGE_INTEGER)&a ); b = (ULONG)(a / (ULONGLONG)(10*1000*1000))
#else
#include <time.h>
#define DECLARE_LOCK_OBJECT(a) CRITICAL_SECTION    a
#define INIT_LOCK_OBJECT(a)
#define TERMINATE_LOCK_OBJECT(a)
#define LockIpMap()
#define UnlockIpMap()
#define LockIpMapAtDpcLevel()
#define UnlockIpMapFromDpcLevel()
#define AllocBuffer(a)      LocalAlloc( LMEM_FIXED, a)
#define FreeBuffer(a)       LocalFree( a )
#define Copy_Memory(a,b,c)   memcpy(a,b,c)
#define Equal_Memory(a,b,c)  0 // !memcmp(a,b,c)
#define DeclareTimeObject(a)
#define GetTime(a,b)        b = time(NULL)
#undef IoCompleteRequest
#define IoCompleteRequest(a,b)
#undef ProbeForRead
#define ProbeForRead(a,b,c)
#define IoDeleteSymbolicLink(a)
#define IoDeleteDevice(a)
#define IoCreateSymbolicLink(a,b) STATUS_SUCCESS
#define IoCreateDevice(a,b,c,d,e,f,g) STATUS_SUCCESS
#define IoGetDeviceObjectPointer(a,b,c,d) (*c=NULL,*d=NULL,STATUS_SUCCESS)
#define IoBuildDeviceIoControlRequest(a,b,c,d,e,f,g,h,i) (PIRP)1
#define ObfDereferenceObject(a)
#include <stdio.h>
#include <stdarg.h>
ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    )
{
    va_list marker;
    CHAR    achD[128];

    va_start( marker, Format );

    wvsprintf( achD, Format, marker );
    OutputDebugString( achD );

    va_end( marker );

    return 0;
}
#endif

//
// Private prototypes
//

NTSTATUS
NotifyPort(
    CKernelIpEndpointEx*    pEndp
    );


NTSTATUS
UnnotifyPort(
    CKernelIpEndpointEx*    pEndp
    );


//
//  Globals
//

HASH_BUCKET                 HashBuckets[NB_BUCKETS];

HASH_ENTRY*                 HashEntries;
unsigned int                cHashEntries;
unsigned int                iFirstFreeHashEntry;

CKernelIpMapMinHelper       IpMap;
ULONG                       iCurrentServer;

PNAT_HELPER_QUERY_INFO_SESSION      pQueryInfoSession;
PNAT_HELPER_DEREGISTER_DIRECTOR     pDeregisterNat;

PDEVICE_OBJECT              NatDeviceObject;
PFILE_OBJECT                NatFileObject;

DECLARE_LOCK_OBJECT(IpMapLock);

//
//  NAT functions
//

extern "C"
NTSTATUS
NatRegisterSessionControl(
    IN  ULONG   Version
    )
/*++

NatRegisterSessionControl

Routine Description:

    This routine is exported by the session-control module.

    It is invoked by the NAT to determine whether the module will be
    directing incoming sessions.

Arguments:

    Version - the version of the NAT which is running.

Return Value:

    STATUS_SUCCESS if the module wishes to direct incoming sessions,
    error code otherwise.

--*/
{
    DeclareTimeObject( RegSes );
    ULONG   Now;
    ULONG   i;

    GetTime( RegSes, Now );
    HashEntries = NULL;
    IpMap.SetBuffer( NULL );
    iFirstFreeHashEntry = EOCHAIN;
    cHashEntries = 0;
    iCurrentServer = 0;

    for ( i = 0 ; i < NB_BUCKETS ; ++i )
    {
        HashBuckets[i].m_HashEntry = EOCHAIN;
        HashBuckets[i].m_CheckExpiry = Now + CHECK_EXPIRY;
    }

    INIT_LOCK_OBJECT(&IpMapLock);

    pQueryInfoSession = NULL;
    pDeregisterNat = NULL;

#if NOISY_DBG
    DbgPrint( "NatRegisterSessionControl:\n" );
#endif

    return STATUS_SUCCESS;
}


extern "C"
NTSTATUS
NatIoctlSessionControl(
    IN  PIRP    Irp
    )
/*++

NatIoctlSessionControl

Routine Description:

    It handles IOCTL_IISNATIO_SET_CONFIG IRP, dispatched from IISNATDispatchIoctl()
    It is also exported to be called directly when called from user mode

    The module should treat the IRP as if it were received in an actual
    dispatch routine; the NAT does no pre-processing or post-processing,
    so the module must update the IRP on its own.

Arguments:

    Irp - the IRP received by the NAT from the I/O manager.

Return Value:

    The status code to be returned from the NAT's dispatch routine.

--*/
{
    ULONG                   cNewIpMapSize;
    LPVOID                  NewIpMap;
    HASH_ENTRY*             pTopHash;
    HASH_ENTRY*             pHash;
    CKernelIpMapMinHelper   NewIpMapHelper;
    UINT                    iOld;
    UINT                    iNew;
    UINT                    iHash;
    UINT                    iF;
    UINT                    iPrevF;
    UINT                    iNext;
    DWORD                   iNewPub;
    DWORD                   iNewPrv;
    BOOL                    fUpdate = FALSE;
    PIO_STACK_LOCATION      IrpSp;
    NTSTATUS                status = STATUS_SUCCESS;
    KIRQL                   oldIrql;
    CKernelIpEndpointEx*    pOld;
    CKernelIpEndpointEx*    pNew;
    UINT                    cPublicIp;
    UINT                    cPrivateIp;
    IPREF*                  pIp;
    IPREF*                  pTopIp;
    UINT                    cSize;
    UINT                    iIpRef;


    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    cNewIpMapSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    NewIpMap = AllocBuffer( cNewIpMapSize );

    if ( NewIpMap == NULL )
    {
        status = STATUS_NO_MEMORY;
        goto complete;
    }

    NewIpMapHelper.SetBuffer( NewIpMap );

    //
    // Copy over the user's buffer into our information structure.
    //

    Copy_Memory( NewIpMap, 
                 Irp->AssociatedIrp.SystemBuffer, 
                 cNewIpMapSize );

    //
    // Configuration validation
    //

    if ( NewIpMapHelper.GetSize() != cNewIpMapSize )
    {
#if NOISY_DBG
        DbgPrint( "NatIoctlSessionControl: size mismatch: %u %u\n", NewIpMapHelper.GetSize(), cNewIpMapSize );
#endif
        FreeBuffer( NewIpMap );

        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    cSize = NewIpMapHelper.GetKernelServerDescriptionSize();
    pIp = NewIpMapHelper.GetPrivateIpRef( NewIpMapHelper.GetServerPtr( 0 ), 0 );
    pTopIp = (IPREF *)((LPBYTE)pIp + cSize * NewIpMapHelper.ServerCount());
    cPublicIp = NewIpMapHelper.PublicIpCount();
    cPrivateIp = NewIpMapHelper.PrivateIpCount();

    //
    // Check that private IP references are in range
    //

    for ( ; 
          pIp < pTopIp ;
          pIp = (IPREF*)(((LPBYTE)pIp) + cSize) )
    {
        for ( iIpRef = 0 ; iIpRef < cPublicIp ; ++iIpRef )
        {
            if ( pIp[iIpRef] >= cPrivateIp &&
                 pIp[iIpRef] != -1 )
            {
#if NOISY_DBG
                DbgPrint( "NatIoctlSessionControl: invalid private IP ref: %u max is %u\n", 
                          pIp[iIpRef], 
                          cPrivateIp );
#endif
                FreeBuffer( NewIpMap );

                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }
        }
    }

    //
    // check if existing configuration not empty. If empty then no cache update
    // necessary : there is no mapping to update
    //

    if ( IpMap.GetBuffer() )
    {
        //
        // Check if each unique port in old cnfg is present in new cnfg
        // if present in both then nothing to do
        // if present in old but not in new then unnotify NAT
        // if present in new but not in old then notify NAT
        //

        for ( iOld = 0 ; 
              iOld < IpMap.PublicIpCount() ; 
              ++iOld )
        {
            pOld = IpMap.GetPublicIpPtr( iOld );

            //
            // need to reset m_dwNotifyPort : might have been set to 0 during previous
            // IOCTL
            // Only consider if != 0 : 0 means non unique port ( i.e already present in a
            // previous entry )
            //

            if ( pOld->m_dwNotifyPort = pOld->m_usUniquePort )
            {
                //
                // Check if present in new. If yes mark as no notification
                // in both old & new configuration
                //

                for ( iNew = 0 ; 
                      iNew < NewIpMapHelper.PublicIpCount() ; 
                      ++iNew )
                {
                    pNew = NewIpMapHelper.GetPublicIpPtr( iNew );

                    if ( pNew->m_usUniquePort == pOld->m_usUniquePort )
                    {
                        pNew->m_dwNotifyPort = 0;
                        pOld->m_dwNotifyPort = 0;
                        pNew->m_pvDirectorHandle = pOld->m_pvDirectorHandle;
                    }
                }

                //
                // If still !=0 then was not found in new configuration,
                // so we have to unnotify NAT
                //

                if ( pOld->m_dwNotifyPort )
                {
                    if ( (status = UnnotifyPort( pOld )) != STATUS_SUCCESS )
                    {
                        FreeBuffer( NewIpMap );

                        goto complete;
                    }
                }
            }
        }

        //
        // build old public IP -> new public IP, old prv IP -> new private IP map
        // if no match then -1
        //

        for ( iOld = 0 ; iOld < IpMap.PublicIpCount() ; ++iOld )
        {
            IpMap.GetPublicIpPtr( iOld )->m_dwIndex = (DWORD)-1;
            for ( iNew = 0 ; iNew < NewIpMapHelper.PublicIpCount() ; ++iNew )
            {
                if ( Equal_Memory( IpMap.GetPublicIpPtr( iOld ),
                                   NewIpMapHelper.GetPublicIpPtr( iNew ),
                                   sizeof(CKernelIpEndpoint) ) )
                {
                    IpMap.GetPublicIpPtr( iOld )->m_dwIndex = iNew;
                    break;
                }
            }

            //
            // If new index not equal to old, then must update cache entries
            //

            if ( iNew != iOld ||
                 iNew == NewIpMapHelper.PublicIpCount() )
            {
#if NOISY_DBG
                DbgPrint( "NatIoctlSessionControl: public IP mismatch: %u/%u %08x:%04x -> %u/%u\n",
                           iOld, IpMap.PublicIpCount(),
                           IpMap.GetPublicIpPtr( iOld )->m_dwIpAddress,
                           IpMap.GetPublicIpPtr( iOld )->m_usPort,
                           iNew, NewIpMapHelper.PublicIpCount() );
#endif
                fUpdate = TRUE;
            }
        }

        for ( iOld = 0 ; iOld < IpMap.PrivateIpCount() ; ++iOld )
        {
            IpMap.GetPrivateIpEndpoint( iOld )->m_dwIndex = (DWORD)-1;
            for ( iNew = 0 ; iNew < NewIpMapHelper.PrivateIpCount() ; ++iNew )
            {
                //
                // Check for identity between old and new private IP address
                // We also check reference count on new private IP > 0
                //  ( or was already 0 for old private IP )
                //

                if ( Equal_Memory( IpMap.GetPrivateIpEndpoint( iOld ),
                                   NewIpMapHelper.GetPrivateIpEndpoint( iNew ),
                                   sizeof(CKernelIpEndpoint) ) &&
                     ( NewIpMapHelper.GetPrivateIpEndpoint( iNew )->m_dwRefCount ||
                       !IpMap.GetPrivateIpEndpoint( iOld )->m_dwRefCount) )
                {
                    IpMap.GetPrivateIpEndpoint( iOld )->m_dwIndex = iNew;
                    break;
                }
            }

            //
            // If new index not equal to old, then must update cache entries
            //

            if ( iNew != iOld || 
                 iNew == NewIpMapHelper.PrivateIpCount() )
            {
#if NOISY_DBG
                DbgPrint( "NatIoctlSessionControl: private IP mismatch: %u/%u %08x:%04x -> %u/%u\n",
                           iOld, IpMap.PrivateIpCount(),
                           IpMap.GetPrivateIpEndpoint( iOld )->m_dwIpAddress,
                           IpMap.GetPrivateIpEndpoint( iOld )->m_usPort,
                           iNew, NewIpMapHelper.PrivateIpCount() );
#endif
                fUpdate = TRUE;
            }
        }

        LockIpMap();

        if ( fUpdate )
        {

#if NOISY_DBG
            DbgPrint( "NatIoctlSessionControl: update cache\n" );
#endif
            // update cache, if no map for either public or private ref then delete entry
            // scan all cache entries for all hash buckets

            for ( iHash = 0 ; iHash < NB_BUCKETS ; ++iHash )
            {
                for ( iF = HashBuckets[iHash].m_HashEntry, iPrevF = EOCHAIN ; 
                      iF != EOCHAIN ; 
                      iF = iNext )
                {
                    iNext = HashEntries[iF].m_NextHashEntry;

                    iNewPrv = IpMap.GetPrivateIpEndpoint( HashEntries[iF].m_PrivateRef )->m_dwIndex;
                    iNewPub = IpMap.GetPublicIpPtr( HashEntries[iF].m_PublicRef )->m_dwIndex;

                    if ( iNewPrv == (DWORD)-1 || 
                         iNewPub == (DWORD)-1 )
                    {
                        // remove it from hash chain

                        if ( iPrevF != EOCHAIN )
                        {
                            HashEntries[iPrevF].m_NextHashEntry = iNext;
                        }
                        else
                        {
                            HashBuckets[iHash].m_HashEntry = iNext;
                        }

                        // insert it in free list

                        HashEntries[iF].m_NextHashEntry = iFirstFreeHashEntry;
                        iFirstFreeHashEntry = iF;
                    }
                    else
                    {
                        HashEntries[iF].m_PrivateRef = (USHORT)iNewPrv;
                        HashEntries[iF].m_PublicRef = (USHORT)iNewPub;

                        iPrevF = iF;
                    }
                }
            }
        }

        FreeBuffer( IpMap.GetBuffer() );
        IpMap.SetBuffer( NewIpMap );

        UnlockIpMap();
    }
    else
    {
        LockIpMap();
        IpMap.SetBuffer( NewIpMap );
        UnlockIpMap();
    }

    //
    // scan new configuration for all m_dwNotifyPort != 0 
    // which means unique ports not found in old cnfg
    // so we have to notify NAT 
    //

    for ( iNew = 0 ; 
          iNew < NewIpMapHelper.PublicIpCount() ;
          ++iNew )
    {
        pNew = NewIpMapHelper.GetPublicIpPtr( iNew );

        if ( pNew->m_dwNotifyPort )
        {
            if ( (status = NotifyPort( pNew )) != STATUS_SUCCESS )
            {
                goto complete;
            }
        }
    }

    iCurrentServer = 0;

complete:

    Irp->IoStatus.Information = 0;      // nothing to send back to user mode
    Irp->IoStatus.Status = status;

    IoCompleteRequest( Irp, 0 );

#if NOISY_DBG
    DbgPrint( "NatIoctlSessionControl: status=%u\n", status );
#endif

    return status;
}


extern "C"
NTSTATUS
NatQuerySessionControl(
    IN  PVOID   DirectorContext,
    IN  UCHAR   Protocol,
    IN  ULONG   PublicAddress,
    IN  USHORT  PublicPort,
    IN  ULONG   RemoteAddress,
    IN  USHORT  RemotePort,
    OUT PULONG  PrivateAddress,
    OUT PUSHORT PrivatePort,
    OUT PVOID*  DirectorSessionContextp OPTIONAL
    )
/*++

NatQuerySessionControl

Routine Description:

    This routine is exported by the session-control module.

    It is invoked by the NAT to obtain the IP address and port to which
    a given incoming session should be directed.

Arguments:

    Protocol - NAT_PROTOCOL_TCP or NAT_PROTOCOL_UDP (See IPNAT.H).

    PublicAddress - the public address on which the session was received

    PublicPort - the public port on which the session was received

    RemoteAddress - the remote address from which the session originated

    RemotePort - the remote port from which the session originated

    PrivateAddress - receives the private address for the session

    PrivatePort - receives the private port for the session

Return Value:

    STATUS_SUCCESS if the session-control module has stored directions
    in 'PrivateAddress' and 'PrivatePort'; failure code otherwise.

--*/
{
    ULONG                       iHash;
    ULONG                       iF;
    ULONG                       iPrevF;
    ULONG                       iNext;
    DeclareTimeObject(          SesCtl );
    ULONG                       Now;
    ULONG                       cGrain;
    int                         fAtLeastOneServer;
    int                         fAnyServerAvailable;
    CKernelIpEndpointEx*        pIp;
    IPREF                       BestIpSoFar = (IPREF)-1;
    IPREF*                      pTopIp;
    IPREF*                      pEndIp;
    IPREF*                      pCurrentIp;
    CKernelServerDescription*   pServer;
    CKernelServerDescription*   BestServerSoFar = NULL;
    ULONG                       iP;
    ULONG                       cPublicIp;
    ULONG                       cServer;
    ULONG                       iS;
    ULONG                       cSize;
    HASH_ENTRY*                 NewHashEntries;
    HASH_ENTRY*                 pHash;
    int                         BestLoadSoFar = 0;
    KIRQL                       oldIrql;
    DWORD                       dwSticky;

    if ( IpMap.GetBuffer() == NULL )
    {
        return STATUS_ADDRESS_NOT_ASSOCIATED;
    }

    *DirectorSessionContextp = NULL;

    GetTime( SesCtl, Now );

#if NOISY_DBG
    DbgPrint( "NatQuerySessionControl: protocol %02x remote %08x:%04x to %08x:%04x time %u\n",
              Protocol,
              RemoteAddress,RemotePort,
              PublicAddress,PublicPort,
              Now );
#endif

    // hash bucket determined by XORing all bytes of public & remote address

    iHash = (PublicAddress ^ RemoteAddress) % NB_BUCKETS;

    LockIpMapAtDpcLevel();

    // check entries for expiration

    if ( HashBuckets[iHash].m_CheckExpiry < Now )
    {
        for ( iF = HashBuckets[iHash].m_HashEntry, iPrevF = EOCHAIN ; 
              iF != EOCHAIN ; 
              iF = iNext )
        {
            iNext = HashEntries[iF].m_NextHashEntry;

            if ( HashEntries[iF].m_Expiry < Now )
            {
#if NOISY_DBG
                DbgPrint( "NatQuerySessionControl: remove entry %u, expire %u prev link %u\n",
                          iF,
                          HashEntries[iF].m_Expiry, iPrevF );
#endif
                // remove it from hash chain

                if ( iPrevF != EOCHAIN )
                {
                    HashEntries[iPrevF].m_NextHashEntry = iNext;
                }
                else
                {
                    HashBuckets[iHash].m_HashEntry = iNext;
                }

                // insert it in free list

                HashEntries[iF].m_NextHashEntry = iFirstFreeHashEntry;
                iFirstFreeHashEntry = iF;
            }
            else
            {
                iPrevF = iF;
            }
        }

        HashBuckets[iHash].m_CheckExpiry = Now + CHECK_EXPIRY;
    }

    cPublicIp = IpMap.PublicIpCount();
    cServer = IpMap.ServerCount();

    // get index of public IP/port

    for ( iP = 0 ; 
          iP < cPublicIp ; 
          ++iP )
    {
        pIp = IpMap.GetPublicIpPtr( iP );
        if ( pIp->m_dwIpAddress == PublicAddress &&
             pIp->m_usPort == PublicPort )
        {
            dwSticky = pIp->m_dwSticky;
            break;
        }
    }

#if NOISY_DBG
    DbgPrint( "NatQuerySessionControl: %d public, %d servers, index public %d\n",
              cPublicIp, cServer, iP );
#endif

    if ( iP == cPublicIp )
    {
        // public IP not found in configuration : fail request

        UnlockIpMapFromDpcLevel();

#if NOISY_DBG
        DbgPrint( "NatQuerySessionControl: public IP not found, fail request\n" );
#endif

        return STATUS_ADDRESS_NOT_ASSOCIATED;
    }

    // check if RemoteAddress in sticky cache ( also check expiration for this cache line )
    //  if yes update expiration time, return addr

    for ( iF = HashBuckets[iHash].m_HashEntry ; 
          iF != EOCHAIN ; 
          iF = pHash->m_NextHashEntry )
    {
        pHash = HashEntries + iF;

        if ( pHash->m_RemoteAddress == RemoteAddress &&
             pHash->m_PublicRef == iP )
        {
            // we have a match : return cached address

            pIp = IpMap.GetPrivateIpEndpoint( pHash->m_PrivateRef );
            *PrivateAddress = pIp->m_dwIpAddress;
            *PrivatePort = pIp->m_usPort;

            // update mapping expiration time

            pHash->m_Expiry = Now + dwSticky;

#if NOISY_DBG
            DbgPrint( "NatQuerySessionControl: found in cache %08x:%04x, sticky %d new expire %u\n",
                      *PrivateAddress,*PrivatePort,
                      dwSticky, pHash->m_Expiry );
#endif

            UnlockIpMapFromDpcLevel();

            return STATUS_SUCCESS;
        }
    }

    // get private IP : find entry with non null private IP, if > 0 then decrease by
    // LOADBAL_NORMALIZED_TOTAL / cServer / 10.
    //  if no valid entry return public IP/port if no load avail entry reset all avail

    fAtLeastOneServer = FALSE;
    fAnyServerAvailable = FALSE;

    //
    // If no server then fail request, as at this point we know that the requested
    // public IP address is in our list, so access is denied by configuration
    //

    if ( cServer == 0 )
    {
        UnlockIpMapFromDpcLevel();

#if NOISY_DBG
        DbgPrint( "NatQuerySessionControl: no server avail, fail\n" );
#endif

        return STATUS_ADDRESS_NOT_ASSOCIATED;
    }

    //
    // load balancing granularity : based on # servers.
    // note that if cGrain > all base load availability for all servers
    // then load availability adjustment will loop several times, decreasing
    // efficiency.
    //

    cGrain = LOADBAL_NORMALIZED_TOTAL / cServer / 10;

again:

    pServer = IpMap.GetServerPtr( iCurrentServer );
    pEndIp = pCurrentIp = IpMap.GetPrivateIpRef( pServer, iP );
    pTopIp = IpMap.GetPrivateIpRef( IpMap.GetServerPtr( cServer ), iP );
    cSize = IpMap.GetKernelServerDescriptionSize();

    // locate entry with highest load available

    for ( ; 
          ; 
        )
    {
        if ( *pCurrentIp != (IPREF)-1 )
        {
            // mapping exist from current server to public IP/port

            if ( pServer->m_dwLoadAvail )
            {
                fAtLeastOneServer = TRUE;

                // check if available

                if ( pServer->m_LoadbalancedLoadAvail > BestLoadSoFar )
                {
                    BestServerSoFar = pServer;
                    BestIpSoFar = *pCurrentIp;
                    BestLoadSoFar = pServer->m_LoadbalancedLoadAvail;
                    fAnyServerAvailable = TRUE;
                }
            }
        }

        // advance to next server

        pServer = (CKernelServerDescription*)(((LPBYTE)pServer) + cSize);
        if ( (pCurrentIp = (IPREF *)(((LPBYTE)pCurrentIp) + cSize )) == pTopIp )
        {
            pServer = IpMap.GetServerPtr( 0 );
            pCurrentIp = IpMap.GetPrivateIpRef( pServer, iP );
        }
        // check if looked at all servers

        if ( pCurrentIp == pEndIp )
        {
            if ( ++iCurrentServer == cServer )
            {
                iCurrentServer = 0;
            }
            break;
        }
    }

    if ( !fAnyServerAvailable )
    {
        // check if at least one server can map the public IP/port

        if ( fAtLeastOneServer )
        {
            // adjust load balanced availability

            for ( iS = 0 ; iS < cServer ; ++iS )
            {
                pServer = IpMap.GetServerPtr( iS );
                pServer->m_LoadbalancedLoadAvail += pServer->m_dwLoadAvail;
            }

            goto again;
        }

        // no server for this public IP/port : fail request

        UnlockIpMapFromDpcLevel();

#if NOISY_DBG
        DbgPrint( "NatQuerySessionControl: no server for this addr avail, fail\n" );
#endif

        return STATUS_ADDRESS_NOT_ASSOCIATED;
    }
    else
    {
        BestServerSoFar->m_LoadbalancedLoadAvail -= cGrain;
        pIp = IpMap.GetPrivateIpEndpoint( BestIpSoFar );
        *PrivateAddress = pIp->m_dwIpAddress;
        *PrivatePort = pIp->m_usPort;
#if NOISY_DBG
        DbgPrint( "NatQuerySessionControl: found %08x:%04x, sticky %d new avail %d grain %d\n",
                  *PrivateAddress,*PrivatePort,
                  dwSticky, BestServerSoFar->m_LoadbalancedLoadAvail, cGrain );
#endif
    }

    //
    // insert in sticky cache if sticky duration not null,
    // don't check if already there ( dups are OK )
    //

    if ( dwSticky != 0 )
    {
        //
        // if no free entry need to extend hash table, insert in iFirstFreeHashEntry
        //

        if ( iFirstFreeHashEntry == EOCHAIN )
        {
            NewHashEntries = (HASH_ENTRY*)AllocBuffer( sizeof(HASH_ENTRY) * (cHashEntries + HASH_ALLOC_GRAIN) );

            if ( NewHashEntries == NULL )
            {
                UnlockIpMapFromDpcLevel();
#if NOISY_DBG
                DbgPrint( "NatQuerySessionControl: out of memory for %u hash entries\n",
                          cHashEntries );
#endif
                return STATUS_NO_MEMORY;
            }

            if ( HashEntries )
            {
                Copy_Memory( NewHashEntries, HashEntries, sizeof(HASH_ENTRY) * cHashEntries );
                FreeBuffer( HashEntries );
            }
            HashEntries = NewHashEntries;

            //
            // insert new entries in free chain
            //

            iFirstFreeHashEntry = cHashEntries;

            for ( iF = cHashEntries, cHashEntries += HASH_ALLOC_GRAIN - 1; 
                  iF < cHashEntries;
                  ++iF
                )
            {
                HashEntries[iF].m_NextHashEntry = iF + 1;
            }

            HashEntries[cHashEntries++].m_NextHashEntry = EOCHAIN;
        }

        //
        // add new entry to cache
        //

        iF = iFirstFreeHashEntry;
        pHash = HashEntries + iF;
        iFirstFreeHashEntry = pHash->m_NextHashEntry;

        pHash->m_RemoteAddress = RemoteAddress;
        pHash->m_PrivateRef = (USHORT)BestIpSoFar;
        pHash->m_PublicRef = (USHORT)iP;
        pHash->m_NextHashEntry = HashBuckets[iHash].m_HashEntry;
        pHash->m_Expiry = Now + dwSticky;
        HashBuckets[iHash].m_HashEntry = iF;
    }

    UnlockIpMapFromDpcLevel();

    return STATUS_SUCCESS;
}


extern "C"
NTSTATUS
IISNATDispatchIoctl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This function handled IOCTL to the IIS LB device driver.

Arguments:

    DeviceObject - Pointer to device object created by the system.
    Irp - I/O request packet

Return Value:

     NT status

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    NTSTATUS                status = STATUS_SUCCESS;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( IrpSp->Parameters.DeviceIoControl.IoControlCode )
    {
        case IOCTL_IISNATIO_SET_CONFIG:
            status = NatIoctlSessionControl( Irp );
            break;

        default:
            status = STATUS_INVALID_PARAMETER;
    }

    return status; 
}


extern "C"
NTSTATUS
IISNATDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This function Create for IIS LB device driver.

Arguments:

    DeviceObject - Pointer to device object created by the system.
    Irp - I/O request packet

Return Value:

     NT status

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;      // nothing to send back to user mode
    Irp->IoStatus.Status = status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

#if NOISY_DBG
    DbgPrint( "IISNATDispatchCreate: status=%u\n", status );
#endif

    return status; 
}


extern "C"
NTSTATUS
IISNATDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This function Close for IIS LB device driver.

Arguments:

    DeviceObject - Pointer to device object created by the system.
    Irp - I/O request packet

Return Value:

     NT status

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;      // nothing to send back to user mode
    Irp->IoStatus.Status = status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

#if NOISY_DBG
    DbgPrint( "IISNATDispatchClose: status=%u\n", status );
#endif

    return status; 
}


extern "C"
VOID
IISNATUnloadDriver(
    IN PDRIVER_OBJECT   DriverObject
    )
/*++

Routine Description:

    This function is called when driver is unloaded

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

     None

--*/
{
    UNICODE_STRING          uszDeviceString;
    UINT                    iOld;
    CKernelIpEndpointEx*    pOld;


    IoDeleteDevice( DriverObject->DeviceObject );

    RtlInitUnicodeString( &uszDeviceString, L"\\DosDevices\\" LSZDRIVERNAME );

    IoDeleteSymbolicLink( &uszDeviceString );

    if ( IpMap.GetBuffer() )
    {
        //
        // Unnotify all ports
        //

        for ( iOld = 0 ; 
              iOld < IpMap.PublicIpCount() ; 
              ++iOld )
        {
            pOld = IpMap.GetPublicIpPtr( iOld );

            if ( pOld->m_usUniquePort )
            {
                //
                // Ignore error : nothing we can do at this point
                //

                UnnotifyPort( pOld );
            }
        }

        FreeBuffer( IpMap.GetBuffer() );
    }

    ObDereferenceObject((PVOID)NatFileObject);
    ObDereferenceObject(NatDeviceObject);

    if ( HashEntries )
    {
        FreeBuffer( HashEntries );
    }

#if NOISY_DBG
    DbgPrint( "IISNATUnloadDriver: unloaded\n" );
#endif
}


extern "C"
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the IIS LB device driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

     The function value is the final status from the initialization operation.

--*/
{
    NTSTATUS        ntStatus = STATUS_SUCCESS;
    UNICODE_STRING  uszDriverString;
    UNICODE_STRING  uszDeviceString;
    UNICODE_STRING  NatDeviceString;
    PDEVICE_OBJECT  pDeviceObject;

    //
    // Get reference to NAT driver, necessary to allow safe calls to deregister port
    //

    RtlInitUnicodeString(&NatDeviceString, DD_IP_NAT_DEVICE_NAME);

    ntStatus =
        IoGetDeviceObjectPointer(
            &NatDeviceString,
            SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
            &NatFileObject,
            &NatDeviceObject
            );

    if (!NT_SUCCESS(ntStatus)) 
    {
        NatFileObject = NULL;
        NatDeviceObject = NULL;

#if NOISY_DBG
        DbgPrint( "DriverEntry: IoGetDeviceObjectPointer for NAT failed %08x\n", 
                  ntStatus );
#endif
        return ntStatus;
    }

    ObReferenceObject( NatDeviceObject );

    RtlInitUnicodeString( &uszDriverString, L"\\Device\\" LSZDRIVERNAME );

    ntStatus = IoCreateDevice( DriverObject,
                               0,
                               &uszDriverString,
                               FILE_DEVICE_UNKNOWN,
                               0,
                               FALSE,
                               &pDeviceObject );

#if NOISY_DBG
    DbgPrint( "DriverEntry: IoCreateDevice=%x\n", ntStatus );
#endif

    if ( ntStatus != STATUS_SUCCESS )
    {
        goto cleanup;
    }

    RtlInitUnicodeString( &uszDeviceString, L"\\DosDevices\\" LSZDRIVERNAME);

    ntStatus = IoCreateSymbolicLink( &uszDeviceString, &uszDriverString );

#if NOISY_DBG
    DbgPrint( "DriverEntry: IoCreateSymbolicLink=%x\n", ntStatus );
#endif

    if ( ntStatus != STATUS_SUCCESS )
    {
        IoDeleteDevice( pDeviceObject );

        goto cleanup;
    }

    NatRegisterSessionControl( 0 );

    DriverObject->DriverUnload                          = IISNATUnloadDriver;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = IISNATDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = IISNATDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = IISNATDispatchIoctl;

cleanup:

    if ( ntStatus != STATUS_SUCCESS )
    {
        ObDereferenceObject((PVOID)NatFileObject);
        ObDereferenceObject(NatDeviceObject);
    }

    return ntStatus;
}


extern "C"
NTSTATUS
NatDeleteSession(
    IN PVOID SessionHandle,
    IN PVOID DirectorContext,
    IN PVOID DirectorSessionContext
    )
/*++

Routine Description:

    This function is called by NAT for session deletion notification

Arguments:

    SessionHandle - NAT session handle
    DirectorContext - IIS LB per port context
    DirectorSessionContext - IIS LB per session context

Return Value:

     NT status

--*/
{
#if NOISY_DBG
    DbgPrint( "NatDeleteSession: session %08x\n",
              SessionHandle );
#endif

    return STATUS_SUCCESS;
}


NTSTATUS
NotifyPort(
    CKernelIpEndpointEx*    pEndp
    )
/*++

Routine Description:

    This function notify NAT that load balancing driver wants to handle
    specified port

Arguments:

    pEndp - endpoint descriptor

Return Value:

     NT status

--*/
{
    IO_STATUS_BLOCK             IoStatusBlock;
    PIRP                        Irp;
    NTSTATUS                    status;
    IP_NAT_REGISTER_DIRECTOR    RegisterDirector;

    RtlZeroMemory(&RegisterDirector, sizeof(RegisterDirector));

    RegisterDirector.Version                = IP_NAT_VERSION;
    RegisterDirector.Flags                  = 0;
    RegisterDirector.Protocol               = NAT_PROTOCOL_TCP;
    RegisterDirector.Port                   = pEndp->m_usUniquePort;
    RegisterDirector.DirectorContext        = NULL;

    RegisterDirector.QueryHandler           = NatQuerySessionControl;
    RegisterDirector.DeleteHandler          = NatDeleteSession;

#if defined(KERNEL_MODE)

    Irp =
        IoBuildDeviceIoControlRequest(
            IOCTL_IP_NAT_REGISTER_DIRECTOR,
            NatDeviceObject,
            (PVOID)&RegisterDirector,
            sizeof(RegisterDirector),
            (PVOID)&RegisterDirector,
            sizeof(RegisterDirector),
            FALSE,
            NULL,
            &IoStatusBlock
            );

    if (!Irp) 
    {
        status = STATUS_UNSUCCESSFUL;
    }
    else 
    {
        status = IoCallDriver(NatDeviceObject, Irp);
#if NOISY_DBG
        if ( !NT_SUCCESS(status) )
        {
            DbgPrint( "NotifyPort: IoCallDriver failed %08x\n", 
                      status );
        }
#endif
    }

    if ( NT_SUCCESS(status) )
    { 
        pEndp->m_pvDirectorHandle   = RegisterDirector.DirectorHandle;
        pQueryInfoSession           = RegisterDirector.QueryInfoSession;
        pDeregisterNat              = RegisterDirector.Deregister;
    }

#else

    pEndp->m_pvDirectorHandle = (LPVOID)0x12345678;
    status = STATUS_SUCCESS;

#endif

#if NOISY_DBG
    DbgPrint( "NotifyPort: %u, status %x handle %08x\n", pEndp->m_usUniquePort, status, pEndp->m_pvDirectorHandle );
#endif

    return status;
}


NTSTATUS
UnnotifyPort(
    CKernelIpEndpointEx*    pEndp
    )
/*++

Routine Description:

    This function notify NAT that load balancing driver does not want to handle
    specified port anymore

Arguments:

    pEndp - endpoint descriptor

Return Value:

     NT status

--*/
{
    NTSTATUS                    status;

    if ( pDeregisterNat )
    {
        status = pDeregisterNat( pEndp->m_pvDirectorHandle );
    }
    else
    {
        //
        // nothing to unregister in this case, so report success
        //

        status = STATUS_SUCCESS;    // STATUS_INVALID_PARAMETER;
    }

#if NOISY_DBG
    DbgPrint( "UnnotifyPort: %u, handle %08x Deregister %08x status %x\n", 
              pEndp->m_usUniquePort, 
              pEndp->m_pvDirectorHandle,
              pDeregisterNat,
              status );
#endif

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\driver\ipnat.h ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    ipnat.h

Abstract:

    Contains semi-public IOCTLS and data-structures related to
    the IP Network Address Translator.

Author:

    Abolade Gbadegesin (t-abolag) 11-July-1997

Revision History:

--*/

#ifndef _ROUTING_IP_NAT_H_
#define _ROUTING_IP_NAT_H_


#include <rtinfo.h>             // for RTR_INFO_BLOCK_HEADER
#include <ipinfoid.h>           // for IP_GENERAL_INFO_BASE

//
// Moved to ipinfoid.h
//
// #define IP_NAT_INFO             IP_GENERAL_INFO_BASE + 8


//
// MISCELLANEOUS DECLARATIONS
//

#define IP_NAT_VERSION          1

#define IP_NAT_SERVICE_NAME     "IPNAT"

#define DD_IP_NAT_DEVICE_NAME   L"\\Device\\IPNAT"


//
// IP header protocol-field constants
//

#define NAT_PROTOCOL_ICMP       0x01
#define NAT_PROTOCOL_IGMP       0x02
#define NAT_PROTOCOL_TCP        0x06
#define NAT_PROTOCOL_UDP        0x11
#define NAT_PROTOCOL_PPTP       0x2F



//
// IOCTL DECLARATIONS
//

#define FSCTL_IP_NAT_BASE       FILE_DEVICE_NETWORK

#define _IP_NAT_CTL_CODE(function, method, access) \
    CTL_CODE(FSCTL_IP_NAT_BASE, function, method, access)


//
// NAT-supported IOCTL constant declarations
//

#define IOCTL_IP_NAT_SET_GLOBAL_INFO \
    _IP_NAT_CTL_CODE(0, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_GLOBAL_INFO \
    _IP_NAT_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_CREATE_INTERFACE \
    _IP_NAT_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_DELETE_INTERFACE \
    _IP_NAT_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_BIND_INTERFACE \
    _IP_NAT_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_UNBIND_INTERFACE \
    _IP_NAT_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_SET_INTERFACE_INFO \
    _IP_NAT_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_INTERFACE_INFO \
    _IP_NAT_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_REGISTER_EDITOR \
    _IP_NAT_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_INTERFACE_STATISTICS \
    _IP_NAT_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_ENUMERATE_SESSION_MAPPINGS \
    _IP_NAT_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_REGISTER_DIRECTOR \
    _IP_NAT_CTL_CODE(11, METHOD_BUFFERED, FILE_WRITE_ACCESS)



//
// IOCTL_IP_NAT_SET_GLOBAL_INFO
//
// Invoked by the IP router-manager to supply the NAT with its configuration.
//


//
// IOCTL_IP_NAT_GET_GLOBAL_INFO
//
// Invoked by the IP router-manager to retrieve the NAT's configuration.
//


//
// Structure:   IP_NAT_GLOBAL_INFO
//
// Holds global configuration information for the NAT.
//

typedef struct _IP_NAT_GLOBAL_INFO {

    BOOL NATEnabled;            // used by IPRTRMGR
    ULONG TCPTimeoutSeconds;
    ULONG UDPTimeoutSeconds;

} IP_NAT_GLOBAL_INFO, *PIP_NAT_GLOBAL_INFO;




//
// IOCTL_IP_NAT_CREATE_INTERFACE
//
// Invoked by the IP router-manager to add router-interfaces to the NAT.
//


//
// Structure:   IP_NAT_CREATE_INTERFACE
//
// On output, 'NatInterfaceContext' contains the new interface's NAT-created
// context.
//

typedef struct _IP_NAT_CREATE_INTERFACE {

    IN ULONG RtrMgrIndex;
    IN PVOID RtrMgrContext;
    OUT PVOID NatInterfaceContext;

} IP_NAT_CREATE_INTERFACE, *PIP_NAT_CREATE_INTERFACE;




//
// IOCTL_IP_NAT_DELETE_INTERFACE
//
// Invoked by the IP router-manager to delete router-interfaces from the NAT.
//

//
// Structure:   IP_NAT_DELETE_INTERFACE
//
// On input, 'NatInterfaceContext' should contain the context for the interface
// to be deleted, as obtained from IOCTL_IP_NAT_CREATE_INTERFACE.
//

typedef struct _IP_NAT_DELETE_INTERFACE {

    IN PVOID NatInterfaceContext;

} IP_NAT_DELETE_INTERFACE, *PIP_NAT_DELETE_INTERFACE;




//
// IOCTL_IP_NAT_BIND_INTERFACE
//
// Invoked by the IP router-manager to set the interface's binding.
//

//
// Structure:   IP_NAT_BIND_INTERFACE
//
// Holds the binding for the specified interface.
// The field 'BindingInfo' should be the beginning of
// an IP_ADAPTER_BINDING_INFO structure (see routprot.h) which
// contains the interface's binding.
//

typedef struct _IP_NAT_BIND_INTERFACE {

    IN PVOID NatInterfaceContext;
    IN ULONG BindingInfo[1];

} IP_NAT_BIND_INTERFACE, *PIP_NAT_BIND_INTERFACE;





//
// IOCTL_NAT_UNBIND_INTERFACE
//
// Invoked by the IP router-manager to remove binding from an interface.
//


//
// Structure:   IP_NAT_UNBIND_INTERFACE
//
// Used to indicate to the NAT which interface should be unbound.
//

typedef struct _IP_NAT_UNBIND_INTERFACE {

    IN PVOID NatInterfaceContext;

} IP_NAT_UNBIND_INTERFACE, *PIP_NAT_UNBIND_INTERFACE;




//
// IOCTL_IP_NAT_SET_INTERFACE_INFO
//
// Invoked by the IP router-manager to set configuration information
// on boundary-interfaces, i.e. interfaces over which translation takes place.
//
// Uses 'IP_NAT_INTERFACE_INFO' for input.
//

//
// IOCTL_IP_NAT_GET_INTERFACE_INFO
//
// Invoked by the IP router-manager to get configuration information on
// boundary interfaces.
//
// uses 'IP_NAT_INTERFACE_INFO' for input and output.
//

// 
// Structure:   IP_NAT_INTERFACE_INFO
//
// 'NatInterfaceContext' identifies the interface to be configured or whose
// configuration is being retrieved, and is the context supplied on output from
// 'IOCTL_IP_NAT_CREATE_INTERFACE'.
//
// The configuration information uses the RTR_INFO_BLOCK_HEADER structure
// of rtinfo.h. See below for the type-codes for structures which may appear
// after IP_NAT_INTERFACE_INFO.Header within the RTR_TOC_ENTRY.InfoType field.
//

typedef struct _IP_NAT_INTERFACE_INFO {

    IN PVOID NatInterfaceContext;
    IN ULONG Flags;
    IN RTR_INFO_BLOCK_HEADER Header;

} IP_NAT_INTERFACE_INFO, *PIP_NAT_INTERFACE_INFO;



//
// Flags for IP_NAT_INTERFACE_INFO.Flags
//
// _BOUNDARY: set to mark interface as boundary-interface.
// _NAPT: set to enable address-sharing via port-translation.
//

#define IP_NAT_INTERFACE_FLAGS_BOUNDARY 0x00000001

#define IP_NAT_INTERFACE_FLAGS_NAPT     0x00000002

#define IP_NAT_INTERFACE_FLAGS_ALL      0x00000003



//
// Type-codes for the IP_NAT_INTERFACE_INFO.Header.TocEntry[] array.
//
// The structures which correspond to each info-type are given below.
//

#define IP_NAT_PORT_RANGE_TYPE          IP_GENERAL_INFO_BASE + 1
#define IP_NAT_ADDRESS_RANGE_TYPE       IP_GENERAL_INFO_BASE + 2
#define IP_NAT_PORT_MAPPING_TYPE        IP_GENERAL_INFO_BASE + 3
#define IP_NAT_ADDRESS_MAPPING_TYPE     IP_GENERAL_INFO_BASE + 4


//
// Structure:   IP_NAT_PORT_RANGE
//
// Holds a range of port numbers which the NAT is allowed to use
// on a boundary interface.
//
// In the case of an interface with a pool of addresses, 'PublicAddress'
// should specify which of those addresses this static-mapping applies to.
//

typedef struct _IP_NAT_PORT_RANGE {

    UCHAR Protocol;
    ULONG PublicAddress;  // OPTIONAL - see IP_NAT_ADDRESS_UNSPECIFIED
    USHORT StartPort;
    USHORT EndPort;

} IP_NAT_PORT_RANGE, *PIP_NAT_PORT_RANGE;



//
// Structure:   IP_NAT_ADDRESS_RANGE
//
// Holds a range of addresses which are part of the address-pool
// for a boundary interface.
//
// An address-pool consists of a list of these structures.
//
// Note: overlapping address-ranges are not supported;
//  discontiguous subnet masks are also unsupported.
//

typedef struct _IP_NAT_ADDRESS_RANGE {

    ULONG StartAddress;
    ULONG EndAddress;
    ULONG SubnetMask;

} IP_NAT_ADDRESS_RANGE, *PIP_NAT_ADDRESS_RANGE;



//
// Structure:   IP_NAT_PORT_MAPPING
//
// Holds a static mapping which ties a public-side port on this NAT interface
// to a particular private machine's address/port.
//
// In the case of an interface with a pool of addresses, 'PublicAddress'
// should specify which of those addresses this static-mapping applies to.
//

typedef struct _IP_NAT_PORT_MAPPING {

    UCHAR Protocol;
    USHORT PublicPort;
    ULONG PublicAddress;  // OPTIONAL - see IP_NAT_ADDRESS_UNSPECIFIED
    USHORT PrivatePort;
    ULONG PrivateAddress;

} IP_NAT_PORT_MAPPING, *PIP_NAT_PORT_MAPPING;


//
// Constant for 'PublicAddress' in IP_NAT_PORT_RANGE and IP_NAT_PORT_MAPPING;
// may be specified for boundary-interfaces which have no address-pool, in
// which case the range/mapping is for the boundary-interface's sole address.
//

#define IP_NAT_ADDRESS_UNSPECIFIED  ((ULONG)0)


//
// Structure:   IP_NAT_ADDRESS_MAPPING
//
// Holds a static mapping which ties an address from this NAT interface's
// address pool to a particular private-machine's address.
//
// Note that this address must fall within one of the ranges comprising
// the pool as specified by the IP_NAT_ADDRESS_RANGE structures.
//

typedef struct _IP_NAT_ADDRESS_MAPPING {

    ULONG PrivateAddress;
    ULONG PublicAddress;
    BOOL AllowInboundSessions;

} IP_NAT_ADDRESS_MAPPING, *PIP_NAT_ADDRESS_MAPPING;




//
// IOCTL_IP_NAT_REGISTER_EDITOR
//
// This IOCTL is invoked by a kernel-mode component which wishes to act
// as an editor for packets which match a particular session-description.
//

//
// Enum:        IP_NAT_DIRECTION
//
// Lists the session-flow directions for which an editor may register.
// IpNatInbound refers to the 'public-to-private' flow, while 
// IpNatOutbound refers to the 'private-to-public' flow.
//

typedef enum _IP_NAT_DIRECTION {

    IpNatInbound = 0,
    IpNatOutbound = 1

} IP_NAT_DIRECTION, *PIP_NAT_DIRECTION;


//
// Editor function prototypes
//

//
// For synchronization reasons, 'CreateHandler' and 'DeleteHandler' 
// CANNOT invoke any helper functions other than 'QueryInfoSession'.
//

typedef NTSTATUS
(*PNAT_EDITOR_CREATE_HANDLER)(
    IN PVOID EditorContext,
    IN ULONG PrivateAddress,
    IN USHORT PrivatePort,
    IN ULONG PublicAddress,
    IN USHORT PublicPort,
    IN ULONG RemoteAddress,
    IN USHORT RemotePort,
    OUT PVOID* EditorSessionContextp   OPTIONAL
    );

typedef NTSTATUS
(*PNAT_EDITOR_DELETE_HANDLER)(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext
    );

typedef NTSTATUS
(*PNAT_EDITOR_DATA_HANDLER)(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    );


//
// Helper function prototypes
//

typedef NTSTATUS
(*PNAT_HELPER_CREATE_TICKET)(
    IN PVOID InterfaceHandle,
    IN UCHAR Protocol,
    IN ULONG PrivateAddress,
    IN USHORT PrivatePort,
    IN ULONG TimeoutSeconds,
    OUT PULONG PublicAddress,
    OUT PUSHORT PublicPort
    );

typedef NTSTATUS
(*PNAT_HELPER_DELETE_TICKET)(
    IN PVOID InterfaceHandle,
    IN ULONG PublicAddress,
    IN UCHAR Protocol,
    IN USHORT PublicPort
    );

typedef NTSTATUS
(*PNAT_HELPER_DEREGISTER_EDITOR)(
    IN PVOID EditorHandle
    );


typedef NTSTATUS
(*PNAT_HELPER_DISSOCIATE_SESSION)(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    );

typedef NTSTATUS
(*PNAT_HELPER_EDIT_SESSION)(
    IN PVOID DataHandle,
    IN PVOID RecvBuffer,
    IN ULONG OldDataOffset,
    IN ULONG OldDataLength,
    IN PUCHAR NewData,
    IN ULONG NewDataLength
    );

typedef VOID
(*PNAT_HELPER_QUERY_INFO_SESSION)(
    IN PVOID SessionHandle,
    IN PULONG PrivateAddress  OPTIONAL,
    IN PUSHORT PrivatePort     OPTIONAL,
    IN PULONG RemoteAddress   OPTIONAL,
    IN PUSHORT RemotePort      OPTIONAL,
    IN PULONG PublicAddress   OPTIONAL,
    IN PUSHORT PublicPort      OPTIONAL
    );

typedef VOID
(*PNAT_HELPER_TIMEOUT_SESSION)(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    );


//
// Structure:   IP_NAT_REGISTER_EDITOR
//
// The editor uses this structure to register itself with the NAT,
// and to obtain entrypoints of helper-functions provided by the NAT.
//
// On input, 'EditorContext' should contain a value which the NAT will
// pass to the editor's provided functions to serve as identification.
//
// On output, 'EditorHandle' contains the handle which the editor should
// pass to the NAT's helper functions to identify itself.
// 

typedef struct _IP_NAT_REGISTER_EDITOR {

    IN ULONG Version;
    IN ULONG Flags;
    IN UCHAR Protocol;
    IN USHORT Port;
    IN IP_NAT_DIRECTION Direction;

    IN PVOID EditorContext;

    IN PNAT_EDITOR_CREATE_HANDLER CreateHandler;            // OPTIONAL
    IN PNAT_EDITOR_DELETE_HANDLER DeleteHandler;            // OPTIONAL
    IN PNAT_EDITOR_DATA_HANDLER InboundDataHandler;         // OPTIONAL
    IN PNAT_EDITOR_DATA_HANDLER OutboundDataHandler;        // OPTIONAL

    OUT PVOID EditorHandle;

    OUT PNAT_HELPER_CREATE_TICKET CreateTicket;
    OUT PNAT_HELPER_DELETE_TICKET DeleteTicket;
    OUT PNAT_HELPER_DEREGISTER_EDITOR Deregister;
    OUT PNAT_HELPER_DISSOCIATE_SESSION DissociateSession;
    OUT PNAT_HELPER_EDIT_SESSION EditSession;
    OUT PNAT_HELPER_QUERY_INFO_SESSION QueryInfoSession;
    OUT PNAT_HELPER_TIMEOUT_SESSION TimeoutSession;

} IP_NAT_REGISTER_EDITOR, *PIP_NAT_REGISTER_EDITOR;


#define IP_NAT_EDITOR_FLAGS_RESIZE      0x00000001


//
// IOCTL_IP_NAT_REGISTER_DIRECTOR
//
// This IOCTL is invoked by a kernel-mode component that wishes to be consulted
// about the direction of incoming TCP/UDP sessions.
// 
// Such a component, if installed, is consulted by the NAT
// to determine dynamically how to direct inbound sessions. The module
// could, for instance, be installed to direct sessions destined for
// a cluster of HTTP servers in such a way as to balance the load across
// the servers via round-robin or other means.
//

//
// Director function prototypes
//

typedef NTSTATUS
(*PNAT_DIRECTOR_QUERY_SESSION)(
    IN PVOID DirectorContext,
    IN UCHAR Protocol,
    IN ULONG PublicAddress,
    IN USHORT PublicPort,
    IN ULONG RemoteAddress,
    IN USHORT RemotePort,
    OUT PULONG PrivateAddress,
    OUT PUSHORT PrivatePort,
    OUT PVOID* Contextp OPTIONAL
    );

typedef NTSTATUS
(*PNAT_DIRECTOR_DELETE_SESSION)(
    IN PVOID SessionHandle,
    IN PVOID DirectorContext,
    IN PVOID DirectorSessionContext
    );

//
// Director-helper function prototypes
//

typedef NTSTATUS
(*PNAT_HELPER_DEREGISTER_DIRECTOR)(
    IN PVOID DirectorHandle
    );


//
// Structure:   IP_NAT_REGISTER_DIRECTOR
//
// The director uses this structure to register itself with the NAT.
//

typedef struct _IP_NAT_REGISTER_DIRECTOR {

    IN ULONG Version;
    IN ULONG Flags;
    IN UCHAR Protocol;
    IN USHORT Port;

    IN PVOID DirectorContext;

    IN PNAT_DIRECTOR_QUERY_SESSION QueryHandler;
    IN PNAT_DIRECTOR_DELETE_SESSION DeleteHandler;

    OUT PVOID DirectorHandle;
    OUT PNAT_HELPER_QUERY_INFO_SESSION QueryInfoSession;
    OUT PNAT_HELPER_DEREGISTER_DIRECTOR Deregister;

} IP_NAT_REGISTER_DIRECTOR, *PIP_NAT_REGISTER_DIRECTOR;



//
// IOCTL_IP_NAT_GET_INTERFACE_STATISTICS
//
// This IOCTL is invoked to retrieve per-interface statistics.
//


//
// Structure:   IP_NAT_INTERFACE_STATISTICS
//
// Used for retrieving statistics. On input, 'NatInterfaceContext'
// should contain the context of the NAT interface whose statistics
// are to be obtained.
//

typedef struct _IP_NAT_INTERFACE_STATISTICS {

    IN PVOID NatInterfaceContext;
    OUT ULONG TotalMappings;
    OUT ULONG InboundMappings;
    OUT ULONG InboundPacketsRejected;
    OUT ULONG OutboundPacketsRejected;

} IP_NAT_INTERFACE_STATISTICS, *PIP_NAT_INTERFACE_STATISTICS;



//
// IOCTL_IP_NAT_ENUMERATE_SESSION_MAPPINGS
//
// This IOCTL is invoked to enumerate the dynamic TCP and UDP mappings
// for an interface.
//

//
// Structure:   IP_NAT_SESSION_MAPPING
//
// This structure holds information for a single mapping
//

typedef struct _IP_NAT_SESSION_MAPPING {

    IP_NAT_DIRECTION Direction;
    UCHAR Protocol;       // see NAT_PROTOCOL_* above
    ULONG PrivateAddress;
    USHORT PrivatePort;
    ULONG PublicAddress;
    USHORT PublicPort;
    ULONG RemoteAddress;
    USHORT RemotePort;
    ULONG IdleTime;       // in seconds
    
} IP_NAT_SESSION_MAPPING, *PIP_NAT_SESSION_MAPPING;


//
// Structure:   IP_NAT_ENUMERATE_SESSION_MAPPINGS
//
// Used for enumerate session mappings. On input, 'NatInterfaceContext'
// should hold the context for the interface whose mappings are to be
// enumerated. On the first call to this routine, 'EnumerateContext'
// should be zeroed out; it will be filled by the NAT with information
// to be passed back down as the enumeration continues. To indicate
// there are no items remaining, the NAT will set EnumerateContext[0] to 0.
//

typedef struct _IP_NAT_ENUMERATE_SESSION_MAPPINGS {

    IN PVOID NatInterfaceContext;
    IN OUT ULONG EnumerateContext[4];
    OUT ULONG EnumerateCount;
    OUT IP_NAT_SESSION_MAPPING EnumerateTable[1];
    
} IP_NAT_ENUMERATE_SESSION_MAPPINGS, *PIP_NAT_ENUMERATE_SESSION_MAPPINGS;



#endif // _ROUTING_IP_NAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\filter\iislbf.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    iislbf.c

Abstract:

    This module filters requests, redirecting IE3 requests coming in through proxy

Author:

    Philippe Choquier ( phillich )

--*/

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include <iisfiltp.h>
#include <inetinfo.h>
#include <w3svc.h>
#include <iiscnfgp.h>

#include <dbgutil.h>
#include <buffer.hxx>
#include <multisz.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>

#ifndef _NO_TRACING_

#define PRINTF( x )     { char buff[256]; wsprintf x; DBGPRINTF((DBG_CONTEXT, buff)); }

#else

#if DBG
#define PRINTF( x )     { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define PRINTF( x )
#endif

#endif

#if 0 && DBG
#define NOISY_PRINTF( x )     { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define NOISY_PRINTF( x )
#endif

}

#include    "mbsink.hxx"

#define LockGlobals()         EnterCriticalSection( &csGlobalLock )
#define UnlockGlobals()       LeaveCriticalSection( &csGlobalLock );

//
//  Globals
//

CRITICAL_SECTION    csGlobalLock;

LIST_ENTRY          g_RedirList;
IMDCOM*             g_pMDObject = NULL;
BOOL                g_fNotificationRequested = FALSE;

DECLARE_DEBUG_PRINTS_OBJECT();
#include <initguid.h>
DEFINE_GUID(IisLBFiltGuid, 
0x784d892D, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

class CUserAgentListEntry {
public:
    LIST_ENTRY  m_ListEntry;
    STR         m_strUserAgent;
} ;


class CRedirEntry {
public:

    CRedirEntry()
    {
        InitializeListHead( &m_UserAgentListHead );
    }

    ~CRedirEntry()
    {
        while ( !IsListEmpty( &m_UserAgentListHead ))
        {
            LIST_ENTRY*          pEntry;
            CUserAgentListEntry* pcci;

            pcci = CONTAINING_RECORD( m_UserAgentListHead.Flink,
                                      CUserAgentListEntry,
                                      m_ListEntry );

            RemoveEntryList( &pcci->m_ListEntry );

            delete pcci;
        }
    }

    BOOL 
    LookForUserAgent( 
        LPSTR pszUserAgent 
        )
    {
        CUserAgentListEntry*    pcci;
        LIST_ENTRY*             pEntry;

        for ( pEntry  = m_UserAgentListHead.Flink;
              pEntry != &m_UserAgentListHead;
              pEntry  = pEntry->Flink )
        {
            pcci = CONTAINING_RECORD( pEntry, CUserAgentListEntry, m_ListEntry );
            if ( strstr( pszUserAgent, pcci->m_strUserAgent.QueryStr() ) )
            {
                return TRUE;
            }
        }

        return FALSE;
    }

    BOOL
    AddUserAgent(
        LPSTR   pszUserAgent
        )
    {
        CUserAgentListEntry*    pcci;

        if ( pcci = new CUserAgentListEntry )
        {
            if ( pcci->m_strUserAgent.Copy( pszUserAgent ) )
            {
                InsertTailList( &m_UserAgentListHead, &pcci->m_ListEntry );
                return TRUE;
            }
            else
            {
                delete pcci;
            }
        }

        return FALSE;
    }

    LIST_ENTRY  m_ListEntry;
    STR         m_strHost;
    LIST_ENTRY  m_UserAgentListHead;    // list of CUserAgentListEntry
    STR         m_strRedirectedHost;
} ;


#define DEFAULT_HTTP_PORT       80

//
//  Private prototypes
//

BOOL
LbMetabaseUpdateNotification(
    );

DWORD
OnPreprocHeaders(
    HTTP_FILTER_CONTEXT *         pfc,
    HTTP_FILTER_PREPROC_HEADERS * pvData
    );

DWORD
OnEndOfNetSession(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    );

BOOL 
IsClientProxyAndIe3( 
    HTTP_FILTER_CONTEXT *         pfc,
    HTTP_FILTER_PREPROC_HEADERS * pvData,
    CRedirEntry*                  pRedirEntry
    );

BOOL
GetRedirectedHost(
    HTTP_FILTER_CONTEXT*    pfc,
    LPSTR                   pszServer,
    LPSTR                   pszMdPath,
    CRedirEntry**           pRedirEntry
    );

BOOL
GetStrHeader( 
    HTTP_FILTER_PREPROC_HEADERS * pvData,
    HTTP_FILTER_CONTEXT*    pfc,
    LPSTR                   pszHeader,
    STR*                    pstr
    );

BOOL
GetStrVariable( 
    HTTP_FILTER_CONTEXT*    pfc,
    LPSTR                   pszVariable,
    STR*                    pstr
    );

DWORD
SendRedirectMessage(
    HTTP_FILTER_PREPROC_HEADERS * pvData,
    HTTP_FILTER_CONTEXT *   pfc,
    LPSTR                   pszHost
    );

BOOL
WINAPI
TerminateFilter(
    DWORD dwFlags
    )
/*++

Routine Description:

    Terminate filter DLL

Arguments:

    dwFlags

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LIST_ENTRY * pEntry;
    CRedirEntry * pcci;

    if ( g_fNotificationRequested )
    {
        TerminateMetabaseSink();
    }

    // flush redirection cache

    while ( !IsListEmpty( &g_RedirList ))
    {
        pcci = CONTAINING_RECORD( g_RedirList.Flink,
                                  CRedirEntry,
                                  m_ListEntry );

        RemoveEntryList( &pcci->m_ListEntry );

        delete pcci;
    }

    DELETE_DEBUG_PRINT_OBJECT( );

    DeleteCriticalSection( &csGlobalLock );

    return TRUE;
}


BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
/*++

Routine Description:

    Get filter version

Arguments:

    pVer - to be updated with filter version

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    pVer->dwFilterVersion = MAKELONG( 0, 5 );   // Version 5.0

    //
    //  Specify the types and order of notification
    //

    pVer->dwFlags = (SF_NOTIFY_SECURE_PORT        |
                     SF_NOTIFY_NONSECURE_PORT     |

                     SF_NOTIFY_PREPROC_HEADERS    |
#if 0
                     SF_NOTIFY_END_OF_NET_SESSION |
#endif

                     SF_NOTIFY_ORDER_DEFAULT);

    strcpy( pVer->lpszFilterDesc, "IIS Load Balancing filter version, v5.0" );

    INITIALIZE_CRITICAL_SECTION( &csGlobalLock );

    InitializeListHead( &g_RedirList );

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "LB", IisLBFiltGuid );
#else
    CREATE_DEBUG_PRINT_OBJECT( "LB" );
#endif

    return TRUE;
}


DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData )
/*++

Routine Description:

    Filter proc

Arguments:

    pfc - filter context
    NotificationType - Notification Type
    pvData - Notification Type specific data

Return Value:

    Filter status

--*/
{
    DWORD   dwRet;
    BOOL    fSeen;

    //
    //  Check if we have not seen this context so far
    //

    if ( !(fSeen = (BOOL)pfc->pFilterContext) ) // BUGBUG64
    {
        pfc->pFilterContext = (VOID *)TRUE;
    }

    //
    //  Indicate this notification to the appropriate routine
    //

    switch ( NotificationType )
    {
    case SF_NOTIFY_PREPROC_HEADERS:

        dwRet = fSeen ? SF_STATUS_REQ_NEXT_NOTIFICATION
                      : OnPreprocHeaders( pfc,
                                          (PHTTP_FILTER_PREPROC_HEADERS) pvData );
        break;

#if 0
    case SF_NOTIFY_END_OF_NET_SESSION:

        dwRet = OnEndOfNetSession( pfc,
                                   (PHTTP_FILTER_LOG) pvData );

        break;
#endif

    default:
        dwRet = SF_STATUS_REQ_NEXT_NOTIFICATION;
        break;
    }

    return dwRet;
}


DWORD
OnPreprocHeaders(
    HTTP_FILTER_CONTEXT *         pfc,
    HTTP_FILTER_PREPROC_HEADERS * pvData
    )
/*++

Routine Description:

    Pre-proc header notification

Arguments:

    pfc - filter context
    pvData - Pre-proc headers notification structure

Return Value:

    Filter status

--*/
{
    CHAR            achHost[512];
    DWORD           cb;
    LPSTR           pszRedirHost;    
    LPSTR           pMdPath;
    CRedirEntry*    pRedirEntry;
    BOOL            fSt;

    // get metabase path for server instance

    if ( !pfc->ServerSupportFunction( pfc,
                                      SF_REQ_GET_PROPERTY,
                                      (LPSTR*)&pMdPath,
                                      (UINT)SF_PROPERTY_MD_PATH,
                                      NULL ) )
    {
        ASSERT( FALSE );

        return SF_STATUS_REQ_ERROR;
    }

    // get redirect host for this server

    LockGlobals();
    if ( fSt = GetRedirectedHost( pfc, pMdPath, pMdPath, &pRedirEntry ) )
    {
        pszRedirHost = pRedirEntry->m_strRedirectedHost.QueryStr();
    }
    UnlockGlobals();
            
    if ( fSt &&
         *pszRedirHost &&
         IsClientProxyAndIe3( pfc, pvData, pRedirEntry ) )
    {
        //
        //  Get the host header
        //

        cb = sizeof( achHost );
        if ( !pvData->GetHeader( pfc,
                                 "Host:",
                                 achHost,
                                 &cb ))
        {
            //
            // Can't safely redirect in this case : no way to check for loops.
            // Should not happen if client is IE3 anyway : Host should always be there
            //

            return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }

        if ( _stricmp( pszRedirHost, achHost ) )
        {
            return SendRedirectMessage( pvData, pfc, pszRedirHost );
        }
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}


DWORD
OnEndOfNetSession(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    )
/*++

Routine Description:

    End of network session notification

Arguments:

    pfc - filter context
    pvData - End of network session notification structure

Return Value:

    Filter status

--*/
{
    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}


DWORD
SendRedirectMessage(
    HTTP_FILTER_PREPROC_HEADERS * pvData,
    HTTP_FILTER_CONTEXT *   pfc,
    LPSTR                   pszHost
    )
/*++

Routine Description:

    Send a redirect ( 302 ) http response

Arguments:

    pvData - Pre-proc headers notification structure
    pfc - filter context
    pszHost - host name to redirect to

Return Value:

    Filter status

--*/
{
    DWORD       cbText;
    DWORD       cb;
    STACK_STR(  strRedir, 512);
    STACK_STR(  strUrl, 256 );
    STACK_STR(  strPort, 16 );
    LPSTR       pszUrl;

    if ( !GetStrHeader( pvData, pfc, "url", &strUrl ) ||
         !GetStrVariable( pfc, "SERVER_PORT", &strPort ) )
    {
        return SF_STATUS_REQ_ERROR;
    }

    //
    // remove host name for fully qualified URLs
    //

    if ( !memcmp( "http://", strUrl.QueryStr(), sizeof("http://")-1 ) )
    {
        if ( ( pszUrl = strchr( strUrl.QueryStr() + sizeof("http://") - 1, '/' ) ) == NULL )
        {
            return SF_STATUS_REQ_ERROR;
        }
    }
    else
    {
        pszUrl = strUrl.QueryStr();
    }

    //
    // build URL : http[s]://host[:port]url
    // where [s] is used for secure connections
    // and [:port] is added for non default HTTP port ( i.e not 80 )
    //

    if ( !strRedir.Copy( "Location: http" ) ||
         (pfc->fIsSecurePort && 
          !strRedir.Append( "s" )) ||
         !strRedir.Append( "://" ) ||
         !strRedir.Append( pszHost ) ||
         (atoi(strPort.QueryStr()) != DEFAULT_HTTP_PORT  &&
          (!strRedir.Append( ":" ) ||
           !strRedir.Append( strPort ))) ||
         !strRedir.Append( pszUrl ) ||
         !strRedir.Append( "\r\nContent-Length: 0\r\n\r\n" ) )
    {
        return SF_STATUS_REQ_ERROR;
    }

    pfc->ServerSupportFunction( pfc,
                                SF_REQ_SEND_RESPONSE_HEADER,
                                "302 Redirect",
                                (DWORD) strRedir.QueryStr(),    // BUGBUG64
                                0 );

    return SF_STATUS_REQ_FINISHED;
}
 

BOOL 
IsClientProxyAndIe3( 
    HTTP_FILTER_CONTEXT *         pfc,
    HTTP_FILTER_PREPROC_HEADERS * pvData,
    CRedirEntry*                  pRedirEntry
    )
/*++
    Description:

        Check if request was issued by a proxy, as determined by following rules :
        - "Via:" header is present (HTTP/1.1)
        - "User-Agent:" contains "via ..." (CERN proxy)

        If proxy is detected then request is checked for IE3, as indicated
        by presence of "MSIE 3." in "User-Agent:" header

    Arguments:
        pvData
        pRedirEntry - cache entry giving access to user agent list

    Returns:
        TRUE if client request was issued by proxy

--*/
{
    LPSTR   pUA;
    UINT    cUA;
    LPSTR   pEnd;
    DWORD   cb;
    CHAR    achHeader[256];
    CHAR    achUserAgent[256];


    cb = sizeof( achHeader );
    if ( pvData->GetHeader( pfc,
                            "Via:",
                            achHeader,
                            &cb ))
    {
        goto get_ua;
    }

    // HTTP 1.1 then if proxy used then 'Via' will be present, so we know
    // we are not using a proxy at this point.

    cb = sizeof( achHeader );
    if ( pvData->GetHeader( pfc,
                            "version",
                            achHeader,
                            &cb ))
    {
        if ( strcmp( "HTTP/1.1", achHeader ) <= 0 )
        {
            return FALSE;
        }
    }

    cb = sizeof( achUserAgent );
    if ( !pvData->GetHeader( pfc,
                             "User-agent:",
                             achUserAgent,
                             &cb ))
    {
        //
        // If no user-agent field then assume worst case : IE3 through proxy
        //

        return TRUE;
    }

    pUA = achUserAgent;
    cUA = strlen( achUserAgent );
    pEnd = pUA + cUA - (sizeof("ia ")-1);

    //
    // scan for "[Vv]ia[ :]" in User-Agent: header
    //

    while ( pUA < pEnd )
    {
        if ( *pUA == 'V' || *pUA == 'v' )
        {
            if ( pUA[1] == 'i' &&
                 pUA[2] == 'a' &&
                 (pUA[3] == ' ' || pUA[3] == ':') )
            {
                goto check_ua;
            }
        }
        ++pUA;
    }

    return FALSE;

get_ua:

    cb = sizeof( achUserAgent );
    if ( !pvData->GetHeader( pfc,
                             "User-agent:",
                             achUserAgent,
                             &cb ))
    {
        //
        // If no user-agent field then assume worst case : IE3
        //

        return TRUE;
    }

check_ua:

    return pRedirEntry->LookForUserAgent( achUserAgent );
}


BOOL
GetRedirectedHost(
    HTTP_FILTER_CONTEXT*    pfc,
    LPSTR                   pszServer,
    LPSTR                   pszMdPath,
    CRedirEntry**           pRedirEntry
    )
/*++

Routine Description:

    Get redirected host for a given server from metabase
    Must be inside global lock before calling this function

Arguments:

    pfc - filter context
    pszServer - current server
    pszMdPath - Metabase path to this server
    pRedirEntry - cache entry giving access to redirected host & user agent list

Return Value:

    TRUE if entry found or created, otherwise FALSE

--*/
{
    CRedirEntry*    pcci;
    LIST_ENTRY *    pEntry;
    LPCSTR          pUA;
    MULTISZ         msz;
    UINT            cServ = strlen( pszServer );

    for ( pEntry  = g_RedirList.Flink;
          pEntry != &g_RedirList;
          pEntry  = pEntry->Flink )
    {
        pcci = CONTAINING_RECORD( pEntry, CRedirEntry, m_ListEntry );
        if ( cServ == pcci->m_strHost.QueryCCH() &&
             !memcmp( pcci->m_strHost.QueryStr(), pszServer, cServ ) )
        {
            *pRedirEntry = pcci;

            return TRUE;
        }
    }

    //
    // Not found : must create new entry
    //

    if ( (pcci = new CRedirEntry) == NULL )
    {
        return FALSE;
    }

    if ( g_pMDObject == NULL )
    {
        // get Metabase Interface

        if ( !pfc->ServerSupportFunction( pfc,
                                    SF_REQ_GET_PROPERTY,
                                    (IMDCOM*)&g_pMDObject,
                                    (UINT)SF_PROPERTY_MD_IF,
                                    NULL ) )
        {
            ASSERT( FALSE );

            delete pcci;
            return FALSE;
        }
    }

    if ( !pcci->m_strHost.Copy( pszServer ) )
    {
        delete pcci;
        return FALSE;
    }

    if ( !g_fNotificationRequested )
    {
        if ( InitializeMetabaseSink( g_pMDObject, 
                                     LbMetabaseUpdateNotification ) )
        {
            g_fNotificationRequested = TRUE;
        }
        else
        {
            delete pcci;
            return FALSE;
        }
    }

    MB                mb( g_pMDObject );

    if ( !mb.Open( pszMdPath ) )
    {
        delete pcci;
        return FALSE;
    }

    if ( !mb.GetStr( "",
                     MD_LB_REDIRECTED_HOST,
                     IIS_MD_UT_SERVER,
                     &pcci->m_strRedirectedHost ) )
    {
        // default is empty host, i.e no redirection
    }

    if ( !mb.GetMultisz( "",
                         MD_LB_USER_AGENT_LIST,
                         IIS_MD_UT_SERVER,
                         &msz ) )
    {
        //
        // Default is MS IE 3
        //

        if ( !pcci->AddUserAgent( "MSIE 3." ) )
        {
            delete pcci;
            return FALSE;
        }
    }
    else
    {
        for ( pUA = msz.First() ; pUA ; pUA = msz.Next( pUA ) )
        {
            if ( !pcci->AddUserAgent( (LPSTR)pUA ) )
            {
                delete pcci;
                return FALSE;
            }
        }
    }

    InsertTailList( &g_RedirList, &pcci->m_ListEntry );

    *pRedirEntry = pcci;

    return TRUE;
}


BOOL
GetStrHeader( 
    HTTP_FILTER_PREPROC_HEADERS * pvData,
    HTTP_FILTER_CONTEXT*    pfc,
    LPSTR                   pszHeader,
    STR*                    pstr
    )
/*++

Routine Description:

    Get a http header in a STR

Arguments:

    pvData - Pre-proc headers notification structure
    pfc - filter context
    pszHeader - header name to access
    pstr - string updated with header value

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD   cb;

ag:
    cb = pstr->QuerySize();

    if ( !pvData->GetHeader( pfc,
                             pszHeader,
                             pstr->QueryStr(),
                             &cb ))
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            if ( !pstr->Resize( cb ) )
            {
                return FALSE;
            }
            goto ag;
        }
        else
        {
            return FALSE;
        }
    }

    pstr->SetLen( strlen( pstr->QueryStr() ) );

    return TRUE;
}


BOOL
GetStrVariable( 
    HTTP_FILTER_CONTEXT*    pfc,
    LPSTR                   pszVariable,
    STR*                    pstr
    )
/*++

Routine Description:

    Get a http server variable in a STR

Arguments:

    pfc - filter context
    pszVariable - server variable name to access
    pstr - string updated with server variable value

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD   cb;

ag:
    cb = pstr->QuerySize();

    if ( !pfc->GetServerVariable( pfc,
                                  pszVariable,
                                  pstr->QueryStr(),
                                  &cb ))
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            if ( !pstr->Resize( cb ) )
            {
                return FALSE;
            }
            goto ag;
        }
        else
        {
            return FALSE;
        }
    }

    pstr->SetLen( strlen( pstr->QueryStr() ) );

    return TRUE;
}


BOOL
LbMetabaseUpdateNotification(
    )
/*++

Routine Description:

    Notification function for metabase change to MD_LB_REDIRECTED_HOST

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LIST_ENTRY * pEntry;
    CRedirEntry * pcci;

    LockGlobals();

    // flush redirection cache

    while ( !IsListEmpty( &g_RedirList ))
    {
        pcci = CONTAINING_RECORD( g_RedirList.Flink,
                                  CRedirEntry,
                                  m_ListEntry );

        RemoveEntryList( &pcci->m_ListEntry );

        delete pcci;
    }

    UnlockGlobals();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\kdriver\iislbdr.cxx ===
#define KERNEL_MODE
#include "..\driver\iislbdr.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\interfac\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

IDL_FILE_NAME   = iislb
IDL_FLAGS       = /I $(SDK_INC_PATH) -DREGISTER_PROXY_DLL


SDKINC          = $(BASEDIR)\public\sdk\inc

INCS            = -I.

CLIENT_STUB     =$(IDL_FILE_NAME)_i.c
SERVER_STUB     =$(IDL_FILE_NAME)_p.c
DLL_STUB        =dlldata.c
HEADER_FILE     =..\..\..\inc\$(IDL_FILE_NAME).h

CLIENT_TARGETS  = $(CLIENT_STUB) \

SERVER_TARGETS  = $(SERVER_STUB) \

DLL_TARGETS     = $(DLL_STUB) \

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)  \
                  $(HEADER_FILE) $(DLL_TARGETS)
#                  $(HEADER_FILE) dlldata.c

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES) -DMIDL_PASS

MSC_WARNING_LEVEL= /W3 /WX

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delsrc all

delsrc:
        -erase $(TARGETS)

$(O)\iislbxp.obj: iislb_p.c

#
#  MIDL Compile stuff
#
#$(HEADER_FILE) $(CLIENT_TARGETS) $(SERVER_TARGETS):  .\$(IDL_FILE_NAME).idl
$(HEADER_FILE) $(CLIENT_TARGETS) $(SERVER_TARGETS) $(DLL_TARGETS) :  .\$(IDL_FILE_NAME).idl
    midl -Oi -error allocation -error ref -h $(HEADER_FILE) $(IDL_FLAGS) $(CPP) .\$(IDL_FILE_NAME).idl  $(INCS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\pdh\strings.h ===
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\filter\mbsink.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :

      mbsink.cxx

   Abstract:

      This module implements the metabase notification support

   Author:

      Johnl         01-Nov-1996

--*/


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include <iisfiltp.h>
#include <inetinfo.h>
#include <w3svc.h>
#include <iiscnfgp.h>

#include <dbgutil.h>
#include <buffer.hxx>
#include <objbase.h>
#include <initguid.h>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>

#ifndef _NO_TRACING_

#define PRINTF( x )     { char buff[256]; wsprintf x; DBGPRINTF((DBG_CONTEXT, buff)); }

#else

#if DBG
#define PRINTF( x )     { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define PRINTF( x )
#endif

#endif

#if 0 && DBG
#define NOISY_PRINTF( x )     { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define NOISY_PRINTF( x )
#endif

}

#include <iistypes.hxx>

#include "mbsink.hxx"


//
//  Derived metadata sink object
//

class CImpIMDCOMSINK : public IMDCOMSINK {

public:

    CImpIMDCOMSINK();
    ~CImpIMDCOMSINK();


    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    HRESULT STDMETHODCALLTYPE ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ]);

    HRESULT STDMETHODCALLTYPE ComMDShutdownNotify()
    {
        return RETURNCODETOHRESULT(ERROR_NOT_SUPPORTED);
    }

private:
    ULONG m_dwRefCount;
};

//
//  Globals
//

DWORD               g_dwSinkCookie = 0;
CImpIMDCOMSINK *    g_pEventSink = NULL;
IConnectionPoint *  g_pConnPoint = NULL;
DWORD               g_dwMBFlushCookie = 0;
PFN_NOTIFY_LB_PROPERTY_CHANGE   g_pfnLb = NULL;

//
//  Functions
//

BOOL
InitializeMetabaseSink(
    IUnknown *                      pmb,
    PFN_NOTIFY_LB_PROPERTY_CHANGE   pfnLb
    )
{

    IConnectionPointContainer * pConnPointContainer = NULL;
    HRESULT                     hRes;
    BOOL                        fSinkConnected = FALSE;

    g_pEventSink = new CImpIMDCOMSINK();

    if ( !g_pEventSink )
    {
        return FALSE;
    }

    //
    // First query the object for its Connection Point Container. This
    // essentially asks the object in the server if it is connectable.
    //

    hRes = pmb->QueryInterface( IID_IConnectionPointContainer,
                                (PVOID *)&pConnPointContainer);
    if SUCCEEDED(hRes)
    {
        // Find the requested Connection Point. This AddRef's the
        // returned pointer.

        hRes = pConnPointContainer->FindConnectionPoint( IID_IMDCOMSINK,
                                                         &g_pConnPoint);

        if (SUCCEEDED(hRes))
        {
            hRes = g_pConnPoint->Advise( (IUnknown *)g_pEventSink,
                                          &g_dwSinkCookie);

            if (SUCCEEDED(hRes))
            {
                fSinkConnected = TRUE;
                g_pfnLb = pfnLb;
            }
        }

        if ( pConnPointContainer )
        {
            pConnPointContainer->Release();
            pConnPointContainer = NULL;
        }
    }

    if ( !fSinkConnected )
    {
        delete g_pEventSink;
        g_pEventSink = NULL;
    }

    return fSinkConnected;
}

VOID
TerminateMetabaseSink(
    VOID
    )
{
    HRESULT hRes;

    if ( g_dwSinkCookie )
    {
        hRes = g_pConnPoint->Unadvise( g_dwSinkCookie );

        g_pConnPoint->Release();
    }

     g_pEventSink = NULL;
}




CImpIMDCOMSINK::CImpIMDCOMSINK()
{
    m_dwRefCount=0;
}

CImpIMDCOMSINK::~CImpIMDCOMSINK()
{
}

HRESULT
CImpIMDCOMSINK::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOMSINK) {
        *ppObject = (IMDCOMSINK *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CImpIMDCOMSINK::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CImpIMDCOMSINK::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CImpIMDCOMSINK::ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
    DWORD i, j;

#if 0
    DBGPRINTF(( DBG_CONTEXT,
                "Recieved callback for handle 0x%08x, NumElements = %d\n",
                hMDHandle,
                dwMDNumElements ));

    for (i = 0; i < dwMDNumElements; i++)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Change Type = %X, Path = %s, NumIDs = %d\n",
                    pcoChangeList[i].dwMDChangeType,
                    pcoChangeList[i].pszMDPath,
                    pcoChangeList[i].dwMDNumDataIDs ));

        for ( j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++ )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\tid[j] = %6d  ",
                        pcoChangeList[i].pdwMDDataIDs[j] ));
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "\n" ));
    }
#endif

    if ( g_pfnLb )
    {
        for (i = 0; i < dwMDNumElements; i++)
        {
            for ( j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++ )
            {
                if ( pcoChangeList[i].pdwMDDataIDs[j] == MD_LB_REDIRECTED_HOST ||
                     pcoChangeList[i].pdwMDDataIDs[j] == MD_LB_USER_AGENT_LIST )
                {
                    (g_pfnLb)();
                    return 0;
                }
            }
        }
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\interfac\main.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    DLL startup routine.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgutil.h>

}   // extern "C"


//
// Private globals.
//

//DECLARE_DEBUG_PRINTS_OBJECT();


//
// Private prototypes.
//


//
// DLL Entrypoint.
//

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    BOOL status = TRUE;

    switch( dwReason ) {

    case DLL_PROCESS_ATTACH :
//        CREATE_DEBUG_PRINT_OBJECT( "admxprox" );
        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH :
//        DELETE_DEBUG_PRINT_OBJECT();
        break;

    }

    return status;

}   // DLLEntry

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\pdh\pdhidef.h ===
/*++

Copyright (C) 1996 Microsoft Corporation

Module Name:

    pdhidef.h

Abstract:

    function definitions used internally by the performance data helper
    functions

--*/

#ifndef _PDHI_DEFS_H_
#define _PDHI_DEFS_H_

#include "pdhitype.h"   // required for data type definitions
#include "pdhmsg.h"     // error message definitions
#include "strings.h"    // for string constants

#if DBG
#define STATIC_PDH_FUNCTION PDH_STATUS __stdcall
#define STATIC_BOOL         BOOL __stdcall
#define STATIC_DWORD        DWORD __stdcall
#else
#define STATIC_PDH_FUNCTION static PDH_STATUS __stdcall
#define STATIC_BOOL         static BOOL __stdcall
#define STATIC_DWORD        static DWORD __stdcall
#endif

// global variable declarations
extern HANDLE   ThisDLLHandle;
extern WCHAR    szStaticLocalMachineName[];
extern HANDLE   hPdhDataMutex;
extern HANDLE   hPdhHeap;
extern HANDLE   hEventLog;

#ifndef _SHOW_PDH_MEM_ALLOCS

#define G_ALLOC(s)          HeapAlloc (hPdhHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, s)
#define G_REALLOC(h,s)      HeapReAlloc (hPdhHeap, HEAP_GENERATE_EXCEPTIONS, h, s)
#define G_FREE(h)           HeapFree (hPdhHeap, 0, h)
#define G_SIZE(h)           HeapSize (hPdhHeap, 0, h)

#else

__inline
LPVOID
PdhiHeapAlloc(LPSTR szSourceFileName, DWORD dwLineNo, DWORD s)
{
    LPVOID  lpRetVal;
    CHAR    szOutputString[MAX_PATH];

    lpRetVal = HeapAlloc (hPdhHeap, HEAP_ZERO_MEMORY, s);
    sprintf (szOutputString, "\n%s (%d): +%d Bytes Allocated to 0x%8.8x",
        szSourceFileName, dwLineNo,
        (lpRetVal != NULL ? s : 0), (DWORD)lpRetVal);
    OutputDebugStringA (szOutputString);
    return lpRetVal;
}

__inline
LPVOID
PdhiHeapReAlloc(LPSTR szSourceFileName, DWORD dwLineNo,
    LPVOID h, DWORD s)
{
    LPVOID  lpRetVal;
    CHAR    szOutputString[MAX_PATH];
    DWORD   dwBeforeSize;

    dwBeforeSize = HeapSize (hPdhHeap, 0, h);
    lpRetVal = HeapReAlloc (hPdhHeap, 0, h, s);
    sprintf (szOutputString, "\n%s (%d): -%d Bytes Freed from 0x%8.8x\n%s (%d): +%d Bytes Reallocd to 0x%8.8x",
        szSourceFileName, dwLineNo,
        dwBeforeSize, (DWORD) h,
        szSourceFileName, dwLineNo,
        (lpRetVal != NULL ? s : 0), (DWORD)lpRetVal);
    OutputDebugStringA (szOutputString);

    return lpRetVal;
}

__inline
BOOL
PdhiHeapFree(LPSTR szSourceFileName, DWORD dwLineNo,
    LPVOID h)
{
    BOOL bRetVal;
    CHAR    szOutputString[MAX_PATH];
    DWORD   dwBlockSize;

    dwBlockSize = HeapSize (hPdhHeap, 0, h);
    bRetVal = HeapFree (hPdhHeap, 0, h);
    sprintf (szOutputString, "\n%s (%d): -%d Bytes Freed from 0x%8.8x",
        szSourceFileName, dwLineNo,
        (bRetVal ? dwBlockSize : 0), (DWORD)h);
    OutputDebugStringA (szOutputString);
    return bRetVal;
}

#define G_ALLOC(s)          PdhiHeapAlloc (__FILE__, __LINE__, s)
#define G_REALLOC(h,s)      PdhiHeapReAlloc (__FILE__, __LINE__, h, s)
#define G_FREE(h)           PdhiHeapFree (__FILE__, __LINE__, h)
#define G_SIZE(h)           HeapSize (hPdhHeap, 0, h)


#endif


//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD)(x) & 0x00000003) ? ( ((DWORD)(x) & 0xFFFFFFFC) + 4 ) : ( (DWORD)(x) ) ))

#define DWORD_MULTIPLE(x) ((((x)+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define CLEAR_FIRST_FOUR_BYTES(x)     *(DWORD *)(x) = 0L

//    (assumes QuadWORD is 8 bytes long and pointer is dword in size)
#define ALIGN_ON_QWORD(x) ((VOID *)( ((DWORD)(x) & 0x00000007) ? ( ((DWORD)(x) & 0xFFFFFFF8) + 8 ) : ( (DWORD)(x) ) ))

#define QWORD_MULTIPLE(x) ((((x)+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))
#define CLEAR_FIRST_EIGHT_BYTES(x)     *(LONGLONG *)(x) = 0L

#define WAIT_FOR_AND_LOCK_MUTEX(h) (h != NULL ? WaitForSingleObject(h, 60000) : WAIT_TIMEOUT)
#define RELEASE_MUTEX(h)  (h != NULL ? ReleaseMutex(h) : TRUE)

// special perf counter type used by text log files
// value is stored as a double precision floating point value
#define PERF_DOUBLE_RAW     (0x00000400 | PERF_TYPE_NUMBER | \
                                PERF_NUMBER_DECIMAL)

#define LODWORD(ll) ((DWORD)((LONGLONG)ll & 0x00000000FFFFFFFF))
#define HIDWORD(ll) ((DWORD)(((LONGLONG)ll >> 32) & 0x00000000FFFFFFFF))

#define SMALL_BUFFER_SIZE   4096
#define MEDIUM_BUFFER_SIZE  16834
#define LARGE_BUFFER_SIZE   65536

// set this to 1 to report code errors (i.e. debugging information) 
// to the event log.
#define PDHI_REPORT_CODE_ERRORS 0

// set this to 1 to report user errors (i.e. things the normal user 
// would care about) to the event log.
#define PDHI_REPORT_USER_ERRORS 1

// USER category errors are typically configuration, schema or access
// access errors, errors the user can usually do something about
#define PDH_EVENT_CATEGORY_USER     100

// COUNTER category errors are errors returned do to valid data returning
// invalid results. These are a special subset of USER Category errors.
#define PDH_EVENT_CATEGORY_COUNTER  110

// DEBUG category errors are of interest only to PDH developers as they
// indicate problems that can normally only be fixed by modifying the 
// program code.
#define PDH_EVENT_CATEGORY_DEBUG    200

#define REPORT_EVENT(t,c,id)    ReportEvent (hEventLog, t, c, id, NULL, 0, 0, NULL, NULL)

//
//  Log file entries
//
extern LPCSTR  szTsvLogFileHeader;
extern LPCSTR  szCsvLogFileHeader;
extern LPCSTR  szBinLogFileHeader;
extern LPCSTR  szTsvType;
extern LPCSTR  szCsvType;
extern LPCSTR  szBinaryType;
extern  const DWORD   dwFileHeaderLength;
extern  const DWORD   dwTypeLoc;
extern  const DWORD   dwVersionLoc;
extern  const DWORD   dwFieldLength;

PDH_FUNCTION
PdhiGetLogCounterInfo (
    IN  HLOG            hLog,
    IN  PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiEnumLoggedMachines (
    IN  LPCWSTR szDataSource,
    IN  LPVOID  mszMachineList,
    IN  LPDWORD pcchBufferSize,
    IN  BOOL    bUnicode
);

PDH_FUNCTION
PdhiEnumLoggedObjects (
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPVOID  mszObjectList,
    IN  LPDWORD pcchBufferSize,
    IN  DWORD   dwDetailLevel,
    IN  BOOL    bRefresh,
    IN  BOOL    bUnicode
);

PDH_FUNCTION
PdhiEnumLoggedObjectItems (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN      LPVOID  mszCounterList,
    IN      LPDWORD pdwCounterListLength,
    IN      LPVOID  mszInstanceList,
    IN      LPDWORD pdwInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags,
    IN      BOOL    bUnicode
);

BOOL
PdhiDataSourceHasDetailLevels (
	IN	LPWSTR	szDataSource
);

PDH_FUNCTION
PdhiGetMatchingLogRecord (
    IN  HLOG        hLog,
    IN  LONGLONG    *pStartTime,
    IN  LPDWORD     pdwIndex
);

PDH_FUNCTION
PdhiGetCounterValueFromLogFile (
    IN  HLOG        hLog,
    IN  DWORD       dwIndex,
    IN  PERFLIB_COUNTER     *pPath,
    IN  PPDH_RAW_COUNTER    pValue
);

// query.c
BOOL
PdhiQueryCleanup (
);

// cutils.c
BOOL
AssignCalcFunction (
    IN      DWORD   dwCounterType,
    IN      LPCOUNTERCALC   *pCalcFunc,
    IN      LPCOUNTERSTAT   *pStatFunc
);

PDH_STATUS
PdhiComputeFormattedValue (
    IN      LPCOUNTERCALC       pCalcFunc,
    IN      DWORD               dwCounterType,
    IN      LONG                lScale,
    IN      DWORD               dwFormat,
    IN      PPDH_RAW_COUNTER    pRawValue1,
    IN      PPDH_RAW_COUNTER    pRawValue2,
    IN      PLONGLONG           pTimeBase,
    IN      DWORD               dwReserved,
    IN  OUT PPDH_FMT_COUNTERVALUE   fmtValue
);

// qutils.c

DWORD
PdhiAsyncTimerThreadProc (
    LPVOID  pArg
);

BOOL
IsValidQuery (
    IN  HQUERY  hQuery
);

BOOL
IsValidCounter (
    IN  HCOUNTER  hCounter
);

BOOL
InitCounter (
    IN  OUT PPDHI_COUNTER pCounter
);

BOOL
ParseFullPathNameW (
    IN      LPCWSTR szFullCounterPath,
    IN  OUT PDWORD  pdwBufferLength,
    IN  OUT PPDHI_COUNTER_PATH  pCounter
);

BOOL
ParseInstanceName (
    IN      LPCWSTR szInstanceString,
    IN OUT  LPWSTR  szInstanceName,
    IN OUT  LPWSTR  szParentName,
    IN OUT  LPDWORD lpIndex
);

BOOL
FreeCounter (
    IN  PPDHI_COUNTER   pThisCounter
);

BOOL
InitPerflibCounterInfo (
    IN  OUT PPDHI_COUNTER   pCounter
);

BOOL
AddMachineToQueryLists (
    IN  PPERF_MACHINE   pMachine,
    IN  PPDHI_COUNTER   pNewCounter
);

BOOL
UpdateCounterValue (
    IN  PPDHI_COUNTER   pCounter
);

BOOL
UpdateMultiInstanceCounterValue (
    IN  PPDHI_COUNTER   pCounter
);

#define GPCDP_GET_BASE_DATA 0x00000001
PVOID
GetPerfCounterDataPtr (
    IN  PPERF_DATA_BLOCK    pPerfData,
    IN  PPDHI_COUNTER_PATH  pPath,
    IN  PPERFLIB_COUNTER    pplCtr ,
    IN  DWORD               dwFlags,
    IN  PDWORD              pStatus
);

LONG
GetQueryPerfData (
    IN  PPDHI_QUERY pQuery
);

BOOL
GetInstanceByNameMatch (
    IN      PPERF_MACHINE   pMachine,
    IN OUT  PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiResetLogBuffers (
    IN  HLOG    hLog
);

DWORD
AddUniqueStringToMultiSz (
    IN  LPVOID  mszDest,
    IN  LPSTR   szSource,
    IN  BOOL    bUnicodeDest
);

DWORD
AddUniqueWideStringToMultiSz (
    IN  LPVOID  mszDest,
    IN  LPWSTR  szSource,
    IN  BOOL    bUnicodeDest
);

BOOL
PdhiBrowseDataSource (
    IN  HWND    hWndParent,
    IN  LPVOID  szFileName,
    IN  LPDWORD pcchFileNameSize,
    IN  BOOL    bUnicodeString
);

LPWSTR
PdhiGetExplainText (
    IN  LPCWSTR     szMachineName,
    IN  LPCWSTR     szObjectName,
    IN  LPCWSTR     szCounterName
);

LONG
GetCurrentServiceState (
    SC_HANDLE   hService,
    BOOL * bStopped,
    BOOL * bPaused
);


#endif // _PDHI_DEFS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\pdh\perftype.h ===
/*++

Copyright (C) 1996 Microsoft Corporation

Module Name:

    perftype.h

Abstract:

    Datatype definitions used by performance api utilities

--*/
#ifndef _PERFTYPE_H_
#define _PERFTYPE_H_

#include <windows.h>
#include <winperf.h>
#include "perfdata.h"

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

// default retry interval is no more often than every 60 seconds (1 min)
#define RETRY_TIME_INTERVAL ((LONGLONG)(1200000000))

typedef struct _LOCAL_PERF_NAME_INFO {
    HKEY    hKeyPerflib;
    HANDLE  hNameFile;
    HANDLE  hHelpFile;
    HANDLE  hNameFileObject;
    HANDLE  hHelpFileObject;
    LPVOID  pNameFileBaseAddr;
    LPVOID  pHelpFileBaseAddr;
} LOCAL_PERF_NAME_INFO, * PLOCAL_PERF_NAME_INFO;

typedef struct _PERF_MACHINE {
    HKEY    hKeyPerformanceData;
    LPWSTR  szName;
    PERF_DATA_BLOCK *pSystemPerfData;
    LPWSTR  *szPerfStrings;
    FILETIME LastStringUpdateTime;
    DWORD   dwLastPerfString;
    DWORD   dwRefCount;
    LPWSTR  szQueryObjects;
    DWORD   dwStatus;
    LONGLONG llRetryTime;
    HANDLE  hMutex;
    DWORD   dwRetryFlags;
    BOOL    bHaveCostlyObjects;
    PLOCAL_PERF_NAME_INFO pLocalNameInfo;
    struct  _PERF_MACHINE   *pNext;
    struct  _PERF_MACHINE   *pPrev;
} PERF_MACHINE, *PPERF_MACHINE;

typedef struct _PERFLIB_COUNTER {
    DWORD   dwObjectId;
    LONG    lInstanceId;
    LPWSTR  szInstanceName;
    DWORD   dwParentObjectId;
    LPWSTR  szParentInstanceName;
    DWORD   dwCounterId;
    DWORD   dwCounterType;
    DWORD   dwCounterSize;
    LONG    lDefaultScale;
} PERFLIB_COUNTER, *PPERFLIB_COUNTER;

//
//  function definitions
//
// perfutil.c

extern PPERF_MACHINE   pFirstMachine;

#define GetLocalFileTime(pTime)    GetSystemTimeAsFileTime ( (LPFILETIME)(pTime) )

PDH_STATUS
ConnectMachine (
    PPERF_MACHINE   pThisMachine
);

PDH_STATUS
ValidateMachineConnection (
    IN  PPERF_MACHINE   pMachine
);

PPERF_MACHINE
GetMachine (
    IN      LPWSTR  szMachineName,
    IN      DWORD   dwFlags
);

// GetMachine Flags...
#define     PDH_GM_UPDATE_NAME      ((DWORD)0x00000001)
#define     PDH_GM_UPDATE_PERFDATA  ((DWORD)0x00000002)
#define     PDH_GM_READ_COSTLY_DATA ((DWORD)0x00000004)

BOOL
FreeMachine (
    PPERF_MACHINE   pMachine
);

BOOL
FreeAllMachines (
);

DWORD
GetObjectId (
    PPERF_MACHINE   pMachine,
    LPWSTR          szObjectName,
    BOOL            *bInstances
);

DWORD
GetCounterId (
    PPERF_MACHINE   pMachine,
    DWORD           dwObjectId,
    LPWSTR          szCounterName
);

BOOL
AppendObjectToValueList (
    DWORD   dwObjectId,
    PWSTR   pwszValueList
);

BOOL
GetObjectPerfInfo (
    IN      PPERF_DATA_BLOCK  pPerfData,
    IN      DWORD           dwObjectId,
    IN OUT  LONGLONG        *pPerfTime,
    IN OUT  LONGLONG        *pPerfFreq
);

// internal PerfName.C functions

LPWSTR
*BuildLocalNameTable(
    LPWSTR   szLangId,
    PLOCAL_PERF_NAME_INFO   *pInfoArg,
    FILETIME *pLastUpdate,
    DWORD   *pdwLastPerfString
);

DWORD
CloseLocalNameTable (
    PLOCAL_PERF_NAME_INFO   pInfoArg
);

LPCWSTR
PdhiLookupPerfNameByIndex (
    PPERF_MACHINE  pMachine,
    DWORD   dwNameIndex
);

#endif // _PERFTYPE_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\serv\makefile.inc ===
#
# Supplemental rules for generating message file.
#

lbmsg.h msg00001.bin: lbmsg.mc
    mc -v lbmsg.mc

clean::
    -del lbmsg.h msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\serv\dcomperm.h ===
DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    );

DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    );

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    );

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    );

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    );

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    );

DWORD
GetCurrentUserSID (
    PSID *Sid
    );

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    );

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    );

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    );

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\pdh\pdhitype.h ===
/*++

Copyright (C) 1995 Microsoft Corporation

Module Name:

    pdhitype.h

Abstract:

    data types used internally by the Data Provider Helper functions.

--*/

#ifndef _PDHI_TYPE_H_
#define _PDHI_TYPE_H_

#include <windows.h>
#include <stdio.h>
#include "pdh.h"
#include "perftype.h"

typedef double  DOUBLE;

// make signature into DWORDs to make this a little faster

#define SigQuery    ((DWORD)0x51484450)    // L"PDHQ"
#define SigCounter  ((DWORD)0x43484450)    // L"PDHC"
#define SigLog      ((DWORD)0x4C484450)    // L"PDHL"

typedef struct _PDHI_QUERY_MACHINE {
    PPERF_MACHINE   pMachine;       // pointer to the machine structure
    LPWSTR          szObjectList;   // list of objects to query on that machine
    PERF_DATA_BLOCK *pPerfData;     // query's perf data block
    LONG            lQueryStatus;   // status of last perf query
    LONGLONG        llQueryTime;    // timestamp from last query attempt
    struct _PDHI_QUERY_MACHINE *pNext;  // next machine in list
} PDHI_QUERY_MACHINE, *PPDHI_QUERY_MACHINE;

typedef struct _PDHI_COUNTER_PATH {
    // machine path
    LPWSTR  szMachineName;      // null = the local machine
    // object Info
    LPWSTR  szObjectName;
    // instance info
    LPWSTR  szInstanceName;     // NULL if no inst.
    LPWSTR  szParentName;       // points to name if instance has a parent
    DWORD   dwIndex;            // index (to support dup. names.) 0 = 1st inst.
    // counter info
    LPWSTR  szCounterName;
    // misc storage
    BYTE    pBuffer[1];         // beginning of string buffer space
} PDHI_COUNTER_PATH, *PPDHI_COUNTER_PATH;

typedef struct _PDHI_RAW_COUNTER_ITEM {
    LPWSTR      szName;
    DWORD       MultiCount;
    LONGLONG    FirstValue;
    LONGLONG    SecondValue;
} PDHI_RAW_COUNTER_ITEM, *PPDHI_RAW_COUNTER_ITEM;

typedef struct _PDHI_RAW_COUNTER_ITEM_BLOCK {
    DWORD                   dwLength;
    DWORD                   dwItemCount;
    DWORD                   dwReserved;
    LONG                    CStatus;
    FILETIME                TimeStamp;
    PDHI_RAW_COUNTER_ITEM   pItemArray[];
} PDHI_RAW_COUNTER_ITEM_BLOCK, *PPDHI_RAW_COUNTER_ITEM_BLOCK;

typedef struct  _PDHI_QUERY_LIST {
    struct _PDHI_QUERY  *flink;
    struct _PDHI_QUERY  *blink;
} PDHI_QUERY_LIST, *PPDHI_QUERY_LIST;

typedef struct  _PDHI_COUNTER_LIST {
    struct _PDHI_COUNTER    *flink;
    struct _PDHI_COUNTER    *blink;
} PDHI_COUNTER_LIST, *PPDHI_COUNTER_LIST;

typedef struct  _PDHI_LOG_LIST {
    struct _PDHI_LOG        *flink;
    struct _PDHI_LOG        *blink;
} PDHI_LOG_LIST, *PPDHI_LOG_LIST;

typedef double (APIENTRY COUNTERCALC) (PPDH_RAW_COUNTER, PPDH_RAW_COUNTER, LONGLONG*, LPDWORD);
typedef double (APIENTRY *LPCOUNTERCALC) (PPDH_RAW_COUNTER, PPDH_RAW_COUNTER, LONGLONG*, LPDWORD);

typedef PDH_STATUS (APIENTRY COUNTERSTAT) (struct _PDHI_COUNTER *, DWORD, DWORD, DWORD, PPDH_RAW_COUNTER, PPDH_STATISTICS);
typedef PDH_STATUS (APIENTRY *LPCOUNTERSTAT) (struct _PDHI_COUNTER *, DWORD, DWORD, DWORD, PPDH_RAW_COUNTER, PPDH_STATISTICS);

typedef struct _PDHI_COUNTER {
    CHAR   signature[4];                // should be "PDHC" for counters
    DWORD   dwLength;                   // length of this structure
    struct _PDHI_QUERY *pOwner;         // pointer to owning query
    LPWSTR  szFullName;                 // full counter path string
    PDHI_COUNTER_LIST next;             // list links
    DWORD   dwUserData;                 // user defined DWORD
    LONG    lScale;                     // integer scale exponent
    // this information is obtained from the system
    DWORD    CVersion;                  // system perfdata version
    DWORD   dwFlags;                    // flags
    PPDHI_QUERY_MACHINE pQMachine;      // pointer to the machine structure
    PPDHI_COUNTER_PATH  pCounterPath;   // parsed counter path
    PDH_RAW_COUNTER ThisValue;          // most recent value
    PDH_RAW_COUNTER LastValue;          // previous value
    LPWSTR  szExplainText;              // pointer to the explain text buffer
    LPCOUNTERCALC       CalcFunc;       // pointer to the calc function
    LPCOUNTERSTAT       StatFunc;       // pointer to the statistics function
    // this field is specific to the Perflib implementation
    LONGLONG    TimeBase;               // freq. of timer used by this counter
    PERFLIB_COUNTER plCounterInfo;      // perflib specific counter data
    // these fields are used by "wildcard" counter handles
    PPDHI_RAW_COUNTER_ITEM_BLOCK    pThisRawItemList;   // pointer to current data set
    PPDHI_RAW_COUNTER_ITEM_BLOCK    pLastRawItemList;   // pointer to previous data set
} PDHI_COUNTER, *PPDHI_COUNTER;

// flags for the PDHI_COUNTER data structure.
#define  PDHIC_MULTI_INSTANCE       ((DWORD)0x00000001)
#define  PDHIC_ASYNC_TIMER          ((DWORD)0x00000002)

typedef struct  _PDHI_QUERY {
    CHAR   signature[4];        // should be "PDHQ" for queries
    PDHI_QUERY_LIST next;       // pointer to next query in list
    PPDHI_QUERY_MACHINE pFirstQMachine; // pointer to first machine in list
    PPDHI_COUNTER   pCounterListHead; // pointer to first counter in list
    DWORD   dwLength;           // length of this structure
    DWORD   dwUserData;
    DWORD   dwInterval;         // interval in seconds
    DWORD   dwNotifyFlags;      // notification flags
    PDH_TIME_INFO   TimeRange;  // query time range
    HLOG    hLog;               // handle to log file (for data source)
    DWORD   dwLastLogIndex;     // the last log record returned to a Get Value call
    HANDLE  hMutex;             // mutex to sync changes to data.
    HANDLE  hNewDataEvent;      // handle to event that is sent when data is collected
    HANDLE  hAsyncThread;       // thread handle for async collection
    HANDLE  hExitEvent;         // event to set for thread to terminate
} PDHI_QUERY, *PPDHI_QUERY;

typedef struct _PDHI_LOG {
    CHAR    signature[4];       // should be "PDHL" for log entries
    PDHI_LOG_LIST   next;       // links to next and previous entries
    DWORD   dwLength;           // the size of this structure
    LPWSTR  szLogFileName;      // full file name for this log file
    HANDLE  hLogFileHandle;     // handle to open log file
    HANDLE  hMappedLogFile;     // handle for memory mapped files
    LPVOID  lpMappedFileBase;   // starting address for mapped log file
    FILE    *StreamFile;        // stream pointer for text files
    LONGLONG llFileSize;        // file size (used only for reading)
    DWORD   dwRecord1Size;      // size of ID record in BLG files, not used by text files
    DWORD   dwLastRecordRead;   // index of last record read from the file
    LPVOID  pLastRecordRead;    // pointer to buffer containing the last record
    LPWSTR  szCatFileName;      // catalog file name
    HANDLE  hCatFileHandle;     // handle to the open catalog file
    PPDHI_QUERY pQuery;         // pointer to the query associated with the log
    LONGLONG llMaxSize;         // max size of a circular log file
    DWORD   dwLogFormat;        // log type and access flags
    DWORD   dwMaxRecordSize;    // size of longest record in log
} PDHI_LOG, *PPDHI_LOG;

#endif // _PDH_TYPE_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\serv\dcomperm.cpp ===
#include "windows.h"

#include <stdio.h>
#include <tchar.h>
#include <string.h>
#include <conio.h>
#include "dcomperm.h"

#define _WIN32_DCOM
#include <objbase.h>

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;

    GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation);

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
            return GetLastError();

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
            return GetLastError();
    }

    return ERROR_SUCCESS;
}

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;
    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    *Acl = newACL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    *Acl = newACL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID = NULL;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (Acl, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
    }

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    DWORD dwReturn = ERROR_SUCCESS;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle, TokenUser, tokenUser, 0, &tokenSize);

        tokenUser = (TOKEN_USER *) malloc (tokenSize);

        if (GetTokenInformation (tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) malloc (sidLength);

            memcpy (*Sid, tokenUser->User.Sid, sidLength);
            CloseHandle (tokenHandle);
        } else
            dwReturn = GetLastError();

        if (tokenUser)
            free(tokenUser);

    } else
        dwReturn = GetLastError();

    return dwReturn;
}

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    //_strlwr( Principal);
    if ( !strcmp( Principal,"administrators") ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if ( !strcmp( Principal, "system") ) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if ( !strcmp( Principal,"interactive") ) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if ( !strcmp( Principal,"everyone") ) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority, 
                                    (BYTE)Count, 
		                            dwRID[0], 
		                            dwRID[1], 
		                            dwRID[2], 
		                            dwRID[3], 
		                            dwRID[4], 
		                            dwRID[5], 
		                            dwRID[6], 
		                            dwRID[7], 
                                    Sid) )
        return GetLastError();
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        DWORD        returnValue;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();
        if (returnValue != ERROR_INSUFFICIENT_BUFFER)
            return returnValue;

        *Sid = (PSID) malloc (sidSize);
        refDomainSize = 255;

        if (!LookupAccountName (NULL,
                                Principal,
                                *Sid,
                                &sidSize,
                                refDomain,
                                &refDomainSize,
                                &snu))
        {
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl;
    DWORD   sidLength;
    PSID    sid;
    PSID    groupSID;
    PSID    ownerSID;
    DWORD   returnValue;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS) {
        if (sid)
            free(sid);
        return returnValue;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}


DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl = NULL;
    PACL                  sacl = NULL;
    PSID                  ownerSID = NULL;
    PSID                  groupSID = NULL;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();

    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, _T(""), 0, KEY_ALL_ACCESS, NULL, &registryKey, &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    )
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        } else
            return returnValue;
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS) {
            if (*SD)
                free(*SD);
            return returnValue;
        }

        *NewSD = TRUE;
    } else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);

        returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, (LPBYTE) *SD, &valueSize);
        if (returnValue)
        {
            if (*SD)
                free (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
        }
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;


    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("system"));
#if 0
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
#endif
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal); 
    else
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);

    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute) 
        free (sdAbsolute);

    return returnValue;
}

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("system"));
#if 0
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
#endif
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal);

     return err;
}

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal);

    return err;
}

DWORD
ChangeDCOMAccessACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal);
    
    return err;
}

DWORD
ChangeDCOMLaunchACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal);
    
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\pdh\perfdata.h ===
#ifndef _PERFDATA_H_
#define _PERFDATA_H_

#define INITIAL_SIZE    ((DWORD)0x00010000)
#define EXTEND_SIZE     ((DWORD)0x00008000)
#define RESERVED        0L

typedef LPVOID  LPMEMORY;
typedef HGLOBAL HMEMORY;

#ifndef _NTDEF_
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt
#endif

LPWSTR
*BuildNameTable(
    LPWSTR  szComputerName, // computer to query names from 
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    FILETIME *pLastUpdate,  // time stamp of the last update
    PDWORD  pdwLastItem     // size of array in elements
);

#define FirstObject(pPerfData) \
    (PPERF_OBJECT_TYPE)((PBYTE)(pPerfData) + (pPerfData)->HeaderLength)

#define NextObject(pObject) \
    (PPERF_OBJECT_TYPE)((pObject)->TotalByteLength != 0 ? (PPERF_OBJECT_TYPE)((PBYTE)(pObject) + (pObject)->TotalByteLength) : NULL)

PERF_OBJECT_TYPE *
GetObjectDefByTitleIndex(
    IN  PERF_DATA_BLOCK *pDataBlock,
    IN  DWORD ObjectTypeTitleIndex
);

PERF_OBJECT_TYPE *
GetObjectDefByName (
    IN  PERF_DATA_BLOCK *pDataBlock,
    IN  DWORD           dwLastNameIndex,
    IN  LPCWSTR         *NameArray,
    IN  LPCWSTR         szObjectName
);

#define FirstInstance(pObjectDef) \
    (PERF_INSTANCE_DEFINITION *)((PCHAR) pObjectDef + pObjectDef->DefinitionLength)


__inline
PERF_INSTANCE_DEFINITION *
NextInstance(
    IN  PERF_INSTANCE_DEFINITION *pInstDef
)
{
    PERF_COUNTER_BLOCK *pCounterBlock;
    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstDef + pInstDef->ByteLength);
    return (PERF_INSTANCE_DEFINITION *)
               ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}

PERF_INSTANCE_DEFINITION *
GetInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceNumber
);

PERF_INSTANCE_DEFINITION *
GetInstanceByUniqueId(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceUniqueId
);

DWORD
GetInstanceNameStr (PPERF_INSTANCE_DEFINITION pInstance,
                    LPWSTR lpszInstance,
                    DWORD dwCodePage);

DWORD
GetFullInstanceNameStr (
    PERF_DATA_BLOCK             *pPerfData,
    PERF_OBJECT_TYPE            *pObjectDef,
    PERF_INSTANCE_DEFINITION    *pInstanceDef,
    LPWSTR                      szInstanceName
);

#define FirstCounter(pObjectDef) \
    (PERF_COUNTER_DEFINITION *)((PCHAR)(pObjectDef) + (pObjectDef)->HeaderLength)

#define NextCounter(pCounterDef) \
    (PERF_COUNTER_DEFINITION *)(((pCounterDef)->ByteLength != 0) ? (PERF_COUNTER_DEFINITION *)((PCHAR)(pCounterDef) + (pCounterDef)->ByteLength) : NULL)

PERF_COUNTER_DEFINITION *
GetCounterDefByName (
    IN  PERF_OBJECT_TYPE    *pObject,
    IN  DWORD           dwLastNameIndex,
    IN  LPWSTR          *NameArray,
    IN  LPWSTR          szCounterName
);

PERF_COUNTER_DEFINITION *
GetCounterDefByTitleIndex(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  BOOL bBaseCounterDef,
    IN  DWORD CounterTitleIndex
);

LONG
GetSystemPerfData (
    IN HKEY hKeySystem,
    IN PPERF_DATA_BLOCK *pPerfData,
    IN LPWSTR   szObjectList,
	IN BOOL		bCollectCostlyData
);

PERF_INSTANCE_DEFINITION *
GetInstanceByName(
    PERF_DATA_BLOCK *pDataBlock,
    PERF_OBJECT_TYPE *pObjectDef,
    LPWSTR pInstanceName,
    LPWSTR pParentName,
    DWORD   dwIndex
);

__inline
PVOID
GetCounterDataPtr (
    PERF_OBJECT_TYPE *pObjectDef,
    PERF_COUNTER_DEFINITION *pCounterDef
)
{

    PERF_COUNTER_BLOCK *pCtrBlock;

    pCtrBlock = (PERF_COUNTER_BLOCK *)((PCHAR)pObjectDef +
					      pObjectDef->DefinitionLength);

    return (PVOID)((PCHAR)pCtrBlock + pCounterDef->CounterOffset);
}

__inline
PVOID
GetInstanceCounterDataPtr (
    PERF_OBJECT_TYPE *pObjectDef,
    PERF_INSTANCE_DEFINITION *pInstanceDef,
    PERF_COUNTER_DEFINITION *pCounterDef
)
{

    PERF_COUNTER_BLOCK *pCtrBlock;

    pCtrBlock = (PERF_COUNTER_BLOCK *)((PCHAR)pInstanceDef +
					      pInstanceDef->ByteLength);

    return (PVOID)((PCHAR)pCtrBlock + pCounterDef->CounterOffset);
}


#endif //_PERFDATA_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\serv\boot.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    boot.cxx

Abstract:

    Load balancing service

Author:

    Philippe Choquier (phillich)

--*/

#define INITGUID
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <ole2.h>
#include <windows.h>
#include <winsock2.h>
#include <olectl.h>
#include <pdh.h>
#pragma warning( disable:4200 )
#include "pdhitype.h"
#include "pdhidef.h"
#include <pdhmsg.h>
#include <stdio.h>
#include <ctype.h>
#include <time.h>

#include <IisLb.h>
#include <lbxbf.hxx>
#include <lbcnfg.hxx>
#include <bootimp.hxx>
#include <IisLbs.hxx>
#include <lbmsg.h>
#include <dcomperm.h>
#include <iisnatio.h>
#include <pudebug.h>

#if DBG
#define _NOISY_DEBUG
#endif

#if defined(_NOISY_DEBUG)
#define DEBUG_BUFFER    char    achE[128]
#define DBG_PRINTF(a)   sprintf a; OutputDebugString( achE )
#define DBG_PUTS(a)     OutputDebugString(a)
#else
#define DEBUG_BUFFER
#define DBG_PRINTF(a)
#define DBG_PUTS(a)
#endif

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))

#define DEFAULT_IP_PORT     80
#define COLLECT_TIMEOUT     20          // in seconds
#define SLEEP_INTERVAL      1000        // for server state query, in ms
#define MAX_SLEEP           (10*1000)   // driver startup time, in ms

typedef
PDH_STATUS
(__stdcall *PFN_OPEN_QUERY)(
    IN      LPVOID      pv,
    IN      DWORD       dwUserData,
    IN      HQUERY      *phQuery);

//
// Globals
//

DWORD           g_dwRefCount = 0;
DWORD           g_dwComRegister;
DWORD           g_bInitialized = FALSE;
HANDLE          g_UserToKernelUpdateEvent;
BOOL            g_fStopUserToKernelThread = FALSE;
HANDLE          g_hUserToKernelThread = NULL;
WSADATA         g_WSAData;
HMODULE         g_hPdh;
PFN_OPEN_QUERY  g_pfnPdhOpenQuery = NULL;
LPBYTE          g_pAcl = NULL;
DWORD           g_dwPdhVersion = 0;

CComputerPerfCounters   g_PerfmonCounterList;
CRITICAL_SECTION        g_csPerfList;
// guarantee structure integrity
CRITICAL_SECTION        g_csIpListCheckpoint;
// for write access w/o modifying structure
CRITICAL_SECTION        g_csIpListUpdate;
CRITICAL_SECTION        g_csAcl;
CRITICAL_SECTION        g_csKernelThreadUpdate;
CKernelIpMapHelper      g_KernelIpMap;
// set to TRUE if load in each server info is available load
BOOL                    g_fNormalized = FALSE;
CIPMap                  g_IpMap;

GENERIC_MAPPING g_FileGenericMapping =
{
    FILE_READ_DATA,
    FILE_WRITE_DATA,
    FILE_EXECUTE,
    FILE_ALL_ACCESS
};

//
// Private prototypes
//

HRESULT InitOleSecurity(
    );

BOOL
LbAccessCheck(
    DWORD           dwAccess
    );

VOID
FlushLbAccessCheck(
    );

HRESULT
SetLbDriverState(
    BOOL        fStart
    );

BOOL
CheckQueryMachineStatus(
    HQUERY  hQuery
    );

/////

BOOL
IncludeServerName(
    LPWSTR  pszPath
    )
/*++

Routine Description:

    Check if path includes server names

Arguments:

    pszPath - UNC path

Return Value:

    TRUE if path refers to server, otherwise FALSE

--*/
{
    return pszPath[0] == L'\\' && pszPath[1] == L'\\';
}


CIisLb::CIisLb(
    )
/*++

Routine Description:

    CIisLb constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_dwRefCount = 0;
}


CIisLb::~CIisLb(
    )
/*++

Routine Description:

    CIisLb destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


HRESULT
CIisLb::QueryInterface(
    REFIID riid,
    void **ppObject
    )
/*++

Routine Description:

    CIisLb QueryInterface

Arguments:

    riid - Interface ID
    ppObject - updated with ptr to interface on success

Return Value:

    status

--*/
{
    if (riid==IID_IUnknown || riid==IID_IMSIisLb) {
        *ppObject = (IMSIisLb *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}


ULONG
CIisLb::AddRef(
    )
/*++

Routine Description:

    CIisLb add reference to COM interface

Arguments:

    None

Return Value:

    reference count

--*/
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}


ULONG
CIisLb::Release(
    )
/*++

Routine Description:

    CIisLb release reference to COM interface
    delete object when reference count drops to zero

Arguments:

    None

Return Value:

    reference count

--*/
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}


HRESULT STDMETHODCALLTYPE
CIisLb::GetIpList(
                /*[in]*/ DWORD dwBufferSize,
                /*[out, size_is(dwBufferSize)]*/ unsigned char *pbBuffer,
                /*[out]*/ DWORD *pdwMDRequiredBufferSize )
/*++

Routine Description:

    Get the IP mapping list in a serialized format

Arguments:

    dwBufferSize - size of pbBuffer
    pbBuffer - buffer updated with serialized IP mapping list
    pdwMDRequiredBufferSize - updated with required size if dwBufferSize too small

Return Value:

    COM status
    will be Win32 error ERROR_INSUFFICIENT_BUFFER if dwBufferSize too small

--*/
{
    XBF     xbf;
    BOOL    fSt;


    EnterCriticalSection( &g_csIpListCheckpoint );

    fSt = g_IpMap.Serialize( &xbf );

    LeaveCriticalSection( &g_csIpListCheckpoint );

    if ( fSt )
    {
        *pdwMDRequiredBufferSize = xbf.GetUsed();

        if ( dwBufferSize < xbf.GetUsed() )
        {
            return RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
        }

        memcpy( pbBuffer, xbf.GetBuff(), xbf.GetUsed() );

        return S_OK;
    }

    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE
CIisLb::SetIpList(
                /*[in]*/ DWORD dwBufferSize,
                /*[in, size_is(dwBufferSize)]*/ unsigned char *pbBuffer )
/*++

Routine Description:

    Set the IP mapping list from serialized format

Arguments:

    dwBufferSize - size of pbBuffer
    pbBuffer - buffer containing serialized IP mapping list

Return Value:

    COM status

--*/
{
    EnterCriticalSection( &g_csIpListCheckpoint );

    if ( g_IpMap.Unserialize( &pbBuffer, &dwBufferSize ) &&
         IpListToKernelConfig( &g_IpMap ) &&
         g_IpMap.Save( HKEY_LOCAL_MACHINE, IISLOADBAL_REGISTRY_KEY, IPLIST_REGISTRY_VALUE ) )
    {
        LeaveCriticalSection( &g_csIpListCheckpoint );

        //
        // update kernel configuration
        //

        SetEvent( g_UserToKernelUpdateEvent );

        return S_OK;
    }

    LeaveCriticalSection( &g_csIpListCheckpoint );

    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE
CIisLb::GetPerfmonCounters(
                /*[in]*/ DWORD dwBufferSize,
                /*[out, size_is(dwBufferSize)]*/ unsigned char *pbBuffer,
                /*[out]*/ DWORD *pdwMDRequiredBufferSize )
/*++

Routine Description:

    Get the perfmon counter list in a serialized format

Arguments:

    dwBufferSize - size of pbBuffer
    pbBuffer - buffer updated with serialized perfmon counter list
    pdwMDRequiredBufferSize - updated with required size if dwBufferSize too small

Return Value:

    COM status
    will be Win32 error ERROR_INSUFFICIENT_BUFFER if dwBufferSize too small

--*/
{
    XBF     xbf;

    if ( KernelConfigToPerfmonCounters( &xbf ) )
    {
        *pdwMDRequiredBufferSize = xbf.GetUsed();

        if ( dwBufferSize < xbf.GetUsed() )
        {
            return RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
        }

        memcpy( pbBuffer, xbf.GetBuff(), xbf.GetUsed() );

        return S_OK;
    }

    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE
CIisLb::SetPerfmonCounters(
                /*[in]*/ DWORD dwBufferSize,
                /*[in, size_is(dwBufferSize)]*/ unsigned char *pbBuffer )
/*++

Routine Description:

    Set the perfmon counter list from serialized format

Arguments:

    dwBufferSize - size of pbBuffer
    pbBuffer - buffer containing serialized perfmon counter list

Return Value:

    COM status

--*/
{
    CComputerPerfCounters   PerfmonCounters;

    if ( PerfmonCounters.Unserialize( &pbBuffer, &dwBufferSize ) &&
         PerfmonCountersToKernelConfig( &PerfmonCounters ) &&
         PerfmonCounters.Save( HKEY_LOCAL_MACHINE, IISLOADBAL_REGISTRY_KEY, PERFMON_REGISTRY_VALUE ) )
    {
        return S_OK;
    }

    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CIisLb::GetStickyDuration(
                /*[out]*/ LPDWORD pdwStickyDuration )
/*++

Routine Description:

    Get the sticky binding duration ( public IP -> private IP )

Arguments:

    pdwStickyDuration - updated with sticky mode duration

Return Value:

    COM status

--*/
{
    *pdwStickyDuration = g_KernelIpMap.GetStickyDuration();

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CIisLb::SetStickyDuration(
                /*[in]*/ DWORD dwStickyDuration )
/*++

Routine Description:

    Set the sticky binding duration ( public IP -> private IP )

Arguments:

    dwStickyDuration - sticky mode duration

Return Value:

    COM status

--*/
{
    XBF     xbf;

    g_KernelIpMap.SetStickyDuration( dwStickyDuration );
    if ( Serialize( &xbf, (DWORD)dwStickyDuration ) &&
         SaveBlobToReg( HKEY_LOCAL_MACHINE, IISLOADBAL_REGISTRY_KEY, STICKY_REGISTRY_VALUE, &xbf ) )
    {
        return S_OK;
    }

    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE
CIisLb::GetIpEndpointList(
                /*[in]*/ DWORD dwBufferSize,
                /*[out, size_is(dwBufferSize)]*/ unsigned char *pbBuffer,
                /*[out]*/ DWORD *pdwMDRequiredBufferSize )
/*++

Routine Description:

    Get the IP endpoint list in a serialized format

Arguments:

    dwBufferSize - size of pbBuffer
    pbBuffer - buffer updated with serialized IP mapping list
    pdwMDRequiredBufferSize - updated with required size if dwBufferSize too small

Return Value:

    COM status
    will be Win32 error ERROR_INSUFFICIENT_BUFFER if dwBufferSize too small

--*/
{
    XBF                 xbf;
    CIpEndpointList     ieEndpointList;


    if ( ieEndpointList.BuildListFromLocalhost() &&
         ieEndpointList.Serialize( &xbf ) )
    {
        *pdwMDRequiredBufferSize = xbf.GetUsed();

        if ( dwBufferSize < xbf.GetUsed() )
        {
            return RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
        }

        memcpy( pbBuffer, xbf.GetBuff(), xbf.GetUsed() );

        return S_OK;
    }

    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE
CIisLb::SetDriverState(
    /*[in]*/ DWORD dwState
    )
/*++

Routine Description:

    Set the driver state ( started or stopped )

Arguments:

    dwState - either SERVICE_RUNNING to start or SERVICE_STOPPED to stop

Return Value:

    COM status

--*/
{
    HRESULT     hresReturn = S_OK;
    DWORD       dwId;

    EnterCriticalSection( &g_csKernelThreadUpdate );

    if ( dwState == SERVICE_STOPPED )
    {
        if ( g_hUserToKernelThread )
        {
            g_fStopUserToKernelThread = TRUE;
            SetEvent( g_UserToKernelUpdateEvent );
            WaitForSingleObject( g_hUserToKernelThread, INFINITE );
            CloseHandle( g_hUserToKernelThread );
            g_hUserToKernelThread = NULL;
        }
    }
    else
    {
        if ( g_hUserToKernelThread == NULL )
        {
            if ( (g_UserToKernelUpdateEvent = CreateEvent(
                        NULL,
                        FALSE,
                        FALSE,
                        NULL )) == NULL ||
                  (g_hUserToKernelThread = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)UserToKernelThread,
                        (LPVOID)g_UserToKernelUpdateEvent,
                        0,
                        &dwId )) == NULL )
            {
                hresReturn = RETURNCODETOHRESULT( GetLastError() );
            }
        }
    }

    LeaveCriticalSection( &g_csKernelThreadUpdate );

    return hresReturn;
}



CIisLbSrvFactory::CIisLbSrvFactory(
    )
/*++

Routine Description:

    CIisLbSrvFactory constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_dwRefCount=0;
}


CIisLbSrvFactory::~CIisLbSrvFactory(
    )
/*++

Routine Description:

    CIisLbSrvFactory destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


HRESULT
CIisLbSrvFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void ** ppObject)
/*++

Routine Description:

    Create instances of CIisLb

Arguments:

    pUnkOuter - controling unknown
    riid - Interface ID in
    ppObject - updated with ptr to interface on success

Return Value:

    COM status

--*/
{
    CIisLb*     pBl;

    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    if ( !LbAccessCheck( FILE_READ_DATA ) ) {
        return RETURNCODETOHRESULT( GetLastError() );
    }

    FlushLbAccessCheck();

    if ( (pBl = new CIisLb) == NULL ) {
        return E_NOINTERFACE;
    }

    if (FAILED(pBl->QueryInterface(riid, ppObject))) {
        delete pBl;
        return E_NOINTERFACE;
    }

    return NO_ERROR;
}


HRESULT
CIisLbSrvFactory::LockServer(
    BOOL fLock
    )
/*++

Routine Description:

    Lock COM DLL

Arguments:

    fLock - TRUE to lock, FALSE to unlock

Return Value:

    COM status

--*/
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}


HRESULT
CIisLbSrvFactory::QueryInterface(
    REFIID riid,
    void **ppObject
    )
/*++

Routine Description:

    CIisLbSrvFactory QueryInterface

Arguments:

    riid - Interface ID
    ppObject - updated with ptr to interface on success

Return Value:

    status

--*/
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
            *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}


ULONG
CIisLbSrvFactory::AddRef(
    )
/*++

Routine Description:

    CIisLbSrvFactory add reference to COM interface

Arguments:

    None

Return Value:

    reference count

--*/
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}


ULONG
CIisLbSrvFactory::Release(
    )
/*++

Routine Description:

    CIisLbSrvFactory release reference to COM interface
    delete object when reference count drops to zero

Arguments:

    None

Return Value:

    reference count

--*/
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0)
    {
        delete this;
    }
    return dwRefCount;
}


STDAPI BootDllRegisterServer(
    )
/*++

Routine Description:

    Register COM objects

Arguments:

    None

Return Value:

    COM status

--*/
{
    HKEY hKeyCLSID, hKeyInproc32;
    HKEY hKeyIF, hKeyStub32;
    HKEY hKeyAppExe, hKeyAppID, hKeyTemp;
    DWORD dwDisposition;


    //
    // register AppExe
    //

    HRESULT hr;


    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{a9da4430-65c5-11d1-a700-00a0c922e752}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IIS load balancing configuration"), sizeof(TEXT("load balancing configuration")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT("AppID"), NULL, REG_SZ, (BYTE*) TEXT("{a9da4430-65c5-11d1-a700-00a0c922e752}"), sizeof(TEXT("{a9da4430-65c5-11d1-a700-00a0c922e752}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    {
        if (RegSetValueEx(hKeyCLSID, TEXT("LocalService"), NULL, REG_SZ, (BYTE*) TEXT(SZSERVICENAME), sizeof(TEXT(SZSERVICENAME)))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
        }
    }

    RegCloseKey(hKeyCLSID);


    //
    // AppID
    //
    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("AppID\\{a9da4430-65c5-11d1-a700-00a0c922e752}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IIS load balancing configuration"), sizeof(TEXT("IIS load balancing configuration")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    {
        if (RegSetValueEx(hKeyCLSID, TEXT("LocalService"), NULL, REG_SZ, (BYTE*) TEXT(SZSERVICENAME), sizeof(TEXT(SZSERVICENAME)))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
        }
    }

    RegCloseKey(hKeyCLSID);

    //
    // Assign ACL to CLSID ( a la dcomcnfg ) granting access only to admins, current user
    // and system
    //

    ChangeAppIDAccessACL( "{a9da4430-65c5-11d1-a700-00a0c922e752}",
                          "administrators",
                          TRUE,
                          TRUE );

    //
    // Main Interface
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{996d0030-65c5-11d1-a700-00a0c922e752}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT(SZSERVICENAME), sizeof(TEXT(SZSERVICENAME)))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       "InprocServer32",
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyInproc32, TEXT(""), NULL, REG_SZ, (BYTE*) "IISLBP.DLL", sizeof(TEXT("IISLBP.DLL")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyInproc32, TEXT("ThreadingModel"), NULL, REG_SZ, (BYTE*) "Both", sizeof("Both")-1 )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    //
    // register Interfaces
    //

    //
    // Main Interface
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{996d0030-65c5-11d1-a700-00a0c922e752}"),
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyIF, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyIF, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT(SZSERVICENAME), sizeof(TEXT(SZSERVICENAME)))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegCreateKeyEx(hKeyIF,
                    "ProxyStubClsid32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyStub32, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyStub32, TEXT(""), NULL, REG_SZ, (BYTE*)"{996d0030-65c5-11d1-a700-00a0c922e752}", sizeof("{996d0030-65c5-11d1-a700-00a0c922e752}") )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyStub32);
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    return S_OK;
}


STDAPI
BootDllUnregisterServer(
    void
    )
/*++

Routine Description:

    Unregister COM objects

Arguments:

    None

Return Value:

    COM status

--*/
{

    //
    // register AppID
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\{a9da4430-65c5-11d1-a700-00a0c922e752}"));

    //
    // register CLSID
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{a9da4430-65c5-11d1-a700-00a0c922e752}"));

    //
    // Main Interfaces
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{996d0030-65c5-11d1-a700-00a0c922e752}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{996d0030-65c5-11d1-a700-00a0c922e752}"));

    //
    // deregister Interfaces
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{996d0030-65c5-11d1-a700-00a0c922e752}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{996d0030-65c5-11d1-a700-00a0c922e752}"));

    return S_OK;
}


BOOL
InitGlobals(
    )
/*++

Routine Description:

    Initialize globals variables

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    INITIALIZE_CRITICAL_SECTION( &g_csPerfList );
    INITIALIZE_CRITICAL_SECTION( &g_csIpListCheckpoint );
    INITIALIZE_CRITICAL_SECTION( &g_csIpListUpdate );
    INITIALIZE_CRITICAL_SECTION( &g_csAcl );
    INITIALIZE_CRITICAL_SECTION( &g_csKernelThreadUpdate );

    //
    // NT4 uses PdhOpenQuery, NT5 has Ansi/Unicode versions only
    //

    if ( (g_hPdh = LoadLibrary( "pdh.dll" )) )
    {
        g_pfnPdhOpenQuery = (PFN_OPEN_QUERY)GetProcAddress( g_hPdh,
                "PdhOpenQuery" );

        if ( g_pfnPdhOpenQuery == NULL )
        {
            g_pfnPdhOpenQuery = (PFN_OPEN_QUERY)GetProcAddress( g_hPdh,
                    "PdhOpenQueryA" );

            if ( g_pfnPdhOpenQuery == NULL )
            {
                FreeLibrary( g_hPdh );
                g_hPdh = NULL;
            }
        }
    }

    if ( g_pfnPdhOpenQuery == NULL )
    {
        WCHAR achErr[32];
        LPCWSTR pA[1];
        pA[0] = achErr;
        _itow( GetLastError(), achErr, 10 );
        ReportIisLbEvent( EVENTLOG_ERROR_TYPE,
                IISLB_EVENT_PDH_ACCESS_ERROR,
                1,
                pA );
    }

    if ( g_pfnPdhOpenQuery == NULL ||
         !g_KernelIpMap.Init() )
    {
        DeleteCriticalSection( &g_csPerfList );
        DeleteCriticalSection( &g_csIpListCheckpoint );
        DeleteCriticalSection( &g_csIpListUpdate );
        DeleteCriticalSection( &g_csAcl );
        DeleteCriticalSection( &g_csKernelThreadUpdate );

        return FALSE;
    }

    PdhGetDllVersion( &g_dwPdhVersion );

    return TRUE;
}


BOOL
TerminateGlobals(
    )
/*++

Routine Description:

    Terminate globals variables

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    //
    // stop perfmon threads
    //

    EnterCriticalSection( &g_csIpListCheckpoint );

    while ( g_KernelIpMap.ServerCount() )
    {
        //
        // do no wait for perfmon thread to stop : timeout is 0
        //

        g_KernelIpMap.StopServerThread( 0, 0 );

        EnterCriticalSection( &g_csIpListUpdate );
        g_KernelIpMap.RemoveServer( 0 );
        LeaveCriticalSection( &g_csIpListUpdate );
    }

    LeaveCriticalSection( &g_csIpListCheckpoint );

    if ( g_pAcl != NULL )
    {
        LocalFree( g_pAcl );
        g_pAcl = NULL;
    }

    DeleteCriticalSection( &g_csAcl );
    DeleteCriticalSection( &g_csPerfList );
    DeleteCriticalSection( &g_csIpListCheckpoint );
    DeleteCriticalSection( &g_csIpListUpdate );
    DeleteCriticalSection( &g_csKernelThreadUpdate );

    FreeLibrary( g_hPdh );

    return TRUE;
}


BOOL
InitComLb(
    )
/*++

Routine Description:

    Init COM interface support & user mode <> kernel communication

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    HRESULT hr;
    BOOL    bReturn = TRUE;
    DWORD   dwId;
    DEBUG_BUFFER;

    if ( WSAStartup( MAKEWORD( 2, 0), &g_WSAData ) != 0 )
    {
        DBG_PUTS( "can't init WSA\n" );
        return FALSE;
    }

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    InitOleSecurity();

    DBG_PUTS("InitComLb");

    {
        CIisLbSrvFactory   *pADMClassFactory = new CIisLbSrvFactory;

        if ( pADMClassFactory == NULL )
        {
            DBG_PUTS("InitComLb:OOM");
            CoUninitialize();
            bReturn = FALSE;
        }
        else {
            if ( !InitGlobals() )
            {
                DBG_PUTS("InitComLb:Init");
                CoUninitialize();
                bReturn = FALSE;
            }
            else
            {
                //
                // register the class-object with OLE
                //

                hr = CoRegisterClassObject(CLSID_MSIisLb, pADMClassFactory,
                    CLSCTX_SERVER, REGCLS_MULTIPLEUSE, &g_dwComRegister);

                if (FAILED(hr))
                {
                    DBG_PRINTF(( achE, "InitComLb:CoRegisterClassObject %08x %d", hr, hr ));
                    bReturn = FALSE;
                    CoUninitialize();
                    delete pADMClassFactory;
                    TerminateGlobals();
                }
                else
                {
                    //
                    // register COM object
                    //

                    if ( (g_UserToKernelUpdateEvent = CreateEvent(
                                NULL,
                                FALSE,
                                FALSE,
                                NULL )) == NULL ||
                         (g_hUserToKernelThread = CreateThread(
                                NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)UserToKernelThread,
                                (LPVOID)g_UserToKernelUpdateEvent,
                                0,
                                &dwId )) == NULL )
                    {
                        DBG_PUTS("InitComLb:CreateEvent/CreateThread");

                        CoRevokeClassObject( g_dwComRegister );
                        CoUninitialize();

                        TerminateGlobals();

                        bReturn = FALSE;
                    }
                    else
                    {
                        g_bInitialized = TRUE;
                    }
                }
            }
        }
    }

    return bReturn;
}


BOOL
TerminateComLb(
    )
/*++

Routine Description:

    Terminate COM interface support & user mode <> kernel communication

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if (g_bInitialized)
    {
        g_bInitialized = FALSE;
        CoRevokeClassObject( g_dwComRegister );

        // Stop user<>kernel mode thread

        EnterCriticalSection( &g_csKernelThreadUpdate );

        if ( g_hUserToKernelThread )
        {
            g_fStopUserToKernelThread = TRUE;
            SetEvent( g_UserToKernelUpdateEvent );
            WaitForSingleObject( g_hUserToKernelThread, INFINITE );
            CloseHandle( g_hUserToKernelThread );
            g_hUserToKernelThread = NULL;
        }

        LeaveCriticalSection( &g_csKernelThreadUpdate );

        TerminateGlobals();

        CoUninitialize();

        WSACleanup();
    }

    return TRUE;
}


BOOL
KernelConfigToIpList(
    XBF*    pxbf
    )
/*++

Routine Description:

    Retrieve serialized IP mapping configuration from kernel mode configuration

Arguments:

    pxbf - ptr to buffer updated with serialized configuration

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CIPMap              IpMap;
    CKernelIpEndpointEx*pIp;
    UINT                iPublic;
    UINT                iServ;
    UINT                iRef;
    WCHAR               achAddr[128];


    EnterCriticalSection( &g_csIpListCheckpoint );

    for ( iServ = 0 ;
          iServ < g_KernelIpMap.ServerCount() ;
          ++iServ )
    {
        IpMap.AddComputer( g_KernelIpMap.GetServerName(iServ) );
    }

    // update public IP addresses list

    for ( iPublic = 0 ;
          iPublic < g_KernelIpMap.PublicIpCount() ;
          ++iPublic )
    {
        pIp  = g_KernelIpMap.GetPublicIpPtr( iPublic );
        if ( !g_KernelIpMap.IpEndpointToString( (CKernelIpEndpoint*)pIp, achAddr, sizeof(achAddr) ) ||
             !IpMap.AddIpPublic( achAddr, L"", pIp->m_dwSticky, 0 ) )
        {
            LeaveCriticalSection( &g_csIpListCheckpoint );
            return FALSE;
        }
    }

    // update private IP address for each ( server, public IP ) pairs

    for ( iServ = 0 ;
          iServ < g_KernelIpMap.ServerCount() ;
          ++iServ )
    {
        for ( iPublic = 0 ;
              iPublic < g_KernelIpMap.PublicIpCount() ;
              ++iPublic )
        {
            if ( (iRef = *g_KernelIpMap.GetPrivateIpRef( g_KernelIpMap.GetServerPtr( iServ ),
                                                         iPublic )) == (UINT)-1 )
            {
                if ( !IpMap.SetIpPrivate( iServ, iPublic, L"", L"" ) )
                {
                    LeaveCriticalSection( &g_csIpListCheckpoint );
                    return FALSE;
                }
            }
            else if ( !g_KernelIpMap.IpEndpointToString(
                        (CKernelIpEndpoint*)g_KernelIpMap.GetPrivateIpEndpoint( iRef ),
                        achAddr,
                        sizeof(achAddr) ) ||
                 !IpMap.SetIpPrivate( iServ, iPublic, achAddr, L"" ) )
            {
                LeaveCriticalSection( &g_csIpListCheckpoint );
                return FALSE;
            }
        }
    }

    LeaveCriticalSection( &g_csIpListCheckpoint );

    return IpMap.Serialize( pxbf );
}


BOOL
IpListToKernelConfig(
    CIPMap* pIpMap
    )
/*++

Routine Description:

    Set kernel mode configuration from serialized IP mapping configuration

Arguments:

    pIpMap - IP mapping configuration

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL    fSt = TRUE;
    LPBOOL  pbToBeAdded = NULL;
    LPBOOL  pbToBeDeleted = NULL;
    UINT    iCurrent;
    UINT    iNew;
    LPWSTR  pCurrent;
    LPWSTR  pNew;
    DEBUG_BUFFER;


    EnterCriticalSection( &g_csIpListCheckpoint );

    DBG_PRINTF(( achE, "%d servers", pIpMap->ComputerCount() ));

    if ( (pbToBeAdded = (LPBOOL)LocalAlloc( LPTR, sizeof(BOOL)*pIpMap->ComputerCount())) == NULL ||
         (pbToBeDeleted = (LPBOOL)LocalAlloc( LPTR, sizeof(BOOL)*g_KernelIpMap.ServerCount())) == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }

    // update to be deleted list

    for ( iCurrent = 0 ;
          iCurrent < g_KernelIpMap.ServerCount() ;
          ++iCurrent )
    {
        pbToBeDeleted[iCurrent] = TRUE;
        pCurrent = g_KernelIpMap.GetServerName( iCurrent );

        for ( iNew = 0 ;
              iNew < pIpMap->ComputerCount() ;
              ++iNew )
        {
            pIpMap->EnumComputer( iNew, &pNew );

            if ( !_wcsicmp( pCurrent, pNew ) )
            {
                pbToBeDeleted[iCurrent] = FALSE;
                break;
            }
        }

        if ( pbToBeDeleted[iCurrent] )
        {
            //
            // Not an error to be unable to stop thread : might be stuck doing RPC
            // as computer name will be removed from list ( protected by g_csIpListUpdate )
            // thread will not find computer and will eventually exit.
            //

            g_KernelIpMap.StopServerThread( iCurrent, STOP_PERFMON_THREAD_TIMEOUT );

            EnterCriticalSection( &g_csIpListUpdate );
            g_KernelIpMap.RemoveServer( iCurrent );
            LeaveCriticalSection( &g_csIpListUpdate );

            --iCurrent;     // because iCurrent was deleted
        }
    }

    // update to be added list

    for ( iNew = 0 ;
          iNew < pIpMap->ComputerCount() ;
          ++iNew )
    {
        pbToBeAdded[iNew] = TRUE;
        pIpMap->EnumComputer( iNew, &pNew );

        for ( iCurrent = 0 ;
              iCurrent < g_KernelIpMap.ServerCount() ;
              ++iCurrent )
        {
            pCurrent = g_KernelIpMap.GetServerName( iCurrent );

            if ( !_wcsicmp( pCurrent, pNew ) )
            {
                pbToBeAdded[iNew] = FALSE;
                break;
            }
        }

        if ( pbToBeAdded[iNew] )
        {
            EnterCriticalSection( &g_csIpListUpdate );
            fSt = g_KernelIpMap.AddServer( pNew );
            LeaveCriticalSection( &g_csIpListUpdate );

            if ( !fSt )
            {
                break;
            }
            if ( !(fSt = g_KernelIpMap.StartServerThread( iCurrent )) )
            {
                break;
            }
        }
    }

    // update public IP list

    if ( fSt )
    {
        EnterCriticalSection( &g_csIpListUpdate );
        fSt = g_KernelIpMap.SetPublicIpList( pIpMap );
        LeaveCriticalSection( &g_csIpListUpdate );
    }

cleanup:
    if ( pbToBeAdded )
    {
        LocalFree( pbToBeAdded );
    }

    if ( pbToBeDeleted )
    {
        LocalFree( pbToBeDeleted );
    }

    LeaveCriticalSection( &g_csIpListCheckpoint );

    return fSt;
}


BOOL
KernelConfigToPerfmonCounters(
    XBF*    pxbf
    )
/*++

Routine Description:

    Retrieve serialized perfmon counters configuration from kernel mode configuration

Arguments:

    pxbf - ptr to buffer updated with serialized configuration

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL fSt;

    EnterCriticalSection( &g_csPerfList );
    fSt = g_PerfmonCounterList.Serialize( pxbf );
    LeaveCriticalSection( &g_csPerfList );

    return fSt;
}


BOOL
PerfmonCountersToKernelConfig(
    CComputerPerfCounters*  pPerfmonCounters
    )
/*++

Routine Description:

    Set kernel mode configuration from perfmon counters configuration

Arguments:

    pPerfmonCounters - perfmon counters configuration

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    XBF     xbf;
    UINT    iS;

    EnterCriticalSection( &g_csPerfList );
    if ( !pPerfmonCounters->Serialize( &xbf ) ||
         !g_PerfmonCounterList.Unserialize( &xbf ) )
    {
        return FALSE;
    }
    LeaveCriticalSection( &g_csPerfList );

    // refresh perf list for each computer

    for ( iS = 0 ;
          iS < g_KernelIpMap.ServerCount() ;
          ++iS )
    {
        //
        // if can't stop thread then do not restart it.
        //

        if ( !g_KernelIpMap.StopServerThread( iS, STOP_PERFMON_THREAD_TIMEOUT ) ||
             !g_KernelIpMap.StartServerThread( iS ) )
        {
            continue;
        }
    }

    return TRUE;
}



CKernelIpMapHelper::CKernelIpMapHelper(
    )
/*++

Routine Description:

    CKernelIpMapHelper constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


BOOL
CKernelIpMapHelper::Init(
    )
/*++

Routine Description:

    Initialize kernel configuration object

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CComputerPerfCounters   PerfmonCounters;
    DWORD                   dwStickyDuration;
    LPBYTE                  pB;
    DWORD                   dwC;
    XBF                     xbf;
    DEBUG_BUFFER;

    if ( (m_pKernelIpMap = (CKernelIpMap*)LocalAlloc( LMEM_FIXED, sizeof(CKernelIpMap) )) == NULL )
    {
        DBG_PUTS("InitComLb:OOM");
        return FALSE;
    }
    m_pKernelIpMap->m_dwServerCount = 0;
    m_pKernelIpMap->m_dwPublicIpCount = 0;
    m_pKernelIpMap->m_dwPrivateIpCount = 0;
    m_pKernelIpMap->m_dwStickyDuration = DEFAULT_STICKY_DURATION;

    if ( g_IpMap.Load( HKEY_LOCAL_MACHINE,
                       IISLOADBAL_REGISTRY_KEY,
                       IPLIST_REGISTRY_VALUE ) )
    {
        if ( !IpListToKernelConfig( &g_IpMap ) )
        {
            DBG_PUTS("!IpListToKernelConfig");
            return FALSE;
        }
    }
    else if ( GetLastError() != ERROR_FILE_NOT_FOUND )
    {
        DBG_PRINTF(( achE, "Err read registry line %d : %08x %d\n", __LINE__, GetLastError(), GetLastError() ));
        return FALSE;
    }

    if ( PerfmonCounters.Load( HKEY_LOCAL_MACHINE,
                               IISLOADBAL_REGISTRY_KEY,
                               PERFMON_REGISTRY_VALUE ) )
    {
        if ( !PerfmonCountersToKernelConfig( &PerfmonCounters ) )
        {
            DBG_PUTS("!IpListToKernelConfig");
            return FALSE;
        }
    }
    else if ( GetLastError() != ERROR_FILE_NOT_FOUND )
    {
        DBG_PRINTF(( achE, "Err read registry line %d : %08x %d\n", __LINE__, GetLastError(), GetLastError() ));
        return FALSE;
    }

    if ( LoadBlobFromReg( HKEY_LOCAL_MACHINE,
                          IISLOADBAL_REGISTRY_KEY,
                          STICKY_REGISTRY_VALUE,
                          &xbf ) )
    {
        pB = xbf.GetBuff();
        dwC = xbf.GetUsed();
        if ( !Unserialize( &pB, &dwC, &dwStickyDuration ) )
        {
            DBG_PUTS("!SetStickyDuration");
            return FALSE;
        }
        g_KernelIpMap.SetStickyDuration( dwStickyDuration );
    }
    else if ( GetLastError() != ERROR_FILE_NOT_FOUND )
    {
        DBG_PRINTF(( achE, "Err read registry line %d : %08x %d\n", __LINE__, GetLastError(), GetLastError() ));
        return FALSE;
    }

    return TRUE;
}


BOOL
CKernelIpMapHelper::SetPublicIpList(
    CIPMap* pIpMap
    )
/*++

Routine Description:

    Update public IP list from CIPMap object

Arguments:

    pIpMap - public -> private IP addresses mapping

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    UINT                        iNew;
    LPWSTR                      pNewEntry;
    CKernelIpEndpoint*          pIp;
    UINT                        cNewSize;
    LPBYTE                      pNew;
    UINT                        iP;
    UINT                        iS;
    CKernelServerDescription*   pNewServer;
    CKernelServerDescription*   pOldServer;
    CKernelIpEndpoint           ieNew;
    UINT                        iPrv;
    LPWSTR                      pName;
    DWORD                       dwSticky;
    DWORD                       dwAttr;
    DEBUG_BUFFER;

    // build private IP list of unique private IP in pIpMap
    // ( as array of CKernelIpEndpoint )

    ResetPrivateIpList();

    for ( iS = 0 ;
          iS < ServerCount() ;
          ++iS )
    {
        for ( iP = 0 ;
              iP < pIpMap->IpPublicCount() ;
              ++iP )
        {
            if ( !pIpMap->GetIpPrivate( iS, iP, &pNewEntry, &pName ) ||
                 !StringToIpEndpoint( pNewEntry, &ieNew ) )
            {
                return FALSE;
            }

            // do not add if private Ip address is NULL, i.e. invalid

            if ( ieNew.m_dwIpAddress != 0 &&
                 !CheckAndAddPrivateIp( &ieNew, TRUE, NULL ) )
            {
                return FALSE;
            }
        }
    }

    // resize array

    cNewSize = GetSize( ServerCount(), pIpMap->IpPublicCount(), PrivateIpListCount() );

    DBG_PRINTF(( achE, "SetPublicIpList: SrvCount=%d pub=%d prv=%d sz=%d\n",
        ServerCount(), pIpMap->IpPublicCount(), PrivateIpListCount(), cNewSize ));

    if ( (pNew = (LPBYTE)LocalAlloc( LMEM_FIXED, cNewSize )) == NULL )
    {
        return FALSE;
    }

    *(CKernelIpMap*)pNew = *m_pKernelIpMap;
    ((CKernelIpMap*)pNew)->m_dwPublicIpCount = pIpMap->IpPublicCount();

    // store private IP list

    for ( iP = 0 ;
          EnumPrivateIpList( iP, &pIp ) ;
          ++iP )
    {
        memcpy( GetPrivateIpEndpoint( iP, pNew ), pIp, sizeof(CKernelIpEndpoint) );
    }

    ((CKernelIpMap*)pNew)->m_dwPrivateIpCount = iP;

    // load private IP addresses

    for ( iS = 0 ;
          iS < ServerCount() ;
          ++iS )
    {
        pNewServer = GetServerPtr( iS, pNew, pIpMap->IpPublicCount(), PrivateIpListCount() );
        pOldServer = GetServerPtr( iS );

        memcpy( pNewServer, pOldServer, sizeof(CKernelServerDescription) );

        for ( iP = 0 ;
              iP < pIpMap->IpPublicCount() ;
              ++iP )
        {
            // transcode private IP addr

            if ( !pIpMap->GetIpPrivate( iS, iP, &pNewEntry, &pName ) ||
                 !StringToIpEndpoint( pNewEntry, &ieNew) )
            {
                return FALSE;
            }

            DBG_PRINTF(( achE, "(s=%d,i=%d) -> %ws, IP = %08x\n",
                iS, iP, pNewEntry, ieNew.m_dwIpAddress ));

            if ( ieNew.m_dwIpAddress == 0 )
            {
                // if no mapping then store as invalid index

                iPrv = (UINT)-1;
            }
            else if ( !CheckAndAddPrivateIp( &ieNew, FALSE, &iPrv ) ||
                      iPrv == (UINT)-1 )
            {
                return FALSE;
            }

            *GetPrivateIpRef( pNewServer, iP ) = iPrv;

            DBG_PRINTF(( achE, "pNew=%08x, pNewServer=%08x, IpRef(%d)=%08x : %u\n",
                    pNew, pNewServer, iP, GetPrivateIpRef( pNewServer, iP ), iPrv ));
        }
    }

    LocalFree(m_pKernelIpMap);
    m_pKernelIpMap = (CKernelIpMap*)pNew;

    // store public ip addresses

    for ( iNew = 0 ;
          iNew < pIpMap->IpPublicCount() ;
          ++iNew )
    {
        pIpMap->EnumIpPublic( iNew, &pNewEntry, &pName, &dwSticky, &dwAttr );

        if ( !StringToIpEndpoint( pNewEntry, (CKernelIpEndpoint*)GetPublicIpPtr( iNew ) ) )
        {
            return FALSE;
        }
        GetPublicIpPtr( iNew )->m_dwSticky = dwSticky;
    }

    return TRUE;
}


BOOL
CKernelIpMapHelper::StringToIpEndpoint(
    LPWSTR              pNew,
    CKernelIpEndpoint*  pIp
    )
/*++

Routine Description:

    Convert string ( IP_ADDR:PORT_# ) to IP endpoint object ( sockaddr_in )

Arguments:

    pNew - string representation of IP address + port #
    pIp - updated with IP address + port # in sockaddr_in

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    SOCKADDR            sockaddr;
    int                 csockaddr;
    LPWSTR              pPort;
    BOOL                fSt = FALSE;
    DEBUG_BUFFER;

    if ( pPort = wcschr( pNew, L':' ) )
    {
        *pPort = L'\0';
        csockaddr = sizeof(sockaddr);

        if ( WSAStringToAddressW( pNew, AF_INET, NULL, &sockaddr, &csockaddr ) == 0 )
        {
            memcpy( &pIp->m_dwIpAddress,
                    &((sockaddr_in*)&sockaddr)->sin_addr,
                    sizeof(pIp->m_dwIpAddress) );
            pIp->m_usPort = htons((u_short)_wtoi(pPort +1));
            fSt = TRUE;
        }
        else
        {
            DBG_PRINTF(( achE, "WSAStringToAddress error: %d\n", WSAGetLastError() ));
        }

        *pPort = L':';
    }
    else if ( *pNew )
    {
        csockaddr = sizeof(sockaddr);

        if ( WSAStringToAddressW( pNew, AF_INET, NULL, &sockaddr, &csockaddr ) == 0 )
        {
            memcpy( &pIp->m_dwIpAddress,
                    &((sockaddr_in*)&sockaddr)->sin_addr,
                    sizeof(pIp->m_dwIpAddress) );
            pIp->m_usPort = htons(DEFAULT_IP_PORT);
            fSt = TRUE;
        }
        else
        {
            DBG_PRINTF(( achE, "WSAStringToAddress error: %d\n", WSAGetLastError() ));
        }
    }
    else
    {
        memset( &pIp->m_dwIpAddress,
                '\0',
                sizeof(pIp->m_dwIpAddress) );
        pIp->m_usPort = 0;

        fSt = TRUE;
    }

    return fSt;
}


BOOL
CKernelIpMapHelper::IpEndpointToString(
    CKernelIpEndpoint*  pIp,
    LPWSTR              pAddr,
    DWORD               cAddr
    )
/*++

Routine Description:

    Convert IP endpoint object ( sockaddr_in ) to string ( IP_ADDR:PORT_# )

Arguments:

    pIp - IP address + port # in sockaddr_in
    pAddr - updated with string representation of IP address + port # on success
    cAddr - size of pAddr on input

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    SOCKADDR            sockaddr;
    BOOL                fSt = FALSE;

    if ( pIp->m_dwIpAddress != 0 )
    {
        ((sockaddr_in*)&sockaddr)->sin_family = AF_INET;
        memcpy( &((sockaddr_in*)&sockaddr)->sin_addr,
                &pIp->m_dwIpAddress,
                sizeof(pIp->m_dwIpAddress) );
        ((sockaddr_in*)&sockaddr)->sin_port = pIp->m_usPort;

        if ( WSAAddressToStringW( &sockaddr, sizeof(sockaddr), NULL, pAddr, &cAddr ) == 0 )
        {
            fSt = TRUE;
        }
    }
    else
    {
        *pAddr = L'\0';
        fSt = TRUE;
    }

    return fSt;
}


BOOL
CKernelIpMapHelper::AddServer(
    LPWSTR  pNewServer
    )
/*++

Routine Description:

    Add a server to kernel configuration

Arguments:

    pNewServer - server name

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE              pNew;
    UINT                cNewSize;
    UINT                iS;
    DEBUG_BUFFER;


    cNewSize = GetSize( ServerCount()+1, PublicIpCount(), PrivateIpCount() );
    DBG_PRINTF(( achE, "cNewSize = %d", cNewSize ));

    if ( (pNew = (LPBYTE)LocalAlloc( LMEM_FIXED, cNewSize )) == NULL )
    {
        return FALSE;
    }

    if ( m_ServerNames.AddEntry( pNewServer ) == INDEX_ERROR ||
         m_PerfmonThreadHandle.AddPtr( NULL ) == INDEX_ERROR ||
         m_PerfmonThreadStopEvent.AddPtr( NULL ) == INDEX_ERROR )
    {
        return FALSE;
    }

    // copy existing

    memcpy( pNew, m_pKernelIpMap, GetSize(ServerCount(), PublicIpCount(), PrivateIpCount() ) );
    DBG_PRINTF(( achE, "memcpy( %08x, %08x, %d", pNew, m_pKernelIpMap, GetSize(ServerCount(), PublicIpCount(), PrivateIpCount() ) ));

    LocalFree(m_pKernelIpMap);
    m_pKernelIpMap = (CKernelIpMap*)pNew;

    // init new entry

    memset( GetServerPtr( ServerCount() ), '\0', GetKernelServerDescriptionSize() );
    DBG_PRINTF(( achE, "memset( %08x, %d", GetServerPtr( ServerCount() ), GetKernelServerDescriptionSize() ));

    for ( iS = 0 ;
          iS < LOADBAL_SAMPLES ;
          ++iS )
    {
        GetServerPtr( ServerCount() )->m_flLoadAvail[iS] = 0;
    }
    DBG_PRINTF(( achE, "memset( %08x, %d", GetServerPtr( ServerCount() ), GetKernelServerDescriptionSize() ));

    ++m_pKernelIpMap->m_dwServerCount;
    DBG_PRINTF(( achE, "m_dwServerCount %d", m_pKernelIpMap->m_dwServerCount ));

    return TRUE;
}


BOOL
CKernelIpMapHelper::RemoveServer(
    UINT    i
    )
/*++

Routine Description:

    Remove a server from kernel configuration

Arguments:

    i - server index ( 0-based )

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE              pNew;
    UINT                cNewSize;


    if ( !m_ServerNames.DeleteEntry( i ) ||
         !m_PerfmonThreadHandle.DeletePtr( i ) ||
         !m_PerfmonThreadStopEvent.DeletePtr( i ) )
    {
        return FALSE;
    }

    // remove CKernelServerDescription entry
    // do not reallocate storage ( SetPublicIpList() will typically be called after
    //   this function )

    memmove( GetServerPtr(i),
             GetServerPtr(i+1),
             GetKernelServerDescriptionSize() * (ServerCount()-i-1) );

    --m_pKernelIpMap->m_dwServerCount;

    return TRUE;
}


BOOL
CKernelIpMapHelper::StopServerThread(
    DWORD   iServer,
    DWORD   dwTimeout
    )
/*++

Routine Description:

    Stop the thread monitoring perfmon counters for a specific server

Arguments:

    iServer - server index ( 0-based )

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL    fSt = FALSE;


    // request thread to stop

    if ( SetEvent( (HANDLE)m_PerfmonThreadStopEvent.GetPtr( iServer ) ) &&
         WaitForSingleObject( (HANDLE)m_PerfmonThreadHandle.GetPtr( iServer ), dwTimeout ) == WAIT_OBJECT_0 )
    {
        fSt = TRUE;
    }

    // close thread handle

    if ( (HANDLE)m_PerfmonThreadHandle.GetPtr( iServer ) )
    {
        CloseHandle( (HANDLE)m_PerfmonThreadHandle.GetPtr( iServer ) );
        m_PerfmonThreadHandle.SetPtr( iServer, NULL );
    }

    m_PerfmonThreadStopEvent.SetPtr( iServer, NULL );

    return fSt;
}


BOOL
CKernelIpMapHelper::StartServerThread(
    DWORD   iServer
    )
/*++

Routine Description:

    Start the thread monitoring perfmon counters for a specific server

Arguments:

    iServer - server index ( 0-based )

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CPerfmonThreadControlBlock* pCB = NULL;
    HANDLE                      hThread;
    DWORD                       dwId;

    if ( pCB = new CPerfmonThreadControlBlock)
    {
        if ( ( pCB->m_hStopEvent = CreateEvent( NULL, TRUE, FALSE, NULL )) == NULL )
        {
            goto cleanup;
        }

        if ( !pCB->m_ServerName.Set( GetServerName( iServer ) ) )
        {
            goto cleanup;
        }

        GetServerPtr( iServer )->m_cNbSamplesAvail = 0;
        GetServerPtr( iServer )->m_dwHeartbeat = UNAVAIL_HEARTBEAT;

        if ( (hThread = CreateThread( NULL,
                                      0,
                                      (LPTHREAD_START_ROUTINE)PermonThread,
                                      (LPVOID)pCB,
                                      0,
                                      &dwId )) == NULL )
        {
            goto cleanup;
        }

        m_PerfmonThreadHandle.SetPtr( iServer, (LPVOID)hThread );
        m_PerfmonThreadStopEvent.SetPtr( iServer, (LPVOID)pCB->m_hStopEvent );

        return TRUE;
    }

cleanup:
    if ( pCB )
    {
        if ( pCB->m_hStopEvent != NULL )
        {
            CloseHandle( pCB->m_hStopEvent );
        }
        delete pCB;
    }

    return FALSE;
}


extern "C" DWORD WINAPI
PermonThread(
    LPVOID      pV
    )
/*++

Routine Description:

    Thread monitoring perfmon counters for a specific server
    update & reference g_KernelIpMap
    reference g_csPerfList

Arguments:

    pV - ptr to CPerfmonThreadControlBlock
         This function will have to cleanup resources associated with this control
         block on thread exit.

Return Value:

    NT status

--*/
{
    HQUERY                      hQuery;
    PDH_STATUS                  pdhStatus;
    CPtrXBF                     CounterArray;
    CPtrXBF                     Weight;
    DWORD                       dwWeight;
    HCOUNTER                    hCounter;
    LPWSTR                      pszPerfCounter;
    LPDWORD                     pdwWeight = NULL;
    UINT                        cComputerName;
    CAllocString                ComputerPlusPerfmonCounter;
    UINT                        iPerf;
    UINT                        iPerfName;
    BOOL                        fCreatedCounters = FALSE;
    UINT                        iServ;
    UINT                        cPerf;
    double                      dbAvail;
    double                      dbAcc;
    UINT                        cInst;
    PDH_FMT_COUNTERVALUE        fmtValue;
    DWORD                       ctrType;
    UINT                        iSample = 0;
    CKernelServerDescription*   pServerInfo;
    LPWSTR                      pDel;
    WCHAR                       ch;
    WCHAR                       achInstance[32];
    UINT                        iInstance;
    DWORD                       dwZero;
    DWORD                       dwSizeInstanceList;
    WCHAR                       achInstanceList[3000];
    LPWSTR                      pIns;
    LPWSTR                      pszPerfServer;
    time_t                      tStartCollect;
    BOOL                        fNormalized = FALSE;
    DEBUG_BUFFER;


    CPerfmonThreadControlBlock* pCB = (CPerfmonThreadControlBlock*)pV;
    cComputerName = wcslen( pCB->m_ServerName.Get() );

    for ( ;
          ;
        )
    {
        // query counters

        if ( !fCreatedCounters )
        {
            DBG_PRINTF(( achE, "%ws: create counters\n",
                pCB->m_ServerName.Get() ));

            if ( g_PerfmonCounterList.PerfCounterCount() == 0 )
            {
                goto waitnext;
            }

            pdhStatus = g_pfnPdhOpenQuery (0, 0, &hQuery);

            if ( pdhStatus != ERROR_SUCCESS )
            {
                return pdhStatus;
            }
#if 0
            pdhStatus = PdhConnectMachineW( pCB->m_ServerName.Get() );

            DBG_PRINTF(( achE, "%ws: connect to machine : %x\n",
                pCB->m_ServerName.Get(), pdhStatus ));
#endif
            CounterArray.Reset();
            Weight.Reset();

            EnterCriticalSection( &g_csPerfList );

            for ( iPerfName = 0, iPerf = 0 ;
                  g_PerfmonCounterList.EnumPerfCounter( iPerfName, &pszPerfServer, &pszPerfCounter, &dwWeight ) ;
                  ++iPerfName )
            {
                // if server name was specified in perf counter list, check we are using
                // this server

                if ( pszPerfServer != NULL )
                {
                    // skip possible leading "\\"

                    if ( *pszPerfServer == L'\\' )
                    {
                        pszPerfServer += (sizeof(L"\\\\") / sizeof(WCHAR)) -1;
                    }
                    if ( _wcsicmp( pszPerfServer, pCB->m_ServerName.Get() ) )
                    {
                        continue;
                    }
                }

                // combine computer name & perf name

                ComputerPlusPerfmonCounter.Reset();

                if ( !IncludeServerName( pszPerfCounter ) &&
                     (!ComputerPlusPerfmonCounter.Set( L"\\\\" ) ||
                      !ComputerPlusPerfmonCounter.Append( pCB->m_ServerName.Get() )) )
                {
eallocname:
                    LeaveCriticalSection( &g_csPerfList );

                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                //
                // If this is a multi-instance object, we need to enumerate
                // all instances. Each instance will be a separate counter, but all of the
                // counters for a given object will be averaged before being added to the
                // composite load.
                //

                if ( (pDel = wcschr( pszPerfCounter, L'(' )) &&
                     iswdigit( pDel[1] ) )
                {
                    dwSizeInstanceList = sizeof(achInstanceList) / sizeof(WCHAR);
                    dwZero = 0;
                    *pDel = L'\0';

                    pdhStatus = PdhEnumObjectItemsW( NULL,
                                                     pCB->m_ServerName.Get(),
                                                     pszPerfCounter + 1,
                                                     NULL,       // don't need Counter list
                                                     &dwZero,
                                                     achInstanceList,
                                                     &dwSizeInstanceList,
                                                     100,
                                                     0 );

                    if ( pdhStatus == ERROR_SUCCESS &&
                         dwSizeInstanceList )
                    {
                        for ( pIns = achInstanceList ;
                              *pIns;
                              pIns += wcslen( pIns ) + 1 )
                        {
                            //
                            // do not consider meta instances ( e.g. _Total )
                            //

                            if ( *pIns == '_' )
                            {
                                continue;
                            }

                            ComputerPlusPerfmonCounter.Reset();

                            //
                            // Add an instance
                            //

                            if ( !IncludeServerName( pszPerfCounter ) &&
                                 (!ComputerPlusPerfmonCounter.Set( L"\\\\" ) ||
                                  !ComputerPlusPerfmonCounter.Append( pCB->m_ServerName.Get() )) )
                            {
                                *pDel = L'(';
                                goto eallocname;
                            }

                            if ( !ComputerPlusPerfmonCounter.Append( pszPerfCounter ) ||
                                 !ComputerPlusPerfmonCounter.Append( L"(" ) ||
                                 !ComputerPlusPerfmonCounter.Append( pIns ) ||
                                 !ComputerPlusPerfmonCounter.Append( wcschr(pDel+1,')') ) )
                            {
                                *pDel = L'(';
                                goto eallocname;
                            }

                            if ( (pdhStatus = PdhAddCounterW( hQuery,
                                                              ComputerPlusPerfmonCounter.Get(),
                                                              0,
                                                              &hCounter )) != ERROR_SUCCESS )
                            {
                                DBG_PRINTF(( achE, "%ws: PdhAddCounterW %ws failed : %x\n",
                                    pCB->m_ServerName.Get(),
                                    ComputerPlusPerfmonCounter.Get(),
                                    pdhStatus ));

                                break;
                            }

                            //
                            // All instances after 1st one will have dwWeight set to -1
                            //

                            if ( CounterArray.AddPtr( (LPVOID)hCounter ) == INDEX_ERROR ||
                                 Weight.AddPtr( (LPVOID)dwWeight ) == INDEX_ERROR )
                            {
                                *pDel = L'(';
                                goto eallocname;
                            }

                            dwWeight = (DWORD)-1;
                            ++iPerf;
                        }

                        *pDel = L'(';
                    }
                    else
                    {
                        if ( pdhStatus == ERROR_SUCCESS )
                        {
                            pdhStatus = PDH_CSTATUS_NO_OBJECT;
                        }

                        // can't enumerate instances

                        *pDel = '(';

                        WCHAR achErr[32];
                        LPCWSTR pA[3];
                        pA[0] = pszPerfCounter;
                        pA[1] = pCB->m_ServerName.Get();
                        pA[2] = achErr;
                        _itow( pdhStatus, achErr, 10 );
                        ReportIisLbEvent( EVENTLOG_ERROR_TYPE,
                                IISLB_EVENT_COUNTER_ENUM_ERROR,
                                1,
                                pA );

                        DBG_PRINTF(( achE, "%ws: PdhEnumObjectItemsW %ws failed : %x\n",
                            pCB->m_ServerName.Get(), pszPerfCounter, pdhStatus ));

                        break;
                    }
                }
                else
                {
                    if ( !ComputerPlusPerfmonCounter.Append( pszPerfCounter ) )
                    {
                        goto eallocname;
                    }

                    if ( (pdhStatus = PdhAddCounterW( hQuery,
                                                      ComputerPlusPerfmonCounter.Get(),
                                                      0,
                                                      &hCounter )) != ERROR_SUCCESS )
                    {
                        DBG_PRINTF(( achE, "%ws: PdhAddCounterW %ws failed : %x\n",
                            pCB->m_ServerName.Get(),
                            ComputerPlusPerfmonCounter.Get(),
                            pdhStatus ));

                        break;
                    }

                    if ( CounterArray.AddPtr( (LPVOID)hCounter ) == INDEX_ERROR ||
                         Weight.AddPtr( (LPVOID)dwWeight ) == INDEX_ERROR )
                    {
                        goto eallocname;
                    }

                    ++iPerf;
                }

                if ( pdhStatus != ERROR_SUCCESS )
                {
                    break;
                }
            }

            if ( pdhStatus == ERROR_SUCCESS )
            {
                fCreatedCounters = TRUE;
                cPerf = iPerf;

                DBG_PRINTF(( achE, "%ws: created counters = %d, perf count %d\n",
                    pCB->m_ServerName.Get(), fCreatedCounters, cPerf ));

            }
            else
            {
                CounterArray.Reset();
                Weight.Reset();
                PdhCloseQuery (hQuery);
            }

            LeaveCriticalSection( &g_csPerfList );
        }

        if ( fCreatedCounters )
        {
            tStartCollect = time( NULL );

            pdhStatus = PdhCollectQueryData( hQuery );

            if ( time(NULL) < tStartCollect + COLLECT_TIMEOUT &&
                 pdhStatus == ERROR_SUCCESS &&
                 CheckQueryMachineStatus( hQuery ) )
            {
                // build normalized load avail

                dbAvail = 0;

                for ( iPerf = 0 ;
                      iPerf < cPerf ;
                    )
                {
                    dwWeight = (DWORD)Weight.GetPtr(iPerf); // BUGBUG64

                    for ( cInst = 0, dbAcc = 0 ;
                          ;
                        )
                    {
                        pdhStatus = PdhGetFormattedCounterValue(
                            (HCOUNTER)CounterArray.GetPtr(iPerf),
                            PDH_FMT_DOUBLE,
                            &ctrType,
                            &fmtValue );

                        if ( pdhStatus == ERROR_SUCCESS &&
                             fmtValue.CStatus == PDH_CSTATUS_VALID_DATA )
                        {
                            dbAcc += fmtValue.doubleValue;
                            ++cInst;
                        }
                        else
                        {
                            DBG_PRINTF(( achE, "%ws: failed format counter, status %x cstatus %x\n",
                                pCB->m_ServerName.Get(), pdhStatus, fmtValue.CStatus ));

                            goto err_acc_cnt;
                        }

                        //
                        // Loop for all instances of a given counter name
                        //

                        if ( ++iPerf == cPerf ||
                             (DWORD)Weight.GetPtr(iPerf) != (DWORD)-1 ) // BUGBUG64
                        {
                            break;
                        }
                    }

                    if (pdhStatus == ERROR_SUCCESS)
                    {
                        // add average of all instances
                        // if not an availability flag : in such a case the fact
                        // that we successfully read the counter is enough

                        if ( dwWeight == LB_WEIGHT_NORMALIZED_FLAG )
                        {
                            DBG_PRINTF(( achE, "%ws: raw normalized load is %f\n",
                                pCB->m_ServerName.Get(),
                                ((dbAcc/cInst)) ));
                            dbAvail += ((dbAcc/cInst));
                            fNormalized = TRUE;
                        }
                        else if ( dwWeight != LB_WEIGHT_AVAILABILITY_FLAG )
                        {
                            DBG_PRINTF(( achE, "%ws: raw load is %f weighted load is %f\n",
                                pCB->m_ServerName.Get(),
                                ((dbAcc/cInst)),
                                ((dbAcc/cInst)) * dwWeight ));
                            dbAvail += ((dbAcc/cInst)) * dwWeight;
                        }
                    }
                }
            }
            else
            {
                // failed to access counters :
                // force re-open
err_acc_cnt:
                DBG_PRINTF(( achE, "%ws: failed to get counters, time %d, status %x\n",
                    pCB->m_ServerName.Get(), time(NULL) - tStartCollect, pdhStatus ));

                if ( fCreatedCounters &&
                     cPerf )
                {
                    WCHAR achErr[32];
                    LPCWSTR pA[2];
                    pA[0] = pCB->m_ServerName.Get();
                    pA[1] = achErr;
                    _itow( pdhStatus, achErr, 10 );
                    ReportIisLbEvent( EVENTLOG_ERROR_TYPE,
                            IISLB_EVENT_COUNTER_COLLECT_ERROR,
                            2,
                            pA );
                }

                for ( iPerf = 0 ;
                      iPerf < cPerf ;
                      ++iPerf )
                {
                    pdhStatus = PdhRemoveCounter( (HCOUNTER)CounterArray.GetPtr(iPerf) );
                }

                CounterArray.Reset();
                Weight.Reset();
                PdhCloseQuery( hQuery );
                fCreatedCounters = FALSE;

                dbAvail = 0;
            }
        }
        else
        {
            dbAvail = 0;
        }

        // locate server name in list

        EnterCriticalSection( &g_csIpListUpdate );

        for ( iServ = 0 ;
              iServ < g_KernelIpMap.ServerCount() &&
              _wcsicmp( pCB->m_ServerName.Get(), g_KernelIpMap.GetServerName( iServ ) ) ;
              ++iServ )
        {
        }

        // update load

        if ( iServ < g_KernelIpMap.ServerCount() )
        {
            pServerInfo = g_KernelIpMap.GetServerPtr( iServ );
            g_fNormalized = fNormalized;

            if ( fCreatedCounters )
            {
                DBG_PRINTF(( achE, "%ws: updated slot %d, %f counters\n", pCB->m_ServerName.Get(), iSample, dbAvail ));

                pServerInfo->m_flLoadAvail[iSample] = (float)dbAvail;
                if ( ++iSample == LOADBAL_SAMPLES )
                {
                    iSample = 0;
                }
                if ( pServerInfo->m_cNbSamplesAvail < LOADBAL_SAMPLES )
                {
                    ++pServerInfo->m_cNbSamplesAvail;
                }

                pServerInfo->m_dwHeartbeat = ~UNAVAIL_HEARTBEAT;
            }
            else
            {
                //
                // No counter available. Reset count of available sample
                //

                pServerInfo->m_cNbSamplesAvail = 0;
                iSample = 0;
                pServerInfo->m_dwHeartbeat = UNAVAIL_HEARTBEAT;
            }
        }
        else
        {
            // can't find computer : exit thread

            LeaveCriticalSection( &g_csIpListUpdate );
            break;
        }

        LeaveCriticalSection( &g_csIpListUpdate );

waitnext:

        if ( WaitForSingleObject( pCB->m_hStopEvent, PERFMON_SLEEP_TIME ) == WAIT_OBJECT_0 )
        {
            // stop request
            break;
        }
    }

    // close counters

    if ( fCreatedCounters )
    {
        PdhCloseQuery( hQuery );
    }

    CloseHandle( pCB->m_hStopEvent );

    delete pCB;

    return 0;
}


extern "C" DWORD WINAPI
UserToKernelThread(
    LPVOID  pV
    )
/*++

Routine Description:

    Thread updating kernel mode info with user mode configuration
    through IOCTL

Arguments:

    pV - event handle set by caller to request this thread to stop

Return Value:

    NT status

--*/
{
    CKernelServerDescription*   pS;
    UINT                        iS;
    UINT                        iL;
    UINT                        iDup;
    float                       flLoadAvail;
    float                       flTotalLoadAvail;
    BOOL                        fSt;
    HANDLE                      hDevice;
    DWORD                       dwOutBytes;
    UINT                        cInitialRetries;
    BOOL                        fSomeServUnavailable;
    DWORD                       dwWaitTime;
    IPREF                       iRef;
    HANDLE                      hDriver;
    DEBUG_BUFFER;


    // open driver

    SetLbDriverState( TRUE );

    hDriver = CreateFile( "\\\\.\\" SZDRIVERNAME,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          0,
                          OPEN_EXISTING,
                          0,
                          0 );

    if ( hDriver == INVALID_HANDLE_VALUE )
    {
        WCHAR achErr[32];
        LPCWSTR pA[1];
        pA[0] = achErr;
        _itow( GetLastError(), achErr, 10 );
        DBG_PRINTF(( achE, "CreateFile to access driver %s failed: %u\n", SZDRIVERNAME, GetLastError() ));
        ReportIisLbEvent( EVENTLOG_ERROR_TYPE,
                IISLB_EVENT_DRIVEROPEN_ERROR,
                1,
                pA );

        goto cleanup;
    }

    cInitialRetries = 30;

    for ( ;
          ;
        )
    {
        EnterCriticalSection( &g_csIpListCheckpoint );

        //
        // Compute average for all servers
        //

        for ( iS = 0, flTotalLoadAvail = 0 ;
              iS < g_KernelIpMap.ServerCount() ;
              ++iS )
        {
            pS = g_KernelIpMap.GetServerPtr( iS );

            for ( iL = 0, flLoadAvail = 0 ;
                  iL < pS->m_cNbSamplesAvail ;
                  ++iL )
            {
                flLoadAvail += pS->m_flLoadAvail[iL];
            }

            pS->m_flLoadAvailAvg = iL ? (flLoadAvail / iL) : 0;

            DBG_PRINTF(( achE, "%d: avg load is %f\n", iS, pS->m_flLoadAvailAvg ));

            flTotalLoadAvail += pS->m_flLoadAvailAvg;
        }

        //
        // Per Server Available load is Total / PerServerLoad
        //

        fSomeServUnavailable = FALSE;

        for ( iS = 0;
              iS < g_KernelIpMap.ServerCount() ;
              ++iS )
        {
            pS = g_KernelIpMap.GetServerPtr( iS );

            if( pS->m_dwHeartbeat == UNAVAIL_HEARTBEAT )
            {
                pS->m_flLoadAvailAvg = 0;
                fSomeServUnavailable = TRUE;
            }
            else
            {
                if ( !g_fNormalized )
                {
                    if ( pS->m_flLoadAvailAvg )
                    {
                        pS->m_flLoadAvailAvg = flTotalLoadAvail / pS->m_flLoadAvailAvg;
                    }
                    else
                    {
                        if ( flTotalLoadAvail )
                        {
                            pS->m_flLoadAvailAvg = flTotalLoadAvail;
                        }
                        else
                        {
                            //
                            // Total load is 0 : avail load should be !0 and identical
                            // on all servers.
                            //

                            pS->m_flLoadAvailAvg = LOADBAL_NORMALIZED_TOTAL;
                        }
                    }
                }
            }

            DBG_PRINTF(( achE, "%d: avail load is %f\n", iS, pS->m_flLoadAvailAvg ));
        }

        //
        // recompute total
        //

        flTotalLoadAvail = 0;

        for ( iS = 0 ;
              iS < g_KernelIpMap.ServerCount() ;
              ++iS )
        {
            pS = g_KernelIpMap.GetServerPtr( iS );
            flTotalLoadAvail += pS->m_flLoadAvailAvg;

            if ( !(fSomeServUnavailable && cInitialRetries) )
            {
                pS->m_dwHeartbeat = UNAVAIL_HEARTBEAT;
            }
        }

        //
        // Normalize each server availability so that total availability is
        // LOADBAL_NORMALIZED_TOTAL
        //

        for ( iS = 0;
              iS < g_KernelIpMap.ServerCount() ;
              ++iS )
        {
            pS = g_KernelIpMap.GetServerPtr( iS );
            if ( flTotalLoadAvail )
            {
                pS->m_dwLoadAvail = (DWORD)((pS->m_flLoadAvailAvg * LOADBAL_NORMALIZED_TOTAL) / flTotalLoadAvail);
            }
            else
            {
                pS->m_dwLoadAvail = 0;
            }
            pS->m_LoadbalancedLoadAvail = pS->m_dwLoadAvail;

            DBG_PRINTF(( achE, "Srv %d, available %d\n", iS, pS->m_dwLoadAvail ));
        }

        if ( fSomeServUnavailable &&
             cInitialRetries )
        {
            dwWaitTime = 1000;
            --cInitialRetries;
        }
        else
        {
            cInitialRetries = 0;

            //
            // set all prv IP index to 0
            //

            for ( iL = 0 ;
                  iL < g_KernelIpMap.PrivateIpCount() ;
                  ++iL )
            {
                g_KernelIpMap.GetPrivateIpEndpoint( iL )->m_dwRefCount = 0;
            }

            //
            // scan all public IP addr:port. Set m_usUniquePort to port only once
            // for each port used in public IP list
            // i.e each port will be present only once in m_usUniquePort list
            // needed so that driver knows if notify / unnotify request to NAT is needed
            //

            for ( iL = 0 ;
                  iL < g_KernelIpMap.PublicIpCount() ;
                  ++iL )
            {
                g_KernelIpMap.GetPublicIpPtr( iL )->m_usUniquePort =
                    g_KernelIpMap.GetPublicIpPtr( iL )->m_usPort;

                for ( iDup = 0 ;
                      iDup < iL ;
                      ++iDup )
                {
                    if ( g_KernelIpMap.GetPublicIpPtr( iL )->m_usPort ==
                         g_KernelIpMap.GetPublicIpPtr( iDup )->m_usPort )
                    {
                        g_KernelIpMap.GetPublicIpPtr( iL )->m_usUniquePort = 0;
                        break;
                    }
                }

                //
                // m_dwNotifyPort is used by driver to build notify/unnotify list
                //

                g_KernelIpMap.GetPublicIpPtr( iL )->m_dwNotifyPort =
                    g_KernelIpMap.GetPublicIpPtr( iL )->m_usUniquePort;

                g_KernelIpMap.GetPublicIpPtr( iL )->m_pvDirectorHandle = NULL;
            }

            //
            // scan all pub / servers, inc count for prv if avail load != 0
            // kernel will use it to check if prv IP in use
            //

            for ( iS = 0;
                  iS < g_KernelIpMap.ServerCount() ;
                  ++iS )
            {
                pS = g_KernelIpMap.GetServerPtr( iS );

                if ( pS->m_dwLoadAvail )
                {
                    for ( iL = 0 ;
                          iL < g_KernelIpMap.PublicIpCount() ;
                          ++iL )
                    {
                        iRef = *g_KernelIpMap.GetPrivateIpRef( pS, iL );
                        if ( iRef != -1 )
                        {
                            ++g_KernelIpMap.GetPrivateIpEndpoint( iRef )->m_dwRefCount;
                        }
                    }
                }
            }

            // IOCTL to load balancing driver

            fSt = DeviceIoControl( hDriver,
                                   IOCTL_IISNATIO_SET_CONFIG,
                                   g_KernelIpMap.GetBuffer(),
                                   g_KernelIpMap.GetSize(),
                                   NULL,
                                   0,
                                   &dwOutBytes,
                                   NULL );

            if ( !fSt )
            {
                WCHAR achErr[32];
                LPCWSTR pA[1];
                pA[0] = achErr;
                _itow( GetLastError(), achErr, 10 );
                DBG_PRINTF(( achE, "IoCtl to access driver failed: %u\n", GetLastError() ));
                ReportIisLbEvent( EVENTLOG_ERROR_TYPE,
                        IISLB_EVENT_IOCTL_ERROR,
                        1,
                        pA );
                LeaveCriticalSection( &g_csIpListCheckpoint );
                break;
            }
            else
            {
                DBG_PRINTF(( achE, "IoCtl to access driver success\n" ));
            }

            dwWaitTime = USER_TO_KERNEL_INTERVAL;
        }

        LeaveCriticalSection( &g_csIpListCheckpoint );

        if ( WaitForSingleObject( (HANDLE)pV, dwWaitTime ) == WAIT_OBJECT_0 &&
             g_fStopUserToKernelThread )
        {
            break;
        }
    }

cleanup:

    //close driver

    if ( hDriver != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hDriver );
    }

    SetLbDriverState( FALSE );

    CloseHandle( (HANDLE)pV );

    return 0;
}


BOOL
CKernelIpMapHelper::CheckAndAddPrivateIp(
    CKernelIpEndpoint*  pEndpoint,
    BOOL                fAddIfNotPresent,
    LPUINT              piFound
    )
/*++

Routine Description:

    look for IP Endpoint in private IP list, optionaly returns its index
    optionaly add it to list if not found

Arguments:

    pEndpoint - Endpoint to look for and optionaly add
    fAddIfNotPresent - TRUE to add if endpoint not found in list
    piFound - (optional, can be NULL ) updated with index if found, otherwise -1

Return Value:

    TRUE if no error ( even if not found ), otherwise FALSE

--*/
{
    UINT                iLoop;
    CKernelIpEndpoint*  pLoopEndpoint;

    for ( iLoop = 0 ;
          EnumPrivateIpList( iLoop, &pLoopEndpoint ) ;
          ++iLoop )
    {
        if ( !memcmp( pLoopEndpoint, pEndpoint, sizeof(CKernelIpEndpoint) ) )
        {
            if ( piFound )
            {
                *piFound = iLoop;
            }

            return TRUE;
        }
    }

    if ( piFound )
    {
        *piFound = (UINT)-1;
    }

    if ( fAddIfNotPresent )
    {
        if ( !m_PrivateIpList.Append( (LPBYTE)pEndpoint, (DWORD)sizeof(CKernelIpEndpoint) ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
CKernelIpMapHelper::EnumPrivateIpList(
    UINT                iIndex,
    CKernelIpEndpoint** ppEndpoint
    )
/*++

Routine Description:

    Enumerate endpoints in private IP list

Arguments:

    iIndex - 0 based index
    ppEndpoint - updated with read-only ptr to endpoint

Return Value:

    TRUE if no error, otherwise FALSE ( end of list )

--*/
{
    if ( iIndex < PrivateIpListCount() )
    {
        *ppEndpoint = (CKernelIpEndpoint*)(m_PrivateIpList.GetBuff()) + iIndex;
        return TRUE;
    }

    return FALSE;
}


BOOL
ReportIisLbEvent(
    WORD wType,
    DWORD dwEventId,
    WORD cNbStr,
    LPCWSTR* pStr
    )
/*++

Routine Description:

    Log an event based on type, ID and insertion strings

Arguments:

    wType -- event type ( error, warning, information )
    dwEventId -- event ID ( as defined by the .mc file )
    cNbStr -- nbr of LPWSTR in the pStr array
    pStr -- insertion strings

Returns:

    TRUE if success, FALSE if failure

--*/
{
    BOOL    fSt = TRUE;
    HANDLE  hEventLog = NULL;

    hEventLog = RegisterEventSourceW(NULL,L"IISLB");

    if ( hEventLog != NULL )
    {
        if (!ReportEventW(hEventLog,            // event log handle
                    wType,                      // event type
                    0,                          // category zero
                    (DWORD) dwEventId,          // event identifier
                    NULL,                       // no user security identifier
                    cNbStr,                     // count of substitution strings (may be no strings)
                                                // less ProgName (argv[0]) and Event ID (argv[1])
                    0,                          // no data
                    (LPCWSTR *) pStr,           // address of string array
                    NULL))                      // address of data
        {
            fSt = FALSE;
        }

        DeregisterEventSource( hEventLog );
    }
    else
    {
        fSt = FALSE;
    }

    return fSt;
}


/*===================================================================
InitOleSecurity

Setup for and call CoInitializeSecurity. This will avoid problems with
DCOM security on sites that have no default security.

Parameters:
    None

Returns:
    Retail -- Always returns NOERROR,  failures are ignored.

    Debug -- DBG_ASSERTs on error and returns error code

Side effects:
    Sets desktop
===================================================================*/
HRESULT InitOleSecurity(
    )
    {
    HRESULT hr = NOERROR;
    DWORD err;

    hr = CoInitializeSecurity(
                NULL,
                -1,
                NULL,
                NULL,
                RPC_C_AUTHN_LEVEL_CONNECT,
                RPC_C_IMP_LEVEL_IDENTIFY,
                NULL,
                EOAC_NONE,
                NULL );

    if (SUCCEEDED(hr))
        {
        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        }
        else
        {
            DBG_PUTS( "Failed to set OLE security\n" );
        }

    return(NOERROR);
    }


BOOL
LbAccessCheck(
    DWORD           dwAccess
    )
/*++

Routine Description:

    Perform security access check

Arguments:

    dwAccess - access type FILE_READ_DATA / FILE_WRITE_DATA

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL            bReturn = TRUE;
    HANDLE          hAccTok = NULL;
    DWORD           dwRef;
    LPBYTE          pAcl;
    HKEY            registryKey;
    DWORD           valueType;
    DWORD           valueSize;


    EnterCriticalSection( &g_csAcl );

    if ( (pAcl = g_pAcl) == NULL )
    {

        if ( RegOpenKeyEx( HKEY_CLASSES_ROOT,
                           "APPID\\{a9da4430-65c5-11d1-a700-00a0c922e752}",
                           0,
                           KEY_READ,
                           &registryKey ) == ERROR_SUCCESS )
        {
            valueSize = 0;

            if ( RegQueryValueEx( registryKey,
                                  "AccessPermission",
                                  NULL,
                                  &valueType,
                                  NULL,
                                  &valueSize ) == ERROR_SUCCESS &&
                 ( g_pAcl = (LPBYTE)LocalAlloc( LMEM_FIXED, valueSize )) != NULL )
            {
                if ( RegQueryValueEx( registryKey,
                                      "AccessPermission",
                                      NULL,
                                      &valueType,
                                      g_pAcl,
                                      &valueSize ) != ERROR_SUCCESS )
                {
                    LocalFree( g_pAcl );
                    g_pAcl = NULL;
                }
                else
                {
                    pAcl = g_pAcl;
                }
            }

            RegCloseKey( registryKey );
        }

    }

    if ( pAcl )
    {
        IServerSecurity* pSec;

        //
        // test if already impersonated ( inprocess call w/o marshalling )
        // If not call DCOM to retrieve security context & impersonate, then
        // extract access token.
        //

        if ( OpenThreadToken( GetCurrentThread(),
                              TOKEN_ALL_ACCESS,
                              TRUE,
                              &hAccTok ) )
        {
            pSec = NULL;
        }
        else
        {
            if ( SUCCEEDED( CoGetCallContext( IID_IServerSecurity, (void**)&pSec ) ) )
            {
                pSec->ImpersonateClient();
                if ( !OpenThreadToken( GetCurrentThread(),
                                       TOKEN_EXECUTE|TOKEN_QUERY,
                                       TRUE,
                                       &hAccTok ) )
                {
                    hAccTok = NULL;
                }
            }
            else
            {
                pSec = NULL;
            }
        }

        if ( hAccTok )
        {
            DWORD dwAcc;

            //
            // Protected properties require EXECUTE access rights instead of WRITE
            //

            if ( dwAccess & FILE_WRITE_DATA )
            {
                dwAcc = COM_RIGHTS_EXECUTE;
            }
            else
            {
                dwAcc = COM_RIGHTS_EXECUTE;
            }

            DWORD         dwGrantedAccess;
            BYTE          PrivSet[400];
            DWORD         cbPrivilegeSet = sizeof(PrivSet);
            BOOL          fAccessGranted;

            if ( !AccessCheck( pAcl,
                               hAccTok,
                               dwAcc,
                               &g_FileGenericMapping,
                               (PRIVILEGE_SET *) &PrivSet,
                               &cbPrivilegeSet,
                               &dwGrantedAccess,
                               &fAccessGranted ) ||
                 !fAccessGranted )
            {
                //
                // If read access denied, retry with restricted read right
                // only if not called from GetAll()
                //

                bReturn = FALSE;
            }
            CloseHandle( hAccTok );
        }
        else
        {
            //
            // For now, assume failure to get IServerSecurity means we are
            // in the SYSTEM context, so grant access.
            //

            bReturn = TRUE;
        }

        if ( pSec )
        {
            pSec->RevertToSelf();
            pSec->Release();
        }
    }
    else
    {
        //
        // No ACL : access check succeed
        //

        bReturn = TRUE;
    }

    if ( !bReturn )
    {
        SetLastError( ERROR_ACCESS_DENIED );
    }

    LeaveCriticalSection( &g_csAcl );

    return bReturn;
}


VOID
FlushLbAccessCheck(
    )
/*++

Routine Description:

    Flush access check ACL cache

Arguments:

    None

Returns:

    Nothing

--*/
{
    EnterCriticalSection( &g_csAcl );

    if ( g_pAcl != NULL )
    {
        LocalFree( g_pAcl );
        g_pAcl = NULL;
    }

    LeaveCriticalSection( &g_csAcl );
}



HRESULT
WaitForServiceStatus(
    SC_HANDLE   schDependent,
    DWORD       dwDesiredServiceState
    )
/*++

Routine Description:

    Wait for status of specified service to match desired state
    with MAX_SLEEP timeout

Arguments:

    schDependent - service/driver to monitor
    dwDesiredServiceState - service/driver state to wait for

Returns:

    STATUS_SUCCESS if success, otherwise error status

--*/
{
    DWORD           dwSleepTotal = 0;
    SERVICE_STATUS  ssDependent;
    DEBUG_BUFFER;

    while ( dwSleepTotal < MAX_SLEEP )
    {
        if ( QueryServiceStatus( schDependent, &ssDependent ) )
        {
            if ( ssDependent.dwCurrentState == dwDesiredServiceState )
            {
                return S_OK;
            }
            else
            {
                //
                // Still pending...
                //
                Sleep( SLEEP_INTERVAL );

                dwSleepTotal += SLEEP_INTERVAL;

                DBG_PRINTF(( achE, "WaitForServiceStatus sleep, state is %u waiting for %u",
                             ssDependent.dwCurrentState, dwDesiredServiceState ));
            }
        }
        else
        {
            return RETURNCODETOHRESULT( GetLastError() );
        }
    }

    return RETURNCODETOHRESULT( ERROR_SERVICE_REQUEST_TIMEOUT );
}


HRESULT
SetLbDriverState(
    BOOL        fStart
    )
/*++

Routine Description:

    Start/Stop Load balancing driver

Arguments:

    fStart - TRUE to start driver, FALSE to stop

Returns:

    STATUS_SUCCESS if success, otherwise error status

--*/
{
    SC_HANDLE           schSCM;
    SC_HANDLE           schDependent;
    HRESULT             hresReturn = S_OK;
    SERVICE_STATUS      ssDependent;
    DEBUG_BUFFER;


    schSCM = OpenSCManager( NULL,
                            NULL,
                            SC_MANAGER_ALL_ACCESS);

    if ( schSCM == NULL )
    {
        hresReturn = RETURNCODETOHRESULT(GetLastError());
    }
    else
    {
        schDependent = OpenService( schSCM,
                                    SZDRIVERNAME,
                                    SERVICE_ALL_ACCESS );

        if (schDependent != NULL)
        {
            if ( fStart )
            {
                if ( !StartService( schDependent, 0, NULL ) )
                {
                    if ( GetLastError() != ERROR_SERVICE_ALREADY_RUNNING )
                    {
                        hresReturn = RETURNCODETOHRESULT( GetLastError() );
                        DBG_PRINTF(( achE, "SetLbDriverState:StartService %u", GetLastError() ));
                    }
                }
                else
                {
                    DBG_PRINTF(( achE, "SetLbDriverState:StartService success\n" ));
                }
            }
            else
            {
                if ( ControlService( schDependent, SERVICE_CONTROL_STOP, &ssDependent ) ||
                     GetLastError() == ERROR_INVALID_SERVICE_CONTROL )
                {
                    hresReturn = WaitForServiceStatus( schDependent, SERVICE_STOPPED );
                }
                else
                {
                    if ( GetLastError() != ERROR_SERVICE_NOT_ACTIVE )
                    {
                        hresReturn = RETURNCODETOHRESULT( GetLastError() );
                        DBG_PRINTF(( achE, "SetLbDriverState:ControlService %u", GetLastError() ));
                    }
                }
                CloseServiceHandle( schDependent );
            }
        }
        else
        {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            DBG_PRINTF(( achE, "SetLbDriverState:OpenService %u", GetLastError() ));
        }

        CloseServiceHandle( schSCM );
    }

    return hresReturn;
}


BOOL
CheckQueryMachineStatus(
    HQUERY  hQuery
    )
/*++

Routine Description:

    Check machine status in query
    This is not the same as checking the result of PdhCollectQueryData() and CStatus
    of each counter, as PDH library will attempt to reconnect before reporting an
    invalid status, so 1st query after disconnect will give back success status.

Arguments:

    hQuery - PDH query

Returns:

    TRUE if all machine status OK, otherwise FALSE

--*/
{
    PPDHI_QUERY_MACHINE pQMachine;
    PPDHI_QUERY         pQuery = (PPDHI_QUERY)hQuery;
    DEBUG_BUFFER;

    //
    // Check that the structure is something we understand
    //

    if ( g_dwPdhVersion == ((DWORD)((PDH_CVERSION_WIN40) + 0x0003)) )
    {
        pQMachine = pQuery->pFirstQMachine;
        while (pQMachine != NULL)
        {
            DBG_PRINTF(( achE, "Machine %ws status %x\n",
                         pQMachine->pMachine->szName,
                         pQMachine->pMachine->dwStatus ));

            if ( pQMachine->pMachine->dwStatus != ERROR_SUCCESS )
            {
                return FALSE;
            }

            pQMachine = pQMachine->pNext;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\serv\servhnd.cxx ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   simple.c
//
//  PURPOSE:  Implements the body of the service.
//            The default behavior is to open a
//            named pipe, \\.\pipe\simple, and read
//            from it.  It the modifies the data and
//            writes it back to the pipe.
//
//  FUNCTIONS:
//            ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
//            ServiceStop( );
//
//  COMMENTS: The functions implemented in simple.c are
//            prototyped in service.h
//              
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include "service.h"

#include "bootexp.hxx"

// this event is signalled when the
// service should end
//
HANDLE  hServerStopEvent = NULL;


//
//  FUNCTION: ServiceStart
//
//  PURPOSE: Actual code of the service
//           that does the work.
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//

VOID 
ServiceStart(
    DWORD   dwArgc, 
    LPTSTR* lpszArgv
    )
{
    HANDLE                  hEvents[2] = {NULL, NULL};
    BOOL                    bRet;
    DWORD                   dwWait;

    ///////////////////////////////////////////////////
    //
    // Service initialization
    //

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        SERVICE_UPDATE_WAIT_HINT))                // wait hint
        goto cleanup;

    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    //
    hServerStopEvent = CreateEvent(
        NULL,    // no security attributes
        TRUE,    // manual reset event
        FALSE,   // not-signalled
        NULL);   // no name

    if ( hServerStopEvent == NULL)
        goto cleanup;

    hEvents[0] = hServerStopEvent;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        SERVICE_UPDATE_WAIT_HINT))                // wait hint
        goto cleanup;

    InitComLb();

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_RUNNING,       // service state
        NO_ERROR,              // exit code
        0))                    // wait hint
        goto cleanup;

    //
    // End of initialization
    //
    ////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////
    //
    // Service is now running, perform work until shutdown
    //

    dwWait = WaitForMultipleObjects( 1, hEvents, FALSE, INFINITE );

  cleanup:

    if (hServerStopEvent)
        CloseHandle(hServerStopEvent);

    TerminateComLb();
}


//
//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//    
VOID ServiceStop()
{
    if ( hServerStopEvent )
        SetEvent(hServerStopEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mdadmin\admsub.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    admsub.cxx

    This module contains IISADMIN subroutines.


    FILE HISTORY:
    7/7/97      michth      created
*/
#define INITGUID
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <apiutil.h>
#include <loadmd.hxx>
#include <loadadm.hxx>
#include <ole2.h>
#include <inetsvcs.h>
#include <ntsec.h>
#include <string.hxx>
#include <registry.hxx>
#include <iadmext.h>
#include <admsub.hxx>
#include <stringau.hxx>
#include <imd.h>
#include <iiscnfg.h>

PIADMEXT_CONTAINER        g_piaecHead = NULL;

HRESULT AddServiceExtension(IADMEXT *piaeExtension)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    PIADMEXT_CONTAINER piaecExtension = new IADMEXT_CONTAINER;

    if (piaecExtension == NULL) {
        hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        piaecExtension->piaeInstance = piaeExtension;
        piaecExtension->NextPtr = g_piaecHead;
        g_piaecHead = piaecExtension;
    }
    return hresReturn;
}

VOID
StartServiceExtension(LPTSTR pszExtension)
{
    HRESULT hresError;
    CLSID clsidExtension;
    IADMEXT *piaeExtension;
    STRAU strauCLSID(pszExtension);

    if (strauCLSID.IsValid() && (strauCLSID.QueryStrW() != NULL)) {

        hresError = CLSIDFromString(strauCLSID.QueryStrW(),
                                    &clsidExtension);

        if (SUCCEEDED(hresError)) {
            hresError = CoCreateInstance(clsidExtension,
                                         NULL,
                                         CLSCTX_SERVER,
                                         IID_IADMEXT,
                                         (void**) &piaeExtension);
            if (SUCCEEDED(hresError)) {
                hresError = piaeExtension->Initialize();
                if (SUCCEEDED(hresError)) {
                    hresError = AddServiceExtension(piaeExtension);
                    if (FAILED(hresError)) {
                        piaeExtension->Terminate();
                    }
                }
                if (FAILED(hresError)) {
                    piaeExtension->Release();
                }
            }
        }
    }
}

VOID
StartServiceExtensions()
{
    DBG_ASSERT(g_piaecHead == NULL);

    MDRegKey mdrkMain(HKEY_LOCAL_MACHINE,
                      IISADMIN_EXTENSIONS_REG_KEY);
    if (GetLastError() == ERROR_SUCCESS) {
        MDRegKeyIter *pmdrkiCLSID = new MDRegKeyIter(mdrkMain);
        if ((pmdrkiCLSID != NULL) && (GetLastError() == ERROR_SUCCESS)) {
            LPTSTR pszExtension;
            for (DWORD dwIndex = 0;
                pmdrkiCLSID->Next(&pszExtension, NULL, dwIndex) == ERROR_SUCCESS;
                dwIndex++) {
                StartServiceExtension(pszExtension);
            }
        }
        delete (pmdrkiCLSID);
    }
}

BOOL
RemoveServiceExtension(IADMEXT **ppiaeExtension)
{
    BOOL bReturn = FALSE;
    if (g_piaecHead != NULL) {
        PIADMEXT_CONTAINER piaecExtension = g_piaecHead;
        *ppiaeExtension = g_piaecHead->piaeInstance;
        g_piaecHead = g_piaecHead->NextPtr;
        delete piaecExtension;
        bReturn = TRUE;
    }
    return bReturn;
}

VOID
StopServiceExtension(IADMEXT *piaeExtension)
{
    piaeExtension->Terminate();
    piaeExtension->Release();
}


VOID StopServiceExtensions()
{
    IADMEXT *piaeExtension;

    while (RemoveServiceExtension(&piaeExtension)) {
        StopServiceExtension(piaeExtension);
    }
    DBG_ASSERT(g_piaecHead == NULL);
}

HRESULT
AddClsidToBuffer(CLSID clsidDcomExtension,
                 BUFFER *pbufCLSIDs,
                 DWORD *pdwMLSZLen,
                 LPMALLOC pmallocOle)
{
    HRESULT hresReturn = S_OK;

    LPWSTR pszCLSID;

    if (!pbufCLSIDs->Resize((*pdwMLSZLen + CLSID_LEN) * sizeof(WCHAR))) {
        hresReturn =  HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        if (SUCCEEDED(StringFromCLSID(clsidDcomExtension, &pszCLSID))) {
            DBG_ASSERT(wcslen(pszCLSID) + 1 == CLSID_LEN);
            memcpy(((LPWSTR)pbufCLSIDs->QueryPtr()) + *pdwMLSZLen, pszCLSID, CLSID_LEN * sizeof(WCHAR));
            (*pdwMLSZLen) += CLSID_LEN;
            if (pmallocOle != NULL) {
                pmallocOle->Free(pszCLSID);
            }
        }
    }
    return hresReturn;
}

VOID
RegisterServiceExtensionCLSIDs()
{
    HRESULT hresMDError;
    HRESULT hresExtensionError;
    HRESULT hresBufferError;
    HRESULT hresCom;
    CLSID clsidDcomExtension;
    DWORD i;
    IMDCOM * pcCom = NULL;
    METADATA_HANDLE mdhRoot;
    METADATA_HANDLE mdhExtension;
    METADATA_RECORD mdrData;
    PIADMEXT_CONTAINER piaecExtension;
    BUFFER bufCLSIDs;
    DWORD dwMLSZLen = 0;
    BOOL bAreCLSIDs = FALSE;
    LPMALLOC pmallocOle = NULL;

    hresCom = CoGetMalloc(1, &pmallocOle);
    if( SUCCEEDED(hresCom) ) {

        hresMDError = CoCreateInstance(CLSID_MDCOM,
                                       NULL,
                                       CLSCTX_SERVER,
                                       IID_IMDCOM,
                                       (void**) &pcCom);
        if (SUCCEEDED(hresMDError)) {
            hresMDError = pcCom->ComMDInitialize();
            if (SUCCEEDED(hresMDError)) {

                hresMDError = pcCom->ComMDOpenMetaObject(
                    METADATA_MASTER_ROOT_HANDLE,
                    (PBYTE)IISADMIN_EXTENSIONS_CLSID_MD_KEY,
                    METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                    MD_OPEN_DEFAULT_TIMEOUT_VALUE,
                    &mdhExtension);
                if (hresMDError == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
                    hresMDError = pcCom->ComMDOpenMetaObject(
                        METADATA_MASTER_ROOT_HANDLE,
                        NULL,
                        METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                        MD_OPEN_DEFAULT_TIMEOUT_VALUE,
                        &mdhRoot);
                    if (SUCCEEDED(hresMDError)) {
                        hresMDError = pcCom->ComMDAddMetaObject(
                            mdhRoot,
                            (PBYTE)IISADMIN_EXTENSIONS_CLSID_MD_KEY);
                        pcCom->ComMDCloseMetaObject(mdhRoot);
                        if (SUCCEEDED(hresMDError)) {
                            hresMDError = pcCom->ComMDOpenMetaObject(
                                METADATA_MASTER_ROOT_HANDLE,
                                (PBYTE)IISADMIN_EXTENSIONS_CLSID_MD_KEY,
                                METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                MD_OPEN_DEFAULT_TIMEOUT_VALUE,
                                &mdhExtension);
                        }
                    }
                }
                if (SUCCEEDED(hresMDError)) {

                    pcCom->ComMDDeleteMetaData(
                        mdhExtension,
                        NULL,
                        MD_IISADMIN_EXTENSIONS,
                        MULTISZ_METADATA);

                    for (piaecExtension = g_piaecHead, hresBufferError = S_OK;
                         (piaecExtension != NULL) && (SUCCEEDED(hresBufferError));
                         piaecExtension = piaecExtension->NextPtr) {
                        hresMDError = ERROR_SUCCESS;
                        for (i = 0;
                            SUCCEEDED(hresExtensionError =
                                      piaecExtension->piaeInstance->EnumDcomCLSIDs(&clsidDcomExtension,
                                                                                   i));
                            i++) {
                            bAreCLSIDs = TRUE;
                            hresBufferError = AddClsidToBuffer(clsidDcomExtension,
                                                               &bufCLSIDs,
                                                               &dwMLSZLen,
                                                               pmallocOle);
                            if (FAILED(hresBufferError)) {
                                break;
                            }

                        }
                    }
                    if (bAreCLSIDs && SUCCEEDED(hresBufferError)) {
                        if (bufCLSIDs.Resize((dwMLSZLen + 1) * sizeof(WCHAR))) {
                            *(((LPWSTR)bufCLSIDs.QueryPtr()) + dwMLSZLen) = (WCHAR)'\0';
                            mdrData.dwMDAttributes = METADATA_NO_ATTRIBUTES;
                            mdrData.dwMDUserType = IIS_MD_UT_SERVER;
                            mdrData.dwMDDataType = MULTISZ_METADATA;
                            mdrData.dwMDDataLen = (dwMLSZLen + 1) * sizeof(WCHAR);
                            mdrData.pbMDData = (PBYTE)bufCLSIDs.QueryPtr();
                            mdrData.dwMDIdentifier = IISADMIN_EXTENSIONS_CLSID_MD_ID;
                            hresMDError = pcCom->ComMDSetMetaDataW(
                                mdhExtension,
                                NULL,
                                &mdrData);
                        }
                    }
                    pcCom->ComMDCloseMetaObject(mdhExtension);
                }
                pcCom->ComMDTerminate(TRUE);
            }
            pcCom->Release();
        }
        if (pmallocOle != NULL) {
            pmallocOle->Release();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\serv\service.cxx ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.c
//
//  PURPOSE:  Implements functions required by all services
//            windows.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    service_main(DWORD dwArgc, LPTSTR *lpszArgv);
//    CmdInstallService();
//    CmdRemoveService();
//    CmdDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>

#include "service.h"

#include "bootexp.hxx"

// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;
BOOL                    bDebug = FALSE;
TCHAR                   szErr[256];

// internal function prototypes
VOID WINAPI service_ctrl(DWORD dwCtrlCode);
VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID CmdInstallService();
VOID CmdRemoveService();
VOID CmdDebugService(int argc, char **argv);
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );

//
//  FUNCTION: main
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    main() either performs the command line task, or
//    call StartServiceCtrlDispatcher to register the
//    main service thread.  When the this call returns,
//    the service has stopped, so exit.
//
void __cdecl main(int argc, char **argv)
{
    SERVICE_TABLE_ENTRY dispatchTable[] =
    {
        { TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main },
        { NULL, NULL }
    };

    if ( (argc > 1) &&
         ((*argv[1] == '-') || (*argv[1] == '/')) )
    {
        if ( _stricmp( "install", argv[1]+1 ) == 0 )
        {
            CmdInstallService();
        }
        else if ( _stricmp( "remove", argv[1]+1 ) == 0 )
        {
            CmdRemoveService();
        }
        else if ( _stricmp( "register", argv[1]+1 ) == 0 )
        {
            BootDllRegisterServer();
        }
        else if ( _stricmp( "unregister", argv[1]+1 ) == 0 )
        {
            BootDllUnregisterServer();
        }
        else if ( _stricmp( "debug", argv[1]+1 ) == 0 )
        {
            bDebug = TRUE;
            CmdDebugService(argc, argv);
        }
        else
        {
            goto dispatch;
        }
        exit(0);
    }

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher
    dispatch:
        // this is just to be friendly
        printf( "%s -install          to install the service\n", SZAPPNAME );
        printf( "%s -remove           to remove the service\n", SZAPPNAME );
        printf( "%s -debug <params>   to run as a console app for debugging\n", SZAPPNAME );
        printf( "\nStartServiceCtrlDispatcher being called.\n" );
        printf( "This may take several seconds.  Please wait.\n" );

        if (!StartServiceCtrlDispatcher(dispatchTable))
            AddToMessageLog(TEXT("StartServiceCtrlDispatcher failed."));
}



//
//  FUNCTION: service_main
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl);

    if (!sshStatusHandle)
        goto cleanup;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        SERVICE_UPDATE_WAIT_HINT ))     // wait hint
        goto cleanup;


    ServiceStart( dwArgc, lpszArgv );

cleanup:

    // try to report the stopped status to the service control manager.
    //
    if (sshStatusHandle)
        (VOID)ReportStatusToSCMgr(
                            SERVICE_STOPPED,
                            dwErr,
                            0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        // SERVICE_STOP_PENDING should be reported before
        // setting the Stop Event - hServerStopEvent - in
        // ServiceStop().  This avoids a race condition
        // which may result in a 1053 - The Service did not respond...
        // error.
        case SERVICE_CONTROL_STOP:
            ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, SERVICE_UPDATE_WAIT_HINT);
            ServiceStop();
            return;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if ( !bDebug ) // when debugging we don't report to the SCM
    {
        if (dwCurrentState == SERVICE_START_PENDING)
            ssStatus.dwControlsAccepted = 0;
        else
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) )
            ssStatus.dwCheckPoint = 0;
        else
            ssStatus.dwCheckPoint = dwCheckPoint++;


        // Report the status of the service to the service control manager.
        //
        if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
            AddToMessageLog(TEXT("SetServiceStatus"));
        }
    }
    return fResult;
}



//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(LPTSTR lpszMsg)
{
    TCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[2];


    if ( !bDebug )
    {
        dwErr = GetLastError();

        // Use event logging to log the error.
        //
        hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));

        _stprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), dwErr);
        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        if (hEventSource != NULL) {
            ReportEvent(hEventSource, // handle of event source
                EVENTLOG_ERROR_TYPE,  // event type
                0,                    // event category
                0,                    // event ID
                NULL,                 // current user's SID
                2,                    // strings in lpszStrings
                0,                    // no bytes of raw data
                (const char **)lpszStrings,          // array of error strings
                NULL);                // no raw data

            (VOID) DeregisterEventSource(hEventSource);
        }
    }
}




///////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//


//
//  FUNCTION: CmdInstallService()
//
//  PURPOSE: Installs the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdInstallService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    TCHAR szPath[512];

    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
    {
        _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZSERVICENAME),        // name of service
            TEXT(SZSERVICEDISPLAYNAME), // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            NULL,                       // LocalSystem account
            NULL);                      // no password

        if ( schService )
        {
            _tprintf(TEXT("%s installed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            CloseServiceHandle(schService);
        }
        else
        {
            _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZDRIVERNAME),         // name of service
            TEXT(SZDRIVERDISPLAYNAME),  // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_KERNEL_DRIVER,      // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            TEXT(SZDRIVERPATH),         // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            NULL,                       // LocalSystem account
            NULL);                      // no password

        if ( schService )
        {
            _tprintf(TEXT("%s (driver) installed.\n"), TEXT(SZDRIVERDISPLAYNAME) );
            CloseServiceHandle(schService);
        }
        else
        {
            _tprintf(TEXT("CreateService for driver failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}



//
//  FUNCTION: CmdRemoveService()
//
//  PURPOSE: Stops and removes the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, TEXT(SZSERVICENAME), SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
                Sleep( 1000 );

                while( QueryServiceStatus( schService, &ssStatus ) )
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                    {
                        _tprintf(TEXT("."));
                        Sleep( 1000 );
                    }
                    else
                        break;
                }

                if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                    _tprintf(TEXT("\n%s stopped.\n"), TEXT(SZSERVICEDISPLAYNAME) );
                else
                    _tprintf(TEXT("\n%s failed to stop.\n"), TEXT(SZSERVICEDISPLAYNAME) );

            }

            // now remove the service
            if( DeleteService(schService) )
                _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            else
                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));

            CloseServiceHandle(schService);
        }
        else
        {
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));
        }

        schService = OpenService(schSCManager, TEXT(SZDRIVERNAME), SERVICE_ALL_ACCESS);

        if (schService)
        {
            // now remove the service
            if( DeleteService(schService) )
                _tprintf(TEXT("%s (driver) removed.\n"), TEXT(SZDRIVERDISPLAYNAME) );
            else
                _tprintf(TEXT("DeleteService for driver failed - %s\n"), GetLastErrorText(szErr,256));

            CloseServiceHandle(schService);
        }
        else
        {
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));
        }


        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}




///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//


//
//  FUNCTION: CmdDebugService(int argc, char ** argv)
//
//  PURPOSE: Runs the service as a console application
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdDebugService(int argc, char ** argv)
{
    DWORD dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME));

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    ServiceStart( dwArgc, lpszArgv );
}


//
//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
//
//  PURPOSE: Handled console control events
//
//  PARAMETERS:
//    dwCtrlType - type of control event
//
//  RETURN VALUE:
//    True - handled
//    False - unhandled
//
//  COMMENTS:
//
BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZSERVICEDISPLAYNAME));
            ServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}

//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\loadbal\serv\service.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: service.h
//
//  AUTHOR: Craig Link
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and 
//  implement the ServiceStart() and ServiceStop() functions.
//  
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            "IISLB"
// displayed name of the service
#define SZSERVICEDISPLAYNAME "IIS Load Balancing Service"
// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       ""

// displayed name of the driver
#define SZDRIVERDISPLAYNAME "IIS Load Balancing Driver"
#define SZDRIVERPATH        "\\SystemRoot\\System32\\drivers\\IISLBK.SYS"

#define SERVICE_UPDATE_WAIT_HINT        (200*1000)

//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
void AddToMessageLog(LPTSTR lpszMsg);
//////////////////////////////////////////////////////////////////////////////


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mdadmin\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    main.cxx

    This module contains the main startup code for the IISADMIN Service.

    Functions exported by this module:

        ServiceEntry


    FILE HISTORY:
        michth - created
*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include <dbgutil.h>
#include <apiutil.h>
#include <loadmd.hxx>
#include <loadadm.hxx>
#include <ole2.h>
#include <inetsvcs.h>
#include <ntsec.h>
#include <iadmext.h>
#include <string.hxx>
#include <admsub.hxx>
#include <registry.hxx>
#include <imd.h>
#include <irtlmisc.h>
#include "mdwriter.hxx"
#include "iisadminmb.hxx"

#define IISADMIN_SERVICE_NAME               TEXT("IISADMIN")
#define QueryServiceName()                 IISADMIN_SERVICE_NAME
#define NULL_SERVICE_STATUS_HANDLE      ((SERVICE_STATUS_HANDLE ) NULL)

#define IISADMIN_SVC_KEY                    "SYSTEM\\CurrentControlSet\\Services\\IISADMIN"
#define IISADMIN_STARTUP_WAITHINT_VALUE             "StartupWaitHintInMilliseconds"

//
// Note:  Due to how the system starts up, we can not have another thread that lies to the SCM
// and tells it we are still starting, so instead we are going to have a hard coded startup time
// limit of 3 minutes.  However, there is also a registry key that can override this value if we
// ever need to bump the start time limit to a larger value.
//
#define SERVICE_START_WAIT_HINT         (180000)        // milliseconds = 180 seconds = 3 minutes

//
// For shutdown it is fine to have the thread lie-ing to the SCM because it will not block any
// vital system operations ( like startup )
//
#define SERVICE_STOP_WAIT_HINT          (10000)        // milliseconds = 10 seconds
#define SERVICE_UPDATE_STATUS           (9000)         // milliseconds = 9 seconds (must be less that the stop wait hint)

//
//  Default timeout for SaveMetabase
//

#define MB_SAVE_TIMEOUT      (10000)        // milliseconds


BOOL g_fIgnoreSC = FALSE;
BOOL g_fAsExe = FALSE;

SERVICE_STATUS          g_svcStatus;
SERVICE_STATUS_HANDLE   g_hsvcStatus;
HANDLE                  g_hShutdownEvent = NULL;
HANDLE                  g_hComHackThread = NULL;

//
// Debugging stuff
//

#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisAdminGuid, 
0x784d8918, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif
DECLARE_DEBUG_PRINTS_OBJECT();

typedef struct _THREAD_PARAMS {
    HANDLE hInitEvent;
    BOOL   bInitSuccess;
} THREAD_PARAMS, *PTHREAD_PARAMS;

extern "C" {
BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

DWORD
GetStartupWaitHint();


BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
/*++

Routine Description:

    DLL entrypoint.

Arguments:

    hDLL          - Instance handle.

    Reason        - The reason the entrypoint was called.
                    DLL_PROCESS_ATTACH
                    DLL_PROCESS_DETACH
                    DLL_THREAD_ATTACH
                    DLL_THREAD_DETACH

    Reserved      - Reserved.

Return Value:

    BOOL          - TRUE if the action succeeds.

--*/
{
    BOOL bReturn = TRUE;
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("IISADMIN");
        SET_DEBUG_FLAGS(DEBUG_ERROR);
#else
        CREATE_DEBUG_PRINT_OBJECT("IISADMIN", IisAdminGuid);
#endif
        break;

    case DLL_PROCESS_DETACH:
        DELETE_DEBUG_PRINT_OBJECT( );
        break;

    default:
        break;
    }

    return bReturn;
}

DWORD
ReportServiceStatus( VOID)
/*++
    Description:

        Wraps the call to SetServiceStatus() function.
        Prints the service status data if need be

    Arguments:

        None

    Returns:

        NO_ERROR if successful. other Win32 error code on failure.
        If successfull the new status has been reported to the service
         controller.
--*/
{
    DWORD err = NO_ERROR;

    if (!g_fIgnoreSC) {

        IF_DEBUG( DLL_SERVICE_INFO)   
        {

              DBGPRINTF(( DBG_CONTEXT, "dwServiceType             = %08lX\n",
                         g_svcStatus.dwServiceType ));

              DBGPRINTF(( DBG_CONTEXT, "dwCurrentState            = %08lX\n",
                         g_svcStatus.dwCurrentState ));

              DBGPRINTF(( DBG_CONTEXT, "dwControlsAccepted        = %08lX\n",
                         g_svcStatus.dwControlsAccepted ));

              DBGPRINTF(( DBG_CONTEXT, "dwWin32ExitCode           = %08lX\n",
                         g_svcStatus.dwWin32ExitCode ));

              DBGPRINTF(( DBG_CONTEXT, "dwServiceSpecificExitCode = %08lX\n",
                         g_svcStatus.dwServiceSpecificExitCode ));

              DBGPRINTF(( DBG_CONTEXT, "dwCheckPoint              = %08lX\n",
                         g_svcStatus.dwCheckPoint ));

              DBGPRINTF(( DBG_CONTEXT, "dwWaitHint                = %08lX\n",
                         g_svcStatus.dwWaitHint ));
        }

        if( !SetServiceStatus( g_hsvcStatus, &g_svcStatus ) ) {

            err = GetLastError();

        } else {

            err = NO_ERROR;
        }
    }

    return err;
}   // ReportServiceStatus()

DWORD
UpdateServiceStatus(
        IN DWORD dwState,
        IN DWORD dwWin32ExitCode,
        IN DWORD dwServiceSpecificExitCode,
        IN DWORD dwCheckPoint,
        IN DWORD dwWaitHint
        )
/*++
    Description:

        Updates the local copy status of service controller status
         and reports it to the service controller.

    Arguments:

        dwState - New service state.

        dwWin32ExitCode - Service exit code.

        dwCheckPoint - Check point for lengthy state transitions.

        dwWaitHint - Wait hint for lengthy state transitions.

    Returns:

        NO_ERROR on success and returns Win32 error if failure.
        On success the status is reported to service controller.

--*/
{
    g_svcStatus.dwCurrentState              = dwState;
    g_svcStatus.dwWin32ExitCode             = dwWin32ExitCode;
    g_svcStatus.dwServiceSpecificExitCode   = dwServiceSpecificExitCode;
    g_svcStatus.dwCheckPoint                = dwCheckPoint;
    g_svcStatus.dwWaitHint                  = dwWaitHint;

    return ReportServiceStatus();

} // UpdateServiceStatus()

VOID
InterrogateService( VOID )
/*++
    Description:

        This function interrogates with the service status.
        Actually, nothing needs to be done here; the
        status is always updated after a service control.
        We have this function here to provide useful
        debug info.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     15-Nov-1994 Ported to Tcpsvcs.dll
--*/
{
    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "Interrogating service status for %s\n",
                   QueryServiceName())
                 );
    }

    return;

}   // InterrogateService()

VOID
PauseService( VOID )
/*++
    Description:

        This function pauses the service. When the service is paused,
        no new user sessions are to be accepted, but existing connections
        are not effected.

        This function must update the SERVICE_STATUS::dwCurrentState
         field before returning.

    Returns:

        None. If successful the service is paused.

--*/
{
    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "pausing service %s\n",
                   QueryServiceName())
                 );
    }

    g_svcStatus.dwCurrentState = SERVICE_PAUSED;

    return;
}   // PauseService()


VOID
ContinueService( VOID )
/*++

    Description:
        This function restarts ( continues) a paused service. This
        will return the service to the running state.

        This function must update the g_svcStatus.dwCurrentState
         field to running mode before returning.

    Returns:
        None. If successful then the service is running.

--*/
{

    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "continuing service %s\n",
                   QueryServiceName())
                 );
    }
    g_svcStatus.dwCurrentState = SERVICE_RUNNING;

    return;
}   // ContinueService()

VOID
StopService( VOID )
/*++
    Description:

        This function performs the shutdown on a service.
        This is called during system shutdown.

        This function is time constrained. The service controller gives a
        maximum of 20 seconds for shutdown for all active services.
         Only timely operations should be performed in this function.

    Returns:

        None. If successful, the service is shutdown.
--*/
{
    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "shutting down service %s\n",
                   QueryServiceName())
                 );
    }


    SetEvent( g_hShutdownEvent );

    return;
} // StopService()


BOOL
SaveMetabase( VOID )
/*++
    Description:

        This function tells the metabase to save itself.

    Returns:

        If TRUE, the metabase has been saved.
--*/
{
    HRESULT hRes;
    METADATA_HANDLE mdhRoot;
    IMDCOM * pMDCom = NULL;

    hRes = CoCreateInstance(CLSID_MDCOM,
                                   NULL,
                                   CLSCTX_SERVER,
                                   IID_IMDCOM,
                                   (void**) &pMDCom);

    if (SUCCEEDED(hRes))
    {
        hRes = pMDCom->ComMDInitialize();

        if (SUCCEEDED(hRes))
        {

            //
            // Try to lock the tree
            //

            hRes = pMDCom->ComMDOpenMetaObjectW(METADATA_MASTER_ROOT_HANDLE,
                                                    NULL,
                                                    METADATA_PERMISSION_READ,
                                                    MB_SAVE_TIMEOUT,
                                                    &mdhRoot);

            //
            // If failed, then someone has a write handle open,
            // and there might be an inconsistent data state, so don't save.
            //

            if (SUCCEEDED(hRes))
            {

                //
                // Call metadata com api to save
                //

                hRes = pMDCom->ComMDSaveData(mdhRoot);


                pMDCom->ComMDCloseMetaObject(mdhRoot);

            }

            pMDCom->ComMDTerminate(TRUE);
        }

        pMDCom->Release();
    }


    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "IISAdmin Service, SaveMetabase() failed, hr=%lu\n", hRes ));
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;

} // SaveMetabase()


VOID
ServiceControlHandler (
                    IN DWORD dwOpCode
                    )
/*++
    Description:

        This function received control requests from the service controller.
        It runs in the context of service controller's dispatcher thread and
        performs the requested function.
        ( Note: Avoid time consuming operations in this function.)

    Arguments:

        dwOpCode
            indicates the requested operation. This should be
            one of the SERVICE_CONTROL_* manifests.


    Returns:
        None. If successful, then the state of the service might be changed.

    Note:
        if an operation ( especially SERVICE_CONTROL_STOP) is very lengthy,
         then this routine should report a STOP_PENDING status and create
         a worker thread to do the dirty work. The worker thread would then
         perform the necessary work and for reporting timely wait hints and
         final SERVICE_STOPPED status.

    History:
        KeithMo     07-March-1993  Created
        MuraliK     15-Nov-1994    Generalized it for all services.
--*/
{
    //
    //  Interpret the opcode.
    //

    switch( dwOpCode ) {

    case SERVICE_CONTROL_INTERROGATE :
        InterrogateService();
        break;

    case SERVICE_CONTROL_STOP :
        DBGPRINTF(( DBG_CONTEXT, "IISAdmin Service received stop notice\n"));
        StopService();
        break;

    case SERVICE_CONTROL_PAUSE :
        PauseService();
        break;

    case SERVICE_CONTROL_CONTINUE :
        ContinueService();
        break;

    case SERVICE_CONTROL_SHUTDOWN :
#if 0
        //
        //  On shutdown, service controller doesn't respect ordering so
        //  this call can block here or force unloading of some stuff that
        //  a subsequent service needs.

        StopService();
#else
        //
        // Although we aren't cleanly shutting down everything, we want
        // to at least make sure the metabase has been saved.
        //

        DBGPRINTF(( DBG_CONTEXT, "IISAdmin Service saving metabase\n"));

        DBG_REQUIRE( SaveMetabase() );

        DBGPRINTF(( DBG_CONTEXT, "IISAdmin Service IGNORING shutdown notice\n"));
#endif
        break;

    default :
        DBGPRINTF(( DBG_CONTEXT, "Unrecognized Service Opcode %lu\n",
                     dwOpCode ));
        break;
    }

    //
    //  Report the current service status back to the Service
    //  Controller.  The workers called to implement the OpCodes
    //  should set the g_svcStatus.dwCurrentState field if
    //  the service status changed.
    //

    if ((dwOpCode != SERVICE_CONTROL_STOP) && (dwOpCode != SERVICE_CONTROL_SHUTDOWN)) {
        // there is a race condition between this thread and the main thread, which
        // was kicked off in StopService.
        // The dll can get unloaded while this call is in progress.
        // Main thread reports status anyways, so don't report it.
        ReportServiceStatus();
    }

}   // ServiceControlHandler()
/*
//
// Must start a thread with CoInitialize(NULL)
// and keep it for the life of the service
// for OLE. The web server also does this,
// so this is  only an issue if the iisadmin
// runs without the web server.
//


DWORD
OleHackThread(
    PVOID pv
    )
{
    DWORD dwWaitReturn;
    HRESULT hRes;
    PTHREAD_PARAMS ptpParams = (PTHREAD_PARAMS)pv;

    hRes = CoInitialize(NULL);
    ptpParams->bInitSuccess = SUCCEEDED(hRes);

    if (!(ptpParams->bInitSuccess)) {
        SetLastError(hRes);
        IF_DEBUG( DLL_SERVICE_INFO) {

            DBGPRINTF(( DBG_CONTEXT, "CoInitialize Failed\n"));
        }
    }

    SetEvent(ptpParams->hInitEvent);

    if (ptpParams->bInitSuccess) {
        dwWaitReturn = WaitForSingleObject( g_hShutdownEvent,
                                            INFINITE );
        CoUninitialize();
    }

    return 0;
}

*/

//
// While we are in the process of shutting down the timer
// code will call us so we can let the SCM no that we are still
// alive.
//
VOID CALLBACK ShutdownCallback(
    PVOID pIgnored,
    BOOLEAN IgnoredReason
    )
{

    UpdateServiceStatus( SERVICE_STOP_PENDING,
                         0,
                         0,
                         g_svcStatus.dwCheckPoint + 1,
                         SERVICE_STOP_WAIT_HINT );

};


//
// We must init com in a separate thread, to avoid conflicts
// between CoInitializeEx(NULL, MULTI_THREADED)
// and CoInitialize(NULL)
// In the normal case of a service, this is not an issue,
// as IISADMIN is in a different thread from the other services
//

DWORD
ComHackThread(
    PVOID pv
    )
{
    DWORD dwWaitReturn;
    BOOL bInitSucceeded;
    PTHREAD_PARAMS ptpParams = (PTHREAD_PARAMS)pv;

    //
    // Bug 80253: Set thread desktop here.  The next time CoCreateInstance is
    //        called, COM will cache the desktop.  Note that InitComAdminData
    //        (below) calls CoCreateInstance, so we are groovy.
    //
    if ( !SUCCEEDED( SetDesktop(FALSE) ) )
    {
        return FALSE;
    }

    bInitSucceeded = ptpParams->bInitSuccess = InitComAdmindata( g_fAsExe );

    if (bInitSucceeded) {

        //
        // Don't bother starting extensions if init failed
        //

        StartServiceExtensions();

        RegisterServiceExtensionCLSIDs();

    }

    //
    // Always set init event to free up calling thread
    //

    SetEvent(ptpParams->hInitEvent);


    if (bInitSucceeded) {

        //
        // If succeeded, wait until termination event,
        // else die immeditately
        //

        dwWaitReturn = WaitForSingleObject( g_hShutdownEvent,
                                            INFINITE );
        StopServiceExtensions();
    }


    //
    // Terminate can always be called.
    // It will detect if it's not needed.
    //

    TerminateComAdmindata();

    return 0;
}

BOOL
StartThread(
    IN LPTHREAD_START_ROUTINE pStartAddress,
    OUT PHANDLE phThread
    )
{
    BOOL bReturn = FALSE;
    HANDLE hThread = NULL;
    DWORD dwThreadID;
    DWORD dwWaitReturn;
    THREAD_PARAMS tpParams;

    tpParams.bInitSuccess   = FALSE;
    tpParams.hInitEvent     = IIS_CREATE_EVENT(
                                "THREAD_PARAMS::hInitEvent",
                                &tpParams,
                                TRUE,             // fManualReset
                                FALSE             // fInitialState
                                );

    if( tpParams.hInitEvent != NULL ) {
        hThread = CreateThread(NULL,
                           0,
                           pStartAddress,
                           (PVOID)&tpParams,
                           0,
                           &dwThreadID);

        if (hThread != NULL) {

            //
            //  Wait for the init event.
            //

            dwWaitReturn = WaitForSingleObject( tpParams.hInitEvent,
                                       10000 );
            bReturn = tpParams.bInitSuccess;
        }
        CloseHandle(tpParams.hInitEvent);
    }

    *phThread = hThread;
    return(bReturn);
}

VOID
ServiceEntry(
    DWORD                   cArgs,
    LPWSTR                  pArgs[],
    PTCPSVCS_GLOBAL_DATA    pGlobalData     
    )
/*++

    Routine:
        This is the "real" entrypoint for the service.  When
                the Service Controller dispatcher is requested to
                start a service, it creates a thread that will begin
                executing this routine.

    Arguments:
        cArgs - Number of command line arguments to this service.

        pArgs - Pointers to the command line arguments.

    Returns:
        None.  Does not return until service is stopped.

--*/
{
    DWORD   err = NO_ERROR;
    HRESULT hr = S_OK;
    HANDLE  hAsExe;
    HANDLE  hShutdownCallbackTimer = NULL;
    HANDLE  hMDWriterEvent        = NULL;
    CIISAdminMB  Metabase;
    RPC_STATUS   rpcStatus;

    //
    // Figure out if we are running with or without the SCM.
    //
    if ( !(hAsExe = CreateSemaphore( NULL, 1, 1, IIS_AS_EXE_OBJECT_NAME )))
    {
        g_fIgnoreSC = (GetLastError() == ERROR_INVALID_HANDLE);
    }
    else
    {
        CloseHandle( hAsExe );
    }

    //
    // If we are running as a service, tell the SCM what we are doing.
    //

    // 
    // First initalize the global status structure.  This shouldn't be used
    // if we are not running as a service, but since this is legacy code I 
    // will continue to initialize this here.
    //
    g_svcStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    g_svcStatus.dwCurrentState            = SERVICE_STOPPED;
    g_svcStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP
                                              | SERVICE_ACCEPT_PAUSE_CONTINUE
                                              | SERVICE_ACCEPT_SHUTDOWN;
    g_svcStatus.dwWin32ExitCode           = NO_ERROR;
    g_svcStatus.dwServiceSpecificExitCode = NO_ERROR;
    g_svcStatus.dwCheckPoint              = 0;
    g_svcStatus.dwWaitHint                = 0;


    //
    // If we are running as a service then we need to register
    // with SCM.
    //
    if (!g_fIgnoreSC) {
        g_hsvcStatus = RegisterServiceCtrlHandler(
                        QueryServiceName(),
                        ServiceControlHandler
                        );
        //
        //  Register the Control Handler routine.
        //

        if( g_hsvcStatus == NULL_SERVICE_STATUS_HANDLE ) {
            hr = HRESULT_FROM_WIN32(GetLastError());

            goto Cleanup;
        }
    }

    //
    //  Update the service status.  (This will not update
    //  the service if we are not running as a service, but
    //  it will adjust the global service status
    //
    
    err = UpdateServiceStatus( SERVICE_START_PENDING,
                               NO_ERROR,
                               S_OK,
                               1,
                               GetStartupWaitHint() );

    if( err != NO_ERROR ) {

        hr = HRESULT_FROM_WIN32(err);
        goto Cleanup;
    }

    //
    //  Do the OLE security hack to setup the NT desktop
    //

    if ( !SUCCEEDED( err = InitDesktopWinsta(FALSE) ) )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto Cleanup;
    }

    InitializeIISRTL ();

    //
    // This should happen before any other pieces
    // of code attempt to use the metabase.  This
    // is the sanity check to make sure the metabase
    // is is usable form.
    //
    hr = Metabase.InitializeMetabase();
    if ( FAILED ( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT, 
                    "Failed to initialize the metabase %x\n",
                    hr 
                 ));

        goto Cleanup;
    }        

    //
    //  Create metabase writer event.
    //

    hMDWriterEvent = IIS_CREATE_EVENT( "hMDWriterEvent",
                                       &hMDWriterEvent,
                                       TRUE,           // fManualReset
                                       FALSE           // fInitialState
                                       );

    if( hMDWriterEvent == NULL ) {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Cleanup;
    }

    //
    // Initialize IIS metabase writer.  
    //
    hr = InitializeMDWriter( hMDWriterEvent );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT, 
                    "Failed to initialize IIS metabase writer %x\n",
                    hr ));
        goto Cleanup;
    }

    //
    // Bug 80253: Set thread desktop here.  The next time CoCreateInstance is
    //        called, COM will cache the desktop.  Note that InitComAdminData
    //        (below) calls CoCreateInstance, so we are groovy.
    //
    if ( !SUCCEEDED( err = SetDesktop(FALSE) ) )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto Cleanup;
    }

    if ( !InitComAdmindata(g_fIgnoreSC) )
    {
        //
        // InitComAdmindata does not return error
        // information or SetLastError, but we should
        // still pass back a bad hresult to show that
        // something went wrong.
        //
        hr = E_UNEXPECTED;
        goto Cleanup;
    }


    //
    //  Create shutdown event.
    //

    g_hShutdownEvent = IIS_CREATE_EVENT(
                           "g_hShutdownEvent",
                           &g_hShutdownEvent,
                           TRUE,                        // fManualReset
                           FALSE                        // fInitialState
                           );

    if( g_hShutdownEvent == NULL ) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    StartServiceExtensions();

    RegisterServiceExtensionCLSIDs();

    //
    // Start service RPC listening
    //
    if( pGlobalData != NULL )
    {
        rpcStatus = pGlobalData->StartRpcServerListen();
        if( rpcStatus != RPC_S_OK )
        {
            hr = HRESULT_FROM_WIN32( rpcStatus );
            goto Cleanup;
        }
    }

    //
    //  Update the service status.
    //  it is officially running now.
    //

    err = UpdateServiceStatus( SERVICE_RUNNING,
                               NO_ERROR,
                               S_OK,
                               0,
                               0 );

    if( err != NO_ERROR ) {
        hr = HRESULT_FROM_WIN32(err);
        goto Cleanup;
    }

    //
    //  Wait for the shutdown event.
    //

    err = WaitForSingleObject( g_hShutdownEvent,
                               INFINITE );

    if ( err != WAIT_OBJECT_0) {

        //
        // Error. Unable to wait for single object.
        //
    }

    //
    //  Stop time.  Tell the Service Controller that we're stopping,
    //  then terminate the various service components.
    //

    err = UpdateServiceStatus( SERVICE_STOP_PENDING,
                         NO_ERROR,
                         S_OK,
                         1,
                         SERVICE_STOP_WAIT_HINT );

    if( err != NO_ERROR) {

        hr = HRESULT_FROM_WIN32(err);
        //
        //  The event has already been logged.
        //
    }

    //
    //  Now setup a timer callback function that will tell
    //  the service we are still stopping.  Note, the COM
    //  thread will all ready be stopping too, but it won't
    //  setup the callback function.  Since both this routine
    //  and the com thread routine must finish before the 
    //  timer is cancelled, it is fine that we just create it 
    //  here.
    //

    DBG_ASSERT ( hShutdownCallbackTimer == NULL );

    if ( !CreateTimerQueueTimer(&hShutdownCallbackTimer,
                               NULL,       // handle to timer queue, use default queue
                               &ShutdownCallback,
                               NULL,
                               SERVICE_UPDATE_STATUS,
                               SERVICE_UPDATE_STATUS,
                               WT_EXECUTEINIOTHREAD) )
    {
        //
        // Spew out that there was an error, but don't propogate 
        // the error, we should still try and shutdown.
        //

        DBGPRINTF(( DBG_CONTEXT, 
                    "Failed to create the timer queue for shutdown %x\n",
                    HRESULT_FROM_WIN32(GetLastError())
                 ));
    };
    

Cleanup:

    //
    // Stop service RPC listening
    //
    if( pGlobalData != NULL )
    {
        pGlobalData->StopRpcServerListen();
    }

    StopServiceExtensions();

    TerminateComAdmindata();

    // 
    // Terminate IIS metabase wirter 
    //
    if( hMDWriterEvent != NULL )
    {
        TerminateMDWriter( hMDWriterEvent );
    
        CloseHandle( hMDWriterEvent );
        hMDWriterEvent = NULL;
    }

    // 
    // This will only terminate the metabase if
    // it was initialized in the first place.
    //
    Metabase.TerminateMetabase();

    TerminateIISRTL();

    //
    // Now tell the SCM that we have shutdown the service
    // and mean it!!
    //
    if ( g_hsvcStatus != NULL_SERVICE_STATUS_HANDLE )
    {
        DWORD ExitErr = NO_ERROR;

        //
        // Setup the error codes as they will be reported back
        // to the SCM.
        //
        if ( FAILED ( hr ) )
        {

            if ( HRESULT_FACILITY( hr ) == FACILITY_WIN32 )
            {
                ExitErr = HRESULT_CODE ( hr );
            }
            else
            {
                ExitErr = ERROR_SERVICE_SPECIFIC_ERROR;
            }
        }

        
        //
        // If the shutdown timer is still in play we need to 
        // shut it down before we start the service.  Note that
        // we should never have both timers running at the same
        // time.
        //
        if ( hShutdownCallbackTimer )
        {

            //
            // Ping the server for more time, so we know we will
            // have enough time to shutdown the callback timer before
            // we end the service.
            //

            UpdateServiceStatus( SERVICE_STOP_PENDING,
                                 NO_ERROR,
                                 S_OK,
                                 g_svcStatus.dwCheckPoint + 1,
                                 SERVICE_STOP_WAIT_HINT );

            //
            // Stop the callback function.
            //
            if ( !DeleteTimerQueueTimer(NULL, 
                                       hShutdownCallbackTimer,
                                       INVALID_HANDLE_VALUE ) )
            {
                //
                // Spew out that there was an error, but don't propogate 
                // the error, we should still try and shutdown.
                //

                DBGPRINTF(( DBG_CONTEXT, 
                            "Failed to delete the timer queue for shutdown %x\n",
                            HRESULT_FROM_WIN32(GetLastError())
                         ));

            };

            hShutdownCallbackTimer = NULL;

        };

        //
        // Now let SCM know that we are done.
        //

        UpdateServiceStatus( SERVICE_STOPPED,
                             ExitErr,
                             hr,
                             0,
                             0 );
    };


} // ServiceEntry()


BOOL
ExeEntry(
    BOOL    fAsExe,                 // TRUE  for exe
    BOOL    fIgnoreWinstaError,     // FALSE for exe
    BOOL    fInitWam                // FALSE for exe
    )
{
    BOOL   bReturn = TRUE;
    DWORD  err;

    g_fAsExe = fAsExe;

    //
    //  Do the OLE security hack to setup the NT desktop
    //

    if ( !SUCCEEDED( err = InitDesktopWinsta(fIgnoreWinstaError) ))
    {
        if ( !fIgnoreWinstaError )
        {
            return FALSE;
        }
    }

    //
    //  Create shutdown event.
    //

    g_hShutdownEvent = IIS_CREATE_EVENT(
                           "g_hShutdownEvent",
                           &g_hShutdownEvent,
                           TRUE,                        // fManualReset
                           FALSE                        // fInitialState
                           );

    if( g_hShutdownEvent == NULL ) {
        bReturn = FALSE;
    }
    else {

        bReturn = StartThread(ComHackThread, &g_hComHackThread);

        if ( bReturn && fInitWam )
        {
        }
/*
        if (bReturn) {
            StartThread(OleHackThread);
        }
*/
    }
    return bReturn;
}

VOID
ExeExit()
{
    if (g_hShutdownEvent != NULL) {

        SetEvent(g_hShutdownEvent);

        if ( g_hComHackThread != NULL ) {

            DWORD err;

            err = WaitForSingleObject(g_hComHackThread,10000);
            if ( err != WAIT_OBJECT_0 ) {
                IIS_PRINTF((buff,
                    "Wait for ComHackThread death returns %d[err %d]\n",
                    err, GetLastError()));
            }
            CloseHandle(g_hComHackThread);
            g_hComHackThread = NULL;
        }

        CloseHandle(g_hShutdownEvent);
        g_hShutdownEvent = NULL;
    }
}

/***************************************************************************++

Routine Description:

    Checks the registry to see if there is an override set for the
    iisadmin startup time limit.  If there is we use that value, if there
    is not we will use the default 3 minutes.

Arguments:

    None.

Return Value:

    DWORD - time to tell scm to wait for our startup.

--***************************************************************************/
DWORD
GetStartupWaitHint(
    )
{
    HKEY    hKey;
    DWORD   dwType;
    DWORD   cbData;
    DWORD   dwWaitHint;
    DWORD   dwActualWaitHint = SERVICE_START_WAIT_HINT;

    // 
    // Read the registry key to see if we are trying to
    // override the startup wait hint limit.  If there are
    // any problems just return the default.
    //
    if ( !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        IISADMIN_SVC_KEY,
                        0,
                        KEY_QUERY_VALUE,
                        &hKey ) ) 
    {
        cbData = sizeof( DWORD );

        if( !RegQueryValueEx( hKey,
                              IISADMIN_STARTUP_WAITHINT_VALUE,
                              NULL,
                              &dwType,
                              ( LPBYTE )&dwWaitHint,
                              &cbData ) )
        {
            if( dwType == REG_DWORD && dwWaitHint != 0 )
            {
                dwActualWaitHint = dwWaitHint;
            }
        }

        RegCloseKey( hKey );
    }    
    
    return dwActualWaitHint;
}

/************************ End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mdadmin\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
      THIS IS A TEMPLATE. Please clone it for your DLL!
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>



//
//  Define the debugging constants
//

#define DEBUG_DLL_SERVICE_INFO     0x00200000L

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mdadmin\iisadminmb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/
/*
    metabase.cxx

    This module contains a class that supports openning the metabase
	and keeping it open for the life of the IISAdmin Service.


    FILE HISTORY:
        emilyk - created
*/
#include <dbgutil.h>
#include <imd.h>
#include "iisadminmb.hxx"

/***************************************************************************++

Routine Description:

    Opens the metabase and initializes it.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/

HRESULT
CIISAdminMB::InitializeMetabase(
    )
{
    HRESULT hr = S_OK;

    hr = CoCreateInstance( CLSID_MDCOM, NULL, CLSCTX_SERVER, IID_IMDCOM, (void**) &m_pMdObject);
    if( SUCCEEDED( hr ) )
    {
        hr = m_pMdObject->ComMDInitialize();
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initialize MDCOM object.  hr = %x\n",
                        hr ));

            m_pMdObject->Release();
            m_pMdObject = NULL;

            goto exit;
        }
    }

exit:

    return hr;
}

/***************************************************************************++

Routine Description:

    Closes the metabase.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID 
CIISAdminMB::TerminateMetabase(
    )
{
    if( m_pMdObject )
    {
        m_pMdObject->ComMDTerminate(FALSE);

        m_pMdObject->Release();
        m_pMdObject = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mdadmin\ntsec.cxx ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1996-1997 Microsoft Corporation. All Rights Reserved.

Component: Server object

File: NTSec.cxx

Owner: AndrewS

This file contains code related to NT security on WinSta's and Desktops
===================================================================*/

#include <dbgutil.h>
#include <apiutil.h>
#include <loadmd.hxx>
#include <loadadm.hxx>
#include <ole2.h>
#include <inetsvcs.h>
#include "ntsec.h"

// Globals
HWINSTA ghWinSta = NULL;
HWINSTA ghWinStaPrev = NULL;
HDESK ghDesktop = NULL;
HDESK ghdeskPrev = NULL;

HRESULT InitOleSecurity(BOOL);

/*===================================================================
InitDesktopWinsta

Create a desktop and a winstation for IIS to use

Parameters:

Returns:
    HRESULT     NOERROR on success

Side effects
    Sets global variables
===================================================================*/
HRESULT InitDesktopWinsta(
    BOOL    fAllowError
    )
    {
    HRESULT hr = NOERROR;
    DWORD err;
    HWINSTA hWinSta = NULL;
    HDESK hDesktop = NULL;
    OSVERSIONINFO osInfo;
    BOOL          fWinNT = FALSE;

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        fWinNT = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    }

    // Only applies to NT
    if ( !fWinNT )
        return(NOERROR);

    // Save our old window station so we can restore it later
    ghWinStaPrev = GetProcessWindowStation();
    if (ghWinStaPrev == NULL)
        goto LErr;
        
    // Create a winsta for IIS to use
    if ((hWinSta = CreateWindowStation(SZ_IIS_WINSTA, NULL, WINSTA_ALL, NULL)) == NULL)
    {
        if ( !fAllowError )
        {
            goto LErr;
        }
    }
    else
    {
        // Set this as IIS's window station
        if (!SetProcessWindowStation(hWinSta))
            goto LErr;
    }

    // Save the old desktop because we might need it later for an obscure error condition
    if ((ghdeskPrev = GetThreadDesktop(GetCurrentThreadId())) == NULL)
    {
        goto LErr;
    }

    // Create a desktop for IIS to use
    if ((hDesktop = CreateDesktop(SZ_IIS_DESKTOP, NULL, NULL, 0, DESKTOP_ALL, NULL)) == NULL)
    {
        if ( !fAllowError )
        {
            goto LErr;
        }
    }

    // store these handles in the globals
    ghWinSta = hWinSta;
    ghDesktop = hDesktop;

    // Now initialize Ole security
    hr = InitOleSecurity(fAllowError);

    return(hr);
    
LErr:

    if (ghWinStaPrev != NULL)
        SetProcessWindowStation(ghWinStaPrev);
    if (hWinSta != NULL)
        CloseWindowStation(hWinSta);
    if (hDesktop != NULL)
        CloseDesktop(hDesktop);

    err = GetLastError();
    hr = HRESULT_FROM_WIN32(err);
    return(hr);
    }
    
/*===================================================================
UnInitDesktopWinsta

Destroy the IIS desktop and winstation

Parameters:
    None
    
Returns:
    Nothing

Side effects
    Sets global variables
===================================================================*/
VOID UnInitDesktopWinsta()
    {
    BOOL fClosed;

    if (ghWinSta != NULL)
        {
        // Set winsta back to the old winsta so we can close the new one
        fClosed = SetProcessWindowStation(ghWinStaPrev);
        DBG_ASSERT(fClosed);
    
        fClosed = CloseWindowStation(ghWinSta);
        DBG_ASSERT(fClosed);
        ghWinSta = NULL;
        }
        
    if (ghDesktop != NULL)
        {
        BOOL fRetried = FALSE;
LRetry:
        DBG_ASSERT(ghDesktop != NULL);
        fClosed = CloseDesktop(ghDesktop);
        // If this fails, it probably means that we are in the obscure case where
        // IIS's CacheExtensions registry setting is 0.  In this case, we are shutting
        // down in a worker thread.  This worker thread is using the desktop, so
        // it cant be closed.  In this case, attempt to set the desktop back to the
        // original IIS desktop, and then retry closing the desktop.  Only retry once.
        if (!fClosed && !fRetried)
            {
            fRetried = TRUE;
            if (!SetThreadDesktop(ghdeskPrev))
                DBG_ASSERT(FALSE);
            goto LRetry;
            }
        DBG_ASSERT(fClosed);
        ghDesktop = NULL;
        }
        
    return;
    }

/*===================================================================
SetDesktop

Set the desktop for the calling thread

Parameters:
    None
    
Returns:
    NOERROR on success

Side effects:
    Sets desktop
===================================================================*/
HRESULT SetDesktop( 
    BOOL fAllowError 
    )
    {
    DWORD err;

    if (!SetThreadDesktop(ghDesktop))
        goto LErr;

    return(NOERROR);
    
LErr:
    if ( !fAllowError )
    {
        DBG_ASSERT(FALSE);
    }

    err = GetLastError();
    return(HRESULT_FROM_WIN32(err));
    }


/*===================================================================
InitOleSecurity

Setup for and call CoInitializeSecurity. This will avoid problems with
DCOM security on sites that have no default security.

Parameters:
    None
    
Returns:
    Retail -- Always returns NOERROR,  failures are ignored.
            We dont want to have a failure of setting up security
            stop IIS from running at all.

    Debug -- DBG_ASSERTs on error and returns error code

Side effects:
    Sets desktop
===================================================================*/
HRESULT InitOleSecurity(
    BOOL    fAllowError
    )
    {
    HRESULT hr = NOERROR;
    BOOL    fDoCoUninit = TRUE;
    DWORD err;
    SECURITY_DESCRIPTOR SecurityDesc;
    SID NullSid = { SID_REVISION, 1, SECURITY_NULL_SID_AUTHORITY, SECURITY_NULL_RID };
    HDESK hdeskSave = NULL;
    
    /*
     * We need to set up a security descriptor with an empty ACL so that
     * we can CoInitializeSecurity but not give everyone access to the server.
     */
    if (!InitializeSecurityDescriptor(&SecurityDesc, SECURITY_DESCRIPTOR_REVISION))
        goto LErr;

    ACL Acl;
    // Initialize a new ACL.
    if (!InitializeAcl(&Acl, sizeof(ACL), ACL_REVISION2))
        goto LErr;

    // Add new ACL to the security descriptor.
    if (!SetSecurityDescriptorDacl( &SecurityDesc, TRUE, &Acl, FALSE ))
        goto LErr;

    if (!SetSecurityDescriptorOwner(&SecurityDesc, &NullSid, FALSE))
        goto LErr;

    if (!SetSecurityDescriptorGroup(&SecurityDesc, &NullSid, FALSE))
        goto LErr;

    /*
     * This work must be done on the desktop that our threads are going to use.
     * However, we are currently running on IIS's thread, and we dont want to
     * whack their desktop.  So, set to our desktop, do the CoInitializeSecurity,
     * then set the old desktop back again.  Ole will cache the desktop that
     * was set when this CoInitSec was done.
     */
    if (FAILED(hr = SetDesktop(fAllowError)))
        {
        goto LErr;
        }
    
    hr = CoInitialize(NULL);
    if( FAILED(hr) )
    {
        fDoCoUninit = FALSE;
    }

    hr = CoInitializeSecurity(
                    NULL,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_DYNAMIC_CLOAKING,
                    NULL );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "CoInitializeSecurity failed running with default "
                   "DCOM security settings, hr=%8x\n",
                   hr
                   ));
    }

    if( fDoCoUninit )
    {
        CoUninitialize();
    }

    // Set the desktop back to what IIS expected it to be
    if (!SetThreadDesktop(ghdeskPrev))
        {
        // Nothing we can do if this fails
        DBG_ASSERT(FALSE);
        }

    //
    // This may fire if CoInitializeSecurity fails. So it is probably 
    // overactive we would have let the CoInitializeSecurity call fail 
    // in the past, before some PREFIX changes.
    //

    DBG_ASSERT(SUCCEEDED(hr));
    
    return(hr);
    
LErr:
    DBG_ASSERT(FALSE);

    if (SUCCEEDED(hr))
        {
        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        }
#ifdef DEBUG
    return(hr);
#else
    return(NOERROR);
#endif
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mdadmin\mdwriter.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mdwriter.cxx

Abstract:

    This file contains implementation for snapshot writer class

Author:

    Ming Lu (MingLu)            30-Apr-2000

--*/

#include <dbgutil.h>
#include "mdwriter.hxx"

#define TIMEOUT_INTERVAL       ( 2 * 60 )
#define DEFAULT_SAVE_TIMEOUT   30000
#define MDWRITER_EVENT_TIMEOUT 30000
#define IISCOMPONENT           L"IISMETABASE"
#define METABASEPATH           L"%windir%\\system32\\inetsrv"
#define METABASENAME1          L"metabase.bin"
#define METABASENAME2          L"MetaBase.XML"
#define METABASENAME3          L"MBSchema.XML"

#define NT_SETUP_KEY           "SYSTEM\\Setup"

static VSS_ID  s_WRITERID =
    {
    0x59b1f0cf, 0x90ef, 0x465f,
    0x96, 0x09, 0x6c, 0xa8, 0xb2, 0x93, 0x83, 0x66
    };

static LPCWSTR  s_WRITERNAME         = L"IIS Metabase Writer";

BOOL            g_fWriterSubscribed  = FALSE;
CIISVssWriter * g_pIISVssWriter      = NULL;

VOID CALLBACK UnlockMBProc(
    LPVOID pIISVssWriter,   
    DWORD  dwTimerLowValue, 
    DWORD  dwTimerHighValue 
);


BOOL 
CIISVssWriter::Initialize(
    VOID
    )
{
    HRESULT hr;

    hr = CVssWriter::Initialize( s_WRITERID,
                                 s_WRITERNAME,
                                 VSS_UT_SYSTEMSERVICE,
                                 VSS_ST_OTHER 
                                 );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in base object Initialize().  hr = %x\n",
                    hr ));

        return FALSE;
    }

    m_hTimer = CreateWaitableTimer( NULL, FALSE, NULL );
    if( !m_hTimer )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating timer object.  hr = %x\n",
                    HRESULT_FROM_WIN32( GetLastError() ) ));

        return FALSE;
    }
        
    hr = CoCreateInstance( CLSID_MDCOM, NULL, CLSCTX_SERVER, IID_IMDCOM, (void**) &m_pMdObject);
    if( SUCCEEDED( hr ) )
    {
        hr = m_pMdObject->ComMDInitialize();
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initialize MDCOM object.  hr = %x\n",
                        hr ));

            m_pMdObject->Release();
            m_pMdObject = NULL;

            return FALSE;
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating MDCOM object.  hr = %x\n",
                    hr ));

        return FALSE;
    }

    return TRUE;
}

bool STDMETHODCALLTYPE 
CIISVssWriter::OnIdentify(
    IN IVssCreateWriterMetadata *pMetadata
    )
{
    HRESULT hr;

    hr = pMetadata->AddComponent( VSS_CT_FILEGROUP,
                                  NULL,
                                  IISCOMPONENT, 
                                  NULL,
                                  0,
                                  0,
                                  FALSE,
                                  FALSE,
                                  FALSE );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error AddComponent().  hr = %x\n",
                    hr ));

        return FALSE;
    }

    hr = pMetadata->AddFilesToFileGroup( NULL,
                                         IISCOMPONENT, 
                                         METABASEPATH,
                                         METABASENAME1,
                                         FALSE,
                                         NULL );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error AddFilesToFileGroup().  hr = %x\n",
                    hr ));

        return FALSE;
    }

    hr = pMetadata->AddFilesToFileGroup( NULL,
                                         IISCOMPONENT, 
                                         METABASEPATH,
                                         METABASENAME2,
                                         FALSE,
                                         NULL );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error AddFilesToFileGroup().  hr = %x\n",
                    hr ));

        return FALSE;
    }

    hr = pMetadata->AddFilesToFileGroup( NULL,
                                         IISCOMPONENT, 
                                         METABASEPATH,
                                         METABASENAME3,
                                         FALSE,
                                         NULL );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error AddFilesToFileGroup().  hr = %x\n",
                    hr ));

        return FALSE;
    }

    hr = pMetadata->SetRestoreMethod( 
               VSS_RME_RESTORE_AT_REBOOT,    // restore method
               NULL,                         // service name
               NULL,                         // user procedure
               VSS_WRE_NEVER,                // when to call writer restore method
               TRUE                          // reboot is required
               );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error setting restore method.  hr = %x\n",
                    hr ));

        return FALSE;
    }

    return TRUE;
}

bool STDMETHODCALLTYPE 
CIISVssWriter::OnPrepareBackup(
    IN IVssWriterComponents *pWriterComponents
    )
{
    return TRUE;
}

bool STDMETHODCALLTYPE 
CIISVssWriter::OnPrepareSnapshot(
    VOID
    )
{
    HRESULT           hr;

    if( IsPathAffected( METABASEPATH ) )
    {
        //
        // First try to lock the tree
        //

        hr = m_pMdObject->ComMDOpenMetaObjectW( METADATA_MASTER_ROOT_HANDLE,
                                                NULL,
                                                METADATA_PERMISSION_READ,
                                                DEFAULT_SAVE_TIMEOUT,
                                                &m_mdhRoot);

        if ( SUCCEEDED( hr ) ) {
            //
            // call metadata com api
            //

            hr = m_pMdObject->ComMDSaveData( m_mdhRoot );

            if( SUCCEEDED( hr ) )
            {
                hr = m_pMdObject->ComMDCloseMetaObject( m_mdhRoot );

                if( SUCCEEDED ( hr ) )
                {
                    return TRUE;
                }
        
                DBGPRINTF(( DBG_CONTEXT,
                            "Error on unlocking the metabase.  hr = %x\n",
                            hr ));

                return FALSE;
            }

            DBGPRINTF(( DBG_CONTEXT,
                        "Error on saving the metabase.  hr = %x\n",
                        hr ));

            m_pMdObject->ComMDCloseMetaObject( m_mdhRoot );

            return FALSE;
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "Error on locking down the metabase.  hr = %x\n",
                    hr ));

        return FALSE;
    }

    return TRUE;
}


bool STDMETHODCALLTYPE 
CIISVssWriter::OnFreeze(
    VOID
    )
{
    HRESULT hr;
    
    if( IsPathAffected( METABASEPATH ) )
    {
        //
        // Lock down the metabase
        //

        hr = m_pMdObject->ComMDOpenMetaObjectW(METADATA_MASTER_ROOT_HANDLE,
                                               NULL,
                                               METADATA_PERMISSION_READ,
                                               DEFAULT_SAVE_TIMEOUT,
                                               &m_mdhRoot);

        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error on locking down the metabase.  hr = %x\n",
                        hr ));
            
            return FALSE;
        }
        else
        {
            if( !ResetTimer( m_hTimer, TIMEOUT_INTERVAL ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Could not reset the internal timer.  hr = %x\n",
                            hr ));
                
                return FALSE;
            }
            
            EnterCriticalSection( &m_csMBLock );
            
            m_fMBLocked = TRUE;

            LeaveCriticalSection( &m_csMBLock );
              
        }
    }

    return TRUE;
}

bool STDMETHODCALLTYPE 
CIISVssWriter::OnThaw(
    VOID
    )
{
    HRESULT hr;
        
    if( IsPathAffected( METABASEPATH ) )
    {

        EnterCriticalSection( &m_csMBLock );

        if( m_fMBLocked )
        {
            hr = m_pMdObject->ComMDCloseMetaObject( m_mdhRoot );

            if( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error on unlocking the metabase.  hr = %x\n",
                            hr ));

                LeaveCriticalSection( &m_csMBLock );

                return FALSE;
            }
            
            m_fMBLocked = FALSE;

            LeaveCriticalSection( &m_csMBLock );

            CancelWaitableTimer( m_hTimer );
        }
        else
        {
            LeaveCriticalSection( &m_csMBLock );
        }
    }

    return TRUE;
}

bool STDMETHODCALLTYPE 
CIISVssWriter::OnBackupComplete(
    IN IVssWriterComponents *pWriterComponents
    )
{
    return TRUE;
}

bool STDMETHODCALLTYPE 
CIISVssWriter::OnAbort(
    VOID
    )
{
    HRESULT hr;
        
    if( IsPathAffected( METABASEPATH ) )
    {

        EnterCriticalSection( &m_csMBLock );

        if( m_fMBLocked )
        {
            hr = m_pMdObject->ComMDCloseMetaObject( m_mdhRoot );

            if( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error on unlocking the metabase.  hr = %x\n",
                            hr ));

                LeaveCriticalSection( &m_csMBLock );

                return FALSE;
            }
            
            m_fMBLocked = FALSE;

            LeaveCriticalSection( &m_csMBLock );

            CancelWaitableTimer( m_hTimer );
        }
        else
        {
            LeaveCriticalSection( &m_csMBLock );
        }
    }

    return true;
}

VOID 
CIISVssWriter::UnlockMetaBase(
     VOID
     )
{
    HRESULT hr;

    EnterCriticalSection( &m_csMBLock );

    if( m_fMBLocked )
    {
        hr = m_pMdObject->ComMDCloseMetaObject( m_mdhRoot );

        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error on unlocking the metabase.  hr = %x\n",
                        hr ));

            LeaveCriticalSection( &m_csMBLock );

            return;
        }
            
        m_fMBLocked = FALSE;
    }

    LeaveCriticalSection( &m_csMBLock );
}
      
BOOL 
CIISVssWriter::ResetTimer(
    HANDLE hTimer, 
    DWORD  dwDuration
    )
{
    LARGE_INTEGER li;
    const int nNanosecondsPersecond = 10000000;
    __int64 qwTimeFromNowInNanoseconds = 
                      (__int64)dwDuration * nNanosecondsPersecond;

    qwTimeFromNowInNanoseconds = -qwTimeFromNowInNanoseconds;

    li.LowPart = (DWORD) (qwTimeFromNowInNanoseconds & 0xFFFFFFFF);
    li.HighPart = (LONG) (qwTimeFromNowInNanoseconds >> 32);

    if( !SetWaitableTimer( hTimer, &li, 0, UnlockMBProc, this, FALSE ) )
    {
        return FALSE;
    }

    return TRUE;
}

VOID CALLBACK 
UnlockMBProc(
    LPVOID pIISVssWriter,   
    DWORD  dwTimerLowValue, 
    DWORD  dwTimerHighValue 
    )
{
    ( ( CIISVssWriter * )pIISVssWriter )->UnlockMetaBase();
}

VOID
InitMDWriterThread(
    HANDLE hMDWriterEvent
    )
{
    HKEY    hKey;
    DWORD   dwType;
    DWORD   cbData;
    DWORD   dwSetupInProgress  = 0;
    DWORD   dwUpgradeInProcess = 0;

    DBG_ASSERT( hMDWriterEvent != NULL );

    // 
    // Read the setup registry key to see if we are in 
    // setup mode. If we are, don't init IIS writer.
    //
    if ( !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        NT_SETUP_KEY,
                        0,
                        KEY_QUERY_VALUE,
                        &hKey ) ) 
    {
        cbData = sizeof( DWORD );

        if( !RegQueryValueEx( hKey,
                              "SystemSetupInProgress",
                              NULL,
                              &dwType,
                              ( LPBYTE )&dwSetupInProgress,
                              &cbData ) )
        {
            if( dwType == REG_DWORD && dwSetupInProgress != 0 )
            {
                //
                // We are in setup mode
                //
                RegCloseKey( hKey );
                goto exit;
            }
        }

        if( !RegQueryValueEx( hKey,
                              "UpgradeInProgress",
                              NULL,
                              &dwType,
                              ( LPBYTE )&dwUpgradeInProcess,
                              &cbData ) )
        {
            if( dwType == REG_DWORD && dwUpgradeInProcess != 0 )
            {
                //
                // We are in upgrade mode
                //
                RegCloseKey( hKey );
                goto exit;
            }
        }

        RegCloseKey( hKey );
    }     

    //
    // OK, we are not in setup mode, initialize our IIS writer
    //

    g_pIISVssWriter = new CIISVssWriter;
    if ( g_pIISVssWriter == NULL )
    {
        //
        // oh well.  guess we wont support snapshots
        //

        DBGPRINTF(( DBG_CONTEXT,
                 "Error on creating the writer object, out of memory\n" 
                 ));

        goto exit;
    }
    else
    {
        //
        // cool, weve got the object now.
        //

        if( !g_pIISVssWriter->Initialize() )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error on initializing the writer object\n" 
                        ));

            delete g_pIISVssWriter;
            g_pIISVssWriter = NULL;

            goto exit;
        }

        if( SUCCEEDED( g_pIISVssWriter->Subscribe() ) )
        {
            g_fWriterSubscribed = TRUE;
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error on subscribing the writer object\n" 
                        ));

            delete g_pIISVssWriter;
            g_pIISVssWriter = NULL;
        }
    }

exit:
    //
    // Let the TerminateMDWriter know we are ready to terminate during 
    // IISADMIN service shutdown
    //
    SetEvent( hMDWriterEvent );
}

HRESULT
InitializeMDWriter(
    HANDLE hMDWriterEvent
    )
{
    HRESULT hr          = S_OK;
    HANDLE  hThread     = NULL;
    DWORD   dwThreadID;

    DBG_ASSERT( hMDWriterEvent != NULL );

    hThread = CreateThread( NULL,
                            0,
                            ( LPTHREAD_START_ROUTINE )InitMDWriterThread,
                            ( PVOID )hMDWriterEvent,
                            0,
                            &dwThreadID);
    if( hThread == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    return hr;
}

VOID 
TerminateMDWriter(
    HANDLE hMDWriterEvent
    )
{
    DBG_ASSERT( hMDWriterEvent != NULL );

    //
    // Only do cleanup if the hMDWriterEvent is signaled
    //
    if( WAIT_OBJECT_0 == WaitForSingleObject( hMDWriterEvent, 
                                              MDWRITER_EVENT_TIMEOUT ) )
    {
        if( g_fWriterSubscribed )
        {
            DBG_ASSERT( g_pIISVssWriter );
        
            g_pIISVssWriter->Unsubscribe();    
        }

        if( g_pIISVssWriter )
        {
            delete g_pIISVssWriter;
            g_pIISVssWriter = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mibs\dummy.c ===
/**
    This is just a dummy C file for the compiler to have
**/

void dummy_main(void)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mdadmin\registry.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    registry.cxx

    This module contains registry classes.


    FILE HISTORY:
    7/7/97      michth      ported from metadata.
*/
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <apiutil.h>
#include <loadmd.hxx>
#include <loadadm.hxx>
#include <ole2.h>
#include <inetsvcs.h>
#include <buffer.hxx>
#include <registry.hxx>

MDRegKey::MDRegKey (
    HKEY hKeyBase,
    LPCTSTR pchSubKey,
    REGSAM regSam,
    LPCTSTR pchServerName
    )
    : m_hKey(NULL),
      m_dwDisposition(0)
{
    HKEY hkBase = NULL ;
    DWORD err = ERROR_SUCCESS;

    if ( pchServerName != NULL)
    {
        //
        // This is a remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)pchServerName, hKeyBase, &hkBase);
        if (err != ERROR_SUCCESS)
        {
            hkBase = NULL ;
            SetLastError(err);
        }
    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == ERROR_SUCCESS)
    {
        if ( pchSubKey )
        {
            err = ::RegOpenKeyEx( hkBase, pchSubKey, 0, regSam, & m_hKey ) ;
        }
        else
        {
            m_hKey = hkBase ;
            hkBase = NULL ;
        }

        if ( hkBase && hkBase != hKeyBase )
        {
            ::RegCloseKey( hkBase ) ;
        }
    }

    if ( err != ERROR_SUCCESS)
    {
        m_hKey = NULL ;
    }
    SetLastError(err);
}

//
//  Constructor creating a new key.
//
MDRegKey::MDRegKey (
    LPCTSTR pchSubKey,
    HKEY hKeyBase,
    DWORD dwOptions,
    REGSAM regSam,
    LPSECURITY_ATTRIBUTES pSecAttr,
    LPCTSTR pchServerName
    )
    : m_hKey(NULL),
      m_dwDisposition(0)
{
    HKEY hkBase = NULL ;
    DWORD err = 0;

    if (pchServerName != NULL)
    {
        //
        // This is a remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)pchServerName, hKeyBase, & hkBase);
        if (err != ERROR_SUCCESS)
        {
            hkBase = NULL;
            SetLastError(err);
        }

    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == ERROR_SUCCESS)
    {
        LPCTSTR szEmpty = TEXT("") ;

        err = ::RegCreateKeyEx( hkBase, pchSubKey, 0, (TCHAR *) szEmpty,
            dwOptions, regSam, pSecAttr, &m_hKey, &m_dwDisposition );
    }
    if (err != ERROR_SUCCESS)
    {
        m_hKey = NULL ;
    }
    SetLastError(err);
}

MDRegKey::~MDRegKey()
{
    if (m_hKey != NULL)
    {
        ::RegCloseKey( m_hKey ) ;
    }
}

DWORD
MDRegKey::QueryValue (
    LPTSTR pchValueName,
    DWORD * pdwType,
    DWORD * pdwSize,
    BUFFER *pbufData
    )
{
    DWORD dwReturn = ERROR_SUCCESS;

    *pdwSize = pbufData->QuerySize();

    dwReturn = ::RegQueryValueEx(*this, (LPTSTR) pchValueName,
        0, pdwType, (PBYTE) pbufData->QueryPtr(), pdwSize);

    if (dwReturn == ERROR_MORE_DATA) {
        if (pbufData->Resize(*pdwSize)) {
            *pdwSize = pbufData->QuerySize();
            dwReturn = ::RegQueryValueEx(*this, (LPTSTR) pchValueName,
                0, pdwType, (PBYTE)pbufData->QueryPtr(), pdwSize);
        }
    }

    return dwReturn;
}

//
//  Overloaded value setting members.
//
DWORD
MDRegKey::SetValue (
    LPCTSTR pchValueName,
    DWORD dwType,
    DWORD dwSize,
    PBYTE pbData
    )
{
    return ::RegSetValueEx( *this, pchValueName, 0, dwType,
        pbData, dwSize );
}


DWORD
MDRegKey::DeleteValue (
    LPCTSTR pchValueName
    )
{
    return ::RegDeleteValue( *this, (LPTSTR) pchValueName);
}

DWORD
MDRegKey::QueryKeyInfo (
    MDREGKEY_KEY_INFO * pRegKeyInfo
    )
{
    DWORD err = 0 ;

    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;

    err = ::RegQueryInfoKey(*this,
        pRegKeyInfo->chBuff,
        &pRegKeyInfo->dwClassNameSize,
        NULL,
        &pRegKeyInfo->dwNumSubKeys,
        &pRegKeyInfo->dwMaxSubKey,
        &pRegKeyInfo->dwMaxClass,
        &pRegKeyInfo->dwMaxValues,
        &pRegKeyInfo->dwMaxValueName,
        &pRegKeyInfo->dwMaxValueData,
        &pRegKeyInfo->dwSecDesc,
        &pRegKeyInfo->ftKey
        );

    return err ;
}

//
// Iteration class
//
MDRegKeyIter::MDRegKeyIter (
    MDRegKey & regKey
    )
    : m_rk_iter( regKey ),
      m_p_buffer( NULL ),
      m_cb_buffer( 0 )
{
    DWORD err = 0 ;

    MDRegKey::MDREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        m_cb_buffer = regKeyInfo.dwMaxSubKey + sizeof (DWORD) ;
        m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        if (m_p_buffer == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }
    SetLastError(err);
}

MDRegKeyIter :: ~ MDRegKeyIter ()
{
    delete [] m_p_buffer ;
}

//
// Get the name (and optional last write time) of the next key.
//

DWORD MDRegKeyIter::Next(
    LPTSTR *ppszName,
    FILETIME *pTime,
    DWORD dwIndex
    )
{
    DWORD err = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cb_buffer ;

    if (dwIndex != 0xffffffff) {
        m_dw_index = dwIndex;
    }

    err = ::RegEnumKeyEx( m_rk_iter, m_dw_index, m_p_buffer, & dwNameSize,
        NULL, NULL, NULL, & ftDummy ) ;

    if (err == ERROR_SUCCESS)
    {
        ++m_dw_index;

        if ( pTime )
        {
            *pTime = ftDummy ;
        }

        *ppszName = m_p_buffer;
    }

    return err;
}

MDRegValueIter::MDRegValueIter (
    MDRegKey &regKey
    )
    : m_rk_iter(regKey),
      m_p_buffer(NULL),
      m_cb_buffer(0)
{
    DWORD err = 0;

    MDRegKey::MDREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if (err == ERROR_SUCCESS)
    {
        m_cb_buffer = regKeyInfo.dwMaxValueName + sizeof (DWORD);
        m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        if (m_p_buffer == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }
    SetLastError(err);
}

MDRegValueIter::~MDRegValueIter()
{
    delete [] m_p_buffer;
}

DWORD
MDRegValueIter::Next (
    LPTSTR * ppszName,
    DWORD * pdwType
    )
{
    DWORD err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;

    err = ::RegEnumValue(m_rk_iter, m_dw_index, m_p_buffer,
        &dwNameLength, NULL, pdwType, NULL, NULL );

    if ( err == ERROR_SUCCESS )
    {
        ++m_dw_index;

        *ppszName = m_p_buffer;
    }

    return err;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mdadmin\ntsec.h ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1996-1997 Microsoft Corporation. All Rights Reserved.

Component: Server object

File: NTSec.h

Owner: AndrewS

This file contains includes related to NT security on WinSta's and Desktops
===================================================================*/

#ifndef __NTSec_h
#define __NTSec_h

// Local Defines
// Note: These names are deliberately obscure so no one will guess them
#define SZ_IIS_WINSTA   "__X78B95_89_IW"
#define SZ_IIS_DESKTOP  "__A8D9S1_42_ID"

#define DESKTOP_ALL (DESKTOP_READOBJECTS     | DESKTOP_CREATEWINDOW     | \
                     DESKTOP_CREATEMENU      | DESKTOP_HOOKCONTROL      | \
                     DESKTOP_JOURNALRECORD   | DESKTOP_JOURNALPLAYBACK  | \
                     DESKTOP_ENUMERATE       | DESKTOP_WRITEOBJECTS     | \
                     DESKTOP_SWITCHDESKTOP   | STANDARD_RIGHTS_REQUIRED)

#define WINSTA_ALL  (WINSTA_ENUMDESKTOPS     | WINSTA_READATTRIBUTES    | \
                     WINSTA_ACCESSCLIPBOARD  | WINSTA_CREATEDESKTOP     | \
                     WINSTA_WRITEATTRIBUTES  | WINSTA_ACCESSGLOBALATOMS | \
                     WINSTA_EXITWINDOWS      | WINSTA_ENUMERATE         | \
                     WINSTA_READSCREEN       | \
                     STANDARD_RIGHTS_REQUIRED)

HRESULT InitDesktopWinsta(BOOL);
VOID UnInitDesktopWinsta();
HRESULT SetDesktop(BOOL);
HRESULT AddUserSecurity(HANDLE hImpersonate);

#endif //__NTSec_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mdadmin\exttest\globals.cxx ===
#define INITGUID
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <ole2.h>
#include <windows.h>
#include <olectl.h>
#include <stdio.h>
#include <iadmext.h>
#include <coimp.hxx>


ULONG g_dwRefCount;
CAdmExtSrvFactory g_aesFactory;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mdadmin\exttest\cofact.cxx ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <ole2.h>
#include <windows.h>
#include <olectl.h>
#include <stdio.h>
#include <iadmext.h>
#include <coimp.hxx>

CAdmExtSrvFactory::CAdmExtSrvFactory()
    :m_admextObject()
{
    m_dwRefCount=0;
    g_dwRefCount = 0;
    //
    // Addref object, so refcount doesn't go to 0 if all clients release.
    //
    m_admextObject.AddRef();
}

CAdmExtSrvFactory::~CAdmExtSrvFactory()
{
    m_admextObject.Release();
}
HRESULT
CAdmExtSrvFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppObject)
{
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }
    if (FAILED(m_admextObject.QueryInterface(riid, ppObject))) {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
            *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CAdmExtSrvFactory::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExtSrvFactory::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // There must only be one copy of this. So keep the first one around regardless.
    //
    //    if (dwRefCount == 0) {
    //        delete this;
    //    }
    return dwRefCount;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject)
{
    if (rclsid != CLSID_ADMEXT) {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if (FAILED(g_aesFactory.QueryInterface(riid, ppObject))) {
        *ppObject = NULL;
        return E_INVALIDARG;
    }
    return NO_ERROR;
}

HRESULT _stdcall DllCanUnloadNow() {
        if (g_dwRefCount) {
                return S_FALSE;
                }
        else {
                return S_OK;
                }
}

STDAPI DllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32;
    DWORD dwDisposition;
    HMODULE hModule;
    DWORD dwReturn = ERROR_SUCCESS;

    dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              TEXT("CLSID\\{51DFE972-F6F2-11d0-B9BD-00A0C922E750}"),
                              NULL,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyCLSID,
                              &dwDisposition);
    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegSetValueEx(hKeyCLSID,
                                 TEXT(""),
                                 NULL,
                                 REG_SZ,
                                 (BYTE*) TEXT("IISAdmin Extension Test"),
                                 sizeof(TEXT("IISAdmin Extension Test")));
        if (dwReturn == ERROR_SUCCESS) {
            dwReturn = RegCreateKeyEx(hKeyCLSID,
                "InprocServer32",
                NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hKeyInproc32, &dwDisposition);

            if (dwReturn == ERROR_SUCCESS) {
                hModule=GetModuleHandle(TEXT("EXTTEST.DLL"));
                if (!hModule) {
                    dwReturn = GetLastError();
                }
                else {
                    TCHAR szName[MAX_PATH+1];
                    if (GetModuleFileName(hModule,
                                          szName,
                                          sizeof(szName)) == NULL) {
                        dwReturn = GetLastError();
                    }
                    else {
                        dwReturn = RegSetValueEx(hKeyInproc32,
                                                 TEXT(""),
                                                 NULL,
                                                 REG_SZ,
                                                 (BYTE*) szName,
                                                 sizeof(TCHAR)*(lstrlen(szName)+1));
                        if (dwReturn == ERROR_SUCCESS) {
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT("ThreadingModel"),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) TEXT("Both"),
                                                     sizeof(TEXT("Both")));
                        }
                    }
                }
                RegCloseKey(hKeyInproc32);
            }
        }
        RegCloseKey(hKeyCLSID);
    }

    if (dwReturn == ERROR_SUCCESS) {

        dwReturn = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                                  IISADMIN_EXTENSIONS_REG_KEYW
                                      L"\\{51DFE972-F6F2-11d0-B9BD-00A0C922E750}",
                                  NULL,
                                  L"",
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyCLSID,
                                  &dwDisposition);

        if (dwReturn == ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
        }

    }

    return HRESULT_FROM_WIN32(dwReturn);
}

STDAPI DllUnregisterServer(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwTemp;

    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                          TEXT("CLSID\\{51DFE972-F6F2-11d0-B9BD-00A0C922E750}\\InprocServer32"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                            TEXT("CLSID\\{51DFE972-F6F2-11d0-B9BD-00A0C922E750}"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwTemp = RegDeleteKey(HKEY_LOCAL_MACHINE,
                          IISADMIN_EXTENSIONS_REG_KEY
                              TEXT("\\{51DFE972-F6F2-11d0-B9BD-00A0C922E750}"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    return HRESULT_FROM_WIN32(dwReturn);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mdadmin\exttest\comobj.cxx ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <ole2.h>
#include <windows.h>
#include <olectl.h>
#include <stdio.h>
#include <iadmext.h>
#include <coimp.hxx>


CAdmExt::CAdmExt()
{
}

CAdmExt::~CAdmExt()
{
}

HRESULT
CAdmExt::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IADMEXT) {
        *ppObject = (IADMEXT *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CAdmExt::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExt::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // This is now a member of class factory.
    // It is not dynamically allocated, so don't delete it.
    //
/*
    if (dwRefCount == 0) {
        delete this;
        return 0;
    }
*/
    return dwRefCount;
}


HRESULT STDMETHODCALLTYPE
CAdmExt::Initialize(void)
{
    return ERROR_SUCCESS;
}


HRESULT STDMETHODCALLTYPE
CAdmExt::EnumDcomCLSIDs(
    /* [size_is][out] */ CLSID *pclsidDcom,
    /* [in] */ DWORD dwEnumIndex)
{
    HRESULT hresReturn = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    if (dwEnumIndex == 0) {
        *pclsidDcom = CLSID_DCOMADMEXT;
        hresReturn = S_OK;
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CAdmExt::Terminate(void)
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\mibs\makefile.inc ===
copyfiles:
!ifdef _NTTREE
	xcopy /verifd .\smi.mib $(_NTTREE)
	xcopy /verifd .\ftp.mib $(_NTTREE)
	xcopy /verifd .\gateway.mib $(_NTTREE)
	xcopy /verifd .\inetsrv.mib $(_NTTREE)
	xcopy /verifd .\http.mib $(_NTTREE)
!endif	

inetsmib.bin: smi.mib ftp.mib gopherd.mib inetsrv.mib http.mib gateway.mib
    mibcc -o.\inetsmib.bin smi.mib ftp.mib gopherd.mib inetsrv.mib http.mib gateway.mib
!ifdef _NTTREE    
    binplace inetsmib.bin
    binplace smi.mib
    binplace ftp.mib
    binplace gateway.mib
    binplace gopherd.mib
    binplace inetsrv.mib
    binplace http.mib
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#define LPWSTR      [string] wchar_t*
#define BOOL        DWORD
#endif

#include <nntptype.h>
#include <nntpapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntp.inc ===
# Global settings for NNTP subprojects

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

!INCLUDE $(IISBASEDIR)\staxinc\build\paths.inc

STAXNNTP=$(STAXBASE)\nntp
STAXNNTPTARGET=$(STAXNNTP)\$(_OBJ_DIR)
STAXNNTPLIBPATH=$(STAXNNTPTARGET)\$(TARGET_DIRECTORY)

# Hack to create the lib directory
!if [mkdir $(STAXNNTPTARGET)\$(TARGET_DIRECTORY)]
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\admin.h ===
// admin.h : Declaration of the CNntpAdmin

// Dependencies:

#include "metafact.h"

/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpAdmin : 
	public CComDualImpl<INntpAdmin, &IID_INntpAdmin, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdmin,&CLSID_CNntpAdmin>
{
public:
	CNntpAdmin();
	virtual ~CNntpAdmin ();

BEGIN_COM_MAP(CNntpAdmin)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpAdmin)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdmin) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdmin, _T("Nntpadm.Admin.1"), _T("Nntpadm.Admin"), IDS_NNTPADMIN_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpAdmin
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Pointers to other INntpAdmin interfaces:
		
	STDMETHODIMP	get_ServerAdmin		( IDispatch ** ppIDispatch );
//	STDMETHODIMP	get_ServiceAdmin	( IDispatch ** ppIDispatch );

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Versioning:

	STDMETHODIMP	get_HighVersion		( long * plHighVersion );
	STDMETHODIMP	get_LowVersion		( long * plLowVersion );
	STDMETHODIMP	get_BuildNum		( long * plBuildNumber );
	STDMETHODIMP	get_ServiceVersion	( long * plServiceVersion );
	
	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	EnumerateInstances	( SAFEARRAY ** ppsaInstances );
	STDMETHODIMP	EnumerateInstancesVariant	( SAFEARRAY ** ppsaInstances );
	STDMETHODIMP	CreateInstance		( 
		BSTR	strNntpFileDirectory,
		BSTR	strHomeDirectory,
        BSTR    strProgId,
        BSTR    strMdbGuid,
		long * plInstanceId 
		);
	STDMETHODIMP	DestroyInstance		( long lInstanceId );
	STDMETHODIMP	ErrorToString		( long lErrorCode, BSTR * pstrError );
	STDMETHODIMP	Tokenize			( BSTR strIn, BSTR * pstrOut );
	STDMETHODIMP	Truncate			( BSTR strIn, long cMaxChars, BSTR * pstrOut );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComBSTR	m_strServer;
	DWORD		m_dwServiceInstance;

	DWORD		m_dwServiceVersion;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	HRESULT			QueryMetabaseInstances	( IMSAdminBase * pMetabase, SAFEARRAY ** ppsaInstances );
	HRESULT			CreateNewInstance		(
		IMSAdminBase *	pMetabase,
		BSTR			strNntpFileDirectory,
		BSTR			strHomeDirectory,
        BSTR            strProgId,
        BSTR            strMdbGuid,
		long * 			plInstanceId
		);
	HRESULT			DeleteInstance			( IMSAdminBase * pMetabase, long lInstanceId );
	HRESULT         CreateVRoot(    
            CMetabaseKey    &mkeyNntp,
            BSTR            strVPath,
            BSTR            strProgId,
            BSTR            strMdbGuid,
            LPWSTR          wszKeyPath
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\admin.cpp ===
// admin.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"
#include "nntpcmn.h"
#include "oleutil.h"
#include "cmultisz.h"

#include "metautil.h"
#include "metakey.h"

#include "admin.h"
#include "version.h"

#define NNTP_DEF_SERVICE_VERSION	( 0 )

#define	DEFAULT_SERVER_BINDINGS		_T(":119:\0")
#define	DEFAULT_SECURE_BINDINGS		_T(":563:\0")

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Admin.1")
#define THIS_FILE_IID				IID_INntpAdmin

//
//	Metabase key strings used by CreateNewInstance:
//

const WCHAR * g_cszFeeds			= _T("Feeds");
const WCHAR * g_cszExpires			= _T("Expires");
const WCHAR * g_cszRoot				= _T("Root");
const WCHAR * g_cszBindingPoints	= _T("BindingPoints");
const WCHAR * g_cszDDropCLSID		= _T("{8b4316f4-af73-11d0-b0ba-00aa00c148be}");
const WCHAR * g_cszBindings			= _T("Bindings");
const WCHAR * g_cszDDrop			= _T("ddrop");
const WCHAR * g_cszDescription		= _T("Description");
const WCHAR * g_cszPriority			= _T("Priority");
const WCHAR * g_cszProgID			= _T("ProgID");
const WCHAR * g_cszDDropDescription	= _T("NNTP Directory Drop");
const WCHAR * g_cszDDropPriority	= _T("4");
const WCHAR * g_cszDDropProgID		= _T("DDropNNTP.Filter");

/////////////////////////////////////////////////////////////////////////////
//

CNntpAdmin::CNntpAdmin () :
	m_dwServiceVersion		( 0 ),
	m_dwServiceInstance		( 0 )
	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );
}

CNntpAdmin::~CNntpAdmin ()
{
	// All CComBSTR's are freed automatically.
	TermAsyncTrace ( );
}

STDMETHODIMP CNntpAdmin::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_INntpAdmin,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
STDMETHODIMP CNntpAdmin::get_ServiceAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpService>	pINntpService;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpService,
		IID_INntpService,
		&pINntpService,
		ppIDispatch
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpService->put_Server ( m_strServer ? m_strServer : _T("") );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminExpiration
}
*/

STDMETHODIMP CNntpAdmin::get_ServerAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpVirtualServer>	pINntpVirtualServer;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpVirtualServer,
		IID_INntpVirtualServer,
		&pINntpVirtualServer,
		ppIDispatch
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpVirtualServer->put_Server ( m_strServer ? m_strServer : _T("") );
	if ( FAILED (hr) ) {
		goto Error;
	}

	hr = pINntpVirtualServer->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpVirtualServer
}

// Which service to configure:

STDMETHODIMP CNntpAdmin::get_Server ( BSTR * pstrServer )
{
	return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CNntpAdmin::put_Server ( BSTR strServer )
{
	return StdPropertyPutServerName ( &m_strServer, strServer );
}

STDMETHODIMP CNntpAdmin::get_ServiceInstance ( long * plServiceInstance )
{
	return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CNntpAdmin::put_ServiceInstance ( long lServiceInstance )
{
	return StdPropertyPut ( &m_dwServiceInstance, lServiceInstance );
}

// Versioning:

STDMETHODIMP CNntpAdmin::get_HighVersion ( long * plHighVersion )
{
	*plHighVersion = HIGH_VERSION;
	return NOERROR;
}

STDMETHODIMP CNntpAdmin::get_LowVersion ( long * plLowVersion )
{
	*plLowVersion = LOW_VERSION;
	return NOERROR;
}

STDMETHODIMP CNntpAdmin::get_BuildNum ( long * plBuildNumber )
{
	*plBuildNumber = CURRENT_BUILD_NUMBER;
	return NOERROR;
}

STDMETHODIMP CNntpAdmin::get_ServiceVersion ( long * plServiceVersion )
{
	*plServiceVersion = m_dwServiceVersion;
	return NOERROR;
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

//$-------------------------------------------------------------------
//
//	CNntpAdmin::EnumerateInstances
//
//	Description:
//
//		Returns a list of the virtual servers on the given machine.
//
//	Parameters:
//
//		ppsaInstances - Returned SAFEARRAY of instance IDs.
//			Must be freed by caller.
//		pErr - Error return code.
//
//	Returns:
//
//		Error code in *pErr.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::EnumerateInstances ( SAFEARRAY ** ppsaInstances)
{
	TraceFunctEnter ( "CNntpAdmin::EnumerateInstances" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;
	SAFEARRAY * 		psaEmpty	= NULL;
	SAFEARRAYBOUND		sabound[1];

	// Check parameters:
	_ASSERT ( ppsaInstances != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaInstances ) );

	if ( ppsaInstances == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		hr = E_POINTER;
		goto Exit;
	}

	// Zero the out parameters:
	*ppsaInstances	= NULL;

	// Set the return array to an empty array:
	sabound[0].lLbound = 0;
	sabound[0].cElements = 0;

	psaEmpty = SafeArrayCreate ( VT_I4, 1, sabound );
	if ( psaEmpty == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	*ppsaInstances = psaEmpty;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Enumerate the instances:
	hr = QueryMetabaseInstances ( pMetabase, ppsaInstances );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	if ( FAILED(hr) ) {
		_VERIFY ( SUCCEEDED (SafeArrayDestroy ( psaEmpty )) );
		if (ppsaInstances)
		    *ppsaInstances	= NULL;
	}

	TRACE_HRESULT ( hr );
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdmin::EnumerateInstancesVariant ( SAFEARRAY ** ppsaInstances)
{
	TraceFunctEnter ( "CNntpAdmin::EnumerateInstancesVariant" );

	HRESULT			hr;
	SAFEARRAY	*	psaInstances	= NULL;

	hr = EnumerateInstances ( &psaInstances );
	BAIL_ON_FAILURE(hr);

	hr = LongArrayToVariantArray ( psaInstances, ppsaInstances );
	BAIL_ON_FAILURE(hr);

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::CreateInstance
//
//	Description:
//
//		Creates a new NNTP virtual server on the given machine.
//
//	Parameters:
//
//		strNntpFileDirectory - Directory where all the hash files go.
//		strHomeDirectory - Path of the home directory vroot.
//		plInstanceId - The new virtual server ID.
//		pErr	- Resulting error code.
//
//	Returns:
//
//		Error condition in *pErr.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::CreateInstance (
	BSTR	strNntpFileDirectory,
	BSTR	strHomeDirectory,
    BSTR    strProgId,
    BSTR    strMdbGuid,
	long *	plInstanceId
	)
{
	TraceFunctEnter ( "CNntpAdmin::CreateInstance" );

	HRESULT					hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Check parameters:
	_ASSERT ( IS_VALID_STRING ( strNntpFileDirectory ) );
	_ASSERT ( IS_VALID_STRING ( strHomeDirectory ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( plInstanceId ) );

	if ( !strNntpFileDirectory || !strHomeDirectory ) {
		FatalTrace ( 0, "Bad String Pointer" );
		hr = E_POINTER;
		goto Exit;
	}

	if ( !plInstanceId ) {
		FatalTrace ( 0, "Bad return pointer" );
		hr = E_POINTER;
		goto Exit;
	}

	// Zero the out parameter:
	*plInstanceId 	= 0;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Create a new instance:
	hr = CreateNewInstance (
		pMetabase,
		strNntpFileDirectory,
		strHomeDirectory,
        strProgId,
        strMdbGuid,
		plInstanceId
		);
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::DestroyInstance
//
//	Description:
//
//		Removes the given virtual server.
//
//	Parameters:
//
//		lInstanceId - The ID of the virtual server to delete.
//		pErr - Resulting error code.
//
//	Returns:
//
//		Error code in *pErr.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::DestroyInstance ( long lInstanceId )
{
	TraceFunctEnter ( "CNntpAdmin::DestroyInstance" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	if ( lInstanceId == 0 ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
		goto Exit;
	}

	if ( lInstanceId == 1 ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_CANT_DELETE_DEFAULT_INSTANCE );
		goto Exit;
	}

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Delete the instance:
	hr = DeleteInstance ( pMetabase, lInstanceId );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::ErrorToString
//
//	Description:
//
//		Translates an NNTP_ERROR_CODE to a readable string.
//
//	Parameters:
//
//		lErrorCode 	- Win32 error code.
//		pstrError	- the readable error string.
//
//	Returns:
//
//		The error string in *pstrError.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::ErrorToString ( long lErrorCode, BSTR * pstrError )
{
	TraceFunctEnter ( "CNntpAdmin::ErrorToString" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pstrError ) );

	HRESULT		hr = NOERROR;
	WCHAR		wszError [ 1024 ];

	if ( pstrError == NULL ) {
		FatalTrace ( (LPARAM) this, "Bad return pointer" );
		hr = E_POINTER;
		goto Exit;
	}

	Win32ErrorToString ( lErrorCode, wszError, 1024 );

	*pstrError = ::SysAllocString( wszError );

	if ( *pstrError == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::Tokenize
//
//	Description:
//
//		Makes the given string safe for HTML & Javascript
//
//	Parameters:
//
//		strIn - the input string
//		strOut - the resulting string with appropriate escape sequences.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::Tokenize ( BSTR strIn, BSTR * pstrOut )
{
	TraceFunctEnter ( "CNntpAdmin::Tokenize" );

	_ASSERT ( IS_VALID_STRING ( strIn ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrOut ) );

	HRESULT		hr		= NOERROR;
	PWCHAR		pSrc	= strIn;
	PWCHAR		pSrcCur	= NULL;
	PWCHAR		pDstCur	= NULL;
	PWCHAR		pDst	= NULL;

	*pstrOut = NULL;

	pDst = new WCHAR [ 3 * lstrlen ( strIn ) + 1 ];
	if ( pDst == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

    for ( pSrcCur = pSrc, pDstCur = pDst; *pSrcCur; pSrcCur++ ) {
        switch ( *pSrcCur ) {
            case L'\\':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'5';
                *(pDstCur++) = L'c';
                break;

            case L' ':
                *(pDstCur++) = L'+';
                break;

            case L':':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'3';
                *(pDstCur++) = L'a';
                break;

            case L'/':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'2';
                *(pDstCur++) = L'f';
                break;

            default:
                *(pDstCur++) = *pSrcCur;
        }
    }
    *pDstCur = L'\0';

	*pstrOut = ::SysAllocString ( pDst );
	if ( *pstrOut == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	delete pDst;

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::Truncate
//
//	Description:
//
//		Cuts off a string to a certain length using '...'
//
//	Parameters:
//
//		strIn 		- The input string.
//		cMaxChars	- The maximum characters allowed in the resulting string.
//		pstrOut		- The resulting (possibly truncated) string.
//
//	Returns:
//
//
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdmin::Truncate ( BSTR strIn, long cMaxChars, BSTR * pstrOut )
{
	TraceFunctEnter ( "CNntpAdmin::Truncate" );

	PWCHAR	pSrc	= strIn;
	PWCHAR	pDst	= NULL;
	DWORD	cDst	= cMaxChars;
	HRESULT	hr		= NOERROR;

	*pstrOut = NULL;

    if ( wcslen( pSrc ) <= cDst ) {
        pDst = pSrc;
    } else {
        pDst = ::SysAllocStringLen( pSrc, cDst + 1 );
        if ( !pDst ) {
        	FatalTrace ( (LPARAM) this, "Out of memory" );
        	hr = E_OUTOFMEMORY;
        	goto Exit;
        }

        wcscpy( pDst + cDst - 3, L"..." );
    }

	*pstrOut = pDst;

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::QueryMetabaseInstances
//
//	Description:
//
//		Retrieves the list of virtual servers from the metabase
//
//	Parameters:
//
//		pMetabase		- the metabase object
//		ppsaInstances	- resulting array of instance ids.
//		pErr			- resulting error code.
//
//	Returns:
//
//		Error code in *pErr.  If *pErr = 0 then an array of IDs in ppsaInstances.
//
//--------------------------------------------------------------------

HRESULT CNntpAdmin::QueryMetabaseInstances ( IMSAdminBase * pMetabase, SAFEARRAY ** ppsaInstances )
{
	TraceFunctEnter ( "CNntpAdmin::QueryMetabaseInstances" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaInstances ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeyNntp ( pMetabase );
	SAFEARRAY *		psaResult		= NULL;
	DWORD			cValidInstances	= 0;
	SAFEARRAYBOUND	rgsaBound[1];
	DWORD			i;
	WCHAR			wszName[ METADATA_MAX_NAME_LEN ];
	long			index[1];
	DWORD			dwInstance;

	hr = mkeyNntp.Open ( NNTP_MD_ROOT_PATH );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open NntpSvc key, %x", hr );
		hr = HRESULT_FROM_WIN32 ( ERROR_SERVICE_DOES_NOT_EXIST );
		goto Exit;
	}

	//	pickup the service version number:
	hr = mkeyNntp.GetDword ( MD_NNTP_SERVICE_VERSION, &m_dwServiceVersion );
	if ( FAILED(hr) ) {
		m_dwServiceVersion	= NNTP_DEF_SERVICE_VERSION;
	}

	hr = mkeyNntp.GetIntegerChildCount ( &cValidInstances );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Allocate the array:
	rgsaBound[0].lLbound	= 0;
	rgsaBound[0].cElements	= cValidInstances;

	psaResult	= SafeArrayCreate ( VT_I4, 1, rgsaBound );

	if ( psaResult == NULL ) {
		FatalTrace ( 0, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	mkeyNntp.BeginChildEnumeration ();

	for ( i = 0; i < cValidInstances; i++ ) {
		hr = mkeyNntp.NextIntegerChild ( &dwInstance, wszName );
		_ASSERT ( SUCCEEDED(hr) );

		index[0]	= i;
		hr			= SafeArrayPutElement ( psaResult, index, &dwInstance );
		_ASSERT ( SUCCEEDED(hr) );
	}

	*ppsaInstances = psaResult;
	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED (hr) ) {
		SafeArrayDestroy ( psaResult );
	}

	TraceFunctLeave ();
	return hr;
}

HRESULT WriteNntpFileLocation (
	CMetabaseKey * 	pmkeyNntp,
	LPCWSTR			wszSubkey,
	LPCWSTR			wszNntpFileDirectory,
	LPCWSTR			wszFilename,
	DWORD			mdValue
	)
{
	HRESULT		hr;
	WCHAR		wszFullPath	[ MAX_PATH ];

//	wsprintf ( wszFullPath, "%s\\%s\\%s", szNntpFileDirectory, szSubkey, szFilename );
	wsprintf ( wszFullPath, _T("%s\\%s"), wszNntpFileDirectory, wszFilename );

	hr = pmkeyNntp->SetString ( wszSubkey, mdValue, wszFullPath );

	return hr;
}

//$-------------------------------------------------------------------
// CNntpAdmin::CreateVRoot
// 
// Description:
//  
//      Create a vroot for the new instance
//
// Parameters:
//
//      CMetabaseKey    &mkeyNntp   - The metabase key object
//      BSTR            strVPath    - The vroot path
//      BSTR            strProgId   - The prog id to identify vroot type
//      LPWSTR          wszKeyPath  - The key path to set values to
//
//  Returns:
//
//      HRESULT
//
//--------------------------------------------------------------------

HRESULT CNntpAdmin::CreateVRoot(    
    CMetabaseKey    &mkeyNntp,
    BSTR            strVPath,
    BSTR            strProgId,
    BSTR            strMdbGuid,
    LPWSTR          wszKeyPath
    )
{
    TraceFunctEnter( "CNntpAdmin::CreateVRoot" );

    HRESULT hr = S_OK;

	hr = mkeyNntp.SetString ( wszKeyPath, MD_KEY_TYPE, L"IIsNntpVirtualDir",  METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER);
	BAIL_ON_FAILURE(hr);

	hr = mkeyNntp.SetString ( wszKeyPath, MD_VR_PATH, strVPath );
	BAIL_ON_FAILURE(hr);

    if ( NULL == strProgId || *strProgId == 0 || _wcsicmp( strProgId, L"NNTP.FSPrepare" ) == 0 ) {
    
        //
        // File system driver case
        //
	    hr = mkeyNntp.SetString ( wszKeyPath, MD_FS_PROPERTY_PATH, strVPath );
	    BAIL_ON_FAILURE(hr);

	    if ( *strVPath == L'\\' && *(strVPath+1) == L'\\' ) {   // UNC
            hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_USE_ACCOUNT, 1 );
            BAIL_ON_FAILURE( hr );
        } else {    // regular file system
            hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_USE_ACCOUNT, 0 );
        }

        hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_DO_EXPIRE, 0 );
        BAIL_ON_FAILURE( hr );

        hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_OWN_MODERATOR, 0 );
        BAIL_ON_FAILURE( hr );
    } else {

        //
        // Exchange store driver
        //
        hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_USE_ACCOUNT, 0 );
        BAIL_ON_FAILURE( hr );

        hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_DO_EXPIRE, 1 );
        BAIL_ON_FAILURE( hr );

        hr = mkeyNntp.SetDword( wszKeyPath, MD_VR_OWN_MODERATOR, 1 );
        BAIL_ON_FAILURE( hr );

        hr = mkeyNntp.SetString( wszKeyPath, MD_EX_MDB_GUID, strMdbGuid );
        BAIL_ON_FAILURE( hr );

    }

	if (NULL == strProgId || *strProgId == 0) {
		hr = mkeyNntp.SetString ( wszKeyPath, MD_VR_DRIVER_PROGID, L"NNTP.FSPrepare" );
	} else {
    	hr = mkeyNntp.SetString ( wszKeyPath, MD_VR_DRIVER_PROGID, strProgId );
    }
    BAIL_ON_FAILURE(hr);

	hr = mkeyNntp.SetDword ( wszKeyPath, MD_ACCESS_PERM, MD_ACCESS_READ | MD_ACCESS_WRITE );
	BAIL_ON_FAILURE(hr);

Exit:

    TraceFunctLeave();
    return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::CreateNewInstance
//
//	Description:
//
//		Creates a new virtual server in the metabase.
//
//	Parameters:
//
//		pMetabase		- The metabase object
//		plInstanceId	- The new instance ID.
//		pErr			- The resulting error code
//
//	Returns:
//
//		Resulting error code in *pErr.  If *pErr = 0, then the new
//		ID in plInstanceId.
//
//--------------------------------------------------------------------

HRESULT CNntpAdmin::CreateNewInstance (
	IMSAdminBase *	pMetabase,
	BSTR			strNntpFileDirectory,
	BSTR			strHomeDirectory,
    BSTR            strProgId,
    BSTR            strMdbGuid,
	long * 			plInstanceId
	)
{
	TraceFunctEnter ( "CNntpAdmin::CreateNewInstance" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );
	_ASSERT ( IS_VALID_IN_PARAM ( strNntpFileDirectory ) );
	_ASSERT ( IS_VALID_IN_PARAM ( strHomeDirectory ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( plInstanceId ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeyNntp ( pMetabase );
	DWORD			dwInstance;
	WCHAR			wszInstance [ METADATA_MAX_NAME_LEN ];
	WCHAR			wszHomeDirKey [ METADATA_MAX_NAME_LEN ];
	WCHAR           wszSpecialDirKey[ METADATA_MAX_NAME_LEN ];
	WCHAR           wszSpecialDirectory[ MAX_PATH * 2 ];
	WCHAR			wszControlDirKey [ METADATA_MAX_NAME_LEN ];
	WCHAR           wszControlDirectory[ MAX_PATH * 2 ];
	WCHAR			wszBuf [ METADATA_MAX_NAME_LEN * 2 ];
    WCHAR           wszFeedTempDir [ MAX_PATH * 2 ];
    CMultiSz		mszBindings;
    DWORD           dwLen;

	// Zero the out parameter:
	*plInstanceId	= NULL;

	mszBindings			= DEFAULT_SERVER_BINDINGS;

	//
	//	Convert strings to ascii:
	//

	hr = mkeyNntp.Open ( NNTP_MD_ROOT_PATH, METADATA_PERMISSION_WRITE );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open NntpSvc key, %x", hr );
		goto Exit;
	}

	hr = mkeyNntp.CreateIntegerChild ( &dwInstance, wszInstance );
	if ( FAILED (hr) ) {
		goto Exit;
	}

    //
    //  Write out the subkeys of the instance key:
    //

	wsprintf ( wszBuf, _T("%s/%s"), wszInstance, g_cszFeeds );
	hr = mkeyNntp.CreateChild ( wszBuf );
    BAIL_ON_FAILURE ( hr );

    wsprintf ( wszFeedTempDir, _T("%s\\%s"), strNntpFileDirectory, _T("_temp.files_") );
    mkeyNntp.SetString ( wszBuf, MD_FEED_PEER_TEMP_DIRECTORY, wszFeedTempDir );
    BAIL_ON_FAILURE ( hr );

	wsprintf ( wszBuf, _T("%s/%s"), wszInstance, g_cszExpires );
	hr = mkeyNntp.CreateChild ( wszBuf );
    BAIL_ON_FAILURE ( hr );

	wsprintf ( wszHomeDirKey, _T("%s/%s"), wszInstance, g_cszRoot );
	hr = mkeyNntp.CreateChild ( wszHomeDirKey );
    BAIL_ON_FAILURE ( hr );

    //
    //  Set MD_KEY_TYPE for each key:
    //

    hr = mkeyNntp.SetString ( wszInstance, MD_KEY_TYPE, _T("IIsNntpServer"), METADATA_NO_ATTRIBUTES );
    BAIL_ON_FAILURE ( hr );

	hr = mkeyNntp.SetString ( wszHomeDirKey, MD_KEY_TYPE, _T("IIsNntpVirtualDir"), METADATA_NO_ATTRIBUTES );
	BAIL_ON_FAILURE(hr);

    //
    //  Write out the file locations:
    //

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("descrip.txt"),	MD_GROUP_HELP_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("group.lst"),	MD_GROUP_LIST_FILE );
    BAIL_ON_FAILURE(hr);

    hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("groupvar.lst"), MD_GROUPVAR_LIST_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("article.hsh"),	MD_ARTICLE_TABLE_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("history.hsh"),	MD_HISTORY_TABLE_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("moderatr.txt"),	MD_MODERATOR_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("xover.hsh"),	MD_XOVER_TABLE_FILE );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("pickup"),	MD_PICKUP_DIRECTORY );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("failedpickup"),	MD_FAILED_PICKUP_DIRECTORY );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("drop"),	MD_DROP_DIRECTORY );
    BAIL_ON_FAILURE(hr);

	hr = WriteNntpFileLocation ( &mkeyNntp, wszInstance, strNntpFileDirectory, _T("prettynm.txt"),	MD_PRETTYNAMES_FILE);
    BAIL_ON_FAILURE(hr);

    //
    //  Set the default vroot:
    //
    dwLen = wcslen( wszHomeDirKey );
    _ASSERT( dwLen > 0 );
    if ( dwLen == 0 ) hr = E_INVALIDARG;
    BAIL_ON_FAILURE(hr);
    hr = CreateVRoot(   mkeyNntp,
                        strHomeDirectory,
                        strProgId,
                        strMdbGuid,
                        wszHomeDirKey );
    BAIL_ON_FAILURE(hr);

    //
    //  Set the special vroots
    //
    if ( dwLen + wcslen(L"_slavegroup") >= METADATA_MAX_NAME_LEN - 2 ) 
        hr = HRESULT_FROM_WIN32( RPC_S_STRING_TOO_LONG );
    BAIL_ON_FAILURE(hr);
    if ( *(wszHomeDirKey + dwLen - 1 ) == L'/' ) *(wszHomeDirKey + dwLen - 1 ) = 0;
    wcscpy(wszControlDirKey, wszHomeDirKey);
    wcscat(wszControlDirKey, L"/control");
    wcscat( wszHomeDirKey, L"/_slavegroup" );

    //
    //  For the special _slavegroup vroot, we need to see if strProgId is "NNTP.ExDriverPrepare"
    //  If so, we need to re-calculate re-calculate wszSpecialDirectory as follow
    //
    if (_wcsicmp(L"NNTP.ExDriverPrepare", strProgId) == 0)
    {
        //  the default Vroot with the new instance is Exchange Vroot
        //  re-calculate wszSpecialDirectory
        wcscpy( wszSpecialDirectory, strNntpFileDirectory );
        dwLen = wcslen( wszSpecialDirectory );
        if ( dwLen > 0 && *(wszSpecialDirectory + dwLen - 1 ) == L'/' ) 
            *(wszSpecialDirectory + dwLen - 1 ) = 0;
        wcscpy(wszControlDirectory, wszSpecialDirectory);
        wcscat( wszControlDirectory, L"\\root\\control" );
        wcscat( wszSpecialDirectory, L"\\root\\_slavegroup" );
    }
    else
    {
        wcscpy( wszSpecialDirectory, strHomeDirectory );
        dwLen = wcslen( wszSpecialDirectory );
        if ( dwLen > 0 && *(wszSpecialDirectory + dwLen - 1 ) == L'/' ) 
            *(wszSpecialDirectory + dwLen - 1 ) = 0;
        wcscpy(wszControlDirectory, wszSpecialDirectory);
        wcscat( wszControlDirectory, L"\\control" );
        wcscat( wszSpecialDirectory, L"\\_slavegroup" );
    }

    hr = CreateVRoot(   mkeyNntp,
                        wszSpecialDirectory,
                        L"NNTP.FSPrepare",
                        NULL,
                        wszHomeDirKey );
    BAIL_ON_FAILURE(hr);

    //
    // Create the control groups on the file system
    //

    hr = CreateVRoot(   mkeyNntp,
                        wszControlDirectory,
                        L"NNTP.FSPrepare",
                        NULL,
                        wszControlDirKey );
    BAIL_ON_FAILURE(hr);

    
	//
	//	Write out the default bindings:
	//

	StdPutMetabaseProp ( &mkeyNntp, MD_SERVER_BINDINGS, &mszBindings, wszInstance );

    //
    //  Initialize the server state:
    //

    mkeyNntp.SetDword ( wszInstance, MD_SERVER_COMMAND, MD_SERVER_COMMAND_STOP );
    mkeyNntp.SetDword ( wszInstance, MD_SERVER_STATE, MD_SERVER_STATE_STOPPED );
    mkeyNntp.SetDword ( wszInstance, MD_SERVER_AUTOSTART, FALSE );
    mkeyNntp.SetDword ( wszInstance, MD_WIN32_ERROR, ERROR_SERVICE_REQUEST_TIMEOUT, METADATA_VOLATILE );

    //
    //  Save all the changes:
    //

	hr = mkeyNntp.Save ( );
    BAIL_ON_FAILURE(hr)

	mkeyNntp.Close ();

	//
	//	Now see if the service picked things up successfully:
	//

	DWORD	dwSleepTotal;
	DWORD	dwWin32Error;
	WCHAR	wszNewInstanceKey [ METADATA_MAX_NAME_LEN * 2 ];

	GetMDInstancePath ( wszNewInstanceKey, dwInstance );

	for ( dwWin32Error = ERROR_SERVICE_REQUEST_TIMEOUT, dwSleepTotal = 0; 
		dwWin32Error == ERROR_SERVICE_REQUEST_TIMEOUT && dwSleepTotal < MAX_SLEEP_INST;
		dwSleepTotal += SLEEP_INTERVAL
		) {

		HRESULT		hr2;

		Sleep ( SLEEP_INTERVAL );

		hr2 = mkeyNntp.Open ( wszNewInstanceKey );
		_ASSERT ( SUCCEEDED(hr2) );

		hr2 = mkeyNntp.GetDword ( MD_WIN32_ERROR, &dwWin32Error );
		_ASSERT ( SUCCEEDED(hr2) );
	}

	if ( dwWin32Error != NOERROR ) {
		HRESULT		hr2;

		//
		//	The service reported an error.
		//	Delete the new instance key
		//

		hr2 = mkeyNntp.Open ( NNTP_MD_ROOT_PATH, METADATA_PERMISSION_WRITE );
		_ASSERT ( SUCCEEDED(hr2) );

		hr2 = mkeyNntp.DestroyChild ( wszInstance );
		_ASSERT ( SUCCEEDED(hr2) );

		hr2 = mkeyNntp.Save ();
		_ASSERT ( SUCCEEDED(hr2) );

		hr = HRESULT_FROM_WIN32 ( dwWin32Error );
		goto Exit;
	}

	*plInstanceId = dwInstance;

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdmin::DeleteInstance
//
//	Description:
//
//		Removes a virtual server from the metabase
//
//	Parameters:
//
//		pMetabase	- The metabase object
//		lInstanceId	- The ID of the virtual server to delete.
//		pErr		- The resulting error code.
//
//	Returns:
//
//		Resulting error code in *pErr.
//
//--------------------------------------------------------------------

HRESULT CNntpAdmin::DeleteInstance ( IMSAdminBase * pMetabase, long lInstanceId )
{
	TraceFunctEnter ( "CNntpAdmin::CreateNewInstance" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeyNntp ( pMetabase );

    //
    //  Tell U2 to delete any mappings associated with this virtual server:
    //

    ::DeleteMapping ( m_strServer, (BSTR) MD_SERVICE_NAME, lInstanceId );

    //
    //  Delete the virtual server from the metabase:
    //

	hr = mkeyNntp.Open ( NNTP_MD_ROOT_PATH );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open NntpSvc key, %x", GetLastError() );
		goto Exit;
	}

	hr = mkeyNntp.DestroyIntegerChild ( (DWORD) lInstanceId );
	if ( FAILED (hr) ) {
		goto Exit;
	}

    hr = mkeyNntp.Save ();
    BAIL_ON_FAILURE(hr);

Exit:
	TraceFunctLeave ();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\binding.cpp ===
// binding.cpp : Implementation of CNntpServerBinding & CNntpServerBindings.

#include "stdafx.h"
#include "nntpcmn.h"
#include "cmultisz.h"
#include "binding.h"
#include "oleutil.h"

// #include <stdio.h>

HRESULT	CBinding::SetProperties ( 
	BSTR	strIpAddress, 
	long	dwTcpPort,
	long	dwSslPort
	)
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	m_strIpAddress	= strIpAddress;
	m_dwTcpPort		= dwTcpPort;
	m_dwSslPort		= dwSslPort;

	if ( !m_strIpAddress ) {
		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_INntpServerBinding

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpServerBinding::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpServerBinding,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpServerBinding::CNntpServerBinding ()
	// CComBSTR's are initialized to NULL by default.
{
}

CNntpServerBinding::~CNntpServerBinding ()
{
	// All CComBSTR's are freed automatically.
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpServerBinding::get_IpAddress ( BSTR * pstrIpAddress )
{
	return StdPropertyGet ( m_binding.m_strIpAddress, pstrIpAddress );
}

STDMETHODIMP CNntpServerBinding::put_IpAddress ( BSTR strIpAddress )
{
	return StdPropertyPut ( &m_binding.m_strIpAddress, strIpAddress );
}

STDMETHODIMP CNntpServerBinding::get_TcpPort ( long * pdwTcpPort )
{
	return StdPropertyGet ( m_binding.m_dwTcpPort, pdwTcpPort );
}

STDMETHODIMP CNntpServerBinding::put_TcpPort ( long dwTcpPort )
{
	return StdPropertyPut ( &m_binding.m_dwTcpPort, dwTcpPort );
}

STDMETHODIMP CNntpServerBinding::get_SslPort ( long * plSslPort )
{
	return StdPropertyGet ( m_binding.m_dwSslPort, plSslPort );
}

STDMETHODIMP CNntpServerBinding::put_SslPort ( long lSslPort )
{
	return StdPropertyPut ( &m_binding.m_dwSslPort, lSslPort );
}

//
// Must define THIS_FILE_* macros to use NntpCreateException()
//

#undef THIS_FILE_HELP_CONTEXT
#undef THIS_FILE_PROG_ID
#undef THIS_FILE_IID

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_INntpServerBindings

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpServerBindings::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpServerBindings,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpServerBindings::CNntpServerBindings () :
	m_dwCount			( 0 ),
	m_rgBindings		( NULL )
	// CComBSTR's are initialized to NULL by default.
{
}

CNntpServerBindings::~CNntpServerBindings ()
{
	// All CComBSTR's are freed automatically.

	delete [] m_rgBindings;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpServerBindings::get_Count ( long * pdwCount )
{
	return StdPropertyGet ( m_dwCount, pdwCount );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpServerBindings::Item ( 
	long index, 
	INntpServerBinding ** ppBinding 
	)
{
	TraceFunctEnter ( "CNntpServerBindings::Item" );

	_ASSERT ( IS_VALID_OUT_PARAM ( ppBinding ) );

	*ppBinding = NULL;

	HRESULT								hr			= NOERROR;
	CComObject<CNntpServerBinding> *	pBinding	= NULL;

	if ( index < 0 || index >= m_dwCount ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = CComObject<CNntpServerBinding>::CreateInstance ( &pBinding );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( pBinding );
	hr = pBinding->SetProperties ( m_rgBindings[index] );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->QueryInterface ( IID_INntpServerBinding, (void **) ppBinding );
	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED(hr) ) {
		delete pBinding;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpServerBindings::ItemDispatch ( long index, IDispatch ** ppDispatch )
{
	HRESULT						hr;
	CComPtr<INntpServerBinding>	pBinding;

	hr = Item ( index, &pBinding );
	BAIL_ON_FAILURE ( hr );

	hr = pBinding->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CNntpServerBindings::Add ( 
	BSTR strIpAddress, 
	long dwTcpPort,
	long dwSslPort
	)
{
	TraceFunctEnter ( "CNntpServerBindings::Add" );

	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	HRESULT		hr	= NOERROR;
	CBinding *	rgNewBindings	= NULL;
	long		i;

	//
	//	Validate the new binding:
	//

	//
	//	See if we can merge this binding with an existing one:
	//
	if ( dwTcpPort == 0 || dwSslPort == 0 ) {
		for ( i = 0; i < m_dwCount; i++ ) {

			if ( (dwTcpPort == 0 && m_rgBindings[i].m_dwSslPort == 0) ||
				 (dwSslPort == 0 && m_rgBindings[i].m_dwTcpPort == 0) ) {

				if ( lstrcmpi ( m_rgBindings[i].m_strIpAddress, strIpAddress ) == 0 ) {

					if ( m_rgBindings[i].m_dwSslPort == 0 ) {
						m_rgBindings[i].m_dwSslPort = dwSslPort;
					}
					else {
						m_rgBindings[i].m_dwTcpPort = dwTcpPort;
					}
					hr = NOERROR;
					goto Exit;
				}
			}
		}
	}

	//	Allocate the new binding array:
	rgNewBindings	= new CBinding [ m_dwCount + 1 ];
	if ( !rgNewBindings ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	//	Copy the old bindings to the new array:
	for ( i = 0; i < m_dwCount; i++ ) {
		hr = rgNewBindings[i].SetProperties ( m_rgBindings[i] );
		if ( FAILED (hr) ) {
			goto Exit;
		}
	}

	//	Add the new binding to the end of the array:
	hr = rgNewBindings[m_dwCount].SetProperties ( strIpAddress, dwTcpPort, dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );
	delete [] m_rgBindings;
	m_rgBindings = rgNewBindings;
	rgNewBindings = NULL;
	m_dwCount++;

Exit:
    if (rgNewBindings) {
        delete [] rgNewBindings;
    }
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpServerBindings::ChangeBinding ( 
	long index, 
	INntpServerBinding * pBinding 
	)
{
	TraceFunctEnter ( "CNntpServerBindings::ChangeBinding" );

	HRESULT		hr	= NOERROR;

	CComBSTR	strIpAddress;
	long		dwTcpPort;
	long		dwSslPort;

	if ( index < 0 || index >= m_dwCount ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = pBinding->get_IpAddress ( &strIpAddress );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->get_TcpPort ( &dwTcpPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->get_SslPort ( &dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = m_rgBindings[index].SetProperties ( strIpAddress, dwTcpPort, dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpServerBindings::ChangeBindingDispatch ( long index, IDispatch * pDispatch )
{
	HRESULT						hr;
	CComPtr<INntpServerBinding>	pBinding;

	hr = pDispatch->QueryInterface ( IID_INntpServerBinding, (void **) &pBinding );
	BAIL_ON_FAILURE ( hr );

	hr = ChangeBinding ( index, pBinding );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CNntpServerBindings::Remove ( long index )
{
	TraceFunctEnter ( "CNntpServerBindings::Remove" );

	HRESULT		hr	= NOERROR;
	CBinding	temp;
	long		cPositionsToSlide;

	if ( index < 0 || index >= m_dwCount ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	//	Slide the array down by one position:

	_ASSERT ( m_rgBindings );

	cPositionsToSlide	= (m_dwCount - 1) - index;

	_ASSERT ( cPositionsToSlide < m_dwCount );

	if ( cPositionsToSlide > 0 ) {
		// Save the deleted binding in temp:
		CopyMemory ( &temp, &m_rgBindings[index], sizeof ( CBinding ) );

		// Move the array down one:
		MoveMemory ( &m_rgBindings[index], &m_rgBindings[index + 1], sizeof ( CBinding ) * cPositionsToSlide );

		// Put the deleted binding on the end (so it gets destructed):
		CopyMemory ( &m_rgBindings[m_dwCount - 1], &temp, sizeof ( CBinding ) );

		// Zero out the temp binding:
		ZeroMemory ( &temp, sizeof ( CBinding ) );
	}

	m_dwCount--;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpServerBindings::Clear ( )
{
	delete [] m_rgBindings;
	m_rgBindings 	= NULL;
	m_dwCount		= 0;

	return NOERROR;
}

//////////////////////////////////////////////////////////////////////
//
//	Useful routines to go from INntpServerBindings to 
//	Metabase data types.
//
//////////////////////////////////////////////////////////////////////

static DWORD CountBindingChars ( LPCWSTR strIpAddress, DWORD dwPort )
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	DWORD		cchResult	= 0;
	WCHAR		wszPort [256];

	wsprintf ( wszPort, _T("%u"), dwPort );

	cchResult += lstrlen ( strIpAddress );	// <IPADDRESS>
	cchResult += 1;							// :
	cchResult += lstrlen ( wszPort );		// <PORT>
	cchResult += 1;							// :
//	cchResult += lstrlen ( strPathHeader );	// <PATHHEADER>

	cchResult += 1;		// For the terminating NULL

	return cchResult;
}

static void ToBindingString ( LPCWSTR strIpAddress, DWORD dwPort, LPWSTR wszBinding )
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );
	_ASSERT ( dwPort != 0 );

	_ASSERT ( !IsBadWritePtr ( wszBinding, CountBindingChars ( strIpAddress, dwPort ) ) );

	wsprintf ( wszBinding, _T("%s:%u:"), strIpAddress, dwPort );
}

static HRESULT FromBindingString ( LPCWSTR wszBinding, LPWSTR wszIpAddressOut, DWORD * pdwPort )
{
	HRESULT	hr	= NOERROR;

	LPWSTR	pchFirstColon;
	LPWSTR	pchSecondColon;

	WCHAR	wszIpAddress	[ 256 ];
	WCHAR	wszPort			[ 256 ];
	long	dwPort;

	LPWSTR	pchColon;

	wszIpAddress[0]	= NULL;
	wszPort[0]		= NULL;

	pchFirstColon = wcschr ( wszBinding, _T(':') );
	if ( pchFirstColon ) {
		pchSecondColon = wcschr ( pchFirstColon + 1, _T(':') );
	}

	if ( !pchFirstColon || !pchSecondColon ) {
		hr = HRESULT_FROM_WIN32 ( ERROR_INVALID_DATA );
		goto Exit;
	}

	lstrcpyn ( wszIpAddress, wszBinding, 250 );
	lstrcpyn ( wszPort, pchFirstColon + 1, 250 );

	// Get the Port:
	dwPort	= _wtoi ( wszPort );

	// Cutoff the IpAddress at the colon:
	pchColon = wcschr ( wszIpAddress, _T(':') );
	if ( pchColon ) {
		*pchColon = NULL;
	}

	lstrcpy ( wszIpAddressOut, wszIpAddress );
	*pdwPort		= dwPort;

Exit:
	return hr;
}

HRESULT 
MDBindingsToIBindings ( 
	CMultiSz *				pmsz, 
	BOOL					fTcpBindings,
	INntpServerBindings *	pBindings 
	)
{
	HRESULT		hr	= NOERROR;
	DWORD		cBindings;
	DWORD		i;
	LPCWSTR		pchCurrent;
	CBinding	binding;

	cBindings = pmsz->Count ();

	for ( 
			i = 0, pchCurrent = *pmsz; 
			i < cBindings; 
			i++, pchCurrent += lstrlen ( pchCurrent ) + 1 
		) {

		WCHAR	wszIpAddress[512];
		DWORD	dwPort;

		hr = FromBindingString ( pchCurrent, wszIpAddress, &dwPort );
		BAIL_ON_FAILURE(hr);

		if ( fTcpBindings ) {
			hr = pBindings->Add ( wszIpAddress, dwPort, 0 );
		}
		else {
			hr = pBindings->Add ( wszIpAddress, 0, dwPort );
		}
		BAIL_ON_FAILURE(hr);
	}

Exit:
	return hr;
}

HRESULT IBindingsToMDBindings ( 
	INntpServerBindings *	pBindings,
	BOOL					fTcpBindings,
	CMultiSz *				pmsz
	)
{
	HRESULT		hr	= NOERROR;
	long		cBindings;
	long		i;
	DWORD		cbCount		= 0;
	LPWSTR		wszBindings	= NULL;

	// Count the characters of the regular bindings list:
	cbCount	= 0;
	pBindings->get_Count ( &cBindings );

	for ( i = 0; i < cBindings; i++ ) {
		CComPtr<INntpServerBinding>	pBinding;
		CComBSTR					strIpAddress;
		long						lTcpPort;
		long						lSslPort;

		hr = pBindings->Item ( i, &pBinding );
		BAIL_ON_FAILURE(hr);

		pBinding->get_IpAddress	( &strIpAddress );
		pBinding->get_TcpPort	( &lTcpPort );
		pBinding->get_SslPort	( &lSslPort );

		if ( fTcpBindings ) {
			if ( lTcpPort != 0 ) {
				cbCount += CountBindingChars ( strIpAddress, lTcpPort );
			}
		}
		else {
			if ( lSslPort != 0 ) {
				cbCount += CountBindingChars ( strIpAddress, lSslPort );
			}
		}
	}

	if ( cbCount == 0 ) {
		cbCount		= 2;
		wszBindings	= new WCHAR [ cbCount ];

		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		wszBindings[0]	= NULL;
		wszBindings[1]	= NULL;
	}
	else {
		cbCount++;	// For double null terminator

		wszBindings	= new WCHAR [ cbCount ];
		if ( !wszBindings ) {
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		LPWSTR		pchCurrent	= wszBindings;

		for ( i = 0; i < cBindings; i++ ) {
			CComPtr<INntpServerBinding>	pBinding;
			CComBSTR					strIpAddress;
			long						lTcpPort;
			long						lSslPort;

			hr = pBindings->Item ( i, &pBinding );
			BAIL_ON_FAILURE(hr);

			pBinding->get_IpAddress	( &strIpAddress );
			pBinding->get_TcpPort	( &lTcpPort );
			pBinding->get_SslPort	( &lSslPort );

			if ( fTcpBindings ) {
				if ( lTcpPort != 0 ) {
					ToBindingString ( strIpAddress, lTcpPort, pchCurrent );
					pchCurrent += lstrlen ( pchCurrent ) + 1;
				}
			}
			else {
				if ( lSslPort != 0 ) {
					ToBindingString ( strIpAddress, lSslPort, pchCurrent );
					pchCurrent += lstrlen ( pchCurrent ) + 1;
				}
			}
		}

		*pchCurrent = NULL;
	}

	_ASSERT ( wszBindings[cbCount - 1] == NULL );
	_ASSERT ( wszBindings[cbCount - 2] == NULL );

	pmsz->Attach ( wszBindings );

Exit:
	return hr;
}

#if 0
	
DWORD CBinding::SizeInChars ( )
{
	DWORD		cchResult	= 0;
	WCHAR		wszTcpPort [256];

	wsprintf ( wszTcpPort, _T("%d"), m_dwTcpPort );

	cchResult += lstrlen ( m_strIpAddress );	// <IPADDRESS>
	cchResult += 1;								// :
	cchResult += lstrlen ( wszTcpPort );		// <TCPPORT>
	cchResult += 1;								// :
//	cchResult += lstrlen ( m_strPathHeader );	// <PATHHEADER>

	return cchResult;
}

void CBinding::ToString	( LPWSTR wszBinding )
{
	wsprintf ( wszBinding, _T("%s:%d:"), m_strIpAddress, m_dwTcpPort );
}

HRESULT CBinding::FromString ( LPCWSTR wszBinding )
{
	HRESULT	hr	= NOERROR;

	LPWSTR	pchFirstColon;
	LPWSTR	pchSecondColon;

	WCHAR	wszIpAddress 	[ 256 ];
	WCHAR	wszTcpPort		[ 256 ];
	long	dwTcpPort;

	LPWSTR	pchColon;

	wszIpAddress[0]		= NULL;
	wszTcpPort[0]		= NULL;

	pchFirstColon = wcschr ( wszBinding, _T(':') );
	if ( pchFirstColon ) {
		pchSecondColon = wcschr ( pchFirstColon + 1, _T(':') );
	}

	if ( !pchFirstColon || !pchSecondColon ) {
		hr = E_FAIL;
		goto Exit;
	}

	lstrcpyn ( wszIpAddress, wszBinding, 250 );
	lstrcpyn ( wszTcpPort, pchFirstColon + 1, 250 );

	// Get the TcpPort:
	dwTcpPort = _wtoi ( wszTcpPort );

	// Cutoff the IpAddress at the colon:
	pchColon = wcschr ( wszIpAddress, _T(':') );
	if ( pchColon ) {
		*pchColon = NULL;
	}

	m_strIpAddress	= wszIpAddress;
	m_dwTcpPort		= dwTcpPort;

	if ( !m_strIpAddress ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	return hr;
}

HRESULT CNntpServerBindings::FromMultiSz ( CMultiSz * pmsz )
{
	HRESULT		hr;
	DWORD		cBindings;
	DWORD		i;
	LPCWSTR		pchCurrent;
	CBinding	binding;

	hr = Clear ();
	_ASSERT ( SUCCEEDED(hr) );

	cBindings = pmsz->Count ();

	for ( 
			i = 0, pchCurrent = *pmsz; 
			i < cBindings; 
			i++, pchCurrent += lstrlen ( pchCurrent ) + 1 
		) {

		hr = binding.FromString ( pchCurrent );
		if ( FAILED(hr) ) {
			if ( hr == E_FAIL ) {
				// Skip the bad binding strings.
				continue;
			}
			else {
				goto Exit;
			}
		}

		hr = Add ( binding.m_strIpAddress, binding.m_dwTcpPort );
		if ( FAILED(hr) ) {
			goto Exit;
		}
	}

Exit:
	return hr;
}

HRESULT CNntpServerBindings::ToMultiSz ( CMultiSz * pmsz )
{
	HRESULT	hr	= NOERROR;
	DWORD	cchSize;
	long	i;
	LPWSTR	wszBindings;
	LPWSTR	pchCurrent;

	// Special case - the empty binding list:
	if ( m_dwCount == 0 ) {
		cchSize		= 2;
		wszBindings	= new WCHAR [ cchSize ];

		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		wszBindings[0]	= NULL;
		wszBindings[1]	= NULL;
	}
	else {

		cchSize = 0;

		for ( i = 0; i < m_dwCount; i++ ) {
			cchSize += m_rgBindings[i].SizeInChars ( ) + 1;
		}
		// Add the size of the final terminator:
		cchSize += 1;

		wszBindings = new WCHAR [ cchSize ];
		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		for ( i = 0, pchCurrent = wszBindings; i < m_dwCount; i++ ) {

			m_rgBindings[i].ToString ( pchCurrent );
			pchCurrent += lstrlen ( pchCurrent ) + 1;
		}

		// Add the final NULL terminator:
		*pchCurrent = NULL;
	}

	_ASSERT ( wszBindings[cchSize - 1] == NULL );
	_ASSERT ( wszBindings[cchSize - 2] == NULL );

	pmsz->Attach ( wszBindings );

	_ASSERT ( pmsz->Count () == (DWORD) m_dwCount );

Exit:
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\binding.h ===
// binding.h : Declaration of the CNntpServerBinding & CNntpServerBindings classes.


//
//	Dependencies:
//

class CMultiSz;

//
//	A simple binding class:
//

class CBinding
{
public:
	CBinding () : 
		m_dwTcpPort ( 0 ),
		m_dwSslPort ( 0 )
		{ }

	CComBSTR	m_strIpAddress;
	long		m_dwTcpPort;
	long		m_dwSslPort;

	HRESULT	SetProperties ( BSTR strIpAddress, long dwTcpPort, long dwSslPort );
	inline HRESULT	SetProperties ( const CBinding & binding )
	{
		return SetProperties ( 
			binding.m_strIpAddress, 
			binding.m_dwTcpPort,
			binding.m_dwSslPort
			);
	}

private:
	// Don't call this:
	const CBinding & operator= ( const CBinding & );
};

/////////////////////////////////////////////////////////////////////////////
// The Binding Object

class CNntpServerBinding : 
	public CComDualImpl<INntpServerBinding, &IID_INntpServerBinding, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
	friend class CNntpServerBindings;
	friend class CNntpVirtualServer;

public:
	CNntpServerBinding();
	virtual ~CNntpServerBinding ();
BEGIN_COM_MAP(CNntpServerBinding)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpServerBinding)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpServerBinding) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpServerBinding
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_IpAddress	( BSTR * pstrIpAddress );
	STDMETHODIMP	put_IpAddress	( BSTR strIpAddress );

	STDMETHODIMP	get_TcpPort	( long * pdwTcpPort );
	STDMETHODIMP	put_TcpPort	( long dwTcpPort );

	STDMETHODIMP	get_SslPort	( long * plSslPort );
	STDMETHODIMP	put_SslPort	( long lSslPort );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	inline HRESULT	SetProperties	( const CBinding & binding )
	{
		return m_binding.SetProperties ( binding );
	}

	// Property variables:
	CBinding	m_binding;
};

/////////////////////////////////////////////////////////////////////////////
// The Bindings Object

class CNntpServerBindings : 
	public CComDualImpl<INntpServerBindings, &IID_INntpServerBindings, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
	friend class CNntpServerBinding;
	friend class CNntpVirtualServer;

public:
	CNntpServerBindings();
	virtual ~CNntpServerBindings ();
BEGIN_COM_MAP(CNntpServerBindings)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpServerBindings)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpServerBindings) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpServerBindings
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_Count	( long * pdwCount );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Item			( long index, INntpServerBinding ** ppBinding );
	STDMETHODIMP	ItemDispatch	( long index, IDispatch ** ppBinding );
	STDMETHODIMP	Add				( BSTR strIpAddress, long dwTcpPort, long dwSslPort );
	STDMETHODIMP	ChangeBinding	( long index, INntpServerBinding * pBinding );
	STDMETHODIMP	ChangeBindingDispatch	( long index, IDispatch * pBinding );
	STDMETHODIMP	Remove			( long index );
	STDMETHODIMP	Clear			( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Property variables:
	long			m_dwCount;
	CBinding *		m_rgBindings;
};

//////////////////////////////////////////////////////////////////////
//
//	Useful routines to go from INntpServerBindings to 
//	Metabase data types.
//
//////////////////////////////////////////////////////////////////////

HRESULT 
MDBindingsToIBindings ( 
	CMultiSz *				pmszBindings, 
	BOOL					fTcpBindings,
	INntpServerBindings *	pBindings 
	);

HRESULT IBindingsToMDBindings ( 
	INntpServerBindings *	pBindings,
	BOOL					fTcpBindings,
	CMultiSz *				pmszBindings
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\expire.h ===
// expire.h : Declaration of the CNntpAdminExpiration


/////////////////////////////////////////////////////////////////////////////
// Dependencies:

#include "metafact.h"
#include "expinfo.h"

/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpAdminExpiration : 
	public INntpAdminExpiration, 
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdminExpiration,&CLSID_CNntpAdminExpiration>
{
public:
	CNntpAdminExpiration();
	virtual ~CNntpAdminExpiration ();
BEGIN_COM_MAP(CNntpAdminExpiration)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(INntpAdminExpiration)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdminExpiration) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdminExpiration, _T("Nntpadm.Expiration.1"), _T("Nntpadm.Expiration"), IDS_NNTPADMINEXPIRATION_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_NNTPADMLib
	#define THIS_IID	IID_INntpAdminExpiration
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// INntpAdminExpiration
public:

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Enumeration Properties:

	STDMETHODIMP	get_Count	( long * plCount );

	// Cursor Feed Properties:

	STDMETHODIMP	get_ExpireId	( long * plId );
	STDMETHODIMP	put_ExpireId	( long lId );

	STDMETHODIMP	get_PolicyName	( BSTR * pstrPolicyName );
	STDMETHODIMP	put_PolicyName	( BSTR strPolicyName );

	STDMETHODIMP	get_ExpireTime	( long * plExpireTime );
	STDMETHODIMP	put_ExpireTime	( long lExpireTime );

	STDMETHODIMP	get_ExpireSize	( long * plExpireSize );
	STDMETHODIMP	put_ExpireSize	( long lExpireSize );

	STDMETHODIMP	get_Newsgroups	( SAFEARRAY ** ppsastrNewsgroups );
	STDMETHODIMP	put_Newsgroups	( SAFEARRAY * psastrNewsgroups );

	STDMETHODIMP	get_NewsgroupsVariant	( SAFEARRAY ** ppsastrNewsgroups );
	STDMETHODIMP	put_NewsgroupsVariant	( SAFEARRAY * psastrNewsgroups );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Default		( );
	STDMETHODIMP	Enumerate	( );
	STDMETHODIMP	GetNth		( long lIndex );
	STDMETHODIMP	FindID		( long lID, long * plIndex );
	STDMETHODIMP	Add			( );
	STDMETHODIMP	Set			( );
	STDMETHODIMP	Remove		( long lID);

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	BOOL			m_fEnumerated;
	DWORD			m_cCount;
	CExpirationPolicy *	m_rgExpires;

	// The current expiration policy.  All properties manipulate this policy:
	CExpirationPolicy	m_expireCurrent;
	DWORD				m_bvChangedFields;

	//////////////////////////////////////////////////////////////////////
	//	Private Methods:
	//////////////////////////////////////////////////////////////////////

	long		IndexFromID ( long dwExpireId );

/*
	HRESULT		EnumerateMetabaseExpirationPolicies ( IMSAdminBase * pMetabase);
	HRESULT		AddPolicyToMetabase			( IMSAdminBase * pMetabase);
	HRESULT		AddPolicyToArray			( );
	HRESULT		SetPolicyToMetabase			( IMSAdminBase * pMetabase);
	HRESULT		SetPolicyToArray			( );
	HRESULT		RemovePolicyFromMetabase	( IMSAdminBase * pMetabase, DWORD index);
	HRESULT		RemovePolicyFromArray		( DWORD index );
	DWORD		IndexFromID 				( DWORD dwID );
*/
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\expire.cpp ===
// expire.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"
#include "nntpcmn.h"
#include "expire.h"
#include "oleutil.h"

#include "nntptype.h"
#include "nntpapi.h"

#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Expiration.1")
#define THIS_FILE_IID				IID_INntpAdminExpiration

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(NntpAdminExpiration, CNntpAdminExpiration, IID_INntpAdminExpiration)

STDMETHODIMP CNntpAdminExpiration::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpAdminExpiration,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpAdminExpiration::CNntpAdminExpiration () :
	m_fEnumerated				( FALSE ),
	m_bvChangedFields			( 0 ),
	m_cCount					( 0 ),
	m_rgExpires					( NULL )
	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Expires") );
    m_iadsImpl.SetClass ( _T("IIsNntpExpires") );
}

CNntpAdminExpiration::~CNntpAdminExpiration ()
{
	// All CComBSTR's are freed automatically.

	if ( m_rgExpires ) {
		delete [] m_rgExpires;

		m_rgExpires = NULL;
	}

	TermAsyncTrace ( );
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CNntpAdminExpiration,m_iadsImpl)

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// Enumeration Properties:

STDMETHODIMP CNntpAdminExpiration::get_Count ( long * plCount )
{
	return StdPropertyGet ( m_cCount, plCount );
}

// Cursor Expire Properties:

STDMETHODIMP CNntpAdminExpiration::get_ExpireId ( long * plId )
{
	return StdPropertyGet ( m_expireCurrent.m_dwExpireId, plId );
}

STDMETHODIMP CNntpAdminExpiration::put_ExpireId ( long lId )
{
	return StdPropertyPut ( &m_expireCurrent.m_dwExpireId, lId, &m_bvChangedFields, CHNG_EXPIRE_ID );
}

STDMETHODIMP CNntpAdminExpiration::get_PolicyName ( BSTR * pstrPolicyName )
{
	return StdPropertyGet ( m_expireCurrent.m_strPolicyName, pstrPolicyName );
}

STDMETHODIMP CNntpAdminExpiration::put_PolicyName ( BSTR strPolicyName )
{
	return StdPropertyPut ( &m_expireCurrent.m_strPolicyName, strPolicyName, &m_bvChangedFields, CHNG_EXPIRE_POLICY_NAME );
}

STDMETHODIMP CNntpAdminExpiration::get_ExpireTime ( long * plExpireTime )
{
	return StdPropertyGet ( m_expireCurrent.m_dwTime, plExpireTime );
}

STDMETHODIMP CNntpAdminExpiration::put_ExpireTime ( long lExpireTime )
{
	return StdPropertyPut ( &m_expireCurrent.m_dwTime, lExpireTime, &m_bvChangedFields, CHNG_EXPIRE_TIME );
}

STDMETHODIMP CNntpAdminExpiration::get_ExpireSize ( long * plExpireSize )
{
	return StdPropertyGet ( m_expireCurrent.m_dwSize, plExpireSize );
}

STDMETHODIMP CNntpAdminExpiration::put_ExpireSize ( long lExpireSize )
{
	return StdPropertyPut ( &m_expireCurrent.m_dwSize, lExpireSize, &m_bvChangedFields, CHNG_EXPIRE_SIZE );
}

STDMETHODIMP CNntpAdminExpiration::get_Newsgroups ( SAFEARRAY ** ppsastrNewsgroups )
{
	return StdPropertyGet ( &m_expireCurrent.m_mszNewsgroups, ppsastrNewsgroups );
}

STDMETHODIMP CNntpAdminExpiration::put_Newsgroups ( SAFEARRAY * psastrNewsgroups )
{
	return StdPropertyPut ( &m_expireCurrent.m_mszNewsgroups, psastrNewsgroups, &m_bvChangedFields, CHNG_EXPIRE_NEWSGROUPS );
}

STDMETHODIMP CNntpAdminExpiration::get_NewsgroupsVariant ( SAFEARRAY ** ppsavarNewsgroups )
{
	HRESULT			hr;
	SAFEARRAY *		psastrNewsgroups	= NULL;

	hr = get_Newsgroups ( &psastrNewsgroups );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = StringArrayToVariantArray ( psastrNewsgroups, ppsavarNewsgroups );

Exit:
	if ( psastrNewsgroups ) {
		SafeArrayDestroy ( psastrNewsgroups );
	}

	return hr;
}

STDMETHODIMP CNntpAdminExpiration::put_NewsgroupsVariant ( SAFEARRAY * psavarNewsgroups )
{
	HRESULT			hr;
	SAFEARRAY *		psastrNewsgroups	= NULL;

	hr = VariantArrayToStringArray ( psavarNewsgroups, &psastrNewsgroups );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = put_Newsgroups ( psastrNewsgroups );

Exit:
	if ( psastrNewsgroups ) {
		SafeArrayDestroy ( psastrNewsgroups );
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpAdminExpiration::Default	( )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Default" );
	HRESULT		hr	= NOERROR;

	m_expireCurrent.m_dwSize			= DEFAULT_EXPIRE_SIZE;
	m_expireCurrent.m_dwTime			= DEFAULT_EXPIRE_TIME;
	m_expireCurrent.m_mszNewsgroups		= DEFAULT_EXPIRE_NEWSGROUPS;

	m_bvChangedFields	= (DWORD) -1;

	if ( !m_expireCurrent.CheckValid() ) {
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Enumerate	( )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Enumerate" );

	HRESULT				hr			= NOERROR;
	DWORD				dwError		= NOERROR;
	DWORD				cExpires		= 0;
	LPNNTP_EXPIRE_INFO	pExpireInfo	= NULL;
	CExpirationPolicy * 			rgNewExpires	= NULL;
	DWORD				i;

	dwError = NntpEnumerateExpires (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &cExpires,
        &pExpireInfo
        );
	if ( dwError != 0 ) {
		ErrorTrace ( (LPARAM) this, "Error enumerating Expires: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

	// Empty the old Expire list:
	m_fEnumerated = FALSE;

	if ( m_rgExpires ) {
		delete [] m_rgExpires;
		m_rgExpires 	= NULL;
	}
	m_cCount	= 0;

	// Attempt to copy the Expire list into our structures:

	if ( cExpires > 0 ) {
		rgNewExpires = new CExpirationPolicy [ cExpires ];
		for ( i = 0; i < cExpires; i++ ) {
			rgNewExpires[i].FromExpireInfo ( &pExpireInfo[i] );

			if ( !rgNewExpires[i].CheckValid () ) {
				hr = E_OUTOFMEMORY;
				goto Exit;
			}
		}
	}

	m_fEnumerated 	= TRUE;
	m_rgExpires		= rgNewExpires;
	m_cCount		= cExpires;

Exit:
	if ( FAILED(hr) ) {
		delete [] rgNewExpires;
	}

	if ( pExpireInfo ) {
		::NetApiBufferFree ( pExpireInfo );
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::GetNth	( long lIndex )
{
	TraceFunctEnter ( "CNntpAdminExpiration::GetNth" );

	HRESULT		hr	= NOERROR;

	// Did we enumerate first?
	if ( m_rgExpires == NULL ) {
		TraceFunctLeave ();
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );
	}
	
	// Is the index valid?
	if ( lIndex < 0 || (DWORD) lIndex >= m_cCount ) {
		TraceFunctLeave ();
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	//
	// Copy the properties from m_rgExpires [ lIndex ] to member variables:
	//

	_ASSERT ( lIndex >= 0 );
	_ASSERT ( (DWORD) lIndex < m_cCount );
	_ASSERT ( m_rgExpires != NULL );

	m_expireCurrent = m_rgExpires[ (DWORD) lIndex ];

	// Check to make sure the strings were copied okay:
	if ( !m_expireCurrent.CheckValid() ) {
		return E_OUTOFMEMORY;
	}

	_ASSERT ( m_expireCurrent.CheckValid() );

	// ( CComBSTR handles free-ing of old properties )
	TraceFunctLeave ();
	return NOERROR;
}

STDMETHODIMP CNntpAdminExpiration::FindID ( long lID, long * plIndex )
{
	TraceFunctEnter ( "CNntpAdminExpiration::FindID" );

	HRESULT		hr	= NOERROR;

	// Assume that we can't find it:
	*plIndex = IndexFromID ( lID );

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Add ( )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Add" );

	HRESULT		            hr 				= NOERROR;
	CExpirationPolicy *		rgNewExpireArray	= NULL;
	DWORD		            cNewCount		= m_cCount + 1;
	DWORD		            i;

	hr = m_expireCurrent.Add (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
    BAIL_ON_FAILURE(hr);

	// Add the new Expire to our current Expire list:
	_ASSERT ( IndexFromID ( m_expireCurrent.m_dwExpireId ) == (DWORD) -1 );

	// Allocate the new array:
	_ASSERT ( cNewCount == m_cCount + 1 );

	rgNewExpireArray = new CExpirationPolicy [ cNewCount ];
	if ( rgNewExpireArray == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );

		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Copy the old array into the new one:
	for ( i = 0; i < m_cCount; i++ ) {
		rgNewExpireArray[i] = m_rgExpires[i];
	}

	// Add the new element:
	rgNewExpireArray[cNewCount - 1] = m_expireCurrent;

	// Check to make sure everything was allocated okay:
	for ( i = 0; i < cNewCount; i++ ) {
		if ( !rgNewExpireArray[i].CheckValid() ) {
			FatalTrace ( (LPARAM) this, "Out of memory" );

			hr = E_OUTOFMEMORY;
			goto Exit;
		}
	}

	// Replace the old array with the new one:
	delete [] m_rgExpires;
	m_rgExpires 	= rgNewExpireArray;
	m_cCount	= cNewCount;

Exit:
	if ( FAILED(hr) ) {
		delete [] rgNewExpireArray;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Set ( )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Set" );

	HRESULT		hr = NOERROR;
	DWORD		index;

	hr = m_expireCurrent.Set (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	index = IndexFromID ( m_expireCurrent.m_dwExpireId );
	if ( index == (DWORD) -1 ) {
		ErrorTraceX ( (LPARAM) this, "Couldn't find Expire with ID: %d", m_expireCurrent.m_dwExpireId );
		// This is okay, since we succeeded in setting the current Expire already.
		goto Exit;
	}

	// Set the current Expire in the current Expire list:

	m_rgExpires[index] = m_expireCurrent;

	if ( !m_rgExpires[index].CheckValid () ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );

		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Remove ( long lID )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Remove" );

	HRESULT		hr = NOERROR;
	DWORD		index;

	index = IndexFromID ( lID );
	if ( index == (DWORD) -1 ) {
		ErrorTraceX ( (LPARAM) this, "Couldn't find Expire with ID: %d", lID );
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = m_rgExpires[index].Remove (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	//	Slide the array down by one position:

	_ASSERT ( m_rgExpires );

	DWORD	cPositionsToSlide;

	cPositionsToSlide	= (m_cCount - 1) - index;

	_ASSERT ( cPositionsToSlide < m_cCount );

	if ( cPositionsToSlide > 0 ) {
		CExpirationPolicy	temp;
		
		// Save the deleted binding in temp:
		CopyMemory ( &temp, &m_rgExpires[index], sizeof ( CExpirationPolicy ) );

		// Move the array down one:
		MoveMemory ( &m_rgExpires[index], &m_rgExpires[index + 1], sizeof ( CExpirationPolicy ) * cPositionsToSlide );

		// Put the deleted binding on the end (so it gets destructed):
		CopyMemory ( &m_rgExpires[m_cCount - 1], &temp, sizeof ( CExpirationPolicy ) );

		// Zero out the temp binding:
		ZeroMemory ( &temp, sizeof ( CExpirationPolicy ) );
	}

	m_cCount--;

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

long CNntpAdminExpiration::IndexFromID ( long dwExpireId )
{
	TraceFunctEnter ( "CNntpAdminExpiration::IndexFromID" );

	DWORD	i;

	if ( m_rgExpires == NULL ) {
		return -1;
	}

	_ASSERT ( !IsBadReadPtr ( m_rgExpires, sizeof ( CExpirationPolicy ) * m_cCount ) );

	for ( i = 0; i < m_cCount; i++ ) {
		_ASSERT ( m_rgExpires[i].m_dwExpireId != 0 );

		if ( (DWORD) dwExpireId == m_rgExpires[i].m_dwExpireId ) {
			TraceFunctLeave ();
			return i;
		}
	}

	TraceFunctLeave ();
	return (DWORD) -1;
}

//
// Use RPCs instead of direct metabase calls:
//

#if 0

STDMETHODIMP CNntpAdminExpiration::Enumerate ( )
{
	TraceFunctEnter ( "CNntpadminExpiration::Enumerate" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Reset our last enumeration:
	delete [] m_rgExpires;
	m_rgExpires 	= NULL;
	m_cCount		= 0;
	m_fEnumerated	= FALSE;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Enumerate the policies:
	hr = EnumerateMetabaseExpirationPolicies ( pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::GetNth	( DWORD lIndex )
{
	HRESULT		hr	= NOERROR;

	// Did we enumerate first?
	if ( m_rgExpires == NULL ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );
	}
	
	// Is the index valid?
	if ( lIndex < 0 || (DWORD) lIndex >= m_cCount ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	//
	// Copy the properties from m_rgExpires [ lIndex ] to member variables:
	//

	_ASSERT ( lIndex >= 0 );
	_ASSERT ( (DWORD) lIndex < m_cCount );
	_ASSERT ( m_rgExpires != NULL );

	m_expireCurrent = m_rgExpires[ (DWORD) lIndex ];

	// Check to make sure the strings were copied okay:
	if ( !m_expireCurrent.CheckValid() ) {
		return E_OUTOFMEMORY;
	}

	m_bvChangedFields	= 0;

	_ASSERT ( m_expireCurrent.CheckValid() );

	// ( CComBSTR handles free-ing of old properties )
	return NOERROR;
}

STDMETHODIMP CNntpAdminExpiration::FindID ( DWORD lID, DWORD * plIndex )
{
	TraceFunctEnter ( "CNntpAdminExpiration::FindID" );

	HRESULT		hr	= NOERROR;
	DWORD		i;

	_ASSERT ( IS_VALID_OUT_PARAM ( plIndex ) );

	*plIndex = IndexFromID ( lID );

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Add ( )
{
	TraceFunctEnter ( "CNntpAdminExpiration::Add" );
	
	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = AddPolicyToMetabase ( pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	m_bvChangedFields = 0;
	hr = AddPolicyToArray ( );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Set		( BOOL fFailIfChanged)
{
	TraceFunctEnter ( "CNntpadminExpiration::Enumerate" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Set the policy:
	hr = SetPolicyToMetabase ( pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}
	
	m_bvChangedFields = 0;
	hr = SetPolicyToArray ( );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminExpiration::Remove	( DWORD lID)
{
	TraceFunctEnter ( "CNntpadminExpiration::Remove" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;
	DWORD				index;

	// Find the index of the policy to remove:
	index = IndexFromID ( lID );

	if ( index == (DWORD) -1 ) {
		hr = RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance()
        );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Remove the current policy:
	hr = RemovePolicyFromMetabase ( pMetabase, index );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = RemovePolicyFromArray ( index );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT	CNntpAdminExpiration::EnumerateMetabaseExpirationPolicies ( IMSAdminBase * pMetabase)
{
	TraceFunctEnter ( "CNE::EnumerateMetabaseExpirationPolicies" );

	_ASSERT ( pMetabase );

	HRESULT				hr		= NOERROR;
	char				szExpirationPath[ METADATA_MAX_NAME_LEN ];
	METADATA_HANDLE		hExpiration	= NULL;
	CMetabaseKey		mkeyExpiration	( pMetabase );
	DWORD				cExpires;
	DWORD				i;

	_ASSERT ( m_dwServiceInstance != 0 );

	hr = CreateSubkeyOfInstanceKey ( 
		pMetabase, 
		NNTP_MD_ROOT_PATH, 
		m_dwServiceInstance, 
		NNTP_MD_EXPIRES_PATH, 
		&hExpiration 
		);

	if ( FAILED(hr) ) {
		goto Exit;
	}

	mkeyExpiration.Attach ( hExpiration );

	// Count the items under the /LM/NntpSvc/Expires/ key:
	hr = mkeyExpiration.GetCustomChildCount ( IsKeyValidExpire, &cExpires );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	if ( cExpires != 0 ) {
		// Allocate the expiration policy array:
		m_rgExpires = new CExpirationPolicy [ cExpires ];

		mkeyExpiration.BeginChildEnumeration ();

		for ( i = 0; i < cExpires; i++ ) {
			char		szName[ METADATA_MAX_NAME_LEN ];
			DWORD		dwID;

			hr = mkeyExpiration.NextCustomChild ( IsKeyValidExpire, szName );
			_ASSERT ( SUCCEEDED(hr) );

			hr = m_rgExpires[i].GetFromMetabase ( &mkeyExpiration, szName );
			if ( FAILED (hr) ) {
				goto Exit;
			}
		}
	}

	m_cCount		= cExpires;
	m_fEnumerated	= TRUE;

	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED(hr) ) {
		delete [] m_rgExpires;
		m_rgExpires		= NULL;
		m_cCount		= 0;
		m_fEnumerated	= FALSE;
	}

	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::AddPolicyToMetabase ( IMSAdminBase * pMetabase)
{
	TraceFunctEnter ( "CNE::AddPolicyToMetabase" );

	_ASSERT ( pMetabase );

	HRESULT				hr = NOERROR;
	char				szExpirationPath [ METADATA_MAX_NAME_LEN ];
	METADATA_HANDLE		hExpiration	= NULL;
	CMetabaseKey		mkeyExpiration ( pMetabase );
	char				szNewId [ METADATA_MAX_NAME_LEN ];
	DWORD				dwNewId;

	if ( !m_expireCurrent.CheckPolicyProperties ( ) ) {
		hr = RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

	hr = CreateSubkeyOfInstanceKey ( 
		pMetabase,
		NNTP_MD_ROOT_PATH,
		m_dwServiceInstance,
		NNTP_MD_EXPIRES_PATH,
		&hExpiration,
		METADATA_PERMISSION_WRITE
		);
		
	if ( FAILED(hr) ) {
		goto Exit;
	}

	mkeyExpiration.Attach ( hExpiration );

	hr = m_expireCurrent.AddToMetabase ( &mkeyExpiration );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );
	
	hr = pMetabase->SaveData ( );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::AddPolicyToArray ( )
{
	TraceFunctEnter ( "CNE::AddPolicyToArray" );

	HRESULT					hr 					= NOERROR;
	CExpirationPolicy *		rgNewPolicyArray 	= NULL;
	DWORD					i;

	// Adjust the expiration policy array:
	rgNewPolicyArray = new CExpirationPolicy [ m_cCount + 1 ];

	if ( rgNewPolicyArray == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Copy the old entries:
	for ( i = 0; i < m_cCount; i++ ) {
		_ASSERT ( m_rgExpires[i].CheckValid() );
		rgNewPolicyArray[i] = m_rgExpires[i];

		if ( !rgNewPolicyArray[i].CheckValid() ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}
	}

	// Add the new entry:
	_ASSERT ( m_expireCurrent.CheckValid() );
	rgNewPolicyArray[m_cCount] = m_expireCurrent;
	if ( !rgNewPolicyArray[m_cCount].CheckValid() ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );
	delete [] m_rgExpires;
	m_rgExpires = rgNewPolicyArray;
	m_cCount++;

Exit:
	if ( FAILED(hr) ) {
		delete [] rgNewPolicyArray;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::SetPolicyToMetabase ( IMSAdminBase * pMetabase)
{
	TraceFunctEnter ( "CNE::SetPolicyToMetabase" );

	_ASSERT ( pMetabase );

	HRESULT			hr = NOERROR;
	CMetabaseKey	mkeyExpiration ( pMetabase );
	char			szExpirationPath [ METADATA_MAX_NAME_LEN ];

	if ( !m_expireCurrent.CheckPolicyProperties ( ) ) {
		hr = RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

	GetMDExpirationPath ( szExpirationPath, m_dwServiceInstance );

	hr = mkeyExpiration.Open ( szExpirationPath, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( m_expireCurrent.m_dwExpireId != 0 );

	hr = m_expireCurrent.SendToMetabase ( &mkeyExpiration, m_bvChangedFields );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pMetabase->SaveData ( );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::SetPolicyToArray ( )
{
	TraceFunctEnter ( "CNE::SetPolicyToArray" );

	HRESULT	hr	= NOERROR;

	// Find the index of the current ID:
	DWORD	i;
	BOOL	fFound	= FALSE;
	DWORD	index;

	index = IndexFromID ( m_expireCurrent.m_dwExpireId );
	if ( index == (DWORD) -1 ) {
		// Couldn't find an id that matched, but the policy was successfully
		// set.  Just ignore:
		goto Exit;
	}

	_ASSERT ( index >= 0 && index < m_cCount );

	m_rgExpires[index] = m_expireCurrent;
	if ( !m_rgExpires[index].CheckValid() ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::RemovePolicyFromMetabase ( IMSAdminBase * pMetabase, DWORD index)
{
	TraceFunctEnter ( "CNE::RemovePolicyFromMetabase" );

	_ASSERT ( pMetabase );

	HRESULT				hr = NOERROR;
	CMetabaseKey		mkeyExpiration ( pMetabase );
	char				szExpirationPath [ METADATA_MAX_NAME_LEN ];
	char				szID [ METADATA_MAX_NAME_LEN ];

	GetMDExpirationPath ( szExpirationPath, m_dwServiceInstance );

	hr = mkeyExpiration.Open ( szExpirationPath, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( index >= 0 && index < m_cCount );

	wsprintfA ( szID, "expire%ud", m_rgExpires[index].m_dwExpireId );

	hr = mkeyExpiration.DestroyChild ( szID );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );

	hr = pMetabase->SaveData ( );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminExpiration::RemovePolicyFromArray ( DWORD index )
{
	TraceFunctEnter ( "CNE::RemovePolicyFromArray" );

	HRESULT				hr					= NOERROR;
	CExpirationPolicy *	rgNewExpireArray	= NULL;
	DWORD				i;

	// !!!magnush - Should I just do a memmove and slide the entries
	// down, and zero out the last entry?

	_ASSERT ( index >= 0 && index < m_cCount );

	// Adjust the Expiration policy array:
	if ( m_cCount > 1 ) {
		// Allocate a new expiration policy array:
		rgNewExpireArray = new CExpirationPolicy [ m_cCount - 1 ];

		// Copy the items from 0 .. (current index) to the new list:
		for ( i = 0; i < index; i++ ) {
			_ASSERT ( m_rgExpires[i].CheckValid() );

			rgNewExpireArray[i] = m_rgExpires[i];

			if ( !rgNewExpireArray[i].CheckValid() ) {
				hr = E_OUTOFMEMORY;
				goto Exit;
			}
		}

		// Copy the items from (current index + 1) .. m_cCount to the new list:
		for ( i = index + 1; i < m_cCount; i++ ) {
			_ASSERT ( m_rgExpires[i].CheckValid() );

			rgNewExpireArray[i - 1] = m_rgExpires[i];

			if ( !rgNewExpireArray[i - 1].CheckValid() ) {
				hr = E_OUTOFMEMORY;
				goto Exit;
			}
		}
	}

	_ASSERT ( SUCCEEDED(hr) );

	// Replace the old expiration list with the new one:
	delete [] m_rgExpires;
	m_rgExpires = rgNewExpireArray;
	m_cCount--;

Exit:
	if ( FAILED (hr) ) {
		delete [] rgNewExpireArray;
	}

	TraceFunctLeave ();
	return hr;
}

long CNntpAdminExpiration::IndexFromID ( long dwID )
{
	TraceFunctEnter ( "CNE::IndexFromID" );

	DWORD	i;

	if ( m_rgExpires == NULL ) {

		DebugTrace ( (LPARAM) this, "Expire array is NULL" );
		TraceFunctLeave ();

		return (DWORD) -1;
	}

	_ASSERT ( !IsBadReadPtr ( m_rgExpires, sizeof ( CExpirationPolicy ) * m_cCount ) );

	for ( i = 0; i < m_cCount; i++ ) {
		if ( m_rgExpires[i].m_dwExpireId == dwID ) {

			DebugTraceX ( (LPARAM) this, "Found ID: %d, index = ", dwID, i );
			TraceFunctLeave ();

			return i;
		}
	}

	DebugTraceX ( (LPARAM) this, "Failed to find ID: %d", dwID );
	TraceFunctLeave ();
	return (DWORD) -1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\expinfo.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	expinfo.h

Abstract:

	Defines the CExpirationPolicy class that maintains all properties about an 
	expiration policy.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _EXPINFO_INCLUDED_
#define _EXPINFO_INCLUDED_

// Dependencies:

#include "cmultisz.h"

typedef struct _NNTP_EXPIRE_INFO NNTP_EXPIRE_INFO, * LPNNTP_EXPIRE_INFO;

//
//	Changed flags:
//

#define CHNG_EXPIRE_SIZE			0x00000001
#define CHNG_EXPIRE_TIME			0x00000002
#define CHNG_EXPIRE_NEWSGROUPS		0x00000004
#define CHNG_EXPIRE_ID				0x00000008
#define CHNG_EXPIRE_POLICY_NAME		0x00000010

/////////////////////////////////////////////////////////////////////////////
// Defaults:

#define DEFAULT_EXPIRE_SIZE			( 500 )			// 500 megabytes
#define DEFAULT_EXPIRE_TIME			( 24 * 7 )		// One week
#define DEFAULT_EXPIRE_NEWSGROUPS	( _T ("\0") )	// Empty list
#define DEFAULT_EXPIRE_POLICY_NAME	( _T ("") )		// No name

DWORD GetExpireId ( const LPWSTR wszKey );
BOOL IsKeyValidExpire ( const LPWSTR wszKey );

//$-------------------------------------------------------------------
//
//	Class:
//
//		CExpirationPolicy
//
//	Description:
//
//		Maintains properties about a expire & communicates with the metabase.
//
//	Interface:
//
//		
//
//--------------------------------------------------------------------

class CExpirationPolicy
{
public:
	CExpirationPolicy	( );
	~CExpirationPolicy	( );

	void	Destroy ();

	const CExpirationPolicy & operator= ( const CExpirationPolicy & Expire );
	inline const CExpirationPolicy & operator= ( const NNTP_EXPIRE_INFO & Expire ) {
		FromExpireInfo ( &Expire );
		return *this;
	}

	BOOL	CheckValid ();

	HRESULT		ToExpireInfo		( LPNNTP_EXPIRE_INFO pExpireInfo );
	void		FromExpireInfo	( const NNTP_EXPIRE_INFO * pExpireInfo );

	HRESULT		Add 	( LPCWSTR strServer, DWORD dwInstance);
	HRESULT		Set 	( LPCWSTR strServer, DWORD dwInstance);
//	HRESULT		Get 	( LPCWSTR strServer, DWORD dwInstance);
	HRESULT		Remove 	( LPCWSTR strServer, DWORD dwInstance);

	// expire Properties:
public:
	DWORD		m_dwExpireId;

	CComBSTR	m_strPolicyName;
	DWORD		m_dwSize;
	DWORD		m_dwTime;
	CMultiSz	m_mszNewsgroups;

private:
	// Don't call the copy constructor:
	CExpirationPolicy ( const CExpirationPolicy & );
};

#endif // _EXPINFO_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\feedinfo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	feedinfo.cpp

Abstract:


Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

    Kangrong Yan ( KangYan )    Feb-28-1998
        Feed config change no longer calls NNTP RPC.  It directly writes to MB
        and synchronize with NNTPSVC's response in the metabase.

--*/

#include "stdafx.h"
#include "oleutil.h"
#include "nntpcmn.h"
#include "nntptype.h"
#include "nntpapi.h"
#include "feedpach.h"

#include "feeds.h"
#include "feedinfo.h"

#include <lmapibuf.h>

BOOL IsInboundFeed ( CFeed * pFeed )
{
    DWORD   dwType = pFeed->m_FeedType;

	return FEED_IS_PASSIVE ( dwType ) || FEED_IS_PULL ( dwType );
}

BOOL IsOutboundFeed ( CFeed * pFeed )
{
    DWORD   dwType = pFeed->m_FeedType;

	return FEED_IS_PUSH ( dwType );
}

NNTP_FEED_SERVER_TYPE FeedTypeToEnum ( FEED_TYPE ft )
{
	NNTP_FEED_SERVER_TYPE	type	= NNTP_FEED_TYPE_PEER;

	if ( FEED_IS_PEER ( ft ) ) {
		type = NNTP_FEED_TYPE_PEER;
	}
	else if ( FEED_IS_MASTER ( ft ) ) {
		type = NNTP_FEED_TYPE_MASTER;
	}
	else if ( FEED_IS_SLAVE ( ft ) ) {
		type = NNTP_FEED_TYPE_SLAVE;
	}
	else {
		_ASSERT ( FALSE );
	}

	return type;
}

void EnumToFeedType ( NNTP_FEED_SERVER_TYPE type, FEED_TYPE & ftMask )
{
	DWORD	dwType	= 0;

	//	Clear out the feed type from the mask

	ftMask &= ~FEED_REMOTE_MASK;

	switch ( type ) {
	case NNTP_FEED_TYPE_PEER:
		dwType = FEED_TYPE_PEER;
		break;

	case NNTP_FEED_TYPE_MASTER:
		dwType = FEED_TYPE_MASTER;
		break;

	case NNTP_FEED_TYPE_SLAVE:
		dwType = FEED_TYPE_SLAVE;
		break;
	}

	//	Move the feed type into the mask:
	ftMask |= dwType;
}

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Feeds.1")
#define THIS_FILE_IID				IID_INntpAdminFeeds

CFeed::CFeed ( )
	// CComBSTR's are automatically initialized to NULL
{
    //
    //  Initialize all properties to 0
    //

    m_dwFeedId                  = 0;
    m_dwPairFeedId              = 0;
    m_fAllowControlMessages     = FALSE;
    m_dwAuthenticationType      = AUTH_PROTOCOL_NONE;
    m_dwConcurrentSessions      = 0;
    m_fCreateAutomatically      = FALSE;
    m_dwFeedInterval            = 0;
    m_datePullNews              = 0;
    m_dwMaxConnectionAttempts   = 0;
    m_dwSecurityType            = 0;
    m_dwOutgoingPort            = 0;

	m_FeedType  = FEED_TYPE_PULL | FEED_TYPE_PEER;
    m_fEnabled  = TRUE;
}

CFeed::~CFeed ( )
{
	AssertValid ();

	// CComBSTR's are automatically freed.
}

void CFeed::Destroy ()
{
	AssertValid ();

	// Need to empty all strings:

	m_mszDistributions.Empty();
	m_mszNewsgroups.Empty();
	m_strRemoteServer.Empty();
	m_strUucpName.Empty();
	m_strAccountName.Empty();
	m_strPassword.Empty();
	m_strTempDirectory.Empty();
}

HRESULT CFeed::CreateFeed ( CFeed ** ppNewFeed )
{
	CFeed *	pFeedNew = new CFeed;

	if ( pFeedNew ) {
		*ppNewFeed	= pFeedNew;
		return NOERROR;
	}
	else {
		*ppNewFeed = NULL;
		return E_OUTOFMEMORY;
	}
}

HRESULT CFeed::CreateFeedFromFeedInfo ( LPNNTP_FEED_INFO pFeedInfo, CFeed ** ppNewFeed )
{
	HRESULT		hr	= NOERROR;
	CFeed * 	pFeedNew;

	*ppNewFeed = NULL;

	hr = CreateFeed ( &pFeedNew );
	BAIL_ON_FAILURE ( hr );

	hr = pFeedNew->FromFeedInfo ( pFeedInfo );
	BAIL_ON_FAILURE ( hr );

	*ppNewFeed = pFeedNew;

Exit:
	return hr;
}

HRESULT CFeed::CreateFeedFromINntpOneWayFeed ( INntpOneWayFeed * pFeed, CFeed ** ppNewFeed )
{
	HRESULT		hr	= NOERROR;
	CFeed * 	pFeedNew = NULL;

	*ppNewFeed = NULL;

	hr = CreateFeed ( &pFeedNew );
	BAIL_ON_FAILURE ( hr );

	hr = pFeedNew->FromINntpOneWayFeed ( pFeed );
	BAIL_ON_FAILURE ( hr );

	*ppNewFeed = pFeedNew;

	return hr;

Exit:
	if (pFeedNew)
		delete pFeedNew;
	return hr;
}

const CFeed & CFeed::operator= ( const CFeed & feed )
{
	AssertValid ();
	feed.AssertValid ();

	// Check for assignment to self:

	if ( &feed == this ) {
		return *this;
	}

	// Empty the old feed values:

	this->Destroy ();

	// Copy all member variables:

	m_dwFeedId					= feed.m_dwFeedId;
	m_dwPairFeedId				= feed.m_dwPairFeedId;
	m_FeedType					= feed.m_FeedType;
	m_fAllowControlMessages		= feed.m_fAllowControlMessages;
	m_dwAuthenticationType		= feed.m_dwAuthenticationType;
	m_dwConcurrentSessions		= feed.m_dwConcurrentSessions;
	m_fCreateAutomatically		= feed.m_fCreateAutomatically;
	m_fEnabled					= feed.m_fEnabled;
	m_mszDistributions			= feed.m_mszDistributions;
	m_dwFeedInterval			= feed.m_dwFeedInterval;
	m_datePullNews				= feed.m_datePullNews;
	m_dwMaxConnectionAttempts	= feed.m_dwMaxConnectionAttempts;
	m_mszNewsgroups				= feed.m_mszNewsgroups;
	m_dwSecurityType			= feed.m_dwSecurityType;
	m_dwOutgoingPort			= feed.m_dwOutgoingPort;
	m_strRemoteServer			= feed.m_strRemoteServer;
	m_strUucpName				= feed.m_strUucpName;
	m_strAccountName			= feed.m_strAccountName;
	m_strPassword				= feed.m_strPassword;
	m_strTempDirectory			= feed.m_strTempDirectory;

	m_strRemoteServer			= feed.m_strRemoteServer;
	m_EnumType					= feed.m_EnumType;

	return *this;
}

BOOL CFeed::CheckValid ( ) const
{
	AssertValid ();

	// Check Strings:

	if (
		!m_mszDistributions     ||
		!m_mszNewsgroups        ||
		!m_strUucpName          ||
		!m_strAccountName       ||
		!m_strPassword			||
		!m_strRemoteServer
		) {

		return FALSE;
	}

	return TRUE;
}

HRESULT	CFeed::get_FeedAction ( NNTP_FEED_ACTION * feedaction )
{
	AssertValid ();

	NNTP_FEED_ACTION	result;

	switch ( m_FeedType & FEED_ACTION_MASK ) {
	case FEED_TYPE_PULL:
		result = NNTP_FEED_ACTION_PULL;
		break;

	case FEED_TYPE_PUSH:
		result = NNTP_FEED_ACTION_PUSH;
		break;

	case FEED_TYPE_PASSIVE:
		result = NNTP_FEED_ACTION_ACCEPT;
		break;

	default:
		_ASSERT ( FALSE );
		result = NNTP_FEED_ACTION_PULL;
	}

	*feedaction = result;
	return NOERROR;
}

HRESULT	CFeed::put_FeedAction ( NNTP_FEED_ACTION feedaction )
{
	AssertValid ();

	FEED_TYPE	ftNew;

	ftNew = m_FeedType & (~FEED_ACTION_MASK);

	switch ( feedaction ) {
	case NNTP_FEED_ACTION_PULL:
		ftNew |= FEED_TYPE_PULL;
		break;

	case NNTP_FEED_ACTION_PUSH:
		ftNew |= FEED_TYPE_PUSH;
		break;

	case NNTP_FEED_ACTION_ACCEPT:
		ftNew |= FEED_TYPE_PASSIVE;
		break;

	default:
		_ASSERT ( FALSE );
		return TranslateFeedError ( ERROR_INVALID_PARAMETER, FEED_PARM_FEEDTYPE );
	}

	m_FeedType = ftNew;
	return NOERROR;
}

HRESULT CFeed::FromFeedInfo ( const NNTP_FEED_INFO * pFeedInfo )
{
	AssertValid ();

    FILETIME    ftPullNewsLocal;
	SYSTEMTIME	stPullNews;

	this->Destroy ();

	m_dwFeedId					= pFeedInfo->FeedId;
	m_dwPairFeedId				= pFeedInfo->FeedPairId;
	m_FeedType					= pFeedInfo->FeedType;
	m_fAllowControlMessages		= pFeedInfo->fAllowControlMessages;
	m_dwAuthenticationType		= pFeedInfo->AuthenticationSecurityType;
	m_dwConcurrentSessions		= pFeedInfo->ConcurrentSessions;
	m_fCreateAutomatically		= pFeedInfo->AutoCreate;
	m_fEnabled					= pFeedInfo->Enabled;
	m_mszDistributions			= pFeedInfo->Distribution ? pFeedInfo->Distribution : _T("\0");

    if ( !FEED_IS_PULL (m_FeedType) ||
            (
                pFeedInfo->PullRequestTime.dwLowDateTime == 0 &&
                pFeedInfo->PullRequestTime.dwHighDateTime == 0
            )
       ) {
        //
        //  Not a pull feed - so default to something reasonable here:
        //
        GetLocalTime ( &stPullNews );
    }
    else {
        FileTimeToLocalFileTime ( &pFeedInfo->PullRequestTime, &ftPullNewsLocal );
	    FileTimeToSystemTime ( &ftPullNewsLocal, &stPullNews );
    }
	SystemTimeToVariantTime		( &stPullNews, &m_datePullNews );

	m_dwFeedInterval			= pFeedInfo->FeedInterval;
	m_dwMaxConnectionAttempts	= pFeedInfo->MaxConnectAttempts;
	m_mszNewsgroups				= pFeedInfo->Newsgroups ? pFeedInfo->Newsgroups : _T("\0");
	m_dwSecurityType			= pFeedInfo->SessionSecurityType;
	m_dwOutgoingPort			= pFeedInfo->OutgoingPort;
	m_strUucpName				= pFeedInfo->UucpName ? pFeedInfo->UucpName : _T("");
	m_strAccountName			= pFeedInfo->NntpAccountName ? pFeedInfo->NntpAccountName : _T("");
	m_strPassword				= pFeedInfo->NntpPassword ? pFeedInfo->NntpPassword : _T("");
	m_strTempDirectory			= pFeedInfo->FeedTempDirectory;

	if ( pFeedInfo->Distribution ) {
		_ASSERT ( m_mszDistributions.SizeInBytes () == pFeedInfo->cbDistribution );
	}
	_ASSERT ( m_mszNewsgroups.SizeInBytes () == pFeedInfo->cbNewsgroups );

	m_strRemoteServer			= pFeedInfo->ServerName ? pFeedInfo->ServerName : _T("");
	m_EnumType					= FeedTypeToEnum ( m_FeedType );

	// Check Strings:
	if ( !CheckValid () ) {
		return E_OUTOFMEMORY;
	}
	return NOERROR;
}

HRESULT CFeed::ToFeedInfo ( LPNNTP_FEED_INFO 		pFeedInfo )
{
	TraceFunctEnter ( "CFeed::ToFeedInfo" );

	AssertValid ();
	_ASSERT ( IS_VALID_OUT_PARAM ( pFeedInfo ) );

	HRESULT	hr	= NOERROR;

	SYSTEMTIME	stPullNews;
    FILETIME    ftPullNewsLocal;

	EnumToFeedType ( m_EnumType, m_FeedType );

	ZeroMemory ( pFeedInfo, sizeof (*pFeedInfo) );

	pFeedInfo->ServerName					= m_strRemoteServer;
	pFeedInfo->FeedId						= m_dwFeedId;
	pFeedInfo->FeedPairId					= m_dwPairFeedId;
	pFeedInfo->FeedType						= m_FeedType;
	pFeedInfo->fAllowControlMessages		= m_fAllowControlMessages;
	pFeedInfo->AuthenticationSecurityType	= m_dwAuthenticationType;
	pFeedInfo->ConcurrentSessions			= m_dwConcurrentSessions;
	pFeedInfo->AutoCreate					= m_fCreateAutomatically;
	pFeedInfo->Enabled						= m_fEnabled;

    //
    //  Convert time formats:
    //

	VariantTimeToSystemTime		( m_datePullNews,	&stPullNews );

	SystemTimeToFileTime		( &stPullNews,	    &ftPullNewsLocal );

    LocalFileTimeToFileTime     ( &ftPullNewsLocal,  &pFeedInfo->PullRequestTime);
    ZeroMemory ( &pFeedInfo->StartTime, sizeof ( FILETIME ) );

	pFeedInfo->FeedInterval				= m_dwFeedInterval;
	pFeedInfo->MaxConnectAttempts		= m_dwMaxConnectionAttempts;
	pFeedInfo->SessionSecurityType		= m_dwSecurityType;
	pFeedInfo->OutgoingPort				= m_dwOutgoingPort;
	pFeedInfo->ServerName				= m_strRemoteServer;
	pFeedInfo->UucpName					= m_strUucpName;
	pFeedInfo->cbUucpName				= STRING_BYTE_LENGTH ( m_strUucpName );
	pFeedInfo->NntpAccountName			= m_strAccountName;
	pFeedInfo->cbAccountName			= STRING_BYTE_LENGTH ( m_strAccountName );
	pFeedInfo->NntpPassword				= m_strPassword;
	pFeedInfo->cbPassword				= STRING_BYTE_LENGTH ( m_strPassword );
	pFeedInfo->FeedTempDirectory		= m_strTempDirectory;
	pFeedInfo->cbFeedTempDirectory		= STRING_BYTE_LENGTH ( m_strTempDirectory );

	pFeedInfo->Distribution				= (LPWSTR) (LPCWSTR) m_mszDistributions;
	pFeedInfo->cbDistribution			= m_mszDistributions.SizeInBytes();
	pFeedInfo->Newsgroups				= (LPWSTR) (LPCWSTR) m_mszNewsgroups;
	pFeedInfo->cbNewsgroups				= m_mszNewsgroups.SizeInBytes();

	TraceFunctLeave ();
	return hr;
}

HRESULT	CFeed::FromINntpOneWayFeed ( INntpOneWayFeed * pFeed )
{
	AssertValid ();

	CNntpOneWayFeed *	pPrivateFeed;

	pPrivateFeed = (CNntpOneWayFeed *) pFeed;

	*this = pPrivateFeed->m_feed;

	if ( !CheckValid () ) {
		return E_OUTOFMEMORY;
	}
	return NOERROR;
}

HRESULT CFeed::ToINntpOneWayFeed ( INntpOneWayFeed ** ppFeed )
{
	AssertValid ();

	HRESULT							hr		= NOERROR;
	CComObject<CNntpOneWayFeed> *	pFeed	= NULL;

	hr = CComObject<CNntpOneWayFeed>::CreateInstance ( &pFeed );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	pFeed->m_feed = *this;
	if ( !pFeed->m_feed.CheckValid() ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	hr = pFeed->QueryInterface ( IID_INntpOneWayFeed, (void **) ppFeed );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	if ( FAILED(hr) ) {
		delete pFeed;
	}
	return hr;
}

HRESULT CFeed::CheckConfirm(    IN DWORD   dwFeedId,
                                IN DWORD   dwInstanceId,
                                IN CMetabaseKey* pMK,
                                OUT PDWORD  pdwErr,
                                OUT PDWORD  pdwErrMask )
{
    TraceFunctEnter( "CFeed::CheckConfirm" );
    _ASSERT( pMK );
    _ASSERT( dwFeedId > 0 );
    
    HRESULT         hr;
    const DWORD     dwMaxAttempts = 10;
    const DWORD     dwWaitMilliSeconds = 500;
    DWORD           dwHandShake;

    for ( int i = 0; i < dwMaxAttempts; i++ ) {
        hr = OpenKey( dwFeedId, pMK, METADATA_PERMISSION_READ, dwInstanceId );
        if ( FAILED( hr ) ) {
            if ( HRESULTTOWIN32( hr )  == ERROR_PATH_BUSY ) {
                Sleep( dwWaitMilliSeconds );
                continue;
            }
            else {
                ErrorTrace(0, "Open key fail with 0x%x", hr );
                return hr;
            }
        }

        //
        // getting the handshake    
        //
        hr = pMK->GetDword( MD_FEED_HANDSHAKE, &dwHandShake );
        if ( FAILED( hr ) ) {   // shouldn't happen , it's an error
            pMK->Close();
            ErrorTrace(0, "Get handshake fail with 0x%x", hr );
            return hr;
        }

        if ( dwHandShake != FEED_UPDATE_CONFIRM ) {
            pMK->Close();
            Sleep( dwWaitMilliSeconds );
            continue;
        }

        //
        // Now get error / masks
        //
        hr = pMK->GetDword( MD_FEED_ADMIN_ERROR, pdwErr );
        if ( FAILED(  hr  )  ) {    // the server is possibly not
                                    // writing the confirm /error
                                    // in good sequence, lets give
                                    // it more chances
            pMK->Close();
            Sleep( dwWaitMilliSeconds );
            continue;
        }

        hr = pMK->GetDword( MD_FEED_ERR_PARM_MASK, pdwErrMask );
        if ( FAILED( hr ) ) {       // same comments as above
            pMK->Close();
            Sleep( dwWaitMilliSeconds );
            continue;
        }

        //
        // Now we are done
        //
        pMK->Close();
        break;
    } 

    if ( i == dwMaxAttempts ) return E_FAIL;
    else return S_OK;
}

HRESULT CFeed::Add ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK )
{
	TraceFunctEnter ( "CFeed::Add" );

	AssertValid ();

	HRESULT			hr 			= NOERROR;
	DWORD			dwError		= NOERROR;
	DWORD			dwParmErr	= 0;
	NNTP_FEED_INFO	feedinfo;
    DWORD           dwFeedId    = 0;

	FillMemory ( &feedinfo, sizeof (feedinfo), 0 );

	hr = ToFeedInfo ( &feedinfo );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	feedinfo.FeedId = 0;

    //
    // KangYan: RPC goes away.  We use metabase writes
    //
    hr = AddFeedToMB( &feedinfo, pMK, &dwParmErr, dwInstance, &dwFeedId );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Add to MB fail with 0x%x", hr );
        goto Exit;
    }

    hr = CheckConfirm(  dwFeedId, dwInstance, pMK, &dwError, &dwParmErr );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Check confirm fail with 0x%x", hr );
        goto Exit;
    }

	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to add feed: %x (%x)", dwError, dwParmErr );
		hr = TranslateFeedError ( dwError, dwParmErr );
		goto Exit;
	}

	this->m_dwFeedId = dwFeedId;

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CFeed::Set ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK )
{
	TraceFunctEnter ( "CFeed::Set" );

	AssertValid ();

	HRESULT			hr 			= NOERROR;
	DWORD			dwError		= NOERROR;
	DWORD			dwParmErr	= 0;
	NNTP_FEED_INFO	feedinfo;

	FillMemory ( &feedinfo, sizeof (feedinfo), 0 );

	hr = ToFeedInfo ( &feedinfo );
	if ( FAILED(hr) ) {
		goto Exit;
	}

    //
    // KangYan: RPC goes away. We use metabase writes
    //
    hr = SetFeedToMB(   &feedinfo,
                        pMK,
                        &dwParmErr,
                        dwInstance );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Set MB fail with 0x%x", hr );
        goto Exit;
    }

    hr = CheckConfirm( feedinfo.FeedId, dwInstance, pMK, &dwError, &dwParmErr );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Check confirm fail with 0x%x", hr );
        goto Exit;
    } 

	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to set feed[%d]: %x (%x)", m_dwFeedId, dwError, dwParmErr );
		hr = TranslateFeedError ( dwError, dwParmErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CFeed::Remove ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK )
{
	TraceFunctEnter ( "CFeed::Remove" );

	AssertValid ();

	HRESULT				hr 			= NOERROR;
	DWORD				dwError		= NOERROR;

    hr = DeleteFeed( m_dwFeedId, pMK, dwInstance );
    if ( FAILED( hr ) ) {
        dwError = HRESULTTOWIN32( hr );
    	ErrorTraceX ( (LPARAM) this, "Failed to remove feed[%d]: %x", m_dwFeedId, hr );
		hr = TranslateFeedError ( dwError );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CFeed::SetPairId ( LPCWSTR strServer, DWORD dwInstance, DWORD dwPairId, CMetabaseKey* pMK )
{
	TraceFunctEnter ( "CFeed::SetPairID" );

	AssertValid ();

	HRESULT			hr 			= NOERROR;
	DWORD			dwError		= NOERROR;
	DWORD			dwParmErr	= 0;
	NNTP_FEED_INFO	feedinfo;

	//
	//	Assume that this feed was just Added/Set to the server.
	//

	_ASSERT ( dwPairId != m_dwFeedId );
	m_dwPairFeedId	= dwPairId;

	FillMemory ( &feedinfo, sizeof (feedinfo), 0 );

	hr = ToFeedInfo ( &feedinfo );
	if ( FAILED(hr) ) {
		goto Exit;
	}

    //
    // KangYan: RPC goes away. We use metabase writes
    //
    hr = SetFeedToMB(   &feedinfo,
                        pMK,
                        &dwParmErr,
                        dwInstance );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Set MB fail with 0x%x", hr );
        goto Exit;
    }

    hr = CheckConfirm( feedinfo.FeedId, dwInstance, pMK, &dwError, &dwParmErr );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Check confirm fail with 0x%x", hr );
        goto Exit;
    } 

	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to set feed[%d]: %x (%x)", m_dwFeedId, dwError, dwParmErr );
		hr = TranslateFeedError ( dwError, dwParmErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

DWORD GetBitPosition ( DWORD dwValue )
{
	_ASSERT ( dwValue != 0 );
	// _ASSERT ( Only one bit should be on );

	DWORD	dwResult;
	DWORD	dwTemp;

	for (	dwTemp = dwValue, dwResult = (DWORD) -1; 
			dwTemp != 0; 
			dwTemp = dwTemp >> 1, dwResult++ ) {
		// Empty for

		// Make sure there is at most one bit on:
		_ASSERT ( !(dwTemp & 1) || dwTemp == 1 );
	}

	return dwResult;
}

HRESULT	CFeed::TranslateFeedError ( DWORD dwErrorCode, DWORD dwParmErr )
{
	HRESULT		hr;

	_ASSERT ( dwErrorCode != NOERROR );

	if (    dwErrorCode != ERROR_INVALID_PARAMETER ||
            dwParmErr == 0 ||
            dwParmErr == (DWORD) -1 
            ) {
		hr = RETURNCODETOHRESULT ( dwErrorCode );
	}
	else {
		DWORD	dwBitPosition;
		DWORD	nID;

		dwBitPosition = GetBitPosition ( dwParmErr );
		nID = IDS_FEED_PARM_ERR_BASE + dwBitPosition;

		hr = NntpCreateException ( nID );
	}

	return hr;
}

#ifdef DEBUG

void CFeed::AssertValid ( ) const
{
	_ASSERT ( !IsBadWritePtr ( (void *) this, sizeof (*this) ) );

	//
	//	!!!magnush - Add more debug code here
	//
}

#endif

/////////////////////////////////////////////////////////////////////
//
//  CFeedPair Implementation
//

CFeedPair::CFeedPair () :
	m_type ( NNTP_FEED_TYPE_PEER ),
    m_pInbound ( NULL ),
    m_pOutbound ( NULL ),
    m_pNext     ( NULL )
{
}

CFeedPair::~CFeedPair ()
{
	AssertValid ();

    Destroy ();
}

void CFeedPair::Destroy ()
{
	AssertValid ();

    // !!!magnush - Fix reference counting problem here
    delete m_pInbound;
    delete m_pOutbound;

    m_pInbound = NULL; 
    m_pOutbound = NULL;
}

HRESULT CFeedPair::CreateFeedPair ( 
	CFeedPair ** 			ppNewFeedPair, 
	BSTR 					strRemoteServer,
	NNTP_FEED_SERVER_TYPE	type
	)
{
	_ASSERT ( IS_VALID_STRING (strRemoteServer) );

    HRESULT     hr  = NOERROR;
    CFeedPair *	pNewFeedPair;

	*ppNewFeedPair = NULL;

	// Allocate a new feed pair:
    pNewFeedPair = new CFeedPair;
    if ( pNewFeedPair == NULL ) {
    	BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
    }

	// Copy properties:
	pNewFeedPair->m_strRemoteServer = strRemoteServer;
	pNewFeedPair->m_type = type;

	// Check for failed copy:
	if ( pNewFeedPair->m_strRemoteServer == NULL ) {
    	BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
	}

	// Set the out parameter to the new feed:
	*ppNewFeedPair = pNewFeedPair;

Exit:
	if ( FAILED(hr) ) {
		delete pNewFeedPair;
	}
	
    return hr;
}

HRESULT CFeedPair::AddFeed ( CFeed * pFeed )
{
	AssertValid ();

    HRESULT     hr  = NOERROR;

	_ASSERT ( IS_VALID_STRING ( m_strRemoteServer ) );
	_ASSERT ( IS_VALID_STRING ( pFeed->m_strRemoteServer ) );

	//
	//	Check error conditions:
	//		1. Different remote server name
	//		2. Different feed type
	//		3. Two inbound feeds
	//		4. Two outbound feeds
	//		5. Bad feed type
	//

	if ( lstrcmpi ( m_strRemoteServer, pFeed->m_strRemoteServer ) != 0 ) {
		BAIL_WITH_FAILURE ( hr, E_FAIL );
	}

	if ( m_type != pFeed->m_EnumType ) {
		BAIL_WITH_FAILURE ( hr, E_FAIL );
	}

	if ( IsInboundFeed ( pFeed ) && m_pInbound != NULL ) {
		BAIL_WITH_FAILURE ( hr, E_FAIL );
	}

	if ( IsOutboundFeed ( pFeed ) && m_pOutbound != NULL ) {
		BAIL_WITH_FAILURE ( hr, E_FAIL );
	}

	if ( !IsInboundFeed ( pFeed ) && !IsOutboundFeed ( pFeed ) ) {
        _ASSERT (FALSE);
		BAIL_WITH_FAILURE ( hr, E_FAIL );
	}

	//
	//	Everything is okay so take the feed into this pair:
	//

    if ( IsInboundFeed ( pFeed ) ) {
		m_pInbound = pFeed;
    }
    else {
    	// It's an outbound feed:
        m_pOutbound = pFeed;
    }

Exit:
    return hr;
}

HRESULT CFeedPair::FromINntpFeed ( INntpFeed * pFeed )
{
	AssertValid ();

    HRESULT                     hr              = NOERROR;
    CComPtr<INntpOneWayFeed>    pInbound;
    CComPtr<INntpOneWayFeed>    pOutbound;
    CFeed *                     pFeedInbound   = NULL;
    CFeed *                     pFeedOutbound   = NULL;

    m_strRemoteServer.Empty();
    pFeed->get_RemoteServer ( &m_strRemoteServer );
    pFeed->get_FeedType ( &m_type );

    pFeed->get_InboundFeed ( &pInbound );
    pFeed->get_OutboundFeed ( &pOutbound );

    if ( pInbound ) {
        hr = CFeed::CreateFeedFromINntpOneWayFeed ( pInbound, &pFeedInbound );
        BAIL_ON_FAILURE(hr);

        pFeedInbound->m_strRemoteServer = m_strRemoteServer;
    }
    if ( pOutbound ) {
        hr = CFeed::CreateFeedFromINntpOneWayFeed ( pOutbound, &pFeedOutbound );
        BAIL_ON_FAILURE(hr);

        pFeedOutbound->m_strRemoteServer = m_strRemoteServer;
    }

    delete m_pInbound;
    delete m_pOutbound;
    m_pInbound = pFeedInbound;
    m_pOutbound = pFeedOutbound;

Exit:
    if ( FAILED(hr) ) {
        delete pFeedInbound;
        delete pFeedOutbound;
    }

    return hr;
}

HRESULT CFeedPair::ToINntpFeed ( INntpFeed ** ppFeed )
{
	AssertValid ();

    CComObject<CNntpFeed> * pFeed   = NULL;

	HRESULT		hr	= NOERROR;

    hr = CComObject<CNntpFeed>::CreateInstance ( &pFeed );
    if ( FAILED(hr) ) { 
        goto Exit;
    }

    hr = pFeed->FromFeedPair ( this );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = pFeed->QueryInterface ( IID_INntpFeed, (void **) ppFeed );
    if ( FAILED(hr) ) {
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT CFeedPair::AddIndividualFeed (  LPCWSTR strServer, 
                                        DWORD dwInstance, 
                                        CFeed * pFeed ,
                                        CMetabaseKey* pMK )
{
	AssertValid ();

	pFeed->m_dwPairFeedId		= 0;
	pFeed->m_EnumType			= m_type;
	pFeed->m_strRemoteServer	= m_strRemoteServer;

	return pFeed->Add ( strServer, dwInstance, pMK );
}

HRESULT CFeedPair::SetIndividualFeed ( LPCWSTR strServer, DWORD dwInstance, CFeed * pFeed, CMetabaseKey* pMK )
{
	AssertValid ();

	pFeed->m_dwPairFeedId		= 0;
	pFeed->m_EnumType			= m_type;
	pFeed->m_strRemoteServer	= m_strRemoteServer;

	return pFeed->Set ( strServer, dwInstance, pMK );
}

HRESULT	CFeedPair::SetPairIds ( LPCWSTR strServer, DWORD dwInstance, 
	CFeed * pFeed1, CFeed * pFeed2, CMetabaseKey* pMK )
{
	AssertValid ();

	HRESULT		hr	= NOERROR;
	DWORD		dwPairId1;
	DWORD		dwPairId2;

	dwPairId1 = pFeed2 ? pFeed2->m_dwFeedId : 0;
	dwPairId2 = pFeed1 ? pFeed1->m_dwFeedId : 0;

	if ( pFeed1 ) {
		hr = pFeed1->SetPairId ( strServer, dwInstance, dwPairId1, pMK );
		BAIL_ON_FAILURE(hr);
	}

	if ( pFeed2 ) {
		hr = pFeed2->SetPairId ( strServer, dwInstance, dwPairId2, pMK );
		BAIL_ON_FAILURE(hr);
	}

Exit:
	return hr;
}

HRESULT CFeedPair::AddToServer ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK )
{
	AssertValid ();

    HRESULT     hr = E_UNEXPECTED;

    if ( m_pInbound ) {
    	hr = AddIndividualFeed ( strServer, dwInstance, m_pInbound, pMK );
    	BAIL_ON_FAILURE(hr);
    }

    if ( m_pOutbound ) {
    	hr = AddIndividualFeed ( strServer, dwInstance, m_pOutbound, pMK );
    	BAIL_ON_FAILURE(hr);
    }

	if ( m_pInbound && m_pOutbound ) {
		HRESULT		hr2;

		hr2 = SetPairIds ( strServer, dwInstance, m_pInbound, m_pOutbound, pMK );
		_ASSERT ( SUCCEEDED(hr2) );
	}

Exit:
    if ( FAILED(hr) ) {
		//
		//	Undo the add:
		//

		IErrorInfo *pErrorInfo = NULL;
		if (FAILED(GetErrorInfo(NULL, &pErrorInfo))) {
		    pErrorInfo = NULL;
		}

        if ( m_pInbound ) {
			m_pInbound->Remove ( strServer, dwInstance, pMK );
		}
		if ( m_pOutbound ) {
			m_pOutbound->Remove ( strServer, dwInstance, pMK );
		}

		if (pErrorInfo != NULL) {
		    SetErrorInfo(NULL, pErrorInfo);
		}
    }
    return hr;
}

HRESULT CFeedPair::UndoFeedAction ( 
	LPCWSTR strServer, 
	DWORD	dwInstance,
	CFeed *	pNewFeed,
	CFeed *	pOldFeed,
    CMetabaseKey* pMK
	)
{
	AssertValid ();

	HRESULT		hr	= NOERROR;

	if ( pNewFeed != NULL ) {
		if ( pOldFeed ) {
			hr = pOldFeed->Set ( strServer, dwInstance, pMK );
		}
		else {
			hr = pNewFeed->Remove ( strServer, dwInstance, pMK );
		}
	}

	return hr;
}

HRESULT CFeedPair::SetToServer ( LPCWSTR strServer, DWORD dwInstance, INntpFeed * pFeed, CMetabaseKey* pMK )
{
	AssertValid ();

    HRESULT                     hr = NOERROR;
    CComPtr<INntpOneWayFeed>    pInbound;
    CComPtr<INntpOneWayFeed>    pOutbound;
    CFeed *						pNewInbound		= NULL;
    CFeed *						pNewOutbound	= NULL;
    CComBSTR					strOldRemoteServer;

	strOldRemoteServer	= m_strRemoteServer;

	pFeed->get_RemoteServer ( &m_strRemoteServer );
    pFeed->get_InboundFeed ( &pInbound );
    pFeed->get_OutboundFeed ( &pOutbound );

	//
	//	Add the new feeds:
	//

	if ( !m_pInbound && pInbound ) {
        hr = CFeed::CreateFeedFromINntpOneWayFeed ( pInbound, &pNewInbound );
        BAIL_ON_FAILURE(hr);

		hr = AddIndividualFeed ( strServer, dwInstance, pNewInbound, pMK );
        BAIL_ON_FAILURE(hr);
	}
	if ( !m_pOutbound && pOutbound ) {
        hr = CFeed::CreateFeedFromINntpOneWayFeed ( pOutbound, &pNewOutbound );
        BAIL_ON_FAILURE(hr);

		hr = AddIndividualFeed ( strServer, dwInstance, pNewOutbound, pMK );
        BAIL_ON_FAILURE(hr);
	}

	//
	//	Set the existing feeds:
	//

    if ( m_pInbound && pInbound ) {
        // The Inbound feed exists already, so call set on it:
		hr = CFeed::CreateFeed ( &pNewInbound );
        BAIL_ON_FAILURE(hr);

		*pNewInbound = *m_pInbound;

		hr = pNewInbound->FromINntpOneWayFeed ( pInbound );
        BAIL_ON_FAILURE(hr);

		hr = SetIndividualFeed ( strServer, dwInstance, pNewInbound, pMK );
        BAIL_ON_FAILURE(hr);
    }

    if ( m_pOutbound && pOutbound ) {
        // The Outbound feed exists already, so call set on it:
		hr = CFeed::CreateFeed ( &pNewOutbound );
        BAIL_ON_FAILURE(hr);

		*pNewOutbound = *m_pOutbound;

		hr = pNewOutbound->FromINntpOneWayFeed ( pOutbound );
        BAIL_ON_FAILURE(hr);

		hr = SetIndividualFeed ( strServer, dwInstance, pNewOutbound, pMK );
        BAIL_ON_FAILURE(hr);
    }
    
	//
	//	Remove the deleted feeds:
	//

	if ( m_pInbound && !pInbound ) {
		HRESULT		hr2;

		hr2 = m_pInbound->Remove ( strServer, dwInstance, pMK );
		_ASSERT ( SUCCEEDED(hr2) );
	}

	if ( m_pOutbound && !pOutbound ) {
		HRESULT		hr2;
		
		hr2 = m_pOutbound->Remove ( strServer, dwInstance, pMK );
		_ASSERT ( SUCCEEDED(hr2) );
	}

	SetPairIds ( strServer, dwInstance, pNewInbound, pNewOutbound, pMK );

	_ASSERT ( SUCCEEDED(hr) );

	delete m_pInbound;
	delete m_pOutbound;
	m_pInbound	= pNewInbound;
	m_pOutbound	= pNewOutbound;

Exit:
	if ( FAILED(hr) ) {
		//
		// Attempt to back out the changes:
		//

		UndoFeedAction ( strServer, dwInstance, pNewInbound, m_pInbound, pMK );

		UndoFeedAction ( strServer, dwInstance, pNewOutbound, m_pOutbound, pMK );
		if ( pNewOutbound ) {
			if ( m_pOutbound ) {
				m_pOutbound->Set ( strServer, dwInstance, pMK );
			}
			else {
				pNewOutbound->Remove ( strServer, dwInstance, pMK );
			}
		}

		delete pNewInbound;
		delete pNewOutbound;

		m_strRemoteServer = strOldRemoteServer;
	}
    return hr;
}

HRESULT CFeedPair::RemoveFromServer ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK )
{
	AssertValid ();

    HRESULT     hr  = NOERROR;

    if ( m_pInbound ) {
        hr = m_pInbound->Remove ( strServer, dwInstance, pMK );
    }
    if ( m_pOutbound ) {
        hr = m_pOutbound->Remove ( strServer, dwInstance, pMK );
    }

    return hr;
}

BOOL CFeedPair::ContainsFeedId ( DWORD dwFeedId )
{
	AssertValid ();

    if ( m_pInbound && m_pInbound->m_dwFeedId == dwFeedId ) {
        return TRUE;
    }
    if ( m_pOutbound && m_pOutbound->m_dwFeedId == dwFeedId ) {
        return TRUE;
    }

    return FALSE;
}

#ifdef DEBUG

void CFeedPair::AssertValid ( ) const
{
	_ASSERT ( !IsBadWritePtr ( (void *) this, sizeof (*this) ) );

	if ( m_pInbound ) {
		m_pInbound->AssertValid ();
	}

	if ( m_pOutbound ) {
		m_pOutbound->AssertValid ();
	}
}

#endif

/////////////////////////////////////////////////////////////////////
//
//  CFeedPairList Implementation
//

CFeedPairList::CFeedPairList () :
    m_cCount    ( 0 ),
    m_pHead     ( NULL ),
    m_pTail     ( NULL )
{
}

CFeedPairList::~CFeedPairList ()
{
	AssertValid ();
	
    Empty();
}

DWORD CFeedPairList::GetCount ( ) const
{
	AssertValid ();

    return m_cCount;
}

void CFeedPairList::Empty ( )
{
	AssertValid ();

    CFeedPair * pPair;
    CFeedPair * pKill;

    pPair = m_pHead;
    while ( pPair ) {
        pKill = pPair;
        pPair = pPair->m_pNext;
        delete pKill;
    }

    m_cCount    = 0;
    m_pHead     = NULL;
    m_pTail     = NULL;
}

CFeedPair * CFeedPairList::Item ( DWORD index )
{
	AssertValid ();

    CFeedPair * pResult = NULL;
    DWORD       i;

    if ( index >= m_cCount ) {
        return NULL;
    }

    pResult = m_pHead;
    _ASSERT ( pResult );

    for ( i = 0; i < index; i++ ) {
        pResult = pResult->m_pNext;
        _ASSERT ( pResult );
    }

    return pResult;
}

void CFeedPairList::Add ( CFeedPair * pFeedPair )
{
	AssertValid ();
    _ASSERT ( GetPairIndex ( pFeedPair ) == (DWORD) -1 );

    pFeedPair->m_pNext  = NULL;

    if ( m_pTail == NULL ) {
        //
        //  Handle special case - Adding to empty list:
        //

        _ASSERT ( m_pHead == NULL );

        m_pHead = pFeedPair;
        m_pTail = pFeedPair;
    }
    else {
        m_pTail->m_pNext = pFeedPair;
        m_pTail = pFeedPair;
    }
	m_cCount++;
}

void CFeedPairList::Remove ( CFeedPair * pFeedPair )
{
	AssertValid ();
    _ASSERT ( GetPairIndex ( pFeedPair ) != (DWORD) -1 );

    CFeedPair * pLead;
    CFeedPair * pFollow;

    for ( pLead = m_pHead, pFollow = NULL;
            pLead != NULL && pLead != pFeedPair;
            pFollow = pLead, pLead = pLead->m_pNext
            ) {
        // Empty For
    }
    _ASSERT ( pLead );
    if ( !pLead ) {
        return;
    }

    if ( pFollow != NULL ) {
        pFollow->m_pNext = pLead->m_pNext;
    }
    if ( m_pHead == pFeedPair ) {
        m_pHead = m_pHead->m_pNext;
    }
    if ( m_pTail == pFeedPair ) {
        m_pTail = pFollow;
    }

    delete pFeedPair;
	m_cCount--;
}

CFeedPair * CFeedPairList::Find ( DWORD dwFeedId )
{
	AssertValid ();
    CFeedPair   * pResult;

    if ( dwFeedId == 0 ) {
        return NULL;
    }

    for ( pResult = m_pHead; pResult != NULL; pResult = pResult->m_pNext ) {
        if ( pResult->ContainsFeedId ( dwFeedId ) ) {
            return pResult;
        }
    }

    return NULL;
}

DWORD CFeedPairList::GetPairIndex ( CFeedPair * pPairToFind ) const
{
	AssertValid ();
    _ASSERT ( pPairToFind );

    DWORD       index;
    CFeedPair * pFeedPair;

    for ( pFeedPair = m_pHead, index = 0;
            pFeedPair != NULL;
            pFeedPair = pFeedPair->m_pNext, index++ ) {

        if ( pFeedPair == pPairToFind ) {
            return index;
        }
    }

    return (DWORD) -1;
}

#ifdef DEBUG

void CFeedPairList::AssertValid ( ) const
{
	_ASSERT ( !IsBadWritePtr ( (void *) this, sizeof (*this) ) );

	// Walk the list and assert each feed pair is valid:

	CFeedPair *	pPair;
	DWORD		cCount;

	for ( cCount = 0, pPair = m_pHead; 
			pPair != NULL; 
			pPair = pPair->m_pNext, cCount++ 
			) {
		_ASSERT ( !IsBadWritePtr ( pPair, sizeof (*pPair) ) );

		_ASSERT ( IS_VALID_STRING ( pPair->m_strRemoteServer ) );

		_ASSERT ( pPair->m_pInbound || pPair->m_pOutbound );

		if ( pPair->m_pInbound ) {
			_ASSERT ( IS_VALID_STRING ( pPair->m_pInbound->m_strRemoteServer ) );
			_ASSERT ( !lstrcmpi ( pPair->m_pInbound->m_strRemoteServer, pPair->m_strRemoteServer ) );
		}
		if ( pPair->m_pOutbound ) {
			_ASSERT ( IS_VALID_STRING ( pPair->m_pOutbound->m_strRemoteServer ) );
			_ASSERT ( !lstrcmpi ( pPair->m_pOutbound->m_strRemoteServer, pPair->m_strRemoteServer ) );
		}
	}

	_ASSERT ( m_cCount == cCount );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\expinfo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	expinfo.cpp

Abstract:


Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "oleutil.h"
#include "nntpcmn.h"
#include "nntptype.h"
#include "nntpapi.h"

#include "expinfo.h"

#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Expiration.1")
#define THIS_FILE_IID				IID_INntpAdminExpiration

CExpirationPolicy::CExpirationPolicy ( ) :
	m_dwExpireId	( 0 ),
	m_dwSize		( 0 ),
	m_dwTime		( 0 )
	// CMultiSz's are set to NULL automatically.
{
}

CExpirationPolicy::~CExpirationPolicy ( )
{
	// CMultiSz's are deleted automatically.
}

void CExpirationPolicy::Destroy ()
{
	m_mszNewsgroups.Empty ();
}

const CExpirationPolicy & CExpirationPolicy::operator= ( const CExpirationPolicy & Expire )
{
	// Check for assignment to self:

	if ( &Expire == this ) {
		return *this;
	}

	// Empty the old Expire values:
	this->Destroy ();

	// Copy all member variables:
	m_dwExpireId		= Expire.m_dwExpireId;
	m_strPolicyName		= Expire.m_strPolicyName;
	m_dwSize			= Expire.m_dwSize;
	m_dwTime			= Expire.m_dwTime;
	m_mszNewsgroups		= Expire.m_mszNewsgroups;

	// If anything didn't work, CheckValid will fail.

	return *this;
}

BOOL CExpirationPolicy::CheckValid ( )
{
	// Check Strings:

	if (
		!m_mszNewsgroups
		) {

		return FALSE;
	}

	return TRUE;
}

void CExpirationPolicy::FromExpireInfo ( const NNTP_EXPIRE_INFO * pExpireInfo )
{
	this->Destroy ();

	m_dwExpireId		= pExpireInfo->ExpireId;
	m_strPolicyName		= pExpireInfo->ExpirePolicy;
	m_dwSize			= pExpireInfo->ExpireSizeHorizon;
	m_dwTime			= pExpireInfo->ExpireTime;
	m_mszNewsgroups		= (LPWSTR) pExpireInfo->Newsgroups;

	_ASSERT ( pExpireInfo->cbNewsgroups == m_mszNewsgroups.SizeInBytes () );
}

HRESULT CExpirationPolicy::ToExpireInfo ( LPNNTP_EXPIRE_INFO pExpireInfo )
{
	TraceFunctEnter ( "CExpirationPolicy::ToExpireInfo" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pExpireInfo ) );

	HRESULT	hr	= NOERROR;

	ZeroMemory ( pExpireInfo, sizeof ( *pExpireInfo ) );

	pExpireInfo->ExpireId			= m_dwExpireId;
	pExpireInfo->ExpirePolicy		= m_strPolicyName;
	pExpireInfo->ExpireSizeHorizon	= m_dwSize;
	pExpireInfo->ExpireTime			= m_dwTime;
	pExpireInfo->Newsgroups			= (UCHAR *) (LPCWSTR) m_mszNewsgroups;
	pExpireInfo->cbNewsgroups		= m_mszNewsgroups.SizeInBytes ();

	TraceFunctLeave ();
	return hr;
}

HRESULT CExpirationPolicy::Add ( LPCWSTR strServer, DWORD dwInstance)
{
	TraceFunctEnter ( "CExpirationPolicy::Add" );

	HRESULT			hr 			= NOERROR;
	DWORD			dwError		= NOERROR;
	DWORD			dwParmErr	= 0;
	DWORD			dwNewId		= 0;
	NNTP_EXPIRE_INFO	Expireinfo;

	FillMemory ( &Expireinfo, sizeof (Expireinfo), 0 );

	hr = ToExpireInfo ( &Expireinfo );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	Expireinfo.ExpireId = 0;

	dwError = NntpAddExpire ( (LPWSTR) strServer, dwInstance, &Expireinfo, &dwParmErr, &dwNewId );
	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to add Expire %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

	this->m_dwExpireId = dwNewId;

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT CExpirationPolicy::Set ( LPCWSTR strServer, DWORD dwInstance)
{
	TraceFunctEnter ( "CExpirationPolicy::Set" );

	HRESULT			hr 			= NOERROR;
	DWORD			dwError		= NOERROR;
	DWORD			dwParmErr	= 0;
	NNTP_EXPIRE_INFO	Expireinfo;

	FillMemory ( &Expireinfo, sizeof (Expireinfo), 0 );

	hr = ToExpireInfo ( &Expireinfo );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	dwError = NntpSetExpireInformation ( (LPWSTR) strServer, dwInstance, &Expireinfo, &dwParmErr );
	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to set Expire[%d]: %x", m_dwExpireId, dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT CExpirationPolicy::Remove ( LPCWSTR strServer, DWORD dwInstance)
{
	TraceFunctEnter ( "CExpirationPolicy::Remove" );

	HRESULT				hr 			= NOERROR;
	DWORD				dwError		= NOERROR;

	dwError = NntpDeleteExpire ( (LPWSTR) strServer, dwInstance, m_dwExpireId );
	if ( dwError != NOERROR ) {
		ErrorTraceX ( (LPARAM) this, "Failed to remove Expire[%d]: %x", m_dwExpireId );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

#if 0

BOOL CExpirationPolicy::CheckPolicyProperties ( )
{
	return TRUE;
}

HRESULT	CExpirationPolicy::GetFromMetabase ( CMetabaseKey * pmkeyExpiration, const LPWSTR wszPolicyKey )
{
	TraceFunctEnter ( "CExpirationPolicy::GetFromMetabase" );

	HRESULT	hr		= NOERROR;
	DWORD	cbData	= 0;
	char	Dummy[5];
	WCHAR *	msz = NULL;

	m_dwExpireId = GetExpireId ( szPolicyKey );
	// Assume that the ID is non-zero:
	_ASSERT ( m_dwExpireId != 0 );

	hr = pmkeyExpiration->GetDword ( szPolicyKey, MD_EXPIRE_SPACE, IIS_MD_UT_SERVER, &m_dwSize, 0 );
	if ( FAILED(hr) ) {
		m_dwSize = (DWORD) -1;
		hr = NOERROR;
	}

	hr = pmkeyExpiration->GetDword ( szPolicyKey, MD_EXPIRE_TIME, IIS_MD_UT_SERVER, &m_dwTime, 0 );
	if ( FAILED(hr) ) {
		m_dwTime = (DWORD) -1;
		hr = NOERROR;
	}

	hr = pmkeyExpiration->GetData ( szPolicyKey, MD_EXPIRE_NEWSGROUPS, IIS_MD_UT_SERVER, BINARY_METADATA, &Dummy, &cbData, 0 );
	if ( FAILED (hr) ) {
		cbData = 0;
		hr = NOERROR;
	}

	if ( cbData == 0 ) {
		m_mszNewsgroups = _T("\0");
	}
	else {
		_ASSERT ( (cbData % 2) == 0 );

		msz = new WCHAR [ (cbData + 1) / 2 ];

		if ( msz == NULL ) {
			FatalTrace ( (LPARAM) this, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		hr = pmkeyExpiration->GetData ( szPolicyKey, MD_EXPIRE_NEWSGROUPS, IIS_MD_UT_SERVER, BINARY_METADATA, msz, &cbData, 0 );

		m_mszNewsgroups = msz;
	}

Exit:
	if ( msz ) {
		delete msz;
	}

	TraceFunctLeave ();
	return hr;
}

HRESULT	CExpirationPolicy::SendToMetabase ( CMetabaseKey * pmkeyExpiration, DWORD bvChangedFields )
{
	TraceFunctEnter ( "CExpirationPolicy::SendToMetabase" );

	HRESULT	hr	= NOERROR;
	DWORD	cbNewsgroups = 0;
	CHAR	szPolicyKey[ METADATA_MAX_NAME_LEN ];

	_ASSERT ( m_dwExpireId != 0 );
	wsprintfA ( szPolicyKey, "expire%ud", m_dwExpireId );

	hr = pmkeyExpiration->SetDword ( szPolicyKey, MD_EXPIRE_SPACE, IIS_MD_UT_SERVER, m_dwSize );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pmkeyExpiration->SetDword ( szPolicyKey, MD_EXPIRE_TIME, IIS_MD_UT_SERVER, m_dwTime );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	cbNewsgroups = m_mszNewsgroups.SizeInBytes ();

	hr = pmkeyExpiration->SetData ( szPolicyKey, MD_EXPIRE_NEWSGROUPS, IIS_MD_UT_SERVER, BINARY_METADATA, (void *) (LPCWSTR) m_mszNewsgroups, cbNewsgroups );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT CExpirationPolicy::AddToMetabase ( CMetabaseKey * pmkeyExpiration )
{
	TraceFunctEnter ( "CExpirationPolicy::AddToMetabase" );

	HRESULT		hr = NOERROR;
	char		szExpireKey [ METADATA_MAX_NAME_LEN ];

	m_dwExpireId = 0;

	while ( 1 ) {
		m_dwExpireId++;

		wsprintfA ( szExpireKey, "expire%ud", m_dwExpireId );

		hr = pmkeyExpiration->CreateChild ( szExpireKey );

		if ( SUCCEEDED(hr) ) {
			// Success, get out of the loop:
			break;
		}

		if ( HRESULTTOWIN32 ( hr ) == ERROR_ALREADY_EXISTS ) {
			// This key already exists, try the next one:
			continue;
		}

		_ASSERT ( FAILED(hr) );
		if ( FAILED(hr) ) {
			ErrorTraceX ( (LPARAM) this, "Error adding new expire policy [%d] : %x", m_dwExpireId, hr );
			goto Exit;
		}
	}

	return SendToMetabase ( pmkeyExpiration, (DWORD) -1 );

Exit:
	TraceFunctLeave ();
	return hr;
}

DWORD GetExpireId ( const LPWSTR wszKey )
{
	if ( strncmp ( szKey, "expire", sizeof ("expire") - 1 ) != 0 ) {
		return 0;
	}

	return atoi ( szKey + sizeof("expire") - 1 );
}

BOOL IsKeyValidExpire ( const LPWSTR wszKey )
{
/*
	if ( _strnicmp ( szKey, "expire" ) != 0 ) {
		return FALSE;
	}
*/

	if ( GetExpireId ( szKey ) != 0 ) {
		return TRUE;
	}

	return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\feedpach.cpp ===
#include "stdafx.h"
#include "feedpach.h"

#define ALLOCATE_HEAP( nBytes ) LocalAlloc( 0, nBytes )
#define FREE_HEAP( _heap )      LocalFree( (PVOID)(_heap) )

#define ERR_KEY_ALREADY_EXIST  0x800700b7    // BugBug: This key macro should be 
                                             // replaced by the official one

VOID
FillFeedRoot( DWORD dwInstance, LPWSTR  wszBuffer )
{
    swprintf( wszBuffer, L"/LM/nntpsvc/%d/feeds/", dwInstance );
} 
     
BOOL
VerifyMultiSzListW(
    LPBYTE List,
    DWORD cbList
    )
/*++

Routine Description:

    This routine verifies that the list is indeed a multisz

Arguments:

    List - the list to be verified
    cbList - size of the list

Return Value:

    TRUE, list is a multisz
    FALSE, otherwise

--*/
{
    PWCHAR wList = (PWCHAR)List;
    DWORD len;

    //
    // null are considered no hits
    //

    if ( (List == NULL) || (*List == L'\0') ) {
        return(FALSE);
    }

    //
    // see if they are ok
    //

    for ( DWORD j = 0; j < cbList; ) {

        len = wcslen((LPWSTR)&List[j]);

        if ( len > 0 ) {

            j += ((len + 1) * sizeof(WCHAR));
        } else {

            //
            // all done
            //

            return(TRUE);
        }
    }

#ifndef UNIT_TEST
        ErrorTraceX(0,"VerifyMultiSzListW: exception handled\n");
#endif
    return(FALSE);

} // VerifyMultiSzList

DWORD
MultiListSize(
    LPWSTR *List
    )
/*++

Routine Description:

    This routine computes the size of the multisz structure needed
    to accomodate a list.

Arguments:

    List - the list whose string lengths are to be computed

Return Value:

    Size of buffer needed to accomodate list.

--*/
{
    TraceFunctEnter( "MultiListSize" );
    _ASSERT( List );

    DWORD nBytes = 2;
    DWORD i = 0;

    if ( List != NULL ) {
        while ( List[i] != NULL ) {
            nBytes += ( lstrlen(List[i]) + 1 ) * sizeof( WCHAR );
            i++;
        }
    }

    TraceFunctLeave();
    return(nBytes);
} // MultiListSize

DWORD
GetNumStringsInMultiSz(
    PWCHAR Blob,
    DWORD BlobSize
    )
/*++

Routine Description:

    This routine returns the number of strings in the multisz

Arguments:

    Blob - the list to be verified
    BlobSize - size of the list

Return Value:

    number of entries in the multisz structure.

--*/
{
    TraceFunctEnter( "GetNumStringInMultiSz" );
    _ASSERT( Blob );

    DWORD entries = 0;
    DWORD len;
    DWORD j;

    for ( j = 0; j < BlobSize; ) {
        len = lstrlen(&Blob[j]);
        if ( len > 0 ) {
            entries++;
        }
        j += (len + 1);
        if( len == 0 ) {
            break;
        }
    }

    _ASSERT( j  == BlobSize );

    TraceFunctLeave();
    return(entries);

} // GetNumStringsInMultiSz

LPWSTR *
AllocateMultiSzTable(
            IN PWCHAR List,
            IN DWORD cbList
            )
{
    TraceFunctEnter( "AllocateMultiSzTable" );
    _ASSERT( List );

    DWORD len;
    PCHAR buffer;
    DWORD entries = 0;
    LPWSTR* table;
    PWCHAR nextVar;
    DWORD numItems;

    numItems = GetNumStringsInMultiSz( List, cbList );
    if ( numItems == 0 ) {
        return(NULL);
    }

    buffer = (PCHAR)ALLOCATE_HEAP((numItems + 1) * sizeof(LPWSTR) + cbList * sizeof( WCHAR ));
    if ( buffer == NULL ) {
        return(NULL);
    }

    table = (LPWSTR *)buffer;
    nextVar = PWCHAR( buffer + (numItems + 1)*sizeof(LPWSTR) );

    for ( DWORD j = 0; j < cbList; ) {

        len = lstrlen(&List[j]);
        if ( len > 0 ) {
            table[entries] = (LPWSTR)nextVar;
            CopyMemory(nextVar,&List[j],(len+1)*sizeof( WCHAR ));
            (VOID)_wcslwr(table[entries]);
            entries++;
            nextVar += (len+1);
        }
        j += (len + 1);
    }

    *nextVar = L'\0';
    table[numItems] = NULL;
    
    TraceFunctLeave();
    return(table);

} // AllocateMultiSzTable

HRESULT
OpenKey( DWORD dwFeedId, CMetabaseKey* pMK, DWORD dwPermission, DWORD dwInstance )
{
    
    TraceFunctEnter( "OpenKey" );
    _ASSERT( dwFeedId > 0 );
    _ASSERT( pMK );

    HRESULT hr;
    WCHAR   wszFeedKey[MAX_PATH];

    swprintf( wszFeedKey, L"/LM/nntpsvc/%d/Feeds/feed%d/", dwInstance, dwFeedId );
    hr = pMK->Open( METADATA_MASTER_ROOT_HANDLE,
                    wszFeedKey,
                    dwPermission );
    if ( FAILED( hr ) ) {
        ErrorTrace(0, "Open feed key fail with 0x%x", hr );
        return hr;
    }

    TraceFunctLeave();
    return S_OK;
}

VOID
CloseKey( CMetabaseKey* pMK )
{
    pMK->Close();
}

VOID
SaveKey( CMetabaseKey* pMK )
{
    pMK->Save();
} 

HRESULT
AddKey( DWORD dwFeedId, CMetabaseKey* pMK, DWORD dwInstance )
{
    
    TraceFunctEnter( "Addkey" );
    _ASSERT( dwFeedId > 0 );
    _ASSERT( pMK );

    HRESULT hResult;
    WCHAR   wszFeedRoot[MAX_PATH];
    WCHAR   wszFeedKey[MAX_PATH];

    FillFeedRoot( dwInstance, wszFeedRoot );

    hResult = pMK->Open( METADATA_MASTER_ROOT_HANDLE,
                         wszFeedRoot,
                         METADATA_PERMISSION_WRITE );
    if ( FAILED( hResult ) ) {
        ErrorTrace( 0, "Open root for write fail with 0x%x", hResult );
        return hResult;
    }

    swprintf( wszFeedKey, L"feed%d", dwFeedId );
    hResult = pMK->CreateChild( wszFeedKey );
    if ( FAILED( hResult ) ) {
        ErrorTrace( 0, "Create key fail with 0x%x", hResult );
        pMK->Close();
        return hResult;
    }

    pMK->Close(); 
    TraceFunctLeave();
    return S_OK;
}    

HRESULT
DeleteKey( DWORD dwFeedId, CMetabaseKey* pMK, DWORD dwInstance )
{
    TraceFunctEnter( "DeleteKey" );
    _ASSERT( pMK );

    HRESULT hResult;
    WCHAR   wszFeedRoot[MAX_PATH];
    WCHAR   wszFeedKey[MAX_PATH];

    FillFeedRoot( dwInstance, wszFeedRoot );
    hResult = pMK->Open( METADATA_MASTER_ROOT_HANDLE,
                         wszFeedRoot,
                         METADATA_PERMISSION_WRITE );
    if ( FAILED( hResult ) ) {
        ErrorTrace( 0, "Open root key for write fail with 0x%x", hResult );
        return hResult;
    }

    swprintf( wszFeedKey, L"feed%d", dwFeedId ); 
    hResult = pMK->DestroyChild( wszFeedKey );
    if ( FAILED( hResult ) ) {
        ErrorTrace(0, "Delete key fail with 0x%x", hResult );
        pMK->Close();
    }

    pMK->Close();
    TraceFunctLeave();
    return S_OK;
}

HRESULT
SetDwordProp( DWORD dwPropId, DWORD dwPropVal, CMetabaseKey* pMK )
{
    TraceFunctEnter( "SetDwordProp" );
    _ASSERT( pMK );

    HRESULT hResult;

    hResult = pMK->SetDword( dwPropId, dwPropVal );
    if ( FAILED( hResult ) ) {
        ErrorTrace( 0, "Set DWord fail with 0x%x", hResult );
        return hResult;
    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT
SetStringProp( DWORD dwPropId, LPWSTR wszStringVal, CMetabaseKey* pMK )
{
    TraceFunctEnter( "SetStringProp" );
    HRESULT hr;

    hr = pMK->SetString( dwPropId, wszStringVal );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Open key for property setting fail with 0x%x", hr );
        return hr;
    }

    TraceFunctLeave();
    return S_OK;
}
HRESULT
SetStringProp( DWORD dwPropId, LPWSTR wszStringVal, CMetabaseKey* pMK, DWORD dwFlags, DWORD dwUserType)
{
    TraceFunctEnter( "SetStringProp" );
    HRESULT hr;

    hr = pMK->SetString( dwPropId, wszStringVal, dwFlags, dwUserType );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Open key for property setting fail with 0x%x", hr );
        return hr;
    }

    TraceFunctLeave();
    return S_OK;
}
HRESULT 
SetMultiString(     DWORD dwPropId, 
                    LPWSTR*  mszPropVal,
                    CMetabaseKey* pMK )
{
    TraceFunctEnter( "SetMultiString" );

    HRESULT hr;

    hr = pMK->SetMultiSz( dwPropId, mszPropVal[0], MultiListSize( mszPropVal ) );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Set multisz property fail with 0x%x", hr );
        return hr;
    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT
AllocNextAvailableFeedId( CMetabaseKey* pMK, PDWORD pdwFeedId, DWORD dwInstance )
{
    TraceFunctEnter(  "AllocNextAvailableFeedId" );
    _ASSERT( pMK );

    HRESULT hr;
    DWORD   dwCounter = 0;

    while( TRUE ) {

        hr = AddKey( ++dwCounter, pMK, dwInstance );
        if ( SUCCEEDED( hr ) ) {
            TraceFunctLeave();
            *pdwFeedId = dwCounter;
            return S_OK;
        }

        if ( hr != ERR_KEY_ALREADY_EXIST ) {
            TraceFunctLeave();
            ErrorTrace( 0, "Alloc key fail with 0x%x", hr );
            return hr;
        }
    }

    TraceFunctLeave();  // will never reach here
    return E_FAIL;
}

//
// The pMK should already have been opened for write permission
//
HRESULT
UpdateFeedMetabaseValues(   CMetabaseKey* pMK, 
                            LPNNTP_FEED_INFO pFeedInfo, 
                            DWORD dwMask,
                            PDWORD dwRetMask   )
{
    TraceFunctEnter( "UpdateFeedMetabaseValues" );
    _ASSERT( pMK );
    _ASSERT( pFeedInfo );

    HRESULT hr;
    LPWSTR* stringList;

	//
	// Set the KeyType.
	//

	hr = SetStringProp(	MD_KEY_TYPE,
    					TEXT(NNTP_ADSI_OBJECT_FEED),
    					pMK,
    					METADATA_NO_ATTRIBUTES,
    					IIS_MD_UT_SERVER
					 );
	if (FAILED(hr))
	{
        goto fail_exit;
	}

    if ( ( dwMask & FEED_PARM_FEEDTYPE) != 0 ) {
        hr = SetDwordProp(  MD_FEED_TYPE,
                            pFeedInfo->FeedType,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set feed type fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_FEEDTYPE;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_AUTOCREATE  ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_CREATE_AUTOMATICALLY,
                            DWORD(pFeedInfo->AutoCreate),
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set auto creat fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_AUTOCREATE;
            goto fail_exit;
        }
    }

    if ( !FEED_IS_PASSIVE( pFeedInfo->FeedType ) ) {
        
        if (  ( dwMask &  FEED_PARM_FEEDINTERVAL ) != 0 ) {
            hr = SetDwordProp(  MD_FEED_INTERVAL,
                                pFeedInfo->FeedInterval,
                                pMK  );
            if ( FAILED( hr ) ) {
                ErrorTrace(0, "Set feed interval fail with 0x%x", hr );
                *dwRetMask |= FEED_PARM_FEEDINTERVAL;
                goto fail_exit;
            }
        }

        if (  ( dwMask & FEED_PARM_STARTTIME ) != 0 ) {
            hr = SetDwordProp(  MD_FEED_START_TIME_HIGH,
                                (pFeedInfo->StartTime).dwHighDateTime,
                                pMK );
            if ( FAILED( hr ) ) {
                ErrorTrace(0, "Set start time fail with 0x%x", hr );
                *dwRetMask |= FEED_PARM_STARTTIME;
                goto fail_exit;
            }

            hr = SetDwordProp(  MD_FEED_START_TIME_LOW,
                                (pFeedInfo->StartTime).dwLowDateTime,
                                pMK );
            if ( FAILED( hr ) ) {
                ErrorTrace(0, "Set start time fail with 0x%x" , hr );
                *dwRetMask |= FEED_PARM_STARTTIME;
                goto fail_exit;
            }
        }

        if (  ( dwMask & FEED_PARM_PULLREQUESTTIME ) != 0 ) {
            
            hr = SetDwordProp(
                                MD_FEED_NEXT_PULL_HIGH,
                                (pFeedInfo->PullRequestTime).dwHighDateTime,
                                pMK ); 
            if ( FAILED( hr ) ) {
                ErrorTrace(0, "Set pull request time fail with 0x%x", hr );
                *dwRetMask |= FEED_PARM_PULLREQUESTTIME;
                goto fail_exit;
            }

            hr = SetDwordProp(
                                MD_FEED_NEXT_PULL_LOW,
                                (pFeedInfo->PullRequestTime).dwLowDateTime,
                                pMK ); 
            if ( FAILED( hr ) ) {
                ErrorTrace(0, "Set pull request time fail with 0x%x", hr );
                *dwRetMask |= FEED_PARM_PULLREQUESTTIME;
                goto fail_exit;
            }

        } 
        
    }

    if ( ( dwMask & FEED_PARM_SERVERNAME  ) != 0 ) {
        hr = SetStringProp( MD_FEED_SERVER_NAME,
                            pFeedInfo->ServerName,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set server name fail with 0x%x", hr ) ;
            *dwRetMask |= FEED_PARM_SERVERNAME;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_NEWSGROUPS ) != 0 ) {
        stringList =  AllocateMultiSzTable( pFeedInfo->Newsgroups,
                                             pFeedInfo->cbNewsgroups  / sizeof( WCHAR ));
        if ( !stringList ) {
            ErrorTrace(0, "Generate multi sz fail" );
            hr = E_OUTOFMEMORY;
            *dwRetMask |= FEED_PARM_NEWSGROUPS;
            goto fail_exit;
        }

        hr = SetMultiString(    MD_FEED_NEWSGROUPS,
                                stringList,
                                pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set newsgroups fail with 0x%x", hr );
            *dwRetMask |= MD_FEED_NEWSGROUPS;
            goto fail_exit;
        }

        FREE_HEAP( stringList );        
    }

    if (  ( dwMask & FEED_PARM_DISTRIBUTION  ) != 0 ) {
        stringList = AllocateMultiSzTable(  pFeedInfo->Distribution,
                                            pFeedInfo->cbDistribution / sizeof( WCHAR ));
        if ( !stringList ) {
            ErrorTrace(0, "Generate multi sz fail" );
            hr = E_OUTOFMEMORY;
            *dwRetMask |= FEED_PARM_DISTRIBUTION;
            goto fail_exit;
        }

        hr = SetMultiString(    MD_FEED_DISTRIBUTION,
                                stringList,
                                pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set distribution fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_DISTRIBUTION;
            goto fail_exit;
        }

        FREE_HEAP( stringList );
    }  

    if ( ( dwMask & FEED_PARM_ENABLED  ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_DISABLED,    
                            DWORD( pFeedInfo->Enabled ), 
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set feed enable fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_ENABLED;
            goto fail_exit;
        }
    }

    if (  ( dwMask & FEED_PARM_UUCPNAME  ) != 0 && pFeedInfo->UucpName ){
        hr = SetStringProp( MD_FEED_UUCP_NAME,
                            pFeedInfo->UucpName,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set uucp name fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_UUCPNAME;
            goto fail_exit;
        }
    }

    if (  ( dwMask & FEED_PARM_TEMPDIR ) != 0 && pFeedInfo->FeedTempDirectory ) {
        hr = SetStringProp( MD_FEED_TEMP_DIRECTORY,
                            pFeedInfo->FeedTempDirectory,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set temp dir fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_TEMPDIR;
            goto fail_exit;
        }
    }

    if (  ( dwMask & FEED_PARM_MAXCONNECT ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_MAX_CONNECTION_ATTEMPTS,
                            pFeedInfo->MaxConnectAttempts,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set max connect fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_MAXCONNECT;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_SESSIONSECURITY ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_SECURITY_TYPE,
                            pFeedInfo->SessionSecurityType,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set session sec type fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_SESSIONSECURITY;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_CONCURRENTSESSION ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_CONCURRENT_SESSIONS,
                            pFeedInfo->ConcurrentSessions,
                            pMK );
        if ( FAILED(hr ) ) {
            ErrorTrace(0, "Set concurrent sessions fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_CONCURRENTSESSION;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_AUTHTYPE ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_AUTHENTICATION_TYPE,
                            pFeedInfo->AuthenticationSecurityType,
                            pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set auth type fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_AUTHTYPE;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_ACCOUNTNAME ) != 0 && pFeedInfo->NntpAccountName ) {
        hr = SetStringProp( MD_FEED_ACCOUNT_NAME,
                        pFeedInfo->NntpAccountName,
                        pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set account name fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_ACCOUNTNAME;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_PASSWORD ) != 0 && pFeedInfo->NntpPassword ) {
        hr = SetStringProp( MD_FEED_PASSWORD,
                        pFeedInfo->NntpPassword,
                        pMK,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER);
        if( FAILED( hr ) ) {
            ErrorTrace(0, "Set password fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_PASSWORD;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_ALLOW_CONTROL ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_ALLOW_CONTROL_MSGS,
                        DWORD( pFeedInfo->fAllowControlMessages ),
                        pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Set allow control msgs fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_ALLOW_CONTROL;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_OUTGOING_PORT ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_OUTGOING_PORT,
                        pFeedInfo->OutgoingPort,
                        pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set outgoing port fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_OUTGOING_PORT;
            goto fail_exit;
        }
    }

    if ( ( dwMask & FEED_PARM_FEEDPAIR_ID  ) != 0 ) {
        hr = SetDwordProp(  MD_FEED_FEEDPAIR_ID,
                        pFeedInfo->FeedPairId,
                        pMK );
        if ( FAILED( hr ) ) {
            ErrorTrace(0, "Set pair id fail with 0x%x", hr );
            *dwRetMask |= FEED_PARM_FEEDPAIR_ID;
            goto fail_exit;
        }
    }

    TraceFunctLeave();
    return S_OK;

fail_exit:

    TraceFunctLeave();
    return hr;
}

VOID
SetPresenceMask( LPNNTP_FEED_INFO pFeedInfo, PDWORD pdwMask, BOOL fIsAdd )
{
    TraceFunctEnter( "SetPresenceMask" );
    _ASSERT( pFeedInfo );
    _ASSERT( pdwMask );

    BOOL    newsPresent = FALSE;

    *pdwMask = 0;

    //
    // feed type, assume always exist for add, non-existant for set
    //
    if ( fIsAdd ) *pdwMask |= FEED_PARM_FEEDTYPE;
    
    //
    // server name
    //
    if ( pFeedInfo->ServerName != FEED_STRINGS_NOCHANGE &&
         *pFeedInfo->ServerName != L'\0' )
        *pdwMask |= FEED_PARM_SERVERNAME;

    //
    // news groups
    //
    if ( VerifyMultiSzListW(    LPBYTE( pFeedInfo->Newsgroups ),
                                pFeedInfo->cbNewsgroups ) ) {
        *pdwMask |= FEED_PARM_NEWSGROUPS;
        newsPresent = TRUE;
    }

    //
    // Distribution
    //
    if ( VerifyMultiSzListW(    LPBYTE( pFeedInfo->Distribution ),
                                pFeedInfo->cbDistribution ) )
        *pdwMask |= FEED_PARM_DISTRIBUTION;

    //
    // Uucp Name
    //
    if (    pFeedInfo->UucpName != FEED_STRINGS_NOCHANGE &&
            *pFeedInfo->UucpName != L'\0' )
        *pdwMask |= FEED_PARM_UUCPNAME;

    //
    // account name
    //
    if (    pFeedInfo->NntpAccountName != FEED_STRINGS_NOCHANGE &&
            *pFeedInfo->NntpAccountName != L'\0' )
        *pdwMask |= FEED_PARM_ACCOUNTNAME;

    //
    // Password
    //
    if (    pFeedInfo->NntpPassword != FEED_STRINGS_NOCHANGE &&
            *pFeedInfo->NntpPassword != L'\0' )
        *pdwMask |= FEED_PARM_PASSWORD;

    //
    // Temp dir 
    //
    if (    pFeedInfo->FeedTempDirectory != FEED_STRINGS_NOCHANGE &&
            *pFeedInfo->FeedTempDirectory != L'\0' )
        *pdwMask |= FEED_PARM_TEMPDIR;

    //
    // auth type
    //
    if ( pFeedInfo->AuthenticationSecurityType == AUTH_PROTOCOL_NONE ||
            pFeedInfo->AuthenticationSecurityType == AUTH_PROTOCOL_CLEAR ) {
        *pdwMask |= FEED_PARM_AUTHTYPE;

        if ( pFeedInfo->AuthenticationSecurityType == AUTH_PROTOCOL_NONE ) {
            *pdwMask &= ~FEED_PARM_ACCOUNTNAME;
            *pdwMask &= ~FEED_PARM_PASSWORD;
        }
    }

    //
    // start time
    //
    if ( pFeedInfo->StartTime.dwHighDateTime != FEED_STARTTIME_NOCHANGE )
        *pdwMask |= FEED_PARM_STARTTIME;

    //
    // pull request time
    //
    if ( pFeedInfo->PullRequestTime.dwHighDateTime != FEED_PULLTIME_NOCHANGE )
        *pdwMask |= FEED_PARM_PULLREQUESTTIME;

    //
    // feed interval
    //
    if ( pFeedInfo->FeedInterval != FEED_FEEDINTERVAL_NOCHANGE )
        *pdwMask |= FEED_PARM_FEEDINTERVAL;

    //
    // auto create
    //
    if ( pFeedInfo->AutoCreate != FEED_AUTOCREATE_NOCHANGE )
        *pdwMask |= FEED_PARM_AUTOCREATE;

    if ( newsPresent ) {
        *pdwMask |= FEED_PARM_AUTOCREATE;
        pFeedInfo->AutoCreate = TRUE;
    }

    //
    // allow control
    //
    *pdwMask |= FEED_PARM_ALLOW_CONTROL;

    //
    // Max connect
    //
    if ( pFeedInfo->MaxConnectAttempts != FEED_MAXCONNECTS_NOCHANGE )
        *pdwMask |= FEED_PARM_MAXCONNECT;

    //
    // outgoing port
    //
    *pdwMask |= FEED_PARM_OUTGOING_PORT;

    //
    // feedpair id
    //
    *pdwMask |= FEED_PARM_FEEDPAIR_ID;

    //
    // feed enable
    //
    *pdwMask |= FEED_PARM_ENABLED;

    TraceFunctLeave();
}

HRESULT AddFeedToMB( LPNNTP_FEED_INFO pFeedInfo, CMetabaseKey* pMK, PDWORD pdwErrMask, DWORD dwInstance, PDWORD pdwFeedId )
{
    TraceFunctEnter( "AddFeed" );
    _ASSERT( pFeedInfo );

    HRESULT hr;
    DWORD   dwSetMask = 0;

    //
    // Get set mask
    //
    //SetPresenceMask( pFeedInfo, &dwSetMask, TRUE );
    
    //
    // Alloc and create the feed key in the metabase
    //
    hr = AllocNextAvailableFeedId( pMK, pdwFeedId, dwInstance );
    if ( FAILED( hr ) ) {
        TraceFunctLeave();
        return hr;
    }

    pFeedInfo->FeedId = *pdwFeedId; 

    //
    // Open that key for write
    //
    hr = OpenKey( *pdwFeedId, pMK, METADATA_PERMISSION_WRITE, dwInstance );
    if ( FAILED( hr ) ) 
        goto fail_exit; 

    //
    // Write the handshake start updating flag
    //
    hr = SetDwordProp(  MD_FEED_HANDSHAKE, 
                        FEED_UPDATING,
                        pMK ); 
    if ( FAILED( hr ) )
        goto fail_exit;

    //
    // Set feed info
    //
    hr = UpdateFeedMetabaseValues(  pMK,
                                    pFeedInfo,
                                    FEED_ALL_PARAMS,
                                    pdwErrMask );
    if ( FAILED( hr ) ) 
        goto fail_exit;

    //
    // Set handshake
    //
    hr = SetDwordProp(  MD_FEED_HANDSHAKE,
                        FEED_UPDATE_COMPLETE,
                        pMK );
    if ( FAILED( hr )  ) 
        goto fail_exit;

    //
    // done.
    //
    CloseKey( pMK );
    SaveKey( pMK );
    TraceFunctLeave();
    return S_OK;

fail_exit:

    CloseKey( pMK );
    DeleteKey( 1, pMK, dwInstance );
    TraceFunctLeave();
    return hr;
} 

HRESULT 
SetFeedToMB( LPNNTP_FEED_INFO pFeedInfo, CMetabaseKey* pMK, PDWORD pdwErrMask, DWORD dwInstance )
{
    TraceFunctEnter( "AddFeed" );
    _ASSERT( pFeedInfo );

    HRESULT hr;
    DWORD   dwSetMask = 0;

    //
    // Get set mask
    //
    SetPresenceMask( pFeedInfo, &dwSetMask, FALSE );

    //
    // Open that key for write
    //
    hr = OpenKey( pFeedInfo->FeedId, pMK, METADATA_PERMISSION_WRITE, dwInstance );
    if ( FAILED( hr ) )
        goto fail_exit;

    //
    // Write the handshake start updating flag
    //
    hr = SetDwordProp(  MD_FEED_HANDSHAKE,
                        FEED_UPDATING,
                        pMK );
    if ( FAILED( hr ) )
        goto fail_exit;

    //
    // Set feed info
    //
    hr = UpdateFeedMetabaseValues(  pMK,
                                    pFeedInfo,
                                    dwSetMask,
                                    pdwErrMask );
    if ( FAILED( hr ) )
        goto fail_exit;

    //
    // Set handshake
    //
    hr = SetDwordProp(  MD_FEED_HANDSHAKE,
                        FEED_UPDATE_COMPLETE,
                        pMK );
    if ( FAILED( hr )  )
        goto fail_exit;

    //
    // done.
    //
    CloseKey( pMK );
    SaveKey( pMK );
    TraceFunctLeave();
    return S_OK;

fail_exit:

    CloseKey( pMK );
    TraceFunctLeave();
    return hr;
}

HRESULT
DeleteFeed( DWORD dwFeedId, CMetabaseKey* pMK, DWORD dwInstance )
{
    return  DeleteKey( dwFeedId, pMK, dwInstance);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\feeds.cpp ===
// feeds.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"
#include "nntpcmn.h"
#include "feeds.h"
#include "oleutil.h"

#include "nntptype.h"
#include "nntpapi.h"

#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Feeds.1")
#define THIS_FILE_IID				IID_INntpAdminFeeds

/////////////////////////////////////////////////////////////////////////////
// Defaults:

#define DEFAULT_FEED_ID						0
#define DEFAULT_FEED_SERVER					_T("")
#define DEFAULT_PULL_NEWS_DATE				0
#define DEFAULT_START_TIME					0
#define DEFAULT_FEED_INTERVAL				15
#define DEFAULT_AUTO_CREATE					TRUE
#define DEFAULT_ENABLED						TRUE
#define DEFAULT_MAX_CONNECTIONS_ATTEMPTS	10
#define DEFAULT_SECURITY_TYPE				0
#define DEFAULT_AUTH_TYPE                   AUTH_PROTOCOL_NONE
#define DEFAULT_ACCOUNT_NAME				_T("")
#define DEFAULT_PASSWORD					_T("")
#define DEFAULT_ALLOW_CONTROL_MESSAGES		TRUE
#define DEFAULT_UUCP_NAME                   _T("")
#define DEFAULT_NEWSGROUPS                  _T("\0")
#define DEFAULT_DISTRIBUTION                _T("world\0")

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(NntpAdminFeeds, CNntpAdminFeeds, IID_INntpAdminFeeds)

STDMETHODIMP CNntpOneWayFeed::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpOneWayFeed,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpOneWayFeed::CNntpOneWayFeed ()
	// CComBSTR's are initialized to NULL by default.
{
//	InitAsyncTrace ( );
}

CNntpOneWayFeed::~CNntpOneWayFeed ()
{
	// All CComBSTR's are freed automatically.
//	TermAsyncTrace ( );
}

STDMETHODIMP CNntpOneWayFeed::get_FeedId ( long * plFeedId )
{
	return StdPropertyGet ( m_feed.m_dwFeedId, plFeedId );
}

STDMETHODIMP CNntpOneWayFeed::get_RemoteServer ( BSTR * pstrRemoteServer )
{
	return StdPropertyGet ( m_feed.m_strRemoteServer, pstrRemoteServer );
}

STDMETHODIMP CNntpOneWayFeed::get_FeedAction ( NNTP_FEED_ACTION * pfeedaction )
{
	return m_feed.get_FeedAction ( pfeedaction );
}

STDMETHODIMP CNntpOneWayFeed::put_FeedAction ( NNTP_FEED_ACTION feedaction )
{
	return m_feed.put_FeedAction ( feedaction );
}

STDMETHODIMP CNntpOneWayFeed::get_UucpName ( BSTR * pstrUucpName )
{
	return StdPropertyGet ( m_feed.m_strUucpName, pstrUucpName );
}

STDMETHODIMP CNntpOneWayFeed::put_UucpName ( BSTR strUucpName )
{
	return StdPropertyPut ( &m_feed.m_strUucpName, strUucpName );
}

STDMETHODIMP CNntpOneWayFeed::get_PullNewsDate ( DATE * pdatePullNews )
{
	return StdPropertyGet ( m_feed.m_datePullNews, pdatePullNews );
}

STDMETHODIMP CNntpOneWayFeed::put_PullNewsDate ( DATE datePullNews )
{
	return StdPropertyPut ( &m_feed.m_datePullNews, datePullNews );
}

STDMETHODIMP CNntpOneWayFeed::get_FeedInterval ( long * plFeedInterval )
{
	return StdPropertyGet ( m_feed.m_dwFeedInterval, plFeedInterval );
}

STDMETHODIMP CNntpOneWayFeed::put_FeedInterval ( long lFeedInterval )
{
	return StdPropertyPut ( &m_feed.m_dwFeedInterval, lFeedInterval );
}

STDMETHODIMP CNntpOneWayFeed::get_AutoCreate ( BOOL * pfAutoCreate )
{
	return StdPropertyGet ( m_feed.m_fCreateAutomatically, pfAutoCreate );
}

STDMETHODIMP CNntpOneWayFeed::put_AutoCreate ( BOOL fAutoCreate )
{
	return StdPropertyPut ( &m_feed.m_fCreateAutomatically, fAutoCreate );
}

STDMETHODIMP CNntpOneWayFeed::get_Enabled ( BOOL * pfEnabled )
{
	return StdPropertyGet ( m_feed.m_fEnabled, pfEnabled );
}

STDMETHODIMP CNntpOneWayFeed::put_Enabled ( BOOL fEnabled )
{
	return StdPropertyPut ( &m_feed.m_fEnabled, fEnabled );
}

STDMETHODIMP CNntpOneWayFeed::get_MaxConnectionAttempts ( long * plMaxConnectionAttempts )
{
	return StdPropertyGet ( m_feed.m_dwMaxConnectionAttempts, plMaxConnectionAttempts );
}

STDMETHODIMP CNntpOneWayFeed::put_MaxConnectionAttempts ( long lMaxConnectionAttempts )
{
	return StdPropertyPut ( &m_feed.m_dwMaxConnectionAttempts, lMaxConnectionAttempts );
}

STDMETHODIMP CNntpOneWayFeed::get_SecurityType ( long * plSecurityType )
{
	return StdPropertyGet ( m_feed.m_dwSecurityType, plSecurityType );
}

STDMETHODIMP CNntpOneWayFeed::put_SecurityType ( long lSecurityType )
{
	return StdPropertyPut ( &m_feed.m_dwSecurityType, lSecurityType );
}

STDMETHODIMP CNntpOneWayFeed::get_AuthenticationType ( long * plAuthenticationType )
{
	return StdPropertyGet ( m_feed.m_dwAuthenticationType, plAuthenticationType );
}

STDMETHODIMP CNntpOneWayFeed::put_AuthenticationType ( long lAuthenticationType )
{
	return StdPropertyPut ( &m_feed.m_dwAuthenticationType, lAuthenticationType );
}

STDMETHODIMP CNntpOneWayFeed::get_AccountName ( BSTR * pstrAccountName )
{
	return StdPropertyGet ( m_feed.m_strAccountName, pstrAccountName );
}

STDMETHODIMP CNntpOneWayFeed::put_AccountName ( BSTR strAccountName )
{
	return StdPropertyPut ( &m_feed.m_strAccountName, strAccountName );
}

STDMETHODIMP CNntpOneWayFeed::get_Password ( BSTR * pstrPassword )
{
	return StdPropertyGet ( m_feed.m_strPassword, pstrPassword );
}

STDMETHODIMP CNntpOneWayFeed::put_Password ( BSTR strPassword )
{
	return StdPropertyPut ( &m_feed.m_strPassword, strPassword );
}

STDMETHODIMP CNntpOneWayFeed::get_AllowControlMessages ( BOOL * pfAllowControlMessages )
{
	return StdPropertyGet ( m_feed.m_fAllowControlMessages, pfAllowControlMessages );
}

STDMETHODIMP CNntpOneWayFeed::put_AllowControlMessages ( BOOL fAllowControlMessages )
{
	return StdPropertyPut ( &m_feed.m_fAllowControlMessages, fAllowControlMessages );
}

STDMETHODIMP CNntpOneWayFeed::get_OutgoingPort ( long * plOutgoingPort )
{
	return StdPropertyGet ( m_feed.m_dwOutgoingPort, plOutgoingPort );
}

STDMETHODIMP CNntpOneWayFeed::put_OutgoingPort ( long lOutgoingPort )
{
	return StdPropertyPut ( &m_feed.m_dwOutgoingPort, lOutgoingPort );
}

STDMETHODIMP CNntpOneWayFeed::get_Newsgroups ( SAFEARRAY ** ppsastrNewsgroups )
{
	return StdPropertyGet ( &m_feed.m_mszNewsgroups, ppsastrNewsgroups );
}

STDMETHODIMP CNntpOneWayFeed::put_Newsgroups ( SAFEARRAY * psastrNewsgroups )
{
	return StdPropertyPut ( &m_feed.m_mszNewsgroups, psastrNewsgroups );
}

STDMETHODIMP CNntpOneWayFeed::get_NewsgroupsVariant ( SAFEARRAY ** ppsavarNewsgroups )
{
	HRESULT			hr;
	SAFEARRAY *		psastrNewsgroups	= NULL;

	hr = get_Newsgroups ( &psastrNewsgroups );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = StringArrayToVariantArray ( psastrNewsgroups, ppsavarNewsgroups );

Exit:
	if ( psastrNewsgroups ) {
		SafeArrayDestroy ( psastrNewsgroups );
	}

	return hr;
}

STDMETHODIMP CNntpOneWayFeed::put_NewsgroupsVariant ( SAFEARRAY * psavarNewsgroups )
{
	HRESULT			hr;
	SAFEARRAY *		psastrNewsgroups	= NULL;

	hr = VariantArrayToStringArray ( psavarNewsgroups, &psastrNewsgroups );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = put_Newsgroups ( psastrNewsgroups );

Exit:
	if ( psastrNewsgroups ) {
		SafeArrayDestroy ( psastrNewsgroups );
	}

	return hr;
}

STDMETHODIMP CNntpOneWayFeed::get_Distributions ( SAFEARRAY ** ppsastrDistributions )
{
	return StdPropertyGet ( &m_feed.m_mszDistributions, ppsastrDistributions );
}

STDMETHODIMP CNntpOneWayFeed::put_Distributions ( SAFEARRAY * psastrDistributions )
{
	return StdPropertyPut ( &m_feed.m_mszDistributions, psastrDistributions );
}

STDMETHODIMP CNntpOneWayFeed::get_TempDirectory ( BSTR * pstrTempDirectory )
{
	return StdPropertyGet ( m_feed.m_strTempDirectory, pstrTempDirectory );
}

STDMETHODIMP CNntpOneWayFeed::put_TempDirectory ( BSTR strTempDirectory )
{
	return StdPropertyPut ( &m_feed.m_strTempDirectory, strTempDirectory );
}

STDMETHODIMP CNntpOneWayFeed::Default	( )
{
	TraceFunctEnter ( "CNntpOneWayFeed::Default" );

	SYSTEMTIME	st;
	DATE		dateToday;

	GetSystemTime ( &st );
	SystemTimeToVariantTime ( &st, &dateToday );

	m_feed.m_dwFeedId				= DEFAULT_FEED_ID;
	m_feed.m_strRemoteServer		= DEFAULT_FEED_SERVER;
	m_feed.m_dwFeedInterval			= DEFAULT_FEED_INTERVAL;
	m_feed.m_fCreateAutomatically	= DEFAULT_AUTO_CREATE;
	m_feed.m_fEnabled				= DEFAULT_ENABLED;
	m_feed.m_dwMaxConnectionAttempts	= DEFAULT_MAX_CONNECTIONS_ATTEMPTS;
	m_feed.m_dwSecurityType			= DEFAULT_SECURITY_TYPE;
    m_feed.m_dwAuthenticationType   = DEFAULT_AUTH_TYPE;
	m_feed.m_strAccountName			= DEFAULT_ACCOUNT_NAME;
	m_feed.m_strPassword			= DEFAULT_PASSWORD;
	m_feed.m_fAllowControlMessages	= DEFAULT_ALLOW_CONTROL_MESSAGES;
    m_feed.m_strUucpName         	= DEFAULT_UUCP_NAME;
    m_feed.m_dwOutgoingPort			= 119;

    m_feed.m_mszNewsgroups           = DEFAULT_NEWSGROUPS;
    m_feed.m_mszDistributions        = DEFAULT_DISTRIBUTION;

	m_feed.m_datePullNews			= dateToday;

	if ( !m_feed.CheckValid() ) {
		TraceFunctLeave ();
		return E_OUTOFMEMORY;
	}
	
	TraceFunctLeave ();
	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpFeed::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpFeed,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpFeed::CNntpFeed () :
	m_type ( NNTP_FEED_TYPE_PEER )
	// CComBSTR's are initialized to NULL by default.
{
//	InitAsyncTrace ( );
}

CNntpFeed::~CNntpFeed ()
{
	// All CComBSTR's are freed automatically.
//	TermAsyncTrace ( );
}

STDMETHODIMP CNntpFeed::get_RemoteServer ( BSTR * pstrRemoteServer )
{
	return StdPropertyGet ( m_strRemoteServer, pstrRemoteServer );
}

STDMETHODIMP CNntpFeed::put_RemoteServer ( BSTR strRemoteServer )
{
	return StdPropertyPut ( &m_strRemoteServer, strRemoteServer );
}

STDMETHODIMP CNntpFeed::get_FeedType ( NNTP_FEED_SERVER_TYPE * pfeedtype )
{
	*pfeedtype = m_type;
	return NOERROR;
}

STDMETHODIMP CNntpFeed::put_FeedType ( NNTP_FEED_SERVER_TYPE feedtype )
{
	switch ( feedtype ) {
	case NNTP_FEED_TYPE_PEER:
	case NNTP_FEED_TYPE_MASTER:
	case NNTP_FEED_TYPE_SLAVE:
		m_type = feedtype;
		return NOERROR;
		break;

	default:
		return RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
		break;
	}
}

STDMETHODIMP CNntpFeed::get_HasInbound ( BOOL * pfHasInbound )
{
    *pfHasInbound = m_pInbound != NULL;
    return NOERROR;
}

STDMETHODIMP CNntpFeed::get_HasOutbound ( BOOL * pfHasOutbound )
{
    *pfHasOutbound = m_pOutbound != NULL;
    return NOERROR;
}

STDMETHODIMP CNntpFeed::get_InboundFeed ( INntpOneWayFeed ** ppFeed )
{
    HRESULT     hr  = NOERROR;

    *ppFeed = NULL;
    if ( m_pInbound ) {
        hr = m_pInbound->QueryInterface ( IID_INntpOneWayFeed, (void **) ppFeed );
        return hr;
    }
    return E_FAIL;
}

STDMETHODIMP CNntpFeed::get_OutboundFeed ( INntpOneWayFeed ** ppFeed )
{
    HRESULT     hr  = NOERROR;

    *ppFeed = NULL;
    if ( m_pOutbound ) {
        hr = m_pOutbound->QueryInterface ( IID_INntpOneWayFeed, (void **) ppFeed );
    	return hr;
    }
    return E_FAIL;
}

STDMETHODIMP CNntpFeed::put_InboundFeed ( INntpOneWayFeed * pFeed )
{
    HRESULT     hr  = NOERROR;

    // !!!magnush - Do some feed type checking here.

    m_pInbound.Release ();
    m_pInbound = pFeed;

    return NOERROR;
}

STDMETHODIMP CNntpFeed::put_OutboundFeed ( INntpOneWayFeed * pFeed )
{
    HRESULT     hr  = NOERROR;

    // !!!magnush - Do some feed type checking here.

    m_pOutbound.Release ();
    m_pOutbound = pFeed;

    return hr;
}

STDMETHODIMP CNntpFeed::get_InboundFeedDispatch ( IDispatch ** ppDispatch )
{
	HRESULT						hr;
	CComPtr<INntpOneWayFeed>	pInbound;

	hr = get_InboundFeed ( &pInbound );
	BAIL_ON_FAILURE(hr);

	hr = pInbound->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

STDMETHODIMP CNntpFeed::put_InboundFeedDispatch ( IDispatch * pDispatch )
{
	HRESULT						hr;
	CComPtr<INntpOneWayFeed>	pInbound;

	hr = pDispatch->QueryInterface ( IID_INntpOneWayFeed, (void **) &pInbound );
	BAIL_ON_FAILURE(hr);

	hr = put_InboundFeed ( pInbound );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

STDMETHODIMP CNntpFeed::get_OutboundFeedDispatch ( IDispatch ** ppDispatch )
{
	HRESULT						hr;
	CComPtr<INntpOneWayFeed>	pOutbound;

	hr = get_OutboundFeed ( &pOutbound );
	BAIL_ON_FAILURE(hr);

	hr = pOutbound->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

STDMETHODIMP CNntpFeed::put_OutboundFeedDispatch ( IDispatch * pDispatch )
{
	HRESULT						hr;
	CComPtr<INntpOneWayFeed>	pOutbound;

	hr = pDispatch->QueryInterface ( IID_INntpOneWayFeed, (void **) &pOutbound );
	BAIL_ON_FAILURE(hr);

	hr = put_OutboundFeed ( pOutbound );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

HRESULT	CNntpFeed::FromFeedPair ( CFeedPair * pFeedPair )
{
	HRESULT		hr	= NOERROR;

	m_pInbound.Release ();
	m_pOutbound.Release ();

	m_strRemoteServer	= pFeedPair->m_strRemoteServer;
	m_type				= pFeedPair->m_type;
	if ( pFeedPair->m_pInbound ) {
		hr = pFeedPair->m_pInbound->ToINntpOneWayFeed ( &m_pInbound );
		BAIL_ON_FAILURE(hr);
	}
	if ( pFeedPair->m_pOutbound ) {
		hr = pFeedPair->m_pOutbound->ToINntpOneWayFeed ( &m_pOutbound );
		BAIL_ON_FAILURE(hr);
	}

Exit:
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpAdminFeeds::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpAdminFeeds,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpAdminFeeds::CNntpAdminFeeds () :
	m_fEnumerated				( FALSE )
	// CComBSTR's are initialized to NULL by default.
{

	InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Feeds") );
    m_iadsImpl.SetClass ( _T("IIsNntpFeeds") );

    OleInitialize( NULL );
}

CNntpAdminFeeds::~CNntpAdminFeeds ()
{
	// All CComBSTR's are freed automatically.
	TermAsyncTrace ( );
    OleUninitialize();
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CNntpAdminFeeds,m_iadsImpl)

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// Enumeration Properties:

STDMETHODIMP CNntpAdminFeeds::get_Count ( long * plCount )
{
	return StdPropertyGet ( m_listFeeds.GetCount(), plCount );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpAdminFeeds::Enumerate	( )
{
	TraceFunctEnter ( "CNntpAdminFeeds::Enumerate" );

	HRESULT				hr			= NOERROR;
	DWORD				dwError		= NOERROR;
	DWORD				cFeeds		= 0;
	LPNNTP_FEED_INFO	pFeedInfo	= NULL;
	DWORD				i;

	dwError = NntpEnumerateFeeds (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &cFeeds,
        &pFeedInfo
        );
	if ( dwError != 0 ) {
		ErrorTrace ( (LPARAM) this, "Error enumerating feeds: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

	// Empty the old feed list:
	m_fEnumerated = FALSE;
    m_listFeeds.Empty ();

    // Add each feed to our list:
    for ( i = 0; i < cFeeds; i++ ) {
        DWORD           dwPairID;
        CFeedPair *     pFeedPair;
        CFeed *         pFeed;

        // Create a new Feed object:
        hr = CFeed::CreateFeedFromFeedInfo ( &pFeedInfo[i], &pFeed );
        if ( FAILED(hr) ) {
            goto Exit;
        }

        // Find the pair that matches Feed[i]:
        dwPairID = pFeed->m_dwPairFeedId;
        pFeedPair = m_listFeeds.Find ( dwPairID );

        if ( pFeedPair ) {
            // We found a matching pair, so add it:
            hr = pFeedPair->AddFeed ( pFeed );
            if ( hr == E_FAIL ) {
                // Something went wrong - Try to add the feed by itself.
                pFeedPair = NULL;
                hr = NOERROR;
            }
            if ( FAILED(hr) ) {
                goto Exit;
            }
        }

        if ( pFeedPair == NULL ) {
            // We need to create a new feed pair:
            hr = CFeedPair::CreateFeedPair ( 
            	&pFeedPair, 
            	pFeedInfo[i].ServerName,
            	FeedTypeToEnum ( pFeedInfo[i].FeedType )
            	);
            if ( FAILED(hr) ) {
                goto Exit;
            }

            // Add the current feed to the new pair:
            hr = pFeedPair->AddFeed ( pFeed );
            if ( FAILED(hr) ) {
                goto Exit;
            }

            // Add the new pair to the pair list:
            m_listFeeds.Add ( pFeedPair );
        }
    }

    // !!!magnush - Stop memory leaks here.

	m_fEnumerated 	= TRUE;

Exit:
	if ( FAILED(hr) ) {
        m_listFeeds.Empty();
	}

	if ( pFeedInfo ) {
		::NetApiBufferFree ( pFeedInfo );
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::Item ( long lIndex, INntpFeed ** ppFeed )
{
	TraceFunctEnter ( "CNntpAdminFeeds::Item" );

	HRESULT		        hr	= NOERROR;
    CFeedPair *         pFeedPair;

	// Did we enumerate first?
	if ( !m_fEnumerated ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );
		TraceFunctLeave ();
        return hr;
	}
	
    pFeedPair = m_listFeeds.Item ( lIndex );
    if ( !pFeedPair ) {
        hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
        goto Exit;
    }

    hr = pFeedPair->ToINntpFeed ( ppFeed );
    if ( FAILED(hr) ) {
        goto Exit;
    }

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::FindID ( long lID, long * plIndex )
{
	TraceFunctEnter ( "CNntpAdminFeeds::FindID" );

	HRESULT		hr	= NOERROR;
    CFeedPair * pFeedPair;

    *plIndex = -1;

    pFeedPair   = m_listFeeds.Find ( (DWORD) lID );

    if ( pFeedPair ) {
        *plIndex = (long) m_listFeeds.GetPairIndex ( pFeedPair );
    }

	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpAdminFeeds::ReturnFeedPair ( CFeedPair * pFeedPair, INntpFeed * pFeed )
{
	HRESULT						hr;
    CComPtr<INntpOneWayFeed>    pInbound;
    CComPtr<INntpOneWayFeed>    pOutbound;
    CComPtr<INntpFeed>          pNewFeedPair;

    hr = pFeedPair->ToINntpFeed ( &pNewFeedPair );
	BAIL_ON_FAILURE(hr);

    pNewFeedPair->get_InboundFeed ( &pInbound );
    pNewFeedPair->get_OutboundFeed ( &pOutbound );

    pFeed->put_InboundFeed ( pInbound );
    pFeed->put_OutboundFeed ( pOutbound );

Exit:
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::Add ( INntpFeed * pFeed )
{
	TraceFunctEnter ( "CNntpAdminFeeds::Add" );

	HRESULT		hr 				= NOERROR;
    CFeedPair * pFeedPair       = NULL;
    CComBSTR	strRemoteServer;
    CComBSTR	strServer;
    NNTP_FEED_SERVER_TYPE	    type;
    CMetabaseKey *pMK = NULL;
    IMSAdminBase *pMeta = NULL;

	hr = pFeed->get_RemoteServer ( &strRemoteServer );
	BAIL_ON_FAILURE(hr);

	hr = get_Server(&strServer);
	BAIL_ON_FAILURE(hr);

    hr = CreateMetabaseObject( strServer, &pMeta ); 
    _ASSERT( SUCCEEDED( hr ) );
    BAIL_ON_FAILURE(hr);

	pMK = new CMetabaseKey(pMeta);
	if (!pMK)
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);

	hr = pFeed->get_FeedType ( &type );
	BAIL_ON_FAILURE(hr);

    hr = CFeedPair::CreateFeedPair ( &pFeedPair, strRemoteServer, type );
	BAIL_ON_FAILURE(hr);

    hr = pFeedPair->FromINntpFeed ( pFeed );
	BAIL_ON_FAILURE(hr);

    hr = pFeedPair->AddToServer (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        pMK
        );
	BAIL_ON_FAILURE(hr);

    m_listFeeds.Add ( pFeedPair );

    //  Return the new feeds (and their IDs) to the caller:
	hr = ReturnFeedPair ( pFeedPair, pFeed );
	BAIL_ON_FAILURE(hr);

Exit:
    if ( FAILED(hr) ) {
        delete pFeedPair;
    }

    if (pMK)
    	delete pMK;

    if (pMeta)
    	pMeta->Release();

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::Set ( long lIndex, INntpFeed * pFeed )
{
	TraceFunctEnter ( "CNntpAdminFeeds::Set" );

	HRESULT		hr = NOERROR;
    CFeedPair * pFeedPair;
    CComPtr<INntpFeed>          pNewFeedPair;
    CComPtr<INntpOneWayFeed>    pInbound;
    CComPtr<INntpOneWayFeed>    pOutbound;
    CComBSTR	strServer;
    CMetabaseKey *pMK = NULL;
    IMSAdminBase *pMeta = NULL;

	hr = get_Server ( &strServer );
	BAIL_ON_FAILURE(hr);

    hr = CreateMetabaseObject( strServer, &pMeta ); 
    _ASSERT( SUCCEEDED( hr ) );
    BAIL_ON_FAILURE(hr);

	pMK = new CMetabaseKey(pMeta);
	if (!pMK)
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);

    pFeedPair = m_listFeeds.Item ( lIndex );
    if ( !pFeedPair ) {
        hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
        goto Exit;
    }

    hr = pFeedPair->SetToServer (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        pFeed,
        pMK
        );
	BAIL_ON_FAILURE(hr);

    //  Return the new feeds (and their IDs) to the caller:
	hr = ReturnFeedPair ( pFeedPair, pFeed );
	BAIL_ON_FAILURE(hr);

Exit:
    if (pMK)
    	delete pMK;

    if (pMeta)
    	pMeta->Release();

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::Remove ( long lIndex )
{
	TraceFunctEnter ( "CNntpAdminFeeds::Remove" );

	HRESULT		hr = NOERROR;
	CFeedPair *	pFeedPair;
    CComBSTR	strServer;
    CMetabaseKey *pMK = NULL;
    IMSAdminBase *pMeta = NULL;

    pFeedPair   = m_listFeeds.Item ( lIndex );
    if ( !pFeedPair ) {
        hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
        goto Exit;
    }

	hr = get_Server ( &strServer );
	BAIL_ON_FAILURE(hr);

    hr = CreateMetabaseObject( strServer, &pMeta ); 
    _ASSERT( SUCCEEDED( hr ) );
    BAIL_ON_FAILURE(hr);

	pMK = new CMetabaseKey(pMeta);
	if (!pMK)
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);

    hr = pFeedPair->RemoveFromServer (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        pMK
        );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    m_listFeeds.Remove ( pFeedPair );

Exit:
    if (pMK)
    	delete pMK;

    if (pMeta)
    	pMeta->Release();

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::ItemDispatch ( long index, IDispatch ** ppDispatch )
{
	HRESULT				hr;
	CComPtr<INntpFeed>	pFeed;

	hr = Item ( index, &pFeed );
	BAIL_ON_FAILURE ( hr );

	hr = pFeed->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::AddDispatch ( IDispatch * pFeed )
{
	HRESULT				hr;
	CComPtr<INntpFeed>	pINntpFeed;

	hr = pFeed->QueryInterface ( IID_INntpFeed, (void **) &pINntpFeed );
	BAIL_ON_FAILURE(hr);

	hr = Add ( pINntpFeed );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

STDMETHODIMP CNntpAdminFeeds::SetDispatch ( long lIndex, IDispatch * pFeed )
{
	HRESULT				hr;
	CComPtr<INntpFeed>	pINntpFeed;

	hr = pFeed->QueryInterface ( IID_INntpFeed, (void **) &pINntpFeed );
	BAIL_ON_FAILURE(hr);

	hr = Set ( lIndex, pINntpFeed );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\feedpach.h ===
#ifndef _FEED_PATCH_H_
#include "metakey.h"
#include <stdio.h>
#include <nntpmeta.h>
#include <nntptype.h>
#include <nntpapi.h>

HRESULT AddFeedToMB( LPNNTP_FEED_INFO pFeedInfo, CMetabaseKey* pMK, PDWORD pdwErrMask, DWORD, PDWORD );
HRESULT SetFeedToMB( LPNNTP_FEED_INFO pFeedInfo, CMetabaseKey* pMK, PDWORD pdwErrMask, DWORD );
HRESULT DeleteFeed( DWORD dwFeedId, CMetabaseKey* pMK, DWORD );
HRESULT OpenKey( DWORD, CMetabaseKey*, DWORD, DWORD );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\feedinfo.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	feedinfo.h

Abstract:

	Defines the CFeed class that maintains all properties about a feed.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _FEEDINFO_INCLUDED_
#define _FEEDINFO_INCLUDED_

// Dependencies

#include "cmultisz.h"
#include "metakey.h"

typedef struct _NNTP_FEED_INFO NNTP_FEED_INFO, * LPNNTP_FEED_INFO;
typedef DWORD FEED_TYPE;

//
//  Forward declarations:
//

class CFeed;
class CFeedPair;
class CFeedPairList;

NNTP_FEED_SERVER_TYPE FeedTypeToEnum ( FEED_TYPE ft );
void EnumToFeedType ( NNTP_FEED_SERVER_TYPE type, FEED_TYPE & ftMask );

//$-------------------------------------------------------------------
//
//	Class:
//		CFeed
//
//	Description:
//
//--------------------------------------------------------------------

class CFeed
{
    friend class CFeedPair;
    friend class CFeedPairList;

public:
    //
    //  Creating CFeed objects:
    //
    static HRESULT CreateFeed ( CFeed ** ppNewFeed );
    static HRESULT CreateFeedFromFeedInfo ( LPNNTP_FEED_INFO pFeedInfo, CFeed ** ppNewFeed );
    static HRESULT CreateFeedFromINntpOneWayFeed ( INntpOneWayFeed * pFeed, CFeed ** ppNewFeed );

	CFeed	( );
	~CFeed	( );
	void	Destroy ();

	const CFeed & operator= ( const CFeed & feed );
	inline const CFeed & operator= ( const NNTP_FEED_INFO & feed ) {
		FromFeedInfo ( &feed );
		return *this;
	}

	//
	//	Conversion routines:
	//

	HRESULT		ToFeedInfo		( LPNNTP_FEED_INFO 		pFeedInfo );
	HRESULT		FromFeedInfo	( const NNTP_FEED_INFO * pFeedInfo );
	HRESULT		ToINntpOneWayFeed	( INntpOneWayFeed ** ppFeed );
	HRESULT		FromINntpOneWayFeed	( INntpOneWayFeed * pFeed );

	//
	//	Communicating changes to the service:
	//

	HRESULT		Add 	( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK );
	HRESULT		Remove 	( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK );
	HRESULT		Set 	( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK );

	HRESULT		SetPairId ( LPCWSTR strServer, DWORD dwInstance, DWORD dwPairId, CMetabaseKey* pMK );

	// Feed Properties:
public:
	DWORD		m_dwFeedId;
	DWORD		m_dwPairFeedId;
	FEED_TYPE	m_FeedType;
	BOOL		m_fAllowControlMessages;
	DWORD		m_dwAuthenticationType;
	DWORD		m_dwConcurrentSessions;
	BOOL		m_fCreateAutomatically;
	BOOL		m_fEnabled;
	CMultiSz	m_mszDistributions;
	DWORD		m_dwFeedInterval;
	DATE		m_datePullNews;
	DWORD		m_dwMaxConnectionAttempts;
	CMultiSz	m_mszNewsgroups;
	DWORD		m_dwSecurityType;
	DWORD		m_dwOutgoingPort;
	CComBSTR	m_strUucpName;
	CComBSTR	m_strAccountName;
	CComBSTR	m_strPassword;
	CComBSTR	m_strTempDirectory;

	//
	//	CFeedPair sets these:
	//
	NNTP_FEED_SERVER_TYPE	m_EnumType;
	CComBSTR				m_strRemoteServer;

	//
	//	Routines to help property gets/puts:
	//

	HRESULT	get_FeedAction	( NNTP_FEED_ACTION * feedaction );
	HRESULT	put_FeedAction	( NNTP_FEED_ACTION feedaction );

	BOOL	CheckValid () const;

private:
#ifdef DEBUG
	void		AssertValid	( ) const;
#else
	inline void AssertValid ( ) const { }
#endif

private:
	HRESULT	TranslateFeedError ( DWORD dwErrorCode, DWORD dwParmErr = 0 );
    HRESULT CheckConfirm(   DWORD dwFeedId, 
                            DWORD dwInstanceId,
                            CMetabaseKey* pMK,
                            PDWORD pdwErr,
                            PDWORD pdwErrMask );

	// Don't call the copy constructor:
	CFeed ( const CFeed & );
};

//$-------------------------------------------------------------------
//
//	Class:
//		CFeedPair
//
//	Description:
//
//--------------------------------------------------------------------

class CFeedPair
{
	friend class CNntpFeed;
    friend class CFeedPairList;

public:
    CFeedPair();
    ~CFeedPair();

    static  HRESULT CreateFeedPair ( 
    	CFeedPair ** 			ppNewFeedPair, 
    	BSTR 					strRemoteServer,
    	NNTP_FEED_SERVER_TYPE	type
    	);
    void    Destroy ();

    HRESULT AddFeed         ( CFeed * pFeed );
    BOOL    ContainsFeedId  ( DWORD dwFeedId );

	//	Routines to help property gets/puts:
	HRESULT	get_FeedType	( NNTP_FEED_SERVER_TYPE * feedtype );
	HRESULT	put_FeedType	( NNTP_FEED_SERVER_TYPE feedtype );

    // CFeedPair <-> OLE INntpFeedPair:
    HRESULT ToINntpFeed     ( INntpFeed ** ppFeed );
    HRESULT FromINntpFeed   ( INntpFeed * pFeed );

    // Talking with the Server:
    HRESULT AddToServer         ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK );
    HRESULT SetToServer         ( LPCWSTR strServer, DWORD dwInstance, INntpFeed * pFeed, CMetabaseKey* pMK );
    HRESULT RemoveFromServer    ( LPCWSTR strServer, DWORD dwInstance, CMetabaseKey* pMK );

private:
	HRESULT	AddIndividualFeed ( LPCWSTR strServer, DWORD dwInstance, CFeed * pFeed, CMetabaseKey* pMK );
	HRESULT SetIndividualFeed ( LPCWSTR strServer, DWORD dwInstance, CFeed * pFeed, CMetabaseKey* pMK );
	HRESULT	SetPairIds ( 
		LPCWSTR		strServer, 
		DWORD		dwInstance, 
		CFeed *		pFeed1, 
		CFeed *		pFeed2,
		CMetabaseKey* pMK
		);
	HRESULT	UndoFeedAction ( 
		LPCWSTR strServer, 
		DWORD	dwInstance, 
		CFeed *	pNewFeed, 
		CFeed *	pOldFeed ,
        CMetabaseKey* pMK
		);

    CComBSTR        		m_strRemoteServer;
    NNTP_FEED_SERVER_TYPE	m_type;
    CFeed *         		m_pInbound;
    CFeed *         		m_pOutbound;
    CFeedPair *     		m_pNext;        // Used by CFeedPairList

private:
#ifdef DEBUG
	void		AssertValid	( ) const;
#else
	inline void AssertValid ( ) const { }
#endif

};

//$-------------------------------------------------------------------
//
//	Class:
//		CFeedPairList
//
//	Description:
//
//--------------------------------------------------------------------

class CFeedPairList
{
public:
    CFeedPairList ( );
    ~CFeedPairList ( );

    //
    // List interface:
    //

    DWORD   GetCount    ( ) const;
    void    Empty       ( );

    CFeedPair * Item    ( DWORD index );
    void        Add     ( CFeedPair * pPair );
    void        Remove  ( CFeedPair * pPair );
    CFeedPair * Find    ( DWORD dwFeedId );
    DWORD       GetPairIndex    ( CFeedPair * pPair ) const;

private:
#ifdef DEBUG
	void		AssertValid	( ) const;
#else
	inline void AssertValid ( ) const { }
#endif

private:
    DWORD           m_cCount;
    CFeedPair *     m_pHead;
    CFeedPair *     m_pTail;

};

#endif // _FEEDINFO_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\guids.cpp ===
#include "stdafx.h"

#define INITGUIDS
#include "initguid.h"

#include "mimeole.h"

//
//	My GUIDS:
//

#include "nntpadm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\groups.cpp ===
// groups.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"
#include "nntpcmn.h"
#include "oleutil.h"

#include "groups.h"
#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Groups.1")
#define THIS_FILE_IID				IID_INntpAdminGroups

#define DEFAULT_NEWSGROUP_NAME			_T("")
#define DEFAULT_NEWSGROUP_DESCRIPTION	_T("")
#define DEFAULT_NEWSGROUP_PRETTYNAME	_T("")
#define DEFAULT_NEWSGROUP_MODERATED		FALSE
#define DEFAULT_NEWSGROUP_MODERATOR		_T("")
#define DEFAULT_NEWSGROUP_READONLY		FALSE

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(NntpAdminGroups, CNntpAdminGroups, IID_INntpAdminGroups)

STDMETHODIMP CNntpAdminGroups::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpAdminGroups,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpAdminGroups::CNntpAdminGroups () :
	m_fModerated			( FALSE ),
	m_fReadOnly				( FALSE ),
    m_dateCreation          ( 0 ),
	m_pFindList				( NULL ),
	m_cMatchingGroups		( 0 )
	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Groups") );
    m_iadsImpl.SetClass ( _T("IIsNntpGroups") );
}

CNntpAdminGroups::~CNntpAdminGroups ()
{
	if ( m_pFindList ) {
		::NetApiBufferFree ( m_pFindList );
	}

	// All CComBSTR's are freed automatically.
	TermAsyncTrace ( );
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CNntpAdminGroups,m_iadsImpl)

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// Enumeration Properties:

STDMETHODIMP CNntpAdminGroups::get_Count ( long * plCount )
{
	return StdPropertyGet ( m_cMatchingGroups, plCount );
}

STDMETHODIMP CNntpAdminGroups::get_Newsgroup ( BSTR * pstrNewsgroup )
{
	return StdPropertyGet ( m_strNewsgroup, pstrNewsgroup );
}

STDMETHODIMP CNntpAdminGroups::put_Newsgroup ( BSTR strNewsgroup )
{
	return StdPropertyPut ( &m_strNewsgroup, strNewsgroup );
}

STDMETHODIMP CNntpAdminGroups::get_Description ( BSTR * pstrDescription )
{
	return StdPropertyGet ( m_strDescription, pstrDescription );
}

STDMETHODIMP CNntpAdminGroups::put_Description ( BSTR strDescription )
{
	return StdPropertyPut ( &m_strDescription, strDescription );
}

STDMETHODIMP CNntpAdminGroups::get_PrettyName ( BSTR * pstrPrettyName )
{
	return StdPropertyGet ( m_strPrettyName, pstrPrettyName );
}

STDMETHODIMP CNntpAdminGroups::put_PrettyName ( BSTR strPrettyName )
{
    if ( strPrettyName && wcschr ( strPrettyName, _T('\n') ) ) {
        return E_INVALIDARG;
    }

	return StdPropertyPut ( &m_strPrettyName, strPrettyName );
}

STDMETHODIMP CNntpAdminGroups::get_IsModerated ( BOOL * pfIsModerated )
{
	return StdPropertyGet ( m_fModerated, pfIsModerated );
}

STDMETHODIMP CNntpAdminGroups::put_IsModerated ( BOOL fIsModerated )
{
	return StdPropertyPut ( &m_fModerated, fIsModerated );
}

STDMETHODIMP CNntpAdminGroups::get_Moderator ( BSTR * pstrModerator )
{
	return StdPropertyGet ( m_strModerator, pstrModerator );
}

STDMETHODIMP CNntpAdminGroups::put_Moderator ( BSTR strModerator )
{
	return StdPropertyPut ( &m_strModerator, strModerator );
}

STDMETHODIMP CNntpAdminGroups::get_ReadOnly ( BOOL * pfReadOnly )
{
	return StdPropertyGet ( m_fReadOnly, pfReadOnly );
}

STDMETHODIMP CNntpAdminGroups::put_ReadOnly ( BOOL fReadOnly )
{
	return StdPropertyPut ( &m_fReadOnly, fReadOnly );
}

STDMETHODIMP CNntpAdminGroups::get_CreationTime ( DATE * pdateCreation )
{
	return StdPropertyGet ( m_dateCreation, pdateCreation );
}

STDMETHODIMP CNntpAdminGroups::put_CreationTime ( DATE dateCreation )
{
	return StdPropertyPut ( &m_dateCreation, dateCreation );
}

STDMETHODIMP CNntpAdminGroups::get_MatchingCount ( long * plMatchingCount )
{
	return StdPropertyGet ( m_cMatchingGroups, plMatchingCount );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpAdminGroups::Default ( )
{
	TraceFunctEnter ( "CNntpAdminGroups::Default" );

    SYSTEMTIME      st;

	m_strNewsgroup 		= DEFAULT_NEWSGROUP_NAME;
	m_strDescription 	= DEFAULT_NEWSGROUP_DESCRIPTION;
	m_strPrettyName		= DEFAULT_NEWSGROUP_PRETTYNAME;
	m_fModerated		= DEFAULT_NEWSGROUP_MODERATED;
	m_strModerator		= DEFAULT_NEWSGROUP_MODERATOR;
	m_fReadOnly			= DEFAULT_NEWSGROUP_READONLY;

    GetLocalTime ( &st );
    SystemTimeToVariantTime ( &st, &m_dateCreation );

	if ( 
		!m_strNewsgroup ||
		!m_strDescription ||
		!m_strModerator
		) {

		FatalTrace ( (LPARAM) this, "Out of memory" );
		return E_OUTOFMEMORY;
	}

	TraceFunctLeave ();
	return NOERROR;
}

STDMETHODIMP CNntpAdminGroups::Add ( )
{
	TraceFunctEnter ( "CNntpAdminGroups::Add" );

	HRESULT					hr				= NOERROR;
	DWORD					dwError			= NOERROR;
	LPSTR					szPrettyName	= NULL;
	NNTP_NEWSGROUP_INFO		newsgroup;

	ZeroMemory ( &newsgroup, sizeof ( newsgroup ) );

	_ASSERT ( m_strNewsgroup );

	hr = UnicodeToMime2 ( m_strPrettyName, &szPrettyName );
	BAIL_ON_FAILURE(hr);

	newsgroup.Newsgroup 	= (PUCHAR) (LPWSTR) m_strNewsgroup;
	newsgroup.cbNewsgroup	= STRING_BYTE_LENGTH ( m_strNewsgroup );
	if ( szPrettyName && *szPrettyName ) {
		newsgroup.Prettyname	= (PUCHAR) szPrettyName;
		newsgroup.cbPrettyname	= strlen (szPrettyName) + sizeof(char);
	}
	else {
		newsgroup.Prettyname	= NULL;
		newsgroup.cbPrettyname	= 0;
	}
	newsgroup.Description	= (PUCHAR) (LPWSTR) m_strDescription;
	newsgroup.cbDescription	= STRING_BYTE_LENGTH ( m_strDescription );
	newsgroup.fIsModerated	= m_fModerated;
	if ( m_strModerator == NULL || *m_strModerator == NULL ) {
		newsgroup.Moderator		= NULL;
		newsgroup.cbModerator	= 0;
	}
	else {
		newsgroup.Moderator		= (PUCHAR) (LPWSTR) m_strModerator;
		newsgroup.cbModerator	= STRING_BYTE_LENGTH ( m_strModerator );
	}
	newsgroup.ReadOnly		= m_fReadOnly;

	dwError = NntpCreateNewsgroup (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &newsgroup
        );
	if ( dwError != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to add newsgroup: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	if ( szPrettyName ) {
		m_pMimeAlloc->Free ( szPrettyName );
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminGroups::Remove ( BSTR strNewsgroup )
{
	TraceFunctEnter ( "CNntpAdminGroups::Remove" );
	
	_ASSERT ( IS_VALID_STRING ( strNewsgroup ) );

	HRESULT					hr			= NOERROR;
	DWORD					dwError		= NOERROR;
	NNTP_NEWSGROUP_INFO		newsgroup;

	ZeroMemory ( &newsgroup, sizeof ( newsgroup ) );

	newsgroup.Newsgroup 	= (PUCHAR) (LPWSTR) strNewsgroup;
	newsgroup.cbNewsgroup	= STRING_BYTE_LENGTH ( strNewsgroup );

	dwError = NntpDeleteNewsgroup (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &newsgroup
        );
	if ( dwError != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to remove newsgroup: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminGroups::Get ( BSTR strNewsgroup )
{
	TraceFunctEnter ( "CNntpAdminGroups::Get" );

	_ASSERT ( IS_VALID_STRING ( strNewsgroup ) );

	HRESULT					hr			= NOERROR;
	DWORD					dwError		= NOERROR;
	NNTP_NEWSGROUP_INFO		newsgroup;
	LPNNTP_NEWSGROUP_INFO	pNewsgroup	= &newsgroup;
    SYSTEMTIME              st;
    FILETIME                ftLocal;

	ZeroMemory ( &newsgroup, sizeof ( newsgroup ) );

	newsgroup.Newsgroup 	= (PUCHAR) (LPWSTR) strNewsgroup;
	newsgroup.cbNewsgroup	= STRING_BYTE_LENGTH ( strNewsgroup );

	dwError = NntpGetNewsgroup (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &pNewsgroup
        );
	if ( dwError != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to get newsgroup: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

	_ASSERT ( IS_VALID_STRING ( (LPWSTR) pNewsgroup->Newsgroup ) );

	m_strNewsgroup 		= pNewsgroup->Newsgroup ? (LPWSTR) pNewsgroup->Newsgroup : _T("");
	m_strDescription 	= pNewsgroup->Description ? (LPWSTR) pNewsgroup->Description : _T("");
	m_fModerated		= pNewsgroup->fIsModerated;
	m_strModerator 		= pNewsgroup->Moderator ? (LPWSTR) pNewsgroup->Moderator : _T("");
	m_fReadOnly			= pNewsgroup->ReadOnly;

    FileTimeToLocalFileTime ( &pNewsgroup->ftCreationDate, &ftLocal );
    FileTimeToSystemTime ( &ftLocal, &st );
    SystemTimeToVariantTime ( &st, &m_dateCreation );

	if ( pNewsgroup->Prettyname && *pNewsgroup->Prettyname ) {
		hr = Mime2ToUnicode ( (LPSTR) pNewsgroup->Prettyname, m_strPrettyName );
		if ( FAILED(hr) ) {
			m_strPrettyName	= _T("");
			hr = NOERROR;
		}
	}
	else {
		m_strPrettyName     = _T("");
	}

	if ( 
		!m_strNewsgroup ||
		!m_strDescription ||
        !m_strPrettyName ||
		!m_strModerator 
		) {

		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	if ( pNewsgroup && pNewsgroup != &newsgroup ) {
		NetApiBufferFree ( pNewsgroup );
	}

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminGroups::Set ( )
{
	TraceFunctEnter ( "CNntpAdminGroups::Set" );

	HRESULT		                    hr				= NOERROR;
	DWORD					        dwError			= NOERROR;
	LPSTR							szPrettyName	= NULL;
	NNTP_NEWSGROUP_INFO		        newsgroup;
    SYSTEMTIME                      st;
    FILETIME                        ftLocal;

	ZeroMemory ( &newsgroup, sizeof ( newsgroup ) );

	_ASSERT ( m_strNewsgroup );

	hr = UnicodeToMime2 ( m_strPrettyName, &szPrettyName );
	BAIL_ON_FAILURE(hr);

	newsgroup.Newsgroup 	= (PUCHAR) (LPWSTR) m_strNewsgroup;
	newsgroup.cbNewsgroup	= STRING_BYTE_LENGTH ( m_strNewsgroup );
	newsgroup.Description	= (PUCHAR) (LPWSTR) m_strDescription;
	newsgroup.cbDescription	= STRING_BYTE_LENGTH ( m_strDescription );
	if ( szPrettyName && *szPrettyName ) {
		newsgroup.Prettyname	= (PUCHAR) szPrettyName;
		newsgroup.cbPrettyname	= strlen (szPrettyName) + sizeof(char);
	}
	else {
		newsgroup.Prettyname	= NULL;
		newsgroup.cbPrettyname	= 0;
	}
	newsgroup.fIsModerated	= m_fModerated;
	if ( m_strModerator == NULL || *m_strModerator == NULL ) {
		newsgroup.Moderator		= NULL;
		newsgroup.cbModerator	= 0;
	}
	else {
		newsgroup.Moderator		= (PUCHAR) (LPWSTR) m_strModerator;
		newsgroup.cbModerator	= STRING_BYTE_LENGTH ( m_strModerator );
	}
	newsgroup.ReadOnly		= m_fReadOnly;

    VariantTimeToSystemTime ( m_dateCreation, &st );
    SystemTimeToFileTime ( &st, &ftLocal );
    LocalFileTimeToFileTime ( &ftLocal, &newsgroup.ftCreationDate );

	dwError = NntpSetNewsgroup (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &newsgroup
        );

	if ( dwError != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to set newsgroup: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	if ( szPrettyName ) {
		m_pMimeAlloc->Free ( szPrettyName );
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminGroups::MatchingGroup ( long iGroup, BSTR * pstrNewsgroup )
{
	TraceFunctEnter ( "CNntpAdminGroups::MatchingGroup" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pstrNewsgroup ) );

	HRESULT		hr			= NOERROR;

	if ( pstrNewsgroup == NULL ) {
		FatalTrace ( (LPARAM) this, "Bad return pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}

	*pstrNewsgroup = NULL;

	// Did we enumerate first?
	if ( m_pFindList == NULL ) {
		ErrorTrace ( (LPARAM) this, "Failed to call find first" );

		TraceFunctLeave ();
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_FIND );
	}
	
	// Is the index valid?
	if ( iGroup < 0 || (DWORD) iGroup >= m_cMatchingGroups ) {
		ErrorTraceX ( (LPARAM) this, "Invalid index: %d", iGroup );

		TraceFunctLeave ();
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	_ASSERT ( IS_VALID_STRING ( m_pFindList->aFindEntry [ iGroup ].lpszName ) );

	// Copy the property into the result:
	*pstrNewsgroup = ::SysAllocString ( m_pFindList->aFindEntry [ iGroup ].lpszName );

	if ( *pstrNewsgroup == NULL ) {

		// Allocation failed.
		FatalTrace ( 0, "Out of memory" );
		hr = E_OUTOFMEMORY;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminGroups::Find ( 
	BSTR strWildmat,
	long cMaxResults
	)
{
	TraceFunctEnter ( "CNntpAdminGroups::Find" );

	HRESULT		hr			= NOERROR;
	DWORD		dwError		= NOERROR;

	// Free the old newsgroup list:
	if ( m_pFindList ) {
		::NetApiBufferFree ( m_pFindList );
		m_pFindList		= NULL;
	}
	m_cMatchingGroups	= 0;

	dwError = NntpFindNewsgroup (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        strWildmat,
        cMaxResults,
        &m_cMatchingGroups,
        &m_pFindList
        );
	if ( dwError != 0 ) {
		ErrorTraceX ( (LPARAM) this, "Failed to find groups: %x", dwError );
		hr = RETURNCODETOHRESULT ( dwError );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT
CNntpAdminGroups::CancelMessage (
    BSTR    strMessageID
    )
{
    TraceFunctEnter ( "CNntpAdminGroups::CancelMessage" );

    HRESULT     hr          = NOERROR;
    DWORD       dwError     = NOERROR;
    LPSTR       szMessageID = NULL;
    int         cchMessageID = 0;

    if ( !strMessageID ) {
        BAIL_WITH_FAILURE( hr, E_INVALIDARG );
    }

    cchMessageID = WideCharToMultiByte ( CP_ACP, 0, strMessageID, -1, NULL, 0, NULL, NULL );

    szMessageID = new char [ cchMessageID ];
    if ( !szMessageID ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    WideCharToMultiByte ( CP_ACP, 0, strMessageID, -1, szMessageID, cchMessageID, NULL, NULL );

    dwError = NntpCancelMessageID (
        m_iadsImpl.QueryComputer (),
        m_iadsImpl.QueryInstance (),
        szMessageID
        );

    if ( dwError != 0 ) {
        BAIL_WITH_FAILURE ( hr, RETURNCODETOHRESULT ( dwError ) );
    }

Exit:
    delete [] szMessageID;

    TRACE_HRESULT(hr);
    TraceFunctLeave ();
    return hr;
}

HRESULT CNntpAdminGroups::AllocateMimeOleObjects ( )
{
	HRESULT		hr	= NOERROR;

	if ( !m_pMimeAlloc ) {
	    hr = CoCreateInstance ( CLSID_IMimeAllocator,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_IMimeAllocator,
								(void **) &m_pMimeAlloc
								);
	    BAIL_ON_FAILURE(hr);
	}

	if ( !m_pMimeInternational ) {
	    hr = CoCreateInstance ( CLSID_IMimeInternational,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_IMimeInternational,
								(void **) &m_pMimeInternational
								);
	    BAIL_ON_FAILURE(hr);
	}

Exit:
	return hr;
}

HRESULT CNntpAdminGroups::UnicodeToMime2 ( LPCWSTR wszUnicode, LPSTR * pszMime2 )
{
    TraceQuietEnter("CNntpAdminGroups::UnicodeToMime2");

	_ASSERT ( IS_VALID_OUT_PARAM ( pszMime2 ) );

	HRESULT			hr = S_OK;
    PROPVARIANT    	pvSrc;
    RFC1522INFO    	rfc1522info;
    HCHARSET        hCharset = NULL;

	ZeroMemory ( &pvSrc, sizeof (pvSrc) );
	ZeroMemory ( &rfc1522info, sizeof (rfc1522info) );

    if ( !wszUnicode || !*wszUnicode ) {
        *pszMime2 = NULL;
        goto Exit;
    }

	_ASSERT ( IS_VALID_STRING ( wszUnicode ) );

	hr = AllocateMimeOleObjects ();
	BAIL_ON_FAILURE(hr);

    pvSrc.vt        = VT_LPWSTR;
    pvSrc.pwszVal   = const_cast<LPWSTR> (wszUnicode);

    rfc1522info.fRfc1522Used    = TRUE;
    rfc1522info.fRfc1522Allowed = TRUE;
    rfc1522info.fAllow8bit		= FALSE;

    // Try to get the UTF-8 character set
    hr = m_pMimeInternational->FindCharset("UTF-8", &hCharset);
    if (FAILED(hr)) {
        ErrorTrace(0, "Error getting UTF-8 character set, %x", hr);
        hCharset = NULL;
    }

    hr = m_pMimeInternational->EncodeHeader ( 
    		hCharset, 
    		&pvSrc, 
    		pszMime2, 
    		&rfc1522info 
    		);
    _ASSERT ( SUCCEEDED(hr) );
    BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

HRESULT CNntpAdminGroups::Mime2ToUnicode ( LPCSTR szMime2, CComBSTR & strUnicode )
{
	_ASSERT ( IS_VALID_IN_PARAM (szMime2) );

	HRESULT			hr = S_OK;
    PROPVARIANT    	pvDest;
    RFC1522INFO    	rfc1522info;

	ZeroMemory ( &pvDest, sizeof (pvDest) );
	ZeroMemory ( &rfc1522info, sizeof (rfc1522info) );

    if ( !szMime2 || !*szMime2 ) {
        strUnicode = _T("");
        goto Exit;
    }

	hr = AllocateMimeOleObjects ();
	BAIL_ON_FAILURE(hr);

    pvDest.vt        = VT_LPWSTR;

    rfc1522info.fRfc1522Used    = TRUE;
    rfc1522info.fRfc1522Allowed = TRUE;
    rfc1522info.fAllow8bit		= TRUE;

    hr = m_pMimeInternational->DecodeHeader ( 
    		NULL, 
    		const_cast<LPSTR> (szMime2), 
    		&pvDest, 
    		&rfc1522info 
    		);
    _ASSERT ( SUCCEEDED(hr) );
    BAIL_ON_FAILURE(hr);

	_ASSERT ( pvDest.vt == VT_LPWSTR );

	strUnicode	= pvDest.pwszVal;
	if ( !strUnicode ) {
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
	}

Exit:
	m_pMimeAlloc->PropVariantClear ( &pvDest );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\groups.h ===
// groups.h : Declaration of the CNntpAdminGroups


/////////////////////////////////////////////////////////////////////////////
// Dependencies:

#include "nntptype.h"
#include "nntpapi.h"
#include <mimeole.h>

/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpAdminGroups : 
	public INntpAdminGroups,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdminGroups,&CLSID_CNntpAdminGroups>
{
public:
	CNntpAdminGroups();
	virtual ~CNntpAdminGroups();
BEGIN_COM_MAP(CNntpAdminGroups)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(INntpAdminGroups)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdminGroups) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdminGroups, _T("Nntpadm.Groups.1"), _T("Nntpadm.Groups"), IDS_NNTPADMINGROUPS_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_NNTPADMLib
	#define THIS_IID	IID_INntpAdminGroups
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// INntpAdminGroups
public:

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Enumeration Properties:

	STDMETHODIMP	get_Count	( long * plCount );

	// Newsgroup Properties:

	STDMETHODIMP	get_Newsgroup	( BSTR * pstrNewsgroup );
	STDMETHODIMP	put_Newsgroup	( BSTR strNewsgroup );

	STDMETHODIMP	get_Description	( BSTR * pstrDescription );
	STDMETHODIMP	put_Description	( BSTR strDescription );

	STDMETHODIMP	get_PrettyName  ( BSTR * pstrPrettyName );
	STDMETHODIMP	put_PrettyName  ( BSTR strPrettyName );

	STDMETHODIMP	get_IsModerated	( BOOL * pfIsModerated );
	STDMETHODIMP	put_IsModerated	( BOOL fIsModerated );

	STDMETHODIMP	get_Moderator	( BSTR * pstrModerator );
	STDMETHODIMP	put_Moderator	( BSTR strModerator );

	STDMETHODIMP	get_ReadOnly	( BOOL * pfReadOnly );
	STDMETHODIMP	put_ReadOnly	( BOOL fReadOnly );

	STDMETHODIMP	get_CreationTime	( DATE * pdateCreation );
	STDMETHODIMP	put_CreationTime	( DATE dateCreation );

	STDMETHODIMP	get_MatchingCount	( long * plCount );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Default	( );
	STDMETHODIMP	Add		( );
	STDMETHODIMP	Remove	( BSTR strNewsgroup );
	STDMETHODIMP	Get		( BSTR strNewsgroup );
	STDMETHODIMP	Set		( );

	STDMETHODIMP	MatchingGroup	( long iGroup, BSTR * pstrNewsgroup );
	STDMETHODIMP	Find			( BSTR strWildmat, long cMaxResults );

	STDMETHODIMP	CancelMessage	( BSTR strMessageID );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	CComPtr<IMimeAllocator>		m_pMimeAlloc;
	CComPtr<IMimeInternational>	m_pMimeInternational;

	CComBSTR	m_strNewsgroup;
	CComBSTR	m_strDescription;
	CComBSTR	m_strPrettyName;
	BOOL		m_fModerated;
	CComBSTR	m_strModerator;
	BOOL		m_fReadOnly;
    DATE        m_dateCreation;

	DWORD				m_cMatchingGroups;
	LPNNTP_FIND_LIST	m_pFindList;

	HRESULT		AllocateMimeOleObjects	 ( );
	HRESULT		UnicodeToMime2	( LPCWSTR wszUnicode, LPSTR * pszMime2 );
	HRESULT		Mime2ToUnicode	( LPCSTR szMime2, CComBSTR & strUnicode );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\feeds.h ===
// feeds.h : Declaration of the CNntpAdminFeeds


/////////////////////////////////////////////////////////////////////////////
// Dependencies:

#include "feedinfo.h"

/////////////////////////////////////////////////////////////////////////////
// CNntpOneWayFeed:

class CNntpOneWayFeed: 
	public CComDualImpl<INntpOneWayFeed, &IID_INntpOneWayFeed, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpOneWayFeed,&CLSID_CNntpOneWayFeed>
{
	friend class CFeed;

public:
	CNntpOneWayFeed();
	virtual ~CNntpOneWayFeed ();
BEGIN_COM_MAP(CNntpOneWayFeed)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpOneWayFeed)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpOneWayFeed) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpOneWayFeed, _T("Nntpadm.OneWayFeed.1"), _T("Nntpadm.OneWayFeed"), IDS_NNTPONEWAYFEED_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpOneWayFeed
public:
	STDMETHODIMP	get_FeedId			( long * plFeedId );
	STDMETHODIMP	get_RemoteServer	( BSTR * pstrRemoteServer );

	STDMETHODIMP	get_FeedAction	( NNTP_FEED_ACTION * pfeedaction );
	STDMETHODIMP	put_FeedAction	( NNTP_FEED_ACTION feedaction );

	STDMETHODIMP	get_UucpName	( BSTR * pstrUucpName );
	STDMETHODIMP	put_UucpName	( BSTR strUucpName );

	STDMETHODIMP	get_PullNewsDate	( DATE * pdatePullNews );
	STDMETHODIMP	put_PullNewsDate	( DATE datePullNews );

	STDMETHODIMP	get_FeedInterval	( long * plFeedInterval );
	STDMETHODIMP	put_FeedInterval	( long lFeedInterval );

	STDMETHODIMP	get_AutoCreate	( BOOL * pfAutoCreate );
	STDMETHODIMP	put_AutoCreate	( BOOL fAutoCreate );

	STDMETHODIMP	get_Enabled	( BOOL * pfEnabled );
	STDMETHODIMP	put_Enabled	( BOOL fEnabled );

	STDMETHODIMP	get_MaxConnectionAttempts	( long * plMaxConnectionAttempts );
	STDMETHODIMP	put_MaxConnectionAttempts	( long lMaxConnectionAttempts );

	STDMETHODIMP	get_SecurityType	( long * plSecurityType );
	STDMETHODIMP	put_SecurityType	( long lSecurityType );

	STDMETHODIMP	get_AuthenticationType	( long * plAuthenticationType );
	STDMETHODIMP	put_AuthenticationType	( long lAuthenticationType );

	STDMETHODIMP	get_AccountName	( BSTR * pstrAccountName );
	STDMETHODIMP	put_AccountName	( BSTR strAccountName );

	STDMETHODIMP	get_Password	( BSTR * pstrPassword );
	STDMETHODIMP	put_Password	( BSTR strPassword );

	STDMETHODIMP	get_AllowControlMessages	( BOOL * pfAllowControlMessages );
	STDMETHODIMP	put_AllowControlMessages	( BOOL fAllowControlMessages );

	STDMETHODIMP	get_OutgoingPort	( long * plOutgoingPort );
	STDMETHODIMP	put_OutgoingPort	( long lOutgoingPort );

	STDMETHODIMP	get_Newsgroups	( SAFEARRAY ** ppsastrNewsgroups );
	STDMETHODIMP	put_Newsgroups	( SAFEARRAY * psastrNewsgroups );

	STDMETHODIMP	get_NewsgroupsVariant	( SAFEARRAY ** ppsastrNewsgroups );
	STDMETHODIMP	put_NewsgroupsVariant	( SAFEARRAY * psastrNewsgroups );

	STDMETHODIMP	get_Distributions	( SAFEARRAY ** ppsastrDistributions );
	STDMETHODIMP	put_Distributions	( SAFEARRAY * psastrDistributions );

	STDMETHODIMP	get_TempDirectory	( BSTR * pstrTempDirectory );
	STDMETHODIMP	put_TempDirectory	( BSTR strTempDirectory );

	STDMETHODIMP	Default		( );

private:
    //
    //  Each one-way feed corresponds to an NNTP_FEED_INFO struct.
    //
    CFeed   m_feed;
};

/////////////////////////////////////////////////////////////////////////////
// CNntpFeed:

class CNntpFeed: 
	public CComDualImpl<INntpFeed, &IID_INntpFeed, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpFeed,&CLSID_CNntpFeed>
{
	friend class CFeedPair;

public:
	CNntpFeed();
	virtual ~CNntpFeed ();
BEGIN_COM_MAP(CNntpFeed)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpFeed)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpFeed) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpFeed, _T("Nntpadm.Feed.1"), _T("Nntpadm.Feed"), IDS_NNTPFEED_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpFeed
public:
	STDMETHODIMP	get_RemoteServer	( BSTR * pstrServerName );
	STDMETHODIMP	put_RemoteServer	( BSTR strServerName );

	STDMETHODIMP	get_FeedType	( NNTP_FEED_SERVER_TYPE * pfeedtype );
	STDMETHODIMP	put_FeedType	( NNTP_FEED_SERVER_TYPE feedtype );

    STDMETHODIMP    get_HasInbound	( BOOL * pfHasInbound );
    STDMETHODIMP    get_HasOutbound	( BOOL * pfHasOutbound );

	STDMETHODIMP	get_InboundFeed	( INntpOneWayFeed ** ppOneWayFeed );
	STDMETHODIMP	put_InboundFeed	( INntpOneWayFeed * pOneWayFeed );

	STDMETHODIMP	get_OutboundFeed	( INntpOneWayFeed ** ppOneWayFeed );
	STDMETHODIMP	put_OutboundFeed	( INntpOneWayFeed * pOneWayFeed );

	STDMETHODIMP	get_InboundFeedDispatch	( IDispatch ** ppOneWayFeed );
	STDMETHODIMP	put_InboundFeedDispatch	( IDispatch * pOneWayFeed );

	STDMETHODIMP	get_OutboundFeedDispatch	( IDispatch ** ppOneWayFeed );
	STDMETHODIMP	put_OutboundFeedDispatch	( IDispatch * pOneWayFeed );

private:
	HRESULT			FromFeedPair ( CFeedPair * pFeedPair );

private:
    CComBSTR                    m_strRemoteServer;
    NNTP_FEED_SERVER_TYPE		m_type;
    CComPtr<INntpOneWayFeed>    m_pInbound;
    CComPtr<INntpOneWayFeed>    m_pOutbound;
};

/////////////////////////////////////////////////////////////////////////////
// CNntpAdminFeeds:

class CNntpAdminFeeds : 
	public INntpAdminFeeds,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdminFeeds,&CLSID_CNntpAdminFeeds>
{
public:
	CNntpAdminFeeds();
	virtual ~CNntpAdminFeeds ();
BEGIN_COM_MAP(CNntpAdminFeeds)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(INntpAdminFeeds)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdminFeeds) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdminFeeds, _T("Nntpadm.Feeds.1"), _T("Nntpadm.Feeds"), IDS_NNTPADMINFEEDS_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_NNTPADMLib
	#define THIS_IID	IID_INntpAdminFeeds
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// INntpAdminFeeds
public:

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Enumeration Properties:

	STDMETHODIMP	get_Count	( long * plCount );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Enumerate	( );
	STDMETHODIMP	Item		( long lIndex, INntpFeed ** ppFeed );
	STDMETHODIMP	ItemDispatch( long lIndex, IDispatch ** ppFeed );
	STDMETHODIMP	FindID		( long lID, long * plIndex );
	STDMETHODIMP	Add			( INntpFeed * pFeed );
	STDMETHODIMP	AddDispatch	( IDispatch * pFeed );
	STDMETHODIMP	Set			( long lIndex, INntpFeed * pFeed );
	STDMETHODIMP	SetDispatch	( long lIndex, IDispatch * pFeed );
	STDMETHODIMP	Remove		( long lIndex );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	BOOL		m_fEnumerated;
    CFeedPairList   m_listFeeds;

	//////////////////////////////////////////////////////////////////////
	//	Private Methods:
	//////////////////////////////////////////////////////////////////////

	HRESULT		ReturnFeedPair ( CFeedPair * pFeedPair, INntpFeed * pFeed );
	long		IndexFromID ( long dwFeedId );
    long        FindFeedPair ( long dwFeedId );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\ipaccess.cpp ===
// ipaccess.cpp : Implementation of CTcpAccess & CTcpAccessExceptions.

#include "stdafx.h"

#include "pudebug.h"
#define _RDNS_STANDALONE
#include <rdns.hxx>

DECLARE_DEBUG_PRINTS_OBJECT()

#include "nntpcmn.h"
#include "cmultisz.h"
#include "ipaccess.h"
#include "oleutil.h"
#include "metautil.h"
#include "metakey.h"

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.TcpAccess.1")
#define THIS_FILE_IID				IID_ITcpAccess

//
//	Useful macros:
//

#define MAKEIPADDRESS(b1,b2,b3,b4) (((DWORD)(b1)<<24) +\
                                    ((DWORD)(b2)<<16) +\
                                    ((DWORD)(b3)<< 8) +\
                                    ((DWORD)(b4)))

#define GETIP_FIRST(x)             ((x>>24) & 0xff)
#define GETIP_SECOND(x)            ((x>>16) & 0xff)
#define GETIP_THIRD(x)             ((x>> 8) & 0xff)
#define GETIP_FOURTH(x)            ((x)     & 0xff)

inline void 
DWORDtoLPBYTE ( 
	IN	DWORD	dw, 
	OUT	LPBYTE	lpBytes 
	)
{
	_ASSERT ( !IsBadWritePtr ( lpBytes, 4 * sizeof ( BYTE ) ) ); 

	lpBytes[0] = (BYTE)GETIP_FIRST(dw);
	lpBytes[1] = (BYTE)GETIP_SECOND(dw);
	lpBytes[2] = (BYTE)GETIP_THIRD(dw);
	lpBytes[3] = (BYTE)GETIP_FOURTH(dw);
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccess::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccess,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccess::CTcpAccess ()
	// CComBSTR's are initialized to NULL by default.
{
	m_pGrantList		= NULL;
	m_pDenyList			= NULL;
}

CTcpAccess::~CTcpAccess ()
{
	// All CComBSTR's are freed automatically.

    if ( m_pGrantList ) {
        m_pGrantList->Release ();
    }
    if ( m_pDenyList ) {
        m_pDenyList->Release ();
    }
}

HRESULT CTcpAccess::GetAddressCheckFromMetabase ( CMetabaseKey * pMB, ADDRESS_CHECK * pAC )
{
	HRESULT				hr		= NOERROR;
	DWORD				dwDummy	= 0;
	DWORD				cbIpSec	= 0;
	BYTE *				pIpSec	= NULL;

	hr = pMB->GetDataSize ( _T(""), MD_IP_SEC, BINARY_METADATA, &cbIpSec, METADATA_INHERIT, IIS_MD_UT_FILE );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		hr = NOERROR;
		cbIpSec = 0;
	}
	BAIL_ON_FAILURE ( hr );

	if ( cbIpSec != 0 ) {
		pIpSec = new BYTE [ cbIpSec ];
		if ( !pIpSec ) {
			BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
		}

		hr = pMB->GetBinary ( MD_IP_SEC, pIpSec, cbIpSec, METADATA_INHERIT, IIS_MD_UT_FILE );
		BAIL_ON_FAILURE (hr);

		pAC->BindCheckList ( pIpSec, cbIpSec );
	}

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Private admin object interface:
//////////////////////////////////////////////////////////////////////

HRESULT CTcpAccess::GetFromMetabase ( CMetabaseKey * pMB )
{
    HRESULT     	hr	= NULL;
	CComObject<CTcpAccessExceptions> *	pGrantList	= NULL;
	CComObject<CTcpAccessExceptions> *	pDenyList	= NULL;

    ADDRESS_CHECK	ac;

	hr = GetAddressCheckFromMetabase ( pMB, &ac );
	BAIL_ON_FAILURE ( hr );

	hr = CComObject<CTcpAccessExceptions>::CreateInstance ( &pGrantList );
	BAIL_ON_FAILURE(hr);

	hr = CComObject<CTcpAccessExceptions>::CreateInstance ( &pDenyList );
	BAIL_ON_FAILURE(hr);

	//
	//	Copy each list into our object:
	//

	hr = pGrantList->FromAddressCheck ( &ac, TRUE );
	BAIL_ON_FAILURE(hr);

	hr = pDenyList->FromAddressCheck ( &ac, FALSE );
	BAIL_ON_FAILURE(hr);

	//
	//	Replace the old grant & deny lists with the new ones:
	//

    if ( m_pGrantList ) {
        m_pGrantList->Release ();
        m_pGrantList = NULL;
    }
    if ( m_pDenyList ) {
        m_pDenyList->Release ();
        m_pDenyList = NULL;
    }

    m_pGrantList    = pGrantList;
    m_pDenyList     = pDenyList;

    m_pGrantList->AddRef ();
    m_pDenyList->AddRef ();

Exit:
	ac.UnbindCheckList ();

	if ( FAILED(hr) ) {
		delete pGrantList;
		delete pDenyList;
	}

	return hr;
}

HRESULT CTcpAccess::SendToMetabase ( CMetabaseKey * pMB )
{
	HRESULT			hr;
	ADDRESS_CHECK	ac;
	BYTE *			pIpSec	= NULL;
	DWORD			cbIpSec	= 0;

	_ASSERT ( m_pGrantList );
	_ASSERT ( m_pDenyList );

	ac.BindCheckList ();

	hr = m_pGrantList->ToAddressCheck ( &ac, TRUE );
	BAIL_ON_FAILURE(hr);

	hr = m_pDenyList->ToAddressCheck ( &ac, FALSE );
	BAIL_ON_FAILURE(hr);

	cbIpSec	= ac.QueryCheckListSize ();
	pIpSec	= ac.QueryCheckListPtr ();

	hr = pMB->SetBinary ( MD_IP_SEC, pIpSec, cbIpSec, METADATA_INHERIT | METADATA_REFERENCE, IIS_MD_UT_FILE );

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccess::get_GrantedList ( ITcpAccessExceptions ** ppGrantedList )
{
	return m_pGrantList->QueryInterface ( IID_ITcpAccessExceptions, (void **) ppGrantedList );
}

STDMETHODIMP CTcpAccess::get_DeniedList ( ITcpAccessExceptions ** ppDeniedList )
{
	return m_pDenyList->QueryInterface ( IID_ITcpAccessExceptions, (void **) ppDeniedList );
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccessExceptions::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccessExceptions,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccessExceptions::CTcpAccessExceptions () :
	m_cCount	( 0 ),
	m_rgItems	( NULL )
	// CComBSTR's are initialized to NULL by default.
{
}

CTcpAccessExceptions::~CTcpAccessExceptions ()
{
	// All CComBSTR's are freed automatically.
}

HRESULT 
CTcpAccessExceptions::FromAddressCheck ( 
	ADDRESS_CHECK * pAC, 
	BOOL fGrantList 
	)
{
	HRESULT		hr	= NOERROR;
	DWORD		cNames;
	DWORD		cAddresses;
	DWORD		i;

	cNames		= pAC->GetNbName ( fGrantList );
	cAddresses	= pAC->GetNbAddr ( fGrantList );

	//
	//	Copy the Dns Names:
	//

	for ( i = 0; i < cNames; i++ ) {
		DWORD		dwFlags	= 0;
		LPSTR		lpName	= NULL;
		CComBSTR	strDomain;

		if ( pAC->GetName ( fGrantList, i, &lpName, &dwFlags ) ) {

			if ( !(dwFlags & DNSLIST_FLAG_NOSUBDOMAIN) ) {
				strDomain = _T("*.");

				strDomain.Append ( lpName );
			}
			else {
				strDomain = lpName;
			}

			hr = AddDnsName ( strDomain );
			BAIL_ON_FAILURE(hr);
		}
	}

	//
	//	Copy the IpAddresses:
	//

	for ( i = 0; i < cAddresses; i++ ) {
		DWORD		dwFlags	= 0;
		LPBYTE		lpMask	= NULL;
		LPBYTE		lpAddr	= NULL;
		DWORD		dwIpAddress;
		DWORD		dwIpMask;

		if ( pAC->GetAddr ( fGrantList, i, &dwFlags, &lpMask, &lpAddr ) ) {

			dwIpAddress	= MAKEIPADDRESS( lpAddr[0], lpAddr[1], lpAddr[2], lpAddr[3] );
			dwIpMask	= MAKEIPADDRESS( lpMask[0], lpMask[1], lpMask[2], lpMask[3] );

			hr = AddIpAddress ( (long) dwIpAddress, (long) dwIpMask );
			BAIL_ON_FAILURE(hr);
		}
	}

Exit:
	return hr;
}

HRESULT 
CTcpAccessExceptions::ToAddressCheck ( 
	ADDRESS_CHECK * pAC, 
	BOOL fGrantList
	)
{
	HRESULT		hr	= NOERROR;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		BOOL	fIsName	= FALSE;
		BOOL	fIsAddr	= FALSE;

		m_rgItems[i]->get_IsDnsName		( &fIsName );
		m_rgItems[i]->get_IsIpAddress	( &fIsAddr );

		if ( fIsName ) {
			CComBSTR	strDnsName;
			DWORD		cchName		= 0;
			LPSTR		szAnsiName	= NULL;

			DWORD		dwFlags		= 0;
			LPSTR		lpName		= NULL;

			hr = m_rgItems[i]->get_DnsName ( &strDnsName );
			BAIL_ON_FAILURE(hr);

			cchName = strDnsName.Length ( );

			szAnsiName = new char [ cchName + 1 ];
			if ( !szAnsiName ) {
				BAIL_WITH_FAILURE( hr, E_OUTOFMEMORY );
			}

			WideCharToMultiByte ( CP_ACP, 0, strDnsName, -1, szAnsiName, cchName + 1, NULL, NULL );

			if ( strncmp ( szAnsiName, "*.", 2 ) == 0 ) {
				dwFlags	= 0;
				lpName	= szAnsiName + 2;
			}
			else {
				dwFlags |= DNSLIST_FLAG_NOSUBDOMAIN;
				lpName	= szAnsiName;
			}
			pAC->AddName ( fGrantList, lpName, dwFlags );

			delete szAnsiName;
		}
		else if ( fIsAddr ) {
			long	lIpAddress	= 0;
			long	lIpMask		= 0;
			BYTE	bIp[4];
			BYTE	bMask[4];

			m_rgItems[i]->get_IpAddress ( &lIpAddress );
			m_rgItems[i]->get_IpMask	( &lIpMask );

			DWORDtoLPBYTE ( (DWORD) lIpAddress, bIp );
			DWORDtoLPBYTE ( (DWORD) lIpMask, bMask );

			pAC->AddAddr ( fGrantList, AF_INET, bMask, bIp );
		}
	}

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccessExceptions::get_Count ( long * pcCount )
{
	return StdPropertyGet ( m_cCount, pcCount );
}

STDMETHODIMP CTcpAccessExceptions::AddDnsName ( BSTR strDnsName )
{
	HRESULT							hr					= NOERROR;
	CComPtr<ITcpAccessException>	pNew;

	hr = CTcpAccessException::CreateNew ( strDnsName, &pNew );
	BAIL_ON_FAILURE ( hr );

	hr = AddItem ( pNew );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::AddIpAddress ( long lIpAddress, long lIpMask )
{
	HRESULT							hr					= NOERROR;
	CComPtr<ITcpAccessException>	pNew;

	hr = CTcpAccessException::CreateNew ( lIpAddress, lIpMask, &pNew );
	BAIL_ON_FAILURE ( hr );

	hr = AddItem ( pNew );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

HRESULT CTcpAccessExceptions::AddItem ( ITcpAccessException * pNew )
{
	HRESULT							hr			= NOERROR;
	CComPtr<ITcpAccessException> *	rgNewItems	= NULL;
	long							i;

	rgNewItems = new CComPtr<ITcpAccessException> [ m_cCount + 1 ];
	if ( !rgNewItems ) {
		BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
	}

	for ( i = 0; i < m_cCount; i++ ) {
		rgNewItems[i] = m_rgItems[i];
	}
	rgNewItems[m_cCount] = pNew;

	delete [] m_rgItems;
	m_rgItems = rgNewItems;
	m_cCount++;

Exit:
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::Item ( long index, ITcpAccessException ** ppTcpAccessException )
{
	HRESULT		hr;

	if ( index < 0 || index >= m_cCount ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	hr = m_rgItems[index]->QueryInterface ( IID_ITcpAccessException, (void **) ppTcpAccessException );
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::Remove ( long index )
{
	HRESULT					hr		= NOERROR;
	CComPtr<ITcpAccessException>	pTemp;
	long					i;

	if ( index < 0 || index >= m_cCount ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	for ( i = index + 1; i < m_cCount; i++ ) {
		m_rgItems[i - 1] = m_rgItems[i];
	}

	m_rgItems[m_cCount - 1].Release ();
	m_cCount--;

	return hr;
}

STDMETHODIMP 
CTcpAccessExceptions::FindDnsIndex (
	BSTR	strDnsNameToFind,
	long *	pIndex 
	)
{
	long		lResult	= -1;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		HRESULT		hr1;
		CComBSTR	strDnsName;
		BOOL		fIsDnsName	= FALSE;

		hr1 = m_rgItems[i]->get_IsDnsName ( &fIsDnsName );
		if ( !fIsDnsName ) {
			continue;
		}

		hr1 = m_rgItems[i]->get_DnsName ( &strDnsName );

		if ( SUCCEEDED(hr1) &&
			!lstrcmpi ( strDnsName, strDnsNameToFind ) ) {

			lResult = i;
			break;
		}
	}

	*pIndex = lResult;
	return NOERROR;
}

STDMETHODIMP 
CTcpAccessExceptions::FindIpIndex (
	long	lIpAddressToFind,
	long	lIpMaskToFind,
	long *	pIndex 
	)
{
	long		lResult	= -1;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		BOOL		fIsIpAddress	= FALSE;
		long		lIpAddress;
		long		lIpMask;

		m_rgItems[i]->get_IsIpAddress ( &fIsIpAddress );
		if ( !fIsIpAddress ) {
			continue;
		}

		m_rgItems[i]->get_IpAddress ( &lIpAddress );
		m_rgItems[i]->get_IpMask ( &lIpMask );

		if ( lIpAddress == lIpAddressToFind && lIpMask == lIpMaskToFind ) {
			lResult = i;
			break;
		}
	}

	*pIndex = lResult;
	return NOERROR;
}

STDMETHODIMP CTcpAccessExceptions::Clear ( )
{
	delete [] m_rgItems;
	m_rgItems	= NULL;
	m_cCount		= 0;

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccessException::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccessException,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccessException::CTcpAccessException () :
	m_fIsDnsName	( FALSE ),
	m_fIsIpAddress	( FALSE ),
	m_dwIpAddress	( 0 ),
	m_dwIpMask		( 0 )
	// CComBSTR's are initialized to NULL by default.
{
}

CTcpAccessException::~CTcpAccessException ()
{
	// All CComBSTR's are freed automatically.
}

HRESULT 
CTcpAccessException::CreateNew ( 
	LPWSTR strDnsName, 
	ITcpAccessException ** ppNew 
	)
{
	HRESULT		hr;
	CComObject<CTcpAccessException> *	pNew	= NULL;

	hr = CComObject<CTcpAccessException>::CreateInstance ( &pNew );
	BAIL_ON_FAILURE(hr);

	hr = pNew->put_DnsName ( strDnsName );
	BAIL_ON_FAILURE(hr);

	hr = pNew->QueryInterface ( IID_ITcpAccessException, (void **) ppNew );
	BAIL_ON_FAILURE(hr);

Exit:
	if ( FAILED(hr) ) {
		delete pNew;
	}

	return hr;
}

HRESULT 
CTcpAccessException::CreateNew ( 
	DWORD dwIpAddress, 
	DWORD dwIpMask, 
	ITcpAccessException ** ppNew 
	)
{
	HRESULT		hr;
	CComObject<CTcpAccessException> *	pNew	= NULL;

	hr = CComObject<CTcpAccessException>::CreateInstance ( &pNew );
	BAIL_ON_FAILURE(hr);

	hr = pNew->put_IpAddress ( (long) dwIpAddress );
	hr = pNew->put_IpMask ( (long) dwIpMask );

	hr = pNew->QueryInterface ( IID_ITcpAccessException, (void **) ppNew );
	BAIL_ON_FAILURE(hr);

Exit:
	if ( FAILED(hr) ) {
		delete pNew;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccessException::get_IsDnsName ( BOOL * pfIsDnsName )
{
	return StdPropertyGet ( m_fIsDnsName, pfIsDnsName );
}

STDMETHODIMP CTcpAccessException::get_IsIpAddress ( BOOL * pfIsIpAddress )
{
	return StdPropertyGet ( m_fIsIpAddress, pfIsIpAddress );
}

STDMETHODIMP CTcpAccessException::get_DnsName ( BSTR * pstrDnsName )
{
	return StdPropertyGet ( m_strDnsName, pstrDnsName );
}

STDMETHODIMP CTcpAccessException::put_DnsName ( BSTR strDnsName )
{
	HRESULT		hr;

	hr = StdPropertyPut ( &m_strDnsName, strDnsName );
	if ( SUCCEEDED(hr) ) {
		m_fIsDnsName	= TRUE;
		m_fIsIpAddress	= FALSE;
	}
	return hr;
}

STDMETHODIMP CTcpAccessException::get_IpAddress ( long * plIpAddress )
{
	return StdPropertyGet ( m_dwIpAddress, plIpAddress );
}

STDMETHODIMP CTcpAccessException::put_IpAddress ( long lIpAddress )
{
	HRESULT		hr;

	hr = StdPropertyPut ( &m_dwIpAddress, lIpAddress );
	if ( SUCCEEDED(hr) ) {
		m_fIsDnsName	= FALSE;
		m_fIsIpAddress	= TRUE;
	}
	return hr;
}

STDMETHODIMP CTcpAccessException::get_IpMask ( long * plIpMask )
{
	return StdPropertyGet ( m_dwIpMask, plIpMask );
}

STDMETHODIMP CTcpAccessException::put_IpMask ( long lIpMask )
{
	return StdPropertyPut ( &m_dwIpMask, lIpMask );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\metafact.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metafact.h

Abstract:

	Defines the CMetabaseFactory class.  This class deals with creating
	metabase objects, on either the local machine or a remote machine.

	The class provides a simple caching scheme where it will keep the name of
	the server the object was created on.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _METAFACT_INCLUDED_
#define _METAFACT_INCLUDED_

class CMetabaseFactory
{
public:
	CMetabaseFactory ();
	~CMetabaseFactory ();

	HRESULT	GetMetabaseObject	( LPCWSTR wszServer, IMSAdminBase ** ppMetabase );
	// You must call (*ppMetabase)->Release() after using the metabase object.

private:
	BOOL	IsCachedMetabase	( LPCWSTR wszServer );
	BOOL	SetServerName		( LPCWSTR wszServer );
	void	DestroyMetabaseObject	( );
	
	LPWSTR		m_wszServerName;
	IMSAdminBase *	m_pMetabase;
};

#endif // _METAFACT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\ipaccess.h ===
//
//	Dependencies
//

class ADDRESS_CHECK;
class CTcpAccess;
class CTcpAccessExceptions;
class CTcpAccessException;
class CMetabaseKey;

/////////////////////////////////////////////////////////////////////////////
// The TcpAccess Object

class CTcpAccess : 
	public CComDualImpl<ITcpAccess, &IID_ITcpAccess, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccess();
	virtual ~CTcpAccess ();

BEGIN_COM_MAP(CTcpAccess)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccess)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccess) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccess, _T("Nntpadm.TcpAccess.1"), _T("Nntpadm.TcpAccess"), IDS_TCPACCESS_DESC, THREADFLAGS_BOTH)
// Private admin object interface:
public:
	HRESULT			GetFromMetabase ( CMetabaseKey * pMB );
	HRESULT			SendToMetabase ( CMetabaseKey * pMB );

// ITcpAccess
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_GrantedList	( ITcpAccessExceptions ** ppGrantedList );
	STDMETHODIMP	get_DeniedList	( ITcpAccessExceptions ** ppDeniedList );
/*
	STDMETHODIMP	put_GrantedList	( ITcpAccessExceptions * pGrantedList );
	STDMETHODIMP	put_DeniedList	( ITcpAccessExceptions * pDeniedList );
*/
	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComObject<CTcpAccessExceptions> *	m_pGrantList;
	CComObject<CTcpAccessExceptions> *	m_pDenyList;

	HRESULT	GetAddressCheckFromMetabase ( CMetabaseKey * pMB, ADDRESS_CHECK * pAC );
};

/////////////////////////////////////////////////////////////////////////////
// The TcpAccessExceptions Object

class CTcpAccessExceptions : 
	public CComDualImpl<ITcpAccessExceptions, &IID_ITcpAccessExceptions, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccessExceptions();
	virtual ~CTcpAccessExceptions ();

BEGIN_COM_MAP(CTcpAccessExceptions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccessExceptions)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccessExceptions) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccessExceptions, _T("Nntpadm.TcpAccessExceptions.1"), _T("Nntpadm.TcpAccessExceptions"), IDS_TCPACCESSEXCEPTIONS_DESC, THREADFLAGS_BOTH)
//
//	Private admin object interface:
//
	HRESULT FromAddressCheck ( ADDRESS_CHECK * pAC, BOOL fGrant );
	HRESULT ToAddressCheck ( ADDRESS_CHECK * pAC, BOOL fGrant );

// ITcpAccessExceptions
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_Count	( long * pcCount );
	STDMETHODIMP	AddDnsName	( BSTR strDnsName );
	STDMETHODIMP	AddIpAddress( long lIpAddress, long lIpMask );
	STDMETHODIMP	Item		( long index, ITcpAccessException ** ppAccessException );
	STDMETHODIMP	Remove		( long index );
	STDMETHODIMP	FindDnsIndex( BSTR strDnsName, long * pIndex );
	STDMETHODIMP	FindIpIndex	( long lIpAddress, long lIpMask, long * pIndex );
	STDMETHODIMP	Clear		( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:
	long							m_cCount;
	CComPtr<ITcpAccessException> *	m_rgItems;

	HRESULT	AddItem ( ITcpAccessException * pNew );
};

class CTcpAccessException : 
	public CComDualImpl<ITcpAccessException, &IID_ITcpAccessException, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccessException();
	virtual ~CTcpAccessException ();

	static HRESULT CreateNew ( LPWSTR strDnsName, ITcpAccessException ** ppNew );
	static HRESULT CreateNew ( DWORD dwIpAddress, DWORD dwIpMask, ITcpAccessException ** ppNew );

BEGIN_COM_MAP(CTcpAccessException)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccessException)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccessException) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccessException, _T("Nntpadm.TcpAccessException.1"), _T("Nntpadm.TcpAccessException"), IDS_TCPACCESSEXCEPTION_DESC, THREADFLAGS_BOTH)
// ITcpAccessException
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_IsDnsName	( BOOL * pfIsDnsName );
	STDMETHODIMP	get_IsIpAddress	( BOOL * pfIsIpAddress );

	STDMETHODIMP	get_DnsName	( BSTR * pstrDnsName );
	STDMETHODIMP	put_DnsName	( BSTR strDnsName );

	STDMETHODIMP	get_IpAddress	( long * plIpAddress );
	STDMETHODIMP	put_IpAddress	( long lIpAddress );

	STDMETHODIMP	get_IpMask	( long * plIpMask );
	STDMETHODIMP	put_IpMask	( long lIpMask );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:
	CComBSTR	m_strDnsName;
	DWORD		m_dwIpAddress;
	DWORD		m_dwIpMask;
	BOOL		m_fIsDnsName;
	BOOL		m_fIsIpAddress;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\metafact.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metafact.cpp

Abstract:

	The CMetabaseFactory class.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "nntpcmn.h"
#include "oleutil.h"

#include "metautil.h"
#include "metafact.h"

CMetabaseFactory::CMetabaseFactory ( ) :
	m_wszServerName	( NULL ),
	m_pMetabase		( NULL )
{
}

CMetabaseFactory::~CMetabaseFactory ()
{
	if ( m_wszServerName ) {
		delete m_wszServerName;
		m_wszServerName = NULL;
	}

	DestroyMetabaseObject ( );
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::DestroyMetabaseObject
//
//	Description:
//
//		Destroys the current metabase object.  This includes calling
//		the terminate routine on the metabase.
//
//--------------------------------------------------------------------

void CMetabaseFactory::DestroyMetabaseObject ( )
{
	TraceQuietEnter ( "CMetabaseFactory::DestroyMetabaseObject" );
	
	if ( m_pMetabase ) {
		_VERIFY ( m_pMetabase->Release () == 0 );
		m_pMetabase = NULL;
	}
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::GetMetabaseObject
//
//	Description:
//
//		Returns an interface to the metabase.  If the metabase object
//		hasn't been created on the same machine, it is created.
//
//	Parameters:
//
//		wszServer - remote machine to create object on, or NULL for local machine.
//		ppMetabaseResult - returns the interface pointer if successful.
//			client has the responsibility to Release this pointer.
//
//	Returns:
//
//		hresult.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseFactory::GetMetabaseObject	( LPCWSTR wszServer, IMSAdminBase ** ppMetabaseResult )
{
	TraceFunctEnter ( "CMetabaseFactory::GetMetabaseObject" );

	// Validate parameters:
	_ASSERT ( ppMetabaseResult != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppMetabaseResult ) );

	if ( ppMetabaseResult == NULL ) {
		FatalTrace ( (LPARAM) this, "Bad Return Pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}
	
	// Variables:
	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pNewMetabase;

	// Zero the out parameter:
	*ppMetabaseResult = NULL;

	// A server name of "" should be NULL:
	if ( wszServer && *wszServer == NULL ) {
		wszServer = NULL;
	}

	if ( IsCachedMetabase ( wszServer ) ) {
		// We've already got this metabase pointer.  Just return it.

		DebugTrace ( (LPARAM) this, "Returning Cached metabase" );
		_ASSERT ( m_pMetabase );

		*ppMetabaseResult = m_pMetabase;
		m_pMetabase->AddRef ();

		hr = NOERROR;
		goto Exit;
	}

	// We have to create the metabase object:
	StateTrace ( (LPARAM) this, "Creating new metabase" );

	// Destroy the old metabase object:
	DestroyMetabaseObject ( );

	// Setup the server name field:
	if ( !SetServerName ( wszServer ) ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// m_wszServer = NULL is valid, it means the local machine.

	hr = CreateMetabaseObject ( m_wszServerName, &pNewMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Save the metabase pointer:
	m_pMetabase	= pNewMetabase;
	pNewMetabase->AddRef ();

	// Return the interface pointer:
	*ppMetabaseResult = pNewMetabase;
	pNewMetabase->AddRef ();

Exit:
	TraceFunctLeave ();
	return hr;

	// pMetabase will be released automatically.
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::IsCachedMetabase
//
//	Description:
//
//		Returns TRUE if we have a metabase for the given server
//
//	Parameters:
//
//		wszServer - remote machine or NULL
//
//	Returns:
//
//		TRUE if we have a pointer already, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL CMetabaseFactory::IsCachedMetabase ( LPCWSTR wszServer )
{
	if ( !m_pMetabase ) {
		// We don't even have a cached metabase object.
		return FALSE;
	}

	if (
		// Both are the local machine OR
		( m_wszServerName == NULL && wszServer == NULL ) ||
		// Both are the same remote machine
		( m_wszServerName && wszServer && !lstrcmpi ( m_wszServerName, wszServer ) ) ) {

		// It's a match
		return TRUE;
	}

	// No dice...
	return FALSE;
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::SetServerName
//
//	Description:
//
//		Sets the m_wszServerName string.
//
//	Parameters:
//
//		wszServer - The new servername.  Can be NULL.
//
//	Returns:
//
//		FALSE on failure due to lack of memory.
//
//--------------------------------------------------------------------

BOOL CMetabaseFactory::SetServerName ( LPCWSTR wszServer ) 
{
	TraceQuietEnter ( "CMetabaseFactory::SetServerName" );

	delete m_wszServerName;
	m_wszServerName = NULL;

	if ( wszServer != NULL ) {
		_ASSERT ( IS_VALID_STRING ( wszServer ) );

		m_wszServerName = new WCHAR [ lstrlen ( wszServer ) + 1 ];

		if ( m_wszServerName == NULL ) {
			FatalTrace ( (LPARAM) this, "Out of Memory" );
			return FALSE;
		}

		lstrcpy ( m_wszServerName, wszServer );
	}
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\metautil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metautil.cpp

Abstract:

	Useful functions for dealing with the metabase

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "nntpcmn.h"

#include "cmultisz.h"
#include "oleutil.h"
#include "metautil.h"
#include "metakey.h"

// Metabase property manipulation:

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fDefault, BOOL * pfOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp<BOOL>" );

	HRESULT	hr;
	DWORD	dwTemp;

	hr = pMB->GetDword ( wszPath, dwID, &dwTemp, dwFlags, dwUserType );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		// Couldn't find property, use defaults.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );
		dwTemp = fDefault;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	*pfOut = dwTemp;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwDefault, DWORD * pdwOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp<DWORD>" );

	DWORD	dwTemp;
	HRESULT	hr;

	hr = pMB->GetDword ( wszPath, dwID, &dwTemp, dwFlags, dwUserType );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		// Couldn't find property, use defaults.

		DebugTraceX ( 0, "Using default for ID: %d", dwID );
		dwTemp = dwDefault;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	*pdwOut = dwTemp;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR wszDefault, BSTR * pstrOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp <BSTR>" );

	HRESULT	hr			= NOERROR;
	BSTR	strNew 		= NULL;
	DWORD	cbRequired	= 0;
	DWORD	cchRequired	= 0;
	BOOL	fUseDefault	= FALSE;

	// Get the length of the string to retrieve:
	hr = pMB->GetDataSize ( wszPath, dwID, STRING_METADATA, &cbRequired, dwFlags, dwUserType );
	cchRequired	= cbRequired / sizeof ( WCHAR );

	// Is the value there?
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {

		// No, so use the default that was passed in.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		fUseDefault	= TRUE;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	if ( !fUseDefault ) {

		strNew = ::SysAllocStringLen ( NULL, cbRequired );
		if ( !strNew ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		// Get the metabase string:
		hr = pMB->GetString ( wszPath, dwID, strNew, cbRequired, dwFlags, dwUserType );
		BAIL_ON_FAILURE(hr);
	}

	if ( fUseDefault ) {
		// Use the default:
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		strNew = ::SysAllocString ( wszDefault );
		if ( !strNew ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}
	}

	SAFE_FREE_BSTR ( *pstrOut );
	*pstrOut = strNew;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}
	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR mszDefault, CMultiSz * pmszOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp <CMultiSz>" );

	HRESULT	hr			= NOERROR;
	BSTR	strNew 		= NULL;
	DWORD	cbRequired	= 0;
	DWORD	cchRequired	= 0;
	BOOL	fUseDefault	= FALSE;
	LPWSTR	msz			= NULL;

	// Get the length of the string to retrieve:
	hr = pMB->GetDataSize ( wszPath, dwID, MULTISZ_METADATA, &cbRequired, dwFlags, dwUserType );
	cchRequired	= cbRequired / sizeof ( WCHAR );

	// Is the value there?
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {

		// No, so use the default that was passed in.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		fUseDefault	= TRUE;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	if ( !fUseDefault ) {

		msz = new WCHAR [ cchRequired ];
		if ( !msz ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		// Get the metabase string:
		hr = pMB->GetData ( wszPath, dwID, dwUserType, MULTISZ_METADATA, msz, &cbRequired, dwFlags );
		BAIL_ON_FAILURE(hr);

		*pmszOut = msz;
	}

	if ( fUseDefault ) {
		// Use the default:
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		*pmszOut = mszDefault;
	}

	if ( !*pmszOut ) {
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
	}

Exit:
	delete msz;

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}
	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BOOL>" );

	HRESULT		hr;

	hr = pMB->SetDword ( wszPath, dwID, fValue, dwFlags, dwUserType );

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <DWORD>" );

	HRESULT		hr;

	hr = pMB->SetDword ( wszPath, dwID, dwValue, dwFlags, dwUserType );

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BSTR strValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BSTR>" );

	_ASSERT ( strValue );

	HRESULT		hr;

	if ( !strValue ) {
		// Just skip it, but log the trace.
		FatalTrace ( 0, "strValue should not be NULL here" );
		return TRUE;
	}

	hr = pMB->SetString ( wszPath, dwID, strValue, dwFlags, dwUserType );
	BAIL_ON_FAILURE (hr);

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, CMultiSz * pmszValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BSTR>" );

	_ASSERT ( pmszValue );

	if ( !*pmszValue ) {
		// Just skip it, but log the trace.
		FatalTrace ( 0, "strValue should not be NULL here" );
		return TRUE;
	}

	HRESULT		hr;
	DWORD		cbMultiSz;
	LPCWSTR		wszValue;

	cbMultiSz	= pmszValue->SizeInBytes ();
	wszValue	= *pmszValue;

	hr = pMB->SetData ( wszPath, dwID, dwUserType, MULTISZ_METADATA, (void *) wszValue, cbMultiSz, dwFlags );
	BAIL_ON_FAILURE (hr);

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL HasKeyChanged ( IMSAdminBase * pMetabase, METADATA_HANDLE hKey, const FILETIME * pftLastChanged, LPCWSTR wszSubKey )
{
	TraceFunctEnter ( "HasKeyChanged" );

	FILETIME		ftNew;
	HRESULT			hr		= NOERROR;
	BOOL			fResult	= FALSE;

	if ( pftLastChanged->dwHighDateTime == 0 && pftLastChanged->dwLowDateTime == 0 ) {
		ErrorTrace ( 0, "Last changed time is NULL" );

		// No setting, so say it hasn't changed:
		goto Exit;
	}

	hr = pMetabase->GetLastChangeTime ( hKey, wszSubKey, &ftNew, FALSE );
	if ( FAILED (hr) ) {
		ErrorTrace ( 0, "Failed to get last change time: %x", hr );

		// This is an unexpected error.  Ignore it.
		goto Exit;
	}

	// Has the metabase been changed since last time?

	// Time can't go backwards:
	_ASSERT ( ftNew.dwHighDateTime >= pftLastChanged->dwHighDateTime );
	_ASSERT ( ftNew.dwLowDateTime >= pftLastChanged->dwLowDateTime ||
			ftNew.dwHighDateTime > pftLastChanged->dwHighDateTime );

	if ( ftNew.dwHighDateTime	!= pftLastChanged->dwHighDateTime ||
		 ftNew.dwLowDateTime	!= pftLastChanged->dwLowDateTime ) {

		fResult = TRUE;
	}

Exit:
	TraceFunctLeave ();
	return FALSE;
}

BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey )
{
	TraceQuietEnter ( "IsValidIntegerSubKey" );

	WCHAR	wszIntegerKey [ METADATA_MAX_NAME_LEN ];
	DWORD	dwItemValue;

	dwItemValue = _wtoi ( wszSubKey );
	wsprintf ( wszIntegerKey, _T("%d"), dwItemValue );

	// If the key is nonzero AND
	// The key is just the itoa value of the number:
	if ( dwItemValue != 0 &&
		 lstrcmp ( wszIntegerKey, wszSubKey ) == 0 ) {

		 return TRUE;
	}
	else {
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\makefile.inc ===
$(O)\nntpadm.h $(O)\nntpadm_i.c : $(STAXINC)\export\nntpadm.idl
    $(MIDL) \
    $(INCPATH0) \
    -proxy $(PASS0_SOURCEDIR)\nntpadm_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpadm_i.c \
    -header $@ \
    -tlb $(O)\nntpadm.tlb \
    $**

copytlb:
	xcopy /verifd $(IISBASEDIR)\svcs\adsi\oleds2.0\types\activeds.tlb $(O)

copyfiles:
!if "$(_NTTREE)" != ""
	if not exist $(_NTTREE)\staxpt mkdir $(_NTTREE)\staxpt
	xcopy /verifd scripts\rexpire.vbs $(_NTTREE)\staxpt
	xcopy /verifd scripts\rgroup.vbs $(_NTTREE)\staxpt
	xcopy /verifd scripts\rserver.vbs $(_NTTREE)\staxpt
	xcopy /verifd scripts\rsess.vbs $(_NTTREE)\staxpt
#	xcopy /verifd scripts\rfeed.vbs $(_NTTREE)\staxpt
!endif
!if "$(_NTTREE_NO_SPLIT)" != ""
	if not exist $(_NTTREE_NO_SPLIT)\staxpt mkdir $(_NTTREE_NO_SPLIT)\staxpt
	xcopy /verifd scripts\rexpire.vbs $(_NTTREE_NO_SPLIT)\staxpt
	xcopy /verifd scripts\rgroup.vbs $(_NTTREE_NO_SPLIT)\staxpt
	xcopy /verifd scripts\rserver.vbs $(_NTTREE_NO_SPLIT)\staxpt
	xcopy /verifd scripts\rsess.vbs $(_NTTREE_NO_SPLIT)\staxpt
#	xcopy /verifd scripts\rfeed.vbs $(_NTTREE_NO_SPLIT)\staxpt
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\metautil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metautil.h

Abstract:

	Useful functions for dealing with the metabase.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _METAUTIL_INCLUDED_
#define _METAUTIL_INCLUDED_

// Dependencies:

#include <iiscnfg.h>	// IIS Metabase Values
#include <iiscnfgp.h>
class CMultiSz;
class CMetabaseKey;

// Defaults:

#define MD_DEFAULT_TIMEOUT	5000

// Creating a metabase object:

HRESULT CreateMetabaseObject	( LPCWSTR wszMachine, IMSAdminBase ** ppMetabase );

// Metabase property manipulation:

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fDefault, BOOL * pfOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwDefault, DWORD * pdwOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR strDefault, BSTR * pstrOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR mszDefault, CMultiSz * pmszOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BSTR strValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, CMultiSz * pmszValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );

BOOL HasKeyChanged ( IMSAdminBase * pMetabase, METADATA_HANDLE hKey, const FILETIME * pftLastChanged, LPCWSTR wszSubKey = _T("") );

// Metabase lists:

BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey );

#endif // _METAUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\nntpadm.cpp ===
// nntpadm.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f nntpadmps.mak in the project directory.

#include "stdafx.h"
#include "nntpcmn.h"

#include "admin.h"
#include "expire.h"
#include "feeds.h"
#include "groups.h"
#include "rebuild.h"
#include "sessions.h"
#include "server.h"
#include "vroots.h"

/*
#include "propcach.h"
#include "service.h"
#include "virsrv.h"
*/

#include "regmacro.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CNntpAdmin, CNntpAdmin)
	OBJECT_ENTRY(CLSID_CNntpVirtualServer, CNntpVirtualServer)
	OBJECT_ENTRY(CLSID_CNntpAdminFeeds, CNntpAdminFeeds)
	OBJECT_ENTRY(CLSID_CNntpAdminExpiration, CNntpAdminExpiration)
	OBJECT_ENTRY(CLSID_CNntpAdminGroups, CNntpAdminGroups)
	OBJECT_ENTRY(CLSID_CNntpAdminSessions, CNntpAdminSessions)
	OBJECT_ENTRY(CLSID_CNntpAdminRebuild, CNntpAdminRebuild)
	OBJECT_ENTRY(CLSID_CNntpVirtualRoot, CNntpVirtualRoot)
	OBJECT_ENTRY(CLSID_CNntpFeed, CNntpFeed)
	OBJECT_ENTRY(CLSID_CNntpOneWayFeed, CNntpOneWayFeed)
//	OBJECT_ENTRY(CLSID_CNntpService, CNntpAdminService)
//	OBJECT_ENTRY(CLSID_CAdsNntpVirtualServer, CAdsNntpVirtualServer)
END_OBJECT_MAP()

BEGIN_EXTENSION_REGISTRATION_MAP
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsNntpExpires, NntpAdminExpiration)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsNntpFeeds, NntpAdminFeeds)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsNntpGroups, NntpAdminGroups)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsNntpRebuild, NntpAdminRebuild)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsNntpSessions, NntpAdminSessions)
END_EXTENSION_REGISTRATION_MAP

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
//		InitAsyncTrace ();
		
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
//		TermAsyncTrace ();
		
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// register extensions
	RegisterExtensions();

	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	// register extensions
	UnregisterExtensions();

	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\nntpcmn.h ===
// Common header file for the Nntp administration objects.

//
// Dependencies:
//

//
// Should put these files in the stdafx.h
//

#include "iadm.h"
#include "nntpadm.h"
#include "resource.h"

// Constants:

#define HELP_FILE_NAME		_T("nntpadm.hlp")

// Exception creation:

#define NntpCreateException(nDescriptionId) 	\
	CreateException ( 						\
		_Module.GetResourceInstance(), 		\
		THIS_FILE_IID, 						\
		HELP_FILE_NAME,						\
		THIS_FILE_HELP_CONTEXT,				\
		THIS_FILE_PROG_ID,					\
		(nDescriptionId) 					\
		)

#define NntpCreateExceptionFromHresult(hr)	\
	CreateExceptionFromHresult (			\
		_Module.GetResourceInstance(),		\
		THIS_FILE_IID,						\
		HELP_FILE_NAME,						\
		THIS_FILE_HELP_CONTEXT,				\
		THIS_FILE_PROG_ID,					\
		(hr)								\
		)

#define NntpCreateExceptionFromWin32Error(error)	\
	CreateExceptionFromWin32Error (					\
		_Module.GetResourceInstance(),				\
		THIS_FILE_IID,								\
		HELP_FILE_NAME,								\
		THIS_FILE_HELP_CONTEXT,						\
		THIS_FILE_PROG_ID,							\
		(error)										\
		)

// Property validation:

#define VALIDATE_STRING(string, maxlen) \
	if ( !PV_MaxChars ( (string), (maxlen) ) ) {	\
		return NntpCreateException ( IDS_NNTPEXCEPTION_STRING_TOO_LONG );	\
	}

#define VALIDATE_DWORD(dw, dwMin, dwMax)	\
	if ( !PV_MinMax ( (DWORD) (dw), (DWORD) (dwMin), (DWORD) (dwMax) ) ) {	\
		return NntpCreateException ( IDS_NNTPEXCEPTION_PROPERTY_OUT_OF_RANGE );	\
	}

#define VALIDATE_LONG(l, lMin, lMax)	\
	if ( !PV_MinMax ( (l), (lMin), (lMax) ) ) {	\
		return NntpCreateException ( IDS_NNTPEXCEPTION_PROPERTY_OUT_OF_RANGE );	\
	}

#define CHECK_FOR_SET_CURSOR(fEnumerated,fSetCursor)	\
{							\
	if ( !fEnumerated ) {	\
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );	\
	}						\
							\
	if ( !fSetCursor ) {	\
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_SET_CURSOR );	\
	}						\
}

// Metabase paths:

inline void GetMDInstancePath ( LPWSTR wszInstancePath, DWORD dwServiceInstance )
{
	wsprintf ( wszInstancePath, _T("%s%d/"), NNTP_MD_ROOT_PATH, dwServiceInstance );
}

//
//  Constants:
//

#define MAX_SLEEP_INST      30000
#define SLEEP_INTERVAL      500

#define MD_SERVICE_NAME      _T("NntpSvc")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\oleutil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	oleutil.h

Abstract:

	Defines some useful functions for dealing with OLE.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _OLEUTIL_INCLUDED_
#define _OLEUTIL_INCLUDED_

// Dependencies:

class CMultiSz;

// Common Property Operations:

HRESULT StdPropertyGet			( const BSTR strProperty, BSTR * ppstrOut );
HRESULT StdPropertyGet			( long lProperty, long * plOut );
HRESULT StdPropertyGet			( DATE dateProperty, DATE * pdateOut );
inline HRESULT StdPropertyGet	( DWORD lProperty, DWORD * pdwOut );
inline HRESULT StdPropertyGet	( BOOL fProperty, BOOL * plOut );
HRESULT StdPropertyGet			( const CMultiSz * pmszProperty, SAFEARRAY ** ppsaStrings );
HRESULT	StdPropertyGetBit		( DWORD bvBitVector, DWORD dwBit, BOOL * pfOut );

HRESULT StdPropertyPut			( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( long * plProperty, long lNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( DATE * pdateProperty, DATE dateNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
inline HRESULT StdPropertyPut	( DWORD * plProperty, long lNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
inline HRESULT StdPropertyPut	( BOOL * pfProperty, BOOL fNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( CMultiSz * pmszProperty, SAFEARRAY * psaStrings, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT	StdPropertyPutBit		( DWORD * pbvBitVector, DWORD dwBit, BOOL fIn );
inline HRESULT StdPropertyPutServerName	( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );

HRESULT LongArrayToVariantArray ( SAFEARRAY * psaLongs, SAFEARRAY ** ppsaVariants );
HRESULT StringArrayToVariantArray ( SAFEARRAY * psaStrings, SAFEARRAY ** ppsaVariants );
HRESULT VariantArrayToStringArray ( SAFEARRAY * psaVariants, SAFEARRAY ** ppsaStrings );

// Property Field Validation: (based on the mfc DDV_ routines)
// These routines return FALSE if the validation fails.

BOOL PV_MaxChars	( const BSTR strProperty,	DWORD nMaxChars );
BOOL PV_MinMax		( int nProperty,			int nMin,		int nMax );
BOOL PV_MinMax		( DWORD dwProperty,			DWORD dwMin,	DWORD dwMax );
BOOL PV_Boolean		( BOOL fProperty );

// Handing off IDispatch pointers:

template<class T> HRESULT StdPropertyHandoffIDispatch ( 
	REFCLSID clisd, 
	REFIID riid, 
	T ** ppIAdmin, 
	IDispatch ** ppIDispatchResult 
	);

HRESULT StdPropertyGetIDispatch ( REFCLSID clsid, IDispatch ** ppIDispatchResult );

// Internet addresses <-> Strings

BOOL InetAddressToString ( DWORD dwAddress, LPWSTR wszAddress, DWORD cAddress );
BOOL StringToInetAddress ( LPCWSTR wszAddress, DWORD * pdwAddress );

//--------------------------------------------------------------------
// Inlined functions:
//--------------------------------------------------------------------

inline HRESULT StdPropertyGet ( DWORD lProperty, DWORD * pdwOut )
{
	return StdPropertyGet ( (long) lProperty, (long *) pdwOut );
}

inline HRESULT StdPropertyGet ( BOOL fProperty, BOOL * plOut )
{
	// Make sure it's our kind of boolean:
	fProperty = !!fProperty;

	return StdPropertyGet ( (long) fProperty, (long *) plOut );
}

inline HRESULT StdPropertyPut ( DWORD * plProperty, long lNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	return StdPropertyPut ( (long *) plProperty, lNew, pbvChangedProps, dwBitMask );
}

inline HRESULT StdPropertyPut ( BOOL * pfProperty, BOOL fNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	// Make sure it's our kind of boolean:
	fNew = !!fNew;

	return StdPropertyPut ( (long *) pfProperty, (long) fNew, pbvChangedProps, dwBitMask );
}

inline HRESULT StdPropertyPutServerName ( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
    if ( strNew && lstrcmpi ( strNew, _T("localhost") ) == 0 ) {
        // Special case: localhost => ""

        return StdPropertyPut ( pstrProperty, _T(""), pbvChangedProps, dwBitMask );
    }

    return StdPropertyPut ( pstrProperty, strNew, pbvChangedProps, dwBitMask );
}

template<class T>
HRESULT StdPropertyHandoffIDispatch ( REFCLSID clsid, REFIID riid, T ** ppIAdmin, IDispatch ** ppIDispatchResult )
{
	// Validate parameters:
	_ASSERT ( ppIAdmin != NULL );
	_ASSERT ( ppIDispatchResult != NULL );

	if ( ppIAdmin == NULL || ppIDispatchResult == NULL ) {
		return E_POINTER;
	}

	// Variables:
	HRESULT	hr = NOERROR;
	CComPtr<T>	pIAdmin;

	// Zero the out parameters:
	*ppIAdmin 			= NULL;
	*ppIDispatchResult	= NULL;

	// Get the IDispatch pointer to return:
	hr = StdPropertyGetIDispatch ( 
		clsid, 
		ppIDispatchResult
		);
	if ( FAILED (hr) ) {
		goto Error;
	}

	// Get the specific interface pointer:
	hr = (*ppIDispatchResult)->QueryInterface ( riid, (void **) &pIAdmin );
	if ( FAILED (hr) ) {
		goto Error;
	}

	*ppIAdmin = pIAdmin;
	pIAdmin->AddRef ();

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatchResult );
	*ppIDispatchResult = NULL;

	return hr;

	// Destructor releases pINntpAdminExpiration
}

#endif // _OLEUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\rebuild.h ===
// Rebuild.h : Declaration of the CNntpAdminRebuild


/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpAdminRebuild : 
	public INntpAdminRebuild,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdminRebuild,&CLSID_CNntpAdminRebuild>
{
public:
	CNntpAdminRebuild();
	virtual ~CNntpAdminRebuild ();
BEGIN_COM_MAP(CNntpAdminRebuild)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(INntpAdminRebuild)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdminRebuild) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdminRebuild, _T("Nntpadm.Rebuild.1"), _T("Nntpadm.Rebuild"), IDS_NNTPADMINREBUILD_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_NNTPADMLib
	#define THIS_IID	IID_INntpAdminRebuild
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// INntpAdminRebuild
public:

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:

	STDMETHODIMP	get_Server			( BSTR * pstrServer );
	STDMETHODIMP	put_Server			( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	STDMETHODIMP	get_Verbose	( BOOL * pfVerbose );
	STDMETHODIMP	put_Verbose	( BOOL fVerbose );

	STDMETHODIMP	get_CleanRebuild	( BOOL * pfCleanRebuild );
	STDMETHODIMP	put_CleanRebuild	( BOOL fCleanRebuild );

	STDMETHODIMP	get_DontDeleteHistory	( BOOL * pfDontDeleteHistory );
	STDMETHODIMP	put_DontDeleteHistory	( BOOL fDontDeleteHistory );

	STDMETHODIMP	get_ReuseIndexFiles	( BOOL * pfReuseIndexFiles );
	STDMETHODIMP	put_ReuseIndexFiles	( BOOL fReuseIndexFiles );

	STDMETHODIMP	get_OmitNonLeafDirs	( BOOL * pfOmitNonLeafDirs );
	STDMETHODIMP	put_OmitNonLeafDirs	( BOOL fOmitNonLeafDirs );

	STDMETHODIMP	get_GroupFile	( BSTR * pstrGroupFile );
	STDMETHODIMP	put_GroupFile	( BSTR strGroupFile );

	STDMETHODIMP	get_ReportFile	( BSTR * pstrReportFile );
	STDMETHODIMP	put_ReportFile	( BSTR strReportFile );

	STDMETHODIMP	get_NumThreads	( long * plNumThreads );
	STDMETHODIMP	put_NumThreads	( long lNumThreads );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

    STDMETHODIMP    Default         ( );
	STDMETHODIMP	StartRebuild	( );
	STDMETHODIMP	GetProgress		( long * pdwProgress );
	STDMETHODIMP	Cancel			( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Property variables:
    CIADsImpl   m_iadsImpl;

	BOOL		m_fVerbose;
	BOOL		m_fCleanRebuild;
	BOOL		m_fDontDeleteHistory;
	BOOL		m_fReuseIndexFiles;
	BOOL		m_fOmitNonLeafDirs;
	CComBSTR	m_strGroupFile;
	CComBSTR	m_strReportFile;
	DWORD		m_dwNumThreads;

	//
	//	Status variables:
	//

	BOOL		m_fRebuildInProgress;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\rebuild.cpp ===
// Rebuild.cpp : Implementation of CNntpAdminRebuild.

#include "stdafx.h"
#include "nntpcmn.h"
#include "oleutil.h"
#include "Rebuild.h"

#include "nntptype.h"
#include "nntpapi.h"

#include <lmapibuf.h>

//
//  Defaults:
//

#define DEFAULT_VERBOSE                 ( FALSE )
#define DEFAULT_CLEAN_REBUILD           ( TRUE )
#define DEFAULT_DONT_DELETE_HISTORY     ( FALSE )
#define DEFAULT_REUSE_INDEX_FILES       ( TRUE )
#define DEFAULT_OMIT_NON_LEAF_DIRS      ( TRUE )
#define DEFAULT_GROUP_FILE              ( NULL )
#define DEFAULT_REPORT_FILE             ( _T("nntpbld.log") )
#define DEFAULT_NUM_THREADS             ( 0 )

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Rebuild.1")
#define THIS_FILE_IID				IID_INntpAdminRebuild

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(NntpAdminRebuild, CNntpAdminRebuild, IID_INntpAdminRebuild)

STDMETHODIMP CNntpAdminRebuild::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpAdminRebuild,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpAdminRebuild::CNntpAdminRebuild () :
	m_fVerbose				( FALSE ),
	m_fCleanRebuild			( FALSE ),
	m_fDontDeleteHistory	( FALSE ),
	m_fReuseIndexFiles		( FALSE ),
	m_fOmitNonLeafDirs		( FALSE ),
	m_dwNumThreads			( 0 ),

	m_fRebuildInProgress	( FALSE )

	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Rebuild") );
    m_iadsImpl.SetClass ( _T("IIsNntpRebuild") );
}

CNntpAdminRebuild::~CNntpAdminRebuild ()
{
	// All CComBSTR's are freed automatically.
	TermAsyncTrace ( );
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CNntpAdminRebuild,m_iadsImpl)

//
//	Properties:
//

STDMETHODIMP CNntpAdminRebuild::get_Verbose ( BOOL * pfVerbose )
{
	return StdPropertyGet ( m_fVerbose, pfVerbose );
}

STDMETHODIMP CNntpAdminRebuild::put_Verbose ( BOOL fVerbose )
{
	return StdPropertyPut ( &m_fVerbose, fVerbose );
}

STDMETHODIMP CNntpAdminRebuild::get_CleanRebuild ( BOOL * pfCleanRebuild )
{
	return StdPropertyGet ( m_fCleanRebuild, pfCleanRebuild );
}

STDMETHODIMP CNntpAdminRebuild::put_CleanRebuild ( BOOL fCleanRebuild )
{
	return StdPropertyPut ( &m_fCleanRebuild, fCleanRebuild );
}

STDMETHODIMP CNntpAdminRebuild::get_DontDeleteHistory ( BOOL * pfDontDeleteHistory )
{
	return StdPropertyGet ( m_fDontDeleteHistory, pfDontDeleteHistory );
}

STDMETHODIMP CNntpAdminRebuild::put_DontDeleteHistory ( BOOL fDontDeleteHistory )
{
	return StdPropertyPut ( &m_fDontDeleteHistory, fDontDeleteHistory );
}

STDMETHODIMP CNntpAdminRebuild::get_ReuseIndexFiles ( BOOL * pfReuseIndexFiles )
{
	return StdPropertyGet ( (DWORD) m_fReuseIndexFiles, (DWORD *) pfReuseIndexFiles );
}

STDMETHODIMP CNntpAdminRebuild::put_ReuseIndexFiles ( BOOL fReuseIndexFiles )
{
	return StdPropertyPut ( (DWORD *) &m_fReuseIndexFiles, (DWORD) fReuseIndexFiles );
}

STDMETHODIMP CNntpAdminRebuild::get_OmitNonLeafDirs ( BOOL * pfOmitNonLeafDirs )
{
	return StdPropertyGet ( m_fOmitNonLeafDirs, pfOmitNonLeafDirs );
}

STDMETHODIMP CNntpAdminRebuild::put_OmitNonLeafDirs ( BOOL fOmitNonLeafDirs )
{
	return StdPropertyPut ( &m_fOmitNonLeafDirs, fOmitNonLeafDirs );
}

STDMETHODIMP CNntpAdminRebuild::get_GroupFile ( BSTR * pstrGroupFile )
{
	return StdPropertyGet ( m_strGroupFile, pstrGroupFile );
}

STDMETHODIMP CNntpAdminRebuild::put_GroupFile ( BSTR strGroupFile )
{
	return StdPropertyPut ( &m_strGroupFile, strGroupFile );
}

STDMETHODIMP CNntpAdminRebuild::get_ReportFile ( BSTR * pstrReportFile )
{
	return StdPropertyGet ( m_strReportFile, pstrReportFile );
}

STDMETHODIMP CNntpAdminRebuild::put_ReportFile ( BSTR strReportFile )
{
	return StdPropertyPut ( &m_strReportFile, strReportFile );
}

STDMETHODIMP CNntpAdminRebuild::get_NumThreads ( long * plNumThreads )
{
	return StdPropertyGet ( m_dwNumThreads, plNumThreads );
}

STDMETHODIMP CNntpAdminRebuild::put_NumThreads ( long lNumThreads )
{
	return StdPropertyPut ( &m_dwNumThreads, lNumThreads );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpAdminRebuild::Default ( )
{
    HRESULT     hr  = NOERROR;

    m_fVerbose              = DEFAULT_VERBOSE;
    m_fCleanRebuild         = DEFAULT_CLEAN_REBUILD;
    m_fDontDeleteHistory    = DEFAULT_DONT_DELETE_HISTORY;
    m_fReuseIndexFiles      = DEFAULT_REUSE_INDEX_FILES;
    m_fOmitNonLeafDirs      = DEFAULT_OMIT_NON_LEAF_DIRS;
//    m_strGroupFile          = DEFAULT_GROUP_FILE;
    m_strReportFile         = DEFAULT_REPORT_FILE;
    m_dwNumThreads          = DEFAULT_NUM_THREADS;

    return hr;
}

STDMETHODIMP CNntpAdminRebuild::StartRebuild ( )
{
	TraceFunctEnter ( "CNntpAdminRebuild::StartRebuild" );

	HRESULT			hr		= NOERROR;
	NNTPBLD_INFO	bldinfo;
	DWORD			dwError;

	if ( m_fRebuildInProgress ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_ALREADY_BUILDING );
	}

	ZeroMemory ( &bldinfo, sizeof (bldinfo) );

	bldinfo.Verbose			= !!m_fVerbose;
	bldinfo.DoClean			= !!m_fCleanRebuild;
	bldinfo.NoHistoryDelete	= !!m_fDontDeleteHistory;
	bldinfo.ReuseIndexFiles	= m_fReuseIndexFiles;
	bldinfo.OmitNonleafDirs	= !!m_fOmitNonLeafDirs;
	bldinfo.szGroupFile		= m_strGroupFile;
	bldinfo.cbGroupFile		= STRING_BYTE_LENGTH ( m_strGroupFile );
	bldinfo.szReportFile	= m_strReportFile;
	bldinfo.cbReportFile	= STRING_BYTE_LENGTH ( m_strReportFile );
	bldinfo.NumThreads		= m_dwNumThreads;

	dwError = NntpStartRebuild (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &bldinfo,
        NULL
        );

	if ( dwError == NOERROR ) {
		// We've successfully started a rebuild.

		m_fRebuildInProgress = TRUE;
	}
	else {
		_ASSERT ( dwError != NOERROR );
	
		hr = RETURNCODETOHRESULT ( dwError );
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminRebuild::GetProgress ( long * pdwProgress )
{
	TraceFunctEnter ( "CNntpAdminRebuild::GetProgress" );

	HRESULT			hr		= NOERROR;
	DWORD			dwError;
	DWORD			dwProgress;

	_ASSERT ( IS_VALID_OUT_PARAM ( pdwProgress ) );

	if ( pdwProgress == NULL ) {
		return E_POINTER;
	}

	*pdwProgress	= 0;

	// Should I send back an exception if the build is finished?
	if ( !m_fRebuildInProgress ) {
		*pdwProgress	= 100;
		return NOERROR;
	}

	dwError = NntpGetBuildStatus (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        FALSE,
        &dwProgress
        );

	if ( dwError == NOERROR ) {
		*pdwProgress	= dwProgress;
	}
	else {
		_ASSERT ( dwError != NOERROR );

		hr = RETURNCODETOHRESULT ( dwError );
	}

	// Are we still rebuilding?
	if ( dwError != NOERROR || dwProgress == 100 ) {
		// The rebuild is finished.
		m_fRebuildInProgress = FALSE;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminRebuild::Cancel ( )
{
	TraceFunctEnter ( "CNntpAdminRebuild::Cancel" );

	HRESULT			hr		= NOERROR;
	DWORD			dwError;
	DWORD			dwProgress;

	// Should I send back an exception if the build is finished?
	if ( !m_fRebuildInProgress ) {
		return NOERROR;
	}

	dwError = NntpGetBuildStatus (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        TRUE,
        &dwProgress
        );

	if ( dwError != NOERROR ) {
		hr = RETURNCODETOHRESULT ( dwError );
	}

	// Cancel always stops a rebuild:
	m_fRebuildInProgress	= FALSE;

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\oleutil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	oleutil.cpp

Abstract:

	Provides Useful functions for dealing with OLE.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "iadm.h"
#include "oleutil.h"
#include "cmultisz.h"
#include "resource.h"

//$-------------------------------------------------------------------
//
//	UpdateChangedMask
//
//	Description:
//
//		Marks a field as changed in the given bit vector
//
//	Parameters:
//
//		pbvChangedProps - points to the bit vector
//		dwBitMask - Bit to turn on. (must have only one bit on)
//
//--------------------------------------------------------------------

static void UpdateChangedMask ( DWORD * pbvChangedProps, DWORD dwBitMask )
{
	if ( pbvChangedProps == NULL ) {
		// Legal, means that the caller doesn't want change tracking.

		return;
	}

	_ASSERT ( dwBitMask != 0 );

	*pbvChangedProps |= dwBitMask;
}

HRESULT LongArrayToVariantArray ( SAFEARRAY * psaLongs, SAFEARRAY ** ppsaVariants )
{
	_ASSERT ( psaLongs );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaVariants;

	*ppsaVariants = NULL;

	_ASSERT ( SafeArrayGetDim ( psaLongs ) == 1 );

	SafeArrayGetLBound ( psaLongs, 1, &lLBound );
	SafeArrayGetUBound ( psaLongs, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaVariants = SafeArrayCreate ( VT_VARIANT, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		long		lTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaLongs, &i, &lTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		V_VT (&var) = VT_I4;
		V_I4 (&var) = lTemp;

		hr = SafeArrayPutElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear ( &var );
	}

	*ppsaVariants	= psaVariants;
Exit:
	return hr;
}

HRESULT StringArrayToVariantArray ( SAFEARRAY * psaStrings, SAFEARRAY ** ppsaVariants )
{
	_ASSERT ( psaStrings );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaVariants;

	*ppsaVariants = NULL;

	_ASSERT ( SafeArrayGetDim ( psaStrings ) == 1 );

	SafeArrayGetLBound ( psaStrings, 1, &lLBound );
	SafeArrayGetUBound ( psaStrings, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaVariants = SafeArrayCreate ( VT_VARIANT, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		CComBSTR	strTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaStrings, &i, &strTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		V_VT (&var) = VT_BSTR;
		V_BSTR (&var) = ::SysAllocString ( strTemp );

		hr = SafeArrayPutElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear ( &var );
	}

	*ppsaVariants	= psaVariants;
Exit:
	return hr;
}

HRESULT VariantArrayToStringArray ( SAFEARRAY * psaVariants, SAFEARRAY ** ppsaStrings )
{
	_ASSERT ( psaVariants );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaStrings;

	_ASSERT ( SafeArrayGetDim ( psaVariants ) == 1 );
	
	*ppsaStrings = NULL;

	SafeArrayGetLBound ( psaVariants, 1, &lLBound );
	SafeArrayGetUBound ( psaVariants, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaStrings = SafeArrayCreate ( VT_BSTR, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		CComBSTR	strTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		strTemp = V_BSTR (&var);

		hr = SafeArrayPutElement ( psaStrings, &i, strTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear (&var);
	}

	*ppsaStrings = psaStrings;
Exit:
	return hr;
}

//$-------------------------------------------------------------------
//
//	StdPropertyGet < BSTR, long, DWORD, DATE >
//
//	Description:
//
//		Performs a default Property Get on a BSTR, long, DWORD or 
//		Ole DATE.
//
//	Parameters:
//
//		Property	- The property to get.
//		pOut		- The resulting copy.
//
//	Returns:
//
//		E_POINTER		- invalid arguments
//		E_OUTOFMEMORY	- Not enough memory to copy
//		NOERROR			- success.
//
//--------------------------------------------------------------------

HRESULT StdPropertyGet ( const BSTR strProperty, BSTR * pstrOut )
{
	TraceQuietEnter ( "StdPropertyGet <BSTR>" );

	_ASSERT ( pstrOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrOut ) );

	if ( pstrOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		return E_POINTER;
	}

	*pstrOut = NULL;

	if ( strProperty == NULL ) {

		// If the property is NULL, use a blank string:
		*pstrOut = ::SysAllocString ( _T("") );
	}
	else {
		_ASSERT ( IS_VALID_STRING ( strProperty ) );

		// Copy the property into the result:
		*pstrOut = ::SysAllocString ( strProperty );
	}

	if ( *pstrOut == NULL ) {

		// Allocation failed.
		FatalTrace ( 0, "Out of memory" );

		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

HRESULT StdPropertyGet ( long lProperty, long * plOut )
{
	TraceQuietEnter ( "StdPropertyGet <long>" );

	_ASSERT ( plOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( plOut ) );

	if ( plOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		return E_POINTER;
	}

	*plOut = lProperty;
	return NOERROR;
}

HRESULT StdPropertyGet ( DATE dateProperty, DATE * pdateOut )
{
	TraceQuietEnter ( "StdPropertyGet <DATE>" );

	_ASSERT ( pdateOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pdateOut ) );

	if ( pdateOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		return E_POINTER;
	}
	
	*pdateOut = dateProperty;
	return NOERROR;
}

HRESULT StdPropertyGet ( const CMultiSz * pmszProperty, SAFEARRAY ** ppsaStrings )
{
	TraceFunctEnter ( "StdPropertyGet <MULTI_SZ>" );

	_ASSERT ( pmszProperty );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaStrings ) );

	HRESULT		hr	= NOERROR;

	*ppsaStrings = pmszProperty->ToSafeArray ( );

	if ( *ppsaStrings == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT	StdPropertyGetBit ( DWORD bvBitVector, DWORD dwBit, BOOL * pfOut )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pfOut ) );

	if ( !pfOut ) {
		return E_POINTER;
	}

	*pfOut	= GetBitFlag ( bvBitVector, dwBit );

	return NOERROR;
}

//$-------------------------------------------------------------------
//
//	StdPropertyPut <BSTR, long, DWORD or DATE>
//
//	Description:
//
//		Performs a default Property Put on a BSTR, long, DWORD or
//		Ole date.
//
//	Parameters:
//
//		pProperty	- The property to put.
//		New			- The new value.
//		pbvChangedProps [optional] - Bit Vector which holds which
//				properties have changed.
//		dwBitMask [optional] - This property's bitmask for the 
//				changed bit vector.
//
//	Returns:
//
//		E_POINTER - invalid arguments
//		E_OUTOFMEMORY - Not enough memory to copy
//		NOERROR - success.
//
//--------------------------------------------------------------------

HRESULT StdPropertyPut ( 
	BSTR * pstrProperty, 
	const BSTR strNew, 
	DWORD * pbvChangedProps, // = NULL 
	DWORD dwBitMask // = 0 
	)
{
	TraceQuietEnter ( "StdPropertyPut <BSTR>" );

	// Validate Parameters:
	_ASSERT ( pstrProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrProperty ) );

	_ASSERT ( strNew != NULL );
	_ASSERT ( IS_VALID_STRING ( strNew ) );

	if ( pstrProperty == NULL ) {
		FatalTrace ( 0, "Bad property pointer" );
		return E_POINTER;
	}

	if ( strNew == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	HRESULT	hr	= NOERROR;
	BSTR	strCopy = NULL;

	// Copy the new string:
	strCopy = ::SysAllocString ( strNew );

	if ( strCopy == NULL ) {
		hr = E_OUTOFMEMORY;

		FatalTrace ( 0, "Out of memory" );
		goto Error;
	}

	// Update the changed bit, if necessary:
	if ( *pstrProperty && lstrcmp ( *pstrProperty, strCopy ) != 0 ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	// Replace the old property with the new one.
	SAFE_FREE_BSTR ( *pstrProperty );

	*pstrProperty = strCopy;

Error:
	return hr;
}

HRESULT StdPropertyPut ( 
	long * plProperty, 
	long lNew, 
	DWORD * pbvChangedProps, // = NULL 
	DWORD dwBitMask // = 0
	)
{
	TraceQuietEnter ( "StdPropertyPut <long>" );

	_ASSERT ( plProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( plProperty ) );

	if ( plProperty == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	if ( *plProperty != lNew ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	*plProperty = lNew;
	return NOERROR;
}

HRESULT StdPropertyPut ( 
	DATE * pdateProperty, 
	DATE dateNew, 
	DWORD * pbvChangedProps, // = NULL
	DWORD dwBitMask // = 0
	)
{
	TraceQuietEnter ( "StdPropertyPut <DATE>" );

	_ASSERT ( pdateProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pdateProperty ) );

	if ( pdateProperty == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	if ( *pdateProperty != dateNew ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	*pdateProperty = dateNew;
	return NOERROR;
}

HRESULT StdPropertyPut ( CMultiSz * pmszProperty, SAFEARRAY * psaStrings, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	TraceFunctEnter ( "StdPropertyPut <MULTI_SZ>" );

	_ASSERT ( IS_VALID_IN_PARAM ( psaStrings ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( pmszProperty ) );

	if ( psaStrings == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}

	HRESULT		hr	= NOERROR;

	pmszProperty->FromSafeArray ( psaStrings );

	if ( !*pmszProperty ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Don't want to deal with comparing these properties:
	UpdateChangedMask ( pbvChangedProps, dwBitMask );

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT	StdPropertyPutBit ( DWORD * pbvBitVector, DWORD dwBit, BOOL fIn )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pbvBitVector ) );
	_ASSERT ( dwBit );

	SetBitFlag ( pbvBitVector, dwBit, fIn );

	return NOERROR;
}

//$-------------------------------------------------------------------
//
//	PV_MaxChars
//
//	Description:
//
//		Validates a string to make sure it's not too long.
//
//	Parameters:
//
//		strProperty - the string to check
//		nMaxChars - the maximum number of characters in the string,
//			not including the NULL terminator.
//
//	Returns:
//
//		FALSE if the string is too long.
//
//--------------------------------------------------------------------

BOOL PV_MaxChars ( const BSTR strProperty, DWORD nMaxChars )
{
	TraceQuietEnter ( "PV_MaxChars" );

	_ASSERT ( strProperty != NULL );
	_ASSERT ( IS_VALID_STRING ( strProperty ) );

	_ASSERT ( nMaxChars > 0 );

	if ( strProperty == NULL ) {
		// This error should be caught somewhere else.
		return TRUE;
	}

	if ( (DWORD) lstrlen ( strProperty ) > nMaxChars ) {
		ErrorTrace ( 0, "String too long" );
		return FALSE;
	}

	return TRUE;
}

//$-------------------------------------------------------------------
//
//	PV_MinMax <int, dword>
//
//	Description:
//
//		Makes sure a property is within a given range.
//
//	Parameters:
//
//		nProperty - the value to test
//		nMin - The minimum value the property could have
//		nMax - The maximum value the property could have
//
//	Returns:
//
//		TRUE if the property is in the range (inclusive).
//
//--------------------------------------------------------------------

BOOL PV_MinMax ( int nProperty, int nMin, int nMax )
{
	TraceQuietEnter ( "PV_MinMax" );

	_ASSERT ( nMin <= nMax );

	if ( nProperty < nMin || nProperty > nMax ) {
		ErrorTrace ( 0, "Integer out of range" );
		return FALSE;
	}
	return TRUE;
}

BOOL PV_MinMax ( DWORD dwProperty, DWORD dwMin, DWORD dwMax )
{
	TraceQuietEnter ( "PV_MinMax" );

	_ASSERT ( dwMin <= dwMax );

	if ( dwProperty < dwMin || dwProperty > dwMax ) {

		ErrorTrace ( 0, "Dword out of range" );
		return FALSE;
	}
	return TRUE;
}

BOOL PV_Boolean		( BOOL fProperty )
{
	TraceQuietEnter ( "PV_Boolean" );

	if ( fProperty != TRUE && fProperty != FALSE ) {

		ErrorTrace ( 0, "Boolean property is not true or false" );
		return FALSE;
	}

	return TRUE;
}

//$-------------------------------------------------------------------
//
//	StdPropertyGetIDispatch
//
//	Description:
//
//		Gets a IDispatch pointer for the given cLSID
//
//	Parameters:
//
//		clsid		- OLE CLSID of the object
//		ppIDipsatch	- the IDispatch pointer to that object.
//
//	Returns:
//
//		E_POINTER	- invalid argument
//		NOERROR		- Success
//		Others - defined by CoCreateInstance.
//
//--------------------------------------------------------------------

HRESULT StdPropertyGetIDispatch ( 
	REFCLSID clsid, 
	IDispatch ** ppIDispatch 
	)
{
	TraceFunctEnter ( "StdPropertyGetIDispatch" );

	CComPtr<IDispatch>	pNewIDispatch;
	HRESULT				hr = NOERROR;

	_ASSERT ( ppIDispatch );

	if ( ppIDispatch == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		TraceFunctLeave ();
		return E_POINTER;
	}

	*ppIDispatch = NULL;

	hr = ::CoCreateInstance ( 
		clsid,
		NULL, 
		CLSCTX_ALL, 
		IID_IDispatch,
		(void **) &pNewIDispatch
		);

	if ( FAILED (hr) ) {
		DebugTraceX ( 0, "CoCreate(IDispatch) failed %x", hr );
		FatalTrace ( 0, "Failed to create IDispatch" );
		goto Exit;
	}

	*ppIDispatch = pNewIDispatch;
	pNewIDispatch->AddRef ();

Exit:
	TraceFunctLeave ();
	return hr;

	// Destructor releases pNewIDispatch
}

//$-------------------------------------------------------------------
//
//	InetAddressToString
//
//	Description:
//
//		Converts a DWORD with an ip address to a string in the form
//		"xxx.xxx.xxx.xxx"
//
//	Parameters:
//
//		dwAddress	- The address to convert
//		wszAddress	- The resulting string
//		cAddress	- The maximum size of the resulting string
//
//	Returns:
//
//		TRUE if succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL InetAddressToString ( DWORD dwAddress, LPWSTR wszAddress, DWORD cAddress )
{
	TraceFunctEnter ( "InetAddressToString" );

	_ASSERT ( wszAddress );

	if ( wszAddress == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	struct in_addr	addr;
	LPSTR			szAnsiAddress;
	DWORD			cchCopied;

	addr.s_addr = dwAddress;

	szAnsiAddress = inet_ntoa ( addr );

	if ( szAnsiAddress == NULL ) {
		ErrorTraceX ( 0, "inet_ntoa failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	cchCopied = MultiByteToWideChar ( 
		CP_ACP, 
		MB_PRECOMPOSED,
		szAnsiAddress,
		-1,
		wszAddress,
		cAddress
		);

	if ( cchCopied == 0 ) {
		ErrorTraceX ( 0, "MultiByteToWideChar failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	TraceFunctLeave ();
	return TRUE;
}

//$-------------------------------------------------------------------
//
//	StringToInetAddress
//
//	Description:
//
//		Converts a string in the form "xxx.xxx.xxx.xxx" to a DWORD
//		IP Address.
//
//	Parameters:
//
//		wszAddress	- The string to convert
//		pdwAddress	- The resulting address
//
//	Returns:
//
//		TRUE if succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL StringToInetAddress ( LPCWSTR wszAddress, DWORD * pdwAddress )
{
	TraceFunctEnter ( "StringToInetAddress" );

	_ASSERT ( wszAddress );
	_ASSERT ( pdwAddress );

	if ( wszAddress == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	if ( pdwAddress == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	char	szAnsiAddress[100];
	DWORD	cchCopied;

	*pdwAddress = 0;

	cchCopied = WideCharToMultiByte ( 
		CP_ACP, 
		0, 
		wszAddress, 
		-1, 
		szAnsiAddress, 
		sizeof ( szAnsiAddress ),
		NULL,
		NULL
		);

	if ( cchCopied == 0 ) {
		ErrorTraceX ( 0, "MultiByteToWideChar failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	*pdwAddress = inet_addr ( szAnsiAddress );

	if ( !*pdwAddress ) {
		ErrorTraceX ( 0, "inet_addr failed: %x", GetLastError () );
	}

	TraceFunctLeave ();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\server.cpp ===
// server.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"
#include <lmcons.h>
#include <sddl.h>
#include "nntpcmn.h"

#include "oleutil.h"
#include "cmultisz.h"
#include "metautil.h"
#include "metakey.h"
#include "server.h"

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_INntpVirtualServer

// Bitmasks for changed fields:

#define CHNG_ARTICLETIMELIMIT			0x00000001
#define CHNG_HISTORYEXPIRATION			0x00000002
#define CHNG_HONORCLIENTMSGIDS			0x00000004
#define CHNG_SMTPSERVER					0x00000008
#define CHNG_ALLOWCLIENTPOSTS			0x00000010
#define CHNG_ALLOWFEEDPOSTS				0x00000020
#define CHNG_ALLOWCONTROLMSGS			0x00000040
#define CHNG_DEFAULTMODERATORDOMAIN		0x00000080
#define CHNG_COMMANDLOGMASK				0x00000100
#define CHNG_DISABLENEWNEWS				0x00000200
#define CHNG_NEWSCRAWLERTIME			0x00000400
#define CHNG_SHUTDOWNLATENCY			0x00000800

#define CHNG_CLIENTPOSTHARDLIMIT		0x00001000
#define CHNG_CLIENTPOSTSOFTLIMIT		0x00002000
#define CHNG_FEEDPOSTHARDLIMIT			0x00004000
#define CHNG_FEEDPOSTSOFTLIMIT			0x00008000

#define CHNG_GROUPHELPFILE				0x00010000
#define CHNG_GROUPLISTFILE				0x00020000
#define CHNG_ARTICLETABLEFILE			0x00040000
#define CHNG_HISTORYTABLEFILE			0x00080000
#define CHNG_MODERATORFILE				0x00100000
#define CHNG_XOVERTABLEFILE				0x00200000
#define CHNG_DISPLAYNAME				0x00400000
#define CHNG_ERRORCONTROL				0x00800000
#define CHNG_CLEANBOOT					0x01000000
#define CHNG_UUCPNAME					0x02000000
#define CHNG_ORGANIZATION				0x04000000
#define CHNG_AUTOSTART					0x08000000

#define CHNG_COMMENT					0x10000000
#define CHNG_BINDING					0x20000000
#define CHNG_SECUREPORT					0x40000000
#define CHNG_MAXCONNECTIONS				0x80000000

#define CHNG2_CONNECTIONTIMEOUT				0x00000001
#define CHNG2_ANONYMOUSUSERNAME				0x00000002
#define CHNG2_ANONYMOUSUSERPASS				0x00000004
#define CHNG2_PICKUPDIRECTORY				0x00000008
#define CHNG2_FAILEDPICKUPDIRECTORY			0x00000010
#define CHNG2_HOMEDIRECTORY					0x00000020
#define CHNG2_NTAUTHENTICATION_PROVIDERS	0x00000040
#define CHNG2_AUTHORIZATION					0x00000080
#define CHNG2_ENABLELOGGING					0x00000100
#define CHNG2_SSLACCESS						0x00000200
#define CHNG2_AUTOSYNCPASSWORD				0x00000400
#define CHNG2_ADMINEMAIL                    0x00000800
#define CHNG2_CLUSTERENABLED                0x00001000
#define CHNG2_ADMINACL						0x00002000

// Default Values:

/*
#define DEFAULT_ARTICLETIMELIMIT		( 1138 )
#define DEFAULT_HISTORYEXPIRATION		( 1138 )
#define DEFAULT_HONORCLIENTMSGIDS		( TRUE )
#define DEFAULT_SMTPSERVER				_T( "" )
#define DEFAULT_ALLOWCLIENTPOSTS		( TRUE )
#define DEFAULT_ALLOWFEEDPOSTS			( TRUE )
#define DEFAULT_ALLOWCONTROLMSGS		( TRUE )
#define DEFAULT_DEFAULTMODERATORDOMAIN	_T( "" )
#define DEFAULT_COMMANDLOGMASK			( (DWORD) -1 )
#define DEFAULT_DISABLENEWNEWS			( FALSE )
#define DEFAULT_NEWSCRAWLERTIME		( 1138 )
#define DEFAULT_SHUTDOWNLATENCY			( 1138 )

#define DEFAULT_CLIENTPOSTHARDLIMIT		( 1138 )
#define DEFAULT_CLIENTPOSTSOFTLIMIT		( 1138 )
#define DEFAULT_FEEDPOSTHARDLIMIT		( 1138 )
#define DEFAULT_FEEDPOSTSOFTLIMIT		( 1138 )

#define DEFAULT_GROUPHELPFILE			_T( "" )
#define DEFAULT_GROUPLISTFILE			_T( "" )
#define DEFAULT_ARTICLETABLEFILE		_T( "" )
#define DEFAULT_HISTORYTABLEFILE		_T( "" )
#define DEFAULT_MODERATORFILE			_T( "" )
#define DEFAULT_XOVERTABLEFILE			_T( "" )
#define DEFAULT_UUCPNAME				_T( "" )
#define DEFAULT_ORGANIZATION			_T( "" )

#define DEFAULT_AUTOSTART				( TRUE )
#define DEFAULT_COMMENT					_T( "" )
#define DEFAULT_BINDINGS				_T( ":119:\0" )
#define DEFAULT_SECUREPORT				( 563 )
#define DEFAULT_MAXCONNECTIONS			( 1138 )
#define DEFAULT_CONNECTIONTIMEOUT		( 1138 )
#define DEFAULT_ANONYMOUSUSERNAME		_T( "" )
#define DEFAULT_ANONYMOUSUSERPASS		_T( "" )
#define DEFAULT_PICKUPDIRECTORY			_T( "" )
#define DEFAULT_FAILEDPICKUPDIRECTORY	_T( "" )
*/

#define NNTP_DEF_ADMIN_EMAIL            _T( "" )
#define NNTP_DEF_NTAUTHENTICATION_PROVIDERS		_T("NTLM\0")
#define NNTP_DEF_AUTHORIZATION			( 0 )
#define NNTP_DEF_ENABLE_LOGGING			( FALSE )
#define NNTP_DEF_SECURE_BINDINGS		( _T("\0") )

// Parameter ranges:

#define MAXLEN_SERVER					( 256 )
#define MIN_ARTICLETIMELIMIT			( (DWORD) 0 )
#define MAX_ARTICLETIMELIMIT			( (DWORD) -1 )
#define MIN_HISTORYEXPIRATION			( (DWORD) 0 )
#define MAX_HISTORYEXPIRATION			( (DWORD) -1 )
#define MAXLEN_SMTPSERVER				( 256 )
#define MAXLEN_DEFAULTMODERATORDOMAIN	( 256 )
#define MIN_COMMANDLOGMASK				( (DWORD) 0 )
#define MAX_COMMANDLOGMASK				( (DWORD) -1 )
#define MIN_NEWSCRAWLERTIME			( (DWORD) 1 )
#define MAX_NEWSCRAWLERTIME			( (DWORD) -1 )
#define MIN_SHUTDOWNLATENCY				( (DWORD) 1 )
#define MAX_SHUTDOWNLATENCY				( (DWORD) -1 )

//
// Administrator ACL:
//
static HRESULT AclToAdministrators ( LPCTSTR strServer, PSECURITY_DESCRIPTOR pSDRelative, SAFEARRAY ** ppsaAdmins );
static HRESULT AdministratorsToAcl ( LPCTSTR strServer, SAFEARRAY * psaAdmins, PSECURITY_DESCRIPTOR* ppSD, DWORD * pcbSD );

static HRESULT SidToString ( LPCWSTR strSystemName, PSID pSID, BSTR * pStr );
static HRESULT StringToSid ( LPCWSTR strSystemName, LPWSTR str, PSID * ppSID );

/////////////////////////////////////////////////////////////////////////////
//

CNntpVirtualServer::CNntpVirtualServer () :
	m_dwServiceInstance			( 0 ),

	m_dwClientPostHardLimit		( 0 ),
	m_dwClientPostSoftLimit		( 0 ),
	m_dwFeedPostHardLimit		( 0 ),
	m_dwFeedPostSoftLimit		( 0 ),
	m_dwEncryptionCapabilities	( 0 ),
	m_fAutoSyncPassword			( FALSE ),
	m_fErrorControl				( FALSE ),
	m_fCleanBoot				( FALSE ),
	m_fAutoStart				( FALSE ),
	m_psaAdmins					( NULL ),

	m_State						( NNTP_SERVER_STATE_UNKNOWN ),
	m_dwWin32ErrorCode			( NOERROR ),

	m_pPrivateBindings			( NULL ),
	m_pPrivateIpAccess			( NULL ),
//	m_pPrivateHomeDirectory		( NULL ),
	m_fGotProperties			( FALSE ),
	m_fClusterEnabled           ( FALSE ),
	m_bvChangedFields			( 0 ),
	m_bvChangedFields2			( 0 )
	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );

	// Create the Ip Access collection:
	CComObject<CTcpAccess> *	pIpAccess;

	CComObject<CTcpAccess>::CreateInstance ( &pIpAccess );
	pIpAccess->QueryInterface ( IID_ITcpAccess, (void **) &m_pIpAccess );
	m_pPrivateIpAccess = pIpAccess;
}

CNntpVirtualServer::~CNntpVirtualServer ()
{
	// All CComBSTR's are freed automatically.

	if ( m_psaAdmins ) {
		SafeArrayDestroy ( m_psaAdmins );
	}

	TermAsyncTrace ( );
}

STDMETHODIMP CNntpVirtualServer::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpVirtualServer,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

// Which service to configure:
	
STDMETHODIMP CNntpVirtualServer::get_Server ( BSTR * pstrServer )
{
	return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CNntpVirtualServer::put_Server ( BSTR strServer )
{
	VALIDATE_STRING ( strServer, MAXLEN_SERVER );

	// If the server name changes, that means the client will have to
	// call Get again:

	// I assume this here:
	_ASSERT ( sizeof (DWORD) == sizeof (int) );
	
	return StdPropertyPutServerName ( &m_strServer, strServer, (DWORD *) &m_fGotProperties, 1 );
}

STDMETHODIMP CNntpVirtualServer::get_ServiceInstance ( long * plServiceInstance )
{
	return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CNntpVirtualServer::put_ServiceInstance ( long lServiceInstance )
{
	// If the service instance changes, that means the client will have to
	// call Get again:

	// I assume this here:
	_ASSERT ( sizeof (DWORD) == sizeof (int) );
	
	return StdPropertyPut ( &m_dwServiceInstance, lServiceInstance, (DWORD *) &m_fGotProperties, 1 );
}

// Other admin interfaces for virtual servers:

STDMETHODIMP CNntpVirtualServer::get_FeedsAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpAdminFeeds>	pINntpAdminFeeds;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpAdminFeeds,
		IID_INntpAdminFeeds,
		&pINntpAdminFeeds, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpAdminFeeds->put_Server ( m_strServer ? m_strServer : _T("") );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pINntpAdminFeeds->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminFeeds
}

STDMETHODIMP CNntpVirtualServer::get_GroupsAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpAdminGroups>	pINntpAdminGroups;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpAdminGroups,
		IID_INntpAdminGroups,
		&pINntpAdminGroups, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpAdminGroups->put_Server ( m_strServer ? m_strServer : _T("") );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pINntpAdminGroups->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminGroups
}

STDMETHODIMP CNntpVirtualServer::get_ExpirationAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpAdminExpiration>	pINntpAdminExpiration;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpAdminExpiration,
		IID_INntpAdminExpiration,
		&pINntpAdminExpiration, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpAdminExpiration->put_Server ( m_strServer ? m_strServer : _T("") );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pINntpAdminExpiration->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminExpiration
}

STDMETHODIMP CNntpVirtualServer::get_SessionsAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpAdminSessions>	pINntpAdminSessions;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpAdminSessions,
		IID_INntpAdminSessions,
		&pINntpAdminSessions, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpAdminSessions->put_Server ( m_strServer ? m_strServer : _T("") );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pINntpAdminSessions->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminSessions
}

STDMETHODIMP CNntpVirtualServer::get_RebuildAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpAdminRebuild>	pINntpAdminRebuild;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpAdminRebuild,
		IID_INntpAdminRebuild,
		&pINntpAdminRebuild, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpAdminRebuild->put_Server ( m_strServer ? m_strServer : _T("") );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pINntpAdminRebuild->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminRebuild
}

STDMETHODIMP CNntpVirtualServer::get_VirtualRoots ( INntpVirtualRoots ** ppVirtualRoots )
{
	HRESULT	hr = NOERROR;
	CComObject<CNntpVirtualRoots> *	pVRoots	= NULL;

	*ppVirtualRoots	= NULL;

	hr = CComObject<CNntpVirtualRoots>::CreateInstance ( &pVRoots );
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	pVRoots->m_strServer			= m_strServer;
	pVRoots->m_dwServiceInstance	= m_dwServiceInstance;

	if ( m_strServer && !pVRoots->m_strServer ) {
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	hr = pVRoots->QueryInterface ( IID_INntpVirtualRoots, (void **) ppVirtualRoots );

Error:
	if ( FAILED(hr) ) {
		delete pVRoots;
	}

	return hr;

	// Destructor releases pINntpAdminRebuild
}

STDMETHODIMP CNntpVirtualServer::get_VirtualRootsDispatch ( IDispatch ** ppVirtualRoots )
{
	HRESULT						hr;
	CComPtr<INntpVirtualRoots>	pVRoots;

	hr = get_VirtualRoots ( &pVRoots );
	BAIL_ON_FAILURE ( hr );

	hr = pVRoots->QueryInterface ( IID_IDispatch, (void **) ppVirtualRoots );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CNntpVirtualServer::get_TcpAccess ( ITcpAccess ** ppTcpAccess )
{
    return m_pIpAccess->QueryInterface ( IID_ITcpAccess, (void **) ppTcpAccess );
}

// Server overridable Properties:

STDMETHODIMP CNntpVirtualServer::get_ArticleTimeLimit ( long * plArticleTimeLimit )
{
	return StdPropertyGet ( m_dwArticleTimeLimit, plArticleTimeLimit );
}

STDMETHODIMP CNntpVirtualServer::put_ArticleTimeLimit ( long lArticleTimeLimit )
{
	return StdPropertyPut ( &m_dwArticleTimeLimit, lArticleTimeLimit, &m_bvChangedFields, CHNG_ARTICLETIMELIMIT );
}

STDMETHODIMP CNntpVirtualServer::get_HistoryExpiration ( long * plHistoryExpiration )
{
	return StdPropertyGet ( m_dwHistoryExpiration, plHistoryExpiration );
}

STDMETHODIMP CNntpVirtualServer::put_HistoryExpiration ( long lHistoryExpiration )
{
	return StdPropertyPut ( &m_dwHistoryExpiration, lHistoryExpiration, &m_bvChangedFields, CHNG_HISTORYEXPIRATION );
}

STDMETHODIMP CNntpVirtualServer::get_HonorClientMsgIDs ( BOOL * pfHonorClientMsgIDs )
{
	return StdPropertyGet ( m_fHonorClientMsgIDs, pfHonorClientMsgIDs );
}

STDMETHODIMP CNntpVirtualServer::put_HonorClientMsgIDs ( BOOL fHonorClientMsgIDs )
{
	return StdPropertyPut ( &m_fHonorClientMsgIDs, fHonorClientMsgIDs, &m_bvChangedFields, CHNG_HONORCLIENTMSGIDS );
}

STDMETHODIMP CNntpVirtualServer::get_SmtpServer ( BSTR * pstrSmtpServer )
{
	return StdPropertyGet ( m_strSmtpServer, pstrSmtpServer );
}

STDMETHODIMP CNntpVirtualServer::put_SmtpServer ( BSTR strSmtpServer )
{
	return StdPropertyPut ( &m_strSmtpServer, strSmtpServer, &m_bvChangedFields, CHNG_SMTPSERVER );
}

STDMETHODIMP CNntpVirtualServer::get_AdminEmail ( BSTR * pstrAdminEmail )
{
	return StdPropertyGet ( m_strAdminEmail, pstrAdminEmail );
}

STDMETHODIMP CNntpVirtualServer::put_AdminEmail ( BSTR strAdminEmail )
{
	return StdPropertyPut ( &m_strAdminEmail, strAdminEmail, &m_bvChangedFields2, CHNG2_ADMINEMAIL );
}

STDMETHODIMP CNntpVirtualServer::get_AllowClientPosts ( BOOL * pfAllowClientPosts )
{
	return StdPropertyGet ( m_fAllowClientPosts, pfAllowClientPosts );
}

STDMETHODIMP CNntpVirtualServer::put_AllowClientPosts ( BOOL fAllowClientPosts )
{
	return StdPropertyPut ( &m_fAllowClientPosts, fAllowClientPosts, &m_bvChangedFields, CHNG_ALLOWCLIENTPOSTS );
}

STDMETHODIMP CNntpVirtualServer::get_AllowFeedPosts ( BOOL * pfAllowFeedPosts )
{
	return StdPropertyGet ( m_fAllowFeedPosts, pfAllowFeedPosts );
}

STDMETHODIMP CNntpVirtualServer::put_AllowFeedPosts ( BOOL fAllowFeedPosts )
{
	return StdPropertyPut ( &m_fAllowFeedPosts, fAllowFeedPosts, &m_bvChangedFields, CHNG_ALLOWFEEDPOSTS );
}

STDMETHODIMP CNntpVirtualServer::get_AllowControlMsgs ( BOOL * pfAllowControlMsgs )
{
	return StdPropertyGet ( m_fAllowControlMsgs, pfAllowControlMsgs );
}

STDMETHODIMP CNntpVirtualServer::put_AllowControlMsgs ( BOOL fAllowControlMsgs )
{
	return StdPropertyPut ( &m_fAllowControlMsgs, fAllowControlMsgs, &m_bvChangedFields, CHNG_ALLOWCONTROLMSGS );
}

STDMETHODIMP CNntpVirtualServer::get_DefaultModeratorDomain ( BSTR * pstrDefaultModeratorDomain )
{
	return StdPropertyGet ( m_strDefaultModeratorDomain, pstrDefaultModeratorDomain );
}

STDMETHODIMP CNntpVirtualServer::put_DefaultModeratorDomain ( BSTR strDefaultModeratorDomain )
{
	return StdPropertyPut ( &m_strDefaultModeratorDomain, strDefaultModeratorDomain, &m_bvChangedFields, CHNG_DEFAULTMODERATORDOMAIN );
}

STDMETHODIMP CNntpVirtualServer::get_CommandLogMask ( long * plCommandLogMask )
{
	return StdPropertyGet ( m_dwCommandLogMask, plCommandLogMask );
}

STDMETHODIMP CNntpVirtualServer::put_CommandLogMask ( long lCommandLogMask )
{
	return StdPropertyPut ( &m_dwCommandLogMask, lCommandLogMask, &m_bvChangedFields, CHNG_COMMANDLOGMASK );
}

STDMETHODIMP CNntpVirtualServer::get_DisableNewnews ( BOOL * pfDisableNewnews )
{
	return StdPropertyGet ( m_fDisableNewnews, pfDisableNewnews );
}

STDMETHODIMP CNntpVirtualServer::put_DisableNewnews ( BOOL fDisableNewnews )
{
	return StdPropertyPut ( &m_fDisableNewnews, fDisableNewnews, &m_bvChangedFields, CHNG_DISABLENEWNEWS );
}

STDMETHODIMP CNntpVirtualServer::get_ExpireRunFrequency ( long * plExpireRunFrequency )
{
	return StdPropertyGet ( m_dwExpireRunFrequency, plExpireRunFrequency );
}

STDMETHODIMP CNntpVirtualServer::put_ExpireRunFrequency ( long lExpireRunFrequency )
{
	return StdPropertyPut ( &m_dwExpireRunFrequency, lExpireRunFrequency, &m_bvChangedFields, CHNG_NEWSCRAWLERTIME );
}

STDMETHODIMP CNntpVirtualServer::get_ShutdownLatency ( long * plShutdownLatency )
{
	return StdPropertyGet ( m_dwShutdownLatency, plShutdownLatency );
}

STDMETHODIMP CNntpVirtualServer::put_ShutdownLatency ( long lShutdownLatency )
{
	return StdPropertyPut ( &m_dwShutdownLatency, lShutdownLatency, &m_bvChangedFields, CHNG_SHUTDOWNLATENCY );
}

STDMETHODIMP CNntpVirtualServer::get_ClientPostHardLimit ( long * plClientPostHardLimit )
{
	return StdPropertyGet ( m_dwClientPostHardLimit, plClientPostHardLimit );
}

STDMETHODIMP CNntpVirtualServer::put_ClientPostHardLimit ( long lClientPostHardLimit )
{
	return StdPropertyPut ( &m_dwClientPostHardLimit, lClientPostHardLimit, &m_bvChangedFields, CHNG_CLIENTPOSTHARDLIMIT );
}

STDMETHODIMP CNntpVirtualServer::get_ClientPostSoftLimit ( long * plClientPostSoftLimit )
{
	return StdPropertyGet ( m_dwClientPostSoftLimit, plClientPostSoftLimit );
}

STDMETHODIMP CNntpVirtualServer::put_ClientPostSoftLimit ( long lClientPostSoftLimit )
{
	return StdPropertyPut ( &m_dwClientPostSoftLimit, lClientPostSoftLimit, &m_bvChangedFields, CHNG_CLIENTPOSTSOFTLIMIT );
}

STDMETHODIMP CNntpVirtualServer::get_FeedPostHardLimit ( long * plFeedPostHardLimit )
{
	return StdPropertyGet ( m_dwFeedPostHardLimit, plFeedPostHardLimit );
}

STDMETHODIMP CNntpVirtualServer::put_FeedPostHardLimit ( long lFeedPostHardLimit )
{
	return StdPropertyPut ( &m_dwFeedPostHardLimit, lFeedPostHardLimit, &m_bvChangedFields, CHNG_FEEDPOSTHARDLIMIT );
}

STDMETHODIMP CNntpVirtualServer::get_FeedPostSoftLimit ( long * plFeedPostSoftLimit )
{
	return StdPropertyGet ( m_dwFeedPostSoftLimit, plFeedPostSoftLimit );
}

STDMETHODIMP CNntpVirtualServer::put_FeedPostSoftLimit ( long lFeedPostSoftLimit )
{
	return StdPropertyPut ( &m_dwFeedPostSoftLimit, lFeedPostSoftLimit, &m_bvChangedFields, CHNG_FEEDPOSTSOFTLIMIT );
}

STDMETHODIMP CNntpVirtualServer::get_EnableLogging ( BOOL * pfEnableLogging )
{
	return StdPropertyGet ( m_fEnableLogging, pfEnableLogging );
}

STDMETHODIMP CNntpVirtualServer::put_EnableLogging ( BOOL fEnableLogging )
{
	return StdPropertyPut ( &m_fEnableLogging, fEnableLogging, &m_bvChangedFields2, CHNG2_ENABLELOGGING );
}

// Service-specific properties:

STDMETHODIMP CNntpVirtualServer::get_Organization ( BSTR * pstrOrganization )
{
	return StdPropertyGet ( m_strOrganization, pstrOrganization );
}

STDMETHODIMP CNntpVirtualServer::put_Organization ( BSTR strOrganization )
{
	return StdPropertyPut ( &m_strOrganization, strOrganization, &m_bvChangedFields, CHNG_ORGANIZATION );
}

STDMETHODIMP CNntpVirtualServer::get_UucpName ( BSTR * pstrUucpName )
{
	return StdPropertyGet ( m_strUucpName, pstrUucpName );
}

STDMETHODIMP CNntpVirtualServer::put_UucpName ( BSTR strUucpName )
{
	return StdPropertyPut ( &m_strUucpName, strUucpName, &m_bvChangedFields, CHNG_UUCPNAME );
}

STDMETHODIMP CNntpVirtualServer::get_GroupHelpFile ( BSTR * pstrGroupHelpFile )
{
	return StdPropertyGet ( m_strGroupHelpFile, pstrGroupHelpFile );
}

STDMETHODIMP CNntpVirtualServer::put_GroupHelpFile ( BSTR strGroupHelpFile )
{
	return StdPropertyPut ( &m_strGroupHelpFile, strGroupHelpFile, &m_bvChangedFields, CHNG_GROUPHELPFILE );
}

STDMETHODIMP CNntpVirtualServer::get_GroupListFile ( BSTR * pstrGroupListFile )
{
	return StdPropertyGet ( m_strGroupListFile, pstrGroupListFile );
}

STDMETHODIMP CNntpVirtualServer::put_GroupListFile ( BSTR strGroupListFile )
{
	return StdPropertyPut ( &m_strGroupListFile, strGroupListFile, &m_bvChangedFields, CHNG_GROUPLISTFILE );
}

STDMETHODIMP CNntpVirtualServer::get_GroupVarListFile( BSTR *pstrGroupListFile )
{
    return StdPropertyGet( m_strGroupVarListFile, pstrGroupListFile );
}

STDMETHODIMP CNntpVirtualServer::put_GroupVarListFile( BSTR strGroupVarListFile )
{
    return StdPropertyPut ( &m_strGroupVarListFile, strGroupVarListFile, &m_bvChangedFields, CHNG_GROUPLISTFILE );
}

STDMETHODIMP CNntpVirtualServer::get_ArticleTableFile ( BSTR * pstrArticleTableFile )
{
	return StdPropertyGet ( m_strArticleTableFile, pstrArticleTableFile );
}

STDMETHODIMP CNntpVirtualServer::put_ArticleTableFile ( BSTR strArticleTableFile )
{
	return StdPropertyPut ( &m_strArticleTableFile, strArticleTableFile, &m_bvChangedFields, CHNG_ARTICLETABLEFILE );
}

STDMETHODIMP CNntpVirtualServer::get_HistoryTableFile ( BSTR * pstrHistoryTableFile )
{
	return StdPropertyGet ( m_strHistoryTableFile, pstrHistoryTableFile );
}

STDMETHODIMP CNntpVirtualServer::put_HistoryTableFile ( BSTR strHistoryTableFile )
{
	return StdPropertyPut ( &m_strHistoryTableFile, strHistoryTableFile, &m_bvChangedFields, CHNG_HISTORYTABLEFILE );
}

STDMETHODIMP CNntpVirtualServer::get_ModeratorFile ( BSTR * pstrModeratorFile )
{
	return StdPropertyGet ( m_strModeratorFile, pstrModeratorFile );
}

STDMETHODIMP CNntpVirtualServer::put_ModeratorFile ( BSTR strModeratorFile )
{
	return StdPropertyPut ( &m_strModeratorFile, strModeratorFile, &m_bvChangedFields, CHNG_MODERATORFILE );
}

STDMETHODIMP CNntpVirtualServer::get_XOverTableFile ( BSTR * pstrXOverTableFile )
{
	return StdPropertyGet ( m_strXOverTableFile, pstrXOverTableFile );
}

STDMETHODIMP CNntpVirtualServer::put_XOverTableFile ( BSTR strXOverTableFile )
{
	return StdPropertyPut ( &m_strXOverTableFile, strXOverTableFile, &m_bvChangedFields, CHNG_XOVERTABLEFILE );
}

STDMETHODIMP CNntpVirtualServer::get_AutoStart ( BOOL * pfAutoStart )
{
	return StdPropertyGet ( m_fAutoStart, pfAutoStart );
}

STDMETHODIMP CNntpVirtualServer::put_AutoStart ( BOOL fAutoStart )
{
	return StdPropertyPut ( &m_fAutoStart, fAutoStart, &m_bvChangedFields, CHNG_AUTOSTART );
}

STDMETHODIMP CNntpVirtualServer::get_Comment ( BSTR * pstrComment )
{
    if ( m_strComment.Length() == 0 ) return StdPropertyGet( m_strUucpName, pstrComment );
    else return StdPropertyGet ( m_strComment, pstrComment );
}

STDMETHODIMP CNntpVirtualServer::put_Comment ( BSTR strComment )
{
	return StdPropertyPut ( &m_strComment, strComment, &m_bvChangedFields, CHNG_COMMENT );
}

STDMETHODIMP CNntpVirtualServer::get_Bindings ( INntpServerBindings ** ppBindings )
{
	TraceQuietEnter ( "CNntpVirtualServer::get_Bindings" );

	HRESULT		hr = NOERROR;

	if ( !m_pBindings ) {
		ErrorTrace ( 0, "Didn't call get first" );
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_CALL_GET );
		goto Exit;
	}
	else {
		hr = m_pBindings->QueryInterface ( IID_INntpServerBindings, (void **) ppBindings );
		_ASSERT ( SUCCEEDED(hr) );
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::get_BindingsDispatch ( IDispatch ** ppBindings )
{
	HRESULT							hr	= NOERROR;
	CComPtr<INntpServerBindings>	pBindings;

	hr = get_Bindings ( &pBindings );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBindings->QueryInterface ( IID_IDispatch, (void **) ppBindings );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	return hr;
}

STDMETHODIMP CNntpVirtualServer::get_SecurePort ( long * pdwSecurePort )
{
	return StdPropertyGet ( m_dwSecurePort, pdwSecurePort );
}

STDMETHODIMP CNntpVirtualServer::put_SecurePort ( long dwSecurePort )
{
	return StdPropertyPut ( &m_dwSecurePort, dwSecurePort, &m_bvChangedFields, CHNG_SECUREPORT );
}

STDMETHODIMP CNntpVirtualServer::get_MaxConnections ( long * pdwMaxConnections )
{
	return StdPropertyGet ( m_dwMaxConnections, pdwMaxConnections );
}

STDMETHODIMP CNntpVirtualServer::put_MaxConnections ( long dwMaxConnections )
{
	return StdPropertyPut ( &m_dwMaxConnections, dwMaxConnections, &m_bvChangedFields, CHNG_MAXCONNECTIONS );
}

STDMETHODIMP CNntpVirtualServer::get_ConnectionTimeout ( long * pdwConnectionTimeout )
{
	return StdPropertyGet ( m_dwConnectionTimeout, pdwConnectionTimeout );
}

STDMETHODIMP CNntpVirtualServer::put_ConnectionTimeout ( long dwConnectionTimeout )
{
	return StdPropertyPut ( &m_dwConnectionTimeout, dwConnectionTimeout, &m_bvChangedFields2, CHNG2_CONNECTIONTIMEOUT );
}

STDMETHODIMP CNntpVirtualServer::get_AnonymousUserName ( BSTR * pstrAnonymousUserName )
{
	return StdPropertyGet ( m_strAnonymousUserName, pstrAnonymousUserName );
}

STDMETHODIMP CNntpVirtualServer::put_AnonymousUserName ( BSTR strAnonymousUserName )
{
	return StdPropertyPut ( &m_strAnonymousUserName, strAnonymousUserName, &m_bvChangedFields2, CHNG2_ANONYMOUSUSERNAME );
}

STDMETHODIMP CNntpVirtualServer::get_AnonymousUserPass ( BSTR * pstrAnonymousUserPass )
{
	return StdPropertyGet ( m_strAnonymousUserPass, pstrAnonymousUserPass );
}

STDMETHODIMP CNntpVirtualServer::put_AnonymousUserPass ( BSTR strAnonymousUserPass )
{
	return StdPropertyPut ( &m_strAnonymousUserPass, strAnonymousUserPass, &m_bvChangedFields2, CHNG2_ANONYMOUSUSERPASS );
}

STDMETHODIMP CNntpVirtualServer::get_AutoSyncPassword ( BOOL * pfAutoSyncPassword )
{
	return StdPropertyGet ( m_fAutoSyncPassword, pfAutoSyncPassword );
}

STDMETHODIMP CNntpVirtualServer::put_AutoSyncPassword ( BOOL fAutoSyncPassword )
{
	return StdPropertyPut ( &m_fAutoSyncPassword, fAutoSyncPassword, &m_bvChangedFields2, CHNG2_AUTOSYNCPASSWORD );
}

STDMETHODIMP CNntpVirtualServer::get_PickupDirectory ( BSTR * pstrPickupDirectory )
{
	return StdPropertyGet ( m_strPickupDirectory, pstrPickupDirectory );
}

STDMETHODIMP CNntpVirtualServer::put_PickupDirectory ( BSTR strPickupDirectory )
{
	return StdPropertyPut ( &m_strPickupDirectory, strPickupDirectory, &m_bvChangedFields2, CHNG2_PICKUPDIRECTORY );
}

STDMETHODIMP CNntpVirtualServer::get_FailedPickupDirectory ( BSTR * pstrFailedPickupDirectory )
{
	return StdPropertyGet ( m_strFailedPickupDirectory, pstrFailedPickupDirectory );
}

STDMETHODIMP CNntpVirtualServer::put_FailedPickupDirectory ( BSTR strFailedPickupDirectory )
{
	return StdPropertyPut ( &m_strFailedPickupDirectory, strFailedPickupDirectory, &m_bvChangedFields2, CHNG2_FAILEDPICKUPDIRECTORY );
}

STDMETHODIMP CNntpVirtualServer::get_AuthAnonymous ( BOOL * pfAuthAnonymous )
{
	return StdPropertyGetBit ( m_bvAuthorization, MD_AUTH_ANONYMOUS, pfAuthAnonymous );
}

STDMETHODIMP CNntpVirtualServer::put_AuthAnonymous ( BOOL fAuthAnonymous )
{
	return StdPropertyPutBit ( &m_bvAuthorization, MD_AUTH_ANONYMOUS, fAuthAnonymous );
}

STDMETHODIMP CNntpVirtualServer::get_AuthBasic ( BOOL * pfAuthBasic )
{
	return StdPropertyGetBit ( m_bvAuthorization, MD_AUTH_BASIC, pfAuthBasic );
}

STDMETHODIMP CNntpVirtualServer::put_AuthBasic ( BOOL fAuthBasic )
{
	return StdPropertyPutBit ( &m_bvAuthorization, MD_AUTH_BASIC, fAuthBasic );
}

STDMETHODIMP CNntpVirtualServer::get_AuthMCISBasic ( BOOL * pfAuthMCISBasic )
{
	*pfAuthMCISBasic = FALSE;
	return NOERROR;
//	return StdPropertyGetBit ( m_bvAuthorization, MD_AUTH_MCIS_BASIC, pfAuthMCISBasic );
}

STDMETHODIMP CNntpVirtualServer::put_AuthMCISBasic ( BOOL fAuthMCISBasic )
{
	return NOERROR;
//	return StdPropertyPutBit ( &m_bvAuthorization, MD_AUTH_MCIS_BASIC, fAuthMCISBasic );
}

STDMETHODIMP CNntpVirtualServer::get_AuthNT ( BOOL * pfAuthNT )
{
	return StdPropertyGetBit ( m_bvAuthorization, MD_AUTH_NT, pfAuthNT );
}

STDMETHODIMP CNntpVirtualServer::put_AuthNT ( BOOL fAuthNT )
{
	return StdPropertyPutBit ( &m_bvAuthorization, MD_AUTH_NT, fAuthNT );
}

STDMETHODIMP CNntpVirtualServer::get_SSLNegotiateCert ( BOOL * pfNegotiateCert )
{
	return StdPropertyGetBit ( m_bvSslAccess, MD_ACCESS_NEGO_CERT, pfNegotiateCert );
}

STDMETHODIMP CNntpVirtualServer::put_SSLNegotiateCert ( BOOL fNegotiateCert )
{
	return StdPropertyPutBit ( &m_bvSslAccess, MD_ACCESS_NEGO_CERT, fNegotiateCert ); // , &m_bvChangedFields2, CHNG2_SSLACCESS  );
}

STDMETHODIMP CNntpVirtualServer::get_SSLRequireCert ( BOOL * pfRequireCert )
{
	return StdPropertyGetBit ( m_bvSslAccess, MD_ACCESS_REQUIRE_CERT, pfRequireCert );
}

STDMETHODIMP CNntpVirtualServer::put_SSLRequireCert ( BOOL fRequireCert )
{
	return StdPropertyPutBit ( &m_bvSslAccess, MD_ACCESS_REQUIRE_CERT, fRequireCert ); // , &m_bvChangedFields2, CHNG2_SSLACCESS  );
}

STDMETHODIMP CNntpVirtualServer::get_SSLMapCert ( BOOL * pfMapCert )
{
	return StdPropertyGetBit ( m_bvSslAccess, MD_ACCESS_MAP_CERT, pfMapCert );
}

STDMETHODIMP CNntpVirtualServer::put_SSLMapCert ( BOOL fMapCert )
{
	return StdPropertyPutBit ( &m_bvSslAccess, MD_ACCESS_MAP_CERT, fMapCert ); // , &m_bvChangedFields2, CHNG2_SSLACCESS  );
}

/*

STDMETHODIMP CNntpVirtualServer::get_AuthenticationProviders ( SAFEARRAY ** ppsastrProviders )
{
	return StdPropertyGet ( &m_mszProviders, ppsastrProviders );
}

STDMETHODIMP CNntpVirtualServer::put_AuthenticationProviders ( SAFEARRAY * psastrProviders )
{
	return StdPropertyPut ( &m_mszProviders, psastrProviders );
}

STDMETHODIMP CNntpVirtualServer::get_AuthenticationProvidersVariant ( SAFEARRAY ** ppsavarAuthProviders )
{
	HRESULT			hr;
	SAFEARRAY *		psastrAuthProviders	= NULL;

	hr = get_AuthenticationProviders ( &psastrAuthProviders );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = StringArrayToVariantArray ( psastrAuthProviders, ppsavarAuthProviders );

Exit:
	if ( psastrAuthProviders ) {
		SafeArrayDestroy ( psastrAuthProviders );
	}

	return hr;
}

STDMETHODIMP CNntpVirtualServer::put_AuthenticationProvidersVariant ( SAFEARRAY * psavarAuthProviders )
{
	HRESULT			hr;
	SAFEARRAY *		psastrAuthProviders	= NULL;

	hr = VariantArrayToStringArray ( psavarAuthProviders, &psastrAuthProviders );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = put_AuthenticationProviders ( psastrAuthProviders );

Exit:
	if ( psastrAuthProviders ) {
		SafeArrayDestroy ( psastrAuthProviders );
	}

	return hr;
}

*/

STDMETHODIMP CNntpVirtualServer::get_Administrators ( SAFEARRAY ** ppsastrAdmins )
{
	TraceFunctEnter ( "CNntpVS::get_Administrators" );

	HRESULT		hr	= NOERROR;

    if ( m_psaAdmins ) {
	    hr = SafeArrayCopy ( m_psaAdmins, ppsastrAdmins );
    }
    else {
        *ppsastrAdmins = NULL;
        hr = NOERROR;
    }

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::put_Administrators ( SAFEARRAY * psastrAdmins )
{
	TraceFunctEnter ( "CNntpVS::put_Administrators" );

	HRESULT		hr	= NOERROR;

	if ( m_psaAdmins ) {
		SafeArrayDestroy ( m_psaAdmins );
	}

    if ( psastrAdmins ) {
    	hr = SafeArrayCopy ( psastrAdmins, &m_psaAdmins );
    }
    else {
        m_psaAdmins = NULL;
        hr = NOERROR;
    }

    m_bvChangedFields2 |= CHNG2_ADMINACL;

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::get_AdministratorsVariant ( SAFEARRAY ** ppsavarAdmins )
{
	HRESULT			hr;
	SAFEARRAY *		psastrAdmins	= NULL;

	hr = get_Administrators ( &psastrAdmins );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = StringArrayToVariantArray ( psastrAdmins, ppsavarAdmins );

Exit:
	if ( psastrAdmins ) {
		SafeArrayDestroy ( psastrAdmins );
	}

	return hr;
}

STDMETHODIMP CNntpVirtualServer::put_AdministratorsVariant ( SAFEARRAY * psavarAdmins )
{
	HRESULT			hr;
	SAFEARRAY *		psastrAdmins	= NULL;

	hr = VariantArrayToStringArray ( psavarAdmins, &psastrAdmins );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = put_Administrators ( psastrAdmins );

Exit:
	if ( psastrAdmins ) {
		SafeArrayDestroy ( psastrAdmins );
	}

	return hr;
}

STDMETHODIMP CNntpVirtualServer::get_ClusterEnabled ( BOOL *pfClusterEnabled )
{
	return StdPropertyGet ( m_fClusterEnabled, pfClusterEnabled );
}

STDMETHODIMP CNntpVirtualServer::put_ClusterEnabled ( BOOL fClusterEnabled )
{
	return StdPropertyPut ( &m_fClusterEnabled, fClusterEnabled, &m_bvChangedFields2, CHNG2_CLUSTERENABLED);
}

STDMETHODIMP CNntpVirtualServer::get_State ( NNTP_SERVER_STATE * pState )
{
	if ( pState == NULL ) {
		return E_POINTER;
	}
	*pState = m_State;
	return NOERROR;
}

STDMETHODIMP CNntpVirtualServer::get_Win32ErrorCode ( long * plWin32ErrorCode )
{
	return StdPropertyGet ( m_dwWin32ErrorCode, plWin32ErrorCode );
}

/*
STDMETHODIMP CNntpVirtualServer::get_DisplayName ( BSTR * pstrDisplayName )
{
	return StdPropertyGet ( m_strDisplayName, pstrDisplayName );
}

STDMETHODIMP CNntpVirtualServer::put_DisplayName ( BSTR strDisplayName )
{
	return StdPropertyPut ( &m_strDisplayName, strDisplayName );
}

STDMETHODIMP CNntpVirtualServer::get_ErrorControl ( BOOL * pfErrorControl )
{
	return StdPropertyGet ( m_fErrorControl, pfErrorControl );
}

STDMETHODIMP CNntpVirtualServer::put_ErrorControl ( BOOL fErrorControl )
{
	return StdPropertyPut ( &m_fErrorControl, fErrorControl );
}

STDMETHODIMP CNntpVirtualServer::get_CleanBoot ( BOOL * pfCleanBoot )
{
	return StdPropertyGet ( m_fCleanBoot, pfCleanBoot );
}

STDMETHODIMP CNntpVirtualServer::put_CleanBoot ( BOOL fCleanBoot )
{
	return StdPropertyPut ( &m_fCleanBoot, fCleanBoot );
}

STDMETHODIMP CNntpVirtualServer::get_EncryptionCapabilitiesMask ( long * plEncryptionCapabilitiesMask )
{
	return StdPropertyGet ( m_dwEncryptionCapabilities, plEncryptionCapabilitiesMask );
}

STDMETHODIMP CNntpVirtualServer::put_EncryptionCapabilitiesMask ( long lEncryptionCapabilitiesMask )
{
	return StdPropertyPut ( &m_dwEncryptionCapabilities, lEncryptionCapabilitiesMask, &m_bvChangedFields, CHNG_ENCRYPTIONCAPABILITIES );
}
*/

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::Get
//
//	Description:
//
//		Gets server properties from the metabase.
//
//	Parameters:
//
//		(property) m_strServer
//		(property) m_dwServiceInstance - which NNTP to talk to.
//		pErr - Resulting error code.  This can be translated to a
//			string through the INntpAdmin interface.
//
//	Returns:
//
//		E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//		Additional error conditions are returned through the pErr value.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpVirtualServer::Get ( )
{
	TraceFunctEnter ( "CNntpVirtualServer::Get" );

	HRESULT								hr			= NOERROR;
	CComPtr<IMSAdminBase>				pmetabase;
	CComObject<CNntpServerBindings> *	pBindings	= NULL;

	// Validate Server & Service Instance:

	// Create the bindings collection:
	m_pBindings.Release ();

	hr = CComObject<CNntpServerBindings>::CreateInstance ( &pBindings );
	if ( FAILED(hr) ) {
		FatalTrace ( (LPARAM) this, "Could not create bindings collection" );
		goto Exit;
	}

	hr = pBindings->QueryInterface ( IID_INntpServerBindings, (void **) &m_pBindings );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	m_pPrivateBindings	= pBindings;

	// Talk to the metabase:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = GetPropertiesFromMetabase ( pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	StateTrace ( 0, "Successfully got service properties" );
	m_fGotProperties	= TRUE;
	m_bvChangedFields	= 0;
	m_bvChangedFields2	= 0;

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;

	// CComPtr automatically releases the metabase handle.
}

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::Set
//
//	Description:
//
//		Sends server properties to the metabase.
//
//	Parameters:
//
//		(property) m_strServer
//		fFailIfChanged - return an error if the metabase has changed?
//		pErr - Resulting error code.  This can be translated to a
//			string through the INntpAdmin interface.
//
//	Returns:
//
//		E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//		Additional error conditions are returned through the pErr value.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpVirtualServer::Set ( BOOL fFailIfChanged)
{
	TraceFunctEnter ( "CNntpVirtualServer::Set" );

	HRESULT	hr	= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;
	
	// Make sure the client call Get first:
	if ( !m_fGotProperties ) {
		ErrorTrace ( 0, "Didn't call get first" );
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_CALL_GET );
	}

	// Validate Server & Service Instance:
	if ( m_dwServiceInstance == 0 ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	if ( !m_fGotProperties ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_CALL_GET );
	}

	// Validate data members:
	if ( !ValidateStrings () ) {
		// !!!magnush - what about the case when any strings are NULL?
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	if ( !ValidateProperties ( ) ) {
		hr = RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = SendPropertiesToMetabase ( fFailIfChanged, pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	StateTrace ( 0, "Successfully set service properties" );

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpVirtualServer::ControlService (
	IMSAdminBase *	pMetabase,
	DWORD			ControlCode,
	DWORD			dwDesiredState,
	DWORD			dwPendingState
	)
{
	TraceFunctEnter ( "CNntpVirtualServer::ControlService" );

	HRESULT	hr				= NOERROR;
	DWORD	dwCurrentState	= dwPendingState;
	DWORD	dwOldState		= dwPendingState;
	DWORD	dwSleepTotal	= 0;

	hr = CheckServiceState ( pMetabase, &dwCurrentState );
	BAIL_ON_FAILURE(hr);

	if ( dwCurrentState == dwDesiredState ) {
		// Nothing to do...
		goto Exit;
	}

	dwOldState	= dwCurrentState;

	//
	//	Special case: trying to start a paused service:
	//

	if ( dwDesiredState == MD_SERVER_STATE_STARTED &&
		dwCurrentState == MD_SERVER_STATE_PAUSED ) {

		ControlCode		= MD_SERVER_COMMAND_CONTINUE;
		dwPendingState	= MD_SERVER_STATE_CONTINUING;
	}
	
	hr = WriteStateCommand ( pMetabase, ControlCode );
	BAIL_ON_FAILURE(hr);

	for (	dwSleepTotal = 0, dwCurrentState = dwPendingState;
			(dwCurrentState == dwPendingState || dwCurrentState == dwOldState) && (dwSleepTotal < MAX_SLEEP_INST); 
			dwSleepTotal += SLEEP_INTERVAL
		) {

		Sleep ( SLEEP_INTERVAL );

		hr = CheckServiceState ( pMetabase, &dwCurrentState );
		BAIL_ON_FAILURE(hr);

        if ( m_dwWin32ErrorCode != NOERROR ) {
            //
            // The service gave an error code.
            //

            break;
        }
	}

	if ( dwSleepTotal >= MAX_SLEEP_INST ) {
		hr = HRESULT_FROM_WIN32 ( ERROR_SERVICE_REQUEST_TIMEOUT );
		goto Exit;
	}

Exit:
	m_State = TranslateServerState ( dwCurrentState );

	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpVirtualServer::WriteStateCommand ( IMSAdminBase * pMetabase, DWORD ControlCode )
{
	HRESULT			hr	= NOERROR;
	CMetabaseKey	metabase	( pMetabase );
	WCHAR			wszInstancePath [ METADATA_MAX_NAME_LEN ];

	GetMDInstancePath ( wszInstancePath, m_dwServiceInstance );

	hr = metabase.Open ( wszInstancePath, METADATA_PERMISSION_WRITE );

	hr = StdPutMetabaseProp ( &metabase, MD_WIN32_ERROR, NOERROR, _T(""), IIS_MD_UT_SERVER, METADATA_VOLATILE );
	BAIL_ON_FAILURE (hr);

	hr = StdPutMetabaseProp ( &metabase, MD_SERVER_COMMAND, ControlCode );
	BAIL_ON_FAILURE (hr);

    hr = metabase.Save ();
    BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

HRESULT CNntpVirtualServer::CheckServiceState ( IMSAdminBase * pMetabase, DWORD * pdwState )
{
	HRESULT			hr	= NOERROR;
	CMetabaseKey	metabase ( pMetabase );
	WCHAR			wszInstancePath [ METADATA_MAX_NAME_LEN ];

	*pdwState	= MD_SERVER_STATE_INVALID;

	GetMDInstancePath ( wszInstancePath, m_dwServiceInstance );

	hr = metabase.Open ( wszInstancePath );
	BAIL_ON_FAILURE(hr);

	m_dwWin32ErrorCode = NOERROR;

	metabase.GetDword ( MD_SERVER_STATE, pdwState );
	metabase.GetDword ( MD_WIN32_ERROR, &m_dwWin32ErrorCode );

Exit:
	return hr;
}

STDMETHODIMP CNntpVirtualServer::Start ( )
{
	TraceFunctEnter ( "CNntpVirtualServer::Start" );

	HRESULT					hr		= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = ControlService ( 
		pmetabase, 
		MD_SERVER_COMMAND_START, 
		MD_SERVER_STATE_STARTED, 
		MD_SERVER_STATE_STARTING 
		);

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::Pause ( )
{
	TraceFunctEnter ( "CNntpVirtualServer::Start" );

	HRESULT					hr		= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = ControlService ( 
		pmetabase, 
		MD_SERVER_COMMAND_PAUSE, 
		MD_SERVER_STATE_PAUSED, 
		MD_SERVER_STATE_PAUSING 
		);

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::Continue ( )
{
	TraceFunctEnter ( "CNntpVirtualServer::Start" );

	HRESULT					hr		= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = ControlService ( 
		pmetabase, 
		MD_SERVER_COMMAND_CONTINUE, 
		MD_SERVER_STATE_STARTED, 
		MD_SERVER_STATE_CONTINUING 
		);

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::Stop ( )
{
	TraceFunctEnter ( "CNntpVirtualServer::Start" );

	HRESULT					hr		= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = ControlService ( 
		pmetabase, 
		MD_SERVER_COMMAND_STOP, 
		MD_SERVER_STATE_STOPPED, 
		MD_SERVER_STATE_STOPPING 
		);

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::GetPropertiesFromMetabase
//
//	Description:
//
//		Asks the metabase for each property in this class.
//		This class's properties come from /LM/NntpSvc/
//
//	Parameters:
//
//		pMetabase - The metabase object
//		pErr - Resulting error code.
//
//	Returns:
//
//		E_OUTOFMEMORY or an error code in pErr.
//
//--------------------------------------------------------------------

HRESULT CNntpVirtualServer::GetPropertiesFromMetabase ( IMSAdminBase * pMetabase)
{
	TraceFunctEnter ( "CNntpVirtualServer::GetPropertiesFromMetabase" );

	HRESULT			hr	= NOERROR;
	CMetabaseKey	metabase	( pMetabase );
	WCHAR			wszInstancePath [ METADATA_MAX_NAME_LEN ];
	DWORD			dwServerState	= MD_SERVER_STATE_STOPPED;
	CMultiSz		mszBindings;
	CMultiSz		mszSecureBindings;
	PSECURITY_DESCRIPTOR    pSD     = NULL;
	DWORD		            cbSD    = 0;
	BOOL					fRet;

	GetMDInstancePath ( wszInstancePath, m_dwServiceInstance );

	hr = metabase.Open ( wszInstancePath );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open service instance key, %x", hr );

		// Return some kind of error code here:
//		hr = NntpCreateExceptionFromWin32Error ( hr );
		goto Exit;
	}

	fRet = TRUE;

	// Overridable server properties:
	fRet = StdGetMetabaseProp ( &metabase, MD_ARTICLE_TIME_LIMIT,	NNTP_DEF_ARTICLETIMELIMIT,		&m_dwArticleTimeLimit )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_HISTORY_EXPIRATION,	NNTP_DEF_HISTORYEXPIRATION,		&m_dwHistoryExpiration )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_HONOR_CLIENT_MSGIDS,	NNTP_DEF_HONORCLIENTMSGIDS,		&m_fHonorClientMsgIDs )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SMTP_SERVER,			NNTP_DEF_SMTPSERVER,				&m_strSmtpServer )			&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ADMIN_EMAIL,			NNTP_DEF_ADMIN_EMAIL,				&m_strAdminEmail )			&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ALLOW_CLIENT_POSTS,	NNTP_DEF_ALLOWCLIENTPOSTS,		&m_fAllowClientPosts )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ALLOW_FEED_POSTS,		NNTP_DEF_ALLOWFEEDPOSTS,			&m_fAllowFeedPosts )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ALLOW_CONTROL_MSGS,	NNTP_DEF_ALLOWCONTROLMSGS,		&m_fAllowControlMsgs )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_DEFAULT_MODERATOR,	NNTP_DEF_DEFAULTMODERATORDOMAIN,	&m_strDefaultModeratorDomain )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_NNTP_COMMAND_LOG_MASK, NNTP_DEF_COMMANDLOGMASK,			&m_dwCommandLogMask )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_DISABLE_NEWNEWS,		NNTP_DEF_DISABLENEWNEWS,			&m_fDisableNewnews )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_NEWS_CRAWLER_TIME,	NNTP_DEF_NEWSCRAWLERTIME,		&m_dwExpireRunFrequency )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SHUTDOWN_LATENCY,		NNTP_DEF_SHUTDOWNLATENCY,		&m_dwShutdownLatency )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_LOG_TYPE,				NNTP_DEF_ENABLE_LOGGING,		&m_fEnableLogging )			&& fRet;

	fRet = StdGetMetabaseProp ( &metabase, MD_CLIENT_POST_HARD_LIMIT,	NNTP_DEF_CLIENTPOSTHARDLIMIT,	&m_dwClientPostHardLimit )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_CLIENT_POST_SOFT_LIMIT,	NNTP_DEF_CLIENTPOSTSOFTLIMIT,	&m_dwClientPostSoftLimit )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_FEED_POST_HARD_LIMIT,		NNTP_DEF_FEEDPOSTHARDLIMIT,		&m_dwFeedPostHardLimit )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_FEED_POST_SOFT_LIMIT,		NNTP_DEF_FEEDPOSTSOFTLIMIT,		&m_dwFeedPostSoftLimit )	&& fRet;

	// Service-specific properties:
	fRet = StdGetMetabaseProp ( &metabase, MD_GROUP_HELP_FILE,		NNTP_DEF_GROUPHELPFILE,			&m_strGroupHelpFile )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_GROUP_LIST_FILE,		NNTP_DEF_GROUPLISTFILE,			&m_strGroupListFile )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_GROUPVAR_LIST_FILE,   NNTP_DEF_GROUPVARLISTFILE,      &m_strGroupVarListFile)     && fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ARTICLE_TABLE_FILE,	NNTP_DEF_ARTICLETABLEFILE,		&m_strArticleTableFile )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_HISTORY_TABLE_FILE,	NNTP_DEF_HISTORYTABLEFILE,		&m_strHistoryTableFile )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_MODERATOR_FILE,		NNTP_DEF_MODERATORFILE,			&m_strModeratorFile )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_XOVER_TABLE_FILE,		NNTP_DEF_XOVERTABLEFILE,			&m_strXOverTableFile )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_NNTP_UUCP_NAME,		NNTP_DEF_UUCPNAME,				&m_strUucpName )			&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_NNTP_ORGANIZATION,	NNTP_DEF_ORGANIZATION,			&m_strOrganization )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_AUTOSTART,		NNTP_DEF_AUTOSTART,				&m_fAutoStart )				&& fRet;

	fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_COMMENT,		NNTP_DEF_COMMENT,				&m_strComment )				&& fRet;
#if 0
	fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_PORT,			NNTP_DEF_SECUREPORT,				&m_dwSecurePort )			&& fRet;
#endif
	fRet = StdGetMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,		NNTP_DEF_MAXCONNECTIONS,			&m_dwMaxConnections )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,	NNTP_DEF_CONNECTIONTIMEOUT,		&m_dwConnectionTimeout )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ANONYMOUS_USER_NAME,	NNTP_DEF_ANONYMOUSUSERNAME,		&m_strAnonymousUserName )	&& fRet;
	if ( fRet && !StdGetMetabaseProp ( &metabase, MD_ANONYMOUS_PWD,		NNTP_DEF_ANONYMOUSUSERPASS,		&m_strAnonymousUserPass, _T(""), IIS_MD_UT_FILE, METADATA_INHERIT | METADATA_SECURE ) ) {
		m_strAnonymousUserPass = _T("");
		fRet = TRUE;
	}
	fRet = StdGetMetabaseProp ( &metabase, MD_ANONYMOUS_USE_SUBAUTH,	FALSE,						&m_fAutoSyncPassword )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_PICKUP_DIRECTORY,		NNTP_DEF_PICKUPDIRECTORY,		&m_strPickupDirectory )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_FAILED_PICKUP_DIRECTORY,	NNTP_DEF_FAILEDPICKUPDIRECTORY,	&m_strFailedPickupDirectory )	&& fRet;

	fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_STATE,			MD_SERVER_STATE_INVALID,		&dwServerState )			&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_BINDINGS,		NNTP_DEF_BINDINGS,				&mszBindings )				&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_BINDINGS,		NNTP_DEF_SECURE_BINDINGS,		&mszSecureBindings )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_WIN32_ERROR,			NOERROR,						&m_dwWin32ErrorCode,
			_T(""), IIS_MD_UT_SERVER, METADATA_VOLATILE)		&& fRet;

	fRet = StdGetMetabaseProp ( &metabase, MD_AUTHORIZATION,		NNTP_DEF_AUTHORIZATION,			&m_bvAuthorization )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SSL_ACCESS_PERM,		0,								&m_bvSslAccess )		&& fRet;
//	fRet = StdGetMetabaseProp ( &metabase, MD_NTAUTHENTICATION_PROVIDERS,	NNTP_DEF_NTAUTHENTICATION_PROVIDERS,	&m_mszProviders ) && fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_CLUSTER_ENABLED,		NNTP_DEF_CLUSTERENABLED,		&m_fClusterEnabled )	&& fRet;

	//	Get the admin ACL
	pSD     = NULL;
	cbSD    = 0;

	hr = metabase.GetDataSize ( _T(""), MD_ADMIN_ACL, BINARY_METADATA, &cbSD );
	if ( SUCCEEDED(hr) ) {
		_ASSERT ( cbSD != 0 );
		pSD = (PSECURITY_DESCRIPTOR) new char [ cbSD ];
		hr = metabase.GetBinary ( MD_ADMIN_ACL, pSD, cbSD );
	}
	hr = NOERROR;

	//
	//	Get the tcp access restrictions:
	//

	hr = m_pPrivateIpAccess->GetFromMetabase ( &metabase );
	BAIL_ON_FAILURE(hr);

	// Check all property strings:
	// If any string is NULL, it is because we failed to allocate memory:
	if ( !ValidateStrings () || !mszBindings) {

		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// We can only fail from memory allocations:
	_ASSERT ( fRet );

	// Extract the server state:
	m_State = TranslateServerState ( dwServerState );

	// Save the last changed time for this key:
	m_ftLastChanged.dwHighDateTime	= 0;
	m_ftLastChanged.dwLowDateTime	= 0;

	hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
		// Ignore this error.
		hr = NOERROR;
	}

	metabase.Close();

	// Extract the bindings:
	hr = MDBindingsToIBindings ( &mszBindings, TRUE, m_pBindings );
	BAIL_ON_FAILURE(hr);

	hr = MDBindingsToIBindings ( &mszSecureBindings, FALSE, m_pBindings );
	BAIL_ON_FAILURE(hr);

	// Extract the Administrator list:
	if ( m_psaAdmins ) {
		SafeArrayDestroy ( m_psaAdmins );
		m_psaAdmins	= NULL;
	}
	if ( pSD ) {
		hr = AclToAdministrators ( m_strServer, pSD, &m_psaAdmins );
		BAIL_ON_FAILURE(hr);
	}

	// Validate the data received from the metabase:
	_ASSERT ( ValidateStrings () );
	_ASSERT ( ValidateProperties( ) );

	if ( !ValidateProperties( ) ) {
		CorrectProperties ();
	}

Exit:
	delete (char*) pSD;

	TraceFunctLeave ();
	return hr;

	// MB automatically closes its handle
}

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::SendPropertiesToMetabase
//
//	Description:
//
//		Saves each property to the metabase.
//		This class's properties go into /LM/NntpSvc/
//
//	Parameters:
//
//		fFailIfChanged	- Return a failure code if the metabase
//			has changed since last get.
//		pMetabase - the metabase object.
//		pErr - resulting error code.
//
//	Returns:
//
//		E_OUTOFMEMORY or resulting error code in pErr.
//
//--------------------------------------------------------------------

HRESULT CNntpVirtualServer::SendPropertiesToMetabase ( 
	BOOL fFailIfChanged, 
	IMSAdminBase * pMetabase
	)
{
	TraceFunctEnter ( "CNntpVirtualServer::SendPropertiesToMetabase" );

	HRESULT			hr	= NOERROR;
	CMetabaseKey	metabase	( pMetabase );
	WCHAR			wszInstancePath [ METADATA_MAX_NAME_LEN ];
	CMultiSz		mszBindings;
	CMultiSz		mszSecureBindings;
	BOOL			fRet;

	//
	//	Set the admin acl:
	//

	PSECURITY_DESCRIPTOR    pSD     = NULL;
	DWORD	                cbSD    = 0;

	if ( m_bvChangedFields2 & CHNG2_ADMINACL ) {
	    if ( m_psaAdmins ) {
		    hr = AdministratorsToAcl ( m_strServer, m_psaAdmins, &pSD, &cbSD );
		    BAIL_ON_FAILURE(hr);
	    }
	}

	//
	//	Open the metabase key:
	//

	GetMDInstancePath ( wszInstancePath, m_dwServiceInstance );

	hr = metabase.Open ( wszInstancePath, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open instance key, %x", hr );

		// !!!magnush - Should we return a simple Service doesn't exist error code?
//		hr = NntpCreateExceptionFromWin32Error ( GetLastError () );
		goto Exit;
	}

	// Does the client care if the key has changed?
	if ( fFailIfChanged ) {

		//	Did the key change?
		if ( HasKeyChanged ( pMetabase, metabase.QueryHandle(), &m_ftLastChanged ) ) {

			StateTrace ( (LPARAM) this, "Metabase has changed, not setting properties" );
			// !!!magnush - Return the appropriate error code:
			hr = E_FAIL;
			goto Exit;
		}
	}

	// Extract the bindings:
	hr = IBindingsToMDBindings ( m_pBindings, TRUE, &mszBindings );
	BAIL_ON_FAILURE(hr);

	hr = IBindingsToMDBindings ( m_pBindings, FALSE, &mszSecureBindings );
	BAIL_ON_FAILURE(hr);

	//
	//	The general procedure here is to keep setting metabase properties
	//	as long as nothing has gone wrong.  This is done by short-circuiting
	//	the statement by ANDing it with the status code.  This makes the code
	//	much more concise.
	//

	fRet = TRUE;

	// Overridable server properties:
	if ( m_bvChangedFields & CHNG_ARTICLETIMELIMIT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ARTICLE_TIME_LIMIT,	m_dwArticleTimeLimit );
	}

	if ( m_bvChangedFields & CHNG_HISTORYEXPIRATION ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_HISTORY_EXPIRATION,	m_dwHistoryExpiration );
	}

	if ( m_bvChangedFields & CHNG_HONORCLIENTMSGIDS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_HONOR_CLIENT_MSGIDS,	m_fHonorClientMsgIDs );
	}

	if ( m_bvChangedFields & CHNG_SMTPSERVER ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SMTP_SERVER,			m_strSmtpServer );
	}

	if ( m_bvChangedFields2 & CHNG2_ADMINEMAIL) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ADMIN_EMAIL,			m_strAdminEmail );
	}

	if ( m_bvChangedFields & CHNG_ALLOWCLIENTPOSTS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ALLOW_CLIENT_POSTS,	m_fAllowClientPosts );
	}

	if ( m_bvChangedFields & CHNG_ALLOWFEEDPOSTS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ALLOW_FEED_POSTS,		m_fAllowFeedPosts );
	}

	if ( m_bvChangedFields & CHNG_ALLOWCONTROLMSGS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ALLOW_CONTROL_MSGS,	m_fAllowControlMsgs );
	}

	if ( m_bvChangedFields & CHNG_DEFAULTMODERATORDOMAIN ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_DEFAULT_MODERATOR,	m_strDefaultModeratorDomain );
	}

	if ( m_bvChangedFields & CHNG_COMMANDLOGMASK ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NNTP_COMMAND_LOG_MASK,m_dwCommandLogMask );
	}

	if ( m_bvChangedFields & CHNG_DISABLENEWNEWS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_DISABLE_NEWNEWS,		m_fDisableNewnews );
	}

	if ( m_bvChangedFields & CHNG_NEWSCRAWLERTIME ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NEWS_CRAWLER_TIME,	m_dwExpireRunFrequency );
	}

	if ( m_bvChangedFields & CHNG_SHUTDOWNLATENCY ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SHUTDOWN_LATENCY,		m_dwShutdownLatency );
	}

	if ( m_bvChangedFields & CHNG_CLIENTPOSTHARDLIMIT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_CLIENT_POST_HARD_LIMIT,	m_dwClientPostHardLimit );
	}

	if ( m_bvChangedFields & CHNG_CLIENTPOSTSOFTLIMIT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_CLIENT_POST_SOFT_LIMIT,	m_dwClientPostSoftLimit );
	}

	if ( m_bvChangedFields & CHNG_FEEDPOSTHARDLIMIT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_FEED_POST_HARD_LIMIT,		m_dwFeedPostHardLimit );
	}

	if ( m_bvChangedFields & CHNG_FEEDPOSTSOFTLIMIT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_FEED_POST_SOFT_LIMIT,		m_dwFeedPostSoftLimit );
	}

	if ( m_bvChangedFields2 & CHNG2_ENABLELOGGING ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,					m_fEnableLogging );
	}

	// Service specific properties:
	if ( m_bvChangedFields & CHNG_GROUPHELPFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_GROUP_HELP_FILE,		m_strGroupHelpFile );
	}

	if ( m_bvChangedFields & CHNG_GROUPLISTFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_GROUP_LIST_FILE,		m_strGroupListFile );
		// BUGBUG: we share this change field, since Magnus didn't leave more space for
		// change bit
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_GROUPVAR_LIST_FILE,   m_strGroupVarListFile );
	}

	if ( m_bvChangedFields & CHNG_ARTICLETABLEFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ARTICLE_TABLE_FILE,	m_strArticleTableFile );
	}

	if ( m_bvChangedFields & CHNG_HISTORYTABLEFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_HISTORY_TABLE_FILE,	m_strHistoryTableFile );
	}

	if ( m_bvChangedFields & CHNG_MODERATORFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_MODERATOR_FILE,		m_strModeratorFile );
	}

	if ( m_bvChangedFields & CHNG_XOVERTABLEFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_XOVER_TABLE_FILE,		m_strXOverTableFile );
	}

	if ( m_bvChangedFields & CHNG_UUCPNAME ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NNTP_UUCP_NAME,		m_strUucpName );
	}

	if ( m_bvChangedFields & CHNG_ORGANIZATION ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NNTP_ORGANIZATION,	m_strOrganization );
	}

	if ( m_bvChangedFields & CHNG_AUTOSTART ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_AUTOSTART,		m_fAutoStart );
	}

	if ( m_bvChangedFields & CHNG_COMMENT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_COMMENT,		m_strComment );
	}

#if 0
	if ( m_bvChangedFields & CHNG_SECUREPORT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SECURE_PORT,			m_dwSecurePort );
	}
#endif

	if ( m_bvChangedFields & CHNG_MAXCONNECTIONS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,		m_dwMaxConnections );
	}

	if ( m_bvChangedFields2 & CHNG2_CONNECTIONTIMEOUT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,	m_dwConnectionTimeout );
	}

	if ( m_bvChangedFields2 & CHNG2_ANONYMOUSUSERNAME ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ANONYMOUS_USER_NAME,	m_strAnonymousUserName, _T(""), IIS_MD_UT_FILE );
	}

	if ( m_bvChangedFields2 & CHNG2_ANONYMOUSUSERPASS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ANONYMOUS_PWD,		m_strAnonymousUserPass, _T(""), IIS_MD_UT_FILE, METADATA_INHERIT | METADATA_SECURE );
	}

	if ( m_bvChangedFields2 & CHNG2_AUTOSYNCPASSWORD ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ANONYMOUS_USE_SUBAUTH,	m_fAutoSyncPassword, _T(""), IIS_MD_UT_FILE );
	}

	if ( m_bvChangedFields2 & CHNG2_PICKUPDIRECTORY ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_PICKUP_DIRECTORY,		m_strPickupDirectory );
	}

	if ( m_bvChangedFields2 & CHNG2_FAILEDPICKUPDIRECTORY ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_FAILED_PICKUP_DIRECTORY,	m_strFailedPickupDirectory );
	}

	if ( m_bvChangedFields2 & CHNG2_CLUSTERENABLED ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_CLUSTER_ENABLED,	m_fClusterEnabled );
	}

//	if ( m_bvChangedFields & CHNG_AUTHORIZATION ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_AUTHORIZATION,		m_bvAuthorization, _T(""), IIS_MD_UT_FILE );
//	}

//	if ( m_bvChangedFields & CHNG2_SSLACCESS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SSL_ACCESS_PERM,		m_bvSslAccess, _T(""), IIS_MD_UT_FILE );
//	}

//	if ( m_bvChangedFields & CHNG_NTAUTHENTICATION_PROVIDERS ) {
//		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NTAUTHENTICATION_PROVIDERS,	&m_mszProviders );
//	}

//	if ( m_bvChangedFields & CHNG_BINDINGS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_BINDINGS,		&mszBindings );
//	}

//	if ( m_bvChangedFields & CHNG_SECURE_BINDINGS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SECURE_BINDINGS,		&mszSecureBindings );
//	}

	if ( m_bvChangedFields2 & CHNG2_ADMINACL ) {
		if ( pSD ) {
		    if (fRet) {
		        hr = metabase.SetBinary ( MD_ADMIN_ACL, pSD, cbSD,
		            METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE, IIS_MD_UT_FILE );
		        if (FAILED(hr)) {
		            fRet = FALSE;
		            goto Exit;
		        }
		    }
		}
		else {
			pMetabase->DeleteData ( metabase.QueryHandle(), _T(""), MD_ADMIN_ACL, BINARY_METADATA );
		}
	}

//	if ( m_bvChangedFields & CHNG_IPACCESS ) {
		hr = m_pPrivateIpAccess->SendToMetabase ( &metabase );
		BAIL_ON_FAILURE(hr);
//	}

	if ( !fRet ) {
		hr = RETURNCODETOHRESULT ( GetLastError () );
		goto Exit;
	}

	// Save the data to the metabase:
	hr = metabase.Save ();
    BAIL_ON_FAILURE(hr);

	// Save the last changed time for this key:
	m_ftLastChanged.dwHighDateTime	= 0;
	m_ftLastChanged.dwLowDateTime	= 0;

	hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
		// Ignore this error.
		hr = NOERROR;
	}

Exit:
	delete (char *) pSD;

	TraceFunctLeave ();
	return hr;

	// MB automatically closes its handle
}

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::ValidateStrings
//
//	Description:
//
//		Checks to make sure each string property is non-null.
//
//	Returns:
//
//		FALSE if any string property is NULL.
//
//--------------------------------------------------------------------

BOOL CNntpVirtualServer::ValidateStrings ( ) const
{
	TraceFunctEnter ( "CNntpVirtualServer::ValidateStrings" );

	// Check all property strings:
	// If any string is NULL, return FALSE:
	if ( 
		!m_strSmtpServer ||
		!m_strDefaultModeratorDomain	||
		!m_strGroupHelpFile		||
		!m_strGroupListFile		||
		!m_strGroupVarListFile  ||
		!m_strArticleTableFile	||
		!m_strHistoryTableFile	||
		!m_strModeratorFile		||
		!m_strXOverTableFile	||
		!m_strUucpName			||
		!m_strOrganization		||
		!m_strComment			||
		!m_strAnonymousUserName	||
		!m_strAnonymousUserPass ||
		!m_strPickupDirectory	||
		!m_strFailedPickupDirectory
		) {

		ErrorTrace ( (LPARAM) this, "String validation failed" );

		TraceFunctLeave ();
		return FALSE;
	}

	_ASSERT ( IS_VALID_STRING ( m_strSmtpServer ) );
	_ASSERT ( IS_VALID_STRING ( m_strDefaultModeratorDomain ) );
	_ASSERT ( IS_VALID_STRING ( m_strGroupHelpFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strGroupListFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strGroupVarListFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strArticleTableFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strHistoryTableFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strModeratorFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strXOverTableFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strUucpName ) );
	_ASSERT ( IS_VALID_STRING ( m_strOrganization ) );
	_ASSERT ( IS_VALID_STRING ( m_strComment ) );
	_ASSERT ( IS_VALID_STRING ( m_strAnonymousUserName ) );
	_ASSERT ( IS_VALID_STRING ( m_strAnonymousUserPass ) );
	_ASSERT ( IS_VALID_STRING ( m_strPickupDirectory ) );
	_ASSERT ( IS_VALID_STRING ( m_strFailedPickupDirectory ) );

	TraceFunctLeave ();
	return TRUE;
}

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::ValidateProperties
//
//	Description:
//
//		Checks to make sure all parameters are valid.
//
//	Parameters:
//
//		pErr - resulting error code.
//
//	Returns:
//
//		FALSE if any property was not valid.  In this case pErr
//		will contain an error that describes the invalid condition.
//
//--------------------------------------------------------------------

BOOL CNntpVirtualServer::ValidateProperties ( ) const
{
	BOOL	fRet	= TRUE;
	
	_ASSERT ( ValidateStrings () );

	fRet = fRet && PV_MinMax	( m_dwArticleTimeLimit, MIN_ARTICLETIMELIMIT, MAX_ARTICLETIMELIMIT );
	fRet = fRet && PV_MinMax	( m_dwHistoryExpiration, MIN_HISTORYEXPIRATION, MAX_HISTORYEXPIRATION );
	fRet = fRet && PV_Boolean	( m_fHonorClientMsgIDs );
	fRet = fRet && PV_MaxChars	( m_strSmtpServer, MAXLEN_SMTPSERVER );
	fRet = fRet && PV_Boolean	( m_fAllowClientPosts );
	fRet = fRet && PV_Boolean	( m_fAllowFeedPosts );
	fRet = fRet && PV_Boolean	( m_fAllowControlMsgs );
	fRet = fRet && PV_MaxChars	( m_strDefaultModeratorDomain, MAXLEN_DEFAULTMODERATORDOMAIN );
	fRet = fRet && PV_MinMax	( m_dwCommandLogMask, MIN_COMMANDLOGMASK, MAX_COMMANDLOGMASK );
	fRet = fRet && PV_Boolean	( m_fDisableNewnews );
	fRet = fRet && PV_MinMax	( m_dwExpireRunFrequency, MIN_NEWSCRAWLERTIME, MAX_NEWSCRAWLERTIME );
	fRet = fRet && PV_MinMax	( m_dwShutdownLatency, MIN_SHUTDOWNLATENCY, MAX_SHUTDOWNLATENCY );
	fRet = fRet && PV_Boolean	( m_fAutoStart );
	fRet = fRet && PV_Boolean	( m_fClusterEnabled );

	return fRet;
}

void CNntpVirtualServer::CorrectProperties ( )
{
	if ( m_strServer && !PV_MaxChars	( m_strServer, MAXLEN_SERVER ) ) {
		m_strServer[ MAXLEN_SERVER - 1 ] = NULL;
	}
	if ( !PV_MinMax	( m_dwArticleTimeLimit, MIN_ARTICLETIMELIMIT, MAX_ARTICLETIMELIMIT ) ) {
		m_dwArticleTimeLimit	= NNTP_DEF_ARTICLETIMELIMIT;
	}
	if ( !PV_MinMax	( m_dwHistoryExpiration, MIN_HISTORYEXPIRATION, MAX_HISTORYEXPIRATION ) ) {
		m_dwHistoryExpiration	= NNTP_DEF_HISTORYEXPIRATION;
	}
	if ( !PV_Boolean	( m_fHonorClientMsgIDs ) ) {
		m_fHonorClientMsgIDs	= !!m_fHonorClientMsgIDs;
	}
	if ( !PV_MaxChars	( m_strSmtpServer, MAXLEN_SMTPSERVER ) ) {
		m_strSmtpServer[ MAXLEN_SMTPSERVER - 1 ] = NULL;
	}
	if ( !PV_Boolean	( m_fAllowClientPosts ) ) {
		m_fAllowClientPosts	= !!m_fAllowClientPosts;
	}
	if ( !PV_Boolean	( m_fAllowFeedPosts ) ) {
		m_fAllowFeedPosts	= !!m_fAllowFeedPosts;
	}
	if ( !PV_Boolean	( m_fAllowControlMsgs ) ) {
		m_fAllowControlMsgs	= !!m_fAllowControlMsgs;
	}
	if ( !PV_MaxChars	( m_strDefaultModeratorDomain, MAXLEN_DEFAULTMODERATORDOMAIN ) ) {
		m_strDefaultModeratorDomain[ MAXLEN_DEFAULTMODERATORDOMAIN - 1] = NULL;
	}
	if ( !PV_MinMax	( m_dwCommandLogMask, MIN_COMMANDLOGMASK, MAX_COMMANDLOGMASK ) ) {
		m_dwCommandLogMask	= NNTP_DEF_COMMANDLOGMASK;
	}
	if ( !PV_Boolean	( m_fDisableNewnews ) ) {
		m_fDisableNewnews	= !!m_fDisableNewnews;
	}
	if ( !PV_MinMax	( m_dwExpireRunFrequency, MIN_NEWSCRAWLERTIME, MAX_NEWSCRAWLERTIME ) ) {
		m_dwExpireRunFrequency	= NNTP_DEF_NEWSCRAWLERTIME;
	}
	if ( !PV_MinMax	( m_dwShutdownLatency, MIN_SHUTDOWNLATENCY, MAX_SHUTDOWNLATENCY ) ) {
		m_dwShutdownLatency		= NNTP_DEF_SHUTDOWNLATENCY;
	}
	if ( !PV_Boolean	( m_fAutoStart ) ) {
		m_fAutoStart		= !!m_fAutoStart;
	}
	if ( !PV_Boolean	( m_fClusterEnabled ) ) {
		m_fClusterEnabled	= !!m_fClusterEnabled;
	}

	_ASSERT ( ValidateProperties ( ) );
}

NNTP_SERVER_STATE CNntpVirtualServer::TranslateServerState ( DWORD dwState )
{
	NNTP_SERVER_STATE	result	= NNTP_SERVER_STATE_UNKNOWN;

	switch ( dwState ) {
	case MD_SERVER_STATE_STARTING:
		result	= NNTP_SERVER_STATE_STARTING;
		break;

	case MD_SERVER_STATE_STARTED:
		result	= NNTP_SERVER_STATE_STARTED;
		break;

	case MD_SERVER_STATE_STOPPING:
		result	= NNTP_SERVER_STATE_STOPPING;
		break;

	case MD_SERVER_STATE_STOPPED:
		result	= NNTP_SERVER_STATE_STOPPED;
		break;

	case MD_SERVER_STATE_PAUSING:
		result	= NNTP_SERVER_STATE_PAUSING;
		break;

	case MD_SERVER_STATE_PAUSED:
		result	= NNTP_SERVER_STATE_PAUSED;
		break;

	case MD_SERVER_STATE_CONTINUING:
		result	= NNTP_SERVER_STATE_CONTINUING;
		break;

	case MD_SERVER_STATE_INVALID:
		result	= NNTP_SERVER_STATE_UNKNOWN;
		break;

	default:
		_ASSERT ( FALSE );
		break;
	}

	return result;
}

HRESULT AclToAdministrators ( LPCTSTR strServer, PSECURITY_DESCRIPTOR pSDRelative, SAFEARRAY ** ppsaAdmins )
{
    HRESULT         hr          = NOERROR;
    SAFEARRAY *     psaResult   = NULL;
    SAFEARRAYBOUND  rgsaBound[1];
    DWORD           cbAcl;
    long            cValidAdmins;
    long            cAdmins;
    long            i;
    long            iValid;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pAcl;
    BOOL fDaclPresent;
    BOOL fDaclDef;

    pSD = (PSECURITY_DESCRIPTOR)pSDRelative;
    if (pSD == NULL)
    {
        //
        // Empty...
        //
        return ERROR_SUCCESS;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        return GetLastError();
    }

    _VERIFY(GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pAcl, &fDaclDef));
    if (!fDaclPresent || pAcl == NULL)
    {
        return ERROR_SUCCESS;
    }

    if (!IsValidAcl(pAcl))
    {
        return GetLastError();
    }

    cAdmins = pAcl->AceCount;
    cbAcl   = pAcl->AclSize;

    //
    //  Count valid Acls:
    //

    for ( cValidAdmins = 0, i = 0; i < cAdmins; i++ ) {
        PVOID           pAce;
        PACE_HEADER     pAceHeader;

        if ( GetAce(pAcl, i, &pAce) ) {
            pAceHeader = (PACE_HEADER)pAce;

            if ( pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE ) {
                ACCESS_MASK AccessMask;

                AccessMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask;

                if ( AccessMask & FILE_GENERIC_WRITE ) {
                    // Only count admins with write access.

                    cValidAdmins++;
                }
            }
        }
    }

    rgsaBound[0].lLbound    = 0;
    rgsaBound[0].cElements  = cValidAdmins;
    psaResult = SafeArrayCreate ( VT_BSTR, 1, rgsaBound );

    if ( !psaResult ) {
        BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
    }

    for ( iValid = 0, i = 0; i < cAdmins; i++ ) {
        PVOID           pAce;
        PACE_HEADER     pAceHeader;
        PSID            pSID;

        if ( GetAce(pAcl, i, &pAce) ) {
            pAceHeader = (PACE_HEADER)pAce;

            if ( pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE ) {
                ACCESS_MASK AccessMask;

                AccessMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask;

                if ( AccessMask & FILE_GENERIC_WRITE ) {
                    CComBSTR    str;
                    pSID = (PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;

                    hr = SidToString ( strServer, pSID, &str );
                    BAIL_ON_FAILURE(hr);

                    hr = SafeArrayPutElement ( psaResult, &iValid, (PVOID) str );
                    BAIL_ON_FAILURE(hr);

                    iValid++;
                }
            }
        }
    }

    if ( *ppsaAdmins ) {
        SafeArrayDestroy ( *ppsaAdmins );
    }
    *ppsaAdmins = psaResult;

Exit:
    return hr;
}


PSID
GetOwnerSID()
/*++

Routine Description:

Arguments:

Return Value:

    Owner sid

--*/
{
    PSID pSID = NULL;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    if (!AllocateAndInitializeSid(
        &NtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &pSID))
    {
        _ASSERT( 0 );
        //TRACEEOLID("Unable to get primary SID " << ::GetLastError());
    }

    return pSID;
}


HRESULT AdministratorsToAcl ( 
    LPCTSTR     strServer,
    SAFEARRAY * psaAdmins, 
    PSECURITY_DESCRIPTOR* ppSD, 
    DWORD * pcbSD 
    )
{
    HRESULT     hr  = NOERROR;
    long        lBound;
    long        uBound;
    long        i;
    BOOL        fRet;
    DWORD       cbAcl;
    PACL        pAclResult  = NULL;
    PSID        pSID;

    *ppSD   = NULL;
    *pcbSD  = 0;

    if ( psaAdmins == NULL ) {
        lBound = 0;
        uBound = -1;
    }
    else {
        SafeArrayGetLBound ( psaAdmins, 1, &lBound );
        SafeArrayGetUBound ( psaAdmins, 1, &uBound );
    }

    // Do we have an array of Domain\Usernames?
    if ( lBound > uBound ) {
        // Nothing in the array, so the ACL is NULL.
        goto Exit;
    }

    //
    // Calculate ACL size:
    //
    cbAcl = sizeof (ACL);

    for ( i = lBound; i <= uBound ; i++ ) {
        CComBSTR    str;

        pSID = NULL;

        SafeArrayGetElement ( psaAdmins, &i, &str );

        hr = StringToSid ( strServer, str, &pSID );

        if ( SUCCEEDED(hr) && IsValidSid(pSID)) {
            cbAcl += GetLengthSid ( pSID );
            cbAcl += sizeof ( ACCESS_ALLOWED_ACE );
            cbAcl -= sizeof (DWORD);
        }
        hr = NOERROR;

        delete pSID;
    }

    pAclResult = (PACL) new char [ cbAcl ];
    if ( !pAclResult ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    fRet = InitializeAcl ( pAclResult, cbAcl, ACL_REVISION );
    _ASSERT ( fRet );
    if ( !fRet ) {
        BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT(GetLastError() ) );
    }

    //
    //  Create ACL:
    //
    for ( i = lBound; i <= uBound; i++ ) {
        CComBSTR    str;
        PSID        pSID;

        pSID = NULL;

        SafeArrayGetElement ( psaAdmins, &i, &str );

        hr = StringToSid ( strServer, str, &pSID );
        if ( SUCCEEDED(hr) ) {
            fRet = AddAccessAllowedAce ( 
                pAclResult, 
                ACL_REVISION, 
                FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
                pSID
                );

            if ( !fRet ) {
                BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT(GetLastError() ) );
            }
        }
        hr = NOERROR;

        delete pSID;
    }

    //
    // Build the security descriptor
    //
    PSECURITY_DESCRIPTOR pSD;
    pSD = new char[SECURITY_DESCRIPTOR_MIN_LENGTH];
    _VERIFY(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
    _VERIFY(SetSecurityDescriptorDacl(pSD, TRUE, pAclResult, FALSE));

    //
    // Set owner and primary group
    //
    pSID = GetOwnerSID();
    _ASSERT(pSID);
    _VERIFY(SetSecurityDescriptorOwner(pSD, pSID, TRUE));
    _VERIFY(SetSecurityDescriptorGroup(pSD, pSID, TRUE));

    //
    // Convert to self-relative
    //
    PSECURITY_DESCRIPTOR pSDSelfRelative;
    pSDSelfRelative = NULL;
    DWORD dwSize;
    dwSize = 0L;
    MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);
    pSDSelfRelative = new char[dwSize]; 
    MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);

    //
    // Clean up
    //
    delete (char*)pSD;
    FreeSid( pSID );


    _ASSERT ( SUCCEEDED(hr) );
    *ppSD   = pSDSelfRelative;
    *pcbSD  = dwSize;

Exit:
    if ( FAILED(hr) ) {
        delete pAclResult;
    }
    return hr;
}

HRESULT SidToString ( LPCWSTR strSystemName, PSID pSID, BSTR * pStr )
{
	HRESULT			hr 				= NOERROR;
	BOOL			fLookup;
	SID_NAME_USE	SidToNameUse;
	WCHAR			wszUsername [ PATHLEN ];
	DWORD			cbUsername		= sizeof ( wszUsername );
	WCHAR			wszDomain [ PATHLEN ];
	DWORD			cbDomain		= sizeof ( wszDomain );
	WCHAR			wszResult [ 2 * PATHLEN + 2 ];
	LPWSTR			pwszSid = NULL;

	fLookup = LookupAccountSid ( 
		strSystemName,
		pSID,
		wszUsername,
		&cbUsername,
		wszDomain,
		&cbDomain,
		&SidToNameUse
		);
		
	if ( !fLookup && GetLastError() != ERROR_NONE_MAPPED) {
		BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT (GetLastError ()) );
	}

	if (fLookup) {
		wsprintf ( wszResult, _T("%s\\%s"), wszDomain, wszUsername );
	} else {
		// Couldn't get the username.  Convert it to a string of the form .\S-1-5-xxx
		if (!ConvertSidToStringSid(pSID, &pwszSid)) {
			BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT (GetLastError ()) );
		}
		wsprintf(wszResult, _T(".\\%s"), pwszSid);
	}

	*pStr = ::SysAllocString ( wszResult );
	if (*pStr == NULL)
		hr = E_OUTOFMEMORY;

Exit:
	if (pwszSid) {
		LocalFree(pwszSid);
	}

	return hr;
}

HRESULT StringToSid ( LPCWSTR strSystemName, LPWSTR str, PSID * ppSID )
{
	HRESULT			hr	= NOERROR;
	BOOL			fLookup;
	WCHAR			wszRefDomain[PATHLEN];
	DWORD			cbRefDomain = sizeof ( wszRefDomain );
	DWORD			cbSid = 0;
	SID_NAME_USE	SidNameUse;
	BOOL			fIsSID = FALSE;
	PSID			pSID = NULL;

	*ppSID = NULL;

	//
	// If the string starts with .\, then a SID follows rather than a domain\user
	//

	if (str[0] == L'.' && str[1] == L'\\') {
		fIsSID = TRUE;
		str+=2;
	}

    if ( str[0] == '\\' ) {
        //
        //  Skip the initial \, this is for BUILTIN usernames:
        //

        str++;
    }

    _ASSERT ( str[0] != '\\' );

    if (fIsSID) {
    	if (!ConvertStringSidToSid(str, &pSID))
    		BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT(GetLastError()));

    	cbSid = GetLengthSid(pSID);
		*ppSID = (LPVOID) new char [ cbSid ];
		if ( !*ppSID ) {
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		memcpy(*ppSID, pSID, cbSid);

    } else {

		fLookup = LookupAccountName	(
			strSystemName,
			str,
			*ppSID,
			&cbSid,
			wszRefDomain,
			&cbRefDomain,
			&SidNameUse
			);

		// First lookup will fail, but the size will be right:
		if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
			BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT ( GetLastError () ) );
		}

		*ppSID = (LPVOID) new char [ cbSid ];
		if ( !*ppSID ) {
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		fLookup = LookupAccountName	(
			strSystemName,
			str,
			*ppSID,
			&cbSid,
			wszRefDomain,
			&cbRefDomain,
			&SidNameUse
			);
    }

	if ( !fLookup ) {
		BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT ( GetLastError () ) );
	}

Exit:
	if (pSID) {
		LocalFree(pSID);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\server.h ===
// server.h : Declaration of the CNntpVirtualServer


/////////////////////////////////////////////////////////////////////////////
// Dependencies:

#include "metafact.h"
#include "binding.h"
#include "vroots.h"
#include "ipaccess.h"

/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpVirtualServer : 
	public CComDualImpl<INntpVirtualServer, &IID_INntpVirtualServer, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpVirtualServer,&CLSID_CNntpVirtualServer>
{
public:
	CNntpVirtualServer();
	virtual ~CNntpVirtualServer ();
	
BEGIN_COM_MAP(CNntpVirtualServer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpVirtualServer)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpVirtualServer) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpVirtualServer, _T("Nntpadm.VirtualServer.1"), _T("Nntpadm.VirtualServer"), IDS_NNTPADMINSERVICE_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpVirtualServer
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Other admin interfaces for virtual server:

	STDMETHODIMP	get_FeedsAdmin		( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_GroupsAdmin		( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_SessionsAdmin	( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_ExpirationAdmin	( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_RebuildAdmin	( IDispatch ** ppIDispatch );

	STDMETHODIMP	get_VirtualRoots	( INntpVirtualRoots ** ppVirtualRoots );
	STDMETHODIMP	get_VirtualRootsDispatch	( IDispatch ** ppVirtualRoots );

	STDMETHODIMP	get_TcpAccess ( ITcpAccess ** ppTcpAccess );
/*
	STDMETHODIMP	get_HomeDirectory	( INntpVirtualRoot ** ppVirtualRoot );
	STDMETHODIMP	put_HomeDirectory	( INntpVirtualRoot * pVirtualRoot );
*/

	// Overridable server properties:

	STDMETHODIMP	get_ArticleTimeLimit	( long * plArticleTimeLimit );
	STDMETHODIMP	put_ArticleTimeLimit	( long lArticleTimeLimit );

	STDMETHODIMP	get_HistoryExpiration	( long * plHistoryExpiration );
	STDMETHODIMP	put_HistoryExpiration	( long lHistoryExpiration );

	STDMETHODIMP	get_HonorClientMsgIDs	( BOOL * pfHonorClientMsgIDs );
	STDMETHODIMP	put_HonorClientMsgIDs	( BOOL fHonorClientMsgIDs );

	STDMETHODIMP	get_SmtpServer	( BSTR * pstrSmtpServer );
	STDMETHODIMP	put_SmtpServer	( BSTR strSmtpServer );

	STDMETHODIMP	get_AdminEmail ( BSTR * pstrAdminEmail );
	STDMETHODIMP	put_AdminEmail ( BSTR strAdminEmail );

	STDMETHODIMP	get_AllowClientPosts	( BOOL * pfAllowClientPosts );
	STDMETHODIMP	put_AllowClientPosts	( BOOL fAllowClientPosts );

	STDMETHODIMP	get_AllowFeedPosts	( BOOL * pfAllowFeedPosts );
	STDMETHODIMP	put_AllowFeedPosts	( BOOL fAllowFeedPosts );

	STDMETHODIMP	get_ClientPostHardLimit ( long * plClientPostHardLimit );
	STDMETHODIMP	put_ClientPostHardLimit ( long lClientPostHardLimit );

	STDMETHODIMP	get_ClientPostSoftLimit ( long * plClientPostSoftLimit );
	STDMETHODIMP	put_ClientPostSoftLimit ( long lClientPostSoftLimit );

	STDMETHODIMP	get_FeedPostHardLimit ( long * plFeedPostHardLimit );
	STDMETHODIMP	put_FeedPostHardLimit ( long lFeedPostHardLimit );

	STDMETHODIMP	get_FeedPostSoftLimit ( long * plFeedPostSoftLimit );
	STDMETHODIMP	put_FeedPostSoftLimit ( long lFeedPostSoftLimit );

	STDMETHODIMP	get_AllowControlMsgs	( BOOL * pfAllowControlMsgs );
	STDMETHODIMP	put_AllowControlMsgs	( BOOL fAllowControlMsgs );

	STDMETHODIMP	get_DefaultModeratorDomain	( BSTR * pstrDefaultModeratorDomain );
	STDMETHODIMP	put_DefaultModeratorDomain	( BSTR strDefaultModeratorDomain );

	STDMETHODIMP	get_CommandLogMask	( long * plCommandLogMask );
	STDMETHODIMP	put_CommandLogMask	( long lCommandLogMask );

	STDMETHODIMP	get_DisableNewnews	( BOOL * pfDisableNewnews );
	STDMETHODIMP	put_DisableNewnews	( BOOL fDisableNewnews );

	STDMETHODIMP	get_ExpireRunFrequency	( long * plExpireRunFrequency );
	STDMETHODIMP	put_ExpireRunFrequency	( long lExpireRunFrequency );

	STDMETHODIMP	get_ShutdownLatency	( long * plShutdownLatency );
	STDMETHODIMP	put_ShutdownLatency	( long lShutdownLatency );

	STDMETHODIMP	get_EnableLogging	( BOOL * pfEnableLogging );
	STDMETHODIMP	put_EnableLogging	( BOOL fEnableLogging );
	
	// Service Properties:
	STDMETHODIMP	get_Organization ( BSTR * pstrOrganization );
	STDMETHODIMP	put_Organization ( BSTR strOrganization );

	STDMETHODIMP	get_UucpName ( BSTR * pstrUucpName );
	STDMETHODIMP	put_UucpName ( BSTR strUucpName );

	STDMETHODIMP	get_GroupHelpFile	( BSTR * pstrGroupHelpFile );
	STDMETHODIMP	put_GroupHelpFile	( BSTR strGroupHelpFile );

	STDMETHODIMP	get_GroupListFile	( BSTR * pstrGroupListFile );
	STDMETHODIMP	put_GroupListFile	( BSTR strGroupListFile );

	STDMETHODIMP    get_GroupVarListFile ( BSTR *pstrGroupVarListFile );
	STDMETHODIMP    put_GroupVarListFile ( BSTR strGroupVarListFile );

	STDMETHODIMP	get_ArticleTableFile	( BSTR * pstrArticleTableFile );
	STDMETHODIMP	put_ArticleTableFile	( BSTR strArticleTableFile );

	STDMETHODIMP	get_HistoryTableFile	( BSTR * pstrHistoryTableFile );
	STDMETHODIMP	put_HistoryTableFile	( BSTR strHistoryTableFile );

	STDMETHODIMP	get_ModeratorFile	( BSTR * pstrModeratorFile );
	STDMETHODIMP	put_ModeratorFile	( BSTR strModeratorFile );

	STDMETHODIMP	get_XOverTableFile	( BSTR * pstrXOverTableFile );
	STDMETHODIMP	put_XOverTableFile	( BSTR strXOverTableFile );

	STDMETHODIMP	get_AutoStart	( BOOL * pfAutoStart );
	STDMETHODIMP	put_AutoStart	( BOOL fAutoStart );

	STDMETHODIMP	get_Comment	( BSTR * pstrComment );
	STDMETHODIMP	put_Comment	( BSTR strComment );

	STDMETHODIMP	get_Bindings	( INntpServerBindings ** ppBindings );
	STDMETHODIMP	get_BindingsDispatch ( IDispatch ** ppDispatch );

	STDMETHODIMP	get_SecurePort	( long * pdwSecurePort );
	STDMETHODIMP	put_SecurePort	( long dwSecurePort );

	STDMETHODIMP	get_MaxConnections	( long * pdwMaxConnections );
	STDMETHODIMP	put_MaxConnections	( long dwMaxConnections );

	STDMETHODIMP	get_ConnectionTimeout	( long * pdwConnectionTimeout );
	STDMETHODIMP	put_ConnectionTimeout	( long dwConnectionTimeout );

	STDMETHODIMP	get_AnonymousUserName	( BSTR * pstrAnonymousUserName );
	STDMETHODIMP	put_AnonymousUserName	( BSTR strAnonymousUserName );

	STDMETHODIMP	get_AnonymousUserPass	( BSTR * pstrAnonymousUserPass );
	STDMETHODIMP	put_AnonymousUserPass	( BSTR strAnonymousUserPass );

	STDMETHODIMP	get_AutoSyncPassword	( BOOL * pfAutoSyncPassword );
	STDMETHODIMP	put_AutoSyncPassword	( BOOL fAutoSyncPassword );

	STDMETHODIMP	get_PickupDirectory	( BSTR * pstrPickupDirectory );
	STDMETHODIMP	put_PickupDirectory	( BSTR strPickupDirectory );

	STDMETHODIMP	get_FailedPickupDirectory	( BSTR * pstrFailedPickupDirectory );
	STDMETHODIMP	put_FailedPickupDirectory	( BSTR strFailedPickupDirectory );

	STDMETHODIMP	get_AuthAnonymous	( BOOL * pfAuthAnonymous );
	STDMETHODIMP	put_AuthAnonymous	( BOOL fAuthAnonymous );

	STDMETHODIMP	get_AuthBasic	( BOOL * pfAuthBasic );
	STDMETHODIMP	put_AuthBasic	( BOOL fAuthBasic );

	STDMETHODIMP	get_AuthMCISBasic	( BOOL * pfAuthMCISBasic );
	STDMETHODIMP	put_AuthMCISBasic	( BOOL fAuthMCISBasic );

	STDMETHODIMP	get_AuthNT	( BOOL * pfAuthNT );
	STDMETHODIMP	put_AuthNT	( BOOL fAuthNT );

	STDMETHODIMP	get_SSLNegotiateCert	( BOOL * pfSSLNegotiateCert );
	STDMETHODIMP	put_SSLNegotiateCert	( BOOL fSSLNegotiateCert );

	STDMETHODIMP	get_SSLRequireCert	( BOOL * pfSSLRequireCert );
	STDMETHODIMP	put_SSLRequireCert	( BOOL fSSLRequireCert );

	STDMETHODIMP	get_SSLMapCert	( BOOL * pfSSLMapCert );
	STDMETHODIMP	put_SSLMapCert	( BOOL fSSLMapCert );

/*
	STDMETHODIMP	get_AuthenticationProviders	( SAFEARRAY ** ppsastrProviders );
	STDMETHODIMP	put_AuthenticationProviders	( SAFEARRAY * psastrProviders );

	STDMETHODIMP	get_AuthenticationProvidersVariant	( SAFEARRAY ** ppsastrProviders );
	STDMETHODIMP	put_AuthenticationProvidersVariant	( SAFEARRAY * psastrProviders );
*/

/*
	STDMETHODIMP	get_NewsgroupsVariant	( SAFEARRAY ** ppsastrNewsgroups );
	STDMETHODIMP	put_NewsgroupsVariant	( SAFEARRAY * psastrNewsgroups );
*/

	STDMETHODIMP	get_Administrators ( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_Administrators ( SAFEARRAY * psastrAdmins );

	STDMETHODIMP	get_AdministratorsVariant ( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_AdministratorsVariant ( SAFEARRAY * psastrAdmins );

	STDMETHODIMP	get_ClusterEnabled	( BOOL *pfClusterEnabled );
	STDMETHODIMP	put_ClusterEnabled	( BOOL fClusterEnabled );

	//
	//	Service State Properties:
	//

	STDMETHODIMP	get_State			( NNTP_SERVER_STATE * pState );
	STDMETHODIMP	get_Win32ErrorCode	( long * plWin32ErrorCode );

/*
	STDMETHODIMP	get_EncryptionCapabilitiesMask ( long * plEncryptionCapabilitiesMask );
	STDMETHODIMP	put_EncryptionCapabilitiesMask ( long lEncryptionCapabilitiesMask );

	STDMETHODIMP	get_DisplayName	( BSTR * pstrDisplayName );
	STDMETHODIMP	put_DisplayName	( BSTR strDisplayName );

	STDMETHODIMP	get_ErrorControl	( BOOL * pfErrorControl );
	STDMETHODIMP	put_ErrorControl	( BOOL fErrorControl );

	STDMETHODIMP	get_CleanBoot	( BOOL * pfCleanBoot );
	STDMETHODIMP	put_CleanBoot	( BOOL fCleanBoot );
*/

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Get ( );
	STDMETHODIMP	Set ( BOOL fFailIfChanged);

	STDMETHODIMP	Start		( );
	STDMETHODIMP	Pause		( );
	STDMETHODIMP	Continue	( );
	STDMETHODIMP	Stop		( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Properties:
	CComBSTR	m_strServer;
	DWORD		m_dwServiceInstance;

	DWORD		m_dwArticleTimeLimit;
	DWORD		m_dwHistoryExpiration;
	BOOL		m_fHonorClientMsgIDs;
	CComBSTR	m_strSmtpServer;
    CComBSTR    m_strAdminEmail;
	BOOL		m_fAllowClientPosts;
	BOOL		m_fAllowFeedPosts;
	BOOL		m_fAllowControlMsgs;
	CComBSTR	m_strDefaultModeratorDomain;
	DWORD		m_dwCommandLogMask;
	BOOL		m_fDisableNewnews;
	DWORD		m_dwExpireRunFrequency;
	DWORD		m_dwShutdownLatency;

	DWORD		m_dwClientPostHardLimit;
	DWORD		m_dwClientPostSoftLimit;
	DWORD		m_dwFeedPostHardLimit;
	DWORD		m_dwFeedPostSoftLimit;

	BOOL		m_fEnableLogging;
	CComBSTR	m_strGroupHelpFile;
	CComBSTR	m_strGroupListFile;
	CComBSTR    m_strGroupVarListFile;
	CComBSTR	m_strArticleTableFile;
	CComBSTR	m_strHistoryTableFile;
	CComBSTR	m_strModeratorFile;
	CComBSTR	m_strXOverTableFile;
	CComBSTR	m_strUucpName;
	CComBSTR	m_strOrganization;
	BOOL		m_fAutoStart;
	CComBSTR	m_strComment;
	DWORD		m_dwSecurePort;
	DWORD		m_dwMaxConnections;
	DWORD		m_dwConnectionTimeout;
	CComBSTR	m_strAnonymousUserName;
	CComBSTR	m_strAnonymousUserPass;
	BOOL		m_fAutoSyncPassword;
	CComBSTR	m_strPickupDirectory;
	CComBSTR	m_strFailedPickupDirectory;
	DWORD		m_bvAuthorization;
	DWORD		m_bvSslAccess;
	BOOL		m_fClusterEnabled;
//	CMultiSz	m_mszProviders;

	SAFEARRAY *	m_psaAdmins;

	// Service State:
	NNTP_SERVER_STATE	m_State;
	DWORD				m_dwWin32ErrorCode;

	// Tcp restrictions:
	CComPtr<ITcpAccess>		m_pIpAccess;
	CTcpAccess *				m_pPrivateIpAccess;

	// Bindings:
	CComPtr<INntpServerBindings>	m_pBindings;
	CNntpServerBindings *			m_pPrivateBindings;
/*
	CComPtr<INntpVirtualRoot>		m_pHomeDirectory;
	CNntpVirtualRoot *				m_pPrivateHomeDirectory;
*/

	// Unused so far:
	DWORD		m_dwEncryptionCapabilities;
	CComBSTR	m_strDisplayName;
	BOOL		m_fErrorControl;
	BOOL		m_fCleanBoot;

	// Status:
	BOOL		m_fGotProperties;
	DWORD		m_bvChangedFields;
	DWORD		m_bvChangedFields2;
	FILETIME	m_ftLastChanged;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	HRESULT 	GetPropertiesFromMetabase	( IMSAdminBase * pMetabase);
	HRESULT 	SendPropertiesToMetabase	( BOOL fFailIfChanged, IMSAdminBase * pMetabase);

	// State:
	HRESULT		ControlService 				( 
					IMSAdminBase *	pMetabase, 
					DWORD			ControlCode,
					DWORD			dwDesiredState,
					DWORD			dwPendingState
					);
	HRESULT		WriteStateCommand	( IMSAdminBase * pMetabase, DWORD dwCommand );
	HRESULT		CheckServiceState	( IMSAdminBase * pMetabase, DWORD * pdwState );
	NNTP_SERVER_STATE	TranslateServerState	( DWORD dwState );

	// Validation:
	BOOL		ValidateStrings ( ) const;
	BOOL		ValidateProperties ( ) const;
	void		CorrectProperties ( );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nntpadm.rc
//
#define IDS_NNTPADMIN_DESC				1
#define IDS_NNTPADMINSERVER_DESC		2
#define IDS_NNTPADMINSERVICE_DESC		3
#define IDS_NNTPADMINFEEDS_DESC			4
#define IDS_NNTPADMINEXPIRATION_DESC	5
#define IDS_NNTPADMINGROUPS_DESC		6
#define IDS_NNTPADMINSESSIONS_DESC		7
#define IDS_NNTPADMINREBUILD_DESC		8
#define IDS_NNTPVIRTUALROOT_DESC		9
#define IDS_NNTPFEED_DESC		        10
#define IDS_NNTPONEWAYFEED_DESC		    11
#define IDS_TCPACCESS_DESC              12
#define IDS_TCPACCESSEXCEPTIONS_DESC    13
#define IDS_TCPACCESSEXCEPTION_DESC     14

// Exceptions:

#define IDS_NNTPEXCEPTION_DIDNT_ENUMERATE						200
#define IDS_NNTPEXCEPTION_DIDNT_SET_CURSOR						201
#define IDS_NNTPEXCEPTION_INVALID_INDEX							202
#define IDS_NNTPEXCEPTION_MUST_SUPPLY_USERNAME_OR_IPADDRESS		203
#define IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO			204
#define IDS_NNTPEXCEPTION_DIDNT_CALL_GET						205
#define IDS_NNTPEXCEPTION_STRING_TOO_LONG						206
#define IDS_NNTPEXCEPTION_PROPERTY_OUT_OF_RANGE					207
#define IDS_NNTPEXCEPTION_DIDNT_FIND							208
#define IDS_NNTPEXCEPTION_ALREADY_BUILDING						209
#define IDS_NNTPEXCEPTION_CANT_DELETE_DEFAULT_INSTANCE			210
#define IDS_NNTPEXCEPTION_VROOT_ALREADY_EXISTS                  211

#define IDS_FEED_PARM_ERR_BASE			300
#define IDS_FEED_PARM_FEEDTYPE			(IDS_FEED_PARM_ERR_BASE + 0)
#define IDS_FEED_PARM_STARTTIME			(IDS_FEED_PARM_ERR_BASE + 1)
#define IDS_FEED_PARM_FEEDID			(IDS_FEED_PARM_ERR_BASE + 2)
#define IDS_FEED_PARM_FEEDINTERVAL		(IDS_FEED_PARM_ERR_BASE + 3)
#define IDS_FEED_PARM_NEWSGROUPS		(IDS_FEED_PARM_ERR_BASE + 4)
#define IDS_FEED_PARM_DISTRIBUTION		(IDS_FEED_PARM_ERR_BASE + 5)
#define IDS_FEED_PARM_SERVERNAME		(IDS_FEED_PARM_ERR_BASE + 6)
#define IDS_FEED_PARM_AUTOCREATE		(IDS_FEED_PARM_ERR_BASE + 7)
#define IDS_FEED_PARM_ENABLED			(IDS_FEED_PARM_ERR_BASE + 8)
#define IDS_FEED_PARM_UUCPNAME			(IDS_FEED_PARM_ERR_BASE + 9)
#define IDS_FEED_PARM_TEMPDIR			(IDS_FEED_PARM_ERR_BASE + 10)
#define IDS_FEED_PARM_MAXCONNECT		(IDS_FEED_PARM_ERR_BASE + 11)
#define IDS_FEED_PARM_SESSIONSECURITY	(IDS_FEED_PARM_ERR_BASE + 12)
#define IDS_FEED_PARM_AUTHTYPE			(IDS_FEED_PARM_ERR_BASE + 13)
#define IDS_FEED_PARM_ACCOUNTNAME		(IDS_FEED_PARM_ERR_BASE + 14)
#define IDS_FEED_PARM_PASSWORD			(IDS_FEED_PARM_ERR_BASE + 15)
#define IDS_FEED_PARM_CONCURRENTSESSION	(IDS_FEED_PARM_ERR_BASE + 16)
#define IDS_FEED_PARM_ALLOW_CONTROL		(IDS_FEED_PARM_ERR_BASE + 17)
#define IDS_FEED_PARM_OUTGOING_PORT		(IDS_FEED_PARM_ERR_BASE + 18)
#define IDS_FEED_PARM_FEEDPAIR_ID		(IDS_FEED_PARM_ERR_BASE + 19)

#define IDS_UNKNOWN_ERROR                                       500

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\service.cpp ===
// service.cpp : Implementation of INntpVirtualServer

#include "stdafx.h"
#include "nntpcmn.h"

#include "oleutil.h"
#include "metautil.h"
#include "service.h"

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Service.1")
#define THIS_FILE_IID				IID_INntpService

// Bitmasks for changed fields:

#define CHNG_ARTICLETIMELIMIT			0x00000001
#define CHNG_HISTORYEXPIRATION			0x00000002
#define CHNG_HONORCLIENTMSGIDS			0x00000004
#define CHNG_SMTPSERVER					0x00000008
#define CHNG_ALLOWCLIENTPOSTS			0x00000010
#define CHNG_ALLOWFEEDPOSTS				0x00000020
#define CHNG_ALLOWCONTROLMSGS			0x00000040
#define CHNG_DEFAULTMODERATORDOMAIN		0x00000080
#define CHNG_COMMANDLOGMASK				0x00000100
#define CHNG_DISABLENEWNEWS				0x00000200
#define CHNG_EXPIRERUNFREQUENCY			0x00000400
#define CHNG_SHUTDOWNLATENCY			0x00000800

// Default Values:

#define DEFAULT_ARTICLETIMELIMIT		( 1138 )
#define DEFAULT_HISTORYEXPIRATION		( 1138 )
#define DEFAULT_HONORCLIENTMSGIDS		( TRUE )
#define DEFAULT_SMTPSERVER				_T( "" )
#define DEFAULT_ALLOWCLIENTPOSTS		( TRUE )
#define DEFAULT_ALLOWFEEDPOSTS			( TRUE )
#define DEFAULT_ALLOWCONTROLMSGS		( TRUE )
#define DEFAULT_DEFAULTMODERATORDOMAIN	_T( "" )
#define DEFAULT_COMMANDLOGMASK			( (DWORD) -1 )
#define DEFAULT_DISABLENEWNEWS			( FALSE )
#define DEFAULT_EXPIRERUNFREQUENCY		( 1138 )
#define DEFAULT_SHUTDOWNLATENCY			( 1138 )

// Parameter ranges:

#define MAXLEN_SERVER					( 256 )
#define MIN_ARTICLETIMELIMIT			( (DWORD) 0 )
#define MAX_ARTICLETIMELIMIT			( (DWORD) -1 )
#define MIN_HISTORYEXPIRATION			( (DWORD) 0 )
#define MAX_HISTORYEXPIRATION			( (DWORD) -1 )
#define MAXLEN_SMTPSERVER				( 256 )
#define MAXLEN_DEFAULTMODERATORDOMAIN	( 256 )
#define MIN_COMMANDLOGMASK				( (DWORD) 0 )
#define MAX_COMMANDLOGMASK				( (DWORD) -1 )
#define MIN_EXPIRERUNFREQUENCY			( (DWORD) 1 )
#define MAX_EXPIRERUNFREQUENCY			( (DWORD) -1 )
#define MIN_SHUTDOWNLATENCY				( (DWORD) 1 )
#define MAX_SHUTDOWNLATENCY				( (DWORD) -1 )

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpAdminService::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpService,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpAdminService::CNntpAdminService () :
	m_dwArticleTimeLimit	( 0 ),
	m_dwHistoryExpiration	( 0 ),
	m_fHonorClientMsgIDs	( FALSE ),
	m_fAllowClientPosts		( FALSE ),
	m_fAllowFeedPosts		( FALSE ),
	m_fAllowControlMsgs		( FALSE ),
	m_dwCommandLogMask		( 0 ),
	m_fDisableNewnews		( FALSE ),
	m_dwExpireRunFrequency	( 0 ),
	m_dwShutdownLatency		( 0 ),

	m_fGotProperties		( FALSE ),
	m_bvChangedFields		( 0 )
	// CComBSTR's are initialized to NULL by default.
{
	m_ftLastChanged.dwHighDateTime	= 0;
	m_ftLastChanged.dwLowDateTime	= 0;

	InitAsyncTrace ( );
}

CNntpAdminService::~CNntpAdminService ()
{
	// All CComBSTR's are freed automatically.
	TermAsyncTrace ( );
}

// Which Server to configure:

STDMETHODIMP CNntpAdminService::get_Server ( BSTR * pstrServer )
{
	return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CNntpAdminService::put_Server ( BSTR strServer )
{
	// If the server name changes, that means the client will have to
	// call Get again:

	// I assume this here:
	_ASSERT ( sizeof (DWORD) == sizeof (int) );
	
	return StdPropertyPutServerName ( &m_strServer, strServer, (DWORD *) &m_fGotProperties, 1 );
}

// Server Properties:

STDMETHODIMP CNntpAdminService::get_ArticleTimeLimit ( long * plArticleTimeLimit )
{
	return StdPropertyGet ( m_dwArticleTimeLimit, plArticleTimeLimit );
}

STDMETHODIMP CNntpAdminService::put_ArticleTimeLimit ( long lArticleTimeLimit )
{
	return StdPropertyPut ( &m_dwArticleTimeLimit, lArticleTimeLimit, &m_bvChangedFields, CHNG_ARTICLETIMELIMIT );
}

STDMETHODIMP CNntpAdminService::get_HistoryExpiration ( long * plHistoryExpiration )
{
	return StdPropertyGet ( m_dwHistoryExpiration, plHistoryExpiration );
}

STDMETHODIMP CNntpAdminService::put_HistoryExpiration ( long lHistoryExpiration )
{
	return StdPropertyPut ( &m_dwHistoryExpiration, lHistoryExpiration, &m_bvChangedFields, CHNG_HISTORYEXPIRATION );
}

STDMETHODIMP CNntpAdminService::get_HonorClientMsgIDs ( BOOL * pfHonorClientMsgIDs )
{
	return StdPropertyGet ( m_fHonorClientMsgIDs, pfHonorClientMsgIDs );
}

STDMETHODIMP CNntpAdminService::put_HonorClientMsgIDs ( BOOL fHonorClientMsgIDs )
{
	return StdPropertyPut ( &m_fHonorClientMsgIDs, fHonorClientMsgIDs, &m_bvChangedFields, CHNG_HONORCLIENTMSGIDS );
}

STDMETHODIMP CNntpAdminService::get_SmtpServer ( BSTR * pstrSmtpServer )
{
	return StdPropertyGet ( m_strSmtpServer, pstrSmtpServer );
}

STDMETHODIMP CNntpAdminService::put_SmtpServer ( BSTR strSmtpServer )
{
	return StdPropertyPut ( &m_strSmtpServer, strSmtpServer, &m_bvChangedFields, CHNG_SMTPSERVER );
}

STDMETHODIMP CNntpAdminService::get_AllowClientPosts ( BOOL * pfAllowClientPosts )
{
	return StdPropertyGet ( m_fAllowClientPosts, pfAllowClientPosts );
}

STDMETHODIMP CNntpAdminService::put_AllowClientPosts ( BOOL fAllowClientPosts )
{
	return StdPropertyPut ( &m_fAllowClientPosts, fAllowClientPosts, &m_bvChangedFields, CHNG_ALLOWCLIENTPOSTS );
}

STDMETHODIMP CNntpAdminService::get_AllowFeedPosts ( BOOL * pfAllowFeedPosts )
{
	return StdPropertyGet ( m_fAllowFeedPosts, pfAllowFeedPosts );
}

STDMETHODIMP CNntpAdminService::put_AllowFeedPosts ( BOOL fAllowFeedPosts )
{
	return StdPropertyPut ( &m_fAllowFeedPosts, fAllowFeedPosts, &m_bvChangedFields, CHNG_ALLOWFEEDPOSTS );
}

STDMETHODIMP CNntpAdminService::get_AllowControlMsgs ( BOOL * pfAllowControlMsgs )
{
	return StdPropertyGet ( m_fAllowControlMsgs, pfAllowControlMsgs );
}

STDMETHODIMP CNntpAdminService::put_AllowControlMsgs ( BOOL fAllowControlMsgs )
{
	return StdPropertyPut ( &m_fAllowControlMsgs, fAllowControlMsgs, &m_bvChangedFields, CHNG_ALLOWCONTROLMSGS );
}

STDMETHODIMP CNntpAdminService::get_DefaultModeratorDomain ( BSTR * pstrDefaultModeratorDomain )
{
	return StdPropertyGet ( m_strDefaultModeratorDomain, pstrDefaultModeratorDomain );
}

STDMETHODIMP CNntpAdminService::put_DefaultModeratorDomain ( BSTR strDefaultModeratorDomain )
{
	return StdPropertyPut ( &m_strDefaultModeratorDomain, strDefaultModeratorDomain, &m_bvChangedFields, CHNG_DEFAULTMODERATORDOMAIN );
}

STDMETHODIMP CNntpAdminService::get_CommandLogMask ( long * plCommandLogMask )
{
	return StdPropertyGet ( m_dwCommandLogMask, plCommandLogMask );
}

STDMETHODIMP CNntpAdminService::put_CommandLogMask ( long lCommandLogMask )
{
	return StdPropertyPut ( &m_dwCommandLogMask, lCommandLogMask, &m_bvChangedFields, CHNG_COMMANDLOGMASK );
}

STDMETHODIMP CNntpAdminService::get_DisableNewnews ( BOOL * pfDisableNewnews )
{
	return StdPropertyGet ( m_fDisableNewnews, pfDisableNewnews );
}

STDMETHODIMP CNntpAdminService::put_DisableNewnews ( BOOL fDisableNewnews )
{
	return StdPropertyPut ( &m_fDisableNewnews, fDisableNewnews, &m_bvChangedFields, CHNG_DISABLENEWNEWS );
}

STDMETHODIMP CNntpAdminService::get_ExpireRunFrequency ( long * plExpireRunFrequency )
{
	return StdPropertyGet ( m_dwExpireRunFrequency, plExpireRunFrequency );
}

STDMETHODIMP CNntpAdminService::put_ExpireRunFrequency ( long lExpireRunFrequency )
{
	return StdPropertyPut ( &m_dwExpireRunFrequency, lExpireRunFrequency, &m_bvChangedFields, CHNG_EXPIRERUNFREQUENCY );
}

STDMETHODIMP CNntpAdminService::get_ShutdownLatency ( long * plShutdownLatency )
{
	return StdPropertyGet ( m_dwShutdownLatency, plShutdownLatency );
}

STDMETHODIMP CNntpAdminService::put_ShutdownLatency ( long lShutdownLatency )
{
	return StdPropertyPut ( &m_dwShutdownLatency, lShutdownLatency, &m_bvChangedFields, CHNG_SHUTDOWNLATENCY );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

//$-------------------------------------------------------------------
//
//	CNntpAdminService::Get
//
//	Description:
//
//		Gets server properties from the metabase.
//
//	Parameters:
//
//		(property) m_strServer
//		pErr - Resulting error code.  This can be translated to a
//			string through the INntpAdmin interface.
//
//	Returns:
//
//		E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//		Additional error conditions are returned through the pErr value.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdminService::Get ( )
{
	TraceFunctEnter ( "CNntpAdminService::Get" );

	HRESULT				hr			= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	// Validate Server & Service Instance:

	// Talk to the metabase:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = GetPropertiesFromMetabase ( pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	StateTrace ( 0, "Successfully got server properties" );
	m_fGotProperties	= TRUE;
	m_bvChangedFields	= 0;

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;

	// CComPtr automatically releases the metabase handle.
}

//$-------------------------------------------------------------------
//
//	CNntpAdminService::Set
//
//	Description:
//
//		Sends server properties to the metabase.
//
//	Parameters:
//
//		(property) m_strServer
//		fFailIfChanged - return an error if the metabase has changed?
//		pErr - Resulting error code.  This can be translated to a
//			string through the INntpAdmin interface.
//
//	Returns:
//
//		E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//		Additional error conditions are returned through the pErr value.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpAdminService::Set ( BOOL fFailIfChanged)
{
	TraceFunctEnter ( "CNntpAdminService::Set" );

	HRESULT	hr	= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	// Make sure the client call Get first:
	if ( !m_fGotProperties ) {
		ErrorTrace ( 0, "Didn't call get first" );

		hr = NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_CALL_GET );
		goto Exit;
	}

	// Validate data members:
	if ( !ValidateStrings () ) {
		// !!!magnush - what about the case when any strings are NULL?
		hr = E_FAIL;
		goto Exit;
	}

	if ( !ValidateProperties ( ) ) {
		hr = RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = SendPropertiesToMetabase ( fFailIfChanged, pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	StateTrace ( 0, "Successfully set server properties" );

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpAdminService::GetPropertiesFromMetabase
//
//	Description:
//
//		Asks the metabase for each property in this class.
//		This class's properties come from /LM/NntpSvc/
//
//	Parameters:
//
//		pMetabase - The metabase object
//		pErr - Resulting error code.
//
//	Returns:
//
//		E_OUTOFMEMORY or an error code in pErr.
//
//--------------------------------------------------------------------

HRESULT CNntpAdminService::GetPropertiesFromMetabase ( IMSAdminBase * pMetabase)
{
	TraceFunctEnter ( "CNntpAdminService::GetPropertiesFromMetabase" );

	HRESULT			hr	= NOERROR;
	CMetabaseKey	metabase	( pMetabase );
	BOOL			fRet;

	hr = metabase.Open ( NNTP_MD_ROOT_PATH );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open NntpSvc key, %x", hr );

		// Return some kind of error code here:
//		hr = RETURNCODETOHRESULT ( GetLastError () );
		goto Exit;
	}

	fRet = TRUE;

	fRet = StdGetMetabaseProp ( &metabase, MD_ARTICLE_TIME_LIMIT,	DEFAULT_ARTICLETIMELIMIT,		&m_dwArticleTimeLimit )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_HISTORY_EXPIRATION,	DEFAULT_HISTORYEXPIRATION,		&m_dwHistoryExpiration )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_HONOR_CLIENT_MSGIDS,	DEFAULT_HONORCLIENTMSGIDS,		&m_fHonorClientMsgIDs )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SMTP_SERVER,			DEFAULT_SMTPSERVER,				&m_strSmtpServer )			&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ALLOW_CLIENT_POSTS,	DEFAULT_ALLOWCLIENTPOSTS,		&m_fAllowClientPosts )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ALLOW_FEED_POSTS,		DEFAULT_ALLOWFEEDPOSTS,			&m_fAllowFeedPosts )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ALLOW_CONTROL_MSGS,	DEFAULT_ALLOWCONTROLMSGS,		&m_fAllowControlMsgs )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_DEFAULT_MODERATOR,	DEFAULT_DEFAULTMODERATORDOMAIN,	&m_strDefaultModeratorDomain )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_NNTP_COMMAND_LOG_MASK,DEFAULT_COMMANDLOGMASK,			&m_dwCommandLogMask )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_DISABLE_NEWNEWS,		DEFAULT_DISABLENEWNEWS,			&m_fDisableNewnews )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_NEWS_CRAWLER_TIME,	DEFAULT_EXPIRERUNFREQUENCY,		&m_dwExpireRunFrequency )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SHUTDOWN_LATENCY,		DEFAULT_SHUTDOWNLATENCY,		&m_dwShutdownLatency )		&& fRet;

	// Check all property strings:
	// If any string is NULL, it is because we failed to allocate memory:
	if ( !ValidateStrings () ) {

		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// We can only fail from memory allocations:
	_ASSERT ( fRet );

	// Save the last changed time for this key:
	m_ftLastChanged.dwHighDateTime	= 0;
	m_ftLastChanged.dwLowDateTime	= 0;

	hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), (BYTE *) "", &m_ftLastChanged, FALSE );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
		// Ignore this error.
		hr = NOERROR;
	}

	// Validate the data received from the metabase:
	_ASSERT ( ValidateStrings () );
	_ASSERT ( ValidateProperties( ) );

	if ( !ValidateProperties( ) ) {
		CorrectProperties ();
	}

Exit:
	TraceFunctLeave ();
	return hr;

	// MB automatically closes its handle
}

//$-------------------------------------------------------------------
//
//	CNntpAdminService::SendPropertiesToMetabase
//
//	Description:
//
//		Saves each property to the metabase.
//		This class's properties go into /LM/NntpSvc/
//
//	Parameters:
//
//		fFailIfChanged	- Return a failure code if the metabase
//			has changed since last get.
//		pMetabase - the metabase object.
//		pErr - resulting error code.
//
//	Returns:
//
//		E_OUTOFMEMORY or resulting error code in pErr.
//
//--------------------------------------------------------------------

HRESULT CNntpAdminService::SendPropertiesToMetabase ( 
	BOOL fFailIfChanged, 
	IMSAdminBase * pMetabase
	)
{
	TraceFunctEnter ( "CNntpAdminService::SendPropertiesToMetabase" );

	HRESULT			hr	= NOERROR;
	CMetabaseKey	metabase	( pMetabase );

	hr = metabase.Open ( (CHAR *) NNTP_MD_ROOT_PATH, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open NntpSvc key, %x", hr );

//		hr = RETURNCODETOHRESULT ( GetLastError () );
		goto Exit;
	}

	// Does the client care if the key has changed?
	if ( fFailIfChanged ) {

		//	Did the key change?
		if ( HasKeyChanged ( pMetabase, metabase.QueryHandle(), &m_ftLastChanged ) ) {

			StateTrace ( (LPARAM) this, "Metabase has changed, not setting properties" );
			// !!!magnush - Return the appropriate error code:
			hr = E_FAIL;
			goto Exit;
		}
	}

	//
	//	The general procedure here is to keep setting metabase properties
	//	as long as nothing has gone wrong.  This is done by short-circuiting
	//	the statement by ANDing it with the status code.  This makes the code
	//	much more concise.
	//

	fRet = TRUE;

	if ( m_bvChangedFields & CHNG_ARTICLETIMELIMIT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ARTICLE_TIME_LIMIT,	m_dwArticleTimeLimit );
	}

	if ( m_bvChangedFields & CHNG_HISTORYEXPIRATION ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_HISTORY_EXPIRATION,	m_dwHistoryExpiration );
	}

	if ( m_bvChangedFields & CHNG_HONORCLIENTMSGIDS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_HONOR_CLIENT_MSGIDS,	m_fHonorClientMsgIDs );
	}

	if ( m_bvChangedFields & CHNG_SMTPSERVER ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SMTP_SERVER,			m_strSmtpServer );
	}

	if ( m_bvChangedFields & CHNG_ALLOWCLIENTPOSTS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ALLOW_CLIENT_POSTS,	m_fAllowClientPosts );
	}

	if ( m_bvChangedFields & CHNG_ALLOWFEEDPOSTS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ALLOW_FEED_POSTS,		m_fAllowFeedPosts );
	}

	if ( m_bvChangedFields & CHNG_ALLOWCONTROLMSGS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ALLOW_CONTROL_MSGS,	m_fAllowControlMsgs );
	}

	if ( m_bvChangedFields & CHNG_DEFAULTMODERATORDOMAIN ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_DEFAULT_MODERATOR,	m_strDefaultModeratorDomain );
	}

	if ( m_bvChangedFields & CHNG_COMMANDLOGMASK ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NNTP_COMMAND_LOG_MASK,m_dwCommandLogMask );
	}

	if ( m_bvChangedFields & CHNG_DISABLENEWNEWS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_DISABLE_NEWNEWS,		m_fDisableNewnews );
	}

	if ( m_bvChangedFields & CHNG_EXPIRERUNFREQUENCY ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NEWS_CRAWLER_TIME,	m_dwExpireRunFrequency );
	}

	if ( m_bvChangedFields & CHNG_SHUTDOWNLATENCY ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SHUTDOWN_LATENCY,		m_dwShutdownLatency );
	}

	if ( !fRet ) {
		hr = RETURNCODETOHRESULT ( GetLastError () );
	}

	// Save the data to the metabase:
	hr = metabase.Save ();
    BAIL_ON_FAILURE(hr);

	// Save the last changed time for this key:
	m_ftLastChanged.dwHighDateTime	= 0;
	m_ftLastChanged.dwLowDateTime	= 0;

	hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), (BYTE *) "", &m_ftLastChanged, FALSE );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
		// Ignore this error.
		hr = NOERROR;
	}

Exit:
	TraceFunctLeave ();
	return hr;

	// MB automatically closes its handle
}

//$-------------------------------------------------------------------
//
//	CNntpAdminService::ValidateStrings
//
//	Description:
//
//		Checks to make sure each string property is non-null.
//
//	Returns:
//
//		FALSE if any string property is NULL.
//
//--------------------------------------------------------------------

BOOL CNntpAdminService::ValidateStrings ( ) const
{
	TraceFunctEnter ( "CNntpAdminService::ValidateStrings" );

	// Check all property strings:
	// If any string is NULL, return FALSE:
	if ( 
		!m_strSmtpServer ||
		!m_strDefaultModeratorDomain
		) {

		ErrorTrace ( (LPARAM) this, "String validation failed" );

		TraceFunctLeave ();
		return FALSE;
	}

	_ASSERT ( IS_VALID_STRING ( m_strSmtpServer ) );
	_ASSERT ( IS_VALID_STRING ( m_strDefaultModeratorDomain ) );

	TraceFunctLeave ();
	return TRUE;
}

//$-------------------------------------------------------------------
//
//	CNntpAdminService::ValidateProperties
//
//	Description:
//
//		Checks to make sure all parameters are valid.
//
//	Parameters:
//
//		pErr - resulting error code.
//
//	Returns:
//
//		FALSE if any property was not valid.  In this case pErr
//		will contain an error that describes the invalid condition.
//
//--------------------------------------------------------------------

BOOL CNntpAdminService::ValidateProperties ( ) const
{
	BOOL	fRet	= TRUE;
	
	_ASSERT ( ValidateStrings () );

	fRet = fRet && PV_MinMax	( m_dwArticleTimeLimit, MIN_ARTICLETIMELIMIT, MAX_ARTICLETIMELIMIT );
	fRet = fRet && PV_MinMax	( m_dwHistoryExpiration, MIN_HISTORYEXPIRATION, MAX_HISTORYEXPIRATION );
	fRet = fRet && PV_Boolean	( m_fHonorClientMsgIDs );
	fRet = fRet && PV_MaxChars	( m_strSmtpServer, MAXLEN_SMTPSERVER );
	fRet = fRet && PV_Boolean	( m_fAllowClientPosts );
	fRet = fRet && PV_Boolean	( m_fAllowFeedPosts );
	fRet = fRet && PV_Boolean	( m_fAllowControlMsgs );
	fRet = fRet && PV_MaxChars	( m_strDefaultModeratorDomain, MAXLEN_DEFAULTMODERATORDOMAIN );
	fRet = fRet && PV_MinMax	( m_dwCommandLogMask, MIN_COMMANDLOGMASK, MAX_COMMANDLOGMASK );
	fRet = fRet && PV_Boolean	( m_fDisableNewnews );
	fRet = fRet && PV_MinMax	( m_dwExpireRunFrequency, MIN_EXPIRERUNFREQUENCY, MAX_EXPIRERUNFREQUENCY );
	fRet = fRet && PV_MinMax	( m_dwShutdownLatency, MIN_SHUTDOWNLATENCY, MAX_SHUTDOWNLATENCY );

	return fRet;
}

void CNntpAdminService::CorrectProperties ( )
{
	if ( m_strServer && !PV_MaxChars	( m_strServer, MAXLEN_SERVER ) ) {
		m_strServer[ MAXLEN_SERVER - 1 ] = NULL;
	}
	if ( !PV_MinMax	( m_dwArticleTimeLimit, MIN_ARTICLETIMELIMIT, MAX_ARTICLETIMELIMIT ) ) {
		m_dwArticleTimeLimit	= DEFAULT_ARTICLETIMELIMIT;
	}
	if ( !PV_MinMax	( m_dwHistoryExpiration, MIN_HISTORYEXPIRATION, MAX_HISTORYEXPIRATION ) ) {
		m_dwHistoryExpiration	= DEFAULT_HISTORYEXPIRATION;
	}
	if ( !PV_Boolean	( m_fHonorClientMsgIDs ) ) {
		m_fHonorClientMsgIDs	= !!m_fHonorClientMsgIDs;
	}
	if ( !PV_MaxChars	( m_strSmtpServer, MAXLEN_SMTPSERVER ) ) {
		m_strSmtpServer[ MAXLEN_SMTPSERVER - 1 ] = NULL;
	}
	if ( !PV_Boolean	( m_fAllowClientPosts ) ) {
		m_fAllowClientPosts	= !!m_fAllowClientPosts;
	}
	if ( !PV_Boolean	( m_fAllowFeedPosts ) ) {
		m_fAllowFeedPosts	= !!m_fAllowFeedPosts;
	}
	if ( !PV_Boolean	( m_fAllowControlMsgs ) ) {
		m_fAllowControlMsgs	= !!m_fAllowControlMsgs;
	}
	if ( !PV_MaxChars	( m_strDefaultModeratorDomain, MAXLEN_DEFAULTMODERATORDOMAIN ) ) {
		m_strDefaultModeratorDomain[ MAXLEN_DEFAULTMODERATORDOMAIN - 1] = NULL;
	}
	if ( !PV_MinMax	( m_dwCommandLogMask, MIN_COMMANDLOGMASK, MAX_COMMANDLOGMASK ) ) {
		m_dwCommandLogMask	= DEFAULT_COMMANDLOGMASK;
	}
	if ( !PV_Boolean	( m_fDisableNewnews ) ) {
		m_fDisableNewnews	= !!m_fDisableNewnews;
	}
	if ( !PV_MinMax	( m_dwExpireRunFrequency, MIN_EXPIRERUNFREQUENCY, MAX_EXPIRERUNFREQUENCY ) ) {
		m_dwExpireRunFrequency	= DEFAULT_EXPIRERUNFREQUENCY;
	}
	if ( !PV_MinMax	( m_dwShutdownLatency, MIN_SHUTDOWNLATENCY, MAX_SHUTDOWNLATENCY ) ) {
		m_dwShutdownLatency		= DEFAULT_SHUTDOWNLATENCY;
	}

	_ASSERT ( ValidateProperties ( ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma warning( disable : 4511 )

#include <ctype.h>
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#include <winsock2.h>

//  Pull in the common admin object code:
#include <admcmn.h>

#include "nntpmeta.h"
#include "tigdflts.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\sessions.h ===
// sessions.h : Declaration of the CNntpAdminSessions


typedef struct _NNTP_SESSION_INFO * LPNNTP_SESSION_INFO;

/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpAdminSessions : 
	public INntpAdminSessions,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdminSessions,&CLSID_CNntpAdminSessions>
{
public:
	CNntpAdminSessions();
	virtual ~CNntpAdminSessions ();
BEGIN_COM_MAP(CNntpAdminSessions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(INntpAdminSessions)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdminSessions) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdminSessions, _T("Nntpadm.Sessions.1"), _T("Nntpadm.Sessions"), IDS_NNTPADMINSESSIONS_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_NNTPADMLib
	#define THIS_IID	IID_INntpAdminSessions
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// INntpAdminSessions
public:

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:
	
	STDMETHODIMP	get_Server			( BSTR * pstrServer );
	STDMETHODIMP	put_Server			( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	STDMETHODIMP	get_Count			( long * plCount );

	STDMETHODIMP	get_Username		( BSTR * pstrUsername );
	STDMETHODIMP	put_Username		( BSTR strUsername );

	STDMETHODIMP	get_IpAddress		( BSTR * pstrIpAddress );
	STDMETHODIMP	put_IpAddress		( BSTR strIpAddress );

	STDMETHODIMP	get_IntegerIpAddress	( long * plIpAddress );
	STDMETHODIMP	put_IntegerIpAddress	( long lIpAddress );

	STDMETHODIMP	get_Port			( long * plPort );

	STDMETHODIMP	get_AuthenticationType	( long * plAuthenticationType );

	STDMETHODIMP	get_IsAnonymous		( BOOL * pfAnonymous );

	STDMETHODIMP	get_StartTime		( DATE * pdateStart );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Enumerate		( );
	STDMETHODIMP	GetNth			( long lIndex );
	STDMETHODIMP	Terminate		( );
	STDMETHODIMP	TerminateAll	( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Property variables:
    CIADsImpl   m_iadsImpl;

	DWORD		m_cCount;
	CComBSTR	m_strUsername;
	CComBSTR	m_strIpAddress;
	DWORD		m_dwIpAddress;
	DWORD		m_dwPort;
	DWORD		m_dwAuthenticationType;
	BOOL		m_fIsAnonymous;
	DATE		m_dateStartTime;

	// Service variables:
	BOOL		m_fSetCursor;
	LPNNTP_SESSION_INFO		m_pSessionInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\version.h ===
#include "exver.h"

#define makeString(x) #x

#define CURRENT_BUILD_NUMBER    atoi(makeString(rmm))

const int HIGH_VERSION = 1;
const int LOW_VERSION = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\service.h ===
// service.h:	Implementation of INntpVirtualServer


/////////////////////////////////////////////////////////////////////////////
// Dependencies
/////////////////////////////////////////////////////////////////////////////

#include "metafact.h"

/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpAdminService : 
	public CComDualImpl<INntpService, &IID_INntpService, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdminService,&CLSID_CNntpService>
{
public:
	CNntpAdminService();
	virtual ~CNntpAdminService ();
BEGIN_COM_MAP(CNntpAdminService)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpService)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdminService) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdminService, _T("Nntpadm.Service.1"), _T("Nntpadm.Service"), IDS_NNTPADMINSERVER_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpService
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which Server to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	// Server Properties:

	STDMETHODIMP	get_ArticleTimeLimit	( long * plArticleTimeLimit );
	STDMETHODIMP	put_ArticleTimeLimit	( long lArticleTimeLimit );

	STDMETHODIMP	get_HistoryExpiration	( long * plHistoryExpiration );
	STDMETHODIMP	put_HistoryExpiration	( long lHistoryExpiration );

	STDMETHODIMP	get_HonorClientMsgIDs	( BOOL * pfHonorClientMsgIDs );
	STDMETHODIMP	put_HonorClientMsgIDs	( BOOL fHonorClientMsgIDs );

	STDMETHODIMP	get_SmtpServer	( BSTR * pstrSmtpServer );
	STDMETHODIMP	put_SmtpServer	( BSTR strSmtpServer );

	STDMETHODIMP	get_AllowClientPosts	( BOOL * pfAllowClientPosts );
	STDMETHODIMP	put_AllowClientPosts	( BOOL fAllowClientPosts );

	STDMETHODIMP	get_AllowFeedPosts	( BOOL * pfAllowFeedPosts );
	STDMETHODIMP	put_AllowFeedPosts	( BOOL fAllowFeedPosts );

	STDMETHODIMP	get_AllowControlMsgs	( BOOL * pfAllowControlMsgs );
	STDMETHODIMP	put_AllowControlMsgs	( BOOL fAllowControlMsgs );

	STDMETHODIMP	get_DefaultModeratorDomain	( BSTR * pstrDefaultModeratorDomain );
	STDMETHODIMP	put_DefaultModeratorDomain	( BSTR strDefaultModeratorDomain );

	STDMETHODIMP	get_CommandLogMask	( long * plCommandLogMask );
	STDMETHODIMP	put_CommandLogMask	( long lCommandLogMask );

	STDMETHODIMP	get_DisableNewnews	( BOOL * pfDisableNewnews );
	STDMETHODIMP	put_DisableNewnews	( BOOL fDisableNewnews );

	STDMETHODIMP	get_ExpireRunFrequency	( long * plExpireRunFrequency );
	STDMETHODIMP	put_ExpireRunFrequency	( long lExpireRunFrequency );

	STDMETHODIMP	get_ShutdownLatency	( long * plShutdownLatency );
	STDMETHODIMP	put_ShutdownLatency	( long lShutdownLatency );
	
	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Get ( );
	STDMETHODIMP	Set ( BOOL fFailIfChanged);

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComBSTR	m_strServer;

	DWORD		m_dwArticleTimeLimit;
	DWORD		m_dwHistoryExpiration;
	BOOL		m_fHonorClientMsgIDs;
	CComBSTR	m_strSmtpServer;
	BOOL		m_fAllowClientPosts;
	BOOL		m_fAllowFeedPosts;
	BOOL		m_fAllowControlMsgs;
	CComBSTR	m_strDefaultModeratorDomain;
	DWORD		m_dwCommandLogMask;
	BOOL		m_fDisableNewnews;
	DWORD		m_dwExpireRunFrequency;
	DWORD		m_dwShutdownLatency;

	// Status:
	BOOL		m_fGotProperties;
	DWORD		m_bvChangedFields;
	FILETIME	m_ftLastChanged;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	HRESULT 	GetPropertiesFromMetabase	( IMSAdminBase * pMetabase);
	HRESULT 	SendPropertiesToMetabase	( BOOL fFailIfChanged, IMSAdminBase * pMetabase);

	// Validation:
	BOOL		ValidateStrings ( ) const;
	BOOL		ValidateProperties ( ) const;
	void		CorrectProperties ( );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\sessions.cpp ===
// sessions.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"

#include "nntpcmn.h"
#include "oleutil.h"
#include "sessions.h"

#include "nntptype.h"
#include "nntpapi.h"

#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Sessions.1")
#define THIS_FILE_IID				IID_INntpAdminSessions

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(NntpAdminSessions, CNntpAdminSessions, IID_INntpAdminSessions)

STDMETHODIMP CNntpAdminSessions::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpAdminSessions,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpAdminSessions::CNntpAdminSessions () :
	m_cCount				( 0 ),
	m_dwIpAddress			( 0 ),
	m_dwPort				( 0 ),
	m_dwAuthenticationType	( 0 ),
	m_fIsAnonymous			( FALSE ),
	m_dateStartTime			( 0 ),
	m_pSessionInfo			( NULL ),
	m_fSetCursor			( FALSE )
	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Sessions") );
    m_iadsImpl.SetClass ( _T("IIsNntpSessions") );
}

CNntpAdminSessions::~CNntpAdminSessions ()
{
	if ( m_pSessionInfo ) {
		NetApiBufferFree ( m_pSessionInfo );
	}

	// All CComBSTR's are freed automatically.
	TermAsyncTrace ( );
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CNntpAdminSessions,m_iadsImpl)

//
//	Properties:
//

STDMETHODIMP CNntpAdminSessions::get_Count ( long * plCount )
{
	// Count should check to be sure the client enumerated.

	return StdPropertyGet ( m_cCount, plCount );
}

STDMETHODIMP CNntpAdminSessions::get_Username ( BSTR * pstrUsername )
{
	return StdPropertyGet ( m_strUsername, pstrUsername );
}

STDMETHODIMP CNntpAdminSessions::put_Username ( 