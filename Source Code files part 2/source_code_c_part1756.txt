 hDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN      LPVOID  mszCounterList,
    IN      LPDWORD pdwCounterListLength,
    IN      LPVOID  mszInstanceList,
    IN      LPDWORD pdwInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags,
    IN      BOOL    bUnicode
)
{
    PDH_STATUS  pdhStatus = PDH_INVALID_HANDLE;
    PPDHI_LOG   pDataSource;
    DWORD       dwLogType;

    PDHI_COUNTER_TABLE CounterTable;
    DWORD              dwIndex;
    LIST_ENTRY         InstanceList;
    PLIST_ENTRY        pHeadInst;
    PLIST_ENTRY        pNextInst;
    PPDHI_INSTANCE     pInstance;
    PPDHI_INST_LIST    pInstList;
    LPVOID             TempBuffer        = NULL;
    DWORD              dwNewBuffer       = 0;
    LPVOID             LocalCounter      = NULL;
    DWORD              LocalCounterSize  = 0;
    LPVOID             LocalInstance     = NULL;
    DWORD              LocalInstanceSize = 0;
    DWORD              dwCntrBufferUsed  = 0;
    DWORD              dwInstBufferUsed  = 0;

    PdhiInitCounterHashTable(CounterTable);
    InitializeListHead(& InstanceList);
    LocalCounter  = G_ALLOC(MEDIUM_BUFFER_SIZE);
    LocalInstance = G_ALLOC(MEDIUM_BUFFER_SIZE);
    if (LocalCounter == NULL || LocalInstance == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    LocalCounterSize = LocalInstanceSize = MEDIUM_BUFFER_SIZE;
    if (mszCounterList != NULL) 
        memset(mszCounterList,   0, * pdwCounterListLength);
    if (mszInstanceList != NULL)
        memset(mszInstanceList,  0, * pdwInstanceListLength);

    if (IsValidLogHandle(hDataSource)) {
        pDataSource = (PPDHI_LOG)hDataSource;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pDataSource->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle (hDataSource)) {

                dwLogType = pDataSource->dwLogFormat;

                // enum objects based on log type & machine name
                switch (LOWORD(dwLogType)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiEnumObjectItemsFromTextLog (
                                (PPDHI_LOG) hDataSource,
                                szMachineName,
                                szObjectName,
                                CounterTable,
                                dwDetailLevel,
                                dwFlags);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                        pdhStatus = PdhiEnumObjectItemsFromWmiLog (
                                (PPDHI_LOG) hDataSource,
                                szMachineName,
                                szObjectName,
                                CounterTable,
                                dwDetailLevel,
                                dwFlags);
                        break;

                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiEnumObjectItemsFromBinaryLog (
                                (PPDHI_LOG) hDataSource,
                                szMachineName,
                                szObjectName,
                                CounterTable,
                                dwDetailLevel,
                                dwFlags);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        pdhStatus = PdhiEnumObjectItemsFromSQLLog (
                                (PPDHI_LOG) hDataSource,
                                szMachineName,
                                szObjectName,
                                CounterTable,
                                dwDetailLevel,
                                dwFlags);
                        break;

                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PdhiEnumObjectItemsFromPerfmonLog (
                                (PPDHI_LOG)hDataSource,
                                szMachineName,
                                szObjectName,
                                CounterTable,
                                dwDetailLevel,
                                dwFlags);
                        break;

                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pDataSource->hLogMutex);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        dwCntrBufferUsed = 0;
        for (dwIndex = 0; dwIndex < HASH_TABLE_SIZE; dwIndex ++) {
            PPDHI_INSTANCE pNewInst;
            pInstList = CounterTable[dwIndex];
            while (pInstList != NULL) {
                if (! IsListEmpty(& pInstList->InstList)) {
                    pHeadInst = & pInstList->InstList;
                    pNextInst = pHeadInst->Flink;
                    while (pNextInst != pHeadInst) {
                        pInstance = CONTAINING_RECORD(
                                        pNextInst, PDHI_INSTANCE, Entry);
                        pdhStatus = PdhiFindInstance(
                                & InstanceList,
                                pInstance->szInstance,
                                FALSE,
                                & pNewInst);
                        if (pNewInst->dwTotal < pInstance->dwTotal) {
                            pNewInst->dwTotal = pInstance->dwTotal;
                        }
                        pNextInst = pNextInst->Flink;
                    }
                }

                dwNewBuffer = (lstrlenW(pInstList->szCounter) + 1)
                            * sizeof(WCHAR);
                while (  LocalCounterSize
                       < (dwCntrBufferUsed + dwNewBuffer)) {
                    TempBuffer = LocalCounter;
                    LocalCounter = G_REALLOC(TempBuffer,
                        LocalCounterSize + MEDIUM_BUFFER_SIZE);
                    if (LocalCounter == NULL) {
                        G_FREE(TempBuffer);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                    LocalCounterSize += MEDIUM_BUFFER_SIZE;
                }

                dwNewBuffer = AddStringToMultiSz(
                              (LPVOID) LocalCounter,
                              pInstList->szCounter,
                              bUnicode);
                if (dwNewBuffer > 0) {
                    dwCntrBufferUsed = dwNewBuffer *
                            (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                }
                pInstList = pInstList->pNext;
            }
        }

        dwInstBufferUsed = 0;
        if (! IsListEmpty(& InstanceList)) {
            pHeadInst = & InstanceList;
            pNextInst = pHeadInst->Flink;
            while (pNextInst != pHeadInst) {
                pInstance = CONTAINING_RECORD(
                        pNextInst, PDHI_INSTANCE, Entry);

                dwNewBuffer  = (lstrlenW(pInstance->szInstance) + 1)
                                 * sizeof(WCHAR) * pInstance->dwTotal;
                while (  LocalInstanceSize
                       < (dwInstBufferUsed + dwNewBuffer)) {
                    TempBuffer = LocalInstance;
                    LocalInstance = G_REALLOC(TempBuffer,
                        LocalInstanceSize + MEDIUM_BUFFER_SIZE);
                    if (LocalInstance == NULL) {
                        G_FREE(TempBuffer);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                    LocalInstanceSize += MEDIUM_BUFFER_SIZE;
                }

                for (dwIndex = 0; dwIndex < pInstance->dwTotal; dwIndex ++) {
                        dwNewBuffer = AddStringToMultiSz(
                                      (LPVOID) LocalInstance,
                                      pInstance->szInstance,
                                      bUnicode);
                }
                if (dwNewBuffer > 0) {
                    dwInstBufferUsed = dwNewBuffer *
                            (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                }

                pNextInst = pNextInst->Flink;
            }
        }

        if (mszCounterList && dwCntrBufferUsed <= * pdwCounterListLength) {
            RtlCopyMemory(mszCounterList, LocalCounter, dwCntrBufferUsed);
        }
        else {
            if (mszCounterList)
                RtlCopyMemory(mszCounterList,
                              LocalCounter,
                              * pdwCounterListLength);
            dwCntrBufferUsed += (bUnicode) ? sizeof(WCHAR)
                                           : sizeof(CHAR);
            pdhStatus = PDH_MORE_DATA;
        }
        *pdwCounterListLength = dwCntrBufferUsed;

        if (dwInstBufferUsed > 0) {
            if (   mszInstanceList
                && dwInstBufferUsed <= * pdwInstanceListLength) {
                RtlCopyMemory(mszInstanceList, LocalInstance, dwInstBufferUsed);
            }
            else {
                if (mszInstanceList)
                    RtlCopyMemory(mszInstanceList,
                                  LocalInstance,
                                  * pdwInstanceListLength);
                dwInstBufferUsed += (bUnicode) ? sizeof(WCHAR)
                                               : sizeof(CHAR);
                pdhStatus = PDH_MORE_DATA;
            }
        }
        *pdwInstanceListLength = dwInstBufferUsed;
    }

Cleanup:
    if (! IsListEmpty(& InstanceList)) {
        pHeadInst = & InstanceList;
        pNextInst = pHeadInst->Flink;
        while (pNextInst != pHeadInst) {
            pInstance = CONTAINING_RECORD(pNextInst, PDHI_INSTANCE, Entry);
            pNextInst = pNextInst->Flink;
            RemoveEntryList(& pInstance->Entry);
            G_FREE(pInstance);
        }
    }
    for (dwIndex = 0; dwIndex < HASH_TABLE_SIZE; dwIndex ++) {
        PPDHI_INST_LIST pCurrent;
        pInstList = CounterTable[dwIndex];
        while (pInstList != NULL) {
            if (! IsListEmpty(& pInstList->InstList)) {
                pHeadInst = & pInstList->InstList;
                pNextInst = pHeadInst->Flink;
                while (pNextInst != pHeadInst) {
                    pInstance = CONTAINING_RECORD(
                                    pNextInst, PDHI_INSTANCE, Entry);
                    pNextInst = pNextInst->Flink;
                    RemoveEntryList(& pInstance->Entry);
                    G_FREE(pInstance);
                }
            }
            pCurrent  = pInstList;
            pInstList = pInstList->pNext;
            G_FREE(pCurrent);
        }
    }
    if (LocalCounter != NULL) {
        G_FREE(LocalCounter);
    }
    if (LocalInstance != NULL) {
        G_FREE(LocalInstance);
    }

    return pdhStatus;
}


BOOL
PdhiDataSourceHasDetailLevels (
    IN  LPWSTR  szDataSource
)
{
    if (szDataSource == NULL) {
        // real-time supports them
        return TRUE;
    } else {
        // logs don't (for now)
        return FALSE;
    }
}

BOOL
PdhiDataSourceHasDetailLevelsH(
    IN HLOG hDataSource
)
{
    return (hDataSource == H_REALTIME_DATASOURCE);
}

PDH_FUNCTION
PdhiGetMatchingLogRecord (
    IN  HLOG        hLog,
    IN  LONGLONG    *pStartTime,
    IN  LPDWORD     pdwIndex
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG   pLog;
    DWORD       dwTempIndex;

    __try {
        dwTempIndex = *pdwIndex;
        *pdwIndex = 0;
        *pdwIndex = dwTempIndex;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (IsValidLogHandle (hLog)) {
            pLog = (PPDHI_LOG)hLog;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                if (IsValidLogHandle (hLog)) {
                    // call any type-specific open functions
                    switch (LOWORD(pLog->dwLogFormat)) {
                        case PDH_LOG_TYPE_CSV:
                        case PDH_LOG_TYPE_TSV:
                            pdhStatus = PdhiGetMatchingTextLogRecord (
                                pLog,
                                pStartTime,
                                pdwIndex);
                            break;

                        case PDH_LOG_TYPE_BINARY:
                        case PDH_LOG_TYPE_RETIRED_BIN:
                            pdhStatus = PdhiGetMatchingBinaryLogRecord (
                                pLog,
                                pStartTime,
                                pdwIndex);
                            break;

                        case PDH_LOG_TYPE_SQL:
                            pdhStatus = PdhiGetMatchingSQLLogRecord (
                                pLog,
                                pStartTime,
                                pdwIndex);
                            break;

                        case PDH_LOG_TYPE_PERFMON:
                            pdhStatus = PdhiGetMatchingPerfmonLogRecord (
                                pLog,
                                pStartTime,
                                pdwIndex);
                            break;

                        default:
                            pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                            break;
                    }
                } else {
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX (pLog->hLogMutex);
            }
        } else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhiGetCounterValueFromLogFile (
    IN HLOG          hLog,
    IN DWORD         dwIndex,
    IN PPDHI_COUNTER pCounter
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG       pLog = NULL;
    PDH_RAW_COUNTER pValue;

    memset (&pValue, 0, sizeof (pValue));

    pCounter->LastValue = pCounter->ThisValue;

    if (pdhStatus == ERROR_SUCCESS) {
        if (IsValidLogHandle (hLog)) {
            pLog = (PPDHI_LOG)hLog;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                if (IsValidLogHandle (hLog)) {
                    // call any type-specific open functions
                    switch (LOWORD(pLog->dwLogFormat)) {
                        case PDH_LOG_TYPE_CSV:
                        case PDH_LOG_TYPE_TSV:
                            pdhStatus = PdhiGetCounterValueFromTextLog (
                                pLog,
                                dwIndex,
                                & pCounter->plCounterInfo,
                                & pValue);
                            break;

                        case PDH_LOG_TYPE_RETIRED_BIN:
                            pdhStatus = PdhiGetCounterValueFromBinaryLog (
                                pLog,
                                dwIndex,
                                pCounter);
                            break;

                        case PDH_LOG_TYPE_SQL:
                            pdhStatus = PdhiGetCounterValueFromSQLLog (
                                pLog,
                                dwIndex,
                                pCounter,
                                &pValue);
                            break;

                        case PDH_LOG_TYPE_PERFMON:
                            pdhStatus = PdhiGetCounterValueFromPerfmonLog (
                                pLog,
                                dwIndex,
                                pCounter,
                                & pValue);
                            break;

                        case PDH_LOG_TYPE_BINARY:
                        default:
                            pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                            break;
                    }
                } else {
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX (pLog->hLogMutex);
            }
        } else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }

    if (   pdhStatus == ERROR_SUCCESS
        && LOWORD(pLog->dwLogFormat) != PDH_LOG_TYPE_RETIRED_BIN
        && LOWORD(pLog->dwLogFormat) != PDH_LOG_TYPE_BINARY) {

        if (pdhStatus != ERROR_SUCCESS) {
            // See if this is because there's no more entries.
            // If not, clear the counter value & return error
            //
            if (pdhStatus != PDH_NO_MORE_DATA) {
                memset (& pCounter->ThisValue, 0, sizeof (PDH_RAW_COUNTER));
                pCounter->ThisValue.CStatus = pdhStatus;
            }
        }
        else {
            pCounter->ThisValue = pValue;
        }
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhiResetLogBuffers (
    IN  HLOG    hLog
)
{
    PDH_STATUS  pdhStatus;
    PPDHI_LOG   pLog;

    if (IsValidLogHandle(hLog)) {
        pLog = (PPDHI_LOG)hLog;

        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle (hLog)) {
                if (LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_BINARY) {
                    pdhStatus = PdhiRewindWmiLog(pLog);
                }
                else {
                    pLog->dwLastRecordRead = 0;

                    if (pLog->lpMappedFileBase != NULL) {
                        // for mapped files we use a pointer into the buffer
                        // so reset it
                        pLog->pLastRecordRead = pLog->lpMappedFileBase;
                    } else {
                        // for other files we have a separate buffer
                        if (pLog->pLastRecordRead != NULL) {
                            G_FREE (pLog->pLastRecordRead);
                            pLog->pLastRecordRead = NULL;
                        }
                    }
                    pdhStatus = ERROR_SUCCESS;
                }
            } else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pLog->hLogMutex);
        }
    } else {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    return pdhStatus;
}


PDH_FUNCTION
PdhListLogFileHeaderW (
    IN  LPCWSTR     szFileName,
    IN  LPWSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
)
{
    HLOG        hDataSource = NULL;
    PDH_STATUS  pdhStatus;
    DWORD       dwLogType = -1;
    PPDHI_LOG   pDataSource;
    BOOL        bUnicode = TRUE;

    // open log file
    pdhStatus = PdhOpenLogW (
        szFileName,
        PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
        &dwLogType,
        NULL,
        0,
        NULL,
        &hDataSource);

    if (pdhStatus == ERROR_SUCCESS) {
        pDataSource = (PPDHI_LOG)hDataSource;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pDataSource->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle (hDataSource)) {
                // enum objects based on log type & machine name
                switch (LOWORD(dwLogType)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiListHeaderFromTextLog (
                            (PPDHI_LOG)hDataSource,
                            (LPVOID)mszHeaderList,
                            pcchHeaderListSize,
                            bUnicode);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiListHeaderFromBinaryLog (
                            (PPDHI_LOG)hDataSource,
                            (LPVOID)mszHeaderList,
                            pcchHeaderListSize,
                            bUnicode);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        pdhStatus = PdhiListHeaderFromSQLLog (
                            (PPDHI_LOG)hDataSource,
                            (LPVOID)mszHeaderList,
                            pcchHeaderListSize,
                            bUnicode);
                        break;

                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PDH_NOT_IMPLEMENTED;
                        break;

                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                }
                PdhCloseLog (hDataSource, 0);
            } else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pDataSource->hLogMutex);
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhListLogFileHeaderA (
    IN  LPCSTR     szFileName,
    IN  LPSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
)
{
    HLOG        hDataSource = NULL;
    PDH_STATUS  pdhStatus;
    DWORD       dwLogType = -1;
    PPDHI_LOG   pDataSource;
    BOOL        bUnicode = FALSE;

    // open log file
    pdhStatus = PdhOpenLogA (
        szFileName,
        PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
        &dwLogType,
        NULL,
        0,
        NULL,
        &hDataSource);

    if (pdhStatus == ERROR_SUCCESS) {
        pDataSource = (PPDHI_LOG)hDataSource;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pDataSource->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle (hDataSource)) {
                // enum objects based on log type & machine name
                switch (LOWORD(dwLogType)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiListHeaderFromTextLog (
                            (PPDHI_LOG)hDataSource,
                            (LPVOID)mszHeaderList,
                            pcchHeaderListSize,
                            bUnicode);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiListHeaderFromBinaryLog (
                            (PPDHI_LOG)hDataSource,
                            (LPVOID)mszHeaderList,
                            pcchHeaderListSize,
                            bUnicode);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        pdhStatus = PdhiListHeaderFromSQLLog (
                            (PPDHI_LOG)hDataSource,
                            (LPVOID)mszHeaderList,
                            pcchHeaderListSize,
                            bUnicode);
                        break;

                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PDH_NOT_IMPLEMENTED;
                        break;

                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                }
                PdhCloseLog (hDataSource, 0);
            } else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pDataSource->hLogMutex);
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiGetMultiInstanceValueFromLogFile (
    IN  HLOG        hLog,
    IN  DWORD       dwIndex,
    IN  PPDHI_COUNTER     pCounter,
    IN  OUT PPDHI_RAW_COUNTER_ITEM_BLOCK    *ppValue
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG   pLog;

    // allocates and updates the raw counter data array 
    // in the counter structure and returns a pointer to that 
    // structure in the ppvalue argument

    if (pdhStatus == ERROR_SUCCESS) {
        if (IsValidLogHandle (hLog)) {
            pLog = (PPDHI_LOG)hLog;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                if (IsValidLogHandle (hLog)) {
                    // call any type-specific open functions
                    switch (LOWORD(pLog->dwLogFormat)) {
                        case PDH_LOG_TYPE_CSV:
                        case PDH_LOG_TYPE_TSV:
                            // Text files do not support this type of counter
                            pdhStatus = PDH_INVALID_ARGUMENT;
                            break;

                        case PDH_LOG_TYPE_BINARY:
                        case PDH_LOG_TYPE_RETIRED_BIN:
                            pdhStatus = PdhiGetCounterArrayFromBinaryLog (
                                pLog,
                                dwIndex,
                                pCounter,
                                ppValue);
                            break;

                        case PDH_LOG_TYPE_PERFMON:
                            // not currently implemented but it could be
                            pdhStatus = PDH_NOT_IMPLEMENTED;
                            break;

                        default:
                            pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                            break;
                    }
                } else {
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX (pLog->hLogMutex);
            }
        } else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }

    return pdhStatus;
}

extern DWORD DataSourceTypeW(IN LPCWSTR szDataSource);

PDH_FUNCTION
PdhBindInputDataSourceW(
    IN HLOG   * phDataSource,
    IN LPCWSTR  LogFileNameList
)
{
    PDH_STATUS PdhStatus    = ERROR_SUCCESS;
    DWORD      dwDataSource = DataSourceTypeW(LogFileNameList);

    LPWSTR     NextLogFile  = (LPWSTR) LogFileNameList;
    ULONG      LogFileCount = 0;
    ULONG      LogFileSize;
    PPDHI_LOG  pLogHead     = NULL;
    PPDHI_LOG  pLogNew      = NULL;
    DWORD      dwLogType;
    HLOG       hLogLocal = NULL;
    WCHAR      wcType[VALUE_BUFFER_SIZE];
    
    switch (dwDataSource) {
    case DATA_SOURCE_WBEM:
        * phDataSource = H_WBEM_DATASOURCE;
        break;

    case DATA_SOURCE_REGISTRY:
        * phDataSource = H_REALTIME_DATASOURCE;
        break;

    case DATA_SOURCE_LOGFILE:
        ZeroMemory((LPWSTR) wcType, sizeof(WCHAR) * VALUE_BUFFER_SIZE);
        lstrcpynW((LPWSTR) wcType,
                  (LPWSTR) LogFileNameList,
                  lstrlenW(cszSQL) + 1);
        if (lstrcmpiW((LPWSTR) wcType, (LPWSTR) cszSQL) == 0) {
            // special handling for SQL datasource
            //
            dwLogType = PDH_LOG_TYPE_SQL;
            PdhStatus = PdhOpenLogW(LogFileNameList,
                                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                    & dwLogType,
                                    NULL,
                                    0,
                                    NULL,
                                    & hLogLocal);
            if (PdhStatus == ERROR_SUCCESS) {
                * phDataSource = hLogLocal;
            }
            break;
        }

        __try {
            while (* NextLogFile != L'\0') {
                LogFileSize  = sizeof(WCHAR) * (lstrlenW(NextLogFile) + 1);
                LogFileSize  = DWORD_MULTIPLE(LogFileSize);
                //LogFileSize += sizeof(PDHI_LOG);

                pLogNew = G_ALLOC(LogFileSize + sizeof(PDHI_LOG));
                if (pLogNew == NULL) {
                    PdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    break;
                }
                RtlZeroMemory(pLogNew, LogFileSize + sizeof(PDHI_LOG));
                * ((LPDWORD)(& pLogNew->signature[0])) = SigLog;
                pLogNew->dwLength  = sizeof(PDHI_LOG);
                pLogNew->szLogFileName = (LPWSTR) (  ((PUCHAR) pLogNew)
                                                   + sizeof(PDHI_LOG));
                lstrcpyW(pLogNew->szLogFileName, NextLogFile);

                pLogNew->NextLog = pLogHead;
                pLogHead         = pLogNew;
                LogFileCount ++;
                NextLogFile     += (lstrlenW(NextLogFile) + 1);
            }

            if (pLogHead == NULL) {
                PdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }

        if (PdhStatus == ERROR_SUCCESS) {
            pLogHead->hLogMutex = CreateMutexW(NULL, TRUE, NULL);
            pLogHead->hLogFileHandle = INVALID_HANDLE_VALUE;
            pLogHead->hCatFileHandle = INVALID_HANDLE_VALUE;
            
            if (PdhiFirstLogEntry == NULL) {
                PdhiFirstLogEntry    = pLogHead;
                pLogHead->next.flink =
                pLogHead->next.blink = pLogHead;
            }
            else {
                PPDHI_LOG pFirstLog   = PdhiFirstLogEntry;
                PPDHI_LOG pLastLog    = pFirstLog->next.blink;

                pLogHead->next.flink  = pLastLog->next.flink;
                pLastLog->next.flink  = pLogHead;
                pLogHead->next.blink  = pFirstLog->next.blink;
                pFirstLog->next.blink = pLogHead;
            }

            PdhStatus = OpenInputLogFile(
                            pLogHead,
                            PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                          & dwDataSource);
            if (   PdhStatus == ERROR_SUCCESS
                && (dwDataSource == PDH_LOG_TYPE_BINARY || LogFileCount == 1)) {
                * phDataSource = (HLOG) pLogHead;
            }
            else {
                if (PdhStatus == ERROR_SUCCESS) {
                    PdhStatus = PDH_INVALID_ARGUMENT;
                    PdhCloseLog(pLogHead, 0);
                }
                DeleteLogEntry(pLogHead);
            }
        }
        else {
            while (pLogHead != NULL) {
                pLogNew  = pLogHead;
                pLogHead = pLogNew->NextLog;
                G_FREE(pLogNew);
            }
        }
        break;

    default:
        PdhStatus = PDH_INVALID_ARGUMENT;
        break;
    }

    return PdhStatus;
}

PDH_FUNCTION
PdhBindInputDataSourceA(
    IN HLOG   * phDataSource,
    IN LPCSTR   LogFileNameList
)
{
    LPWSTR wLogFileNameList = NULL;
    LPWSTR wNextFileName;
    LPSTR  aNextFileName;
    ULONG  LogFileListSize = 1;
    PDH_STATUS PdhStatus = ERROR_SUCCESS;

    if (LogFileNameList == NULL) {
        wLogFileNameList = NULL;
    }
    else {
        __try {
            while (   LogFileNameList[LogFileListSize - 1] != '\0'
                   || LogFileNameList[LogFileListSize] != '\0') {
                LogFileListSize ++;
            }

            LogFileListSize = (LogFileListSize + 1) * sizeof(WCHAR);

            wLogFileNameList = (LPWSTR) G_ALLOC(LogFileListSize);
            if (wLogFileNameList == NULL) {
                PdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else {
                aNextFileName = (LPSTR) LogFileNameList;
                wNextFileName = wLogFileNameList;

                while (* aNextFileName != '\0') {
                    LogFileListSize = lstrlenA(aNextFileName);
                    MultiByteToWideChar(_getmbcp(),
                                        0,
                                        aNextFileName,
                                        LogFileListSize,
                                        (LPWSTR) wNextFileName,
                                        LogFileListSize + 1);

                    aNextFileName += LogFileListSize;
                    wNextFileName += LogFileListSize;
                }
                * wNextFileName = L'\0';
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (PdhStatus == ERROR_SUCCESS) {
        PdhStatus = PdhBindInputDataSourceW(phDataSource, wLogFileNameList);
    }

    return PdhStatus;
}

BOOL
PdhiCloseAllLoggers()
{
    while (PdhiFirstLogEntry != NULL) {
        PPDHI_LOG pLog = PdhiFirstLogEntry;
        CloseAndDeleteLogEntry(pLog, 0, TRUE);
    }

    return TRUE;
}

PDH_FUNCTION PdhiCheckWmiLogFileType(IN LPCWSTR LogFileName,
                                     IN LPDWORD LogFileType);

PDH_FUNCTION
PdhGetLogFileTypeW(
    IN LPCWSTR LogFileName,
    IN LPDWORD LogFileType)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HANDLE     hFile;
    DWORD      dwLogFormat;

    if (LogFileName == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwLogFormat   = * LogFileType;
            * LogFileType = dwLogFormat;
            if (* LogFileName == L'\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        hFile = CreateFileW(LogFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
        if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        dwLogFormat = GetLogFileType(hFile);
        CloseHandle(hFile);
        if (dwLogFormat == PDH_LOG_TYPE_UNDEFINED) {
            pdhStatus = PdhiCheckWmiLogFileType(LogFileName, & dwLogFormat);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        * LogFileType = dwLogFormat;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhGetLogFileTypeA(
    IN LPCSTR  LogFileName,
    IN LPDWORD LogFileType)
{
    PDH_STATUS pdhStatus      = ERROR_SUCCESS;
    LPWSTR     wszLogFileName = NULL;
    DWORD      dwLogFileName  = 0;

    if (LogFileName == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            if (* LogFileName == '\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else {
                dwLogFileName  = lstrlenA(LogFileName);
                wszLogFileName = (LPWSTR)
                                 G_ALLOC((dwLogFileName + 1) * sizeof(WCHAR));
                if (wszLogFileName == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else {
                    MultiByteToWideChar(_getmbcp(),
                                        0,
                                        LogFileName,
                                        dwLogFileName,
                                        (LPWSTR) wszLogFileName,
                                        dwLogFileName + 1);
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhGetLogFileTypeW(wszLogFileName, LogFileType);
    }
    if (wszLogFileName != NULL) {
        G_FREE(wszLogFileName);
    }
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log_bin.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    log_bin.c

Abstract:

    <abstract>

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <pdh.h>
//#define  _SHOW_PDH_MEM_ALLOCS 1
#include "pdhidef.h"
#include "log_bin.h"
#include "log_wmi.h"
#include "strings.h"
#include "pdhmsg.h"

typedef struct _LOG_BIN_CAT_RECORD {
    PDHI_BINARY_LOG_RECORD_HEADER    RecHeader;
    PDHI_LOG_CAT_ENTRY               CatEntry;
    DWORD                            dwEntryRecBuff[1];
} LOG_BIN_CAT_RECORD, *PLOG_BIN_CAT_RECORD;


typedef struct _LOG_BIN_CAT_ENTRY {
    DWORD                       dwEntrySize;
    DWORD                       dwOffsetToNextInstance;
    DWORD                       dwEntryOffset;
    LOG_BIN_CAT_RECORD           bcRec;
} LOG_BIN_CAT_ENTRY, *PLOG_BIN_CAT_ENTRY;


#define RECORD_AT(p,lo)         ((PPDHI_BINARY_LOG_RECORD_HEADER)((LPBYTE)(p->lpMappedFileBase) + lo))

LPCSTR  PdhiszRecordTerminator = "\r\n";
DWORD   PdhidwRecordTerminatorLength = 2;

#define MAX_BINLOG_FILE_SIZE ((LONGLONG)0x0000000040000000)

// dwFlags values
#define WBLR_WRITE_DATA_RECORD      0
#define WBLR_WRITE_LOG_HEADER       1
#define WBLR_WRITE_COUNTER_HEADER   2

PDH_FUNCTION
PdhiWriteOneBinaryLogRecord (
    PPDHI_LOG   pLog,
    LPCVOID     pData,
    DWORD       dwSize,
    LPDWORD     pdwRtnSize,
    DWORD       dwFlags)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwRtnSize;
    LONGLONG    llFirstOffset = 0;
    LONGLONG    llThisOffset =0;
    LONGLONG    llNextOffset =0;
    LONGLONG    llLastOffset =0;
    LONGLONG    llWrapOffset =0;
    PPDHI_BINARY_LOG_HEADER_RECORD pHeader;
    DWORD       dwRecLen;

    LPVOID      lpDest = NULL;

    LARGE_INTEGER   liFileSize;

    SetLastError (ERROR_SUCCESS);

    if (pLog->lpMappedFileBase != NULL) {
        if (dwSize > pLog->llMaxSize) {
            // This record is too large to ever fit in this file
            pdhStatus = PDH_LOG_FILE_TOO_SMALL;
        } else {
            // T
            if (dwFlags == WBLR_WRITE_DATA_RECORD) {
                // this is a mapped file so it's either a circular
                // or a limited linear file.
                // get the address of the log file header record.
                pHeader = (PPDHI_BINARY_LOG_HEADER_RECORD)
                    ((LPBYTE)(pLog->lpMappedFileBase) + pLog->dwRecord1Size);
                // then write the record using memory functions since the
                // file is mapped as a memory section
                // 1st see if there's room in the file for this record
                llNextOffset = pHeader->Info.NextRecordOffset + dwSize;
                if (llNextOffset > pLog->llMaxSize) {
                    if (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR)  {
                        // if circular, then start back at the beginning
                        llWrapOffset = pHeader->Info.NextRecordOffset;
                        if ((pLog->llMaxSize - llWrapOffset) > dwSize) {
                            // This record is too large to ever fit in the rest of this file
                            pdhStatus = PDH_LOG_FILE_TOO_SMALL;
                        } else {
                            llThisOffset = pHeader->Info.FirstDataRecordOffset;
                            llNextOffset = llThisOffset + dwSize;
                            llLastOffset = llThisOffset;
                            llFirstOffset = llThisOffset;
                            while (llFirstOffset < llNextOffset) {
                                dwRecLen = RECORD_AT(pLog, llFirstOffset)->dwLength;
                                if (dwRecLen > 0) {
                                   llFirstOffset += dwRecLen;
                                } else {
                                    // this record is unused so try it.
                                    break;
                                }
                                assert (llFirstOffset < llWrapOffset);
                            }
                        }
                    } else {
                        // that's all that will fit so return
                        // file is full error
                        pdhStatus = PDH_END_OF_LOG_FILE;
                        dwRtnSize = 0;
                    }
                } else {
                    // this record will fit in the remaining space of
                    // the log file so write it
                    llThisOffset = pHeader->Info.NextRecordOffset;
                    llLastOffset = llThisOffset;
                    llWrapOffset = pHeader->Info.WrapOffset;
                    llFirstOffset = pHeader->Info.FirstRecordOffset;
                    if (llWrapOffset != 0) {
                        // check next pointer to see if we're on the
                        // 2nd or more lap through a circular log
                        // in which case, the first record should come after the last
                        while (llNextOffset > llFirstOffset) {
                            llFirstOffset += RECORD_AT(pLog, llFirstOffset)->dwLength;
                            // check for running past the end of the file, in which case
                            // the first record can be found at the beginning of the log
                            if (llFirstOffset >= llWrapOffset) {
                                llFirstOffset = pHeader->Info.FirstDataRecordOffset;
                                llWrapOffset = llNextOffset;
                                break;
                            }
                        }
                        if (llNextOffset > llWrapOffset) llWrapOffset = llNextOffset;
                    } else {
                        // this is just a linear log or a circular log on the first lap
                        // so there's nothing to do
                    }
                }

                if (pdhStatus == ERROR_SUCCESS) {
                    // test for strays here before continuing
                    assert (llThisOffset < pLog->llMaxSize);
                    assert (llNextOffset < pLog->llMaxSize);
                    assert (llWrapOffset < pLog->llMaxSize);
                    // here first, this, next and last should be set
                    // first == the first record to be read from the log
                    // this == where this record will be placed
                    // next == where the next record after this one will be placed
                    // last == the last record in the sequence
                    // wrap == the last byte used in the log file
                    //              (not necessarily the end of the file)

                    __try {
                        // move the caller's data into the file
                        lpDest = (LPVOID)RECORD_AT(pLog, llThisOffset);
                        // make sure there's room in the section for this
                        // record...
                        if ((llThisOffset + dwSize) <= pLog->llMaxSize) {
                            // looks like it'll fit
                            RtlCopyMemory(lpDest, (LPVOID)pData, dwSize);

                            // update the header fields
                            pHeader->Info.NextRecordOffset = llNextOffset;
                            pHeader->Info.FirstRecordOffset = llFirstOffset;
                            pHeader->Info.LastRecordOffset = llLastOffset;
                            pHeader->Info.WrapOffset = llWrapOffset;
                            // write update time stamp
                            GetSystemTimeAsFileTime ((LPFILETIME)(&pHeader->Info.LastUpdateTime));
                            if (pdwRtnSize != NULL) {
                                *pdwRtnSize = dwSize;
                            }
                            // update the filesize
                            if (llNextOffset > pHeader->Info.FileLength) {
                                pHeader->Info.FileLength = llNextOffset;
                            }
                            assert (pHeader->Info.FileLength >= pHeader->Info.WrapOffset);
                        } else {
                            // this record is too big for the file
                            pdhStatus = PDH_LOG_FILE_TOO_SMALL;
                        }
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        pdhStatus = GetExceptionCode();
                    }
                } else {
                    // a error occured so pass it back up to the caller
                }
            } else {
                if (dwFlags == WBLR_WRITE_LOG_HEADER) {
                    // this goes right at the start of the file
                    lpDest = (LPVOID)pLog->lpMappedFileBase;
                    RtlCopyMemory(lpDest, (LPVOID)pData, dwSize);
                } else if (dwFlags == WBLR_WRITE_COUNTER_HEADER) {
                    assert (pLog->dwRecord1Size != 0);
                    lpDest = (LPVOID)RECORD_AT(pLog, pLog->dwRecord1Size);
                    RtlCopyMemory(lpDest, (LPVOID)pData, dwSize);
                } else {
                    // This should never happen
                    assert(   dwFlags == WBLR_WRITE_LOG_HEADER
                           || dwFlags == WBLR_WRITE_COUNTER_HEADER
                           || dwFlags == WBLR_WRITE_DATA_RECORD);
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
    } else {
        liFileSize.LowPart = GetFileSize (
            pLog->hLogFileHandle,
            (LPDWORD)&liFileSize.HighPart);
        // add in new record to see if it will fit.
        liFileSize.QuadPart += dwSize;
        // test for maximum allowable filesize
        if (liFileSize.QuadPart <= MAX_BINLOG_FILE_SIZE) {
            // write the data to the file as a file
            if (!WriteFile (pLog->hLogFileHandle,
                pData,
                dwSize,
                pdwRtnSize,
                NULL)) {
                pdhStatus = GetLastError();
            } else {
                FlushFileBuffers(pLog->hLogFileHandle);
                pdhStatus = ERROR_SUCCESS;
            }
        } else {
            pdhStatus = ERROR_LOG_FILE_FULL;
        } 
    }

    return pdhStatus;
}

DWORD
PdhiComputeDwordChecksum (
    IN  LPVOID    pBuffer,
    IN  DWORD    dwBufferSize    // in bytes
)
{
    LPDWORD    pDwVal;
    LPBYTE    pByteVal;
    DWORD    dwDwCount;
    DWORD    dwByteCount;
    DWORD    dwThisByte;
    DWORD    dwCheckSum = 0;
    DWORD    dwByteVal = 0;

    if (dwBufferSize > 0) {
        dwDwCount = dwBufferSize / sizeof(DWORD);
        dwByteCount = dwBufferSize % sizeof(DWORD);
        assert (dwByteCount >= 0);
        assert (dwByteCount < sizeof(DWORD));

        pDwVal = (LPDWORD)pBuffer;
        while (dwDwCount != 0) {
            dwCheckSum += *pDwVal++;
            dwDwCount--;
        }
        assert (dwDwCount == 0);
        assert ((DWORD)((LPBYTE)pDwVal - (LPBYTE)pBuffer) <= dwBufferSize);

        pByteVal = (LPBYTE)pDwVal;
        dwThisByte = 0;
        while (dwThisByte < dwByteCount) {
            dwByteVal |= ((*pByteVal & 0x000000FF) << (dwThisByte * 8));
            dwThisByte++;
        }
        assert ((DWORD)((LPBYTE)pByteVal - (LPBYTE)pBuffer) == dwBufferSize);

        dwCheckSum += dwByteVal;
    }

    return dwCheckSum;
}

PPDHI_BINARY_LOG_RECORD_HEADER
PdhiGetSubRecord (
    IN  PPDHI_BINARY_LOG_RECORD_HEADER  pRecord,
    IN  DWORD                           dwRecordId
)
// locates the specified sub record in the pRecord Buffer
// the return pointer is between pRecord and pRecord + pRecord->dwLength;
// NULL is returned if the specified record could not be found
// ID values start at 1 for the first sub record in buffer
{
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisRecord;

    DWORD   dwRecordType;
    DWORD   dwRecordLength;
    DWORD   dwBytesProcessed;

    DWORD   dwThisSubRecordId;

    dwRecordType = ((PPDHI_BINARY_LOG_RECORD_HEADER)pRecord)->dwType;
    dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER)pRecord)->dwLength;

    pThisRecord = (PPDHI_BINARY_LOG_RECORD_HEADER)((LPBYTE)pRecord +
        sizeof (PDHI_BINARY_LOG_RECORD_HEADER));
    dwBytesProcessed = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);

    if (dwBytesProcessed < dwRecordLength) {
        dwThisSubRecordId = 1;
        while (dwThisSubRecordId < dwRecordId) {
            if ((WORD)(pThisRecord->dwType & 0x0000FFFF) == BINLOG_START_WORD) {
                // go to next sub record
                dwBytesProcessed += pThisRecord->dwLength;
                pThisRecord = (PPDHI_BINARY_LOG_RECORD_HEADER)
                    (((LPBYTE)pThisRecord) + pThisRecord->dwLength);
                if (dwBytesProcessed >= dwRecordLength) {
                    // out of sub-records so exit
                    break;
                } else {
                    dwThisSubRecordId++;
                }
            } else {
                // we're lost so bail
                break;
            }
        }
    } else {
        dwThisSubRecordId = 0;
    }

    if (dwThisSubRecordId == dwRecordId) {
        // then validate this is really a record and it's within the
        // master record.
        if ((WORD)(pThisRecord->dwType & 0x0000FFFF) != BINLOG_START_WORD) {
            // bogus record so return a NULL pointer
            pThisRecord = NULL;
        } else {
            // this is OK so return pointer
        }
    } else {
        // record not found so return a NULL pointer
        pThisRecord = NULL;
    }

    return pThisRecord;
}

STATIC_PDH_FUNCTION
PdhiReadBinaryMappedRecord(
    IN  PPDHI_LOG   pLog,
    IN  DWORD   dwRecordId,
    IN  LPVOID  pRecord,
    IN  DWORD   dwMaxSize
)
{
    PDH_STATUS  pdhStatus= ERROR_SUCCESS;
    LPVOID      pEndOfFile;
    LPVOID      pLastRecord;
    DWORD       dwLastRecordIndex;
    PPDHI_BINARY_LOG_HEADER_RECORD pHeader;
    PPDHI_BINARY_LOG_RECORD_HEADER pRecHeader;
    LPVOID      pLastRecordInLog;
    DWORD       dwBytesToRead;
    DWORD       dwBytesRead;
    BOOL        bStatus;

    if (dwRecordId == 0) return PDH_ENTRY_NOT_IN_LOG_FILE;    // record numbers start at 1

    // see if the file has been mapped
    if (pLog->hMappedLogFile == NULL) {
        // then it's not mapped so read it using the file system
        if ((pLog->dwLastRecordRead == 0) || (dwRecordId < pLog->dwLastRecordRead)) {
            // then we know no record has been read yet so assign
            // pointer just to be sure
            SetFilePointer (pLog->hLogFileHandle, 0, NULL, FILE_BEGIN);
            
            // allocate a new buffer
            if (pLog->dwMaxRecordSize < 0x10000) pLog->dwMaxRecordSize = 0x10000;
            dwBytesToRead = pLog->dwMaxRecordSize;

            // allocate a fresh buffer
            if (pLog->pLastRecordRead != NULL) {
                G_FREE(pLog->pLastRecordRead);
                pLog->pLastRecordRead = NULL;
            }
            pLog->pLastRecordRead = G_ALLOC (pLog->dwMaxRecordSize);

            if (pLog->pLastRecordRead == NULL) {
                pdhStatus =  PDH_MEMORY_ALLOCATION_FAILURE;
            } else {
                // initialize the first record header
                dwBytesToRead = pLog->dwRecord1Size;
                dwBytesRead = 0;
                bStatus = ReadFile (
                    pLog->hLogFileHandle,
                    pLog->pLastRecordRead,
                    dwBytesToRead,
                    &dwBytesRead,
                    NULL);

                if (bStatus && (dwBytesRead == pLog->dwRecord1Size)) {
                    // make sure the buffer is big enough
                    pLog->dwLastRecordRead = 1;
                    pdhStatus = ERROR_SUCCESS;
                } else {
                    // unable to read the first record
                    pdhStatus = PDH_UNABLE_READ_LOG_HEADER;
                }
            }
        } else {
            // assume everything is already set up and OK
        }

//        pHeader = (PPDHI_BINARY_LOG_HEADER_RECORD)RECORD_AT(pLog, pLog->dwRecord1Size);
//        assert (*(WORD *)&(pHeader->RecHeader.dwType) == BINLOG_START_WORD);

        // "seek" to the desired record file pointer should either be pointed 
        // to the start of a new record or at the end of the file
        while ((dwRecordId != pLog->dwLastRecordRead) && (pdhStatus == ERROR_SUCCESS)) {
            // clear the buffer
            memset (pLog->pLastRecordRead, 0, pLog->dwMaxRecordSize);
            // read record header field
            dwBytesToRead = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
            dwBytesRead = 0;
            bStatus = ReadFile (
                pLog->hLogFileHandle,
                pLog->pLastRecordRead,
                dwBytesToRead,
                &dwBytesRead,
                NULL);

            if (bStatus && (dwBytesRead == dwBytesToRead)) {
               // make sure the rest of the record will fit in the buffer
                pRecHeader = (PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead;
                // make sure this is a valid record
                if (*(WORD *)&(pRecHeader->dwType) == BINLOG_START_WORD) {
                    if (pRecHeader->dwLength > pLog->dwMaxRecordSize) {
                        // realloc the buffer
                        LPVOID pTmp = pLog->pLastRecordRead;
                        pLog->dwMaxRecordSize = pRecHeader->dwLength;
                        pLog->pLastRecordRead = G_REALLOC(pTmp, pLog->dwMaxRecordSize);
                        if (pLog->pLastRecordRead == NULL) {
                            G_FREE(pTmp);
                        }
                    }

                    if (pLog->pLastRecordRead != NULL) {
                        dwBytesToRead = pRecHeader->dwLength - sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
                        dwBytesRead = 0;
                        pLastRecord = (LPVOID)((LPBYTE)(pLog->pLastRecordRead) + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                        bStatus = ReadFile (
                            pLog->hLogFileHandle,
                            pLastRecord,
                            dwBytesToRead,
                            &dwBytesRead,
                            NULL);

                        if (bStatus) {
                            pLog->dwLastRecordRead++;
                        } else {
                            pdhStatus = PDH_END_OF_LOG_FILE;
                        }
                    } else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                } else {
                    // file is corrupt
                    pdhStatus = PDH_INVALID_DATA;
                }
            } else {
                pdhStatus = PDH_END_OF_LOG_FILE;
            }
        }
        // here the result will be success when the specified file has been read or
        // a PDH error if not
    } else {
        // the file has been memory mapped so use that interface
        if (pLog->dwLastRecordRead == 0) {
            // then we know no record has been read yet so assign
            // pointer just to be sure
            pLog->pLastRecordRead = pLog->lpMappedFileBase;
            pLog->dwLastRecordRead = 1;
        }

        pHeader = (PPDHI_BINARY_LOG_HEADER_RECORD)RECORD_AT(pLog, pLog->dwRecord1Size);
        assert (*(WORD *)&(pHeader->RecHeader.dwType) == BINLOG_START_WORD);

        // "seek" to the desired record
        if (dwRecordId < pLog->dwLastRecordRead) {
            if (dwRecordId >= BINLOG_FIRST_DATA_RECORD) {
                // rewind the file
                pLog->pLastRecordRead = (LPVOID)((LPBYTE)pLog->lpMappedFileBase + pHeader->Info.FirstRecordOffset);
                pLog->dwLastRecordRead = BINLOG_FIRST_DATA_RECORD;
            } else {
                // rewind the file
                pLog->pLastRecordRead = pLog->lpMappedFileBase;
                pLog->dwLastRecordRead = 1;
            }
        }

        // then use the point specified as the end of the file
        // if the log file contians a specified Wrap offset, then use that
        // if not, then if the file length is specified, use that
        // if not, the use the reported file length
        pEndOfFile = (LPVOID)((LPBYTE)pLog->lpMappedFileBase);

        if (pHeader->Info.WrapOffset > 0) {
            pEndOfFile = (LPVOID)((LPBYTE)pEndOfFile + pHeader->Info.WrapOffset);
            assert (pHeader->Info.FileLength >= pHeader->Info.WrapOffset);
        } else if (pHeader->Info.FileLength > 0) {
            pEndOfFile = (LPVOID)((LPBYTE)pEndOfFile + pHeader->Info.FileLength);
            assert (pHeader->Info.FileLength <= pLog->llFileSize);
        } else {
            pEndOfFile = (LPVOID)((LPBYTE)pEndOfFile + pLog->llFileSize);
        }

        pLastRecord = pLog->pLastRecordRead;
        dwLastRecordIndex = pLog->dwLastRecordRead;

        __try {
            // walk around the file until an access violation occurs or
            // the record is found. If an access violation occurs,
            // we can assume we went off the end of the file and out
            // of the mapped section

                // make sure the record has a valid header
            if (pLog->dwLastRecordRead !=  BINLOG_TYPE_ID_RECORD ?
                    (*(WORD *)pLog->pLastRecordRead == BINLOG_START_WORD) : TRUE) {
                // then it looks OK so continue
                while (pLog->dwLastRecordRead != dwRecordId) {
                    // go to next record
                    pLastRecord = pLog->pLastRecordRead;
                    if (pLog->dwLastRecordRead != BINLOG_TYPE_ID_RECORD) {
                        if (pLog->dwLastRecordRead == BINLOG_HEADER_RECORD) {                   
                            // if the last record was the header, then the next record
                            // is the "first" data , not the first after the header
                            pLog->pLastRecordRead = (LPVOID)((LPBYTE)pLog->lpMappedFileBase +
                                pHeader->Info.FirstRecordOffset);
                        } else {
                            // if the current record is any record other than the header
                            // ...then
                            if (((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength > 0) {
                                // go to the next record in the file
                                pLog->pLastRecordRead = (LPVOID)((LPBYTE)pLog->pLastRecordRead+
                                    ((PPDHI_BINARY_LOG_RECORD_HEADER)
                                    pLog->pLastRecordRead)->dwLength);
                                // test for exceptions here
                                if (pLog->pLastRecordRead >= pEndOfFile) {
                                    // find out if this is a circular log or not
                                    if (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR) {
                                        // test to see if the file has wrapped
                                        if (pHeader->Info.WrapOffset != 0) {
                                            // then wrap to the beginning of the file
                                            pLog->pLastRecordRead = (LPVOID)((LPBYTE)pLog->lpMappedFileBase +
                                                pHeader->Info.FirstDataRecordOffset);
                                        } else {
                                            // the file is still linear so this is the end
                                            pdhStatus = PDH_END_OF_LOG_FILE;
                                        }
                                    } else {
                                        // this is the end of the file
                                        // so reset to the previous pointer
                                        pdhStatus = PDH_END_OF_LOG_FILE;
                                    }
                                } else {
                                    // not at the physical end of the file, but if this is a circular
                                    // log, it could be the logical end of the records so test that
                                    // here
                                    if (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR) {
                                        pLastRecordInLog = (LPVOID)((LPBYTE)pLog->lpMappedFileBase +
                                            pHeader->Info.LastRecordOffset);
                                        pLastRecordInLog = (LPVOID)((LPBYTE)pLastRecordInLog +
                                            ((PPDHI_BINARY_LOG_RECORD_HEADER)pLastRecordInLog)->dwLength);
                                        if (pLog->pLastRecordRead == pLastRecordInLog) {
                                            // then this is the last record in the log
                                            pdhStatus = PDH_END_OF_LOG_FILE;
                                        }
                                    } else {
                                        // nothing to do since this is a normal case
                                    }
                                } // end if / if not end of log file
                            } else {
                                // length is 0 so we've probably run off the end of the log somehow
                                pdhStatus = PDH_END_OF_LOG_FILE;
                            }
                        } // end if /if not header record
                    } else {
                        pLog->pLastRecordRead = (LPBYTE)pLog->pLastRecordRead +
                            pLog->dwRecord1Size;
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        // update pointers & indices
                        pLog->dwLastRecordRead++;
                        dwLastRecordIndex = pLog->dwLastRecordRead;
                    } else {
                        pLog->pLastRecordRead = pLastRecord;
                        break; // out of the while loop
                    }
                }
            } else {
                pdhStatus = PDH_END_OF_LOG_FILE;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pLog->pLastRecordRead = pLastRecord;
            pLog->dwLastRecordRead = dwLastRecordIndex;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // see if we ended up at the right place
        if (pLog->dwLastRecordRead == dwRecordId) {
            if (pRecord != NULL) {
                // then try to copy it
                // if the record ID is 1 then it's the header record so this is
                // a special case record that is actually a CR/LF terminated record
                if (dwRecordId != BINLOG_TYPE_ID_RECORD) {
                    if (((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength <= dwMaxSize) {
                        // then it'll fit so copy it
                        memcpy (pRecord, pLog->pLastRecordRead,
                            ((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength);
                        pdhStatus = ERROR_SUCCESS;
                    } else {
                        // then copy as much as will fit
                        memcpy (pRecord, pLog->pLastRecordRead, dwMaxSize);
                        pdhStatus = PDH_MORE_DATA;
                    }
                } else {
                    // copy the first record and zero terminate it
                    if (pLog->dwRecord1Size <= dwMaxSize) {
                        memcpy (pRecord, pLog->pLastRecordRead,
                            pLog->dwRecord1Size);
                        // null terminate after string
                        ((LPBYTE)pRecord)[pLog->dwRecord1Size - PdhidwRecordTerminatorLength + 1] = 0;
                    } else {
                        memcpy (pRecord, pLog->pLastRecordRead, dwMaxSize);
                        pdhStatus = PDH_MORE_DATA;
                    }
                }
            } else {
                // just return success
                // no buffer was passed, but the record pointer has been
                // positioned
                pdhStatus = ERROR_SUCCESS;
            }
        } else {
            pdhStatus = PDH_END_OF_LOG_FILE;
        }
    }

    return pdhStatus;
}

STATIC_PDH_FUNCTION
PdhiReadOneBinLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  DWORD   dwRecordId,
    IN  LPVOID  pRecord,
    IN  DWORD   dwMaxSize
)
{
    PDH_STATUS  pdhStatus= ERROR_SUCCESS;
    LPVOID      pEndOfFile;
    LPVOID      pLastRecord;
    DWORD       dwLastRecordIndex = 0;
    PPDHI_BINARY_LOG_HEADER_RECORD pHeader = NULL;
    BOOL        bCircular = FALSE;
    DWORD       dwRecordSize;
    DWORD       dwRecordReadSize;
    LONGLONG    llLastFileOffset;
    LPVOID      pTmpBuffer;

    assert (dwRecordId > 0);    // record numbers start at 1

    if (   (LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_BINARY)
        && (dwRecordId == BINLOG_HEADER_RECORD)) {
        // special handling for WMI event trace logfile format
        //
        return PdhiReadWmiHeaderRecord(pLog, pRecord, dwMaxSize);
    }

    if (pLog->iRunidSQL != 0) {
        return PdhiReadBinaryMappedRecord(pLog, dwRecordId, pRecord, dwMaxSize);
    }

    if (pLog->dwLastRecordRead == 0) {
        // then we know no record has been read yet so assign
        // pointer just to be sure
        pLog->pLastRecordRead = NULL;
        pLog->liLastRecordOffset.QuadPart = 0;
        SetFilePointer (pLog->hLogFileHandle, pLog->liLastRecordOffset.LowPart,
            &pLog->liLastRecordOffset.HighPart, FILE_BEGIN);
        if (pLog->liLastRecordOffset.LowPart == INVALID_SET_FILE_POINTER) {
            pdhStatus = GetLastError();
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {

        // map header to local structure (the header data should be mapped into memory
        pHeader = (PPDHI_BINARY_LOG_HEADER_RECORD)RECORD_AT(pLog, pLog->dwRecord1Size);
        assert (*(WORD *)&(pHeader->RecHeader.dwType) == BINLOG_START_WORD);

        if (pHeader->Info.WrapOffset > 0) {
            bCircular = TRUE;
        }

        // "seek" to the desired record 
        if ((dwRecordId < pLog->dwLastRecordRead) || (pLog->dwLastRecordRead == 0)) {
            // rewind if not initialized or the desired record is before this one
            if (dwRecordId >= BINLOG_FIRST_DATA_RECORD) {
                // rewind the file to the first regular record
                pLog->liLastRecordOffset.QuadPart = pHeader->Info.FirstRecordOffset;
                pLog->dwLastRecordRead = BINLOG_FIRST_DATA_RECORD;
            } else {
                // rewind the file to the very start of the file
                pLog->liLastRecordOffset.QuadPart = 0;
                pLog->dwLastRecordRead = 1;
            }
            pLog->liLastRecordOffset.LowPart = SetFilePointer (pLog->hLogFileHandle, pLog->liLastRecordOffset.LowPart,
                &pLog->liLastRecordOffset.HighPart, FILE_BEGIN);

            if (pLog->liLastRecordOffset.LowPart == INVALID_SET_FILE_POINTER) {
                pdhStatus = GetLastError();
            } else {
                if (pLog->pLastRecordRead != NULL) {
                    G_FREE (pLog->pLastRecordRead);
                    pLog->pLastRecordRead = NULL;
                }

                if (pLog->dwLastRecordRead == 1) {
                    // the this is the text ID field
                    dwRecordSize = pLog->dwRecord1Size;
                } else {
                    dwRecordSize = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
                }

                pLog->pLastRecordRead = G_ALLOC (dwRecordSize);
                if (pLog->pLastRecordRead != NULL) {
                    // read in the header (or entire record if the 1st record
                    // otherwise it's a data record
                    if (ReadFile (pLog->hLogFileHandle,
                        pLog->pLastRecordRead,
                        dwRecordSize,
                        &dwRecordReadSize,
                        NULL)) {
                        // then we have the record header or type record so 
                        // complete the operation and read the rest of the record
                        if (pLog->dwLastRecordRead != BINLOG_TYPE_ID_RECORD) {
                            // the Type ID record is of fixed length and has not header record
                            dwRecordSize = ((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength;
                            pTmpBuffer = pLog->pLastRecordRead;
                            pLog->pLastRecordRead = G_REALLOC(pTmpBuffer, dwRecordSize);
                            if (pLog->pLastRecordRead != NULL) {
                                // read in the rest of the record and append it to the header data already read in
                                // otherwise it's a data record
                                pLastRecord = (LPVOID)&((LPBYTE)pLog->pLastRecordRead)[sizeof(PDHI_BINARY_LOG_RECORD_HEADER)];
                                if (ReadFile (pLog->hLogFileHandle,
                                    pLastRecord,
                                    dwRecordSize - sizeof(PDHI_BINARY_LOG_RECORD_HEADER),
                                    &dwRecordReadSize,
                                    NULL)) {
                                    // then we have the record header or type record
                                    pdhStatus = ERROR_SUCCESS;
                                } else {
                                    pdhStatus = GetLastError();
                                }
                            } else {
                                G_FREE(pTmpBuffer);
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                        }
                        pdhStatus = ERROR_SUCCESS;
                    } else {
                        pdhStatus = GetLastError();
                    }
            
                } else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
        }

        // then use the point specified as the end of the file
        // if the log file contians a specified Wrap offset, then use that
        // if not, then if the file length is specified, use that
        // if not, the use the reported file length
        pEndOfFile = (LPVOID)((LPBYTE)pLog->lpMappedFileBase);

        if (pHeader->Info.WrapOffset > 0) {
            pEndOfFile = (LPVOID)((LPBYTE)pEndOfFile + pHeader->Info.WrapOffset);
            assert (pHeader->Info.FileLength >= pHeader->Info.WrapOffset);
        } else if (pHeader->Info.FileLength > 0) {
            pEndOfFile = (LPVOID)((LPBYTE)pEndOfFile + pHeader->Info.FileLength);
            assert (pHeader->Info.FileLength <= pLog->llFileSize);
        } else {
            pEndOfFile = (LPVOID)((LPBYTE)pEndOfFile + pLog->llFileSize);
        }

        dwLastRecordIndex = pLog->dwLastRecordRead;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            // walk around the file until an access violation occurs or
            // the record is found. If an access violation occurs,
            // we can assume we went off the end of the file and out
            // of the mapped section

                // make sure the record has a valid header
            if (pLog->dwLastRecordRead !=  BINLOG_TYPE_ID_RECORD ?
                    (*(WORD *)pLog->pLastRecordRead == BINLOG_START_WORD) : TRUE) {
                // then it looks OK so continue
                while (pLog->dwLastRecordRead != dwRecordId) {
                    // go to next record
                    if (pLog->dwLastRecordRead != BINLOG_TYPE_ID_RECORD) {
                        llLastFileOffset = pLog->liLastRecordOffset.QuadPart;
                        if (pLog->dwLastRecordRead == BINLOG_HEADER_RECORD) {                   
                            // if the last record was the header, then the next record
                            // is the "first" data , not the first after the header
                            // the function returns the new offset
                            pLog->liLastRecordOffset.QuadPart = pHeader->Info.FirstRecordOffset;
                            pLog->liLastRecordOffset.LowPart = SetFilePointer (pLog->hLogFileHandle,
                                pLog->liLastRecordOffset.LowPart,
                                &pLog->liLastRecordOffset.HighPart,
                                FILE_BEGIN);
                        } else {
                            // if the current record is any record other than the header
                            // ...then
                            if (((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength > 0) {
                                // go to the next record in the file
                                pLog->liLastRecordOffset.QuadPart += ((PPDHI_BINARY_LOG_RECORD_HEADER)
                                    pLog->pLastRecordRead)->dwLength;
                                // test for exceptions here
                                if (pLog->liLastRecordOffset.QuadPart >= pLog->llFileSize) {
                                    // find out if this is a circular log or not
                                    if (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR) {
                                        // test to see if the file has wrapped
                                        if (pHeader->Info.WrapOffset != 0) {
                                            // then wrap to the beginning of the file
                                            pLog->liLastRecordOffset.QuadPart = 
                                                pHeader->Info.FirstDataRecordOffset;
                                        } else {
                                            // the file is still linear so this is the end
                                            pdhStatus = PDH_END_OF_LOG_FILE;
                                        }
                                    } else {
                                        // this is the end of the file
                                        // so reset to the previous pointer
                                        pdhStatus = PDH_END_OF_LOG_FILE;
                                    }
                                } else {
                                    // not at the physical end of the file, but if this is a circular
                                    // log, it could be the logical end of the records so test that
                                    // here
                                    if (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR) {
                                        if (llLastFileOffset == pHeader->Info.LastRecordOffset) {
                                            // then this is the last record in the log
                                            pdhStatus = PDH_END_OF_LOG_FILE;
                                        }
                                    } else {
                                        // nothing to do since this is a normal case
                                    }
                                } // end if / if not end of log file
                            } else {
                                // length is 0 so we've probably run off the end of the log somehow
                                pdhStatus = PDH_END_OF_LOG_FILE;
                            }
                            // now go to that record
                            if (pdhStatus == ERROR_SUCCESS) {
                                pLog->liLastRecordOffset.LowPart = SetFilePointer (pLog->hLogFileHandle,
                                    pLog->liLastRecordOffset.LowPart,
                                    &pLog->liLastRecordOffset.HighPart,
                                    FILE_BEGIN);
                            }
                        } // end if /if not header record
                    } else {
                        pLog->liLastRecordOffset.QuadPart = pLog->dwRecord1Size;
                        pLog->liLastRecordOffset.LowPart = SetFilePointer (pLog->hLogFileHandle,
                            pLog->liLastRecordOffset.LowPart,
                            &pLog->liLastRecordOffset.HighPart,
                            FILE_BEGIN);
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        // the last record buffer should not be NULL and it should
                        // be large enough to hold the header
                        if (pLog->pLastRecordRead != NULL) {
                            // read in the header (or entire record if the 1st record
                            // otherwise it's a data record
                            dwRecordSize = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
                            if (ReadFile (pLog->hLogFileHandle,
                                pLog->pLastRecordRead,
                                dwRecordSize,
                                &dwRecordReadSize,
                                NULL)) {
                                // then we have the record header or type record
                                // update pointers & indices
                                pLog->dwLastRecordRead++;
                                pdhStatus = ERROR_SUCCESS;
                            } else {
                                pdhStatus = GetLastError();
                            }
            
                        } else {
                            DebugBreak();
                        }
                    } else {
                        break; // out of the while loop
                    }
                }
            } else {
                pdhStatus = PDH_END_OF_LOG_FILE;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pLog->dwLastRecordRead = dwLastRecordIndex;
        }
    }

    // see if we ended up at the right place
    if ((pdhStatus == ERROR_SUCCESS) && (pLog->dwLastRecordRead == dwRecordId)) {
        if (dwLastRecordIndex != pLog->dwLastRecordRead) {
            // then we've move the file pointer so read the entire data record
            dwRecordSize = ((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength;
            pTmpBuffer = pLog->pLastRecordRead;
            pLog->pLastRecordRead = G_REALLOC(pTmpBuffer, dwRecordSize);
            if (pLog->pLastRecordRead != NULL) {
                // read in the rest of the record and append it to the header data already read in
                // otherwise it's a data record
                pLastRecord = (LPVOID)&((LPBYTE)pLog->pLastRecordRead)[sizeof(PDHI_BINARY_LOG_RECORD_HEADER)];
                if (ReadFile (pLog->hLogFileHandle,
                    pLastRecord,
                    dwRecordSize - sizeof(PDHI_BINARY_LOG_RECORD_HEADER),
                    &dwRecordReadSize,
                    NULL)) {
                    // then we have the record header or type record
                    pdhStatus = ERROR_SUCCESS;
                } else {
                    pdhStatus = GetLastError();
                }
            
            } else {
                G_FREE(pTmpBuffer);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }

        if ((pdhStatus == ERROR_SUCCESS) && (pRecord != NULL)) {
            // then try to copy it
            // if the record ID is 1 then it's the header record so this is
            // a special case record that is actually a CR/LF terminated record
            if (dwRecordId != BINLOG_TYPE_ID_RECORD) {
                if (((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength <= dwMaxSize) {
                    // then it'll fit so copy it
                    RtlCopyMemory(pRecord, pLog->pLastRecordRead,
                        ((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength);
                    pdhStatus = ERROR_SUCCESS;
                } else {
                    // then copy as much as will fit
                    RtlCopyMemory(pRecord, pLog->pLastRecordRead, dwMaxSize);
                    pdhStatus = PDH_MORE_DATA;
                }
            } else {
                // copy the first record and zero terminate it
                if (pLog->dwRecord1Size <= dwMaxSize) {
                    RtlCopyMemory(pRecord, pLog->pLastRecordRead,
                        pLog->dwRecord1Size);
                    // null terminate after string
                    ((LPBYTE)pRecord)[pLog->dwRecord1Size - PdhidwRecordTerminatorLength + 1] = 0;
                } else {
                    RtlCopyMemory(pRecord, pLog->pLastRecordRead, dwMaxSize);
                    pdhStatus = PDH_MORE_DATA;
                }
            }
        } else {
            // just return current status value
            // no buffer was passed, but the record pointer has been
            // positioned
        }
    } else {
        // if successful so far, then return EOF
        if (pdhStatus == ERROR_SUCCESS) pdhStatus = PDH_END_OF_LOG_FILE;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiUpdateBinaryLogFileCatalog (
    IN    PPDHI_LOG        pLog
)
{
    LPVOID      pTempBuffer = NULL;
    LPVOID      pOldBuffer;
    DWORD       dwTempBufferSize;
    BOOL        bWildCardObjects = FALSE;

    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    // the file must be mapped for this to work
    if (pLog->hMappedLogFile == NULL) return PDH_LOG_FILE_OPEN_ERROR;
    // read the header record and enum the machine name from the entries

    if (pLog->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLog->dwMaxRecordSize = 0x010000;
    }

    dwTempBufferSize = pLog->dwMaxRecordSize;
    pTempBuffer =  G_ALLOC (dwTempBufferSize);
    
    if (pTempBuffer == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    // read in the catalog record at the beginning of the file

    while ((pdhStatus = PdhiReadOneBinLogRecord (pLog, BINLOG_HEADER_RECORD,
            pTempBuffer, dwTempBufferSize)) != ERROR_SUCCESS) {
        if (pdhStatus == PDH_MORE_DATA) {
            // read the 1st WORD to see if this is a valid record
            if (*(WORD *)pTempBuffer == BINLOG_START_WORD) {
                // it's a valid record so read the 2nd DWORD to get the
                // record size;
                dwTempBufferSize = ((DWORD *)pTempBuffer)[1];
                if (dwTempBufferSize < pLog->dwMaxRecordSize) {
                    // then something is bogus so return an error
                    pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                    break; // out of while loop
                } else {
                    pLog->dwMaxRecordSize = dwTempBufferSize;
                }
            } else {
                // we're lost in this file
                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                break; // out of while loop
            }
            // realloc a new buffer
            pOldBuffer = pTempBuffer;
            pTempBuffer = G_REALLOC (pOldBuffer, dwTempBufferSize);
            if (pTempBuffer == NULL) {
                // return memory error
                G_FREE(pOldBuffer);
                assert (GetLastError() == ERROR_SUCCESS);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            }
        } else {
            // some other error was returned so
            // return error from read function
            break;
        }
    }

    // if that worked, then examine the catalog record and prepare to scan the file
    if (pdhStatus == ERROR_SUCCESS) {

        PPDHI_BINARY_LOG_HEADER_RECORD  pHeader;
        PPDHI_LOG_COUNTER_PATH          pPath;

        DWORD                   dwBytesProcessed;
        LONG                    nItemCount = 0;
        LPBYTE                  pFirstChar;
        LPWSTR                  szThisMachineName;
        LPWSTR                  szThisObjectName;
        LPWSTR                  szThisInstanceName;
        WCHAR                   szThisMachineObjectName[MAX_PATH];
        LPWSTR                  szThisEntriesName;

        DWORD                   dwRecordLength;
        DWORD                   dwNewBuffer = 0;

        PLOG_BIN_CAT_ENTRY      *ppCatEntryArray = NULL;
        PLOG_BIN_CAT_ENTRY      pThisCatEntry;
        DWORD                   dwCatEntryArrayUsed = 0;
        DWORD                   dwCatEntryArrayAllocated = 0;
        DWORD                   dwThisCatEntry;

        DWORD                   *pLogIndexArray = NULL;
        DWORD                   dwLogIndexArrayUsed = 0;
        DWORD                   dwLogIndexArrayAllocated = 0;
        DWORD                   dwThisIndex;

        DWORD                   dwCurrentEntryOffset;

        // we can assume the record was read successfully so read in the
        // objects that match the machine name and detail level criteria
        dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER)pTempBuffer)->dwLength;

        pPath = (PPDHI_LOG_COUNTER_PATH)
            ((LPBYTE)pTempBuffer + sizeof (PDHI_BINARY_LOG_HEADER_RECORD));
        dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

        while (dwBytesProcessed < dwRecordLength) {
            szThisObjectName = NULL;
            memset (szThisMachineObjectName, 0, sizeof (szThisMachineObjectName));

            pFirstChar = (LPBYTE)&pPath->Buffer[0];

            if (pPath->lMachineNameOffset >= 0L) {
                // then there's a machine name in this record so get
                // it's size
                szThisMachineName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lMachineNameOffset);
                lstrcatW (szThisMachineObjectName, szThisMachineName);
            } else {
                // no machine name so just add the object name
            }
            if (szThisObjectName >= 0) {
                szThisObjectName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lObjectNameOffset);
                lstrcatW (szThisMachineObjectName, cszBackSlash);
                lstrcatW (szThisMachineObjectName, szThisObjectName);
            } else {
                // no object to copy
                // so clear the string and skip to the next item
                memset (szThisMachineObjectName, 0, sizeof (szThisMachineObjectName));
            }

            if (*szThisMachineObjectName != 0) {
                // search the list of machine/object entries and add this if
                // it's not new.
                if (dwCatEntryArrayUsed > 0) {
                    // then there are entries in the array to examine
                    for (dwThisCatEntry = 0; dwThisCatEntry < dwCatEntryArrayUsed; dwThisCatEntry++) {
                        szThisEntriesName = (LPWSTR)((LPBYTE)(&ppCatEntryArray[dwThisCatEntry]->bcRec.CatEntry) +
                            ppCatEntryArray[dwThisCatEntry]->bcRec.CatEntry.dwMachineObjNameOffset);
                        if (lstrcmpiW (szThisEntriesName, szThisMachineObjectName) == 0) {
                            // match found so no need to add it
                            break;
                        }
                    }
                }  else {
                    dwThisCatEntry = 0;
                }

                if (dwThisCatEntry == dwCatEntryArrayUsed) {
                    dwCatEntryArrayUsed++;
                    // this machine/object was not found so allocate a new one
                    if (dwCatEntryArrayUsed > dwCatEntryArrayAllocated) {
                        // extend the array
                        dwCatEntryArrayAllocated += 256; // for starters
                        if (ppCatEntryArray == NULL) {
                            // then initialize a new one
                            ppCatEntryArray = G_ALLOC (
                                dwCatEntryArrayAllocated * sizeof(PLOG_BIN_CAT_RECORD));
                        } else {
                            // extend it
                            pOldBuffer = ppCatEntryArray;
                            ppCatEntryArray = G_REALLOC(pOldBuffer,
                                dwCatEntryArrayAllocated * sizeof(PLOG_BIN_CAT_RECORD));
                        }
                        if (ppCatEntryArray == NULL) {
                            G_FREE(pOldBuffer);
                            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        assert (dwThisCatEntry == (dwCatEntryArrayUsed - 1));
                        // initialize the entry
                        // allocate the record buffer
                        ppCatEntryArray[dwCatEntryArrayUsed-1] = G_ALLOC(LARGE_BUFFER_SIZE);
                        if (ppCatEntryArray[dwCatEntryArrayUsed-1] == NULL) {
                            assert (GetLastError() == ERROR_SUCCESS);
                            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            break; // break out of loop since we can't allocate any memory
                        } else {
                            pThisCatEntry = ppCatEntryArray[dwCatEntryArrayUsed-1];
                            pThisCatEntry->dwEntrySize = (DWORD)G_SIZE(pThisCatEntry);
                            // initialize the fields of the new structure
                            // start with the record header
                            pThisCatEntry->bcRec.RecHeader.dwType = BINLOG_TYPE_CATALOG_ITEM;
                            // this field will be filled in when the list is completed
                            pThisCatEntry->bcRec.RecHeader.dwLength =0;
                            // now initialize the catalog entry record
                            // offsets are from the start address of the catalog entry record
                            pThisCatEntry->bcRec.CatEntry.dwMachineObjNameOffset =
                                sizeof (PDHI_LOG_CAT_ENTRY);
                            assert ((LONG)pThisCatEntry->bcRec.CatEntry.dwMachineObjNameOffset ==
                                (LONG)((LPBYTE)&pThisCatEntry->bcRec.dwEntryRecBuff[0] -
                                 (LPBYTE)&pThisCatEntry->bcRec.CatEntry));
                            // now copy the machine/object string to the buffer
                            lstrcpyW ((LPWSTR)((LPBYTE)&pThisCatEntry->bcRec.CatEntry +
                                pThisCatEntry->bcRec.CatEntry.dwMachineObjNameOffset),
                                szThisMachineObjectName);
                            // the instance string list will follow the machine name
                            pThisCatEntry->bcRec.CatEntry.dwInstanceStringOffset =
                                pThisCatEntry->bcRec.CatEntry.dwMachineObjNameOffset +
                                ((lstrlenW (szThisMachineObjectName) + 1) * sizeof(WCHAR));
                            // finish off by initializing the offsets
                            // this offset is from the start of the Cat Entry NOT the
                            // cat data record.
                            pThisCatEntry->dwOffsetToNextInstance =
                                // offset to cat entry structure
                                (DWORD)((LPBYTE)(&pThisCatEntry->bcRec.CatEntry) -
                                        (LPBYTE)(pThisCatEntry));
                                // offset from there to the instance string list
                            pThisCatEntry->dwOffsetToNextInstance +=
                                pThisCatEntry->bcRec.CatEntry.dwInstanceStringOffset;
                            assert (pThisCatEntry->dwOffsetToNextInstance <
                                pThisCatEntry->dwEntrySize);
                        }
                    } else {
                        // error encountered so break from loop
                        break;
                    }
                } else {
                    // already in the list so go continue
                }
                // pThisCatEntry = pointer to the matching structure so
                // add it to the index of counter path items if it has
                // a wild card instance
                dwLogIndexArrayUsed++;
                if (dwLogIndexArrayUsed > dwLogIndexArrayAllocated) {
                    // extend the array
                    dwLogIndexArrayAllocated += 256; // for starters
                    if (pLogIndexArray == NULL) {
                        // then initialize a new one
                        pLogIndexArray = G_ALLOC (
                            dwLogIndexArrayAllocated * sizeof(DWORD));
                    } else {
                        // extend it
                        pOldBuffer = pLogIndexArray;
                        pLogIndexArray = G_REALLOC (pOldBuffer,
                            dwLogIndexArrayAllocated * sizeof(DWORD));
                        if (pLogIndexArray == NULL) {
                            G_FREE(pOldBuffer);
                        }
                    }
                    if (pLogIndexArray == NULL) {
                        assert (GetLastError() == ERROR_SUCCESS);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        break; // break out of loop since we can't allocate any memory
                    }
                }
                if (pPath->lInstanceOffset >= 0) {
                    szThisInstanceName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lInstanceOffset);
                    if (*szThisInstanceName == SPLAT_L) {
                        // then this is a wild card instance so save it
                        pLogIndexArray[dwLogIndexArrayUsed-1] = dwThisCatEntry;
                        bWildCardObjects = TRUE;    // there's at least 1 item to scan from the file
                    } else {
                        // this is not a wildcard instance so no instance list
                        // entry is necessary
                        pLogIndexArray[dwLogIndexArrayUsed-1] = (DWORD)-1;
                    }
                } else {
                    // this object doesn't have instances
                    szThisInstanceName = NULL;
                    pLogIndexArray[dwLogIndexArrayUsed-1] = (DWORD)-1;
                }
            } else {
                // no machine or object name to look up
            }
            // get next path entry from log file record
            dwBytesProcessed += pPath->dwLength;
            pPath = (PPDHI_LOG_COUNTER_PATH)
                ((LPBYTE)pPath + pPath->dwLength);
        }

        // If everything is OK so far, fill in the list(s) of instances

        if ((pdhStatus == ERROR_SUCCESS) && (ppCatEntryArray != NULL) && (bWildCardObjects)) {
            PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
            PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;

            PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;
            PPDHI_RAW_COUNTER_ITEM          pDataItem;

            DWORD                   dwThisRecordIndex;
            DWORD                   dwDataItemIndex;
            DWORD                   dwSize;
            DWORD                   dwLowSize, dwHighSize;
            LONGLONG                llEndOfFileOffset;
            DWORD                   dwLowPos, dwHighPos;
            DWORD                   dwBytesWritten;

            // run through the log file and add the instances to the appropriate list
            // look up individual instances in log...
            // read records from file and store instances

            dwThisRecordIndex = BINLOG_FIRST_DATA_RECORD;

            // this call just moves the record pointer
            pdhStatus = PdhiReadOneBinLogRecord (
                    pLog, dwThisRecordIndex, NULL, 0);

            while (pdhStatus == ERROR_SUCCESS) {
                pThisMasterRecord =
                    (PPDHI_BINARY_LOG_RECORD_HEADER)
                        pLog->pLastRecordRead;
                // make sure we haven't left the file
                assert (pThisMasterRecord != NULL);
                assert ((LPBYTE)pThisMasterRecord >
                        (LPBYTE)pLog->lpMappedFileBase);
                assert ((LPBYTE)pThisMasterRecord <
                        ((LPBYTE)pLog->lpMappedFileBase +
                         pLog->llFileSize));

                // examine each entry in the record
                // sub records start with index 1
                for (dwThisIndex = 1; dwThisIndex <= dwLogIndexArrayUsed; dwThisIndex++) {

                    pThisSubRecord = PdhiGetSubRecord (
                        pThisMasterRecord, dwThisIndex);

                    assert (pThisSubRecord != NULL); // this would imply a bad log file

                    // only do multi entries
                    if ((pThisSubRecord != NULL) &&
                        (pThisSubRecord->dwType == BINLOG_TYPE_DATA_MULTI)) {
                        // if this is a multi-counter, then this should have an entry
                        assert (pLogIndexArray[dwThisIndex] != (DWORD)-1);

                        // the array index is 0 based while the records are 1 based
                        // so adjust index value here
                        pThisCatEntry = ppCatEntryArray[pLogIndexArray[dwThisIndex-1]];

                        assert (pThisCatEntry != NULL); // make sure this is a valid entry

                        pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK)
                            ((LPBYTE)pThisSubRecord +
                            sizeof (PDHI_BINARY_LOG_RECORD_HEADER));

                        // walk down list of entries and add them to the
                        // list of instances (these should already
                        // be assembled in parent/instance format)

                        for (dwDataItemIndex = 0;
                             dwDataItemIndex < pDataBlock->dwItemCount;
                             dwDataItemIndex++) {

                            pDataItem = &pDataBlock->pItemArray[dwDataItemIndex];

                            szThisInstanceName = (LPWSTR)
                                (((LPBYTE) pDataBlock) + pDataItem->szName);

                            dwNewBuffer = lstrlenW (szThisInstanceName) + 1;
                            dwNewBuffer *= sizeof (WCHAR);

                            if ((pThisCatEntry->dwOffsetToNextInstance + dwNewBuffer) >=
                                pThisCatEntry->dwEntrySize) {
                                // grow the buffer
                                dwSize = pThisCatEntry->dwEntrySize + LARGE_BUFFER_SIZE;
                                pOldBuffer = pThisCatEntry;
                                pThisCatEntry = G_REALLOC (pOldBuffer, dwSize);
                                if (pThisCatEntry != NULL) {
                                    // update array
                                    ppCatEntryArray[pLogIndexArray[dwThisIndex-1]] = pThisCatEntry;
                                    pThisCatEntry->dwEntrySize = dwSize;
                                } else {
                                    // skip & try the next one
                                    G_FREE(pOldBuffer);
                                    continue;
                                }
                            }

                            // copy string to the buffer
                            dwNewBuffer = AddUniqueWideStringToMultiSz (
                                (LPVOID)((LPBYTE)&pThisCatEntry->bcRec.CatEntry + pThisCatEntry->bcRec.CatEntry.dwInstanceStringOffset),
                                szThisInstanceName,
                                TRUE);

                            // if the string was added to the list, then
                            //  dwNewBuffer is the size of the resulting MSZ
                            //  in characters not including the double NULL
                            //  terminating the MSZ
                            // if no string was added, then it is 0
                            if (dwNewBuffer > 0) {
                                // string was added so update size used.
                                // this is the new size of the MSZ instance list
                                pThisCatEntry->dwOffsetToNextInstance = dwNewBuffer * sizeof (WCHAR);
                                // + the offset of the istance list from the start of the Cat entry
                                pThisCatEntry->dwOffsetToNextInstance +=
                                    pThisCatEntry->bcRec.CatEntry.dwInstanceStringOffset;
                                // + the start of the cat entry from the main structure start
                                pThisCatEntry->dwOffsetToNextInstance +=
                                    (DWORD)((DWORD_PTR)&pThisCatEntry->bcRec.CatEntry -
                                     (DWORD_PTR)pThisCatEntry);
                                nItemCount++;
                            } else {
                                // nothing added so nothing to do
                            }
                        } // end for each istance entry in the array counter
                    } else {
                        // this is not an array counter
                    }
                } // end for each item in this record

                // go to next record in log file
                pdhStatus = PdhiReadOneBinLogRecord (
                        pLog, ++dwThisRecordIndex, NULL, 0);

            } // end while not end of file

            if (pdhStatus == PDH_END_OF_LOG_FILE) {
                // this is good so fix the status
                pdhStatus = ERROR_SUCCESS;
            }

            // update the length fields of the various records
            dwCurrentEntryOffset = 0;
            for (dwThisIndex = 0; dwThisIndex < dwCatEntryArrayUsed; dwThisIndex++) {
                pThisCatEntry = ppCatEntryArray[dwThisIndex];
                // update the record size of the overall record
                pThisCatEntry->bcRec.RecHeader.dwLength =
                    (pThisCatEntry->dwOffsetToNextInstance + sizeof(WCHAR)) // to include MSZ term null
                    // now subtract offset to record struct in
                    // containing structure
                    - (DWORD)((DWORD_PTR)(&pThisCatEntry->bcRec) -
                       (DWORD_PTR)(pThisCatEntry));
                // update the size of this catalog entry
                pThisCatEntry->bcRec.CatEntry.dwEntrySize =
                    (pThisCatEntry->dwOffsetToNextInstance + sizeof(WCHAR)) // to include MSZ term null
                    // now subtract offset to record struct in
                    // containing structure
                    - (DWORD)((DWORD_PTR)(&pThisCatEntry->bcRec.CatEntry) -
                       (DWORD_PTR)(pThisCatEntry));
                // update the size of the MSZ instance list string
                pThisCatEntry->bcRec.CatEntry.dwStringSize =
                    // size of the entry...
                    pThisCatEntry->bcRec.CatEntry.dwEntrySize
                    // - the offset to the start of the string
                    - pThisCatEntry->bcRec.CatEntry.dwInstanceStringOffset;
                // only entries with strings will be written to the
                // file so only they will have offsets
                if (pThisCatEntry->bcRec.CatEntry.dwStringSize > sizeof(DWORD)) {
                    pThisCatEntry->dwEntryOffset = dwCurrentEntryOffset;
                    dwCurrentEntryOffset += pThisCatEntry->bcRec.RecHeader.dwLength;
                } else {
                    pThisCatEntry->dwEntryOffset = 0;
                }

#if _DBG
                swprintf (szThisMachineObjectName, (LPCWSTR)L"\nEntry %d: Offset: %d, Rec Len: %d String Len: %d",
                    dwThisIndex,
                    pThisCatEntry->dwEntryOffset,
                    pThisCatEntry->bcRec.RecHeader.dwLength,
                    pThisCatEntry->bcRec.CatEntry.dwStringSize );
                OutputDebugStringW (szThisMachineObjectName);
#endif
            }

#if _DBG
            swprintf (szThisMachineObjectName, (LPCWSTR)L"\nCatalog Size: %d",
                dwCurrentEntryOffset);
            OutputDebugStringW (szThisMachineObjectName);
#endif

            // see if the end of file is defined as something other
            // then the physical end of the file (e.g. the last record
            // in a circular log file
            pHeader = (PPDHI_BINARY_LOG_HEADER_RECORD)
                ((LPBYTE)(pLog->lpMappedFileBase) + pLog->dwRecord1Size);

            assert (*(WORD *)&(pHeader->RecHeader.dwType) == BINLOG_START_WORD);

            // use the greater of Wrap offset or Next Offset
            llEndOfFileOffset = pHeader->Info.WrapOffset;
            if (pHeader->Info.NextRecordOffset > llEndOfFileOffset) {
                llEndOfFileOffset = pHeader->Info.NextRecordOffset;
            }
            // if neither is defined, then use the physical end of file
            if (llEndOfFileOffset == 0) {
                dwLowSize = GetFileSize (pLog->hLogFileHandle, &dwHighSize);
                assert (dwLowSize != 0xFFFFFFFF);
            } else {
                dwLowSize = LODWORD(llEndOfFileOffset);
                dwHighSize = HIDWORD(llEndOfFileOffset);
            }

            // now get ready to update the log file.
            // 1st unmap the view of the file so we can update it
            if (!UnmapViewOfFile(pLog->lpMappedFileBase)) {
                pdhStatus = GetLastError();
            } else {
                pLog->lpMappedFileBase = NULL;
                pLog->pLastRecordRead = NULL;
                CloseHandle (pLog->hMappedLogFile);
                pLog->hMappedLogFile = NULL;
            }
            assert (pdhStatus == ERROR_SUCCESS);

            // lock the file while we fiddle with it
            if (!LockFile (pLog->hLogFileHandle,0,0,dwLowSize, dwHighSize)) {
                pdhStatus = GetLastError ();
            }
            assert (pdhStatus == ERROR_SUCCESS);

            // 3rd move to the end of the file
            dwLowPos = dwLowSize;
            dwHighPos = dwHighSize;
            dwLowPos = SetFilePointer (pLog->hLogFileHandle, dwLowPos, (LONG *)&dwHighPos, FILE_BEGIN);
            if (dwLowPos == 0xFFFFFFFF) {
                pdhStatus = GetLastError ();
            }
            assert (pdhStatus == ERROR_SUCCESS);
            assert (dwLowPos == dwLowSize);
            assert (dwHighPos == dwHighSize);

            // 4th write the new catalog records
            for (dwThisIndex = 0; dwThisIndex < dwCatEntryArrayUsed; dwThisIndex++) {
                pThisCatEntry = ppCatEntryArray[dwThisIndex];
                if (pThisCatEntry->bcRec.CatEntry.dwStringSize > sizeof (DWORD)) {
                    // then this entry has something to write
                    pdhStatus = PdhiWriteOneBinaryLogRecord (
                        pLog,
                        (LPCVOID)&pThisCatEntry->bcRec,
                        pThisCatEntry->bcRec.RecHeader.dwLength,
                        &dwBytesWritten,
                        0);
                    if (pdhStatus == ERROR_SUCCESS) {
                        // operation succeeded
                        assert (dwBytesWritten == pThisCatEntry->bcRec.RecHeader.dwLength);
                    }
                } else {
                    // this record does not need to be written
                }
            } // end for each machine/object in this log

            // truncate the file here since this must be at the
            // end
            if (!SetEndOfFile (pLog->hLogFileHandle)) {
                pdhStatus = GetLastError();
            }

            // 5th re-map the file to include the new catalog sections
            pdhStatus = PdhiOpenUpdateBinaryLog (pLog);
            assert (pdhStatus == ERROR_SUCCESS);

            // 6th update the catalog entries in the header
            pdhStatus = PdhiReadOneBinLogRecord (pLog, BINLOG_HEADER_RECORD,
                pTempBuffer, dwTempBufferSize);
            assert (pdhStatus == ERROR_SUCCESS);

            // we can assume the record was read successfully so read in the
            // objects that match the machine name and detail level criteria
            dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER)pTempBuffer)->dwLength;
            // the following will update the temp buffer, when
            // everything is finished, we'll copy this back to the
            // mapped file.
            //
            // enter the location of the Catalog
            ((PPDHI_BINARY_LOG_HEADER_RECORD)pTempBuffer)->Info.CatalogOffset =
                (LONGLONG)(dwLowPos + (dwHighPos << 32));
            // update the catalog time
            GetSystemTimeAsFileTime (
                (FILETIME *)&((PPDHI_BINARY_LOG_HEADER_RECORD)pTempBuffer)->Info.CatalogDate);
            // update the log file update time
            ((PPDHI_BINARY_LOG_HEADER_RECORD)pTempBuffer)->Info.LastUpdateTime =
                ((PPDHI_BINARY_LOG_HEADER_RECORD)pTempBuffer)->Info.CatalogDate;
            // go through each counter path item and insert the catalog offset
            // as appropriate (i.e. only to wild card path entries
            pPath = (PPDHI_LOG_COUNTER_PATH)
                ((LPBYTE)pTempBuffer + sizeof (PDHI_BINARY_LOG_HEADER_RECORD));
            dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);
            dwThisIndex = 0; // this counter entry index
            while (dwBytesProcessed < dwRecordLength) {
            // get next path entry from log file record
                if (pLogIndexArray[dwThisIndex] != (DWORD)-1) {
                    // make sure we're not going to step on anything
                    assert (pPath->lMachineNameOffset > 0);
                    // then this item has an extended catalog entry
                    // so load the offset into the catalog here
                    *((LPDWORD)&pPath->Buffer[0]) =
                        ppCatEntryArray[pLogIndexArray[dwThisIndex]]->dwEntryOffset;
                } else {
                    // skip this and go to the next one
                }
                dwThisIndex++;
                dwBytesProcessed += pPath->dwLength;
                pPath = (PPDHI_LOG_COUNTER_PATH)
                    ((LPBYTE)pPath + pPath->dwLength);
            }
            assert (dwThisIndex == dwLogIndexArrayUsed);
            // write the changes to the file
            RtlCopyMemory(pLog->pLastRecordRead, pTempBuffer, dwRecordLength);
            // write changes to disk
            if (!FlushViewOfFile (pLog->lpMappedFileBase, 0)) {
                pdhStatus = GetLastError();
            }
            assert (pdhStatus == ERROR_SUCCESS);

            // unlock the file
            if (!UnlockFile (pLog->hLogFileHandle, 0, 0, dwLowSize, dwHighSize)) {
                pdhStatus = GetLastError();
            }
            // done

            // check the index entries...
            for (dwThisIndex = 0; dwThisIndex < dwCatEntryArrayUsed; dwThisIndex++) {
                pThisCatEntry = ppCatEntryArray[dwThisIndex];
                // free the cat entry
                G_FREE (pThisCatEntry);
                ppCatEntryArray[dwThisIndex] = NULL;
            }
        } else {
            // then there's nothing to list
        }

        if (pLogIndexArray != NULL) G_FREE(pLogIndexArray);
        if (ppCatEntryArray != NULL) G_FREE(ppCatEntryArray);
   }

   if (pTempBuffer != NULL) G_FREE (pTempBuffer);

   return pdhStatus;
}

PDH_FUNCTION
PdhiGetBinaryLogCounterInfo (
    IN  PPDHI_LOG       pLog,
    IN  PPDHI_COUNTER   pCounter
)
{
    PDH_STATUS  pdhStatus;
    DWORD       dwIndex;
    DWORD       dwPrevious = pCounter->dwIndex;
    PPDHI_COUNTER_PATH  pTempPath = NULL;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
    PPDHI_LOG_COUNTER_PATH          pPath;
    DWORD       dwBufferSize;
    DWORD       dwRecordLength;
    DWORD       dwBytesProcessed;
    LPBYTE      pFirstChar;
    LPWSTR      szThisMachineName;
    LPWSTR      szThisObjectName;
    LPWSTR      szThisCounterName;
    LPWSTR      szThisInstanceName;
    LPWSTR      szThisParentName;
    BOOL        bCheckThisObject = FALSE;
    DWORD       dwTmpIndex;

    // crack the path in to components

    pTempPath = G_ALLOC (LARGE_BUFFER_SIZE);

    if (pTempPath == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    dwBufferSize = (DWORD)G_SIZE(pTempPath);


    if (ParseFullPathNameW (pCounter->szFullName, &dwBufferSize, pTempPath, FALSE)) {
        // read the header record to find the matching entry

        pdhStatus = PdhiReadOneBinLogRecord (
            pLog,
            BINLOG_HEADER_RECORD,
            NULL, 0);

        if (pdhStatus == ERROR_SUCCESS) {
            pThisMasterRecord =
                (PPDHI_BINARY_LOG_RECORD_HEADER) pLog->pLastRecordRead;

            dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER)pThisMasterRecord)->dwLength;

            pPath = (PPDHI_LOG_COUNTER_PATH)
                ((LPBYTE)pThisMasterRecord + sizeof (PDHI_BINARY_LOG_HEADER_RECORD));

            dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);
            dwIndex = 0;
            pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
            dwTmpIndex = 0;

            while (dwBytesProcessed < dwRecordLength) {
                // go through catalog to find a match

                dwIndex++;

                pFirstChar = (LPBYTE)&pPath->Buffer[0];
                if (dwPrevious != 0 && dwPrevious >= dwIndex) {
                    bCheckThisObject = FALSE;
                }
                else if (pPath->lMachineNameOffset >= 0L) {
                    // then there's a machine name in this record so get
                    // it's size
                    szThisMachineName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lMachineNameOffset);

                    // if this is for the desired machine, then select the object

                    if (lstrcmpiW(szThisMachineName, pTempPath->szMachineName) == 0) {
                        szThisObjectName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lObjectNameOffset);
                        if (lstrcmpiW(szThisObjectName, pTempPath->szObjectName) == 0) {
                            // then this is the object to look up
                            bCheckThisObject = TRUE;
                        } else {
                            // not this object
                            szThisObjectName = NULL;
                        }
                    } else {
                        // this machine isn't selected
                    }
                } else {
                    // there's no machine specified so for this counter so list it by default
                    if (pPath->lObjectNameOffset >= 0) {
                        szThisObjectName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lObjectNameOffset);
                        if (lstrcmpiW(szThisObjectName,pTempPath->szObjectName) == 0) {
                            // then this is the object to look up
                            bCheckThisObject = TRUE;
                        } else {
                            // not this object
                            szThisObjectName = NULL;
                        }
                    } else {
                        // no object to copy
                        szThisObjectName = NULL;
                    }
                }

                if (bCheckThisObject) {
                    szThisCounterName = (LPWSTR)((LPBYTE)pFirstChar +
                        pPath->lCounterOffset);
                    if (* szThisCounterName == SPLAT_L) {
                        if (pPath->dwFlags & PDHIC_COUNTER_OBJECT) {
                            pdhStatus = PdhiGetWmiLogCounterInfo(pLog, pCounter);
                            pCounter->dwIndex = dwIndex;
                            break;
                        }
                        else {
                            // pPath->dwFlags & PDHIC_COUNTER_BLOCK
                            // this is logged counter object. Since all couter
                            // objects from the same machine are from the same
                            // datablock, dwIndex might be incorrect
                            //
                            DWORD dwTemp = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);
                            PPDHI_LOG_COUNTER_PATH pLPath = (PPDHI_LOG_COUNTER_PATH)
                                    ((LPBYTE) pThisMasterRecord + dwTemp);
                            DWORD dwLIndex = 0;
                            LPBYTE pLChar;
                            LPWSTR szMachine;

                            pdhStatus = PdhiGetWmiLogCounterInfo(pLog, pCounter);
                            while (dwTemp < dwRecordLength) {
                                dwLIndex ++;

                                if (dwPrevious == 0 || dwPrevious < dwLIndex) {
                                    pLChar = (LPBYTE)&pLPath->Buffer[0];
                                    if (pLPath->lMachineNameOffset >= 0L) {
                                        szMachine = (LPWSTR) ((LPBYTE)pLChar
                                                  + pLPath->lMachineNameOffset);
                                        if (lstrcmpiW(szMachine,
                                                  pTempPath->szMachineName) == 0) {
                                            if (pLPath->dwFlags &
                                                        PDHIC_COUNTER_BLOCK) {
                                                break;
                                            }
                                        }
                                    }
                                    else if (pLPath->dwFlags & PDHIC_COUNTER_BLOCK) {
                                        break;
                                    }
                                }

                                dwTemp += pLPath->dwLength;
                                pLPath = (PPDHI_LOG_COUNTER_PATH)
                                         ((LPBYTE) pThisMasterRecord + dwTemp);
                            }
                            if (dwTemp >= dwRecordLength) {
                                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                            }
                            else {
                                pCounter->dwIndex = dwLIndex;
                            }
                        }
                    }
                    else if (lstrcmpiW(szThisCounterName, pTempPath->szCounterName) == 0) {
                        // check instance name
                        // get the instance name from this counter and add it to the list
                        if (pPath->lInstanceOffset >= 0) {
                            szThisInstanceName = (LPWSTR)((LPBYTE)pFirstChar +
                            pPath->lInstanceOffset);

                            if (*szThisInstanceName != SPLAT_L) {
                                if (pPath->lParentOffset >= 0) {
                                    szThisParentName = (LPWSTR)((LPBYTE)pFirstChar +
                                        pPath->lParentOffset);

                                    if (lstrcmpiW(szThisParentName, pTempPath->szParentName) != 0) {
                                        // wrong parent
                                        bCheckThisObject = FALSE;
                                    }
                                }

                                if (lstrcmpiW(szThisInstanceName, pTempPath->szInstanceName) != 0) {
                                    // wrong instance
                                    bCheckThisObject = FALSE;
                                }

                                if (pTempPath->dwIndex > 0) {
                                    if (pPath->dwIndex == pTempPath->dwIndex) {
                                        bCheckThisObject = TRUE;
                                    }
                                    else if (pPath->dwIndex == 0) {
                                        if (dwTmpIndex == pTempPath->dwIndex) {
                                            bCheckThisObject = TRUE;
                                        }
                                        else {
                                            dwTmpIndex ++;
                                            bCheckThisObject = FALSE;
                                        }
                                    }
                                    else {
                                        // wrong index
                                        bCheckThisObject = FALSE;
                                    }
                                }
                                else if (   pPath->dwIndex != 0
                                         && LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_BINARY) {
                                    bCheckThisObject = FALSE;
                                }
                            } else {
                                // this is a wild card spec
                                // so assume it's valid since that's
                                // faster than reading the file each time.
                                // if the instance DOESN't exist in this
                                // file then the appropriate status will
                                // be returned in each query.
                            }
                        } else {
                            // there is no instance name to compare
                            // so assume it's OK
                        }
                        if (bCheckThisObject) {
                            // fill in the data and return
                            // this data is NOT used by the log file reader
                            pCounter->plCounterInfo.dwObjectId = 0;
                            pCounter->plCounterInfo.lInstanceId = 0;
                            if (pPath->lInstanceOffset >= 0) {
                                pCounter->plCounterInfo.szInstanceName =
                                    pCounter->pCounterPath->szInstanceName;
                                pCounter->plCounterInfo.dwParentObjectId = 0;
                                pCounter->plCounterInfo.szParentInstanceName =
                                    pCounter->pCounterPath->szParentName;
                            } else {
                                pCounter->plCounterInfo.szInstanceName = NULL;
                                pCounter->plCounterInfo.dwParentObjectId = 0;
                                pCounter->plCounterInfo.szParentInstanceName = NULL;
                            }
                            //define as multi instance if necessary
                            // if the user is passing in a "*" character
                            if (pCounter->plCounterInfo.szInstanceName != NULL) {
                                if (*pCounter->plCounterInfo.szInstanceName == SPLAT_L) {
                                    pCounter->dwFlags |= PDHIC_MULTI_INSTANCE;
                                }
                            }
                            // this data is used by the log file readers
                            pCounter->plCounterInfo.dwCounterId = dwIndex; // entry in log
                            pCounter->plCounterInfo.dwCounterType = pPath->dwCounterType;
                            pCounter->plCounterInfo.dwCounterSize =
                                pPath->dwCounterType & PERF_SIZE_LARGE ?
                                    sizeof (LONGLONG) : sizeof(DWORD);
                            pCounter->plCounterInfo.lDefaultScale = pPath->lDefaultScale;
                            pCounter->TimeBase = pPath->llTimeBase;
                            pCounter->dwIndex  = dwIndex;
                            pdhStatus = ERROR_SUCCESS;

                            break;
                        }
                    }

                } else {
                    // we aren't interested in this so just ignore it
                }

                // get next path entry from log file record
                dwBytesProcessed += pPath->dwLength;
                pPath = (PPDHI_LOG_COUNTER_PATH)
                    ((LPBYTE)pPath + pPath->dwLength);
            } // end while searching the catalog entries
        } else {
            // unable to find desired record so return status
        }
    } else {
        // unable to read the path
        pdhStatus = PDH_INVALID_PATH;
    }

    if (pTempPath != NULL) G_FREE (pTempPath);

    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenInputBinaryLog (
    IN  PPDHI_LOG   pLog
)
{
    PDH_STATUS  pdhStatus;

    PPDHI_BINARY_LOG_HEADER_RECORD pHeader;

    pLog->StreamFile = (FILE *)((DWORD_PTR)(-1));

    // map file header as a memory array for reading

    assert (pLog->hMappedLogFile != NULL);  // should be open!

    if ((pLog->hMappedLogFile != NULL) && (pLog->lpMappedFileBase != NULL)) {
        // save size of binary log record header
        pLog->dwRecord1Size = dwFileHeaderLength +  // ID characters
            2 +                                     // quotations
            PdhidwRecordTerminatorLength;               // CR/LF terminator
        pLog->dwRecord1Size = QWORD_MULTIPLE(pLog->dwRecord1Size);

        // read the header and get the option flags
        pHeader = (PPDHI_BINARY_LOG_HEADER_RECORD)
            ((LPBYTE)(pLog->lpMappedFileBase) + pLog->dwRecord1Size);

        assert (*(WORD *)&(pHeader->RecHeader.dwType) == BINLOG_START_WORD);

        pLog->dwLogFormat |= pHeader->Info.dwFlags;

        pdhStatus = ERROR_SUCCESS;
    } else {
        // return PDH Error
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
    }

    pdhStatus = ERROR_SUCCESS;

    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenUpdateBinaryLog (
    IN  PPDHI_LOG   pLog
)
{
    PDH_STATUS  pdhStatus;
    LONG        lWin32Status;

    PPDHI_BINARY_LOG_HEADER_RECORD pHeader;

    pLog->StreamFile = (FILE *)((DWORD_PTR)(-1));

    // map file header as a memory array for reading

    assert (pLog->hMappedLogFile != NULL);  // should be open!

    if ((pLog->hMappedLogFile != NULL) && (pLog->lpMappedFileBase != NULL)) {
        // save size of binary log record header
        pLog->dwRecord1Size = dwFileHeaderLength +  // ID characters
            2 +                                     // quotations
            PdhidwRecordTerminatorLength;               // CR/LF terminator
        pLog->dwRecord1Size = QWORD_MULTIPLE(pLog->dwRecord1Size);

        // read the header and get the option flags
        pHeader = (PPDHI_BINARY_LOG_HEADER_RECORD)
            ((LPBYTE)(pLog->lpMappedFileBase) + pLog->dwRecord1Size);

        assert (*(WORD *)&(pHeader->RecHeader.dwType) == BINLOG_START_WORD);

        pLog->dwLogFormat |= pHeader->Info.dwFlags;

        pdhStatus = ERROR_SUCCESS;
    } else {
        // return PDH Error
        lWin32Status = GetLastError();
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
    }

    pdhStatus = ERROR_SUCCESS;

    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenOutputBinaryLog (
    IN  PPDHI_LOG   pLog
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    if (pLog->llMaxSize > 0) {
        // this is a circular or limited linear log file so:
        // 1) allocate a file of the desired size,
        pLog->hMappedLogFile = CreateFileMappingW (
            pLog->hLogFileHandle,
            NULL,
            PAGE_READWRITE,
            HIDWORD(pLog->llMaxSize),
            LODWORD(pLog->llMaxSize),
            NULL);

        if (pLog->hMappedLogFile != NULL) {
            // 2) map it as a memory section
            pLog->lpMappedFileBase = MapViewOfFile (
                pLog->hMappedLogFile,
                FILE_MAP_WRITE, 0, 0,
                LODWORD(pLog->llMaxSize));
            if (pLog->lpMappedFileBase == NULL) {
                // close the file mapping and return error
                pdhStatus = GetLastError();
                CloseHandle (pLog->hMappedLogFile);
                pLog->hMappedLogFile = NULL;
            }
        } else {
            pdhStatus = GetLastError();
            pLog->hMappedLogFile = NULL;
        }
    } else {
        // this is just a sequential access file where each record will
        // be appended to the last one
        pLog->StreamFile = (FILE *)((DWORD_PTR)(-1));
        pdhStatus = ERROR_SUCCESS;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiCloseBinaryLog (
    IN  PPDHI_LOG   pLog,
    IN    DWORD        dwFlags
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    BOOL        bStatus;
    LONGLONG    llEndOfFile = 0;
    PPDHI_BINARY_LOG_HEADER_RECORD pHeader;
    BOOL        bNeedToCloseHandles = FALSE;

    UNREFERENCED_PARAMETER (dwFlags);

    // if open for reading, then the file is also mapped as a memory section
    if (pLog->lpMappedFileBase != NULL) {
        // if open for output, get "logical" end of file so it
        // can be truncated to to the amount of file used in order to
        // save disk space
        if ((pLog->dwLogFormat & PDH_LOG_ACCESS_MASK) == PDH_LOG_WRITE_ACCESS) {
            pHeader = (PPDHI_BINARY_LOG_HEADER_RECORD)
                ((LPBYTE)(pLog->lpMappedFileBase) + pLog->dwRecord1Size);
            llEndOfFile = pHeader->Info.WrapOffset;
            if (llEndOfFile < pHeader->Info.NextRecordOffset) {
                llEndOfFile = pHeader->Info.NextRecordOffset;
            }
        }

        pdhStatus = UnmapReadonlyMappedFile (pLog->lpMappedFileBase, &bNeedToCloseHandles);
        assert (pdhStatus == ERROR_SUCCESS);
        pLog->lpMappedFileBase = NULL;
        // for mapped files, this is a pointer into the file/memory section
        // so once the view is unmapped, it's no longer valid
        pLog->pLastRecordRead = NULL;
    }

    if (bNeedToCloseHandles) {
        if (pLog->hMappedLogFile != NULL) {
            bStatus = CloseHandle (pLog->hMappedLogFile);
            assert (bStatus);
            pLog->hMappedLogFile  = NULL;
        }

        if (pdhStatus == ERROR_SUCCESS) {
            if (!(FlushFileBuffers (pLog->hLogFileHandle))) {
                pdhStatus = GetLastError();
            }
        } else {
            // close them anyway, but save the status from the prev. call
            FlushFileBuffers (pLog->hLogFileHandle);
        }

        // see if we can truncate the file
        if (llEndOfFile > 0) {
            DWORD   dwLoPos, dwHighPos;
            // truncate at the last byte used
            dwLoPos = LODWORD(llEndOfFile);
            dwHighPos = HIDWORD(llEndOfFile);

            dwLoPos = SetFilePointer (pLog->hLogFileHandle,
                dwLoPos, (LONG *)&dwHighPos, FILE_BEGIN);
            if (dwLoPos == 0xFFFFFFFF) {
                pdhStatus = GetLastError ();
            }
            assert (pdhStatus == ERROR_SUCCESS);
            assert (dwLoPos == LODWORD(llEndOfFile));
            assert (dwHighPos == HIDWORD(llEndOfFile));
            if (pdhStatus == ERROR_SUCCESS) {
                if (!SetEndOfFile(pLog->hLogFileHandle)) {
                    pdhStatus = GetLastError();
                }
            }
        } // else don't know where the end is so continue

        if (pLog->hLogFileHandle != INVALID_HANDLE_VALUE) {
            bStatus = CloseHandle (pLog->hLogFileHandle);
            assert (bStatus);
            pLog->hLogFileHandle = INVALID_HANDLE_VALUE;
        }
    } else {
        // the handles have already been closed so just
        // clear their values
        pLog->lpMappedFileBase = NULL;
        pLog->hMappedLogFile  = NULL;
        pLog->hLogFileHandle = INVALID_HANDLE_VALUE;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteBinaryLogHeader (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szUserCaption
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    DWORD           dwBytesWritten;
    CHAR            szTrailDelim[4];
    DWORD           dwTrailSize;
    PPDHI_BINARY_LOG_HEADER_RECORD  pLogHeader;
    PPDHI_LOG_COUNTER_PATH          pLogCounterBuffer = NULL;
    PPDHI_LOG_COUNTER_PATH          pThisLogCounter = NULL;
    PPDHI_COUNTER                   pThisCounter;
    DWORD           dwPathBuffSize;
    DWORD           dwBufSize = 0;
    DWORD           dwBufToCopy;
    DWORD           dwNewSize;

    PCHAR            szOutputBuffer = NULL;
    DWORD            dwOutputBufferSize = 0;
    DWORD            dwOutputBufferUsed = 0;

    PWCHAR           pBufferBase;
    LONG             lBufferOffset;
    PBYTE            pSourceBase;
    LONGLONG         llStartingOffset;

    UNREFERENCED_PARAMETER (szUserCaption);

    // this is just used for the header string so it
    // doesn't need to be very large
    dwOutputBufferSize = SMALL_BUFFER_SIZE;

    szOutputBuffer = G_ALLOC (dwOutputBufferSize);
    if (szOutputBuffer == NULL) {
        assert (GetLastError() == ERROR_SUCCESS);
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    szTrailDelim[0] = DOUBLEQUOTE_A;
    szTrailDelim[1] = 0;
    szTrailDelim[2] = 0;
    szTrailDelim[3] = 0;
    dwTrailSize = 1;

    // write log file type record
    memset (szOutputBuffer, 0, dwOutputBufferSize);

    lstrcpyA (szOutputBuffer, szTrailDelim);
    lstrcatA (szOutputBuffer, szBinLogFileHeader);
    lstrcatA (szOutputBuffer, szTrailDelim);
    lstrcatA (szOutputBuffer, PdhiszRecordTerminator);

    dwOutputBufferUsed = lstrlenA(szOutputBuffer);
    // align following structures on LONGLONG boundries
    dwOutputBufferUsed = QWORD_MULTIPLE (dwOutputBufferUsed);

    // save size of binary log record header
    pLog->dwRecord1Size = dwOutputBufferUsed;

    // from here on out all records have a 2-byte length field at
    // the beginning to indicate how long the record is

    // go through all the counters in the query and
    // write them to the log file

    pThisCounter = pLog->pQuery ? pLog->pQuery->pCounterListHead : NULL;

    if (pThisCounter != NULL) {
        do {
            // get the counter path information from the counter struct
            dwPathBuffSize = (DWORD)G_SIZE (pThisCounter->pCounterPath);
            dwBufToCopy = dwPathBuffSize;
            dwBufToCopy -= (DWORD)((DWORD_PTR)&pThisCounter->pCounterPath->pBuffer[0] -
                            (DWORD_PTR)pThisCounter->pCounterPath);

            dwPathBuffSize -= (DWORD)((DWORD_PTR)&pThisCounter->pCounterPath->pBuffer[0] -
                            (DWORD_PTR)pThisCounter->pCounterPath);
            dwPathBuffSize += sizeof (PDHI_LOG_COUNTER_PATH) -
                              sizeof (WCHAR); // Buffer[0].
            // adjust buffer size for possible wildcard entry
            // note that this may not be used, it'll be allocated in
            // any event
            dwPathBuffSize += sizeof (DWORD);
            // dword align the stuctures
            dwPathBuffSize = QWORD_MULTIPLE(dwPathBuffSize);

            //extend buffer to accomodate this new counter
            if (pLogCounterBuffer == NULL) {
                // then allocate the first one
                dwNewSize = dwPathBuffSize
                    + sizeof(PDHI_BINARY_LOG_HEADER_RECORD);
                assert (dwNewSize > 0);
                // to make sure the structure size doesn't change accidentally
                assert (sizeof(PDHI_BINARY_LOG_INFO) == 256);

                pLogCounterBuffer = G_ALLOC (dwNewSize);
                if (pLogCounterBuffer == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    goto Cleanup;
                }

                pThisLogCounter = (PPDHI_LOG_COUNTER_PATH)(
                    (LPBYTE)pLogCounterBuffer +
                        sizeof(PDHI_BINARY_LOG_HEADER_RECORD));
                dwBufSize = dwNewSize;
            } else {
                PPDHI_LOG_COUNTER_PATH pOldCounter = pLogCounterBuffer;
                // extend buffer for new entry
                dwNewSize = (dwBufSize + dwPathBuffSize);
                assert (dwNewSize > 0);
                pLogCounterBuffer = G_REALLOC (pOldCounter, dwNewSize);
                if (pLogCounterBuffer == NULL) {
                    G_FREE(pOldCounter);
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    goto Cleanup;
                }
                pThisLogCounter = (PPDHI_LOG_COUNTER_PATH)
                    ((LPBYTE)pLogCounterBuffer + dwBufSize);
                dwBufSize += dwPathBuffSize;
            }
            assert (pLogCounterBuffer != NULL);
            assert (pThisLogCounter != NULL);
            assert (G_SIZE (pLogCounterBuffer) > 0);

            pThisLogCounter->dwLength = dwPathBuffSize;
            pThisLogCounter->dwFlags = pThisCounter->dwFlags;

            pThisLogCounter->dwUserData = pThisCounter->dwUserData;
            pThisLogCounter->dwCounterType =
                pThisCounter->plCounterInfo.dwCounterType;
            pThisLogCounter->lDefaultScale =
                pThisCounter->plCounterInfo.lDefaultScale;
            pThisLogCounter->llTimeBase = pThisCounter->TimeBase;

            // copy the counter path string data to the log buffer, then
            // convert the pointers to offsets

            pSourceBase = &pThisCounter->pCounterPath->pBuffer[0];

            // if this is a wild card path, then move the strings up
            // 1 dword in the buffer allowing the first DWORD of the
            // the buffer to contain the offset into the catalog
            // of the instances found in this log file. This list
            // will be built after the log is closed.

            lBufferOffset = 0; // in WORDS (not bytes)
            if (pThisCounter->pCounterPath->szInstanceName != NULL) {
                if (*pThisCounter->pCounterPath->szInstanceName == SPLAT_L) {
                    // this is a wildcard path so save room for the
                    // pointer into the catalog
                    lBufferOffset = sizeof(DWORD);
                }
            }
#if DBG
            if (lBufferOffset > 0) *(LPDWORD)(&pThisLogCounter->Buffer[0]) = 0x12345678;
#endif
            pBufferBase = (PWCHAR)((LPBYTE)&pThisLogCounter->Buffer[0] +
                lBufferOffset);

            RtlCopyMemory((LPVOID) pBufferBase, (LPVOID)pSourceBase, dwBufToCopy);

            // find offsets from the start of the buffer
            if (pThisCounter->pCounterPath->szMachineName != NULL) {
                pThisLogCounter->lMachineNameOffset = lBufferOffset +
                    (LONG)((DWORD_PTR)pThisCounter->pCounterPath->szMachineName -
                        (DWORD_PTR)pSourceBase);
                //assert (pThisLogCounter->lMachineNameOffset == 0);
            } else {
                pThisLogCounter->lMachineNameOffset = (LONG)-1;
            }

            if (pThisCounter->pCounterPath->szObjectName != NULL) {
                pThisLogCounter->lObjectNameOffset = lBufferOffset +
                    (LONG)((DWORD_PTR)pThisCounter->pCounterPath->szObjectName -
                            (DWORD_PTR)pSourceBase);
            } else {
                pThisLogCounter->lObjectNameOffset = (LONG)-1;
            }

            if (pThisCounter->pCounterPath->szInstanceName != NULL) {
                pThisLogCounter->lInstanceOffset = lBufferOffset +
                    (LONG)((DWORD_PTR)pThisCounter->pCounterPath->szInstanceName -
                            (DWORD_PTR)pSourceBase);
            } else {
                pThisLogCounter->lInstanceOffset = (LONG)-1;
            }

            if (pThisCounter->pCounterPath->szParentName != NULL) {
                pThisLogCounter->lParentOffset = lBufferOffset +
                    (LONG)((DWORD_PTR)pThisCounter->pCounterPath->szParentName -
                            (DWORD_PTR)pSourceBase);
            } else {
                pThisLogCounter->lParentOffset = (LONG)-1;
            }

            pThisLogCounter->dwIndex = pThisCounter->pCounterPath->dwIndex;

            if (pThisCounter->pCounterPath->szCounterName != NULL) {
                pThisLogCounter->lCounterOffset = lBufferOffset +
                    (LONG)((DWORD_PTR)pThisCounter->pCounterPath->szCounterName -
                            (DWORD_PTR)pSourceBase);
            } else {
                pThisLogCounter->lCounterOffset = (LONG)-1;
            }

            pThisCounter = pThisCounter->next.flink; // go to next in list
        } while (pThisCounter != pLog->pQuery->pCounterListHead);

        if (pdhStatus == ERROR_SUCCESS) {
            assert (dwBufSize < 0x00010000); // just to see if we get any big lists

            // update the record header
            pLogHeader = (PPDHI_BINARY_LOG_HEADER_RECORD)(pLogCounterBuffer);
            pLogHeader->RecHeader.dwType = BINLOG_TYPE_CATALOG_LIST;
            pLogHeader->RecHeader.dwLength = dwBufSize;
            pLogHeader->Info.FileLength = 0;
            pLogHeader->Info.dwLogVersion = BINLOG_VERSION;
            // save the log options only here
            pLogHeader->Info.dwFlags = pLog->dwLogFormat & PDH_LOG_OPT_MASK;
            pLogHeader->Info.StartTime = 0;
            pLogHeader->Info.EndTime = 0;
            pLogHeader->Info.CatalogOffset = 0;
            pLogHeader->Info.CatalogChecksum = PdhiComputeDwordChecksum (
                (LPVOID) &pLogHeader[1], (dwBufSize - sizeof(PDHI_BINARY_LOG_HEADER_RECORD)));
            pLogHeader->Info.CatalogDate = 0;
            // record pointers are all the same for the first record
            llStartingOffset = dwBufSize + pLog->dwRecord1Size;
            pLogHeader->Info.FirstDataRecordOffset = llStartingOffset;
            pLogHeader->Info.FirstRecordOffset = llStartingOffset;
            pLogHeader->Info.LastRecordOffset = llStartingOffset;
            pLogHeader->Info.NextRecordOffset = llStartingOffset;
            pLogHeader->Info.WrapOffset = 0;

            // write log file header to file
            if ((pdhStatus = PdhiWriteOneBinaryLogRecord (pLog,
                (LPCVOID)szOutputBuffer,
                dwOutputBufferUsed,
                &dwBytesWritten,
                WBLR_WRITE_LOG_HEADER)) == ERROR_SUCCESS) {

                // write log contents record to file
                pdhStatus = PdhiWriteOneBinaryLogRecord (pLog,
                    (LPCVOID)pLogCounterBuffer,
                    dwBufSize,
                    &dwBytesWritten,
                    WBLR_WRITE_COUNTER_HEADER);

            }
        }
        if (pLogCounterBuffer != NULL) G_FREE (pLogCounterBuffer);
    } else {
        // no counter's assigned to this query
        pdhStatus = PDH_NO_DATA;
    }

Cleanup:
    if (szOutputBuffer != NULL) G_FREE (szOutputBuffer);
    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteBinaryLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  SYSTEMTIME  *stTimeStamp,
    IN  LPCWSTR     szUserString
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    DWORD           dwBytesWritten;
    PPDHI_BINARY_LOG_RECORD_HEADER  pLogCounterBuffer = NULL;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisLogCounter = NULL;
    PPDH_RAW_COUNTER                pSingleCounter;
    PPDHI_RAW_COUNTER_ITEM_BLOCK    pMultiCounter;
    PPDHI_COUNTER                   pThisCounter;
    DWORD           dwCtrBufSize;
    DWORD           dwBufSize = 0;
    BOOL            bVarCtr;
    DWORD           dwNewSize;
    DWORD           dwBytesCopied = 0;
    int             nItem;

    UNREFERENCED_PARAMETER (stTimeStamp);
    DBG_UNREFERENCED_PARAMETER (szUserString);

    // get first counter in list
    pThisCounter = pLog->pQuery ? pLog->pQuery->pCounterListHead : NULL;

    if (pThisCounter != NULL) {
        do {
            bVarCtr = pThisCounter->dwFlags & PDHIC_MULTI_INSTANCE ?
                TRUE : FALSE;

            if (bVarCtr) {
                dwCtrBufSize = pThisCounter->pThisRawItemList->dwLength;
            } else {
                dwCtrBufSize = sizeof (PDH_RAW_COUNTER);
            }
            // each counter gets a header
            dwCtrBufSize += sizeof (PDHI_BINARY_LOG_RECORD_HEADER);

            //extend buffer to accomodate this new counter
            if (pLogCounterBuffer == NULL) {
                // add in room for the master record header
                // then allocate the first one
                pLogCounterBuffer = G_ALLOC ((dwCtrBufSize + sizeof (PDHI_BINARY_LOG_RECORD_HEADER)));
                // set counter data pointer to just after the master
                // record header
                if (pLogCounterBuffer == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    break;
                }
                pThisLogCounter = (PPDHI_BINARY_LOG_RECORD_HEADER)(
                    &pLogCounterBuffer[1]);
                dwBufSize = dwCtrBufSize + sizeof (PDHI_BINARY_LOG_RECORD_HEADER);
            } else {
                PPDHI_BINARY_LOG_RECORD_HEADER pOldBuffer = pLogCounterBuffer;
                // extend buffer for new entry
                dwNewSize = (dwBufSize + dwCtrBufSize);
                assert (dwNewSize);
                pLogCounterBuffer = G_REALLOC (pOldBuffer, dwNewSize);
                if (pLogCounterBuffer == NULL) {
                    G_FREE(pOldBuffer);
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    goto Cleanup;
                }
                pThisLogCounter = (PPDHI_BINARY_LOG_RECORD_HEADER)
                    ((LPBYTE)pLogCounterBuffer + dwBufSize);
                dwBufSize += dwCtrBufSize;
            }
            assert (pLogCounterBuffer != NULL);
            assert (pThisLogCounter != NULL);
            assert (G_SIZE (pLogCounterBuffer) > 0);

            // set the header fields and data pointer
            assert (dwCtrBufSize < 0x00010000);
            pThisLogCounter->dwLength = LOWORD(dwCtrBufSize);

            // add in size of record header
            dwBytesCopied += sizeof (PDHI_BINARY_LOG_RECORD_HEADER);
            if (bVarCtr) {
                // multiple counter
                pThisLogCounter->dwType = BINLOG_TYPE_DATA_MULTI;
                pMultiCounter = (PPDHI_RAW_COUNTER_ITEM_BLOCK) (
                    (LPBYTE)pThisLogCounter +
                        sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                RtlCopyMemory(pMultiCounter,
                    pThisCounter->pThisRawItemList,
                    pThisCounter->pThisRawItemList->dwLength);

                dwBytesCopied += pThisCounter->pThisRawItemList->dwLength;
            } else {
                // single counter
                pThisLogCounter->dwType = BINLOG_TYPE_DATA_SINGLE;
                pSingleCounter = (PPDH_RAW_COUNTER) (
                    (LPBYTE)pThisLogCounter +
                        sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                RtlCopyMemory(pSingleCounter,
                    &pThisCounter->ThisValue,
                    sizeof (PDH_RAW_COUNTER));
                dwBytesCopied += sizeof (PDH_RAW_COUNTER);
           }

            pThisCounter = pThisCounter->next.flink; // go to next in list
        } while (pThisCounter != pLog->pQuery->pCounterListHead);
        // update the record header

        if (pdhStatus == ERROR_SUCCESS) {
            // add in size of master record header
            dwBytesCopied += sizeof (PDHI_BINARY_LOG_RECORD_HEADER);
            pLogCounterBuffer->dwType = BINLOG_TYPE_DATA;

            // Need to handle the case where the resulting record is
            // greater than 64K in length. Probably by breaking it into
            // multiple records.
            pLogCounterBuffer->dwLength = dwBufSize;

            assert (dwBufSize == dwBytesCopied);

            // write record to file

            pdhStatus = PdhiWriteOneBinaryLogRecord (
                pLog,
                (LPCVOID)pLogCounterBuffer,
                dwBufSize,
                &dwBytesWritten,
                0);

        }

        if (pLogCounterBuffer != NULL) G_FREE (pLogCounterBuffer);

    } else {
        // no counter's assigned to this query
        pdhStatus = PDH_NO_DATA;
    }

Cleanup:
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumMachinesFromBinaryLog (
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     pcchBufferSize,
    BOOL        bUnicodeDest
)
{
    LPVOID      pTempBuffer = NULL;
    LPVOID      pOldBuffer;
    DWORD       dwTempBufferSize;
    LPVOID      LocalBuffer = NULL;
    DWORD       dwLocalBufferSize;

    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    // read the header record and enum the machine name from the entries

    if (pLog->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLog->dwMaxRecordSize = 0x010000;
    }

    dwTempBufferSize = pLog->dwMaxRecordSize;
    pTempBuffer = G_ALLOC(dwTempBufferSize);
    if (pTempBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    dwLocalBufferSize = MEDIUM_BUFFER_SIZE;
    LocalBuffer       = G_ALLOC(dwLocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    if (LocalBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    // read in the catalog record

    while ((pdhStatus = PdhiReadOneBinLogRecord (pLog, BINLOG_HEADER_RECORD,
            pTempBuffer, dwTempBufferSize)) != ERROR_SUCCESS) {
        if (pdhStatus == PDH_MORE_DATA) {
            // read the 1st WORD to see if this is a valid record
            if (*(WORD *)pTempBuffer == BINLOG_START_WORD) {
                // it's a valid record so read the 2nd DWORD to get the
                // record size;
                dwTempBufferSize = ((DWORD *)pTempBuffer)[1];
                if (dwTempBufferSize < pLog->dwMaxRecordSize) {
                    // then something is bogus so return an error
                    pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                    break; // out of while loop
                } else {
                    pLog->dwMaxRecordSize = dwTempBufferSize;
                }
            } else {
                // we're lost in this file
                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                break; // out of while loop
            }
            // realloc a new buffer
            pOldBuffer = pTempBuffer;
            pTempBuffer = G_REALLOC (pOldBuffer, dwTempBufferSize);
            if (pTempBuffer == NULL) {
                // return memory error
                G_FREE(pOldBuffer);
                assert (GetLastError() == ERROR_SUCCESS);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            }
        } else {
            // some other error was returned so
            // return error from read function
            break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {

        PPDHI_LOG_COUNTER_PATH  pPath;
        DWORD                   dwBytesProcessed;
        LONG                    nItemCount = 0;
        LPBYTE                  pFirstChar;
        LPWSTR                  szMachineName;
        DWORD                   dwRecordLength;
        DWORD                   dwBufferUsed = 0;
        DWORD                   dwNewBuffer = 0;

        // we can assume the record was read successfully so read in the
        // machine names
        dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER)pTempBuffer)->dwLength;

        pPath = (PPDHI_LOG_COUNTER_PATH)
            ((LPBYTE)pTempBuffer + sizeof (PDHI_BINARY_LOG_HEADER_RECORD));
        dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

        while (dwBytesProcessed < dwRecordLength) {
            if (pPath->lMachineNameOffset >= 0L) {
                // then there's a machine name in this record so get
                // it's size
                pFirstChar = (LPBYTE)&pPath->Buffer[0];
                szMachineName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lMachineNameOffset);

                dwNewBuffer = (lstrlenW (szMachineName) + 1);

                while (dwNewBuffer + dwBufferUsed > dwLocalBufferSize) {
                    pOldBuffer         = LocalBuffer;
                    dwLocalBufferSize += MEDIUM_BUFFER_SIZE;
                    LocalBuffer = G_REALLOC(pOldBuffer,
                                            dwLocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                    if (LocalBuffer == NULL) {
                        if (pOldBuffer != NULL) G_FREE(pOldBuffer);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                }
                dwNewBuffer = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer, szMachineName, bUnicodeDest);
                if (dwNewBuffer > 0) {
                    dwBufferUsed = dwNewBuffer;
                    nItemCount ++;
                }
            }
            // get next path entry from log file record
            dwBytesProcessed += pPath->dwLength;
            pPath = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pPath + pPath->dwLength);
        }

        if ((nItemCount > 0)  && (pdhStatus != PDH_INSUFFICIENT_BUFFER)
                              && (pdhStatus != PDH_MORE_DATA)) {
            // then the routine was successful. Errors that occurred
            // while scanning will be ignored as long as at least
            // one entry was successfully read
            pdhStatus = ERROR_SUCCESS;
        }

        if (nItemCount > 0) {
            dwBufferUsed ++;
        }
        if (pBuffer && dwBufferUsed <= * pcchBufferSize) {
            RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
        }
        else {
            if (pBuffer)
                RtlCopyMemory(pBuffer, LocalBuffer, (* pcchBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            pdhStatus = PDH_MORE_DATA;
        }
        *pcchBufferSize = dwBufferUsed;

   }

Cleanup:
   if (LocalBuffer != NULL) G_FREE(LocalBuffer);
   if (pTempBuffer != NULL) G_FREE(pTempBuffer);
   return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectsFromBinaryLog (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szMachineName,
    IN  LPVOID      pBuffer,
    IN  LPDWORD     pcchBufferSize,
    IN  DWORD       dwDetailLevel,
    IN  BOOL        bUnicodeDest
)
{
    LPVOID      pTempBuffer = NULL;
    LPVOID      pOldBuffer;
    DWORD       dwTempBufferSize;
    LPVOID      LocalBuffer = NULL;
    DWORD       dwLocalBufferSize;
    LPCWSTR     szLocalMachine = szMachineName;

    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    // read the header record and enum the machine name from the entries

    UNREFERENCED_PARAMETER (dwDetailLevel);

    if (pLog->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLog->dwMaxRecordSize = 0x010000;
    }

    if (szLocalMachine == NULL)          szLocalMachine = szStaticLocalMachineName;
    else if (szLocalMachine[0] == L'\0') szLocalMachine = szStaticLocalMachineName;

    dwTempBufferSize = pLog->dwMaxRecordSize;
    pTempBuffer = G_ALLOC(dwTempBufferSize);
    if (pTempBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    dwLocalBufferSize = MEDIUM_BUFFER_SIZE;
    LocalBuffer       = G_ALLOC(dwLocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    if (LocalBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    // read in the catalog record

    while ((pdhStatus = PdhiReadOneBinLogRecord (pLog, BINLOG_HEADER_RECORD,
            pTempBuffer, dwTempBufferSize)) != ERROR_SUCCESS) {
        if (pdhStatus == PDH_MORE_DATA) {
            // read the 1st WORD to see if this is a valid record
            if (*(WORD *)pTempBuffer == BINLOG_START_WORD) {
                // it's a valid record so read the 2nd DWORD to get the
                // record size;
                dwTempBufferSize = ((DWORD *)pTempBuffer)[1];
                if (dwTempBufferSize < pLog->dwMaxRecordSize) {
                    // then something is bogus so return an error
                    pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                    break; // out of while loop
                } else {
                    pLog->dwMaxRecordSize = dwTempBufferSize;
                }
            } else {
                // we're lost in this file
                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                break; // out of while loop
            }
            // realloc a new buffer
            pOldBuffer = pTempBuffer;
            pTempBuffer = G_REALLOC (pOldBuffer, dwTempBufferSize);
            if (pTempBuffer == NULL) {
                // return memory error
                G_FREE(pOldBuffer);
                assert (GetLastError() == ERROR_SUCCESS);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            }
        } else {
            // some other error was returned so
            // return error from read function
            break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        PPDHI_LOG_COUNTER_PATH          pPath;

        DWORD                           dwBytesProcessed;
        LONG                            nItemCount = 0;
        LPBYTE                          pFirstChar;
        LPWSTR                          szThisMachineName;
        LPWSTR                          szThisObjectName;

        DWORD                   dwRecordLength;
        DWORD                   dwBufferUsed = 0;
        DWORD                   dwNewBuffer = 0;

        BOOL                    bCopyThisObject;

        // we can assume the record was read successfully so read in the
        // objects that match the machine name and detail level criteria
        dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER)pTempBuffer)->dwLength;

        pPath = (PPDHI_LOG_COUNTER_PATH)
            ((LPBYTE)pTempBuffer + sizeof (PDHI_BINARY_LOG_HEADER_RECORD));
        dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

        while (dwBytesProcessed < dwRecordLength) {
            bCopyThisObject = FALSE;
            szThisObjectName = NULL;
            pFirstChar = (LPBYTE)&pPath->Buffer[0];

            if (pPath->lMachineNameOffset >= 0L) {
                // then there's a machine name in this record so get
                // it's size
                szThisMachineName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lMachineNameOffset);

                // if this is for the desired machine, then copy this object

                if (lstrcmpiW(szThisMachineName, szLocalMachine) == 0) {
                    if (szThisObjectName >= 0) {
                        szThisObjectName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lObjectNameOffset);
                        bCopyThisObject = TRUE;
                    } else {
                        // no object to copy
                    }
                } else {
                    // this machine isn't selected
                }
            } else {
                // there's no machine specified so for this counter so list it by default
                if (szThisObjectName >= 0) {
                    szThisObjectName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lObjectNameOffset);
                    bCopyThisObject = TRUE;
                } else {
                    // no object to copy
                }
            }

            if (bCopyThisObject && szThisObjectName != NULL) {
                // get the size of this object's name
                dwNewBuffer = (lstrlenW(szThisObjectName) + 1);

                while (dwNewBuffer + dwBufferUsed > dwLocalBufferSize) {
                    pOldBuffer         = LocalBuffer;
                    dwLocalBufferSize += MEDIUM_BUFFER_SIZE;
                    LocalBuffer = G_REALLOC(pOldBuffer,
                                            dwLocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                    if (LocalBuffer == NULL) {
                        if (pOldBuffer != NULL) G_FREE(pOldBuffer);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                }
                dwNewBuffer = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer, szThisObjectName, bUnicodeDest);
                if (dwNewBuffer > 0) {
                    dwBufferUsed = dwNewBuffer;
                    nItemCount ++;
                }
            }

            // get next path entry from log file record
            dwBytesProcessed += pPath->dwLength;
            pPath = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE)pPath + pPath->dwLength);
        }

        if ((nItemCount > 0)  && (pdhStatus != PDH_INSUFFICIENT_BUFFER)
                              && (pdhStatus != PDH_MORE_DATA)) {
            // then the routine was successful. Errors that occurred
            // while scanning will be ignored as long as at least
            // one entry was successfully read
            pdhStatus = ERROR_SUCCESS;
        }

        if (nItemCount > 0) {
            dwBufferUsed ++;
        }
        if (pBuffer && dwBufferUsed <= * pcchBufferSize) {
            RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
        }
        else {
            if (pBuffer)
                RtlCopyMemory(pBuffer, LocalBuffer, (* pcchBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            pdhStatus = PDH_MORE_DATA;
        }

        * pcchBufferSize = dwBufferUsed;
   }

Cleanup:
   if (LocalBuffer != NULL) G_FREE(LocalBuffer);
   if (pTempBuffer != NULL) G_FREE(pTempBuffer);
   return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectItemsFromBinaryLog (
    IN  PPDHI_LOG          pLog,
    IN  LPCWSTR            szMachineName,
    IN  LPCWSTR            szObjectName,
    IN  PDHI_COUNTER_TABLE CounterTable,
    IN  DWORD              dwDetailLevel,
    IN  DWORD              dwFlags
)
{
    LPVOID          pTempBuffer       = NULL;
    LPVOID          pOldBuffer;
    DWORD           dwTempBufferSize;
    PDH_STATUS      pdhStatus         = ERROR_SUCCESS;
    PPDHI_INST_LIST pInstList;
    PPDHI_INSTANCE  pInstance;
    BOOL            bProcessInstance  = FALSE;

    UNREFERENCED_PARAMETER (dwDetailLevel);
    UNREFERENCED_PARAMETER (dwFlags);

    // read the header record and enum the machine name from the entries

    if (pLog->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLog->dwMaxRecordSize = 0x010000;
    }

    dwTempBufferSize = pLog->dwMaxRecordSize;
    pTempBuffer = G_ALLOC (dwTempBufferSize);
    assert (pTempBuffer != NULL);
    if (pTempBuffer == NULL) {
        assert (GetLastError() == ERROR_SUCCESS);
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    // read in the catalog record

    while ((pdhStatus = PdhiReadOneBinLogRecord (pLog, BINLOG_HEADER_RECORD,
            pTempBuffer, dwTempBufferSize)) != ERROR_SUCCESS) {
        if (pdhStatus == PDH_MORE_DATA) {
            // read the 1st WORD to see if this is a valid record
            if (*(WORD *)pTempBuffer == BINLOG_START_WORD) {
                // it's a valid record so read the 2nd DWORD to get the
                // record size;
                dwTempBufferSize = ((DWORD *)pTempBuffer)[1];
                if (dwTempBufferSize < pLog->dwMaxRecordSize) {
                    // then something is bogus so return an error
                    pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                    break; // out of while loop
                } else {
                    pLog->dwMaxRecordSize = dwTempBufferSize;
                }
            } else {
                // we're lost in this file
                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                break; // out of while loop
            }
            // realloc a new buffer
            pOldBuffer = pTempBuffer;
            pTempBuffer = G_REALLOC (pOldBuffer, dwTempBufferSize);
            if (pTempBuffer == NULL) {
                // return memory error
                G_FREE(pOldBuffer);
                assert (GetLastError() == ERROR_SUCCESS);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            }
        } else {
            // some other error was returned so
            // return error from read function
            break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {

        PPDHI_BINARY_LOG_HEADER_RECORD  pHeader;
        PPDHI_LOG_COUNTER_PATH          pPath;
        PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
        PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;

        PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;
        PPDHI_RAW_COUNTER_ITEM          pDataItem;

        DWORD                           dwBytesProcessed;
        LONG                            nItemCount = 0;
        LPBYTE                          pFirstChar;
        LPWSTR                          szThisMachineName;
        LPWSTR                          szThisObjectName;
        LPWSTR                          szThisCounterName = NULL;
        LPWSTR                          szThisInstanceName;
        LPWSTR                          szThisParentName;

        WCHAR                   szCompositeInstance[1024];

        DWORD                   dwRecordLength;

        BOOL                    bCopyThisObject;
        DWORD                   dwIndex;
        DWORD                   dwThisRecordIndex;
        DWORD                   dwDataItemIndex;

        PLOG_BIN_CAT_RECORD     pCatRec;
        LPWSTR                  szWideInstanceName;

        pHeader =  (PPDHI_BINARY_LOG_HEADER_RECORD)pTempBuffer;

        // we can assume the record was read successfully so read in the
        // objects that match the machine name and detail level criteria
        dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER)pTempBuffer)->dwLength;

        pPath = (PPDHI_LOG_COUNTER_PATH)
            ((LPBYTE)pTempBuffer + sizeof (PDHI_BINARY_LOG_HEADER_RECORD));
        dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

        dwIndex = 0;

        while (dwBytesProcessed < dwRecordLength) {
            bCopyThisObject = FALSE;
            szThisObjectName = NULL;

            dwIndex++;

            pFirstChar = (LPBYTE)&pPath->Buffer[0];

            if (pPath->lMachineNameOffset >= 0L) {
                // then there's a machine name in this record so get
                // it's size
                szThisMachineName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lMachineNameOffset);

                // if this is for the desired machine, then select the object

                if (lstrcmpiW(szThisMachineName,szMachineName) == 0) {
                    if (szThisObjectName >= 0) {
                        szThisObjectName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lObjectNameOffset);
                        if (lstrcmpiW(szThisObjectName,szObjectName) == 0) {
                            // then this is the object to look up
                            bCopyThisObject = TRUE;
                        } else {
                            // not this object
                        }
                    } else {
                        // no object to copy
                    }
                } else {
                    // this machine isn't selected
                }
            } else {
                // there's no machine specified so for this counter so list it by default
                if (pPath->lObjectNameOffset >= 0) {
                    szThisObjectName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lObjectNameOffset);
                    if (lstrcmpiW(szThisObjectName,szObjectName) == 0) {
                        // then this is the object to look up
                        bCopyThisObject = TRUE;
                    } else {
                        // not this object
                    }
                } else {
                    // no object to copy
                }
            }

            if (bCopyThisObject) {
                // if here, then there should be a name
                assert (szThisObjectName != NULL);

                // get the counter name from this counter and add it to the list
                if (pPath->lCounterOffset > 0) {
                    szThisCounterName = (LPWSTR)((LPBYTE)pFirstChar +
                        pPath->lCounterOffset);
                } else {
                    szThisCounterName = NULL;
                    bCopyThisObject = FALSE;
                }
            }

            if (bCopyThisObject) {
                pdhStatus = PdhiFindCounterInstList(
                            CounterTable,
                            szThisCounterName,
                            & pInstList);

                if (pdhStatus != ERROR_SUCCESS || pInstList == NULL) {
                    continue;
                }

                // check instance now
                // get the instance name from this counter and add it to the list
                if (pPath->lInstanceOffset >= 0) {
                    szThisInstanceName = (LPWSTR)((LPBYTE)pFirstChar +
                        pPath->lInstanceOffset);
                    if (*szThisInstanceName != SPLAT_L) {
                        if (pPath->lParentOffset >= 0) {
                            szThisParentName = (LPWSTR)((LPBYTE)pFirstChar +
                                pPath->lParentOffset);

                            lstrcpyW (szCompositeInstance,
                                szThisParentName);
                            lstrcatW (szCompositeInstance, cszSlash);
                            lstrcatW (szCompositeInstance, szThisInstanceName);
                        } else {
                            lstrcpyW (szCompositeInstance, szThisInstanceName);
                        }

                        //if (pPath->dwIndex > 0) {
                        //    _ltow (pPath->dwIndex, (LPWSTR)
                        //        (szCompositeInstance + lstrlenW(szCompositeInstance)),
                        //        10L);
                        //}

                        pdhStatus = PdhiFindInstance(
                                    & pInstList->InstList,
                                    szCompositeInstance,
                                    TRUE,
                                    & pInstance);

                        if (pdhStatus == ERROR_SUCCESS) {
                            nItemCount++;
                        }
                    } else {
                        // only use the catalog if it's up to date and present
                        if ((pHeader->Info.CatalogOffset > 0) &&
                            (pHeader->Info.LastUpdateTime <= pHeader->Info.CatalogDate)){
                            // find catalog record
                            pCatRec = (PLOG_BIN_CAT_RECORD)
                                // base of mapped log file
                                ((LPBYTE)pLog->lpMappedFileBase +
                                // + offset to catalog records
                                 pHeader->Info.CatalogOffset +
                                // + offset to the instance entry for this item
                                 *(LPDWORD)&pPath->Buffer[0]);
                            assert (pCatRec != NULL);
                            assert (pCatRec->RecHeader.dwType == BINLOG_TYPE_CATALOG_ITEM);
                            for (szWideInstanceName = (LPWSTR)((LPBYTE)&pCatRec->CatEntry + pCatRec->CatEntry.dwInstanceStringOffset);
                                     * szWideInstanceName != 0;
                                     szWideInstanceName += lstrlenW(szWideInstanceName) + 1) {
                                 pdhStatus = PdhiFindInstance(
                                             & pInstList->InstList,
                                               szWideInstanceName,
                                               TRUE,
                                             & pInstance);
                            }
                        } else if (! bProcessInstance) {
                            // look up individual instances in log...
                            // read records from file and store instances

                            dwThisRecordIndex = BINLOG_FIRST_DATA_RECORD;

                            // this call just moved the record pointer
                            pdhStatus = PdhiReadOneBinLogRecord (
                                            pLog, dwThisRecordIndex, NULL, 0);
                            while (pdhStatus == ERROR_SUCCESS) {
                                PdhiResetInstanceCount(CounterTable);
                                pThisMasterRecord =
                                        (PPDHI_BINARY_LOG_RECORD_HEADER)
                                            pLog->pLastRecordRead;
                                // make sure we haven't left the file
                                assert (pThisMasterRecord != NULL);
                                assert ((LPBYTE)pThisMasterRecord >
                                        (LPBYTE)pLog->lpMappedFileBase);
                                assert ((LPBYTE)pThisMasterRecord <
                                        ((LPBYTE)pLog->lpMappedFileBase +
                                         pLog->llFileSize));

                                pThisSubRecord = PdhiGetSubRecord (
                                        pThisMasterRecord, dwIndex);

                                assert (pThisSubRecord != NULL);
                                assert (pThisSubRecord->dwType == BINLOG_TYPE_DATA_MULTI);

                                if (pThisSubRecord == NULL) {
                                    // bail on a null record
                                    pdhStatus = PDH_END_OF_LOG_FILE;
                                    break;
                                }

                                pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK)
                                        ((LPBYTE)pThisSubRecord +
                                        sizeof (PDHI_BINARY_LOG_RECORD_HEADER));

                                // walk down list of entries and add them to the
                                // list of instances (these should already
                                // be assembled in parent/instance format)

                                if (pDataBlock->dwLength > 0) {
                                    for (dwDataItemIndex = 0;
                                        dwDataItemIndex < pDataBlock->dwItemCount;
                                        dwDataItemIndex++) {
                                        pDataItem = &pDataBlock->pItemArray[dwDataItemIndex];
                                        szThisInstanceName = (LPWSTR)
                                                (((LPBYTE) pDataBlock) + pDataItem->szName);
                                        pdhStatus = PdhiFindInstance(
                                                & pInstList->InstList,
                                                szThisInstanceName,
                                                TRUE,
                                                & pInstance);
                                    }
                                } else {
                                    // no data in this record
                                }

                                if (pdhStatus != ERROR_SUCCESS) {
                                    // then exit loop, otherwise
                                    break;
                                } else {
                                    // go to next record in log
                                    pdhStatus = PdhiReadOneBinLogRecord(
                                        pLog, ++dwThisRecordIndex, NULL, 0);
                                }
                            }
                            if (pdhStatus == PDH_END_OF_LOG_FILE) {
                                pdhStatus = ERROR_SUCCESS;
                            }
                            if (pdhStatus == ERROR_SUCCESS) {
                                bProcessInstance = TRUE;
                            }
                        }
                    }
                }
                memset (szCompositeInstance, 0, (sizeof(szCompositeInstance)));
            }

            // get next path entry from log file record
            dwBytesProcessed += pPath->dwLength;
            pPath = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE)pPath + pPath->dwLength);

        }

        if ((nItemCount > 0) && (pdhStatus != PDH_INSUFFICIENT_BUFFER)
                             && (pdhStatus != PDH_MORE_DATA)) {
            // then the routine was successful. Errors that occurred
            // while scanning will be ignored as long as at least
            // one entry was successfully read
            pdhStatus = ERROR_SUCCESS;
        }
   }

   if (pTempBuffer != NULL) G_FREE (pTempBuffer);

   return pdhStatus;
}

PDH_FUNCTION
PdhiGetMatchingBinaryLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  LONGLONG    *pStartTime,
    IN  LPDWORD     pdwIndex
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwRecordId;
    LONGLONG    RecordTimeValue;
    LONGLONG    LastTimeValue = 0;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;

    PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;
    PPDH_RAW_COUNTER                pRawItem;

    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode

    // if the high dword of the time value is 0xFFFFFFFF, then the
    // low dword is the record id to read

    if ((*pStartTime & 0xFFFFFFFF00000000) == 0xFFFFFFFF00000000) {
        dwRecordId = (DWORD)(*pStartTime & 0x00000000FFFFFFFF);
        LastTimeValue = *pStartTime;
        if (dwRecordId == 0) return PDH_ENTRY_NOT_IN_LOG_FILE;
    } else {
        dwRecordId = BINLOG_FIRST_DATA_RECORD;
    }

    pdhStatus = PdhiReadOneBinLogRecord (
        pLog,
        dwRecordId,
        NULL,
        0); // to prevent copying the record

    while ((pdhStatus == ERROR_SUCCESS) && (dwRecordId >= BINLOG_FIRST_DATA_RECORD)) {
        // define pointer to the current record
        pThisMasterRecord =
            (PPDHI_BINARY_LOG_RECORD_HEADER)
                pLog->pLastRecordRead;

        // get timestamp of this record by looking at the first entry in the
        // record.
        assert (pThisMasterRecord->dwType == BINLOG_TYPE_DATA);
        pThisSubRecord =
                (PPDHI_BINARY_LOG_RECORD_HEADER)((LPBYTE)pThisMasterRecord +
                sizeof (PDHI_BINARY_LOG_RECORD_HEADER));

        switch (pThisSubRecord->dwType) {
            case BINLOG_TYPE_DATA_SINGLE:
                pRawItem = (PPDH_RAW_COUNTER)((LPBYTE)pThisSubRecord +
                    sizeof (PDHI_BINARY_LOG_RECORD_HEADER));
                RecordTimeValue = MAKELONGLONG(
                                pRawItem->TimeStamp.dwLowDateTime,
                                pRawItem->TimeStamp.dwHighDateTime);
                break;

            case BINLOG_TYPE_DATA_MULTI:
                pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK)((LPBYTE)pThisSubRecord +
                    sizeof (PDHI_BINARY_LOG_RECORD_HEADER));
                RecordTimeValue = *(LONGLONG *)&pDataBlock->TimeStamp;
                break;

            default:
                // unknown record type
                assert (FALSE);
                RecordTimeValue = 0;
                break;
        }

        if (RecordTimeValue != 0) {
            if ((*pStartTime == RecordTimeValue) || (*pStartTime == 0)) {
                // found the match so bail here
                LastTimeValue = RecordTimeValue;
                break;

            } else if (RecordTimeValue > *pStartTime) {
                // then this is the first record > than the desired time
                // so the desired value is the one before this one
                // unless it's the first data record of the log
                if (dwRecordId > BINLOG_FIRST_DATA_RECORD) {
                    dwRecordId--;
                } else {
                    // this hasnt' been initialized yet.
                    LastTimeValue = RecordTimeValue;
                }
                break;
            } else {
                // save value for next trip through loop
                LastTimeValue = RecordTimeValue;
                // advance record counter and try the next entry
                dwRecordId++;
            }
        } else {
            // no timestamp field so ignore this record.
            dwRecordId++;
        }

        // read the next record in the file
        pdhStatus = PdhiReadOneBinLogRecord (
            pLog,
            dwRecordId,
            NULL,
            1); // to prevent copying the record
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // then dwRecordId is the desired entry
        *pdwIndex = dwRecordId;
        *pStartTime = LastTimeValue;
        pdhStatus = ERROR_SUCCESS;
    } else if (dwRecordId < BINLOG_FIRST_DATA_RECORD) {
        // handle special cases for log type field and header record
        *pdwIndex = dwRecordId;
        *pStartTime = LastTimeValue;
        pdhStatus = ERROR_SUCCESS;
    } else {
        pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiGetCounterFromDataBlock(
    IN PPDHI_LOG          pLog,
    IN PVOID              pDataBuffer,
    IN PPDHI_COUNTER      pCounter);

PDH_FUNCTION
PdhiGetCounterValueFromBinaryLog (
    IN  PPDHI_LOG           pLog,
    IN  DWORD               dwIndex,
    IN  PPDHI_COUNTER       pCounter
)
{
    PDH_STATUS       pdhStatus;
    PPDH_RAW_COUNTER pValue = & pCounter->ThisValue;

    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode

    pdhStatus = PdhiReadOneBinLogRecord(pLog, dwIndex, NULL, 0);

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetCounterFromDataBlock(pLog,
                                                pLog->pLastRecordRead,
                                                pCounter);
    } else {
        // no more records in log file
        pdhStatus = PDH_NO_MORE_DATA;
        // unable to find entry in the log file
        pValue->CStatus = PDH_CSTATUS_INVALID_DATA;
        pValue->TimeStamp.dwLowDateTime = pValue->TimeStamp.dwHighDateTime = 0;
        pValue->FirstValue = 0;
        pValue->SecondValue = 0;
        pValue->MultiCount = 1;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetTimeRangeFromBinaryLog (
    IN  PPDHI_LOG       pLog,
    IN  LPDWORD         pdwNumEntries,
    IN  PPDH_TIME_INFO  pInfo,
    IN  LPDWORD         pdwBufferSize
)
/*++
    the first entry in the buffer returned is the total time range covered
    in the file, if there are multiple time blocks in the log file, then
    subsequent entries will identify each segment in the file.
--*/
{
    PDH_STATUS  pdhStatus;
    LONGLONG    llStartTime = MAX_TIME_VALUE;
    LONGLONG    llEndTime = MIN_TIME_VALUE;
    LONGLONG    llThisTime = (LONGLONG)0;

    DWORD       dwThisRecord = BINLOG_FIRST_DATA_RECORD;
    DWORD       dwValidEntries = 0;

    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;

    PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;
    PPDH_RAW_COUNTER                pRawItem;

    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode

    pdhStatus = PdhiReadOneBinLogRecord (
                pLog,
                dwThisRecord,
                NULL, 0); // to prevent copying the record

    while (pdhStatus == ERROR_SUCCESS) {
        // define pointer to the current record
        pThisMasterRecord =
            (PPDHI_BINARY_LOG_RECORD_HEADER)
                pLog->pLastRecordRead;

        // get timestamp of this record by looking at the first entry in the
        // record.
        assert ((pThisMasterRecord->dwType & 0x0000FFFF) == BINLOG_START_WORD);

        if ((pThisMasterRecord->dwType & BINLOG_TYPE_DATA) == BINLOG_TYPE_DATA) {
            // only evaluate data records
            pThisSubRecord =
                    (PPDHI_BINARY_LOG_RECORD_HEADER)((LPBYTE)pThisMasterRecord +
                    sizeof (PDHI_BINARY_LOG_RECORD_HEADER));

            switch (pThisSubRecord->dwType) {
                case BINLOG_TYPE_DATA_SINGLE:
                    pRawItem = (PPDH_RAW_COUNTER)((LPBYTE)pThisSubRecord +
                        sizeof (PDHI_BINARY_LOG_RECORD_HEADER));
                    llThisTime = MAKELONGLONG(
                                    pRawItem->TimeStamp.dwLowDateTime,
                                    pRawItem->TimeStamp.dwHighDateTime);
                    break;

                case BINLOG_TYPE_DATA_MULTI:
                    pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK)((LPBYTE)pThisSubRecord +
                        sizeof (PDHI_BINARY_LOG_RECORD_HEADER));
                    llThisTime = MAKELONGLONG(
                                    pDataBlock->TimeStamp.dwLowDateTime,
                                    pDataBlock->TimeStamp.dwHighDateTime);
                    break;

                default:
                    // unknown record type
                    assert (FALSE);
                    llThisTime = 0;
                    break;
            }
        } else {
            llThisTime = 0;
        }

        if (llThisTime > 0) {

            if (llThisTime < llStartTime) {
                llStartTime = llThisTime;
            }

            if (llThisTime > llEndTime) {
                llEndTime = llThisTime;
            }

            dwValidEntries++;
        } else {
            // no timestamp field so ignore this record.
        }

        // read the next record in the file
        pdhStatus = PdhiReadOneBinLogRecord (
                    pLog,
                    ++dwThisRecord,
                    NULL, 0); // to prevent copying the record
    }

    if (pdhStatus == PDH_END_OF_LOG_FILE) {
        // clear out any temp values
        if (llStartTime == MAX_TIME_VALUE) llStartTime = 0;
        if (llEndTime == MIN_TIME_VALUE) llEndTime = 0;
        // then the whole file was read so update the args.
        if (*pdwBufferSize >=  sizeof(PDH_TIME_INFO)) {
            *(LONGLONG *)(&pInfo->StartTime) = llStartTime;
            *(LONGLONG *)(&pInfo->EndTime) = llEndTime;
            pInfo->SampleCount = dwValidEntries;
            *pdwBufferSize = sizeof(PDH_TIME_INFO);
            *pdwNumEntries = 1;
        } else {
            pdhStatus = PDH_MORE_DATA;
        }
        pdhStatus = ERROR_SUCCESS;
    } else {
        pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiReadRawBinaryLogRecord (
    IN  PPDHI_LOG    pLog,
    IN  FILETIME     *ftRecord,
    IN  PPDH_RAW_LOG_RECORD     pBuffer,
    IN  LPDWORD                 pdwBufferLength
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    LONGLONG    llStartTime;
    DWORD       dwIndex = 0;
    DWORD       dwSizeRequired;
    DWORD       dwLocalRecordLength; // including terminating NULL
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;

    llStartTime = *(LONGLONG *)ftRecord;

    pdhStatus = PdhiGetMatchingBinaryLogRecord (
        pLog,
        &llStartTime,
        &dwIndex);

    // copy results from internal log buffer if it'll fit.

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwIndex != BINLOG_TYPE_ID_RECORD) {
            // then record is a Binary log type
            pThisMasterRecord =
                (PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead;

            dwLocalRecordLength = pThisMasterRecord
                                ? pThisMasterRecord->dwLength : 0;

        } else {
            // this is a fixed size
            dwLocalRecordLength = pLog->dwRecord1Size;
        }

        dwSizeRequired =
              sizeof (PDH_RAW_LOG_RECORD) - sizeof (UCHAR)
            + dwLocalRecordLength;

        if (*pdwBufferLength >= dwSizeRequired) {
            pBuffer->dwRecordType = (DWORD)(LOWORD(pLog->dwLogFormat));
            pBuffer->dwItems = dwLocalRecordLength;
            // copy it
            if (dwLocalRecordLength > 0) {
                RtlCopyMemory(&pBuffer->RawBytes[0], pLog->pLastRecordRead,
                            dwLocalRecordLength);
            }
            pBuffer->dwStructureSize = dwSizeRequired;
        } else {
            pdhStatus = PDH_MORE_DATA;
        }

        *pdwBufferLength = dwSizeRequired;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiListHeaderFromBinaryLog (
    IN  PPDHI_LOG   pLogFile,
    IN  LPVOID      pBufferArg,
    IN  LPDWORD     pcchBufferSize,
    IN  BOOL        bUnicodeDest
)
{
    LPVOID      pTempBuffer = NULL;
    LPVOID      pOldBuffer;
    DWORD       dwTempBufferSize;

    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    // read the header record and enum the machine name from the entries

    if (pLogFile->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLogFile->dwMaxRecordSize = 0x010000;
    }

    dwTempBufferSize = pLogFile->dwMaxRecordSize;
    pTempBuffer = G_ALLOC (dwTempBufferSize);
    assert (pTempBuffer != NULL);
    if (pTempBuffer == NULL) {
        assert (GetLastError() == ERROR_SUCCESS);
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    // read in the catalog record

    while ((pdhStatus = PdhiReadOneBinLogRecord (pLogFile, BINLOG_HEADER_RECORD,
            pTempBuffer, dwTempBufferSize)) != ERROR_SUCCESS) {
        if (pdhStatus == PDH_MORE_DATA) {
            // read the 1st WORD to see if this is a valid record
            if (*(WORD *)pTempBuffer == BINLOG_START_WORD) {
                // it's a valid record so read the 2nd DWORD to get the
                // record size;
                dwTempBufferSize = ((DWORD *)pTempBuffer)[1];
                if (dwTempBufferSize < pLogFile->dwMaxRecordSize) {
                    // then something is bogus so return an error
                    pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                    break; // out of while loop
                } else {
                    pLogFile->dwMaxRecordSize = dwTempBufferSize;
                }
            } else {
                // we're lost in this file
                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                break; // out of while loop
            }
            // realloc a new buffer
            pOldBuffer = pTempBuffer;
            pTempBuffer = G_REALLOC (pOldBuffer, dwTempBufferSize);
            if (pTempBuffer == NULL) {
                // return memory error
                G_FREE(pOldBuffer);
                assert (GetLastError() == ERROR_SUCCESS);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            }
        } else {
            // some other error was returned so
            // return error from read function
            break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // walk down list and copy strings to msz buffer
        PPDHI_LOG_COUNTER_PATH          pPath;

        DWORD                           dwBytesProcessed;
        LONG                            nItemCount = 0;
        LPBYTE                          pFirstChar;
        PDH_COUNTER_PATH_ELEMENTS_W     pdhPathElem;
        WCHAR                           szPathString[1024];

        DWORD                   dwRecordLength;
        DWORD                   dwBufferUsed = 0;
        DWORD                   dwNewBuffer = 0;

        // we can assume the record was read successfully so read in the
        // machine names
        dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER)pTempBuffer)->dwLength;

        pPath = (PPDHI_LOG_COUNTER_PATH)
            ((LPBYTE)pTempBuffer + sizeof (PDHI_BINARY_LOG_HEADER_RECORD));
        dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

        while (dwBytesProcessed < dwRecordLength) {
            if (pPath->lMachineNameOffset >= 0L) {
                // then there's a machine name in this record so get
                // it's size
                memset (&pdhPathElem, 0, sizeof(pdhPathElem));
                pFirstChar = (LPBYTE)&pPath->Buffer[0];

                if (pPath->lMachineNameOffset >= 0) {
                    pdhPathElem.szMachineName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lMachineNameOffset);
                }
                if (pPath->lObjectNameOffset >= 0) {
                    pdhPathElem.szObjectName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lObjectNameOffset);
                }

                if (pPath->lInstanceOffset >= 0) {
                    pdhPathElem.szInstanceName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lInstanceOffset);
                }

                if (pPath->lParentOffset >= 0) {
                    pdhPathElem.szParentInstance = (LPWSTR)((LPBYTE)pFirstChar + pPath->lParentOffset);
                }

                if (pPath->dwIndex == 0) {
                    // don't display #0 in path
                    pdhPathElem.dwInstanceIndex = (DWORD)-1;
                } else {
                    pdhPathElem.dwInstanceIndex = pPath->dwIndex;
                }

                if (pPath->lCounterOffset >= 0) {
                    pdhPathElem.szCounterName = (LPWSTR)((LPBYTE)pFirstChar + pPath->lCounterOffset);
                }

                dwNewBuffer = sizeof (szPathString) / sizeof(szPathString[0]);

                pdhStatus = PdhMakeCounterPathW (
                    &pdhPathElem,
                    szPathString,
                    &dwNewBuffer,
                    0);

                if (pdhStatus == ERROR_SUCCESS) {
                    if (pBufferArg != NULL) {
                        // copy string to the buffer
                        if ((dwBufferUsed + dwNewBuffer) < *pcchBufferSize) {
                            dwNewBuffer = AddUniqueWideStringToMultiSz (
                                (LPVOID)pBufferArg,
                                szPathString,
                                bUnicodeDest);
                        } else {
                            // this one won't fit, so set the status
                            pdhStatus = PDH_MORE_DATA;

                            // and update the size required to return
                            // add in size of the delimiter
                            dwNewBuffer++;
                            // update the size of the string required
                            dwNewBuffer = dwBufferUsed + dwNewBuffer;
                            nItemCount++;
                        }
                        if (dwNewBuffer > 0) {
                            // string was added so update size used.
                            dwBufferUsed = dwNewBuffer;
                            nItemCount++;
                        }
                    } else {
                        // add in size of the delimiter
                        dwNewBuffer++;
                        // add size of this string to the size required
                        dwBufferUsed += dwNewBuffer;
                        nItemCount++;
                    }
                } // else ignore this entry
            }
            // get next path entry from log file record
            dwBytesProcessed += pPath->dwLength;
            pPath = (PPDHI_LOG_COUNTER_PATH)
                ((LPBYTE)pPath + pPath->dwLength);
        }

        if ((nItemCount > 0)  && (pdhStatus != PDH_INSUFFICIENT_BUFFER)
                              && (pdhStatus != PDH_MORE_DATA)) {
            // then the routine was successful. Errors that occurred
            // while scanning will be ignored as long as at least
            // one entry was successfully read
            pdhStatus = ERROR_SUCCESS;
        }

        if (pBufferArg == NULL) {
            // add in size of MSZ null;
            // (AddUnique... already includes this in the return value
            dwBufferUsed++;
        }

        // update the buffer used or required.
        *pcchBufferSize = dwBufferUsed;

   }

   if (pTempBuffer != NULL) G_FREE (pTempBuffer);

   return pdhStatus;

}

PDH_FUNCTION
PdhiGetCounterArrayFromBinaryLog (
    IN PPDHI_LOG                        pLog,
    IN DWORD                            dwIndex,
    IN PPDHI_COUNTER                    pCounter,
    IN OUT PPDHI_RAW_COUNTER_ITEM_BLOCK     *ppValue
)
{
    PDH_STATUS  pdhStatus;

    DWORD       dwDataItemIndex;

    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;

    PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;

    PPDHI_RAW_COUNTER_ITEM_BLOCK    pNewArrayHeader;

    // allocate a new array for
    // update counter's Current counter array contents

    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode

    pdhStatus = PdhiReadOneBinLogRecord (
        pLog,
        dwIndex,
        NULL, 0); // to prevent copying the record

    if (pdhStatus == ERROR_SUCCESS) {
        // define pointer to the current record
        pThisMasterRecord =
            (PPDHI_BINARY_LOG_RECORD_HEADER)
                pLog->pLastRecordRead;

        // get timestamp of this record by looking at the first entry in the
        // record.
        if (pThisMasterRecord->dwType != BINLOG_TYPE_DATA) return PDH_NO_MORE_DATA;

        pThisSubRecord = PdhiGetSubRecord (
                pThisMasterRecord,
                pCounter->plCounterInfo.dwCounterId);

        if (pThisSubRecord != NULL) {
            switch (pThisSubRecord->dwType) {
                case BINLOG_TYPE_DATA_SINGLE:
                    // return data as one instance
                    // for now this isn't supported as it won't be hit.
                    //
                    break;

                case BINLOG_TYPE_DATA_MULTI:
                    // cast pointer to this part of the data record
                    pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK)((LPBYTE)pThisSubRecord +
                        sizeof (PDHI_BINARY_LOG_RECORD_HEADER));

                    // allocate a new buffer for the data
                    pNewArrayHeader = (PPDHI_RAW_COUNTER_ITEM_BLOCK) G_ALLOC (pDataBlock->dwLength);

                    if (pNewArrayHeader != NULL) {
                        // copy the log record to the local buffer
                        RtlCopyMemory(pNewArrayHeader, pDataBlock, pDataBlock->dwLength);
                        // convert offsets to pointers
                        for (dwDataItemIndex = 0; 
                             dwDataItemIndex < pNewArrayHeader->dwItemCount; 
                             dwDataItemIndex++) {
                            // add in the address of the base of the structure
                            // to the offset stored in the field
                            pNewArrayHeader->pItemArray[dwDataItemIndex].szName =
                                    pNewArrayHeader->pItemArray[dwDataItemIndex].szName;
                        }
                        // clear any old buffers
                        if (pCounter->pThisRawItemList != NULL) {
                            G_FREE(pCounter->pThisRawItemList);
                            pCounter->pThisRawItemList = NULL;
                        }
                        pCounter->pThisRawItemList = pNewArrayHeader;
                        *ppValue = pNewArrayHeader;
                    } else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                    break;

                default:
                    pdhStatus = PDH_LOG_TYPE_NOT_FOUND;
                    break;
            }
        } else {
            // entry not found in record
            pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
        }
    } else {
        // no more records in log file
        pdhStatus = PDH_NO_MORE_DATA;
    }

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhdll\vbfuncs.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    vbfuncs.c

Abstract:

    Visual Basic interface functions exposed in pdh.dll

--*/
#include <windows.h>
#include <winperf.h>
#include <pdh.h>
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"

#define INITIAL_VB_LIST_SIZE    (4096 * 4)
#define EXTEND_VB_LIST_SIZE     (4096 * 2)

typedef struct _VB_STRING_LIST {
    LPSTR   mszList;        // pointer to buffer containing strings
    LPSTR   szTermChar;     // pointer to "next" char to use
    DWORD   dwNumEntries;   // number of strings
    DWORD   dwSize;         // max size (in chars) of buffer
    DWORD   dwRemaining;    // # of chars left
    DWORD   dwLastEntryRead; // index of last string read indicating index of....
    DWORD   dwLastItemLength; // length of last item read
    LPSTR   szLastItemRead; // pointer to START of last item read
} VB_STRING_LIST, FAR * LPVB_STRING_LIST;

VB_STRING_LIST PdhivbList = {NULL, NULL, 0, 0, 0};
void PdhiDialogCallBack(  IN  DWORD_PTR   dwArg );

BOOL
PdhiAddStringToVbList (
    IN  LPSTR   szString
);



BOOL
PdhiAddStringToVbList (
    IN  LPSTR   szString
)
{
    DWORD   dwSize1, dwSize2;
    VB_STRING_LIST *pVbList;

    dwSize1 =  lstrlen(szString) + 1;
    pVbList =  &PdhivbList;
    if (dwSize1 > pVbList->dwRemaining) {
        dwSize2 = (DWORD)(pVbList->szTermChar - pVbList->mszList);
        pVbList->dwSize += EXTEND_VB_LIST_SIZE;
        pVbList->mszList = G_REALLOC (pVbList->mszList, pVbList->dwSize);
        if (pVbList->mszList == NULL) {
            memset(pVbList, 0, sizeof(VB_STRING_LIST));
            return FALSE;
        } else {
            // update values
            pVbList->szLastItemRead = pVbList->mszList;
            pVbList->szTermChar = pVbList->mszList + dwSize2;
            pVbList->dwRemaining += EXTEND_VB_LIST_SIZE;
        }
    }
    // copy new string
    lstrcpy (pVbList->szTermChar, szString);
    pVbList->dwNumEntries++;
    pVbList->szTermChar += dwSize1;
    pVbList->dwRemaining -= dwSize1;

    return TRUE;
}

void
PdhiDialogCallBack(
    IN  DWORD_PTR   dwArg
)
{
    // add strings in buffer to list boxpfdh
    LPTSTR         NewCounterName;
    LPTSTR         NewCounterName2;
    LPTSTR         szExpandedPath;
    DWORD          dwSize1, dwSize2;
    PDH_STATUS    pdhStatus = ERROR_SUCCESS;
    PPDH_BROWSE_DLG_CONFIG    pDlgConfig;

    pDlgConfig = (PPDH_BROWSE_DLG_CONFIG)dwArg;

    if (pDlgConfig->CallBackStatus == PDH_MORE_DATA) {
        // transfer buffer is too small for selection so extend it and
        // try again.
        if (pDlgConfig->szReturnPathBuffer != NULL) {
            G_FREE (pDlgConfig->szReturnPathBuffer);
        }
        pDlgConfig->cchReturnPathLength += EXTEND_VB_LIST_SIZE;
        pDlgConfig->szReturnPathBuffer =
            G_ALLOC ((pDlgConfig->cchReturnPathLength * sizeof (CHAR)));

        if (pDlgConfig->szReturnPathBuffer != NULL) {
            pdhStatus = PDH_RETRY;
        } else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    } else {
        for (NewCounterName = pDlgConfig->szReturnPathBuffer;
            (*NewCounterName != 0) && (pdhStatus == ERROR_SUCCESS);
            NewCounterName += (lstrlen(NewCounterName) + 1)) {
            if (strstr (NewCounterName, caszSplat) == NULL) {
                // this is a regular path entry so add it to the VB List
                if (!PdhiAddStringToVbList (NewCounterName)) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            } else {
                szExpandedPath = G_ALLOC (INITIAL_VB_LIST_SIZE);
                if (szExpandedPath != NULL) {
                    // there's a wild card path character so expand it then enter them
                    // clear the list buffer
                    *(LPDWORD)szExpandedPath = 0;
                    dwSize1 = dwSize2 = INITIAL_VB_LIST_SIZE;
                    PdhExpandCounterPath (NewCounterName, szExpandedPath, &dwSize2);
                    if (dwSize2 < dwSize1) {
                        // then the returned buffer fit
                        for (NewCounterName2 = szExpandedPath;
                            *NewCounterName2 != 0;
                            NewCounterName2 += (lstrlen(NewCounterName2) + 1)) {

                            if (!PdhiAddStringToVbList (NewCounterName2)) {
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                break; //out of loop
                            }
                        }
                    } else {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                    G_FREE (szExpandedPath);
                } else {
                    SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
                }
            }
        }
        // clear buffer
        memset (pDlgConfig->szReturnPathBuffer, 0,
            (pDlgConfig->cchReturnPathLength * sizeof(CHAR)));
    }
    pDlgConfig->CallBackStatus = pdhStatus;
    return;
}

double
PdhVbGetDoubleCounterValue (
    IN  HCOUNTER    hCounter,
    IN  LPDWORD     pdwCounterStatus
)
/*++

Routine Description:

    retrieves the current value of the specified counter and returns the
        formatted version to the caller.

Arguments:

    IN  HCOUNTER hCounter
        pointer to the counter to get the data for

    IN LPDWORD  pdwCounterStatus
        status value of this counter. This value should be checked to
        insure the data is valid. If the status is not successful, then
        the data returned cannot be trusted and should not be used

Return Value:

    a double precesion floating point value of the current counter value
        formatted and computed as required by the counter type.

--*/
{
    PDH_STATUS  pdhStatus;
    PDH_FMT_COUNTERVALUE    pdhValue;
    DWORD       dwCounterType;
    double    dReturn;

    pdhStatus = PdhGetFormattedCounterValue (
        hCounter, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &dwCounterType, &pdhValue);

    if (pdhStatus == ERROR_SUCCESS) {
        // the function was successful so return the counter status
        // and the returned value
        pdhStatus = pdhValue.CStatus;
        dReturn = pdhValue.doubleValue;
    } else {
        // the function returned an error so return the
        // error in the status field & 0.0 for a value
        dReturn = 0.0f;
    }

    if (pdwCounterStatus != NULL) {
        __try {
            *pdwCounterStatus = pdhStatus;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            // unable to write to status variable
            // don't worry about it, since it's optional and there's not much
            // we can do here anyway.
        }
    }
    return dReturn;
}

DWORD
PdhVbGetOneCounterPath (
    IN  LPSTR   szPathBuffer,
    IN  DWORD   cchBufferLength,
    IN  DWORD   dwDetailLevel,
    IN  LPCSTR  szCaption
)
/*++

Routine Description:

    Retrieves one path string from the buffer of stored counter paths
        assembled by the most recent call to PdhVbCreateCounterPathList

Arguments:

    LPSTR   szPathBuffer
        string buffer to return selected counter path in

    DWORD   cchBufferLength
        size of string buffer in characters

    DWORD   dwDetailLevel
        detail level to filter the counters by

    LPCSTR  szCaption
        string to display in the caption bar

Return Value:

    returns the length of the path string in characters returned
        to the caller.

--*/
{
    PDH_BROWSE_DLG_CONFIG_A BrowseConfig;
    PDH_STATUS      PdhStatus = ERROR_SUCCESS;
    DWORD           dwReturn = 0;

    // test access to caller supplied buffer
    __try {
        CHAR cChar;
        if ((cchBufferLength > 0) && (szPathBuffer != NULL)) {
            cChar = szPathBuffer[0];
            szPathBuffer[0] = 0;
            szPathBuffer[0] = cChar;

            cChar = szPathBuffer[cchBufferLength - 1];
            szPathBuffer[cchBufferLength - 1] = 0;
            szPathBuffer[cchBufferLength - 1] = cChar;
        } else {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }

        if (szCaption != NULL) {
            cChar = *((CHAR volatile *)szCaption);
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (PdhStatus == ERROR_SUCCESS) {
        memset (&BrowseConfig, 0, sizeof(BrowseConfig));
        BrowseConfig.bIncludeInstanceIndex = FALSE;
        BrowseConfig.bSingleCounterPerAdd = TRUE;
        BrowseConfig.bSingleCounterPerDialog = TRUE;
        BrowseConfig.bLocalCountersOnly = FALSE;
        BrowseConfig.bWildCardInstances = FALSE;
        BrowseConfig.bDisableMachineSelection = FALSE;
        BrowseConfig.bHideDetailBox = (dwDetailLevel > 0 ? TRUE : FALSE);

        BrowseConfig.hWndOwner = NULL;  // there should be some way to get this

        BrowseConfig.szReturnPathBuffer = szPathBuffer;
        BrowseConfig.cchReturnPathLength = cchBufferLength;

        BrowseConfig.pCallBack = NULL;
        BrowseConfig.dwCallBackArg = 0;

        // default is to show ALL counters
        BrowseConfig.dwDefaultDetailLevel = (dwDetailLevel > 0 ?
            dwDetailLevel : PERF_DETAIL_WIZARD);

        BrowseConfig.szDialogBoxCaption = (LPSTR)szCaption;

        PdhStatus = PdhBrowseCountersA (&BrowseConfig);
    }

    if (PdhStatus == ERROR_SUCCESS) {
        dwReturn = lstrlenA (szPathBuffer);
    } else {
        dwReturn = 0;
    }
    return dwReturn;
}

DWORD
PdhVbCreateCounterPathList (
    IN  DWORD       dwDetailLevel,
    IN  LPCSTR      szCaption
)
/*++

Routine Description:

    Displays the counter browsing dialog box and allows the user to select
        multiple counter paths. As the paths are selected, they are stored
        in an internal buffer for later retrieval by the caller.

    NOTE, that calling this function will clear any previous selections.

Arguments:

    DWORD   dwDetailLevel
        detail level to filter the counters by

    LPCSTR  szCaption
        string to display in the caption bar

Return Value:

    returns the number of path strings selected by the user that must
        be retrieved by the caller.

--*/
{
    PDH_STATUS              PdhStatus = ERROR_SUCCESS;
    PDH_BROWSE_DLG_CONFIG_A BrowseConfig;
    DWORD                   dwReturn = 0;

    // test access to caller supplied buffer
    __try {
        CHAR cChar;
        if (szCaption != NULL) {
            cChar = *((CHAR volatile *)szCaption);
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (PdhStatus == ERROR_SUCCESS) {
        if (PdhivbList.mszList != NULL) {
            G_FREE (PdhivbList.mszList);
            memset ((LPVOID)&PdhivbList, 0, sizeof (VB_STRING_LIST));
        }

        PdhivbList.mszList = G_ALLOC (INITIAL_VB_LIST_SIZE);
        if (PdhivbList.mszList != NULL) {
            PdhivbList.szLastItemRead =
                PdhivbList.szTermChar = PdhivbList.mszList;
            PdhivbList.dwRemaining =
                PdhivbList.dwSize = INITIAL_VB_LIST_SIZE;
            PdhivbList.dwLastEntryRead = 0;
            PdhivbList.dwLastItemLength = 0;
        } else {
            PdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }

    if (PdhStatus == ERROR_SUCCESS) {
        memset (&BrowseConfig, 0, sizeof(BrowseConfig));
        BrowseConfig.bIncludeInstanceIndex = FALSE;
        BrowseConfig.bSingleCounterPerAdd = FALSE;
        BrowseConfig.bSingleCounterPerDialog = FALSE;
        BrowseConfig.bLocalCountersOnly = FALSE;
        BrowseConfig.bWildCardInstances = FALSE;
        BrowseConfig.bDisableMachineSelection = FALSE;
        BrowseConfig.bHideDetailBox = (dwDetailLevel > 0 ? TRUE : FALSE);

        BrowseConfig.hWndOwner = NULL;  // there should be some way to get this

        BrowseConfig.szReturnPathBuffer = G_ALLOC (INITIAL_VB_LIST_SIZE);
        if (BrowseConfig.szReturnPathBuffer != NULL) {
            BrowseConfig.cchReturnPathLength = (BrowseConfig.szReturnPathBuffer != NULL ?
                INITIAL_VB_LIST_SIZE : 0);

            BrowseConfig.pCallBack = (CounterPathCallBack)PdhiDialogCallBack;
            BrowseConfig.dwCallBackArg = (DWORD_PTR)&BrowseConfig;

            // default is to show ALL counters
            BrowseConfig.dwDefaultDetailLevel = (dwDetailLevel > 0 ?
                dwDetailLevel : PERF_DETAIL_WIZARD);

            BrowseConfig.szDialogBoxCaption = (LPSTR)szCaption;

            PdhStatus = PdhBrowseCountersA (&BrowseConfig);

            if (BrowseConfig.szReturnPathBuffer != NULL) {
                G_FREE (BrowseConfig.szReturnPathBuffer);
            }
            dwReturn = PdhivbList.dwNumEntries;
        } else {
            SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
            dwReturn = 0;
        }
    }

    return dwReturn;
}

DWORD
PdhVbGetCounterPathFromList (
    IN  DWORD       dwIndex,    // starting at 1 for VB types
    IN  LPSTR       szBuffer,   // return buffer
    IN  DWORD       dwBufferSize   // size in chars of buffer
)
/*++

Routine Description:

    Displays the counter browsing dialog box and allows the user to select
        multiple counter paths. As the paths are selected, they are stored
        in an internal buffer for later retrieval by the caller.

    NOTE, that calling this function will clear any previous selections.

Arguments:

    DWORD       dwIndex
        The "1-based" index of the counter path to retrieve from
        the list of selected counter paths generated by the previous
        call to PdhVbCreateCounterPathList.

    LPSTR       szBuffer
        string buffer to return the selected string in

    DWORD       dwBufferSize
        size of the szBuffer in characters

Return Value:

    Returns the number of characters copied to the calling function

--*/
{
    DWORD       dwBuffIndex;    // 0-based index for "c"
    DWORD       dwThisIndex;
    DWORD       dwCharsCopied;  // size of string not counting term NULL
    BOOL        bContinue = TRUE;

    dwBuffIndex = dwIndex - 1;
    dwCharsCopied = 0;

    // validate the arguments

    __try {
        if (dwBufferSize > 0) {
            // try writing to ouput buffer
            szBuffer[0] = 0;
            szBuffer[dwBufferSize-1] = 0;
        } else {
            bContinue = FALSE;
        }
        if (dwBuffIndex >= PdhivbList.dwNumEntries) {
            bContinue = FALSE;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        bContinue = FALSE;
    }

    if (bContinue) {
        if (PdhivbList.szLastItemRead == NULL) {
            PdhivbList.szLastItemRead   = PdhivbList.mszList;
            PdhivbList.dwLastEntryRead  = 0;
            PdhivbList.dwLastItemLength = 0;
        }
        if (PdhivbList.szLastItemRead != NULL) {
            if (PdhivbList.dwLastItemLength == 0) {
                PdhivbList.dwLastItemLength =
                        lstrlen(PdhivbList.szLastItemRead) + 1;
            }
        }
        else {
            bContinue = FALSE;
        }
    }

    if (bContinue) {
        // see if this is the next entry
        if (dwBuffIndex == (PdhivbList.dwLastEntryRead + 1)) {
            PdhivbList.szLastItemRead += PdhivbList.dwLastItemLength;
            PdhivbList.dwLastItemLength = lstrlen(PdhivbList.szLastItemRead) + 1;
            PdhivbList.dwLastEntryRead++;
            if (PdhivbList.dwLastItemLength < dwBufferSize) {
                lstrcpy (szBuffer, PdhivbList.szLastItemRead);
                dwCharsCopied = PdhivbList.dwLastItemLength -1;
            }
        } else if  (dwBuffIndex == PdhivbList.dwLastEntryRead) {
            // it's this one (again)
            if (PdhivbList.dwLastItemLength < dwBufferSize) {
                lstrcpy (szBuffer, PdhivbList.szLastItemRead);
                dwCharsCopied = PdhivbList.dwLastItemLength -1;
            }
        } else {
            // walk the list to the desired entry (ugh!)
            PdhivbList.szLastItemRead = PdhivbList.mszList;
            for (dwThisIndex = 0; dwThisIndex < dwBuffIndex; dwThisIndex++) {
                PdhivbList.szLastItemRead += lstrlen (PdhivbList.szLastItemRead) + 1;
            }
            PdhivbList.dwLastItemLength = lstrlen(PdhivbList.szLastItemRead) + 1;
            PdhivbList.dwLastEntryRead = dwThisIndex;
            if (PdhivbList.dwLastItemLength < dwBufferSize) {
                lstrcpy (szBuffer, PdhivbList.szLastItemRead);
                dwCharsCopied = PdhivbList.dwLastItemLength -1;
            }
        }
    }
    return dwCharsCopied;
}

DWORD
PdhVbGetCounterPathElements (
    IN  LPCSTR  szPathString,
    IN  LPSTR   szMachineName,
    IN  LPSTR   szObjectName,
    IN  LPSTR   szInstanceName,
    IN  LPSTR   szParentInstance,
    IN  LPSTR   szCounterName,
    IN  DWORD   dwBufferSize
)
/*++

Routine Description:

    breaks the counter path provided in the szPathString argument and
        returns the components in the buffers provided by the caller.
        The buffers must be at least "dwBufferSize" in length.

Arguments:

    LPCSTR  szPathString
        pointer to the full counter path that is to be parsed into
        component strings

    LPSTR   szMachineName
        caller supplied buffer that is to receive the machine name.
        The buffer must be at least dwBufferSize in length.

    LPSTR   szObjectName
        caller supplied buffer that is to receive the object name.
        The buffer must be at least dwBufferSize in length.

    LPSTR   szInstanceName
        caller supplied buffer that is to receive the Instance name.
        The buffer must be at least dwBufferSize in length.

    LPSTR   szParentInstance
        caller supplied buffer that is to receive the parent instance name.
        The buffer must be at least dwBufferSize in length.

    LPSTR   szCounterName
        caller supplied buffer that is to receive the counter name.
        The buffer must be at least dwBufferSize in length.

    DWORD   dwBufferSize
        The buffer size of the caller supplied string buffers in characters


Return Value:

    ERROR_SUCCESS if the counter string is successfully parsed, otherwise
        a PDH error if not.

    PDH_INVALID_ARGUMENT if one or more of the string buffers is not
        the correct size
    PDH_INSUFFICIENT_BUFFER if one or more of the counter path elements
        is too large for the return buffer length.
    PDH_MEMORY_ALLOCATION_FAILURE if a temporary memory buffer could not
        be allocated.
--*/
{
    PPDH_COUNTER_PATH_ELEMENTS_A pInfo;
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    DWORD               dwSize;

    // validate the return arguments
    __try {
        CHAR    cChar;
        if (szPathString != NULL) {
            cChar = *((CHAR volatile *)szPathString);
            if (cChar == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } else {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        if (pdhStatus == ERROR_SUCCESS){
            if (szMachineName != NULL) {
                szMachineName[0] = 0;
                szMachineName[dwBufferSize-1] = 0;
            } else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }

        if (pdhStatus == ERROR_SUCCESS){
            if (szObjectName != NULL) {
                szObjectName[0] = 0;
                szObjectName[dwBufferSize-1] = 0;
            } else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }

        if (pdhStatus == ERROR_SUCCESS){
            if (szInstanceName != NULL) {
                szInstanceName[0] = 0;
                szInstanceName[dwBufferSize-1] = 0;
            } else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }

        if (pdhStatus == ERROR_SUCCESS){
            if (szParentInstance != NULL) {
                szParentInstance[0] = 0;
                szParentInstance[dwBufferSize-1] = 0;
            } else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }


        if (pdhStatus == ERROR_SUCCESS){
            if (szCounterName != NULL) {
                szCounterName[0] = 0;
                szCounterName[dwBufferSize-1] = 0;
            } else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // allocate temp buffer for component strings
        dwSize = (5 * dwBufferSize) + sizeof (PDH_COUNTER_INFO_A);
        pInfo = G_ALLOC (dwSize);
        if (pInfo != NULL) {
            pdhStatus = PdhParseCounterPathA (
                szPathString,
                pInfo,
                &dwSize,
                0);

            if (pdhStatus == ERROR_SUCCESS) {
                // move from local structure to user args if the strings will fit
                if (pInfo->szMachineName != NULL) {
                    if ((DWORD)lstrlenA(pInfo->szMachineName) < dwBufferSize) {
                        lstrcpyA (szMachineName, pInfo->szMachineName);
                    } else {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                }

                if (pInfo->szObjectName != NULL) {
                    if ((DWORD)lstrlenA(pInfo->szObjectName) < dwBufferSize) {
                        lstrcpyA (szObjectName, pInfo->szObjectName);
                    } else {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                }

                if (pInfo->szInstanceName != NULL) {
                    if ((DWORD)lstrlenA(pInfo->szInstanceName) < dwBufferSize) {
                        lstrcpyA (szInstanceName, pInfo->szInstanceName);
                    } else {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                }

                if (pInfo->szParentInstance != NULL) {
                    if ((DWORD)lstrlenA(pInfo->szParentInstance) < dwBufferSize) {
                        lstrcpyA (szParentInstance, pInfo->szParentInstance);
                    } else {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                }

                if (pInfo->szCounterName != NULL) {
                    if ((DWORD)lstrlenA(pInfo->szCounterName) < dwBufferSize) {
                        lstrcpyA (szCounterName, pInfo->szCounterName);
                    } else {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                }
            } // else pass error to caller
            G_FREE (pInfo);
        } else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    } // else pass error to caller

    return pdhStatus;
}

DWORD
PdhVbAddCounter (
    IN  HQUERY  hQuery,
    IN  LPCSTR  szFullCounterPath,
    IN  HCOUNTER    *hCounter
)
/*++

Routine Description:

    Creates and initializes a counter structure and attaches it to the
        specified query by calling the C function.

Arguments:

    IN  HQUERY  hQuery
        handle of the query to attach this counter to once the counter
        entry has been successfully created.

    IN  LPCSTR szFullCounterPath
        pointer to the path string that describes the counter to add to
        the query referenced above. This string must specify a single
        counter. Wildcard path strings are not permitted.

    IN  HCOUNTER *phCounter
        pointer to the buffer that will get the handle value of the
        successfully created counter entry.

Return Value:

    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.

    PDH_INVALID_ARGUMENT is returned when one or more of the arguements
        is invalid or incorrect.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a memory buffer could
        not be allocated.
    PDH_INVALID_HANDLE is returned if the query handle is not valid.
    PDH_CSTATUS_NO_COUNTER is returned if the specified counter was
        not found
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found
    PDH_CSTATUS_NO_MACHINE is returned if a machine entry could not
        be created.
    PDH_CSTATUS_BAD_COUNTERNAME is returned if the counter name path
        string could not be parsed or interpreted
    PDH_CSTATUS_NO_COUNTERNAME is returned if an empty counter name
        path string is passed in
    PDH_FUNCTION_NOT_FOUND is returned if the calculation function
        for this counter could not be determined.

--*/
{
    DWORD       dwReturn = ERROR_SUCCESS;
    HCOUNTER    hLocalCounter = NULL;

    if ((hCounter == NULL) || (szFullCounterPath == NULL)) {
        dwReturn = PDH_INVALID_ARGUMENT;
    } else {
        dwReturn = PdhAddCounterA (hQuery, szFullCounterPath, 0, &hLocalCounter);
    }

    if (dwReturn == ERROR_SUCCESS) {
        __try {
            * hCounter = hLocalCounter;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    }
    return dwReturn;
}

DWORD
PdhVbOpenQuery (
    IN  HQUERY  *phQuery
)
/*++

Routine Description:

    allocates a new query structure for a VB app by calling the "C"
    function with the rest of the arguments supplied

Arguments:

    IN  HQUERY  *phQuery
        pointer to the buffer that will receive the query handle opened.

Return Value:

    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.

    PDH_INVALID_ARGUMENT is returned when one or more of the arguements
        is invalid or incorrect.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a memory buffer could
        not be allocated.

--*/
{
    DWORD   dwReturn = ERROR_SUCCESS;
    HQUERY  hLocalQuery = NULL;

    if (phQuery == NULL) {
        dwReturn = PDH_INVALID_ARGUMENT;
    } else {
        dwReturn = PdhOpenQuery(NULL, 0, &hLocalQuery);
    }

    if (dwReturn == ERROR_SUCCESS) {
        __try {
            * phQuery = hLocalQuery;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    }

    return dwReturn;
}

DWORD
PdhVbIsGoodStatus (
    IN  LONG lStatus
)
/*++

Routine Description:

    Checks the status severity of the PDH status value
    passed into the function as a binary Good (TRUE)/Bad (FALSE)
    value.

Arguments:

    IN  LONG lStatus
        Status code to test

Return Value:

    TRUE if the status code is Success or Informational severity
    FALSE if the status code is Error or Warning severity

--*/
{
    BOOL   bReturn;

    if (lStatus == ERROR_SUCCESS) {
        bReturn = TRUE;
    } else if (IsSuccessSeverity(lStatus)) {
        bReturn = TRUE;
    } else if (IsInformationalSeverity(lStatus)) {
        bReturn = TRUE;
    } else {
        bReturn = FALSE;
    }

    return (DWORD)bReturn;
}

DWORD
PdhVbOpenLog (
    IN      LPCSTR  szLogFileName,
    IN      DWORD   dwAccessFlags,
    IN      LPDWORD lpdwLogType,
    IN      HQUERY  hQuery,
    IN      DWORD   dwMaxSize,
    IN      LPCSTR  szUserCaption,
    IN      HLOG    *phLog
)
/*++

Routine Description:



Arguments:

    IN      LPCSTR  szLogFileName,
    IN      DWORD   dwAccessFlags,
    IN      LPDWORD lpdwLogType,
    IN      HQUERY  hQuery,
    IN      DWORD   dwMaxSize,
    IN      LPCSTR  szUserCaption,
    IN      HLOG    *phLog

Return Value:

    TRUE if the status code is Success or Informational severity
    FALSE if the status code is Error or Warning severity

--*/
{

    return PdhOpenLogA( szLogFileName,
                        dwAccessFlags,
                        lpdwLogType,
                        hQuery,
                        dwMaxSize,
                        szUserCaption,
                        phLog
                      );
}

DWORD
PdhVbUpdateLog (
    IN      HLOG    hLog,
    IN      LPCSTR szUserString
)
/*++

Routine Description:



Arguments:

    IN      HLOG    hLog,
    IN      LPCWSTR szUserString

Return Value:

    TRUE if the status code is Success or Informational severity
    FALSE if the status code is Error or Warning severity

--*/
{

    return PdhUpdateLogA(hLog,
                         szUserString
                         );
}

DWORD 
PdhVbGetLogFileSize (
    IN      HLOG        hLog,
    IN      LONG        *lSize      
)
/*++

Routine Description:



Arguments:

    IN      HLOG        hLog,
    IN      LONGLONG    *llSize     

Return Value:

    TRUE if the status code is Success or Informational severity
    FALSE if the status code is Error or Warning severity

--*/
{
    PDH_STATUS pdhStatus;
    LONGLONG    llTemp;

    pdhStatus = PdhGetLogFileSize(hLog,
                             &llTemp);

    if (pdhStatus == ERROR_SUCCESS) {
        if (llTemp > 0x0000000080000000) {
            // file size is larger than a long value
            pdhStatus = PDH_INSUFFICIENT_BUFFER;
        } else {
            __try {
                *lSize = (LONG)(llTemp & 0x000000007FFFFFFF);
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log_bin.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    log_bin.h

Abstract:

    <abstract>

--*/

#ifndef _LOG_BIN_H_
#define _LOG_BIN_H_

// define record locations in the file
#define BINLOG_TYPE_ID_RECORD       ((DWORD)1)
#define BINLOG_HEADER_RECORD        ((DWORD)2)
#define BINLOG_FIRST_DATA_RECORD    ((DWORD)3)

// Record type definition
// low WORD of the type header field is "BL" to help re-sync records
// that may have been corrupted
#define BINLOG_START_WORD       ((WORD)0x4C42)
#define BINLOG_TYPE_HEADER      ((DWORD)(0x00010000 | (DWORD)(BINLOG_START_WORD)))
#define BINLOG_TYPE_CATALOG     ((DWORD)(0x00020000 | (DWORD)(BINLOG_START_WORD)))
#define BINLOG_TYPE_CATALOG_LIST ((DWORD)(0x01020000 | (DWORD)(BINLOG_START_WORD)))
#define BINLOG_TYPE_CATALOG_HEAD ((DWORD)(0x02020000 | (DWORD)(BINLOG_START_WORD)))
#define BINLOG_TYPE_CATALOG_ITEM ((DWORD)(0x03020000 | (DWORD)(BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA        ((DWORD)(0x00030000 | (DWORD)(BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA_SINGLE ((DWORD)(0x01030000 | (DWORD)(BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA_MULTI  ((DWORD)(0x02030000 | (DWORD)(BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA_PSEUDO ((DWORD)(0x03030000 | (DWORD)(BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA_OBJECT ((DWORD)(0x04030000 | (DWORD)(BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA_LOC_OBJECT ((DWORD)(0x05030000 | (DWORD)(BINLOG_START_WORD)))

#define BINLOG_VERSION          ((DWORD)(0x000005ff))  // debug value for now

//
//  this is the field at the beginning of each record in the log file
//  after the text log file type record
//
typedef struct _PDHI_BINARY_LOG_RECORD_HEADER {
    DWORD    dwType;
    DWORD   dwLength;
} PDHI_BINARY_LOG_RECORD_HEADER, *PPDHI_BINARY_LOG_RECORD_HEADER;

//
// the first data record after the log file type record is
// an information record followed by the list of counters contained in this
// log file. the record length is the size of the info header record and
// all the counter info blocks in bytes.
// note that this record can occur later in the log file if the query
// is changed or the log file is appended.
//
typedef struct _PDHI_BINARY_LOG_INFO {
    LONGLONG    FileLength;         // file space allocated (optional)
    DWORD       dwLogVersion;       // version stamp
    DWORD       dwFlags;            // option flags
    LONGLONG    StartTime;
    LONGLONG    EndTime;
    LONGLONG    CatalogOffset;      // offset in file to wild card catalog
    LONGLONG    CatalogChecksum;    // checksum of catalog header
    LONGLONG    CatalogDate;        // date/time catalog was updated
    LONGLONG    FirstRecordOffset;  // pointer to first record [to read] in log
    LONGLONG    LastRecordOffset;   // pointer to last record [to read] in log
    LONGLONG    NextRecordOffset;   // pointer to where next one goes
    LONGLONG    WrapOffset;         // pointer to last byte used in file
    LONGLONG    LastUpdateTime;     // date/time last record was written
    LONGLONG    FirstDataRecordOffset; // location of first data record in file
    // makes the info struct 256 bytes
    // and leaves room for future information
    DWORD       dwReserved[38];
} PDHI_BINARY_LOG_INFO, *PPDHI_BINARY_LOG_INFO;

typedef struct _PDHI_BINARY_LOG_HEADER_RECORD {
    PDHI_BINARY_LOG_RECORD_HEADER   RecHeader;
    PDHI_BINARY_LOG_INFO            Info;
} PDHI_BINARY_LOG_HEADER_RECORD, *PPDHI_BINARY_LOG_HEADER_RECORD;

typedef struct _PDHI_LOG_COUNTER_PATH {
    // this value is in bytes used by the entire structure & buffers
    DWORD   dwLength;           // total structure Length (including strings)
    DWORD   dwFlags;            // flags that describe the counter
    DWORD   dwUserData;       // user data from PDH Counter
    DWORD   dwCounterType;      // perflib counter type value
    LONGLONG llTimeBase;        // time base (freq) used by this counter
    LONG    lDefaultScale;      // default display scaling factor
    // the following values are in BYTES from the first byte in
    // the Buffer array.
    LONG    lMachineNameOffset; // offset to start of machine name
    LONG    lObjectNameOffset;  // offset to start of object name
    LONG    lInstanceOffset;    // offset to start of instance name
    LONG    lParentOffset;      // offset to start of parent instance name
    DWORD   dwIndex;            // index value for duplicate instances
    LONG    lCounterOffset;     // offset to start of counter name
    WCHAR   Buffer[1];          // start of string storage
} PDHI_LOG_COUNTER_PATH, *PPDHI_LOG_COUNTER_PATH;

typedef struct _PDHI_LOG_CAT_ENTRY {
    DWORD    dwEntrySize;            // size of this machine\object entry
    DWORD    dwStringSize;            // size of MSZ containing instance strings
    DWORD    dwMachineObjNameOffset;    // offset from the base of this struct to the machine name
    DWORD    dwInstanceStringOffset;    // offset to the first object entry in the list
} PDHI_LOG_CAT_ENTRY, *PPDHI_LOG_CAT_ENTRY;


PDH_FUNCTION
PdhiOpenInputBinaryLog (
    IN  PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiOpenOutputBinaryLog (
    IN  PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiOpenUpdateBinaryLog (
    IN  PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiUpdateBinaryLogFileCatalog (
    IN  PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiCloseBinaryLog (
    IN  PPDHI_LOG   pLog,
    IN    DWORD        dwFlags
);

PDH_FUNCTION
PdhiGetBinaryLogCounterInfo (
    IN  PPDHI_LOG       pLog,
    IN  PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiWriteBinaryLogHeader (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szUserCaption
);

PDH_FUNCTION
PdhiWriteBinaryLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  SYSTEMTIME  *stTimeStamp,
    IN  LPCWSTR     szUserString
);

PDH_FUNCTION
PdhiEnumMachinesFromBinaryLog (
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    BOOL        bUnicodeDest
);

PDH_FUNCTION
PdhiEnumObjectsFromBinaryLog (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szMachineName,
    IN  LPVOID      mszObjectList,
    IN  LPDWORD     pcchBufferSize,
    IN  DWORD       dwDetailLevel,
    IN  BOOL        bUnicode
);

PDH_FUNCTION
PdhiEnumObjectItemsFromBinaryLog (
    IN  PPDHI_LOG          hDataSource,
    IN  LPCWSTR            szMachineName,
    IN  LPCWSTR            szObjectName,
    IN  PDHI_COUNTER_TABLE CounterTable,
    IN  DWORD              dwDetailLevel,
    IN  DWORD              dwFlags
);

PDH_FUNCTION
PdhiGetMatchingBinaryLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  LONGLONG    *pStartTime,
    IN  LPDWORD     pdwIndex
);

PDH_FUNCTION
PdhiGetCounterValueFromBinaryLog (
    IN  PPDHI_LOG     hLog,
    IN  DWORD         dwIndex,
    IN  PPDHI_COUNTER pCounter
);

PDH_FUNCTION
PdhiGetTimeRangeFromBinaryLog (
    IN  PPDHI_LOG       hLog,
    IN  LPDWORD         pdwNumEntries,
    IN  PPDH_TIME_INFO  pInfo,
    IN  LPDWORD         dwBufferSize
);

PDH_FUNCTION
PdhiReadRawBinaryLogRecord (
    IN  PPDHI_LOG    pLog,
    IN  FILETIME     *ftRecord,
    IN  PPDH_RAW_LOG_RECORD     pBuffer,
    IN  LPDWORD                 pdwBufferLength
);


PDH_FUNCTION
PdhiListHeaderFromBinaryLog (
    IN  PPDHI_LOG   pLogFile,
    IN  LPVOID      pBufferArg,
    IN  LPDWORD     pcchBufferSize,
    IN  BOOL        bUnicode
);

PDH_FUNCTION
PdhiGetCounterArrayFromBinaryLog (
    IN PPDHI_LOG                        pLog,
    IN DWORD                            dwIndex,
    IN PPDHI_COUNTER                    pCounter,
    IN OUT PPDHI_RAW_COUNTER_ITEM_BLOCK     *ppValue
);

PPDHI_BINARY_LOG_RECORD_HEADER
PdhiGetSubRecord (
    IN  PPDHI_BINARY_LOG_RECORD_HEADER  pRecord,
    IN  DWORD                           dwRecordId
);

#endif   // _LOG_BIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log_ctrl.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    log_ctrl.c

Abstract:

    Log file control interface helper functions

--*/

#include <windows.h>
#include <stdlib.h>
#include <assert.h>
#include <pdh.h>
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"

#define PDH_LOGSVC_CTRL_FNMASK   ((DWORD)(PDH_LOGSVC_CTRL_ADD \
    | PDH_LOGSVC_CTRL_REMOVE \
    | PDH_LOGSVC_CTRL_INFO \
    ))


//
//  Internal  Logging utility functions
//
LONG
GetCurrentServiceState (
    SC_HANDLE   hService,
    BOOL * bStopped,
    BOOL * bPaused)
{
    SERVICE_STATUS  ssData;
    LONG        lStatus = ERROR_SUCCESS;

    BOOL    bServiceStopped = FALSE;
    BOOL    bServicePaused = FALSE;

    if (ControlService (
        hService, SERVICE_CONTROL_INTERROGATE,
        &ssData)) {
        switch (ssData.dwCurrentState) {

            case SERVICE_STOPPED:
                bServiceStopped = TRUE;
                bServicePaused = FALSE;
                break;

            case SERVICE_START_PENDING:
                bServiceStopped = TRUE;
                bServicePaused = FALSE;
                break;

            case SERVICE_STOP_PENDING:
                bServiceStopped = FALSE;
                bServicePaused = FALSE;
                break;

            case SERVICE_RUNNING:
                bServiceStopped = FALSE;
                bServicePaused = FALSE;
                break;

            case SERVICE_CONTINUE_PENDING:
                bServiceStopped = FALSE;
                bServicePaused = FALSE;
                break;

            case SERVICE_PAUSE_PENDING:
                bServiceStopped = FALSE;
                bServicePaused = FALSE;
                break;

            case SERVICE_PAUSED:
                bServiceStopped = FALSE;
                bServicePaused = TRUE;
                break;

            default:
                ;// no op
        }
    } else {
        bServiceStopped = TRUE;
        bServicePaused = TRUE;
    }

    *bStopped = bServiceStopped;
    *bPaused = bServicePaused;

    return lStatus;
}

STATIC_PDH_FUNCTION
PdhiSetLogQueryState (
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szQueryName,
    IN  DWORD   dwFlags
)
{
    DBG_UNREFERENCED_PARAMETER(szMachineName);
    DBG_UNREFERENCED_PARAMETER(szQueryName);
    DBG_UNREFERENCED_PARAMETER(dwFlags);

    return ERROR_SUCCESS;
}

STATIC_PDH_FUNCTION
PdhiGetLogQueryState (
    IN  SC_HANDLE   hService,
    IN  LPCWSTR     szMachineName,
    IN  LPCWSTR     szQueryName,
    IN  LPDWORD     pdwFlags
)
{
    BOOL    bStopped, bPaused;
    DWORD   dwStatus;

    UNREFERENCED_PARAMETER(szMachineName);
    UNREFERENCED_PARAMETER(szQueryName);

    // first get service status
    GetCurrentServiceState (hService, &bStopped, &bPaused);

    if (bStopped) {
        dwStatus = PDH_LOGSVC_STATUS_STOPPED;
    } else if (bPaused) {
        dwStatus = PDH_LOGSVC_STATUS_PAUSED;
    } else {
        dwStatus = PDH_LOGSVC_STATUS_RUNNING;
    }

    if (dwStatus == PDH_LOGSVC_STATUS_RUNNING) {
        // get status of specific query
        // connect to machine, if necssary
        // open registry key of log service
        // read value of query status
        // adjust status, if necessary
    }

    // return status of query
    *pdwFlags = dwStatus;

    return ERROR_SUCCESS;
}

STATIC_PDH_FUNCTION
PdhiLogServiceAddCommandT (
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szQueryName,
    IN  DWORD   dwFlags,
    IN  LPVOID  pInfoBuffer,
    IN  LPDWORD pdwBufferSize,
    IN  BOOL    bWideChar
)
{
    UNREFERENCED_PARAMETER(szMachineName);
    UNREFERENCED_PARAMETER(szQueryName);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(pInfoBuffer);
    UNREFERENCED_PARAMETER(pdwBufferSize);
    UNREFERENCED_PARAMETER(bWideChar);

    return PDH_NOT_IMPLEMENTED;
}

STATIC_PDH_FUNCTION
PdhiLogServiceRemoveCommandT (
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szQueryName,
    IN  DWORD   dwFlags,
    IN  LPVOID  pInfoBuffer,
    IN  LPDWORD pdwBufferSize,
    IN  BOOL    bWideChar
)
{
    UNREFERENCED_PARAMETER(szMachineName);
    UNREFERENCED_PARAMETER(szQueryName);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(pInfoBuffer);
    UNREFERENCED_PARAMETER(pdwBufferSize);
    UNREFERENCED_PARAMETER(bWideChar);

    return PDH_NOT_IMPLEMENTED;
}

STATIC_PDH_FUNCTION
PdhiLogServiceInfoCommandT (
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szQueryName,
    IN  DWORD   dwFlags,
    IN  LPVOID  pInfoBuffer,
    IN  LPDWORD pdwBufferSize,
    IN  BOOL    bWideChar
)
{

    LONG    lStatus = ERROR_SUCCESS;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    DWORD   dwRegValType;
    DWORD   dwRegValue;
    DWORD   dwRegValueSize;

    WCHAR   szTempFilePath[MAX_PATH];
    WCHAR   szRegString[MAX_PATH];
    WCHAR   szDriveName[MAX_PATH];

    HKEY    hKeyMachine = NULL;
    HKEY    hKeyLogSettings = NULL;
    HKEY    hKeyLogQuery = NULL;

    CHAR    *pNextChar = NULL;
    WCHAR   *pNextWideChar = NULL;

    DWORD   dwCharSize;

    DWORD   dwSize;
    DWORD   dwRequiredSize = sizeof(PDH_LOG_SERVICE_QUERY_INFO_W);
    DWORD   dwRemainingSize = 0;
   
    UNREFERENCED_PARAMETER(dwFlags);

    dwCharSize = bWideChar ? sizeof(WCHAR) : sizeof(CHAR);

    setlocale( LC_ALL, "" ); // to make wcstombs work predictably

    if (*pdwBufferSize < sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
        // then then this is either too small or a size request in either
        // case we won't copy any data and only estimate the size required
        dwRemainingSize = 0;
    } else {
        dwRemainingSize = *pdwBufferSize - sizeof(PDH_LOG_SERVICE_QUERY_INFO_W);
    }

    // get root key to registry
    if (szMachineName != NULL) {
        lStatus = RegConnectRegistryW (
            (LPWSTR)szMachineName,
            HKEY_LOCAL_MACHINE,
            &hKeyMachine);
        if (lStatus != ERROR_SUCCESS) {
            pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
        }
    } else {
        // use predefined key handle
        hKeyMachine = HKEY_LOCAL_MACHINE;
        lStatus = ERROR_SUCCESS;
    }

    if (pInfoBuffer == NULL) {
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        lStatus = ERROR_INVALID_PARAMETER;
    }

    if (lStatus == ERROR_SUCCESS) {
        // open registry key to service
        lStatus = RegOpenKeyExW (
            hKeyMachine,
            cszLogQueries,
            0,
            KEY_READ,
            &hKeyLogSettings);
        if (lStatus != ERROR_SUCCESS) {
            pdhStatus = PDH_LOGSVC_NOT_OPENED;
        }
    }

    if (lStatus == ERROR_SUCCESS) {
        // open registry to specified log query
        lStatus = RegOpenKeyExW (
            hKeyLogSettings,
            (szQueryName != NULL ? szQueryName : cszDefault),
            0,
            KEY_READ,
            &hKeyLogQuery);

        if (lStatus != ERROR_SUCCESS) {
            pdhStatus = PDH_LOGSVC_QUERY_NOT_FOUND;
        }
    }

    // continue

    if (lStatus == ERROR_SUCCESS) {

        // initialize string pointers
        if (bWideChar && (pInfoBuffer != NULL)) {
            pNextWideChar = (WCHAR *)(&((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)[1]);
        } else {
            pNextChar = (CHAR *)(&((PPDH_LOG_SERVICE_QUERY_INFO_A)pInfoBuffer)[1]);
        }

        // read log file format
        dwRegValType = 0;
        dwRegValue = 0;
        dwRegValueSize = sizeof(DWORD);
        lStatus = RegQueryValueExW (
            hKeyLogQuery,
            cszLogFileType,
            NULL,
            &dwRegValType,
            (LPBYTE)&dwRegValue,
            &dwRegValueSize);
        if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
            // this data goes into the fixed portion of the structure
            if ((lStatus == ERROR_SUCCESS) && (dwRegValType == REG_DWORD)) {
                ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->dwFileType = dwRegValue;
            } else {
                ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->dwFileType = PDH_LOG_TYPE_UNDEFINED;
            }
        }

        //read  sample interval
        dwRegValType = 0;
        dwRegValue = 0;
        dwRegValueSize = sizeof(DWORD);
        lStatus = RegQueryValueExW (
            hKeyLogQuery,
            cszAutoNameInterval,
            NULL,
            &dwRegValType,
            (LPBYTE)&dwRegValue,
            &dwRegValueSize);

        if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
            // this data goes into the fixed portion of the structure
            if ((lStatus == ERROR_SUCCESS) && (dwRegValType == REG_DWORD)) {
                ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlAutoNameInterval = dwRegValue;
            } else {
                ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlAutoNameInterval = 0;
                dwRegValue = 0;
            }
        }

        if (dwRegValue == 0) {
            // initialize the rest of the manual name field(s)
            dwRegValType = 0;
            dwRegValueSize = MAX_PATH * sizeof(WCHAR);
            memset (szRegString, 0, dwRegValueSize);
            lStatus = RegQueryValueExW (
                hKeyLogQuery,
                cszLogFileName,
                NULL,
                &dwRegValType,
                (LPBYTE)&szRegString[0],
                &dwRegValueSize);

            if ((lStatus == ERROR_SUCCESS) && (dwRegValType == REG_SZ)) {
                dwRequiredSize += dwRegValueSize / (sizeof(WCHAR) / dwCharSize);
                if (dwRequiredSize <= *pdwBufferSize) {
                    if (bWideChar) {
                        // copy widestrings
                        ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szBaseFileName = pNextWideChar;
                        lstrcpyW (pNextWideChar, szRegString);
                        pNextWideChar += dwRegValueSize / sizeof (WCHAR);
                    } else {
                        // convert to ansi char
                        ((PPDH_LOG_SERVICE_QUERY_INFO_A)pInfoBuffer)->szBaseFileName = pNextChar;
                        wcstombs (pNextChar, szRegString, (dwRegValueSize /sizeof(WCHAR)));
                        pNextChar += dwRegValueSize / sizeof (WCHAR);
                    }
                    dwRemainingSize -= dwRegValueSize / (sizeof(WCHAR) / dwCharSize);
                } else if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                    // no room for this string, but keep the required
                    // total;
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szBaseFileName = NULL;
                } else {
                    // it's an empty buffer
                }
            } else {
                if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szBaseFileName = NULL;
                }
            }

            // if the filename doesn't specify a directory, then use the
            lstrcpyW (szTempFilePath, szRegString);

            _wsplitpath ((LPCWSTR)szTempFilePath, szDriveName, szRegString,
                NULL, NULL);
            if ((lstrlenW(szDriveName) == 0) && (lstrlenW(szRegString) == 0)) {
                // default log file directory
                dwRegValType = 0;
                dwRegValueSize = MAX_PATH * sizeof(WCHAR);
                memset (szRegString, 0, dwRegValueSize);
                lStatus = RegQueryValueExW (
                    hKeyLogQuery,
                    cszLogDefaultDir,
                    NULL,
                    &dwRegValType,
                    (LPBYTE)&szRegString[0],
                    &dwRegValueSize);

            } else {
                // the file parsing function leaves the trailing backslash
                // so remove it before concatenating it.
                dwSize = lstrlenW(szRegString);
                if (dwSize > 0) {
                    if (szRegString[dwSize-1] == L'\\') {
                        szRegString[dwSize-1] = 0;
                    }
                    lStatus = ERROR_SUCCESS;
                    dwRegValType = REG_SZ;
                    dwRegValueSize = dwSize;
                } else {
                    lStatus = ERROR_FILE_NOT_FOUND;
                }
            }

            if ((lStatus == ERROR_SUCCESS) && (dwRegValType == REG_SZ)) {
                dwRequiredSize += dwRegValueSize / (sizeof(WCHAR) / dwCharSize);
                if (dwRequiredSize <= *pdwBufferSize) {
                    if (bWideChar) {
                        // copy widestrings
                        ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szDefaultDir = pNextWideChar;
                        lstrcpyW (pNextWideChar, szRegString);
                        pNextWideChar += dwRegValueSize / sizeof (WCHAR);
                    } else {
                        // convert to ansi char
                        ((PPDH_LOG_SERVICE_QUERY_INFO_A)pInfoBuffer)->szDefaultDir = pNextChar;
                        wcstombs (pNextChar, szRegString, (dwRegValueSize /sizeof(WCHAR)));
                        pNextChar += dwRegValueSize / sizeof (WCHAR);
                    }
                    dwRemainingSize -= dwRegValueSize / (sizeof(WCHAR) / dwCharSize);
                } else if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                    // no room for this string, but keep the required
                    // total;
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szDefaultDir = NULL;
                } else {
                    // no buffer for this
                }
            } else {
                if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szDefaultDir = NULL;
                }
            }
        } else {
            // get values for controls
            dwRegValType = 0;
            dwRegValueSize = MAX_PATH * sizeof(WCHAR);
            memset (szRegString, 0, dwRegValueSize);
            lStatus = RegQueryValueExW (
                hKeyLogQuery,
                cszLogDefaultDir,
                NULL,
                &dwRegValType,
                (LPBYTE)&szRegString[0],
                &dwRegValueSize);

            if ((lStatus == ERROR_SUCCESS) && (dwRegValType == REG_SZ)) {
                dwRequiredSize += dwRegValueSize / (sizeof(WCHAR) / dwCharSize);
                if (dwRequiredSize <= *pdwBufferSize) {
                    if (bWideChar) {
                        // copy widestrings
                        ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szDefaultDir = pNextWideChar;
                        lstrcpyW (pNextWideChar, szRegString);
                        pNextWideChar += dwRegValueSize / sizeof (WCHAR);
                    } else {
                        // convert to ansi char
                        ((PPDH_LOG_SERVICE_QUERY_INFO_A)pInfoBuffer)->szDefaultDir = pNextChar;
                        wcstombs (pNextChar, szRegString, (dwRegValueSize/sizeof(WCHAR)));
                        pNextChar += dwRegValueSize / sizeof (WCHAR);
                    }
                    dwRemainingSize -= dwRegValueSize / (sizeof(WCHAR) / dwCharSize);
                } else if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                    // no room for this string, but keep the required
                    // total;
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szDefaultDir = NULL;
                } else {
                    // no room for anything
                }
            } else {
                if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szDefaultDir = NULL;
                }
            }

            // base filename
            dwRegValType = 0;
            dwRegValueSize = MAX_PATH * sizeof(WCHAR);
            memset (szRegString, 0, dwRegValueSize);
            lStatus = RegQueryValueExW (
                hKeyLogQuery,
                cszBaseFileName,
                NULL,
                &dwRegValType,
                (LPBYTE)&szRegString[0],
                &dwRegValueSize);


            if ((lStatus == ERROR_SUCCESS) && (dwRegValType == REG_SZ)) {
                dwRequiredSize += dwRegValueSize / (sizeof(WCHAR) / dwCharSize);
                if (dwRequiredSize <= *pdwBufferSize) {
                    if (bWideChar) {
                        // copy widestrings
                        ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szBaseFileName = pNextWideChar;
                        lstrcpyW (pNextWideChar, szRegString);
                        pNextWideChar += dwRegValueSize / sizeof (WCHAR);
                    } else {
                        // convert to ansi char
                        ((PPDH_LOG_SERVICE_QUERY_INFO_A)pInfoBuffer)->szBaseFileName = pNextChar;
                        wcstombs (pNextChar, szRegString, (dwRegValueSize/sizeof(WCHAR)));
                        pNextChar += dwRegValueSize / sizeof (WCHAR);
                    }
                    dwRemainingSize -= dwRegValueSize / (sizeof(WCHAR) / dwCharSize);
                } else if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                    // no room for this string, but keep the required
                    // total;
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szBaseFileName = NULL;
                } else {
                    // no buffer
                }
            } else {
                if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->szBaseFileName = NULL;
                }
            }

            // get auto name format
            dwRegValType = 0;
            dwRegValue = 0;
            dwRegValueSize = sizeof(DWORD);
            lStatus = RegQueryValueExW (
                hKeyLogQuery,
                cszLogFileAutoFormat,
                NULL,
                &dwRegValType,
                (LPBYTE)&dwRegValue,
                &dwRegValueSize);

            if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                if ((lStatus == ERROR_SUCCESS) && (dwRegValType == REG_DWORD)) {
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlAutoNameFormat = dwRegValue;
                } else {
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlAutoNameFormat = PDH_LOGSVC_NAME_UNDEFINED;
                }
            }

            dwRegValType = 0;
            dwRegValue = 0;
            dwRegValueSize = sizeof(DWORD);
            lStatus = RegQueryValueExW (
                hKeyLogQuery,
                cszAutoRenameUnits,
                NULL,
                &dwRegValType,
                (LPBYTE)&dwRegValue,
                &dwRegValueSize);

            if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                if ((lStatus == ERROR_SUCCESS) && (dwRegValType == REG_DWORD)) {
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlAutoNameUnits = dwRegValue;
                } else {
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlAutoNameUnits = PDH_LOGSVC_RENAME_UNDEFINED;
                }
            }

            dwRegValType = 0;
            dwRegValueSize = MAX_PATH * sizeof(WCHAR);
            memset (szRegString, 0, dwRegValueSize);
            lStatus = RegQueryValueExW (
                hKeyLogQuery,
                cszCommandFile,
                NULL,
                &dwRegValType,
                (LPBYTE)&szRegString[0],
                &dwRegValueSize);

            if ((lStatus == ERROR_SUCCESS) && (dwRegValType == REG_SZ)) {
                dwRequiredSize += dwRegValueSize / (sizeof(WCHAR) / dwCharSize);
                if (dwRequiredSize <= *pdwBufferSize) {
                    if (bWideChar) {
                        // copy widestrings
                        ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlCommandFilename = pNextWideChar;
                        lstrcpyW (pNextWideChar, szRegString);
                        pNextWideChar += dwRegValueSize / sizeof (WCHAR);
                    } else {
                        // convert to ansi char
                        ((PPDH_LOG_SERVICE_QUERY_INFO_A)pInfoBuffer)->PdlCommandFilename = pNextChar;
                        wcstombs (pNextChar, szRegString, (dwRegValueSize/sizeof(WCHAR)));
                        pNextChar += dwRegValueSize / sizeof (WCHAR);
                    }
                    dwRemainingSize -= dwRegValueSize / (sizeof(WCHAR) / dwCharSize);
                } else if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                    // no room for this string, but keep the required
                    // total;
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlCommandFilename = NULL;
                } else {
                    // no buffer
                }
            } else {
                if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
                    ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlCommandFilename = NULL;
                }
            }
        }

        // get counter string!

        // find out buffer size required
        dwRegValType = 0;
        dwRegValue = 0;
        dwRegValueSize = 0;
        lStatus = RegQueryValueExW (
            hKeyLogQuery,
            cszCounterList,
            NULL,
            &dwRegValType,
            NULL,
            &dwRegValueSize);

        if (dwRegValueSize > 0) {
            // there's room in the caller's buffer so go ahead and
            // fill it
            dwRequiredSize += dwRegValueSize / (sizeof(WCHAR) / dwCharSize);
            if (dwRequiredSize <= *pdwBufferSize) {

                dwRegValueSize = dwRemainingSize;
                dwRegValType = 0;
                dwRegValue = 0;
                if (bWideChar) {
                    lStatus = RegQueryValueExW (
                        hKeyLogQuery,
                        cszCounterList,
                        NULL,
                        &dwRegValType,
                        (LPBYTE)pNextWideChar,
                        &dwRegValueSize);

                    if (lStatus == ERROR_SUCCESS) {
                        // assign pointer to buffer
                        ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlCounterList = pNextWideChar;
                        pNextWideChar += dwRegValueSize / sizeof (WCHAR);
                        dwRemainingSize -= dwRegValueSize;
                    } else {
                        // assign null pointer
                        ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlCounterList = NULL;
                    }
                } else {
                    lStatus = RegQueryValueExA (
                        hKeyLogQuery,
                        caszCounterList,
                        NULL,
                        &dwRegValType,
                        (LPBYTE)pNextChar,
                        &dwRegValueSize);

                    if (lStatus == ERROR_SUCCESS) {
                        // assign pointer to buffer
                        ((PPDH_LOG_SERVICE_QUERY_INFO_A)pInfoBuffer)->PdlCounterList = pNextChar;
                        pNextChar += dwRegValueSize;
                        dwRemainingSize -= dwRegValueSize;
                    } else {
                        // assign null pointer
                        ((PPDH_LOG_SERVICE_QUERY_INFO_A)pInfoBuffer)->PdlCounterList = NULL;
                    }
                }
            } else {
                // no room so don't copy anything
            }
        } else if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
            // no counters defined so return NULL
            ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->PdlCounterList = NULL;
        } else {
            // no buffer
        }
    } //end if registry opened ok

    // close open registry keys

    if (hKeyMachine != NULL) RegCloseKey (hKeyMachine);
    if (hKeyLogSettings != NULL) RegCloseKey (hKeyLogSettings);
    if (hKeyLogQuery != NULL) RegCloseKey (hKeyLogQuery);

    // test to see if the buffer estimate and pointer location line up
    // assuming it was big enough in the first place
    assert ((dwRequiredSize <= *pdwBufferSize) ?
        ((pNextChar != NULL) ? (dwRequiredSize == ((DWORD)pNextChar - (DWORD)pInfoBuffer)) :
        (dwRequiredSize == ((DWORD)pNextWideChar - (DWORD)pInfoBuffer))) : TRUE);

    if (lStatus == ERROR_SUCCESS) {
        if (*pdwBufferSize >= sizeof(PDH_LOG_SERVICE_QUERY_INFO_W)) {
            // if there's enough buffer to write this...
            if (*pdwBufferSize >= dwRequiredSize) {
                // and there was enough for the requested data
                ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->dwSize = dwRequiredSize;
            } else {
                // return the amount used
                ((PPDH_LOG_SERVICE_QUERY_INFO_W)pInfoBuffer)->dwSize =  *pdwBufferSize;
            }
        }
    }

    // save required size
    *pdwBufferSize = dwRequiredSize;

    return pdhStatus;
}

PDH_FUNCTION
PdhLogServiceCommandA (
    IN  LPCSTR          szMachineName,
    IN  LPCSTR          szQueryName,
    IN  DWORD           dwFlags,
    IN  LPDWORD         pdwStatus
)
{
    LPWSTR  wszQueryName    = NULL;
    LPWSTR  wszMachineName  = NULL;
    PDH_STATUS  pdhStatus   = ERROR_SUCCESS;

    // test access to query name

    if (szQueryName != NULL) {
        DWORD   dwNameLength = 0;
        try {
            CHAR    cTest;

            cTest = szQueryName[0];
            dwNameLength = lstrlenA (szQueryName);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            // unable to access name argument
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        if (pdhStatus == ERROR_SUCCESS) {
            // allocate wide name buffer
            wszQueryName = G_ALLOC ((dwNameLength + 1) * sizeof (WCHAR));
            if (wszQueryName != NULL) {
                mbstowcs (wszQueryName, szQueryName, dwNameLength);
            } else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
    } else {
        // make a null arg for the function
        wszQueryName = NULL;
    }

    if ((szMachineName != NULL) && (pdhStatus == ERROR_SUCCESS)) {
        DWORD   dwNameLength = 0;
        try {
            CHAR    cTest;

            cTest = szMachineName[0];
            dwNameLength = lstrlenA (szMachineName);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            // unable to access name argument
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        if (pdhStatus == ERROR_SUCCESS) {
            // allocate wide name buffer
            wszMachineName = G_ALLOC ((dwNameLength + 1) * sizeof (WCHAR));
            if (wszMachineName != NULL) {
                mbstowcs (wszMachineName, szMachineName, dwNameLength);
            } else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
    } else {
        // make a null arg for the function
        wszMachineName = NULL;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // call wide string version
        pdhStatus = PdhLogServiceCommandW (
                        wszMachineName,
                        wszQueryName,
                        dwFlags,
                        pdwStatus);
    }

    if (wszQueryName != NULL) G_FREE (wszQueryName);
    if (wszMachineName != NULL) G_FREE (wszMachineName);

    return pdhStatus;
}

PDH_FUNCTION
PdhLogServiceCommandW (
    IN  LPCWSTR         szMachineName,
    IN  LPCWSTR         szQueryName,
    IN  DWORD           dwFlags,
    IN  LPDWORD         pdwStatus
)
{
    SC_HANDLE           hSC = NULL;
    SC_HANDLE           hService = NULL;
    SERVICE_STATUS      ssData;
    DWORD               dwTimeout;
    DWORD               dwStatus;
    BOOL                bStopped = FALSE;
    BOOL                bPaused = FALSE;
    LONG                lStatus = ERROR_SUCCESS;
    BOOL                bWait;
    LPWSTR              szLocalQueryName = NULL;

    // test arguments
    try {
        WCHAR   wcTest;
        DWORD   dwTest;

        if (szMachineName != NULL) {
            wcTest = szMachineName[0];
        } // null is valid for the local machine

        if (szQueryName != NULL) {
            wcTest = szQueryName[0];
        } // null is a valid query name.

        if (pdwStatus != NULL) {
            dwTest = *pdwStatus;
            *pdwStatus = 0;
            *pdwStatus = dwTest;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = PDH_INVALID_ARGUMENT;
    }

    if (lStatus == ERROR_SUCCESS) {
        if ((dwFlags & PDH_LOGSVC_TRACE_LOG) == PDH_LOGSVC_TRACE_LOG) {
            lStatus = PDH_NOT_IMPLEMENTED;
        } else {
            // this must be a perf log command
            // open SC database
            hSC = OpenSCManagerW (szMachineName, NULL, SC_MANAGER_ALL_ACCESS);

            if (hSC == NULL) {
                // open service
                hService = OpenServiceW (hSC, cszPerfDataLog,
                    SERVICE_START | SERVICE_STOP | SERVICE_USER_DEFINED_CONTROL);
            } // else hService will still be NULL so get the last error below

            if (hService != NULL) {
                // determine wait flag value
                bWait = (dwFlags & PDH_LOGSVC_NO_WAIT) ? FALSE : TRUE;

                if  (szQueryName == NULL) {
                    if ((dwFlags & PDH_LOGSVC_ALL_QUERIES) == PDH_LOGSVC_ALL_QUERIES) {
                        // start / stop the service and all log queries
                        if ((dwFlags & PDH_LOGSVC_CMD_START) == PDH_LOGSVC_CMD_START) {
                            // start the service and start all logs set to run
                            StartService (hService, 0, NULL);
                            if ( bWait ) {
                                // wait for the service to start before returning
                                dwTimeout = 20;
                                while (dwTimeout) {
                                    GetCurrentServiceState (hService, &bStopped, &bPaused);
                                    if (bStopped) {
                                        Sleep(500);
                                    } else {
                                        break;
                                    }
                                    --dwTimeout;
                                }
                                if (bStopped) {
                                    dwStatus = PDH_LOGSVC_STATUS_STOPPED;
                                } else if (bPaused) {
                                    dwStatus = PDH_LOGSVC_STATUS_PAUSED;
                                } else {
                                    dwStatus = PDH_LOGSVC_STATUS_RUNNING;
                                }
                            } else {
                                dwStatus = PDH_LOGSVC_STATUS_PENDING;
                            }

                        } else if ((dwFlags & PDH_LOGSVC_CMD_STOP) == PDH_LOGSVC_CMD_STOP) {
                            ControlService (hService, SERVICE_CONTROL_STOP, &ssData);
                            if ( bWait ) {
                                // wait for the service to stop before returning
                                dwTimeout = 20;
                                while (dwTimeout) {
                                    GetCurrentServiceState (hService, &bStopped, &bPaused);
                                    if (!bStopped) {
                                        Sleep(500);
                                    } else {
                                        break;
                                    }
                                    --dwTimeout;
                                }
                                if (bStopped) {
                                    dwStatus = PDH_LOGSVC_STATUS_STOPPED;
                                } else if (bPaused) {
                                    dwStatus = PDH_LOGSVC_STATUS_PAUSED;
                                } else {
                                    dwStatus = PDH_LOGSVC_STATUS_RUNNING;
                                }
                            }
                        } else {
                            // unknown operation
                            lStatus = PDH_UNKNOWN_LOGSVC_COMMAND;
                        }
                    } else {
                        // this is just a generic log command.
                        szLocalQueryName = (LPWSTR)cszDefault;
                    }
                }

                if (szLocalQueryName != NULL) {
                    // then this command is for a named service
                    lStatus = PdhiSetLogQueryState (
                            szMachineName,
                            szLocalQueryName,
                            (dwFlags & (PDH_LOGSVC_CMD_START | PDH_LOGSVC_CMD_STOP)));
                    if (lStatus == ERROR_SUCCESS) {
                        // service entry was updated to desired status

                        if (!ControlService (hService,
                            SERVICE_CONTROL_PARAMCHANGE, &ssData)) {
                                lStatus = GetLastError ();
                        }
                        lStatus = PdhiGetLogQueryState (
                            hService, szMachineName,
                            szLocalQueryName, &dwStatus);
                    }
                }


                CloseServiceHandle (hService);
            } else {
                lStatus = GetLastError();
                assert (lStatus != 0);
            }
            // close handles
            if (hSC != NULL) CloseServiceHandle (hSC);
        }
    }

    return lStatus;

}

PDH_FUNCTION
PdhLogServiceControlA (
    IN  LPCSTR         szMachineName,
    IN  LPCSTR          szQueryName,
    IN  DWORD           dwFlags,
    IN  PPDH_LOG_SERVICE_QUERY_INFO_A pInfoBuffer,
    IN  LPDWORD         pdwBufferSize
)
{
    LPWSTR  wszQueryName    = NULL;
    LPWSTR  wszMachineName  = NULL;
    PDH_STATUS  pdhStatus   = ERROR_SUCCESS;
    DWORD       dwCmdFn;

    // test access to query name

    if (szQueryName != NULL) {
        DWORD   dwNameLength = 0;
        try {
            CHAR    cTest;

            cTest = szQueryName[0];
            dwNameLength = lstrlenA (szQueryName);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            // unable to access name argument
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        if (pdhStatus == ERROR_SUCCESS) {
            // allocate wide name buffer
            wszQueryName = G_ALLOC ((dwNameLength + 1) * sizeof (WCHAR));
            if (wszQueryName != NULL) {
                mbstowcs (wszQueryName, szQueryName, dwNameLength);
            } else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
    } else {
        // make a null arg for the function
        wszQueryName = NULL;
    }

    if ((szMachineName != NULL) && (pdhStatus == ERROR_SUCCESS)) {
        DWORD   dwNameLength = 0;
        try {
            CHAR    cTest;

            cTest = szMachineName[0];
            dwNameLength = lstrlenA (szMachineName);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            // unable to access name argument
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        if (pdhStatus == ERROR_SUCCESS) {
            // allocate wide name buffer
            wszMachineName = G_ALLOC ((dwNameLength + 1) * sizeof (WCHAR));
            if (wszMachineName != NULL) {
                mbstowcs (wszMachineName, szMachineName, dwNameLength);
            } else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
    } else {
        // make a null arg for the function
        wszMachineName = NULL;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        try {
            DWORD   dwTest;

            if (pdwBufferSize != NULL) {
                dwTest = *pdwBufferSize;
                *pdwBufferSize = 0;
                *pdwBufferSize = dwTest;
            } else {
                // null is NOT valid
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // dispatch to "action" function based on command code
        dwCmdFn = dwFlags & PDH_LOGSVC_CTRL_FNMASK;
        switch (dwCmdFn) {
            case PDH_LOGSVC_CTRL_ADD:
                // call universal string version
                pdhStatus = PdhiLogServiceAddCommandT (
                                wszMachineName,
                                wszQueryName,
                                dwFlags,
                                (LPVOID)pInfoBuffer,
                                pdwBufferSize,
                                FALSE);
                break;

            case PDH_LOGSVC_CTRL_REMOVE:
                // call universal string version
                pdhStatus = PdhiLogServiceRemoveCommandT (
                                wszMachineName,
                                wszQueryName,
                                dwFlags,
                                (LPVOID)pInfoBuffer,
                                pdwBufferSize,
                                FALSE);
                break;

            case PDH_LOGSVC_CTRL_INFO:
                // call universal string version
                pdhStatus = PdhiLogServiceInfoCommandT (
                                wszMachineName,
                                wszQueryName,
                                dwFlags,
                                (LPVOID)pInfoBuffer,
                                pdwBufferSize,
                                FALSE);
                break;

            default:
                pdhStatus = PDH_INVALID_ARGUMENT;
                break;
        }

    }

    if (wszQueryName != NULL) G_FREE (wszQueryName);
    if (wszMachineName != NULL) G_FREE (wszMachineName);

    return pdhStatus;
}

PDH_FUNCTION
PdhLogServiceControlW (
    IN  LPCWSTR         szMachineName,
    IN  LPCWSTR         szQueryName,
    IN  DWORD           dwFlags,
    IN  PPDH_LOG_SERVICE_QUERY_INFO_W pInfoBuffer,
    IN  LPDWORD         pdwBufferSize
)
{
    PDH_STATUS  pdhStatus   = ERROR_SUCCESS;
    DWORD       dwCmdFn;

    // test access to query name

    if (szQueryName != NULL) {
        WCHAR    cTest;
        try {
            cTest = szQueryName[0];
            if (cTest == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            // unable to access name argument
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    } else {
        // NULL is OK
    }

    // test access to machine name

    if ((szMachineName != NULL) && (pdhStatus == ERROR_SUCCESS)) {
        WCHAR    cTest;
        try {
            cTest = szMachineName[0];
            if (cTest == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            // unable to access name argument
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    } else {
        // NULL is OK
    }

    if (pdhStatus == ERROR_SUCCESS) {
        try {
            DWORD   dwTest;

            if (pdwBufferSize != NULL) {
                dwTest = *pdwBufferSize;
                *pdwBufferSize = 0;
                *pdwBufferSize = dwTest;
            } else {
                // null is NOT valid
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // dispatch to "action" function based on command code
        dwCmdFn = dwFlags & PDH_LOGSVC_CTRL_FNMASK;
        switch (dwCmdFn) {
            case PDH_LOGSVC_CTRL_ADD:
                // call universal string version
                pdhStatus = PdhiLogServiceAddCommandT (
                                szMachineName,
                                szQueryName,
                                dwFlags,
                                (LPVOID)pInfoBuffer,
                                pdwBufferSize,
                                TRUE);
                break;

            case PDH_LOGSVC_CTRL_REMOVE:
                // call universal string version
                pdhStatus = PdhiLogServiceRemoveCommandT (
                                szMachineName,
                                szQueryName,
                                dwFlags,
                                (LPVOID)pInfoBuffer,
                                pdwBufferSize,
                                TRUE);
                break;

            case PDH_LOGSVC_CTRL_INFO:
                // call universal string version
                pdhStatus = PdhiLogServiceInfoCommandT (
                                szMachineName,
                                szQueryName,
                                dwFlags,
                                (LPVOID)pInfoBuffer,
                                pdwBufferSize,
                                TRUE);
                break;

            default:
                pdhStatus = PDH_INVALID_ARGUMENT;
                break;
        }

    }

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log_sql.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    log_SQL.c

Abstract:

    <abstract>

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <mbctype.h>
#include <pdh.h>
#include "strings.h"
#include <pdhmsg.h>
#include "pdhidef.h"

#include <sql.h>
#include <odbcss.h>
// pragma to supress /W4 errors
#pragma warning ( disable : 4201 )
#include <sqlext.h>
#pragma warning ( default : 4201 )

#include "log_SQL.h"
#include "log_bin.h" // to get the binary log file record formatting
#include "log_pm.h"  // to get PDH_LOG_... structure definition.

#pragma warning ( disable : 4213)

#define TIME_FIELD_BUFF_SIZE           24
#define PDH_SQL_BULK_COPY_REC        2048
#define PDH_SQL_STRING_SIZE          1024
#define MULTI_COUNT_DOUBLE_RAW 0xFFFFFFFF
#define SQLSTMTSIZE                  1024
#define INITIAL_MSZ_SIZE             1024
#define MSZ_SIZE_ADDON               1024

#define ALLOC_CHECK(pB) if(NULL == pB){assert(GetLastError() == ERROR_SUCCESS);return PDH_MEMORY_ALLOCATION_FAILURE;}
#define ALLOC_CHECK_HSTMT(pB) if(NULL == pB) {SQLFreeStmt(hstmt, SQL_DROP);assert(GetLastError() == ERROR_SUCCESS);return PDH_MEMORY_ALLOCATION_FAILURE;}

#define SQLSUCCEEDED(rc) (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO || rc == SQL_NO_DATA)

typedef struct _PDH_SQL_BULK_COPY {
    GUID   dbGuid;
    INT    dbCounterId;
    INT    dbRecordIndex;
    CHAR   dbDateTime[24];
    double dbCounterValue;
    INT    dbFirstValueA;
    INT    dbFirstValueB;
    INT    dbSecondValueA;
    INT    dbSecondValueB;
    INT    dbMultiCount;
    DWORD  dwRecordCount;
} PDH_SQL_BULK_COPY, * PPDH_SQL_BULK_COPY;

typedef struct _PDHI_SQL_LOG_INFO      PDHI_SQL_LOG_INFO, * PPDHI_SQL_LOG_INFO;

struct _PDHI_SQL_LOG_INFO {
    PPDHI_LOG_MACHINE  MachineList;
    //PPDHI_SQL_LOG_DATA LogData;
    FILETIME           RecordTime;
    DWORD              dwRunId;
};

int
PdhiCompareLogCounterInstance(
    IN  PPDHI_LOG_COUNTER   pCounter,
    IN  LPWSTR              szCounter,
    IN  LPWSTR              szInstance,
    IN  DWORD               dwInstance,
    IN  LPWSTR              szParent
)
{
    int   iResult;
    WCHAR szTmp[PDH_SQL_STRING_SIZE + 1];

    ZeroMemory(szTmp, sizeof(szTmp));
    lstrcpynW(szTmp, szCounter, PDH_SQL_STRING_SIZE);
    iResult = lstrcmpiW(szTmp, pCounter->szCounter);
    if (iResult != 0) goto Cleanup;

    if (   (pCounter->szInstance != NULL && pCounter->szInstance[0] != L'\0')
        && (szInstance != NULL && szInstance[0] != L'\0')) {
        ZeroMemory(szTmp, sizeof(szTmp));
        lstrcpynW(szTmp, szInstance, PDH_SQL_STRING_SIZE);
        iResult = lstrcmpiW(szTmp, pCounter->szInstance);
    }
    else if ((pCounter->szInstance != NULL && pCounter->szInstance[0] != L'\0')
            && (szInstance == NULL || szInstance[0] == L'\0')) {
        iResult = -1;
    }
    else if ((pCounter->szInstance == NULL || pCounter->szInstance[0] == L'\0')
            && (szInstance != NULL && szInstance[0] != L'\0')) {
        iResult = 1;
    }
    if (iResult != 0) goto Cleanup;

    iResult = (dwInstance < pCounter->dwInstance)
            ? (-1)
            : ((dwInstance > pCounter->dwInstance) ? (1) : (0));
    if (iResult != 0) goto Cleanup;

    if (   (pCounter->szParent != NULL && pCounter->szParent[0] != L'\0')
        && (szParent != NULL && szParent[0] != L'\0')) {
        ZeroMemory(szTmp, sizeof(szTmp));
        lstrcpynW(szTmp, szParent, PDH_SQL_STRING_SIZE);
        iResult = lstrcmpiW(szTmp, pCounter->szParent);
    }
    else if ((pCounter->szParent != NULL && pCounter->szParent[0] != L'\0')
            && (szParent == NULL || szParent[0] == L'\0')) {
        iResult = -1;
    }
    else if ((pCounter->szParent == NULL || pCounter->szParent[0] == L'\0')
            && (szParent != NULL && szParent[0] != L'\0')) {
        iResult = 1;
    }

Cleanup:
    return iResult;
}

void
PdhiFreeLogCounterNode(
    IN  PPDHI_LOG_COUNTER pCounter,
    IN  DWORD             dwLevel
)
{
    if (pCounter == NULL) return;

    if (pCounter->left != NULL) {
        PdhiFreeLogCounterNode(pCounter->left, dwLevel + 1);
    }
    if (pCounter->right != NULL) {
        PdhiFreeLogCounterNode(pCounter->right, dwLevel + 1);
    }

    G_FREE(pCounter);
}

void
PdhiFreeLogObjectNode(
    IN  PPDHI_LOG_OBJECT pObject,
    IN  DWORD            dwLevel
)
{
    if (pObject == NULL) return;

    if (pObject->left != NULL) {
        PdhiFreeLogObjectNode(pObject->left, dwLevel + 1);
    }

    PdhiFreeLogCounterNode(pObject->CtrTable, 0);

    if (pObject->right != NULL) {
        PdhiFreeLogObjectNode(pObject->right, dwLevel + 1);
    }

    G_FREE(pObject);
}

void
PdhiFreeLogMachineTable(
    IN  PPDHI_LOG_MACHINE * MachineTable
)
{
    PPDHI_LOG_MACHINE pMachine;
    PPDHI_LOG_OBJECT  pObject;
    PPDHI_LOG_COUNTER pCounter;

    if (MachineTable == NULL) return;

    pMachine = * MachineTable;
    while (pMachine != NULL) {
        PPDHI_LOG_MACHINE pDelMachine = pMachine;
        pMachine = pMachine->next;
        PdhiFreeLogObjectNode(pDelMachine->ObjTable, 0);
        G_FREE(pDelMachine);
    }

    * MachineTable = NULL;
}

PPDHI_LOG_MACHINE
PdhiFindLogMachine(
    IN  PPDHI_LOG_MACHINE * MachineTable,
    IN  LPWSTR              szMachine,
    IN  BOOL                bInsert
)
{
    PPDHI_LOG_MACHINE pMachine = NULL;
    WCHAR             szTmp[PDH_SQL_STRING_SIZE + 1];

    if (MachineTable != NULL) {
        ZeroMemory(szTmp, sizeof(szTmp));
        lstrcpynW(szTmp, szMachine, PDH_SQL_STRING_SIZE);
        for (pMachine = (* MachineTable);
                pMachine && lstrcmpiW(pMachine->szMachine, szTmp) != 0;
                pMachine = pMachine->next);

        if (bInsert && pMachine == NULL) {
            pMachine = G_ALLOC(sizeof(PDHI_LOG_MACHINE) + (PDH_SQL_STRING_SIZE + 1) * sizeof(WCHAR));
            if (pMachine != NULL) {
                pMachine->szMachine = (LPWSTR) (((PCHAR) pMachine) + sizeof(PDHI_LOG_MACHINE));
                lstrcpynW(pMachine->szMachine, szMachine, PDH_SQL_STRING_SIZE);
                pMachine->ObjTable  = NULL;
                pMachine->next      = (* MachineTable);
                * MachineTable      = pMachine;
            }
        }
    }
    return pMachine;
}

PPDHI_LOG_OBJECT
PdhiFindLogObject(
    IN  PPDHI_LOG_MACHINE  pMachine,
    IN  PPDHI_LOG_OBJECT * ObjectTable,
    IN  LPWSTR             szObject,
    IN  BOOL               bInsert
)
{
    PPDHI_LOG_OBJECT  * pStack[MAX_BTREE_DEPTH];
    PPDHI_LOG_OBJECT  * pLink;
    int                 dwStack = 0;
    PPDHI_LOG_OBJECT    pNode   = * ObjectTable;
    PPDHI_LOG_OBJECT    pObject;
    PPDHI_LOG_OBJECT    pParent;
    PPDHI_LOG_OBJECT    pSibling;
    PPDHI_LOG_OBJECT    pChild;
    int                 iCompare;
    WCHAR               szTmp[PDH_SQL_STRING_SIZE + 1];

    ZeroMemory(szTmp, sizeof(szTmp));
    lstrcpynW(szTmp, szObject, PDH_SQL_STRING_SIZE);

    pStack[dwStack ++] = ObjectTable;
    while (pNode != NULL) {
        iCompare = lstrcmpiW(szTmp, pNode->szObject);
        if (iCompare < 0) {
            pStack[dwStack ++] = & (pNode->left);
            pNode = pNode->left;
        }
        else if (iCompare > 0) {
            pStack[dwStack ++] = & (pNode->right);
            pNode = pNode->right;
        }
        else {
            break;
        }
    }

    if (pNode != NULL) {
        pObject = pNode;
    }
    else if (bInsert) {
        pObject = G_ALLOC(sizeof(PDHI_LOG_OBJECT) + (PDH_SQL_STRING_SIZE + 1) * sizeof(WCHAR));
        if (pObject == NULL) goto Cleanup;

        pObject->next     = pMachine->ObjList;
        pMachine->ObjList = pObject;

        pObject->bIsRed   = TRUE;
        pObject->left     = NULL;
        pObject->right    = NULL;
        pObject->CtrTable = NULL;
        pObject->szObject = (LPWSTR) (((PCHAR) pObject) + sizeof(PDHI_LOG_OBJECT));
        lstrcpynW(pObject->szObject, szObject, PDH_SQL_STRING_SIZE);

        pLink   = pStack[-- dwStack];
        * pLink = pObject;

        pChild  = NULL;
        pNode   = pObject;
        while (dwStack > 0) {
            pLink   = pStack[-- dwStack];
            pParent = * pLink;
            if (! pParent->bIsRed) {
                pSibling = (pParent->left == pNode)
                         ? pParent->right : pParent->left;
                if (pSibling && pSibling->bIsRed) {
                    pNode->bIsRed    = FALSE;
                    pSibling->bIsRed = FALSE;
                    pParent->bIsRed  = TRUE;
                }
                else {
                    if (pChild && pChild->bIsRed) {
                        if (pChild == pNode->left) {
                            if (pNode == pParent->left) {
                                pParent->bIsRed = TRUE;
                                pParent->left   = pNode->right;
                                pNode->right    = pParent;
                                pNode->bIsRed   = FALSE;
                                * pLink         = pNode;
                            }
                            else {
                                pParent->bIsRed = TRUE;
                                pParent->right  = pChild->left;
                                pChild->left    = pParent;
                                pNode->left     = pChild->right;
                                pChild->right   = pNode;
                                pChild->bIsRed  = FALSE;
                                * pLink         = pChild;
                            }
                        }
                        else {
                            if (pNode == pParent->right) {
                                pParent->bIsRed = TRUE;
                                pParent->right  = pNode->left;
                                pNode->left     = pParent;
                                pNode->bIsRed   = FALSE;
                                * pLink         = pNode;
                            }
                            else {
                                pParent->bIsRed = TRUE;
                                pParent->left   = pChild->right;
                                pChild->right   = pParent;
                                pNode->right    = pChild->left;
                                pChild->left    = pNode;
                                pChild->bIsRed  = FALSE;
                                * pLink         = pChild;
                            }
                        }
                    }
                    break;
                }
            }
            pChild = pNode;
            pNode  = pParent;
        }

        (* ObjectTable)->bIsRed = FALSE;
    }
    else {
        pObject = NULL;
    }

Cleanup:
    return pObject;
}

PPDHI_LOG_COUNTER
PdhiFindLogCounter(
    IN  PPDHI_LOG           pLog,
    IN  PPDHI_LOG_MACHINE * MachineTable,
    IN  LPWSTR              szMachine,
    IN  LPWSTR              szObject,
    IN  LPWSTR              szCounter,
    IN  DWORD               dwCounterType,
    IN  DWORD               dwDefaultScale,
    IN  LPWSTR              szInstance,
    IN  DWORD               dwInstance,
    IN  LPWSTR              szParent,
    IN  DWORD               dwParent,
    IN  LPDWORD             pdwIndex,
    IN  BOOL                bInsert
)
{
    PPDHI_LOG_MACHINE   pMachine = NULL;
    PPDHI_LOG_OBJECT    pObject  = NULL;
    PPDHI_LOG_COUNTER   pCounter = NULL;
    PPDHI_LOG_COUNTER   pNode    = NULL;

    PPDHI_LOG_COUNTER * pStack[MAX_BTREE_DEPTH];
    PPDHI_LOG_COUNTER * pLink;
    int                 dwStack = 0;
    PPDHI_LOG_COUNTER   pParent;
    PPDHI_LOG_COUNTER   pSibling;
    PPDHI_LOG_COUNTER   pChild;
    int                 iCompare;

    pMachine = PdhiFindLogMachine(MachineTable, szMachine, bInsert);
    if (pMachine == NULL) goto Cleanup;

    pObject = PdhiFindLogObject(pMachine, & (pMachine->ObjTable), szObject, bInsert);
    if (pObject == NULL) goto Cleanup;

    pStack[dwStack ++] = & (pObject->CtrTable);
    pCounter = pObject->CtrTable;
    while (pCounter != NULL) {
        iCompare = PdhiCompareLogCounterInstance(pCounter, szCounter, szInstance, dwInstance, szParent);
#if 0
        if (iCompare == 0) {
            if (dwCounterType < pCounter->dwCounterType) {
                iCompare = -1;
            }
            else if (dwCounterType > pCounter->dwCounterType) {
                iCompare = 1;
            }
            else {
                iCompare = 0;
            }
        }
#endif
        if (iCompare < 0) {
            pStack[dwStack ++] = & (pCounter->left);
            pCounter = pCounter->left;
        }
        else if (iCompare > 0) {
            pStack[dwStack ++] = & (pCounter->right);
            pCounter = pCounter->right;
        }
        else {
            break;
        }
    }

    if (bInsert) {
        if (pCounter == NULL) {
            DWORD dwBufSize = sizeof(PDHI_LOG_COUNTER) + 3 * sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1);
            pCounter = G_ALLOC(dwBufSize);
            if (pCounter == NULL) goto Cleanup;

            pCounter->next           = pObject->CtrList;
            pObject->CtrList         = pCounter;

            pCounter->bIsRed         = TRUE;
            pCounter->left           = NULL;
            pCounter->right          = NULL;
            pCounter->dwCounterID    = * pdwIndex;
            pCounter->dwCounterType  = dwCounterType;
            pCounter->dwDefaultScale = dwDefaultScale;
            pCounter->dwInstance     = dwInstance;
            pCounter->dwParent       = dwParent;
            pCounter->TimeStamp      = 0;

            pCounter->szCounter = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER));
            lstrcpynW(pCounter->szCounter, szCounter, PDH_SQL_STRING_SIZE);
            if (szInstance == NULL || szInstance[0] == L'\0') {
                pCounter->szInstance = NULL;
            }
            else {
                pCounter->szInstance = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER)
                                                                    + sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
                lstrcpynW(pCounter->szInstance, szInstance, PDH_SQL_STRING_SIZE);
            }

            if (szParent == NULL || szParent[0] == L'\0') {
                pCounter->szParent = NULL;
            }
            else {
                pCounter->szParent = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER)
                                                                  + 2 * sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
                lstrcpynW(pCounter->szParent, szParent, PDH_SQL_STRING_SIZE);
            }

            pLink   = pStack[-- dwStack];
            * pLink = pCounter;

            pChild  = NULL;
            pNode   = pCounter;
            while (dwStack > 0) {
                pLink   = pStack[-- dwStack];
                pParent = * pLink;
                if (! pParent->bIsRed) {
                    pSibling = (pParent->left == pNode)
                             ? pParent->right : pParent->left;
                    if (pSibling && pSibling->bIsRed) {
                        pNode->bIsRed    = FALSE;
                        pSibling->bIsRed = FALSE;
                        pParent->bIsRed  = TRUE;
                    }
                    else {
                        if (pChild && pChild->bIsRed) {
                            if (pChild == pNode->left) {
                                if (pNode == pParent->left) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pNode->right;
                                    pNode->right     = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pChild->left;
                                    pChild->left     = pParent;
                                    pNode->left      = pChild->right;
                                    pChild->right    = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                            else {
                                if (pNode == pParent->right) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pNode->left;
                                    pNode->left      = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pChild->right;
                                    pChild->right    = pParent;
                                    pNode->right     = pChild->left;
                                    pChild->left     = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                        }
                        break;
                    }
                }
                pChild = pNode;
                pNode  = pParent;
            }

            pObject->CtrTable->bIsRed = FALSE;
        }
    }
    else if (pCounter != NULL) {
        * pdwIndex = pCounter->dwCounterID;
    }

Cleanup:
    return pCounter;
}

/* external functions */
BOOL __stdcall
IsValidLogHandle (
    IN  HLOG    hLog
);

/* forward declares */
PDH_FUNCTION
PdhpGetSQLLogHeader (
  IN PPDHI_LOG pLog);

PDH_FUNCTION
PdhpWriteSQLCounters(
    IN  PPDHI_LOG   pLog);

BOOL __stdcall
PdhpConvertFileTimeToSQLString(
    FILETIME *pFileTime,
    WCHAR *szStartDate
)
{
    //1998-01-02 12:00:00.000
    SYSTEMTIME  st;

    if (0 == FileTimeToSystemTime(pFileTime,&st)) return 0;

    swprintf(szStartDate, L"%04d-%02d-%02d %02d:%02d:%02d.%03d",
        st.wYear, st.wMonth, st.wDay, st.wHour,
        st.wMinute, st.wSecond, st.wMilliseconds);
    
    return 1;
}

BOOL __stdcall
PdhpConvertSQLStringToFileTime(
    WCHAR *szStartDate,
    FILETIME *pFileTime
)    //          1111111111222
{   //01234567890123456789012
    //1998-01-02 12:00:00.000

    SYSTEMTIME  st;
    
    WCHAR buffer[TIME_FIELD_BUFF_SIZE];
    WCHAR *pwchar;

    lstrcpyW(buffer,szStartDate);
    
    buffer[4] = 0;
    st.wYear = (WORD) _wtoi(buffer);
    pwchar = &(buffer[5]);
    buffer[7] = 0;
    st.wMonth = (WORD) _wtoi(pwchar);
    pwchar = &(buffer[8]);
    buffer[10] = 0;
    st.wDay = (WORD) _wtoi(pwchar);
    pwchar = &(buffer[11]);
    buffer[13] = 0;
    st.wHour = (WORD) _wtoi(pwchar);
    pwchar = &(buffer[14]);
    buffer[16] = 0;
    st.wMinute = (WORD) _wtoi(pwchar);
    pwchar = &(buffer[17]);
    buffer[19] = 0;
    st.wSecond = (WORD) _wtoi(pwchar);
    pwchar = &(buffer[20]);
    st.wMilliseconds = (WORD) _wtoi(pwchar);


    return SystemTimeToFileTime (&st, pFileTime);
}

LPWSTR __stdcall
PdhpGetNextMultisz(
    IN LPWSTR mszSource
)
{
    // get the next string in a multisz
    LPVOID  szDestElem;

    szDestElem=mszSource;

    szDestElem = (LPVOID)((LPWSTR)szDestElem +
            (lstrlenW((LPCWSTR)szDestElem)+1));

    return ((LPWSTR)szDestElem);
}

DWORD
PdhpAddUniqueUnicodeStringToMultiSz (
    IN  LPVOID  mszDest,
    IN  LPWSTR  wszSource,
    IN  BOOL    bUnicodeDest
)
/*++

Routine Description:

    searches the Multi-SZ list, mszDest for wszSource and appends it
        to mszDest if it wasn't found.
    Assumes wszSource is UNICODE - and may have to be converted to ASCII
        for an ascii destination 

Arguments:

    OUT LPVOID  mszDest     Multi-SZ list to get new string
    IN  LPSTR   wszSource    string to add if it's not already in list

ReturnValue:

    The new length of the destination string including both
    trailing NULL characters if the string was added, or 0 if the
    string is already in the list.

--*/
{
    LPVOID  szDestElem;
    DWORD_PTR   dwReturnLength;
    LPSTR  aszSource = NULL;
    DWORD   dwLength;

    // check arguments

    if ((mszDest == NULL) || (wszSource == NULL)) return 0; // invalid buffers
    if (*wszSource == '\0') return 0;    // no source string to add

    // if ascii list, make an ascii copy of the source string to compare
    // and ultimately copy if it's not already in the list

    if (!bUnicodeDest) {
        dwLength = lstrlenW(wszSource) + 1;
        aszSource = G_ALLOC ((dwLength * 3 * sizeof(CHAR))); // DBCS concern
        if (aszSource != NULL) {
            dwReturnLength = WideCharToMultiByte(_getmbcp(),
                                                 0,
                                                 wszSource,
                                                 lstrlenW(wszSource),
                                                 aszSource,
                                                 dwLength * 3 * sizeof(CHAR),
                                                 NULL,
                                                 NULL);
        } else {
            // unable to allocate memory for the temp string
            dwReturnLength = 0;
        }
    } else {
        // just use the Unicode version of the source file name
        dwReturnLength = 1;
    }

    if (dwReturnLength > 0) {
        // go to end of dest string
        //
        for (szDestElem = mszDest;
                (bUnicodeDest ? (*(LPWSTR)szDestElem != 0) :
                    (*(LPSTR)szDestElem != 0));
                ) {
            if (bUnicodeDest) {
                // bail out if string already in list
                if (lstrcmpiW((LPCWSTR)szDestElem, wszSource) == 0) {
                    dwReturnLength = 0;
                    goto AddString_Bailout;
                } else {
                    // goto the next item
                    szDestElem = (LPVOID)((LPWSTR)szDestElem +
                        (lstrlenW((LPCWSTR)szDestElem)+1));
                }
            }  else {
                // bail out if string already in list
                if (lstrcmpiA((LPSTR)szDestElem, aszSource) == 0) {
                    dwReturnLength = 0;
                    goto AddString_Bailout;
                } else {
                    // goto the next item
                    szDestElem = (LPVOID)((LPSTR)szDestElem +
                        (lstrlenA((LPCSTR)szDestElem)+1));
                }
            }
        }

        // if here, then add string
        // szDestElem is at end of list

        if (bUnicodeDest) {
            lstrcpyW ((LPWSTR)szDestElem, wszSource);
            szDestElem = (LPVOID)((LPWSTR)szDestElem + lstrlenW(wszSource) + 1);
            *((LPWSTR)szDestElem)++ = L'\0';
            dwReturnLength = (DWORD)((LPWSTR)szDestElem - (LPWSTR)mszDest);
                // return len is in wide char

        } else {
            lstrcpyA ((LPSTR)szDestElem, aszSource);
            szDestElem = (LPVOID)((LPSTR)szDestElem + lstrlenA(szDestElem) + 1);
            *((LPSTR)szDestElem)++ = '\0'; // add second NULL
            dwReturnLength = (DWORD)((LPSTR)szDestElem - (LPSTR)mszDest);
                // return len is in bytes

        }
    }

AddString_Bailout:
    if (aszSource != NULL) {
        G_FREE (aszSource);
    }
    
    return (DWORD)dwReturnLength;
}

DWORD __stdcall
PdhpSQLAddUniqueStringToMultiSz (
    IN  LPVOID   mszDest,
    IN  LPWSTR   wszSource
)
/*++

Routine Description:

    searches the Multi-SZ list, mszDest for szSource and appends it
        to mszDest if it wasn't found (source & dest assumed to be both
        UNICODE)

Arguments:

    OUT LPVOID  mszDest     Multi-SZ list to get new string
    IN  LPSTR   szSource    string to add if it's not already in list

ReturnValue:

    The new length of the destination string including both
    trailing NULL characters if the string was added, or 0 if the
    string is already in the list.

--*/
{
    LPVOID  szDestElem;
    DWORD   dwReturnLength;

    // check arguments

    if ((mszDest == NULL) || (wszSource == NULL)) return 0; // invalid buffers
    if (*wszSource == '\0') return 0;    // no source string to add


    // go to end of dest string
    //
    for (szDestElem = mszDest;(*(LPWSTR)szDestElem != 0); )
    {
        // bail out if string already in lsit
        if (lstrcmpiW((LPCWSTR)szDestElem, wszSource) == 0) 
        {
            dwReturnLength = 0;
            goto Bailout;
        }
        else
        {
            // goto the next item
            szDestElem = (LPVOID)((LPWSTR)szDestElem +
                (lstrlenW((LPCWSTR)szDestElem)+1));
        }

    }

    // if here (at end of multi sz), then add string
    // szDestElem is at end of list

    lstrcpyW ((LPWSTR)szDestElem, wszSource);
    szDestElem = (LPVOID)((LPWSTR)szDestElem + lstrlenW(wszSource) + 1);
    *((LPWSTR)szDestElem)++ = L'\0';
    dwReturnLength = (DWORD)((LPWSTR)szDestElem - (LPWSTR)mszDest);
    // return len is in wide char

Bailout:

    return dwReturnLength;
}

DWORD __stdcall
PdhpSQLAddStringToMultiSz (
    IN  LPVOID   mszDest,
    IN  LPWSTR   wszSource
)
/*++

Routine Description:

    Appends wszSource to mszDest (source & dest assumed to be both
        UNICODE)

Arguments:

    OUT LPVOID  mszDest     Multi-SZ list to get new string
    IN  LPSTR   szSource    string to add

ReturnValue:

    The new length of the destination string including both
    trailing NULL characters

--*/
{
    LPVOID  szDestElem;
    DWORD   dwReturnLength;

    // check arguments

    if ((mszDest == NULL) || (wszSource == NULL)) return 0; // invalid buffers
    if (*wszSource == '\0') return 0;    // no source string to add


    // go to end of dest string
    //
    for (szDestElem = mszDest;(*(LPWSTR)szDestElem != 0); )
    {
        // goto the next item
        szDestElem = (LPVOID)((LPWSTR)szDestElem +
            (lstrlenW((LPCWSTR)szDestElem)+1));
    }

    // if here (at end of multi sz), then add string
    // szDestElem is at end of list

    lstrcpyW ((LPWSTR)szDestElem, wszSource);
    szDestElem = (LPVOID)((LPWSTR)szDestElem + lstrlenW(wszSource) + 1);
    *((LPWSTR)szDestElem)++ = L'\0';
    dwReturnLength = (DWORD)((LPWSTR)szDestElem - (LPWSTR)mszDest);
    // return len is in wide char

    return dwReturnLength;
}

PPDH_SQL_BULK_COPY
PdhiBindBulkCopyStructure(
    IN  PPDHI_LOG   pLog
)
{
    PDH_STATUS         Status = ERROR_SUCCESS;
    PPDH_SQL_BULK_COPY pBulk  = (PPDH_SQL_BULK_COPY) pLog->lpMappedFileBase;
    RETCODE            rc;

    if (pBulk != NULL) return pBulk;

    pBulk = G_ALLOC(sizeof(PDH_SQL_BULK_COPY));
    if (pBulk != NULL) {
        pLog->lpMappedFileBase = pBulk;
        pBulk->dbGuid          = pLog->guidSQL;
        pBulk->dwRecordCount   = 0;

        rc = bcp_initW(pLog->hdbcSQL, L"CounterData", NULL, NULL, DB_IN);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }

        rc = bcp_bind(pLog->hdbcSQL,
                      (LPCBYTE) & (pBulk->dbGuid),
                      0,
                      sizeof(GUID),
                      NULL,
                      0,
                      SQLUNIQUEID,
                      1);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }

        rc = bcp_bind(pLog->hdbcSQL,
                      (LPCBYTE) & (pBulk->dbCounterId),
                      0,
                      sizeof(INT),
                      NULL,
                      0,
                      SQLINT4,
                      2);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }

        rc = bcp_bind(pLog->hdbcSQL,
                      (LPCBYTE) & (pBulk->dbRecordIndex),
                      0,
                      sizeof(INT),
                      NULL,
                      0,
                      SQLINT4,
                      3);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }

        rc = bcp_bind(pLog->hdbcSQL,
                      (LPCBYTE) (pBulk->dbDateTime),
                      0,
                      24,
                      NULL,
                      0,
                      SQLCHARACTER,
                      4);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }

        rc = bcp_bind(pLog->hdbcSQL,
                      (LPCBYTE) & (pBulk->dbCounterValue),
                      0,
                      sizeof(double),
                      NULL,
                      0,
                      SQLFLT8,
                      5);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }

        rc = bcp_bind(pLog->hdbcSQL,
                      (LPCBYTE) & (pBulk->dbFirstValueA),
                      0,
                      sizeof(INT),
                      NULL,
                      0,
                      SQLINT4,
                      6);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }

        rc = bcp_bind(pLog->hdbcSQL,
                      (LPCBYTE) & (pBulk->dbFirstValueB),
                      0,
                      sizeof(INT),
                      NULL,
                      0,
                      SQLINT4,
                      7);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }

        rc = bcp_bind(pLog->hdbcSQL,
                      (LPCBYTE) & (pBulk->dbSecondValueA),
                      0,
                      sizeof(INT),
                      NULL,
                      0,
                      SQLINT4,
                      8);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }

        rc = bcp_bind(pLog->hdbcSQL,
                      (LPCBYTE) & (pBulk->dbSecondValueB),
                      0,
                      sizeof(INT),
                      NULL,
                      0,
                      SQLINT4,
                      9);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }

        rc = bcp_bind(pLog->hdbcSQL,
                      (LPCBYTE) & (pBulk->dbMultiCount),
                      0,
                      sizeof(INT),
                      NULL,
                      0,
                      SQLINT4,
                      10);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
    }
    else {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
    }

Cleanup:
    if (Status != ERROR_SUCCESS) {
        if (pBulk != NULL) G_FREE(pBulk);
        pBulk  = pLog->lpMappedFileBase = NULL;
        Status = ReportSQLError(pLog, SQL_ERROR, NULL, Status);
        SetLastError(Status);
    }
    return pBulk;
}

PDH_FUNCTION
PdhiSqlUpdateCounterDetails(
    IN  PPDHI_LOG         pLog,
    IN  BOOL              bBeforeSendRow,
    IN  PPDHI_LOG_MACHINE pMachine,
    IN  PPDHI_LOG_OBJECT  pObject,
    IN  PPDHI_LOG_COUNTER pCounter,
    IN  LONGLONG          TimeBase,
    IN  LPWSTR            szMachine,
    IN  LPWSTR            szObject,
    IN  LPWSTR            szCounter,
    IN  DWORD             dwCounterType,
    IN  DWORD             dwDefaultScale,
    IN  LPWSTR            szInstance,
    IN  DWORD             dwInstance,
    IN  LPWSTR            szParent,
    IN  DWORD             dwParent
)
{
    PDH_STATUS Status = ERROR_SUCCESS;
    HSTMT      hstmt  = NULL;
    RETCODE    rc;
    WCHAR      szSQLStmt[SQLSTMTSIZE];
    DWORD      dwCounterId;
    SQLLEN     dwCounterIdLen;
    SQLLEN     dwRowCount;

    PPDH_SQL_BULK_COPY pBulk = (PPDH_SQL_BULK_COPY) pLog->lpMappedFileBase;

    if (! bBeforeSendRow) {
        if (pBulk != NULL && pBulk->dwRecordCount > 0) {
            DBINT rcBCP = bcp_batch(pLog->hdbcSQL);
            if (rcBCP < 0) {
                DebugPrint((1,"bcp_batch(%05d,0x%08X,%d,%d)\n",
                         __LINE__, pLog->hdbcSQL, rcBCP, pBulk->dwRecordCount));
                ReportSQLError(pLog, SQL_ERROR, NULL, PDH_SQL_EXEC_DIRECT_FAILED);
            }
            pBulk->dwRecordCount = 0;
        }
    }

    rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    // need to cover the following cases where 0 = NULL, 1 = present,
    // can't have an Instance Index without an Instance Name
    //
    // Instance Name
    //  Instance Index
    //   Parent Name
    //    Parent Object ID
    // 0000
    // 1000  pos 4 & 5 are countertype,defscale
    // 0010
    // 0001
    // 1100
    // 1010
    // 1001
    // 0011
    // 1110
    // 1101
    // 1011
    // 1111
    //
    if (   (szInstance == NULL || szInstance[0] == L'\0')
        && dwInstance == 0
        && (szParent == NULL || szParent[0] == L'\0')
        && dwParent == 0) {
        swprintf(szSQLStmt, // 0000
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d, NULL,NULL,NULL,NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale, LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if (   (szInstance != NULL && szInstance[0] != '\0')
             && dwInstance == 0
             && (szParent == NULL || szParent[0] == '\0')
             && dwParent == 0) {
        swprintf(szSQLStmt, // 1000
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d, '%ws',NULL,NULL,NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                szInstance, LODWORD(TimeBase), HIDWORD(TimeBase));

    }
    else if (   (szInstance == NULL || szInstance[0] == '\0')
             && dwInstance == 0
             && (szParent != NULL && szParent[0] != '\0')
             && dwParent == 0) {
        swprintf(szSQLStmt,  // 0010
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d, NULL,NULL,'%ws',NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                szParent, LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if (   (szInstance == NULL || szInstance[0] == '\0')
             && dwInstance == 0
             && (szParent == NULL || szParent[0] == '\0')
             && dwParent != 0) {
        swprintf(szSQLStmt,  // 0001
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d, NULL,NULL,NULL,%d,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                dwParent, LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if (   (szInstance != NULL && szInstance[0] != '\0')
             && dwInstance != 0
             && (szParent == NULL || szParent[0] == '\0')
             && dwParent == 0) {
        swprintf(szSQLStmt, // 1100
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d, '%ws',%d,NULL,NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                szInstance, dwInstance, LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if (   (szInstance != NULL && szInstance[0] != '\0')
             && dwInstance == 0
             && (szParent != NULL && szParent[0] != '\0')
             && dwParent == 0) {
        swprintf(szSQLStmt, // 1010
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d, '%ws',NULL,'%ws',NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                szInstance, szParent, LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if (   (szInstance != NULL && szInstance[0] != '\0')
             && dwInstance == 0
             && (szParent == NULL || szParent[0] == '\0')
             && dwParent != 0) {
        swprintf(szSQLStmt, // 1001
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d, '%ws',NULL,NULL,%d,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                szInstance, dwParent, LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if (   (szInstance == NULL || szInstance[0] == '\0')
             && dwInstance == 0
             && (szParent != NULL && szParent[0] != '\0')
             && dwParent != 0) {
        swprintf(szSQLStmt, // 0011
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d, NULL,NULL,'%ws',%d,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                szParent, dwParent, LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if (   (szInstance != NULL && szInstance[0] != '\0')
             && dwInstance != 0
             && (szParent != NULL && szParent[0] != '\0')
             && dwParent == 0) {
        swprintf(szSQLStmt, // 1110
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d, '%ws',%d,'%ws',NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                szInstance, dwInstance, szParent, LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if (   (szInstance != NULL && szInstance[0] != '\0')
             && dwInstance != 0
             && (szParent == NULL || szParent[0] == '\0')
             && dwParent != 0) {
        swprintf(szSQLStmt, //1101
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d, '%ws',%d,NULL,%d,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                szInstance, dwInstance, dwParent, LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if (   (szInstance != NULL && szInstance[0] != '\0')
             && dwInstance == 0
             && (szParent != NULL && szParent[0] != '\0')
             && dwParent != 0) {
        swprintf(szSQLStmt, // 1011
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d, '%ws',NULL,'%ws',%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                szInstance, szParent, dwParent, LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if (   (szInstance != NULL && szInstance[0] != '\0')
             && dwInstance != 0
             && (szParent != NULL && szParent[0] != '\0')
             && dwParent != 0) {
        swprintf(szSQLStmt, // 1111
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws', %d, %d,'%ws',%d,'%ws',%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                szInstance, dwInstance, szParent, dwParent, LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else {
        Status = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }
    
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }

    rc = SQLRowCount(hstmt, & dwRowCount);
    if (!SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ROWCOUNT_FAILED);
        goto Cleanup;
    }

    rc = SQLMoreResults(hstmt);
    if (!SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_MORE_RESULTS_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 1, SQL_C_SLONG, & dwCounterId, 0, & dwCounterIdLen);
    if (!SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLFetch(hstmt);
    if (!SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
        goto Cleanup;
    }

    if (SQL_NO_DATA == rc) {
        Status = PDH_NO_DATA;
        goto Cleanup;
    }

    if (pCounter != NULL) {
        pCounter->dwCounterID = dwCounterId;
    }

Cleanup:
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    return Status;
}

PPDHI_LOG_COUNTER
PdhiSqlFindCounter(
    IN  PPDHI_LOG           pLog,
    IN  PPDHI_LOG_MACHINE * MachineTable,
    IN  LPWSTR              szMachine,
    IN  LPWSTR              szObject,
    IN  LPWSTR              szCounter,
    IN  DWORD               dwCounterType,
    IN  DWORD               dwDefaultScale,
    IN  LPWSTR              szInstance,
    IN  DWORD               dwInstance,
    IN  LPWSTR              szParent,
    IN  DWORD               dwParent,
    IN  LONGLONG            TimeBase,
    IN  BOOL                bBeforeSendRow,
    IN  BOOL                bInsert
)
{
    PPDHI_LOG_MACHINE   pMachine = NULL;
    PPDHI_LOG_OBJECT    pObject  = NULL;
    PPDHI_LOG_COUNTER   pCounter = NULL;
    PPDHI_LOG_COUNTER   pNode    = NULL;
    PPDHI_LOG_COUNTER * pStack[MAX_BTREE_DEPTH];
    PPDHI_LOG_COUNTER * pLink;
    int                 dwStack = 0;
    PPDHI_LOG_COUNTER   pParent;
    PPDHI_LOG_COUNTER   pSibling;
    PPDHI_LOG_COUNTER   pChild;
    int                 iCompare;
    BOOL                bUpdateCounterDetail = FALSE;

    pMachine = PdhiFindLogMachine(MachineTable, szMachine, bInsert);
    if (pMachine == NULL) goto Cleanup;

    pObject = PdhiFindLogObject(pMachine, & (pMachine->ObjTable), szObject, bInsert);
    if (pObject == NULL) goto Cleanup;

    pStack[dwStack ++] = & (pObject->CtrTable);
    pCounter = pObject->CtrTable;
    while (pCounter != NULL) {
        iCompare = PdhiCompareLogCounterInstance(pCounter,
                        szCounter, szInstance, dwInstance, szParent);
        if (iCompare == 0) {
            if (dwCounterType < pCounter->dwCounterType) {
                iCompare = -1;
            }
            else if (dwCounterType > pCounter->dwCounterType) {
                iCompare = 1;
            }
            else {
                iCompare = 0;
            }
        }
        if (iCompare < 0) {
            pStack[dwStack ++] = & (pCounter->left);
            pCounter = pCounter->left;
        }
        else if (iCompare > 0) {
            pStack[dwStack ++] = & (pCounter->right);
            pCounter = pCounter->right;
        }
        else {
            break;
        }
    }

    if (pCounter == NULL) {
        pCounter = G_ALLOC(sizeof(PDHI_LOG_COUNTER) + sizeof(WCHAR) * (3 * (PDH_SQL_STRING_SIZE + 1)));
        if (pCounter == NULL) goto Cleanup;

        pCounter->bIsRed         = TRUE;
        pCounter->left           = NULL;
        pCounter->right          = NULL;
        pCounter->dwCounterType  = dwCounterType;
        pCounter->dwDefaultScale = dwDefaultScale;
        pCounter->dwInstance     = dwInstance;
        pCounter->dwParent       = dwParent;
        pCounter->TimeStamp      = 0;
        pCounter->TimeBase       = TimeBase;

        pCounter->szCounter = (LPWSTR)
                            (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER));
        lstrcpynW(pCounter->szCounter, szCounter, PDH_SQL_STRING_SIZE);
        if (szInstance == NULL || szInstance[0] == L'\0') {
            pCounter->szInstance = NULL;
        }
        else {
            pCounter->szInstance = (LPWSTR) (((PCHAR) pCounter)
                                 + sizeof(PDHI_LOG_COUNTER)
                                 + sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
            lstrcpynW(pCounter->szInstance, szInstance, PDH_SQL_STRING_SIZE);
        }

        if (szParent == NULL || szParent[0] == L'\0') {
            pCounter->szParent = NULL;
        }
        else {
            pCounter->szParent = (LPWSTR) (((PCHAR) pCounter)
                               + sizeof(PDHI_LOG_COUNTER)
                               + 2 * sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
            lstrcpynW(pCounter->szParent, szParent, PDH_SQL_STRING_SIZE);
        }

        if (bInsert) {
            bUpdateCounterDetail = TRUE;
        }

        pLink   = pStack[-- dwStack];
        * pLink = pCounter;

        pChild  = NULL;
        pNode   = pCounter;
        while (dwStack > 0) {
            pLink   = pStack[-- dwStack];
            pParent = * pLink;
            if (! pParent->bIsRed) {
                pSibling = (pParent->left == pNode)
                         ? pParent->right : pParent->left;
                if (pSibling && pSibling->bIsRed) {
                    pNode->bIsRed    = FALSE;
                    pSibling->bIsRed = FALSE;
                    pParent->bIsRed  = TRUE;
                }
                else {
                    if (pChild && pChild->bIsRed) {
                        if (pChild == pNode->left) {
                            if (pNode == pParent->left) {
                                pParent->bIsRed  = TRUE;
                                pParent->left    = pNode->right;
                                pNode->right     = pParent;
                                pNode->bIsRed    = FALSE;
                                * pLink          = pNode;
                            }
                            else {
                                pParent->bIsRed  = TRUE;
                                pParent->right   = pChild->left;
                                pChild->left     = pParent;
                                pNode->left      = pChild->right;
                                pChild->right    = pNode;
                                pChild->bIsRed   = FALSE;
                                * pLink          = pChild;
                            }
                        }
                        else {
                            if (pNode == pParent->right) {
                                pParent->bIsRed  = TRUE;
                                pParent->right   = pNode->left;
                                pNode->left      = pParent;
                                pNode->bIsRed    = FALSE;
                                * pLink          = pNode;
                            }
                            else {
                                pParent->bIsRed  = TRUE;
                                pParent->left    = pChild->right;
                                pChild->right    = pParent;
                                pNode->right     = pChild->left;
                                pChild->left     = pNode;
                                pChild->bIsRed   = FALSE;
                                * pLink          = pChild;
                            }
                        }
                    }
                    break;
                }
            }
            pChild = pNode;
            pNode  = pParent;
        }

        pObject->CtrTable->bIsRed = FALSE;
    }

    if (bUpdateCounterDetail && pCounter) {
        PdhiSqlUpdateCounterDetails(pLog,
                                    bBeforeSendRow,
                                    pMachine,
                                    pObject,
                                    pCounter,
                                    pCounter->TimeBase,
                                    pMachine->szMachine,
                                    pObject->szObject,
                                    pCounter->szCounter,
                                    dwCounterType,
                                    dwDefaultScale,
                                    pCounter->szInstance,
                                    dwInstance,
                                    pCounter->szParent,
                                    dwParent);
    }

Cleanup:
    return pCounter;
}

PDH_FUNCTION
PdhiSqlBuildCounterObjectNode(
    IN  PPDHI_LOG          pLog,
    IN  LPWSTR             szMachine,
    IN  LPWSTR             szObject
)
{
    PDH_STATUS        Status             = ERROR_SUCCESS;
    RETCODE           rc                 = SQL_SUCCESS;
    HSTMT             hstmt              = NULL;
    DWORD             CounterID          = 0;
    SQLLEN            dwCounterID        = 0;
    WCHAR             CounterName[PDH_SQL_STRING_SIZE];
    SQLLEN            dwCounterName      = 0;
    DWORD             CounterType        = 0;
    SQLLEN            dwCounterType      = 0;
    DWORD             DefaultScale       = 0;
    SQLLEN            dwDefaultScale     = 0;
    WCHAR             InstanceName[PDH_SQL_STRING_SIZE];
    SQLLEN            dwInstanceName     = 0;
    DWORD             InstanceIndex      = 0;
    SQLLEN            dwInstanceIndex    = 0;
    WCHAR             ParentName[PDH_SQL_STRING_SIZE];
    SQLLEN            dwParentName       = 0;
    DWORD             ParentObjectID     = 0;
    SQLLEN            dwParentObjectID   = 0;
    LARGE_INTEGER     lTimeBase;
    SQLLEN            dwTimeBaseA        = 0;
    SQLLEN            dwTimeBaseB        = 0;
    WCHAR             SQLStmt[SQLSTMTSIZE];
    BOOL              bFind              = FALSE;
    PPDHI_LOG_OBJECT  pObject            = NULL;
    PPDHI_LOG_MACHINE pMachine;
    PPDHI_LOG_COUNTER pCounter;

    for (pMachine  = ((PPDHI_LOG_MACHINE) (pLog->pPerfmonInfo));
         pMachine != NULL && lstrcmpiW(pMachine->szMachine, szMachine) != 0;
         pMachine  = pMachine->next);
    if (pMachine != NULL) {
        pObject = pMachine->ObjTable;
        while (pObject != NULL) {
            int iCompare = lstrcmpiW(szObject, pObject->szObject);
            if (iCompare < 0)      pObject = pObject->left;
            else if (iCompare > 0) pObject = pObject->right;
            else break;
        }
    }
    if (pObject != NULL) goto Cleanup;

    swprintf(SQLStmt,
              L"select CounterID, CounterName, CounterType, DefaultScale, InstanceName, InstanceIndex, ParentName, ParentObjectID, TimeBaseA, TimeBaseB from CounterDetails where MachineName = '%ws' and ObjectName = '%ws'",
              szMachine, szObject);

    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 1, SQL_C_LONG, & CounterID, 0, & dwCounterID);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 2, SQL_C_WCHAR, CounterName, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwCounterName);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 3, SQL_C_LONG, & CounterType, 0, & dwCounterType);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 4, SQL_C_LONG, & DefaultScale, 0, & dwDefaultScale);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 5, SQL_C_WCHAR, InstanceName, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwInstanceName);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 6, SQL_C_LONG, & InstanceIndex, 0, & dwInstanceIndex);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 7, SQL_C_WCHAR, ParentName, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwParentName);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 8, SQL_C_LONG, & ParentObjectID, 0, & dwParentObjectID);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 9, SQL_C_LONG, & lTimeBase.LowPart, 0, & dwTimeBaseA);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 10, SQL_C_LONG, & lTimeBase.HighPart, 0, & dwTimeBaseB);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLExecDirectW(hstmt, SQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }

    ZeroMemory(CounterName,  sizeof(CounterName));
    ZeroMemory(InstanceName, sizeof(InstanceName));
    ZeroMemory(ParentName,   sizeof(ParentName));
    CounterType = DefaultScale = InstanceIndex = ParentObjectID = 0;
    rc = SQLFetch(hstmt);
    while (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO) {
        pCounter = PdhiSqlFindCounter(
                          pLog,
                          (PPDHI_LOG_MACHINE *) (& (pLog->pPerfmonInfo)),
                          szMachine,
                          szObject,
                          CounterName,
                          CounterType,
                          DefaultScale,
                          InstanceName,
                          InstanceIndex,
                          ParentName,
                          ParentObjectID,
                          0,
                          TRUE,
                          FALSE);
        if (pCounter != NULL) {
            pCounter->dwCounterID = CounterID;
            if (dwTimeBaseA != SQL_NULL_DATA && dwTimeBaseB != SQL_NULL_DATA) {
                pCounter->TimeBase      = lTimeBase.QuadPart;
            }
            else {
                pCounter->TimeBase      = 0;
                pCounter->dwCounterType = PERF_DOUBLE_RAW;
            }
        }
        ZeroMemory(CounterName,  sizeof(CounterName));
        ZeroMemory(InstanceName, sizeof(InstanceName));
        ZeroMemory(ParentName,   sizeof(ParentName));
        CounterType = DefaultScale = InstanceIndex = ParentObjectID = 0;
        rc = SQLFetch(hstmt);
    }
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
        goto Cleanup;
    }

    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiSqlGetCounterArray(
    IN  PPDHI_COUNTER  pCounter,
    IN  LPDWORD        lpdwBufferSize,
    IN  LPDWORD        lpdwItemCount,
    IN  LPVOID         ItemBuffer
)
{
    PDH_STATUS                    Status          = ERROR_SUCCESS;
    PDH_STATUS                    PdhFnStatus     = ERROR_SUCCESS;
    DWORD                         dwRequiredSize  = 0;
    PPDHI_RAW_COUNTER_ITEM        pThisItem       = NULL;
    PPDHI_RAW_COUNTER_ITEM        pLastItem       = NULL;
    LPWSTR                        szThisItem      = NULL;
    LPWSTR                        szLastItem      = NULL;
    PPDH_RAW_COUNTER              pThisRawCounter = NULL;
    PPDH_RAW_COUNTER              pLastRawCounter = NULL;
    PPDH_FMT_COUNTERVALUE_ITEM_W  pThisFmtItem    = NULL;
    DWORD       dwThisItemIndex;
    LPWSTR      wszNextString;
    DWORD       dwRetItemCount = 0;

    LIST_ENTRY     InstList;
    PPDHI_INSTANCE pInstance;
    WCHAR          szPound[16];

    InitializeListHead(& InstList);
    Status = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    if(pCounter->pThisRawItemList == NULL) {
        Status = PDH_CSTATUS_ITEM_NOT_VALIDATED;
        goto Cleanup;
    }

    dwRetItemCount  = pCounter->pThisRawItemList->dwItemCount;
    dwThisItemIndex = 0;

    if (ItemBuffer != NULL) {
        pThisRawCounter = (PPDH_RAW_COUNTER) ItemBuffer;
    }
    else {
        pThisRawCounter = NULL;
    }
    assert(((DWORD) pThisRawCounter & 0x00000007) == 0);

    dwRequiredSize  = (DWORD) (dwRetItemCount * sizeof(PDH_RAW_COUNTER));
    if ((ItemBuffer != NULL) && (dwRequiredSize <= * lpdwBufferSize)) {
        pThisFmtItem = (PPDH_FMT_COUNTERVALUE_ITEM_W)
                       (((LPBYTE) ItemBuffer) + dwRequiredSize);
    }
    else {
        pThisFmtItem = NULL;
    }
    assert(((DWORD) pThisFmtItem & 0x00000007) == 0);

    dwRequiredSize +=
            (DWORD) (dwRetItemCount * sizeof(PDH_FMT_COUNTERVALUE_ITEM_W));
    if ((ItemBuffer != NULL) && (dwRequiredSize <= * lpdwBufferSize)) {
        wszNextString = (LPWSTR) (((LPBYTE) ItemBuffer) + dwRequiredSize);
    }
    else {
        wszNextString = NULL;
    }
    assert(((DWORD) wszNextString & 0x00000007) == 0);

    for (pThisItem = & (pCounter->pThisRawItemList->pItemArray[0]);
            dwThisItemIndex < dwRetItemCount;
            dwThisItemIndex ++, pThisItem ++, pLastItem ++) {
        szThisItem = (LPWSTR) (  ((LPBYTE) pCounter->pThisRawItemList)
                               + pThisItem->szName);
        pInstance = NULL;
        Status = PdhiFindInstance(& InstList, szThisItem, TRUE, & pInstance);
        if (   Status == ERROR_SUCCESS && pInstance != NULL
                                       && pInstance->dwCount > 1) {
            ZeroMemory(szPound, 16 * sizeof(WCHAR));
            _itow(pInstance->dwCount - 1, szPound, 10);
            dwRequiredSize += (lstrlenW(szThisItem) + lstrlenW(szPound) + 2)
                            * sizeof(WCHAR);
        }
        else {
            dwRequiredSize += (lstrlenW(szThisItem) + 1) * sizeof(WCHAR);
        }
        if ((dwRequiredSize <= * lpdwBufferSize) && (wszNextString != NULL)) {
            DWORD dwNextString;

            pThisFmtItem->szName = wszNextString;
            lstrcpyW(wszNextString, szThisItem);
            if (pInstance != NULL) {
                if (pInstance->dwCount > 1) {
                    lstrcatW(wszNextString, cszPoundSign);
                    lstrcatW(wszNextString, szPound);
                }
            }
            dwNextString         = lstrlenW(wszNextString);
            wszNextString       += (dwNextString + 1);
            Status               = ERROR_SUCCESS;
        }
        else {
            Status = PDH_MORE_DATA;
        }

        if (Status == ERROR_SUCCESS) {
            if (pCounter->pThisRawItemList != NULL) {
                pThisRawCounter->CStatus     = pCounter->pThisRawItemList->CStatus;
                pThisRawCounter->TimeStamp   = pCounter->pThisRawItemList->TimeStamp;
                pThisRawCounter->FirstValue  = pThisItem->FirstValue;
                pThisRawCounter->SecondValue = pThisItem->SecondValue;
                pThisRawCounter->MultiCount  = pThisItem->MultiCount;
            }
            else {
                ZeroMemory(pThisRawCounter, sizeof(PDH_RAW_COUNTER));
            }

            pLastRawCounter = NULL;
            if (pCounter->pLastRawItemList != NULL) {
                PPDH_FMT_COUNTERVALUE_ITEM_W pFmtValue;
                DWORD dwLastItem = pCounter->LastValue.MultiCount;
                DWORD i;

                pFmtValue = (PPDH_FMT_COUNTERVALUE_ITEM_W)
                            (  ((LPBYTE) pCounter->pLastObject)
                             + sizeof(PDH_RAW_COUNTER) * dwLastItem);

                for (i = 0; i < dwLastItem; i ++) {
                    if (lstrcmpiW(pThisFmtItem->szName,
                                  pFmtValue->szName) == 0) {
                        pLastRawCounter = (PPDH_RAW_COUNTER)
                                          (  ((LPBYTE) pCounter->pLastObject)
                                           + sizeof(PDH_RAW_COUNTER) * i);
                        break;
                    }
                    else {
                        pFmtValue = (PPDH_FMT_COUNTERVALUE_ITEM_W)
                                    (  ((LPBYTE) pFmtValue)
                                     + sizeof(PDH_FMT_COUNTERVALUE_ITEM_W));
                    }
                }
            }

            PdhFnStatus = PdhiComputeFormattedValue(
                            pCounter->CalcFunc,
                            pCounter->plCounterInfo.dwCounterType,
                            pCounter->lScale,
                            PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                            pThisRawCounter,
                            pLastRawCounter,
                            & pCounter->TimeBase,
                            0L,
                            & pThisFmtItem->FmtValue);
            if (PdhFnStatus != ERROR_SUCCESS) {
                //Status                             = PdhFnStatus;
                pThisFmtItem->FmtValue.CStatus     = PDH_CSTATUS_INVALID_DATA;
                pThisFmtItem->FmtValue.doubleValue = 0;
            }

            pThisRawCounter = (PPDH_RAW_COUNTER)
                (((LPBYTE) pThisRawCounter) + sizeof(PDH_RAW_COUNTER));
            pThisFmtItem = (PPDH_FMT_COUNTERVALUE_ITEM_W)
                (((LPBYTE) pThisFmtItem) + sizeof(PDH_FMT_COUNTERVALUE_ITEM_W));
        }
    }

    dwRetItemCount = dwThisItemIndex;

Cleanup:
    RELEASE_MUTEX(pCounter->pOwner->hMutex);
    if (! IsListEmpty(& InstList)) {
        PLIST_ENTRY pHead = & InstList;
        PLIST_ENTRY pNext = pHead->Flink;
        while (pNext != pHead) {
            pInstance = CONTAINING_RECORD(pNext, PDHI_INSTANCE, Entry);
            pNext     = pNext->Flink;
            RemoveEntryList(& pInstance->Entry);
            G_FREE(pInstance);
        }
    }
    if (Status == ERROR_SUCCESS || Status == PDH_MORE_DATA) {
        * lpdwBufferSize = dwRequiredSize;
        * lpdwItemCount  = dwRetItemCount;
    }

    return Status;
}

RETCODE
PdhiCheckSQLExist(IN  HSTMT  hstmt, IN  RETCODE  rcIn)
{
    SQLCHAR     szSQLStat[6];
    SQLCHAR     szMessage[1024];
    RETCODE     rc           = rcIn;
    SQLSMALLINT iMessage     = 1024;
    SQLSMALLINT iSize        = 0;    
    SQLINTEGER  iNativeError = 0;

    ZeroMemory(szSQLStat,    6 * sizeof(SQLCHAR));
    ZeroMemory(szMessage, 1024 * sizeof(SQLCHAR));
    rc = SQLGetDiagRec(SQL_HANDLE_STMT,
                       hstmt,
                       1,
                       szSQLStat,
                       & iNativeError,
                       szMessage,
                       iMessage,
                       & iSize);
    DebugPrint((4,"SQLGetDiagRec(0x%08X,%d,%s,%d,\"%s\")\n",
            hstmt, rcIn, szSQLStat, rc, szMessage));
    if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO) {
        if (   lstrcmpi(szSQLStat, "42S01") == 0
            || lstrcmpi(szSQLStat, "S0001") == 0
            || lstrcmpi(szSQLStat, "42S02") == 0
            || lstrcmpi(szSQLStat, "S0002") == 0
            || lstrcmpi(szSQLStat, "42S11") == 0
            || lstrcmpi(szSQLStat, "S0011") == 0
            || lstrcmpi(szSQLStat, "42S12") == 0
            || lstrcmpi(szSQLStat, "S0012") == 0) {
            rc = SQL_SUCCESS;
        }
        else {
            rc = rcIn;
        }
    }
    else {
        rc = rcIn;
    }

    return rc;
}

PDH_FUNCTION 
PdhiSQLUpdateCounterDetailTimeBase(
    PPDHI_LOG         pLog,
    DWORD             dwCounterId,
    LONGLONG          lTimeBase,
    BOOL              bBeforeSendRow
)
{
    PDH_STATUS Status = ERROR_SUCCESS;
    HSTMT      hstmt  = NULL;
    RETCODE    rc;
    WCHAR      szSQLStmt[SQLSTMTSIZE];

    if (! bBeforeSendRow) {
        PPDH_SQL_BULK_COPY pBulk = (PPDH_SQL_BULK_COPY) pLog->lpMappedFileBase;

        if (pBulk != NULL && pBulk->dwRecordCount > 0) {
            DBINT rcBCP = bcp_batch(pLog->hdbcSQL);
            if (rcBCP < 0) {
                ReportSQLError(pLog, SQL_ERROR, NULL, PDH_SQL_EXEC_DIRECT_FAILED);
            }
            pBulk->dwRecordCount = 0;
        }
    }

    wsprintfW(szSQLStmt, L"UPDATE CounterDetails SET TimeBaseA = %d, TimeBaseB = %d WHERE CounterID = %d",
            LODWORD(lTimeBase), HIDWORD(lTimeBase), dwCounterId);

    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
    }
    else {
        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (! SQLSUCCEEDED(rc)) {
            Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        }
        SQLFreeStmt(hstmt, SQL_DROP);
    }
    return Status;
}

PDH_FUNCTION
PdhiSQLExtendCounterDetail(
    PPDHI_LOG    pLog
)
{
    PDH_STATUS Status       = ERROR_SUCCESS;
    BOOL       bExtend      = FALSE;
    HSTMT      hstmt        = NULL;    
    RETCODE    rc;
    DWORD      dwTimeBaseA;
    SQLLEN     lenTimeBaseA;
    WCHAR      szSQLStmt[SQLSTMTSIZE];

    wsprintfW(szSQLStmt, L"SELECT TimeBaseA FROM CounterDetails");
    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (!SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
    }
    else {
        rc = SQLBindCol(hstmt, 1, SQL_C_LONG, & dwTimeBaseA, 0, & lenTimeBaseA);
        if (! SQLSUCCEEDED(rc)) {
            Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        }
        else {
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                long  iError;
                short cbErrMsg = SQLSTMTSIZE;
                WCHAR szErrMsg[SQLSTMTSIZE];

                SQLErrorW(pLog->henvSQL, pLog->hdbcSQL, hstmt, NULL, & iError, szErrMsg, SQLSTMTSIZE, & cbErrMsg);
                if (iError == 0x00CF) { // 207, Invalid Column Name.
                    bExtend = TRUE;
                }
                else {
                    ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
                }
            }
        }
        SQLFreeStmt(hstmt, SQL_DROP);
    }

    if (bExtend) {
        wsprintfW(szSQLStmt, L"ALTER TABLE CounterDetails ADD TimeBaseA int NULL");
        rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
        if (! SQLSUCCEEDED(rc)) {
            Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        }
        else {
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
            }
            SQLFreeStmt(hstmt, SQL_DROP);
        }

        if (Status == ERROR_SUCCESS) {
            wsprintfW(szSQLStmt, L"ALTER TABLE CounterDetails ADD TimeBaseB int NULL");
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (! SQLSUCCEEDED(rc)) {
                Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
            }
            else {
                rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
                if (! SQLSUCCEEDED(rc)) {
                    Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
                }
                SQLFreeStmt(hstmt, SQL_DROP);
            }
        }
    }

    return Status;
}

PDH_FUNCTION 
PdhpCreateSQLTables (
    IN  PPDHI_LOG    pLog)
{
    // INTERNAL FUNCTION to
    //Create the correct perfmon tables in the database
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PDH_STATUS pdhCreateStatus = ERROR_SUCCESS;
    HSTMT        hstmt = NULL;    
    RETCODE        rc;
    BOOL         bExistData = FALSE;
    WCHAR        szSQLStmt[SQLSTMTSIZE];


    // difficult to cleanup old tables, also dangerous so we won't...
    // PdhiOpenOutputSQLLog calls this routine to ensure the tables are here without checking
    // create the CounterDetails Table

    swprintf(szSQLStmt,L"CREATE TABLE CounterDetails(\
        CounterID                int IDENTITY PRIMARY KEY,\
        MachineName              varchar(%d) NOT NULL,\
        ObjectName               varchar(%d) NOT NULL,\
        CounterName              varchar(%d) NOT NULL,\
        CounterType              int NOT NULL,\
        DefaultScale             int NOT NULL,\
        InstanceName             varchar(%d),\
        InstanceIndex            int,\
        ParentName               varchar(%d),\
        ParentObjectID           int,\
        TimeBaseA                int,\
        TimeBaseB                int\
        )", PDH_SQL_STRING_SIZE, PDH_SQL_STRING_SIZE, PDH_SQL_STRING_SIZE, PDH_SQL_STRING_SIZE, PDH_SQL_STRING_SIZE);

    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    // execute the create statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc))
    {
        rc = PdhiCheckSQLExist(hstmt, rc);
        if (!(SQLSUCCEEDED(rc))) {
            // don't report the error, as this could be called from
            // opening a database that already exists...
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
        else {
            SQLFreeStmt(hstmt, SQL_DROP);
            hstmt = NULL;

            if ((pdhStatus = PdhiSQLExtendCounterDetail(pLog)) != ERROR_SUCCESS) goto Cleanup;

            swprintf(szSQLStmt, L"ALTER TABLE CounterDetails ALTER COLUMN MachineName varchar(%d) NOT NULL",
                         PDH_SQL_STRING_SIZE);
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (!SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
                goto Cleanup;
            }
            SQLFreeStmt(hstmt, SQL_DROP);
            hstmt = NULL;

            swprintf(szSQLStmt, L"ALTER TABLE CounterDetails ALTER COLUMN ObjectName varchar(%d) NOT NULL",
                         PDH_SQL_STRING_SIZE);
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (!SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
                goto Cleanup;
            }
            SQLFreeStmt(hstmt, SQL_DROP);
            hstmt = NULL;

            swprintf(szSQLStmt, L"ALTER TABLE CounterDetails ALTER COLUMN CounterName varchar(%d) NOT NULL",
                         PDH_SQL_STRING_SIZE);
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (!SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
                goto Cleanup;
            }
            SQLFreeStmt(hstmt, SQL_DROP);
            hstmt = NULL;

            swprintf(szSQLStmt, L"ALTER TABLE CounterDetails ALTER COLUMN InstanceName varchar(%d)",
                         PDH_SQL_STRING_SIZE);
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (!SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
                goto Cleanup;
            }
            SQLFreeStmt(hstmt, SQL_DROP);
            hstmt = NULL;

            swprintf(szSQLStmt, L"ALTER TABLE CounterDetails ALTER COLUMN ParentName varchar(%d)",
                         PDH_SQL_STRING_SIZE);
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (!SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
                goto Cleanup;
            }
        }
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    // Create the CounterData table
    swprintf(szSQLStmt,L"CREATE TABLE CounterData(\
        GUID                     uniqueidentifier NOT NULL,\
        CounterID                int NOT NULL,\
        RecordIndex              int NOT NULL,\
        CounterDateTime          char(24) NOT NULL,\
        CounterValue             float NOT NULL,\
        FirstValueA              int,\
        FirstValueB              int,\
        SecondValueA             int,\
        SecondValueB             int,\
        MultiCount               int,\
        )");

    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    // execute the create statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc))
    {
        rc = PdhiCheckSQLExist(hstmt, rc);
        if (!(SQLSUCCEEDED(rc))) {
            // don't report the error, as this could be called from
            // opening a database that already exists...
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
        else {
            bExistData = TRUE;
        }
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    if (! bExistData) {
        // add the primary keys
        swprintf(szSQLStmt,L"ALTER TABLE CounterData ADD PRIMARY KEY (GUID,counterID,RecordIndex)");

        // allocate an hstmt
        rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
        if (!SQLSUCCEEDED(rc))
        {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
            goto Cleanup;
        }

        // execute the create statement
        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (!SQLSUCCEEDED(rc))
        {
            rc = PdhiCheckSQLExist(hstmt, rc);
            if (!(SQLSUCCEEDED(rc))) {
                // don't report the error, as this could be called from
                // opening a database that already exists...
                pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
                goto Cleanup;
            }
        }
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    // create the DisplayToID table
    swprintf(szSQLStmt,L"CREATE TABLE DisplayToID(\
        GUID                      uniqueidentifier NOT NULL PRIMARY KEY,\
        RunID                     int,\
        DisplayString             varchar(%d) NOT NULL UNIQUE,\
        LogStartTime              char(24),\
        LogStopTime               char(24),\
        NumberOfRecords           int,\
        MinutesToUTC              int,\
        TimeZoneName              char(32)\
        )", PDH_SQL_STRING_SIZE);

    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    // execute the create statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc))
    {
        rc = PdhiCheckSQLExist(hstmt, rc);
        if (!(SQLSUCCEEDED(rc))) {
            // don't report the error, as this could be called from 
            // opening a database that already exists...
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    // execute the create statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc))
    {
        rc = PdhiCheckSQLExist(hstmt, rc);
        if (!(SQLSUCCEEDED(rc))) {
            // don't report the error, as this could be called from
            // opening a database that already exists...
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
    }

    // if any failures to create a table, return that
    if (ERROR_SUCCESS == pdhStatus) pdhStatus = pdhCreateStatus;

Cleanup:
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetSQLLogCounterInfo (
    IN  PPDHI_LOG       pLog,
    IN  PPDHI_COUNTER   pCounter
)
// Figures out if a particular counter is in the log...
// this must be fetched from SQL with a select since
// there is no header record, this will be a complex select
// Use the function PdhpGetSQLLogHeader - which will
// do this, and save the results for subsequent calls.
// store away in the pCounter structure the actual SQL index
// based on how this is used, I think the counterID can be resused.
// however, probably safer to assign one sequentially

{
    PDH_STATUS          pdhStatus   = ERROR_SUCCESS;
    PPDHI_SQL_LOG_INFO  pLogInfo;
    PPDHI_LOG_COUNTER   pLogCounter = NULL;
    DWORD               dwCtrIndex  = 0;
    BOOL                bNoMachine  = FALSE;
    LPWSTR              szMachine;

    pdhStatus = PdhpGetSQLLogHeader(pLog);
    if (pdhStatus != ERROR_SUCCESS) goto Cleanup;

    pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;
    if (pLogInfo == NULL) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        goto Cleanup;
    }

    if (pCounter->pCounterPath->szMachineName == NULL) {
        bNoMachine = TRUE;
        szMachine  = szStaticLocalMachineName;
    }
    else if (lstrcmpiW(pCounter->pCounterPath->szMachineName, L"\\\\.") == 0) {
        bNoMachine = TRUE;
        szMachine  = szStaticLocalMachineName;
    }
    else {
        szMachine  = pCounter->pCounterPath->szMachineName;
    }

    pLogCounter = PdhiFindLogCounter(pLog,
                                     & pLogInfo->MachineList,
                                     szMachine,
                                     pCounter->pCounterPath->szObjectName,
                                     pCounter->pCounterPath->szCounterName,
                                     0,
                                     0,
                                     pCounter->pCounterPath->szInstanceName,
                                     pCounter->pCounterPath->dwIndex,
                                     pCounter->pCounterPath->szParentName,
                                     0,
                                     & dwCtrIndex,
                                     FALSE);
    if (pLogCounter != NULL) {
        if (bNoMachine) {
            pCounter->pCounterPath->szMachineName = NULL;
        }
        pCounter->TimeBase                           = pLogCounter->TimeBase;
        pCounter->plCounterInfo.dwObjectId           = 0;
        pCounter->plCounterInfo.lInstanceId          = pLogCounter->dwInstance;
        pCounter->plCounterInfo.szInstanceName       = pLogCounter->szInstance;
        pCounter->plCounterInfo.dwParentObjectId     = pLogCounter->dwParent;
        pCounter->plCounterInfo.szParentInstanceName = pLogCounter->szParent;
        pCounter->plCounterInfo.dwCounterId          = pLogCounter->dwCounterID;
        pCounter->plCounterInfo.dwCounterType        = pLogCounter->dwCounterType;
        pCounter->plCounterInfo.lDefaultScale        = pLogCounter->dwDefaultScale;
        pCounter->plCounterInfo.dwCounterSize        = (pLogCounter->dwCounterType & PERF_SIZE_LARGE)
                                                     ? sizeof(LONGLONG) : sizeof(DWORD);
        pCounter->plCounterInfo.dwSQLCounterId       = dwCtrIndex;
        pdhStatus                                    = ERROR_SUCCESS;
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_COUNTER;
    }

Cleanup:
    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenSQLLog (
    IN  PPDHI_LOG   pLog,
    IN  BOOL        bOpenInput
)
{
    // string to compare with file name to see if SQL
    WCHAR szSQLType[]          =    L"SQL:";

    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    RETCODE rc;

    pLog->henvSQL = NULL ;
    pLog->hdbcSQL = NULL ;

    // format is SQL:DSNNAME!COMMENT
    // parse out the DSN name and 'dataset' (comment) name from the LogFileName
    // pLog->szDSN - pointer to Data Source Name within LogFileName
    //         (separators replaced with 0's)
    // pLog->szCommentSQL - pointer to the Comment string that defines the
    //         name of the data set within the SQL database

    pLog->szDSN = pLog->szLogFileName
                + (sizeof(szSQLType) / sizeof(WCHAR)) - 1;

    pLog->szCommentSQL = wcschr((const wchar_t *) pLog->szDSN, '!');
    if (NULL == pLog->szCommentSQL) {
        return PDH_INVALID_DATASOURCE;
    }
    pLog->szCommentSQL[0] = 0;    // null terminate the DSN name
    pLog->szCommentSQL ++;        // increment past to the Comment string

    if (0 == lstrlenW(pLog->szCommentSQL)) {
        return PDH_INVALID_DATASOURCE;
    }

    // initialize the rest of the SQL fields
    pLog->dwNextRecordIdToWrite = 1; // start with record 1
    pLog->dwRecord1Size         = 0;
    
    //////////////////////////////////////////////////////////////
    // obtain the ODBC environment and connection
    //

    rc = SQLAllocEnv(&pLog->henvSQL);
    if (! SQLSUCCEEDED(rc)) goto Cleanup;
    
    rc = SQLAllocConnect(pLog->henvSQL, &pLog->hdbcSQL);
    if (! SQLSUCCEEDED(rc)) goto Cleanup;

    rc = SQLSetConnectAttr(pLog->hdbcSQL,
                           SQL_COPT_SS_BCP,
                           (SQLPOINTER) SQL_BCP_ON,
                           SQL_IS_INTEGER);
    if (! SQLSUCCEEDED(rc)) goto Cleanup;

    rc = SQLConnectW(pLog->hdbcSQL,
                     (SQLWCHAR *) pLog->szDSN,
                     SQL_NTS,
                     NULL,
                     SQL_NULL_DATA,
                     NULL,
                     SQL_NULL_DATA);

Cleanup:
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,NULL,PDH_SQL_ALLOCCON_FAILED);
        if (pLog->hdbcSQL) SQLDisconnect(pLog->hdbcSQL);        
        if (pLog->hdbcSQL) SQLFreeHandle(SQL_HANDLE_DBC, pLog->hdbcSQL);
        if (pLog->henvSQL) SQLFreeHandle(SQL_HANDLE_ENV, pLog->henvSQL);
        pLog->henvSQL = NULL;
        pLog->hdbcSQL = NULL;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenInputSQLLog (
    IN  PPDHI_LOG   pLog
)
// open SQL database for input - or anything that isn't actually creating a new space
// database MUST exist 
{
    PDH_STATUS    pdhStatus;
    WCHAR        szSQLStmt[SQLSTMTSIZE];
    HSTMT        hstmt = NULL;    
    RETCODE        rc;
    LONG        lMinutesToUTC = 0;
    WCHAR        szTimeZoneName[32];
    SQLLEN      dwTimeZoneLen;
    
    pdhStatus = PdhiOpenSQLLog(pLog, TRUE);
    if (SUCCEEDED (pdhStatus))
    {
        if ((pdhStatus = PdhiSQLExtendCounterDetail(pLog)) != ERROR_SUCCESS) goto Cleanup;

        // Check that the database exists
        // Select the guid & runid from DisplayToId table
        // allocate an hstmt
        rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
            goto Cleanup;
        }

        swprintf(szSQLStmt,
            L"select GUID, RunID, NumberOfRecords, MinutesToUTC, TimeZoneName  from DisplayToID where DisplayString = '%ws'",
            pLog->szCommentSQL);

        // bind the columns
        rc = SQLBindCol(hstmt, 1, SQL_C_GUID, &pLog->guidSQL, 0, NULL);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }

        rc = SQLBindCol(hstmt, 2, SQL_C_LONG, &pLog->iRunidSQL, 0, NULL);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }

        rc = SQLBindCol(hstmt, 3, SQL_C_LONG, &pLog->dwNextRecordIdToWrite, 0, NULL);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }

        rc = SQLBindCol(hstmt, 4, SQL_C_LONG, &lMinutesToUTC, 0, NULL);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }

        rc = SQLBindCol(hstmt, 5, SQL_C_WCHAR, szTimeZoneName, sizeof(szTimeZoneName), &dwTimeZoneLen);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }

        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }

        rc = SQLFetch(hstmt);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_FETCH_FAILED);
            goto Cleanup;
        }

        pLog->dwNextRecordIdToWrite ++; // increment number of current records to get next recordid to write
    }

Cleanup:
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenOutputSQLLog (
    IN  PPDHI_LOG   pLog
)
// open SQL database for output
// May have to create DB
{
    PDH_STATUS pdhStatus    = PdhiOpenSQLLog(pLog, FALSE);
    WCHAR      szSQLStmt[SQLSTMTSIZE];
    HSTMT      hstmt        = NULL;    
    RETCODE    rc;
    SQLLEN     dwGuid       = 0;
    SQLLEN     dwRunIdSQL   = 0;
    SQLLEN     dwNextRecord = 0;

    if (SUCCEEDED(pdhStatus)) {
        // see if we need to create the database
        // creating the tables is harmless, it won't drop
        // them if they already exist, but ignore any errors

        pdhStatus = PdhpCreateSQLTables(pLog);

        // See if logset already exists. If it does, treat it as an
        // logset append case.
        //
        rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = PDH_SQL_ALLOC_FAILED;
            goto Cleanup;
        }

        swprintf(szSQLStmt,
            L"select GUID, RunID, NumberOfRecords from DisplayToID where DisplayString = '%ws'",
            pLog->szCommentSQL);

        rc = SQLBindCol(hstmt, 1, SQL_C_GUID,
                        & pLog->guidSQL, 0, & dwGuid);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = PDH_SQL_BIND_FAILED;
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 2, SQL_C_LONG,
                        & pLog->iRunidSQL, 0, & dwRunIdSQL);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = PDH_SQL_BIND_FAILED;
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 3, SQL_C_LONG,
                        & pLog->dwNextRecordIdToWrite, 0, & dwNextRecord);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = PDH_SQL_BIND_FAILED;
            goto Cleanup;
        }

        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }

        rc = SQLFetch(hstmt);
        if ((! SQLSUCCEEDED(rc)) || (rc == SQL_NO_DATA)) {
            pdhStatus = PDH_SQL_FETCH_FAILED;
            goto Cleanup;
        }

        pLog->dwNextRecordIdToWrite ++;
        pLog->dwRecord1Size = 1;

Cleanup:
        if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);

        if (pdhStatus != ERROR_SUCCESS) {
            // initialize the GUID
            HRESULT hr                  = CoCreateGuid(& pLog->guidSQL);
            pLog->dwNextRecordIdToWrite = 1;
            pLog->iRunidSQL             = 0;
            pdhStatus                   = ERROR_SUCCESS;
        }
    }

    if (SUCCEEDED(pdhStatus)) {
        PPDH_SQL_BULK_COPY pBulk = PdhiBindBulkCopyStructure(pLog);
        if (pBulk == NULL) {
            pdhStatus = GetLastError();
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
ReportSQLError (
    IN  PPDHI_LOG    pLog,
    RETCODE            rc,
    HSTMT            hstmt,
    DWORD            dwEventNumber)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    
    if (!SQLSUCCEEDED(rc)) 
    {
        pdhStatus = dwEventNumber;
    }

    if (FAILED(pdhStatus))
    {
        // for now this will be reported only whe specifically enabled
        short cbErrMsgSize = 512;
        WCHAR szError[512];
        LPWSTR lpszStrings[1];
        DWORD  dwData[1];
        long  iError;
        lpszStrings[0] = szError;
        SQLErrorW( pLog->henvSQL, pLog->hdbcSQL, hstmt, NULL, &iError, szError, 512, &cbErrMsgSize );
        dwData[0] = iError;
        if (pdhStatus == PDH_SQL_EXEC_DIRECT_FAILED && iError == 1105) {
            pdhStatus = ERROR_DISK_FULL;
        }
        ReportEventW (hEventLog,
            EVENTLOG_ERROR_TYPE,    // error type
            0,                      // category (not used)
            (DWORD)dwEventNumber,   // event,
            NULL,                   // SID (not used),
            1,                      // number of strings
            1,                      // sizeof raw data
            (LPCWSTR *)lpszStrings, // message text array
            (LPVOID) & dwData[0]);  // raw data
    }

    return pdhStatus ;
}

PDH_FUNCTION
PdhiCloseSQLLog (
    IN  PPDHI_LOG   pLog,
    IN  DWORD       dwFlags
)
// close the SQL database
{
    PDH_STATUS            pdhStatus = ERROR_SUCCESS;
    WCHAR                 szSQLStmt[SQLSTMTSIZE];
    HSTMT                 hstmt = NULL;    
    RETCODE               rc;
    SQLLEN                dwDateTimeLen;
    WCHAR                 szDateTime[40];
    OBJECT_NAME_STRUCT  * pObjList;    
    OBJECT_ITEM_STRUCT  * pObjItemList;
    OBJECT_NAME_STRUCT  * pNextObj;    
    OBJECT_ITEM_STRUCT  * pNextObjItem;
    DBINT                 rcBCP;
    DWORD                 dwReturn;
    WCHAR               * pTimeZone;
    TIME_ZONE_INFORMATION TimeZone;
    LONG                  lMinutesToUTC = 0;

    UNREFERENCED_PARAMETER (dwFlags);

    if ((pLog->dwLogFormat & PDH_LOG_ACCESS_MASK) == PDH_LOG_WRITE_ACCESS)
    {
        // need to save the last datetime in the DisplayToID as well as the number of records written

        // allocate an hstmt
        rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
            goto Cleanup;
        }

        // first have to read the date time from the last record

        swprintf(szSQLStmt,
            L"select CounterDateTime from CounterData where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x' and RecordIndex = %d",
            pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
            pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
            pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
            pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7], (pLog->dwNextRecordIdToWrite - 1));

        // bind the column
        rc = SQLBindCol(hstmt, 1, SQL_C_WCHAR, szDateTime, sizeof(szDateTime), &dwDateTimeLen);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }

        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }

        rc = SQLFetch(hstmt);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_FETCH_FAILED);
            goto Cleanup;
        }

        // close the hstmt since we're done, and don't want more rows
        SQLFreeStmt(hstmt, SQL_DROP);
        hstmt = NULL;

        if (SQL_NO_DATA != rc) // if there is no data, we didn't write any rows
        {
            // allocate an hstmt
            rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
            if (!SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }

            // szDateTime should have the correct date & time in it from above.
            // get MinutesToUTC
            //
            dwReturn = GetTimeZoneInformation(&TimeZone);

            if (dwReturn != TIME_ZONE_ID_INVALID)
            {
                if (dwReturn == TIME_ZONE_ID_DAYLIGHT) 
                {
                    pTimeZone = TimeZone.DaylightName;
                    lMinutesToUTC = TimeZone.Bias + TimeZone.DaylightBias;
                }
                else
                {
                    pTimeZone = TimeZone.StandardName;
                    lMinutesToUTC = TimeZone.Bias + TimeZone.StandardBias;
                }
            }

            swprintf(szSQLStmt,
                L"update DisplayToID set LogStopTime = '%ws', NumberOfRecords = %d, MinutesToUTC = %d, TimeZoneName = '%ws' where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x'",
                szDateTime, (pLog->dwNextRecordIdToWrite - 1),
                lMinutesToUTC,pTimeZone,
                pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
                pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
                pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
                pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);

            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (!SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
                goto Cleanup;
            }

        }

        rcBCP = bcp_done(pLog->hdbcSQL);
        if (pLog->lpMappedFileBase != NULL) {
            G_FREE(pLog->lpMappedFileBase);
            pLog->lpMappedFileBase = NULL;
        }

        if (pLog->pPerfmonInfo != NULL) {
            PdhiFreeLogMachineTable(
                            (PPDHI_LOG_MACHINE *) (& (pLog->pPerfmonInfo)));
            pLog->pPerfmonInfo = NULL;
        }
        pLog->dwRecord1Size = 0;
    }// end of extra processing when closing a sql dataset open for writing

    else if (pLog->pPerfmonInfo != NULL) {
        PPDHI_SQL_LOG_INFO pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;

        PdhiFreeLogMachineTable((PPDHI_LOG_MACHINE *) (& pLogInfo->MachineList));
        //PdhiFreeSqlCounterDataNode(pLogInfo->LogData, 0);
        G_FREE(pLog->pPerfmonInfo);
        pLog->pPerfmonInfo = NULL;
    }

Cleanup:
    // clean up the headers for the enumerations of counters
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    if (pLog->hdbcSQL) {
        SQLDisconnect(pLog->hdbcSQL);        
        SQLFreeHandle(SQL_HANDLE_DBC, pLog->hdbcSQL);
    }
    if (pLog->henvSQL) SQLFreeHandle(SQL_HANDLE_ENV, pLog->henvSQL);

    return pdhStatus;
}

PDH_FUNCTION
PdhpWriteSQLCounters(
    IN  PPDHI_LOG   pLog
)
// write the CounterTable entries that are new.
// An entry might already exist for a counter from a previous run
// so the first step is to read a counter (server+object+instance name)
// and see if it exists - if so - just record the counterid in the
// PDHI_LOG structure under pLog->pQuery->pCounterListHead in the
// PDHI_COUNTER.  If the counter doesn't exist - create it in SQL and
// record the counterid in the PDHI_LOG structure under
// pLog->pQuery->pCounterListHead in the PDHI_COUNTER.
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    PPDHI_COUNTER   pCtrEntry;

    if(NULL == pLog->pQuery) return ERROR_SUCCESS;  // no counters to process

    pCtrEntry = pLog->pQuery->pCounterListHead;

    if (NULL != pCtrEntry)
    do {
        PPDHI_LOG_COUNTER pSqlCounter = NULL;
        pdhStatus = PdhiSqlBuildCounterObjectNode(
                        pLog,
                        pCtrEntry->pCounterPath->szMachineName,
                        pCtrEntry->pCounterPath->szObjectName);
        if (pdhStatus != ERROR_SUCCESS) return pdhStatus;

        if ((pCtrEntry->dwFlags & PDHIC_MULTI_INSTANCE) == 0) {
            pSqlCounter = PdhiSqlFindCounter(
                    pLog,
                    (PPDHI_LOG_MACHINE *) (& (pLog->pPerfmonInfo)),
                    pCtrEntry->pCounterPath->szMachineName,
                    pCtrEntry->pCounterPath->szObjectName,
                    pCtrEntry->pCounterPath->szCounterName,
                    pCtrEntry->plCounterInfo.dwCounterType,
                    pCtrEntry->plCounterInfo.lDefaultScale,
                    pCtrEntry->pCounterPath->szInstanceName,
                    pCtrEntry->pCounterPath->dwIndex,
                    pCtrEntry->pCounterPath->szParentName,
                    pCtrEntry->plCounterInfo.dwParentObjectId,
                    pCtrEntry->TimeBase,
                    TRUE,
                    TRUE);
            if (pSqlCounter != NULL) {
                pCtrEntry->pBTreeNode = (LPVOID) pSqlCounter;
                pCtrEntry->plCounterInfo.dwSQLCounterId = pSqlCounter->dwCounterID;
                if (pSqlCounter->dwCounterType == PERF_DOUBLE_RAW) {
                    pSqlCounter->dwCounterType = pCtrEntry->plCounterInfo.dwCounterType;
                    pSqlCounter->TimeBase      = pCtrEntry->TimeBase;
                    pdhStatus = PdhiSQLUpdateCounterDetailTimeBase(pLog,
                                                                   pCtrEntry->plCounterInfo.dwSQLCounterId,
                                                                   pCtrEntry->TimeBase,
                                                                   TRUE);
                    if (pdhStatus != ERROR_SUCCESS) {
                        pSqlCounter->dwCounterType = PERF_DOUBLE_RAW;
                        pSqlCounter->TimeBase      = 0;
                    }
                }

            }
        }

        pCtrEntry = pCtrEntry->next.flink;
    } while (pCtrEntry != pLog->pQuery->pCounterListHead); // loop thru pCtrEntry's
    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteSQLLogHeader (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szUserCaption
)
// there is no 'header record' in the SQL database,
// but we need to write the CounterTable entries that are new.
// use PdhpWriteSQLCounters to do that
// then write the DisplayToID record to identify this logset
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    WCHAR           szSQLStmt[SQLSTMTSIZE];
    HSTMT           hstmt = NULL;    
    RETCODE         rc;

    DBG_UNREFERENCED_PARAMETER (szUserCaption);

    pdhStatus = PdhpWriteSQLCounters(pLog);

    if (pLog->dwRecord1Size == 0) {
        // we also need to write the DisplayToID record at this point
        // allocate an hstmt
        rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
            goto Cleanup;
        }

        swprintf(szSQLStmt,
                L"insert into DisplayToID values ('%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x',%d,'%ws',0,0,0,0,'')",
                pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
                pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
                pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
                pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7],
                pLog->iRunidSQL,
                pLog->szCommentSQL);

        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
    }

Cleanup:
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteOneSQLRecord(
    IN  PPDHI_LOG              pLog,
    IN  PPDHI_COUNTER          pCounter,
    IN  DWORD                  dwCounterID,
    IN  PPDH_RAW_COUNTER       pThisValue,
    IN  PPDH_FMT_COUNTERVALUE  pFmtValue,
    IN  SYSTEMTIME           * stTimeStamp,
    IN  LPWSTR                 szDateTime
    )
{
    PDH_STATUS           pdhStatus = ERROR_SUCCESS;
    RETCODE              rc;
    SYSTEMTIME           st;
    PDH_FMT_COUNTERVALUE pdhValue;
    PPDH_SQL_BULK_COPY   pBulk = PdhiBindBulkCopyStructure(pLog);

    if (   pThisValue->CStatus != ERROR_SUCCESS
        || (   pThisValue->TimeStamp.dwLowDateTime == 0
            && pThisValue->TimeStamp.dwHighDateTime == 0)) {
        SystemTimeToFileTime(stTimeStamp, & pThisValue->TimeStamp);
    }
    PdhpConvertFileTimeToSQLString(& (pThisValue->TimeStamp),
                                   szDateTime);
    FileTimeToSystemTime(& (pThisValue->TimeStamp), & st);

    if (pBulk == NULL) {
        pdhStatus = GetLastError();
        goto Cleanup;
    }

    pBulk->dbCounterId    = dwCounterID;
    pBulk->dbRecordIndex  = pLog->dwNextRecordIdToWrite;
    pBulk->dbFirstValueA  = LODWORD(pThisValue->FirstValue);
    pBulk->dbFirstValueB  = HIDWORD(pThisValue->FirstValue);
    pBulk->dbSecondValueA = LODWORD(pThisValue->SecondValue);
    pBulk->dbSecondValueB = HIDWORD(pThisValue->SecondValue);
    pBulk->dbMultiCount   = (pCounter->plCounterInfo.dwCounterType == PERF_DOUBLE_RAW)
                          ? MULTI_COUNT_DOUBLE_RAW : pThisValue->MultiCount;

    sprintf(pBulk->dbDateTime,
            "%04d-%02d-%02d %02d:%02d:%02d.%03d",
            st.wYear, st.wMonth,  st.wDay,
            st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

    pBulk->dbCounterValue = pFmtValue->doubleValue;
    rc = bcp_sendrow(pLog->hdbcSQL);
    if (rc == FAIL) {
        DebugPrint((1,"bcp_sendrow(\"%ws\",%d,%d,\"%s\")(%d,%d)\n",
                     pCounter->szFullName,
                     pBulk->dbCounterId,
                     pBulk->dbRecordIndex,
                     pBulk->dbDateTime,
                     rc,
                     pBulk->dwRecordCount));
        pdhStatus = PDH_SQL_EXEC_DIRECT_FAILED;
    }
    else {
        pBulk->dwRecordCount ++;
        if (pBulk->dwRecordCount == PDH_SQL_BULK_COPY_REC) {
            DBINT rcBCP = bcp_batch(pLog->hdbcSQL);
            if (rcBCP < 0) {
                DebugPrint((1,"bcp_batch(%05d,0x%08X,%d,%d)\n",
                         __LINE__, pLog->hdbcSQL, rcBCP, pBulk->dwRecordCount));
                pdhStatus = ReportSQLError(
                            pLog, SQL_ERROR, NULL, PDH_SQL_EXEC_DIRECT_FAILED);
            }
           pBulk->dwRecordCount = 0;
        }
    }

Cleanup:
    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteSQLLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  SYSTEMTIME  *stTimeStamp,
    IN  LPCWSTR     szUserString
)
// write multiple CounterData rows - one for each counter.  use the
// SQLCounterID from PDHI_COUNTER, pLog->pQuery->pCounterListHead to
// get the counterid for this entry.
{
    PDH_STATUS               pdhStatus = ERROR_SUCCESS;
    PPDHI_COUNTER            pThisCounter;
    WCHAR                    szSQLStmt[SQLSTMTSIZE];
    HSTMT                    hstmt = NULL;    
    RETCODE                  rc;
    WCHAR                    szDateTime[30];
    DWORD                    dwReturn;
    DWORD                    dwCounterID;
    WCHAR                  * pTimeZone;
    TIME_ZONE_INFORMATION    TimeZone;
    LONG                     lMinutesToUTC = 0;
    DBINT                    rcBCP;
    PPDH_SQL_BULK_COPY       pBulk;
    PDH_FMT_COUNTERVALUE     PdhValue;
    PPDHI_LOG_COUNTER        pSqlCounter;
    ULONGLONG                ThisTimeStamp;

    UNREFERENCED_PARAMETER (stTimeStamp);
    DBG_UNREFERENCED_PARAMETER (szUserString);

    // see if we've written to many records already
    if (0 < pLog->llMaxSize) // ok we have a limit
        if (pLog->llMaxSize < pLog->dwNextRecordIdToWrite) return PDH_LOG_FILE_TOO_SMALL;

    // check each counter in the list of counters for this query and
    // write them to the file

    pThisCounter = pLog->pQuery ? pLog->pQuery->pCounterListHead : NULL;

    if (pThisCounter != NULL) {
        // lock the query while we read the data so the values
        // written to the log will all be from the same sample
        WAIT_FOR_AND_LOCK_MUTEX(pThisCounter->pOwner->hMutex);
        do {
            if ((pThisCounter->dwFlags & PDHIC_MULTI_INSTANCE) != 0) {
                DWORD dwSize;
                DWORD dwItem;

                if (   pThisCounter->pLastObject != NULL
                    && pThisCounter->pLastObject != pThisCounter->pThisObject) {
                    G_FREE(pThisCounter->pLastObject);
                }
                pThisCounter->pLastObject = pThisCounter->pThisObject;
                pThisCounter->LastValue.MultiCount =
                                pThisCounter->ThisValue.MultiCount;

                pThisCounter->pThisObject          = NULL;
                pThisCounter->ThisValue.MultiCount = 0;
                dwSize                             = 0;
                pdhStatus                          = PDH_MORE_DATA;

                while (pdhStatus == PDH_MORE_DATA) {
                    pdhStatus = PdhiSqlGetCounterArray(pThisCounter,
                            & dwSize, & dwItem,
                            (LPVOID) pThisCounter->pThisObject);
                    if (pdhStatus == PDH_MORE_DATA) {
                        LPVOID pTemp = pThisCounter->pThisObject;

                        if (pTemp != NULL) {
                            pThisCounter->pThisObject = G_REALLOC(pTemp, dwSize);
                            if (pThisCounter->pThisObject == NULL) {
                                G_FREE(pTemp);
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                        }
                        else {
                            pThisCounter->pThisObject = G_ALLOC(dwSize);
                            if (pThisCounter->pThisObject == NULL) {
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                        }
                    }
                }
                if (pdhStatus == ERROR_SUCCESS) {
                    PPDH_RAW_COUNTER              pRawValue;
                    PPDH_FMT_COUNTERVALUE_ITEM_W  pFmtValue;
                    DWORD                         dwInstanceName;
                    DWORD                         dwParentName;
                    DWORD                         dwInstanceIndex;
                    WCHAR                         szInstanceName[PDH_SQL_STRING_SIZE];
                    WCHAR                         szParentName[PDH_SQL_STRING_SIZE];

                    pThisCounter->ThisValue.MultiCount = dwItem;
                    pRawValue = (PPDH_RAW_COUNTER) (pThisCounter->pThisObject);
                    pFmtValue = (PPDH_FMT_COUNTERVALUE_ITEM_W)
                                (  ((LPBYTE) pThisCounter->pThisObject)
                                 + sizeof(PDH_RAW_COUNTER) * dwItem);
                    for (dwSize = 0; dwSize < dwItem; dwSize ++) {
                        dwInstanceName  = PDH_SQL_STRING_SIZE;
                        dwParentName    = PDH_SQL_STRING_SIZE;
                        dwInstanceIndex = 0;
                        ZeroMemory(szInstanceName, sizeof(szInstanceName));
                        ZeroMemory(szParentName, sizeof(szParentName));
                        PdhParseInstanceNameW(pFmtValue->szName,
                                szInstanceName,
                                & dwInstanceName,
                                szParentName,
                                & dwParentName,
                                & dwInstanceIndex);
                        pSqlCounter = PdhiSqlFindCounter(
                                pLog,
                                (PPDHI_LOG_MACHINE *) (& (pLog->pPerfmonInfo)),
                                pThisCounter->pCounterPath->szMachineName,
                                pThisCounter->pCounterPath->szObjectName,
                                pThisCounter->pCounterPath->szCounterName,
                                pThisCounter->plCounterInfo.dwCounterType,
                                pThisCounter->plCounterInfo.lDefaultScale,
                                szInstanceName,
                                dwInstanceIndex,
                                szParentName,
                                pThisCounter->plCounterInfo.dwParentObjectId,
                                pThisCounter->TimeBase,
                                FALSE,
                                TRUE);
                        ThisTimeStamp = MAKELONGLONG(
                                        pRawValue->TimeStamp.dwLowDateTime,
                                        pRawValue->TimeStamp.dwHighDateTime);
                        if (pSqlCounter != NULL) {
                            if (pSqlCounter->dwCounterType == PERF_DOUBLE_RAW) {
                                pSqlCounter->dwCounterType = pThisCounter->plCounterInfo.dwCounterType;
                                pSqlCounter->TimeBase      = pThisCounter->TimeBase;
                                pdhStatus = PdhiSQLUpdateCounterDetailTimeBase(pLog,
                                                                               pSqlCounter->dwCounterID,
                                                                               pThisCounter->TimeBase,
                                                                               FALSE);
                                if (pdhStatus != ERROR_SUCCESS) {
                                    pSqlCounter->dwCounterType = PERF_DOUBLE_RAW;
                                    pSqlCounter->TimeBase      = 0;
                                }
                            }
                            if (pSqlCounter->TimeStamp < ThisTimeStamp) {
                                dwCounterID = pSqlCounter->dwCounterID;
                                pSqlCounter->TimeStamp = ThisTimeStamp;
                                if (dwCounterID == 0) {
                                    DebugPrint((1,"bcp_sendrow-1(\"%ws\",\"%ws\",%d,\"%ws\")\n",
                                            pThisCounter->pCounterPath->szCounterName,
                                            szInstanceName,
                                            dwInstanceIndex,
                                            szParentName));
                                }
                                pdhStatus = PdhiWriteOneSQLRecord(
                                            pLog,
                                            pThisCounter,
                                            dwCounterID,
                                            pRawValue,
                                            & (pFmtValue->FmtValue),
                                            stTimeStamp,
                                            szDateTime);
                            }
                        }
                        pRawValue = (PPDH_RAW_COUNTER)
                                    (  ((LPBYTE) pRawValue)
                                     + sizeof(PDH_RAW_COUNTER));
                        pFmtValue = (PPDH_FMT_COUNTERVALUE_ITEM_W)
                                    (  ((LPBYTE) pFmtValue)
                                     + sizeof(PDH_FMT_COUNTERVALUE_ITEM_W));
                    }
                }
            }
            else {
                pSqlCounter   = (PPDHI_LOG_COUNTER) pThisCounter->pBTreeNode;
                ThisTimeStamp = MAKELONGLONG(
                            pThisCounter->ThisValue.TimeStamp.dwLowDateTime,
                            pThisCounter->ThisValue.TimeStamp.dwHighDateTime);
                if (pSqlCounter != NULL) {
                    if (pSqlCounter->TimeStamp < ThisTimeStamp) {
                        dwCounterID = pThisCounter->plCounterInfo.dwSQLCounterId;
                        pSqlCounter->TimeStamp = ThisTimeStamp;
                        pdhStatus = PdhiComputeFormattedValue(
                                    pThisCounter->CalcFunc,
                                    pThisCounter->plCounterInfo.dwCounterType,
                                    pThisCounter->lScale,
                                    PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                                    & (pThisCounter->ThisValue),
                                    & (pThisCounter->LastValue),
                                    & (pThisCounter->TimeBase),
                                    0L,
                                    & PdhValue);
                        if (   (pdhStatus != ERROR_SUCCESS)
                            || (   (PdhValue.CStatus != PDH_CSTATUS_VALID_DATA)
                                && (PdhValue.CStatus != PDH_CSTATUS_NEW_DATA))) {
                            PdhValue.doubleValue = 0.0;
                        }
                        if (dwCounterID == 0) {
                            DebugPrint((1,"bcp_sendrow-2(\"%ws\",\"%ws\",%d,\"%ws\")\n",
                                    pThisCounter->pCounterPath->szCounterName,
                                    pThisCounter->pCounterPath->szInstanceName,
                                    pThisCounter->pCounterPath->dwIndex,
                                    pThisCounter->pCounterPath->szParentName));
                        }
                        pdhStatus   = PdhiWriteOneSQLRecord(
                                        pLog,
                                        pThisCounter,
                                        dwCounterID,
                                        & (pThisCounter->ThisValue),
                                        & PdhValue,
                                        stTimeStamp,
                                        szDateTime);
                    }
#if DBG
                    else {
                        DebugPrint((1,"DuplicateCounter-2(\"%ws\",%d,%I64d)\n",
                                pThisCounter->szFullName,
                                pThisCounter->plCounterInfo.dwSQLCounterId,
                                ThisTimeStamp));
                    }
#endif
                }
#if DBG
                else {
                    DebugPrint((1,"NullCounter-2(\"%ws\",%I64d)\n",
                            pThisCounter->szFullName,
                            ThisTimeStamp));
                }
#endif
            }

            pThisCounter = pThisCounter->next.flink; // go to next in list
        } while (pThisCounter != pLog->pQuery->pCounterListHead);
        // free (i.e. unlock) the query

        rcBCP = bcp_batch(pLog->hdbcSQL);
        if (rcBCP < 0) {
            pBulk = (PPDH_SQL_BULK_COPY) pLog->lpMappedFileBase;
            if (pBulk != NULL) {
                DebugPrint((1,"bcp_batch(%05d,0x%08X,%d,0x%08X,%d)\n",
                             __LINE__, pLog->hdbcSQL, rcBCP,
                             pBulk, pBulk->dwRecordCount));
                pBulk->dwRecordCount = 0;
            }
            return ReportSQLError(pLog, SQL_ERROR, NULL, PDH_SQL_EXEC_DIRECT_FAILED);
        }

        RELEASE_MUTEX(pThisCounter->pOwner->hMutex);
        pLog->dwNextRecordIdToWrite++;
    }

    // if this is the first record then save the start time in DisplayToID
    // we also need to write the DisplayToID record at this point (we just incremented
    // so check for 2)

    if (2 == pLog->dwNextRecordIdToWrite)
    {
        // allocate an hstmt
        rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        }
        else {
            // szDateTime should have the correct date & time in it from above.
            // get MinutesToUTC
            //
            dwReturn = GetTimeZoneInformation(&TimeZone);

            if (dwReturn != TIME_ZONE_ID_INVALID)
            {
                if (dwReturn == TIME_ZONE_ID_DAYLIGHT) 
                {
                    pTimeZone = TimeZone.DaylightName;
                    lMinutesToUTC = TimeZone.Bias + TimeZone.DaylightBias;
                }
                else
                {
                    pTimeZone = TimeZone.StandardName;
                    lMinutesToUTC = TimeZone.Bias + TimeZone.StandardBias;
                }
            }

            swprintf(szSQLStmt,
                    L"update DisplayToID set LogStartTime = '%ws', MinutesToUTC = %d, TimeZoneName = '%ws' where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x'",
                    szDateTime, lMinutesToUTC,pTimeZone,
                    pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
                    pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
                    pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
                    pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);

            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (!SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
            }

            SQLFreeStmt(hstmt, SQL_DROP);
        }
    }

    if (pdhStatus == ERROR_SUCCESS)
    {
        rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        }
        else {
            swprintf(szSQLStmt,
                    L"update DisplayToID set LogStopTime = '%ws', NumberOfRecords = %d where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x'",
                    szDateTime,
                    (pLog->dwNextRecordIdToWrite - 1),
                    pLog->guidSQL.Data1,
                    pLog->guidSQL.Data2,
                    pLog->guidSQL.Data3,
                    pLog->guidSQL.Data4[0],
                    pLog->guidSQL.Data4[1],
                    pLog->guidSQL.Data4[2],
                    pLog->guidSQL.Data4[3],
                    pLog->guidSQL.Data4[4],
                    pLog->guidSQL.Data4[5],
                    pLog->guidSQL.Data4[6],
                    pLog->guidSQL.Data4[7]);
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (!SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
            }

            SQLFreeStmt(hstmt, SQL_DROP);
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumMachinesFromSQLLog (
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    BOOL        bUnicodeDest
)
// Use the results of the function PdhpGetSQLLogHeader to build the list
{
    PDH_STATUS         pdhStatus = ERROR_SUCCESS;
    DWORD              dwBufferUsed    = 0;
    DWORD              dwNewBuffer     = 0;
    DWORD              dwItemCount     = 0;
    LPVOID             LocalBuffer     = NULL;
    LPVOID             TempBuffer      = NULL;
    DWORD              LocalBufferSize = 0;
    PPDHI_LOG_MACHINE  pMachine;
    PPDHI_SQL_LOG_INFO pLogInfo        = NULL;

    pdhStatus = PdhpGetSQLLogHeader(pLog);
    if (pdhStatus == ERROR_SUCCESS) {
        pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;
        if (pLogInfo == NULL) {
            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        }
    }
    if (pdhStatus != ERROR_SUCCESS) goto Cleanup;

    LocalBufferSize = MEDIUM_BUFFER_SIZE;
    LocalBuffer     = G_ALLOC(LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    if (LocalBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    dwItemCount  = 0;
    dwBufferUsed = 0;
    dwItemCount  = 0;
    for (pMachine = pLogInfo->MachineList; pMachine != NULL; pMachine = pMachine->next) {
        if (pMachine->szMachine != NULL) {
            dwNewBuffer = (lstrlenW(pMachine->szMachine) + 1);
            while (LocalBufferSize  < (dwBufferUsed + dwNewBuffer)) {
                TempBuffer       = LocalBuffer;
                LocalBufferSize += MEDIUM_BUFFER_SIZE;
                LocalBuffer = G_REALLOC(TempBuffer, LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                if (LocalBuffer == NULL) {
                    if (TempBuffer != NULL) G_FREE(TempBuffer);
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    goto Cleanup;
                }
            }
            dwNewBuffer = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer, pMachine->szMachine, bUnicodeDest);
        }
        else {
            dwNewBuffer = 0;
        }
        if (dwNewBuffer > 0) {
            dwBufferUsed = dwNewBuffer;
            dwItemCount ++;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwItemCount > 0) {
            dwBufferUsed ++;
        }
        if (pBuffer && (dwBufferUsed <= * lpdwBufferSize)) {
            RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
        }
        else {
            if (pBuffer != NULL) {
                RtlCopyMemory(pBuffer, LocalBuffer, (* lpdwBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            }
            pdhStatus = PDH_MORE_DATA;
        }
        * lpdwBufferSize = dwBufferUsed;
    }

Cleanup:
    if (LocalBuffer != NULL) G_FREE(LocalBuffer);
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectsFromSQLLog (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szMachineName,
    IN  LPVOID      pBuffer,
    IN  LPDWORD     lpdwBufferSize,
    IN  DWORD       dwDetailLevel,
    IN  BOOL        bUnicodeDest
)
// Use the results of the function PdhpGetSQLLogHeader to build the lists
{
    PDH_STATUS          pdhStatus        = ERROR_SUCCESS;
    DWORD               dwBufferUsed     = 0;
    DWORD               dwNewBuffer      = 0;
    DWORD               dwItemCount      = 0;
    LPVOID              LocalBuffer      = NULL;
    LPVOID              TempBuffer       = NULL;
    DWORD               LocalBufferSize  = 0;
    PPDHI_LOG_MACHINE   pMachine         = NULL;
    PPDHI_LOG_OBJECT    pObject          = NULL;
    LPWSTR              szLocMachine     = (LPWSTR) szMachineName;
    PPDHI_SQL_LOG_INFO  pLogInfo         = NULL;

    UNREFERENCED_PARAMETER(dwDetailLevel);
    pdhStatus = PdhpGetSQLLogHeader(pLog);
    if (pdhStatus == ERROR_SUCCESS) {
        pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;
        if (pLogInfo == NULL) {
            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        }
    }
    if (pdhStatus != ERROR_SUCCESS) goto Cleanup;

    LocalBufferSize = MEDIUM_BUFFER_SIZE;
    LocalBuffer     = G_ALLOC(LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    if (LocalBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    if (szLocMachine == NULL) szLocMachine = (LPWSTR) szStaticLocalMachineName;

    dwBufferUsed = 0;
    dwNewBuffer  = 0;
    dwItemCount  = 0;

    for (pMachine = pLogInfo->MachineList; pMachine != NULL; pMachine = pMachine->next) {
        if (lstrcmpiW(pMachine->szMachine, szLocMachine) == 0) break;
    }

    if (pMachine != NULL) {
        for (pObject = pMachine->ObjList; pObject != NULL; pObject = pObject->next) {
            if (pObject->szObject != NULL) {
                dwNewBuffer = (lstrlenW(pObject->szObject) + 1);
                while (LocalBufferSize  < (dwBufferUsed + dwNewBuffer)) {
                    LocalBufferSize += MEDIUM_BUFFER_SIZE;
                    TempBuffer       = LocalBuffer;
                    LocalBuffer      = G_REALLOC(TempBuffer,
                                                 LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                    if (LocalBuffer == NULL) {
                        if (TempBuffer != NULL) G_FREE(TempBuffer);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                }
                dwNewBuffer = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer, pObject->szObject, bUnicodeDest);
            }
            else {
                dwNewBuffer = 0;
            }
            if (dwNewBuffer > 0) {
                dwBufferUsed = dwNewBuffer;
                dwItemCount ++;
            }
        }
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_MACHINE;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwItemCount > 0) {
            dwBufferUsed ++;
        }
        if (dwBufferUsed > 0) {
            if (pBuffer && (dwBufferUsed <= * lpdwBufferSize)) {
                RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            }
            else {
                if (pBuffer) RtlCopyMemory(pBuffer,
                                           LocalBuffer,
                                           (* lpdwBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                pdhStatus = PDH_MORE_DATA;
            }
        }
        * lpdwBufferSize = dwBufferUsed;
    }

Cleanup:
    G_FREE(LocalBuffer);
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectItemsFromSQLLog (
    IN  PPDHI_LOG          pLog,
    IN  LPCWSTR            szMachineName,
    IN  LPCWSTR            szObjectName,
    IN  PDHI_COUNTER_TABLE CounterTable,
    IN  DWORD              dwDetailLevel,
    IN  DWORD              dwFlags
)
{
    PDH_STATUS         pdhStatus      = ERROR_SUCCESS;
    PPDHI_SQL_LOG_INFO pLogInfo       = NULL;
    DWORD              dwItemCount    = 0;
    LPWSTR             szFullInstance = NULL;
    DWORD              dwFullInstance = SMALL_BUFFER_SIZE;
    LPWSTR             szLocMachine   = (LPWSTR) szMachineName;
    PPDHI_INSTANCE     pInstance;
    PPDHI_INST_LIST    pInstList;
    PPDHI_LOG_MACHINE  pMachine       = NULL;
    PPDHI_LOG_OBJECT   pObject        = NULL;
    PPDHI_LOG_COUNTER  pCounter       = NULL;

    UNREFERENCED_PARAMETER(dwDetailLevel);
    UNREFERENCED_PARAMETER(dwFlags);

    pdhStatus = PdhpGetSQLLogHeader(pLog);
    if (pdhStatus == ERROR_SUCCESS) {
        pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;
        if (pLogInfo == NULL) {
            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        }
    }
    if (pdhStatus != ERROR_SUCCESS) goto Cleanup;

    if (szLocMachine == NULL) szLocMachine = (LPWSTR) szStaticLocalMachineName;

    for (pMachine = pLogInfo->MachineList; pMachine != NULL; pMachine = pMachine->next) {
        if (lstrcmpiW(pMachine->szMachine, szLocMachine) == 0) break;
    }

    if (pMachine != NULL) {
        pObject = PdhiFindLogObject(pMachine, & (pMachine->ObjTable), (LPWSTR) szObjectName, FALSE);
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_MACHINE;
        pObject   = NULL;
    }

    if (pObject != NULL) {
        WCHAR szIndexNumber[20];

        szFullInstance = G_ALLOC(dwFullInstance * sizeof(WCHAR));
        if (szFullInstance == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }

        for (pCounter = pObject->CtrList; pCounter != NULL; pCounter = pCounter->next) {
            pdhStatus = PdhiFindCounterInstList(CounterTable, pCounter->szCounter, & pInstList);
            if (pdhStatus != ERROR_SUCCESS) continue;

            if (pCounter->szInstance != NULL && pCounter->szInstance[0] != L'\0') {
                if (pCounter->szParent != NULL && pCounter->szParent[0] != L'\0') {
                    swprintf(szFullInstance, L"%ws%ws%ws", pCounter->szParent, L"/", pCounter->szInstance);
                }
                else {
                    lstrcpynW(szFullInstance, pCounter->szInstance, dwFullInstance);
                }
                if (pCounter->dwInstance > 0) {
                    ZeroMemory(szIndexNumber, 20 * sizeof(WCHAR));
                    _ultow(pCounter->dwInstance, szIndexNumber, 10);
                    lstrcatW(szFullInstance, L"#");
                    lstrcatW(szFullInstance, szIndexNumber);
                }
                pdhStatus = PdhiFindInstance(& pInstList->InstList, szFullInstance, TRUE, & pInstance);
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwItemCount ++;
            }
        }
    }
    else if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PDH_CSTATUS_NO_OBJECT;
    }
    if (dwItemCount > 0) {
        // then the routine was successful. Errors that occurred
        // while scanning will be ignored as long as at least
        // one entry was successfully read

        pdhStatus = ERROR_SUCCESS;
    }

Cleanup:
    G_FREE(szFullInstance);
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetMatchingSQLLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  LONGLONG    *pStartTime,
    IN  LPDWORD     pdwIndex
)
// find the counter detail rows with the correct start time & GUID,
// and return the record index
// and build the result 
{
    PDH_STATUS    pdhStatus = ERROR_SUCCESS;
    WCHAR         szSQLStmt[SQLSTMTSIZE];
    HSTMT         hstmt = NULL;    
    RETCODE       rc;
    DWORD         dwCounterId;
    DWORD         dwRecordIndex;
    WCHAR         szCounterDateTime[TIME_FIELD_BUFF_SIZE];
    LONGLONG      locStartTime = (* pStartTime) - 10;
    LARGE_INTEGER i64FirstValue, i64SecondValue;
    DWORD         dwMultiCount;
    WCHAR         szStartDate[30];

    PdhpConvertFileTimeToSQLString((LPFILETIME) (& locStartTime), szStartDate);

    swprintf(szSQLStmt,
        L"select CounterID, RecordIndex, CounterDateTime, FirstValueA, FirstValueB, SecondValueA, SecondValueB, MultiCount from CounterData where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x' and CounterDateTime >= '%ws'",
        pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
        pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
        pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
        pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7], szStartDate);

    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    // bind the columns
    rc = SQLBindCol(hstmt, 1, SQL_C_LONG, &dwCounterId, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 2, SQL_C_LONG, &dwRecordIndex, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 3, SQL_C_WCHAR, szCounterDateTime, sizeof(szCounterDateTime), NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 4, SQL_C_LONG, &i64FirstValue.LowPart, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 5, SQL_C_LONG, &i64FirstValue.HighPart, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 6, SQL_C_LONG, &i64SecondValue.LowPart, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 7, SQL_C_LONG, &i64SecondValue.HighPart, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 8, SQL_C_LONG, &dwMultiCount, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    // execute the select statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }


    rc = SQLFetch(hstmt);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_FETCH_FAILED);
        goto Cleanup;
    }

    if (SQL_NO_DATA == rc)
    {
        pdhStatus = PDH_NO_DATA;
        goto Cleanup;
    }

    pLog->dwLastRecordRead = dwRecordIndex;
    *pdwIndex = dwRecordIndex;

Cleanup:
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetCounterValueFromSQLLog (
    IN  PPDHI_LOG         pLog,
    IN  DWORD             dwIndex,
    IN  PPDHI_COUNTER     pCounter,
    IN  PPDH_RAW_COUNTER  pValue
)
// looks like this read one counter from the record line
// SQL can do this with a select
// It turns out the caller of this routine is looping thru
// pLog->pQuery->pCounterListHead and getting the pPath from PDHI_COUNTER
// then use the dwIndex as a recordid to get the pPath structure, so we can use the
// SQLCounterID from pPath directly and then use the dwIndex as a recordid. 
{
    PDH_STATUS       pdhStatus = ERROR_SUCCESS;
    WCHAR            szSQLStmt[SQLSTMTSIZE];
    HSTMT            hstmt = NULL;    
    RETCODE          rc;
    DWORD            dwMultiCount;
    WCHAR            szCounterDateTime[TIME_FIELD_BUFF_SIZE];
    FILETIME         ftCounterDateTime;
    LARGE_INTEGER    i64FirstValue, i64SecondValue;
    DOUBLE           dCounterValue;

    swprintf(szSQLStmt,
        L"select FirstValueA, FirstValueB, SecondValueA, SecondValueB, MultiCount, CounterDateTime, CounterValue from CounterData where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x' and CounterID = %d and RecordIndex = %d",
        pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
        pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
        pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
        pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7], pCounter->plCounterInfo.dwSQLCounterId,dwIndex);

    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    // bind the columns

    rc = SQLBindCol(hstmt, 1, SQL_C_LONG, &i64FirstValue.LowPart, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 2, SQL_C_LONG, &i64FirstValue.HighPart, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 3, SQL_C_LONG, &i64SecondValue.LowPart, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 4, SQL_C_LONG, &i64SecondValue.HighPart, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 5, SQL_C_LONG, &dwMultiCount, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 6, SQL_C_WCHAR, szCounterDateTime, sizeof(szCounterDateTime), NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 7, SQL_C_DOUBLE, &dCounterValue, 0, NULL);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    // execute the select statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }

    rc = SQLFetch(hstmt);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_FETCH_FAILED);
        goto Cleanup;
    }

    if (SQL_NO_DATA == rc)
    {
        pdhStatus = PDH_NO_MORE_DATA;
        goto Cleanup;
    }

    // build a raw counter on pValue
    pValue->CStatus      = PDH_CSTATUS_VALID_DATA;
    PdhpConvertSQLStringToFileTime(szCounterDateTime,&ftCounterDateTime);
    pValue->TimeStamp    = ftCounterDateTime;

    if (dwMultiCount == MULTI_COUNT_DOUBLE_RAW) {
        pCounter->plCounterInfo.dwCounterType = PERF_DOUBLE_RAW;
        pValue->FirstValue          = i64FirstValue.QuadPart;
        pValue->MultiCount          = 1;
        pValue->SecondValue         = i64SecondValue.QuadPart;
    }
    else if (pCounter->plCounterInfo.dwCounterType == PERF_DOUBLE_RAW) {
        (double) pValue->FirstValue = dCounterValue;
        pValue->SecondValue         = 0;
        pValue->MultiCount          = 1;
    }
    else {
        pValue->FirstValue          = i64FirstValue.QuadPart;
        pValue->MultiCount          = dwMultiCount;
        pValue->SecondValue         = i64SecondValue.QuadPart;
    }

Cleanup:
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetTimeRangeFromSQLLog (
    IN  PPDHI_LOG       pLog,
    IN  LPDWORD         pdwNumEntries,
    IN  PPDH_TIME_INFO  pInfo,
    IN  LPDWORD         pdwBufferSize
)
// The function PdhpGetSQLLogHeader or another routine that does
// something similar and saves the time range - which will
// do this, and save the results for subsequent calls - also
// gets the time range for a particular GUID.  SQL will never
// have multiple's per DB as it assigns a new GUID for each run.

/*++
    the first entry in the buffer returned is the total time range covered
    in the file, if there are multiple time blocks in the log file, then
    subsequent entries will identify each segment in the file.
--*/
{

    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    LONGLONG    llStartTime = MAX_TIME_VALUE;
    LONGLONG    llEndTime = MIN_TIME_VALUE;
    SQLLEN      dwStartTimeStat;
    SQLLEN      dwEndTimeStat;
    HSTMT        hstmt = NULL;    
    RETCODE        rc;
    WCHAR        szStartTime[TIME_FIELD_BUFF_SIZE];
    WCHAR        szEndTime[TIME_FIELD_BUFF_SIZE];
    DWORD        dwNumberOfRecords;
    SQLLEN      dwNumRecStat;
    WCHAR        szSQLStmt[SQLSTMTSIZE];


    swprintf(szSQLStmt,
        L"select LogStartTime, LogStopTime, NumberOfRecords from DisplayToID where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x'",
        pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
        pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
        pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
        pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);

    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    // bind the date columns column
    rc = SQLBindCol(hstmt, 1, SQL_C_WCHAR, szStartTime, sizeof(szStartTime), &dwStartTimeStat);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 2, SQL_C_WCHAR, szEndTime, sizeof(szEndTime), &dwEndTimeStat);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLBindCol(hstmt, 3, SQL_C_LONG, &dwNumberOfRecords, 0, &dwNumRecStat);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    // execute the select statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }

    rc = SQLFetch(hstmt);
    if (SQL_NO_DATA == rc)
    {
        pdhStatus = PDH_NO_DATA;
        goto Cleanup;
    }

    // if anything is missing - could try and re-create from existing log file
    if ((SQL_NULL_DATA == dwStartTimeStat) ||
        (SQL_NULL_DATA == dwEndTimeStat) ||
        (SQL_NULL_DATA == dwNumRecStat))
    {
        pdhStatus = PDH_INVALID_DATA;
        goto Cleanup;
    }

    // convert the dates
    PdhpConvertSQLStringToFileTime (szStartTime,(LPFILETIME)&llStartTime);
    PdhpConvertSQLStringToFileTime (szEndTime,(LPFILETIME)&llEndTime);

    // we have the info so update the args.
    if (*pdwBufferSize >=  sizeof(PDH_TIME_INFO))
    {
        *(LONGLONG *)(&pInfo->StartTime) = llStartTime;
        *(LONGLONG *)(&pInfo->EndTime) = llEndTime;
        pInfo->SampleCount = dwNumberOfRecords;
        *pdwBufferSize = sizeof(PDH_TIME_INFO);
        *pdwNumEntries = 1;
    }

Cleanup:
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    return pdhStatus;
}

PDH_FUNCTION
PdhiReadRawSQLLogRecord (
    IN  PPDHI_LOG    pLog,
    IN  FILETIME     *ftRecord,
    IN  PPDH_RAW_LOG_RECORD     pBuffer,
    IN  LPDWORD                 pdwBufferLength
)
// requirement to connect counter/instance names makes this difficult - not needed anyway
{
    UNREFERENCED_PARAMETER (pLog);
    UNREFERENCED_PARAMETER (ftRecord);
    UNREFERENCED_PARAMETER (pBuffer);
    UNREFERENCED_PARAMETER (pdwBufferLength);

    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhpGetSQLLogHeader(
    PPDHI_LOG pLog
)
{
    PDH_STATUS         pdhStatus       = ERROR_SUCCESS;
    PPDHI_SQL_LOG_INFO pLogInfo;
    HSTMT              hstmt           = NULL;    
    RETCODE            rc;
    LPWSTR             szSQLStmt       = NULL;
    LPWSTR             szMachineNamel  = NULL;
    LPWSTR             szObjectNamel   = NULL;
    LPWSTR             szCounterNamel  = NULL;
    LPWSTR             szInstanceNamel = NULL;
    LPWSTR             szParentNamel   = NULL;
    DWORD              dwInstanceIndexl;
    DWORD              dwParentObjIdl;
    DWORD              dwSQLCounterIdl;
    DWORD              dwCounterTypel;
    LARGE_INTEGER      lTimeBase;
    LONG               lDefaultScalel;
    SQLLEN             dwMachineNameLen;
    SQLLEN             dwObjectNameLen;
    SQLLEN             dwCounterNameLen;
    SQLLEN             dwInstanceNameLen;
    SQLLEN             dwParentNameLen;
    SQLLEN             dwInstanceIndexStat;
    SQLLEN             dwParentObjIdStat;
    SQLLEN             dwTimeBaseA;
    SQLLEN             dwTimeBaseB;
    SQLLEN             dwSQLCounterId;

    if (pLog->pPerfmonInfo != NULL) return ERROR_SUCCESS;

    pLogInfo  = (PPDHI_SQL_LOG_INFO) G_ALLOC(sizeof(PDHI_SQL_LOG_INFO));
    szSQLStmt = (LPWSTR) G_ALLOC((SQLSTMTSIZE + 5 * PDH_SQL_STRING_SIZE) * sizeof(WCHAR));
    if (pLogInfo == NULL || szSQLStmt == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    pLog->pPerfmonInfo = pLogInfo;
    szMachineNamel  = szSQLStmt + SQLSTMTSIZE;
    szObjectNamel   = szMachineNamel  + PDH_SQL_STRING_SIZE;
    szCounterNamel  = szObjectNamel   + PDH_SQL_STRING_SIZE;
    szInstanceNamel = szCounterNamel  + PDH_SQL_STRING_SIZE;
    szParentNamel   = szInstanceNamel + PDH_SQL_STRING_SIZE;

    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }
    swprintf(szSQLStmt,
            L"select distinct MachineName, ObjectName, CounterName, CounterType, DefaultScale, InstanceName, InstanceIndex, ParentName, ParentObjectID, CounterID, TimeBaseA, TimeBaseB from CounterDetails where CounterID in (select distinct CounterID from CounterData where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x') Order by MachineName, ObjectName, CounterName, InstanceName, InstanceIndex ",
            pLog->guidSQL.Data1,    pLog->guidSQL.Data2,    pLog->guidSQL.Data3,
            pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
            pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
            pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);

    // note SQL returns the size in bytes without the terminating character
    rc = SQLBindCol(hstmt, 1, SQL_C_WCHAR, szMachineNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwMachineNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 2, SQL_C_WCHAR, szObjectNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwObjectNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 3, SQL_C_WCHAR, szCounterNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwCounterNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 4, SQL_C_LONG, & dwCounterTypel, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 5, SQL_C_LONG, & lDefaultScalel, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    // check for SQL_NULL_DATA on the index's and on Instance Name & Parent Name
    rc = SQLBindCol(hstmt, 6, SQL_C_WCHAR, szInstanceNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwInstanceNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 7, SQL_C_LONG, & dwInstanceIndexl, 0, & dwInstanceIndexStat);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 8, SQL_C_WCHAR, szParentNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwParentNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 9, SQL_C_LONG, & dwParentObjIdl, 0, & dwParentObjIdStat);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 10, SQL_C_LONG, & dwSQLCounterIdl, 0, & dwSQLCounterId);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 11, SQL_C_LONG, & lTimeBase.LowPart, 0, & dwTimeBaseA);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 12, SQL_C_LONG, & lTimeBase.HighPart, 0, & dwTimeBaseB);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    // execute the sql command
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }
    rc = SQLFetch(hstmt);
    while (rc != SQL_NO_DATA) {
        PPDHI_LOG_COUNTER pCounter;

        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
            break;
        }
        else {
            LPWSTR szInstance = (dwInstanceNameLen != SQL_NULL_DATA) ? (szInstanceNamel) : (NULL);
            LPWSTR szParent   = (dwParentNameLen   != SQL_NULL_DATA) ? (szParentNamel)   : (NULL);

            if (dwInstanceIndexStat == SQL_NULL_DATA) dwInstanceIndexl = 0;
            if (dwParentObjIdStat   == SQL_NULL_DATA) dwParentObjIdl   = 0;

            pCounter = PdhiFindLogCounter(pLog,
                                          & pLogInfo->MachineList,
                                          szMachineNamel,
                                          szObjectNamel,
                                          szCounterNamel,
                                          dwCounterTypel,
                                          lDefaultScalel,
                                          szInstance,
                                          dwInstanceIndexl,
                                          szParent,
                                          dwParentObjIdl,
                                          & dwSQLCounterIdl,
                                          TRUE);
            if (pCounter == NULL) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_CSTATUS_NO_COUNTER);
                break;
            }
            if (dwTimeBaseA != SQL_NULL_DATA && dwTimeBaseB != SQL_NULL_DATA) {
                pCounter->TimeBase = lTimeBase.QuadPart;
            }
            else {
                pCounter->dwCounterType  = PERF_DOUBLE_RAW;
                pCounter->TimeBase       = 0;
                pCounter->dwDefaultScale = 0;
            }
        }
        rc = SQLFetch(hstmt);
    }

Cleanup:
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    G_FREE(szSQLStmt);
    if (pdhStatus != ERROR_SUCCESS) {
        G_FREE(pLogInfo);
        pLog->pPerfmonInfo = NULL;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiVerifySQLDB (
  LPCWSTR szDataSource)
{
    // INTERNAL FUNCTION to
    // Check that a DSN points to a database that contains the correct Perfmon tables.
    // select from the tables and check for an error

    PDH_STATUS    pdhStatus = ERROR_SUCCESS;
    HSTMT        hstmt = NULL;    
    RETCODE        rc;
    PDHI_LOG    Log; // a fake log structure - just to make opens work ok
    
    WCHAR        szMachineNamel[PDH_SQL_STRING_SIZE+1];
    WCHAR        szObjectNamel[PDH_SQL_STRING_SIZE+1];
    WCHAR        szCounterNamel[PDH_SQL_STRING_SIZE+1];
    WCHAR        szInstanceNamel[PDH_SQL_STRING_SIZE+1];
    WCHAR        szParentNamel[PDH_SQL_STRING_SIZE+1];
    
    SQLLEN      dwMachineNameLen;
    SQLLEN      dwObjectNameLen;
    SQLLEN      dwCounterNameLen;
    SQLLEN      dwInstanceNameLen;
    SQLLEN      dwParentNameLen;

    DWORD        dwInstanceIndexl;
    DWORD        dwParentObjIdl;
    SQLLEN      dwInstanceIndexStat;
    SQLLEN      dwParentObjIdStat;

    DWORD        dwSQLCounterIdl;
    DWORD        dwCounterTypel;
    LONG        lDefaultScalel;
    LONG        lMinutesToUTC = 0;
    WCHAR        szTimeZoneName[32];
    SQLLEN      dwTimeZoneLen;


    DWORD        dwNumOfRecs;
    double      dblCounterValuel;

    WCHAR        szSQLStmt[SQLSTMTSIZE];
    DWORD       dwMultiCount;
    WCHAR        szCounterDateTime[TIME_FIELD_BUFF_SIZE];

    LARGE_INTEGER           i64FirstValue, i64SecondValue;
 
    ZeroMemory((void *)(&Log), sizeof(PDHI_LOG));
 
    // open the database
    //////////////////////////////////////////////////////////////
    // obtain the ODBC environment and connection
    //

    rc = SQLAllocEnv(&Log.henvSQL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }
    
    rc = SQLAllocConnect(Log.henvSQL, &Log.hdbcSQL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }

    rc = SQLSetConnectAttr(Log.hdbcSQL,
                           SQL_COPT_SS_BCP,
                           (SQLPOINTER) SQL_BCP_ON,
                           SQL_IS_INTEGER);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }

    rc = SQLConnectW(Log.hdbcSQL,
                    (SQLWCHAR*)szDataSource, SQL_NTS,
                    NULL, SQL_NULL_DATA,        // Use password & user name from DSN
                    NULL, SQL_NULL_DATA);    
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_CONNECT_FAILED);
        pdhStatus = PDH_INVALID_DATASOURCE;
        goto CleanupExit;
    }

    // do a select on the CounterDetails Table

    swprintf(szSQLStmt,
        L"select MachineName, ObjectName, CounterName, CounterType, DefaultScale, InstanceName, InstanceIndex, ParentName, ParentObjectID, CounterID from CounterDetails");

    // allocate an hstmt
    rc = SQLAllocStmt(Log.hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }

    // note SQL returns the size in bytes without the terminating character
    rc = SQLBindCol(hstmt, 1, SQL_C_WCHAR, szMachineNamel, sizeof(szMachineNamel), &dwMachineNameLen);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 2, SQL_C_WCHAR, szObjectNamel, sizeof(szObjectNamel), &dwObjectNameLen);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 3, SQL_C_WCHAR, szCounterNamel, sizeof(szCounterNamel), &dwCounterNameLen);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 4, SQL_C_LONG, &dwCounterTypel, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 5, SQL_C_LONG, &lDefaultScalel, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }


    rc = SQLBindCol(hstmt, 6, SQL_C_WCHAR, szInstanceNamel, sizeof(szInstanceNamel), &dwInstanceNameLen);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 7, SQL_C_LONG, &dwInstanceIndexl, 0, &dwInstanceIndexStat);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 8, SQL_C_WCHAR, szParentNamel, sizeof(szParentNamel), &dwParentNameLen);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 9, SQL_C_LONG, &dwParentObjIdl, 0, &dwParentObjIdStat);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 10, SQL_C_LONG, &dwSQLCounterIdl, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    // execute the sql command
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = PDH_INVALID_SQLDB;
        goto CleanupExit;
    }

    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    // do a select on the DisplayToID Table

    swprintf(szSQLStmt,L"select GUID, RunID, DisplayString, LogStartTime, LogStopTime, NumberOfRecords, MinutesToUTC, TimeZoneName from DisplayToID");

    // allocate an hstmt
    rc = SQLAllocStmt(Log.hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }

    // bind the column names - reuse local strings as needed
    rc = SQLBindCol(hstmt, 1, SQL_C_GUID, &Log.guidSQL, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 2, SQL_C_LONG, &Log.iRunidSQL, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    // DislayString
    rc = SQLBindCol(hstmt, 3, SQL_C_WCHAR, szMachineNamel, sizeof(szMachineNamel), &dwMachineNameLen);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    //LogStartTime
    rc = SQLBindCol(hstmt, 4, SQL_C_WCHAR, szObjectNamel, sizeof(szObjectNamel), &dwObjectNameLen);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    //LogStopTime
    rc = SQLBindCol(hstmt, 5, SQL_C_WCHAR, szCounterNamel, sizeof(szCounterNamel), &dwCounterNameLen);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 6, SQL_C_LONG, &dwNumOfRecs, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 7, SQL_C_LONG, &lMinutesToUTC, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 8, SQL_C_WCHAR, szTimeZoneName, sizeof(szTimeZoneName), &dwTimeZoneLen);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }


    // execute the sql command
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = PDH_INVALID_SQLDB;
        goto CleanupExit;
    }

    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    // do a select on the CounterData Table

    swprintf(szSQLStmt,
        L"select GUID, CounterID, RecordIndex, CounterDateTime, CounterValue, FirstValueA, FirstValueB, SecondValueA, SecondValueB, MultiCount from CounterData");

    // allocate an hstmt
    rc = SQLAllocStmt(Log.hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }

    // bind the columns

    rc = SQLBindCol(hstmt, 1, SQL_C_GUID, &Log.guidSQL, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 2, SQL_C_LONG, &dwSQLCounterIdl, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    // record index
    rc = SQLBindCol(hstmt, 3, SQL_C_LONG, &dwNumOfRecs, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 4, SQL_C_WCHAR, szCounterDateTime, sizeof(szCounterDateTime), NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 5, SQL_C_DOUBLE, &dblCounterValuel, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 6, SQL_C_LONG, &i64FirstValue.LowPart, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 7, SQL_C_LONG, &i64FirstValue.HighPart, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 8, SQL_C_LONG, &i64SecondValue.LowPart, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 9, SQL_C_LONG, &i64SecondValue.HighPart, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    rc = SQLBindCol(hstmt, 10, SQL_C_LONG, &dwMultiCount, 0, NULL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }


    // execute the select statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = E_FAIL; // PDH_INVALID_SQLDB
        goto CleanupExit;
    }

    // close the database

CleanupExit:  // verify db
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    if (Log.hdbcSQL) {
        SQLDisconnect(Log.hdbcSQL);        
        SQLFreeHandle(SQL_HANDLE_DBC, Log.hdbcSQL);
    }
    if (Log.henvSQL) SQLFreeHandle(SQL_HANDLE_ENV, Log.henvSQL);
    return pdhStatus;
}

PDH_FUNCTION
PdhVerifySQLDBA (
  LPCSTR szDataSource)
{
    //Check that a DSN points to a database that contains the correct Perfmon tables.
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    WCHAR wszDataSource[PDH_SQL_STRING_SIZE+1];
    DWORD dwLength;

    // check args

    __try 
    {

        if (szDataSource != NULL)
        {
            WCHAR       TestChar;
            // test for read access to the name
            TestChar = *szDataSource;
            if (TestChar == 0)
            {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } 
        else pdhStatus = PDH_INVALID_ARGUMENT;

        if (ERROR_SUCCESS == pdhStatus)
        {
            dwLength = lstrlenA(szDataSource);
            RtlZeroMemory(wszDataSource, sizeof(wszDataSource));
            MultiByteToWideChar(_getmbcp(),
                                0,
                                szDataSource,
                                dwLength,
                                (LPWSTR) wszDataSource,
                                PDH_SQL_STRING_SIZE);
            pdhStatus = PdhiVerifySQLDB(wszDataSource);
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhVerifySQLDBW (
  LPCWSTR szDataSource)
{
    //Check that a DSN points to a database that contains the correct Perfmon tables.
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    __try 
    {

        if (szDataSource != NULL)
        {
            WCHAR       TestChar;
            // test for read access to the name
            TestChar = *szDataSource;
            if (TestChar == 0)
            {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } 
        else pdhStatus = PDH_INVALID_ARGUMENT;

        if (ERROR_SUCCESS == pdhStatus)
        {
            pdhStatus = PdhiVerifySQLDB (szDataSource);
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiCreateSQLTables (
  LPCWSTR szDataSource)      
{
    // INTERNAL FUNCTION to
    //Create the correct perfmon tables in the database pointed to by a DSN.
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    RETCODE        rc;
    PDHI_LOG    Log; // a fake log structure - just to make opens work ok

    ZeroMemory((void *)(&Log), sizeof(PDHI_LOG));

    // open the database
    //////////////////////////////////////////////////////////////
    // obtain the ODBC environment and connection
    //

    rc = SQLAllocEnv(&Log.henvSQL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }
    
    rc = SQLAllocConnect(Log.henvSQL, &Log.hdbcSQL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }

    rc = SQLSetConnectAttr(Log.hdbcSQL,
                           SQL_COPT_SS_BCP,
                           (SQLPOINTER) SQL_BCP_ON,
                           SQL_IS_INTEGER);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }

    rc = SQLConnectW(Log.hdbcSQL,
                    (SQLWCHAR*)szDataSource, SQL_NTS,
                    NULL, SQL_NULL_DATA,        // Use password & user name from DSN
                    NULL, SQL_NULL_DATA);    
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_CONNECT_FAILED);
        goto CleanupExit;
    }

    // actually create the tables
    pdhStatus = PdhpCreateSQLTables(&Log);

CleanupExit: 
    if (Log.hdbcSQL) SQLDisconnect(Log.hdbcSQL);        
    if (Log.hdbcSQL) SQLFreeHandle(SQL_HANDLE_DBC, Log.hdbcSQL);
    if (Log.henvSQL) SQLFreeHandle(SQL_HANDLE_ENV, Log.henvSQL);
    return pdhStatus;
}

PDH_FUNCTION
PdhCreateSQLTablesA (
  LPCSTR szDataSource)      
{
    //Create the correct perfmon tables in the database pointed to by a DSN.
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    WCHAR wszDataSource[PDH_SQL_STRING_SIZE+1];
    DWORD dwLength;

    // check args

    __try 
    {

        if (szDataSource != NULL)
        {
            WCHAR       TestChar;
            // test for read access to the name
            TestChar = *szDataSource;
            if (TestChar == 0)
            {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } 
        else pdhStatus = PDH_INVALID_ARGUMENT;

        if (ERROR_SUCCESS == pdhStatus)
        {
            dwLength = lstrlenA(szDataSource);
            ZeroMemory(wszDataSource, sizeof(wszDataSource));
            MultiByteToWideChar(_getmbcp(),
                                0,
                                szDataSource,
                                dwLength,
                                (LPWSTR) wszDataSource,
                                PDH_SQL_STRING_SIZE);
            pdhStatus = PdhiCreateSQLTables (wszDataSource);
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhCreateSQLTablesW (
  LPCWSTR szDataSource)      
{
    //Create the correct perfmon tables in the database pointed to by a DSN.
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    __try 
    {

        if (szDataSource != NULL)
        {
            WCHAR       TestChar;
            // test for read access to the name
            TestChar = *szDataSource;
            if (TestChar == 0)
            {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } 
        else pdhStatus = PDH_INVALID_ARGUMENT;

        if (ERROR_SUCCESS == pdhStatus)
        {
            pdhStatus = PdhiCreateSQLTables (szDataSource);
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumLogSetNames (
  LPCWSTR szDataSource,
  LPVOID mszDataSetNameList,
  LPDWORD pcchBufferLength,
  BOOL bUnicodeDest)
{
    //Return the list of Log set names in the database pointed to by the DSN.
    PDH_STATUS    pdhStatus = ERROR_SUCCESS;
    PDH_STATUS    pdhBuffStatus = ERROR_SUCCESS;
    HSTMT        hstmt = NULL;    
    RETCODE        rc;
    PDHI_LOG    Log; // a fake log structure - just to make opens work ok

    WCHAR        szSQLStmt[SQLSTMTSIZE];
    WCHAR        szDisplayStringl[PDH_SQL_STRING_SIZE+1];

    SQLLEN      dwDisplayStringLen;
    DWORD        dwNewBuffer;
    DWORD        dwListUsed;
    DWORD        dwAdditionalSpace;

    ZeroMemory((void *)(&Log), sizeof(PDHI_LOG));

    // open the database
    //////////////////////////////////////////////////////////////
    // obtain the ODBC environment and connection
    //

    rc = SQLAllocEnv(&Log.henvSQL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }

    
    rc = SQLAllocConnect(Log.henvSQL, &Log.hdbcSQL);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }

    rc = SQLSetConnectAttr(Log.hdbcSQL,
                           SQL_COPT_SS_BCP,
                           (SQLPOINTER) SQL_BCP_ON,
                           SQL_IS_INTEGER);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }

    rc = SQLConnectW(Log.hdbcSQL,
                    (SQLWCHAR*)szDataSource, SQL_NTS,
                    NULL, SQL_NULL_DATA,        // Use password & user name from DSN
                    NULL, SQL_NULL_DATA);    
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,NULL,PDH_SQL_CONNECT_FAILED);
        goto CleanupExit;
    }

    // do a select
    // loop around in a fetch and 
    // build the list of names

    swprintf(szSQLStmt,L"select DisplayString from DisplayToID");

    // allocate an hstmt
    rc = SQLAllocStmt(Log.hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }

    // bind the machine name column
    rc = SQLBindCol(hstmt, 1, SQL_C_WCHAR, szDisplayStringl, sizeof(szDisplayStringl), &dwDisplayStringLen);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }

    // execute the select statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
        goto CleanupExit;
    }

    dwListUsed=1 *(bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)); // include the null terminator to start;
    dwAdditionalSpace = 0; // used to accumulate additional memory size req. when buffer overflows

    // loop around the result set using fetch
    while ( (rc = SQLFetch(hstmt)) != SQL_NO_DATA) 
    {
        if (!SQLSUCCEEDED(rc))
        {
            pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_FETCH_FAILED);
            goto CleanupExit;
        }

        // Append the DisplayName to the returned list
        dwNewBuffer = (lstrlenW (szDisplayStringl) + 1) *
            (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR));

        if (0 == *pcchBufferLength)
        {
            // SQL won't let non unique LogSet names into the database
            // so we don't really have to worry about duplicates
            dwListUsed += dwNewBuffer;
        }
        else
        {// we actually think we have an extra terminator - so for an exact fit test against one extra in the output buffer
            if ((dwListUsed + dwNewBuffer) > *pcchBufferLength * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)))
            {
                pdhBuffStatus = PDH_MORE_DATA;
                dwAdditionalSpace += dwNewBuffer;
            }
            else
            {
                // add the display name
                dwNewBuffer = PdhpAddUniqueUnicodeStringToMultiSz(
                            (LPVOID)mszDataSetNameList,
                            (LPWSTR)szDisplayStringl,
                            bUnicodeDest);
                
                if (dwNewBuffer != 0) // if it got added returned new length in TCHAR
                {
                    dwListUsed = dwNewBuffer * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)); 
                }
            }
        }
                
    } // end of while fetch

    if (!SQLSUCCEEDED(rc))
    {
        pdhStatus = ReportSQLError(&Log,rc,hstmt,PDH_SQL_FETCH_FAILED);
        goto CleanupExit;
    }

    if (0 == *pcchBufferLength)
    {
        pdhBuffStatus = PDH_MORE_DATA; 
        *pcchBufferLength = (dwListUsed / (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    }
    else if (pdhBuffStatus == PDH_MORE_DATA)
    {
        *pcchBufferLength = ((dwListUsed + dwAdditionalSpace) / (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    }
    else
    {
        *pcchBufferLength = (dwListUsed / (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR))); 
    }
    pdhStatus = pdhBuffStatus;

    // close the database

CleanupExit:
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    if (Log.hdbcSQL) {
        SQLDisconnect(Log.hdbcSQL);        
        SQLFreeHandle(SQL_HANDLE_DBC, Log.hdbcSQL);
    }
    if (Log.henvSQL) SQLFreeHandle(SQL_HANDLE_ENV, Log.henvSQL);
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumLogSetNamesA (
  LPCSTR szDataSource,
  LPSTR mszDataSetNameList,
  LPDWORD pcchBufferLength)
{
    //Return the list of Log set names in the database pointed to by the DSN.
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwBufferSize;

    WCHAR wszDataSource[PDH_SQL_STRING_SIZE+1];
    DWORD dwLength;

    // check args

    __try 
    {
        
        if (szDataSource != NULL)
        {
            WCHAR       TestChar;
            // test for read access to the name
            TestChar = *szDataSource;
            if (TestChar == 0)
            {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } 
        else pdhStatus = PDH_INVALID_ARGUMENT;

        if (mszDataSetNameList != NULL)
        {
            // test for write access to the name
            *mszDataSetNameList = 0;
        } 

        if (pdhStatus == ERROR_SUCCESS && mszDataSetNameList != NULL)
        {
            if (*pcchBufferLength >= sizeof(DWORD)) 
            {
                // test writing to the buffers to make sure they are valid
                CLEAR_FIRST_FOUR_BYTES (mszDataSetNameList);
                mszDataSetNameList[*pcchBufferLength -1] = 0;
            } 
            else if (*pcchBufferLength >= sizeof(WCHAR))
            {
                // then just try the first byte
                *mszDataSetNameList = 0;
            }
            else if (*pcchBufferLength != 0)
            {
                // it's smaller than a character so return if not 0
                pdhStatus = PDH_MORE_DATA;
            }
        }

        if (pdhStatus == ERROR_SUCCESS)
        {
            dwBufferSize = *pcchBufferLength;
            *pcchBufferLength = 0;
            *pcchBufferLength = dwBufferSize;
        }

        if (ERROR_SUCCESS == pdhStatus)
        {
            dwLength = lstrlenA(szDataSource);
            ZeroMemory(wszDataSource, sizeof(wszDataSource));
            MultiByteToWideChar(_getmbcp(),
                                0,
                                szDataSource,
                                dwLength,
                                (LPWSTR) wszDataSource,
                                PDH_SQL_STRING_SIZE);
            pdhStatus = PdhiEnumLogSetNames (wszDataSource,
                mszDataSetNameList,
                pcchBufferLength,
                FALSE);
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhEnumLogSetNamesW (
  LPCWSTR szDataSource,
  LPWSTR mszDataSetNameList,
  LPDWORD pcchBufferLength)
{
    //Return the list of Log set names in the database pointed to by the DSN.
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwBufferSize;

    // check args

    __try 
    {

        if (szDataSource != NULL)
        {
            WCHAR       TestChar;
            // test for read access to the name
            TestChar = *szDataSource;
            if (TestChar == 0)
            {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } 
        else pdhStatus = PDH_INVALID_ARGUMENT;

        if (mszDataSetNameList != NULL)
        {
            // test for write access to the name
            *mszDataSetNameList = 0;
        } 

        if (pdhStatus == ERROR_SUCCESS && mszDataSetNameList != NULL)
        {
            if (*pcchBufferLength >= sizeof(DWORD)) 
            {
                // test writing to the buffers to make sure they are valid
                CLEAR_FIRST_FOUR_BYTES (mszDataSetNameList);
                mszDataSetNameList[*pcchBufferLength -1] = 0;
            } 
            else if (*pcchBufferLength >= sizeof(WCHAR))
            {
                // then just try the first byte
                *mszDataSetNameList = 0;
            }
            else if (*pcchBufferLength != 0)
            {
                // it's smaller than a character so return if not 0
                pdhStatus = PDH_MORE_DATA;
            }
        }

        if (pdhStatus == ERROR_SUCCESS)
        {
            dwBufferSize = *pcchBufferLength;
            *pcchBufferLength = 0;
            *pcchBufferLength = dwBufferSize;
        }

        if (ERROR_SUCCESS == pdhStatus)
        {

            pdhStatus = PdhiEnumLogSetNames (szDataSource,
                mszDataSetNameList,
                pcchBufferLength,
                TRUE);
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhGetLogSetGUID (
  HLOG hLog,             
  GUID *pGuid,
  int *pRunId)
{
    //Retrieve the GUID for an open Log Set
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    PPDHI_LOG       pLog;

    if (IsValidLogHandle (hLog)) {
        pLog = (PPDHI_LOG)hLog;
        WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);
        // make sure it's still valid as it could have 
        //  been deleted while we were waiting

        if (IsValidLogHandle (hLog))
        {
            pLog = (PPDHI_LOG)hLog;

            __try
            {
                // test the parameters before continuing
                if ((pGuid == NULL) && (pRunId == NULL))
                {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else
                {
                    if (pGuid != NULL)
                    {
                        // if not NULL, it must be valid
                        *pGuid = pLog->guidSQL;
                    }
                    if (pRunId != NULL)
                    {
                        // if not NULL, it must be valid
                        *pRunId = pLog->iRunidSQL;
                    }
                }

            } 
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                // something failed so give up here
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        else
        {
            pdhStatus = PDH_INVALID_HANDLE;
        }

        RELEASE_MUTEX (pLog->hLogMutex);
    }
    else
    {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    
    return pdhStatus;
}

PDH_FUNCTION
PdhiSetLogSetRunID (
    PPDHI_LOG pLog,
    int RunId)
{
    //Set the RunID for an open Log Set 
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    HSTMT        hstmt = NULL;    
    RETCODE        rc;

    WCHAR   szSQLStmt[SQLSTMTSIZE];

    pLog->iRunidSQL = RunId;

    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    swprintf(szSQLStmt,
        L"update DisplayToID set RunID = %d where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x'",
        RunId,
        pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
        pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
        pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
        pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);

    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }

Cleanup:
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    return pdhStatus;
}

PDH_FUNCTION
PdhSetLogSetRunID (
  HLOG hLog,             
  int RunId)
{
    //Set the RunID for an open Log Set 
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    PPDHI_LOG       pLog;

    if (IsValidLogHandle (hLog))
    {
        pLog = (PPDHI_LOG)hLog;
        WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);
        // make sure it's still valid as it could have 
        //  been deleted while we were waiting

        if (IsValidLogHandle (hLog))
        {
            pLog = (PPDHI_LOG)hLog;

            pdhStatus = PdhiSetLogSetRunID (pLog, RunId);
        }
        else
        {
            pdhStatus = PDH_INVALID_HANDLE;
        }

        RELEASE_MUTEX (pLog->hLogMutex);
    }
    else
    {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    
    return pdhStatus;
}

PDH_FUNCTION
PdhiListHeaderFromSQLLog(
    IN  PPDHI_LOG   pLog,
    IN  LPVOID      pBufferArg,
    IN  LPDWORD     pcchBufferSize,
    IN  BOOL        bUnicode
)
{
    PPDHI_SQL_LOG_INFO           pLogInfo;
    PPDHI_LOG_MACHINE            pMachine;
    PPDHI_LOG_OBJECT             pObject;
    PPDHI_LOG_COUNTER            pCounter;
    PDH_COUNTER_PATH_ELEMENTS_W  pdhPathElem;
    WCHAR                        szPathString[SMALL_BUFFER_SIZE];
    PDH_STATUS                   pdhStatus    = ERROR_SUCCESS;
    DWORD                        dwNewBuffer  = 0;
    DWORD                        dwBufferUsed = 0;
    DWORD                        nItemCount   = 0;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }
    pdhStatus = PdhpGetSQLLogHeader(pLog);
    if (pdhStatus != ERROR_SUCCESS) goto Cleanup;

    pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;
    if (pLogInfo == NULL) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        goto Cleanup;
    }

    for (pMachine = pLogInfo->MachineList; pMachine != NULL; pMachine = pMachine->next) {
        for (pObject = pMachine->ObjList; pObject != NULL; pObject = pObject->next) {
            for (pCounter = pObject->CtrList; pCounter != NULL; pCounter = pCounter->next) {
                ZeroMemory(szPathString,  SMALL_BUFFER_SIZE * sizeof(WCHAR));
                dwNewBuffer = SMALL_BUFFER_SIZE;
                ZeroMemory(& pdhPathElem, sizeof(PDH_COUNTER_PATH_ELEMENTS_W));
                pdhPathElem.szMachineName    = pMachine->szMachine;
                pdhPathElem.szObjectName     = pObject->szObject;
                pdhPathElem.szCounterName    = pCounter->szCounter;
                pdhPathElem.szInstanceName   = pCounter->szInstance;
                pdhPathElem.szParentInstance = pCounter->szParent;
                pdhPathElem.dwInstanceIndex  = (pCounter->dwInstance != 0)
                                             ? (pCounter->dwInstance) : (PERF_NO_UNIQUE_ID);
                pdhStatus = PdhMakeCounterPathW(& pdhPathElem, szPathString, & dwNewBuffer, 0);
                if (pdhStatus != ERROR_SUCCESS || dwNewBuffer == 0) continue;

                if ((dwBufferUsed + dwNewBuffer) < * pcchBufferSize) {
                    if (pBufferArg != NULL) {
                        dwNewBuffer = AddUniqueWideStringToMultiSz((LPVOID) pBufferArg, szPathString, bUnicode);
                    }
                    else {
                        dwNewBuffer += dwBufferUsed;
                        pdhStatus    = PDH_MORE_DATA;
                    }
                }
                else {
                    dwNewBuffer += dwBufferUsed;
                    pdhStatus    = PDH_MORE_DATA;
                }
                if (dwNewBuffer > 0) dwBufferUsed = dwNewBuffer;
                nItemCount ++;
            }
        }
    }

    if (nItemCount > 0  && pdhStatus != PDH_INSUFFICIENT_BUFFER && pdhStatus != PDH_MORE_DATA) {
        pdhStatus = ERROR_SUCCESS;
    }
    if (pBufferArg == NULL) {
        dwBufferUsed ++;
    }

    * pcchBufferSize = dwBufferUsed;

Cleanup:
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log_pm.c ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    log_pm.c

Abstract:
    <abstract>
--*/

#include <windows.h>
#include <limits.h>
#include <pdh.h>
#include "pdhidef.h"
#include "perftype.h"
#include "log_pm.h"
#include "pdhmsg.h"
#include "perftype.h"
#include "perfdata.h"

#define PointerSeek(pBase, lFileOffset) ((PVOID) ((PBYTE) pBase + lFileOffset))

int
PdhiCompareLogCounterInstance(
    PPDHI_LOG_COUNTER pCounter,
    LPWSTR            szCounter,
    LPWSTR            szInstance,
    DWORD             dwInstance,
    LPWSTR            szParent
);

void
PdhiFreeLogCounterNode(
    PPDHI_LOG_COUNTER pCounter,
    DWORD             dwLevel
);

void
PdhiFreeLogObjectNode(
    PPDHI_LOG_OBJECT pObject,
    DWORD            dwLevel
);

void
PdhiFreeLogMachineTable(
    PPDHI_LOG_MACHINE * MachineTable
);

PPDHI_LOG_MACHINE
PdhiFindLogMachine(
    PPDHI_LOG_MACHINE * MachineTable,
    LPWSTR              szMachine,
    BOOL                bInsert
);

PPDHI_LOG_OBJECT
PdhiFindLogObject(
    PPDHI_LOG_MACHINE  pMachine,
    PPDHI_LOG_OBJECT * ObjectTable,
    LPWSTR             szObject,
    BOOL               bInsert
);

PPDHI_LOG_COUNTER
PdhiFindLogCounter(
    PPDHI_LOG           pLog,
    PPDHI_LOG_MACHINE * MachineTable,
    LPWSTR              szMachine,
    LPWSTR              szObject,
    LPWSTR              szCounter,
    DWORD               dwCounterType,
    DWORD               dwDefaultScale,
    LPWSTR              szInstance,
    DWORD               dwInstance,
    LPWSTR              szParent,
    DWORD               dwParent,
    LPDWORD             pdwIndex,
    BOOL                bInsert
);

PDH_FUNCTION
PdhiEnumCachedMachines(
    PPDHI_LOG_MACHINE MachineList,
    LPVOID            pBuffer,
    LPDWORD           lpdwBufferSize,
    BOOL              bUnicodeDest
)
{
    PDH_STATUS        pdhStatus       = ERROR_SUCCESS;
    DWORD             dwBufferUsed    = 0;
    DWORD             dwNewBuffer     = 0;
    DWORD             dwItemCount     = 0;
    LPVOID            LocalBuffer     = NULL;
    LPVOID            TempBuffer      = NULL;
    DWORD             LocalBufferSize = 0;
    PPDHI_LOG_MACHINE pMachine;

    LocalBufferSize = MEDIUM_BUFFER_SIZE;
    LocalBuffer     = G_ALLOC(LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    if (LocalBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    dwItemCount  = 0;
    dwBufferUsed = 0;
    dwItemCount  = 0;
    for (pMachine = MachineList; pMachine != NULL; pMachine = pMachine->next) {
        if (pMachine->szMachine != NULL) {
            dwNewBuffer = (lstrlenW(pMachine->szMachine) + 1);
            while (LocalBufferSize  < (dwBufferUsed + dwNewBuffer)) {
                TempBuffer       = LocalBuffer;
                LocalBufferSize += MEDIUM_BUFFER_SIZE;
                LocalBuffer = G_REALLOC(TempBuffer, LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                if (LocalBuffer == NULL) {
                    if (TempBuffer != NULL) G_FREE(TempBuffer);
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    goto Cleanup;
                }
            }
            dwNewBuffer = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer, pMachine->szMachine, bUnicodeDest);
            if (dwNewBuffer > 0) {
                dwBufferUsed = dwNewBuffer;
                dwItemCount ++;
            }
        }
        else {
            dwNewBuffer = 0;

        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwItemCount > 0) {
            dwBufferUsed ++;
        }
        if (pBuffer && (dwBufferUsed <= * lpdwBufferSize)) {
            RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
        }
        else {
            if (pBuffer) RtlCopyMemory(pBuffer,
                                       LocalBuffer,
                                       (* lpdwBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            pdhStatus = PDH_MORE_DATA;
        }
        * lpdwBufferSize = dwBufferUsed;
    }

Cleanup:
    if (LocalBuffer != NULL) G_FREE(LocalBuffer);
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumCachedObjects(
    PPDHI_LOG_MACHINE MachineList,
    LPCWSTR           szMachineName,
    LPVOID            pBuffer,
    LPDWORD           pcchBufferSize,
    DWORD             dwDetailLevel,
    BOOL              bUnicodeDest
)
{
    PDH_STATUS          pdhStatus        = ERROR_SUCCESS;
    DWORD               dwBufferUsed     = 0;
    DWORD               dwNewBuffer      = 0;
    DWORD               dwItemCount      = 0;
    LPVOID              LocalBuffer      = NULL;
    LPVOID              TempBuffer       = NULL;
    DWORD               LocalBufferSize  = 0;
    PPDHI_LOG_MACHINE   pMachine         = NULL;
    PPDHI_LOG_OBJECT    pObject          = NULL;
    LPWSTR              szLocMachine     = (LPWSTR) szMachineName;

    UNREFERENCED_PARAMETER(dwDetailLevel);

    LocalBufferSize = MEDIUM_BUFFER_SIZE;
    LocalBuffer     = G_ALLOC(LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    if (LocalBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    if (szLocMachine == NULL) szLocMachine = (LPWSTR) szStaticLocalMachineName;

    dwBufferUsed = 0;
    dwNewBuffer  = 0;
    dwItemCount  = 0;

    for (pMachine = MachineList; pMachine != NULL; pMachine = pMachine->next) {
        if (lstrcmpiW(pMachine->szMachine, szLocMachine) == 0) break;
    }

    if (pMachine != NULL) {
        for (pObject = pMachine->ObjList; pObject != NULL; pObject = pObject->next) {
            if (pObject->szObject != NULL) {
                dwNewBuffer = (lstrlenW(pObject->szObject) + 1);
                while (LocalBufferSize  < (dwBufferUsed + dwNewBuffer)) {
                    LocalBufferSize += MEDIUM_BUFFER_SIZE;
                    TempBuffer       = LocalBuffer;
                    LocalBuffer      = G_REALLOC(TempBuffer,
                                                 LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                    if (LocalBuffer == NULL) {
                        if (TempBuffer != NULL) G_FREE(TempBuffer);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                }
                dwNewBuffer = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer, pObject->szObject, bUnicodeDest);
                if (dwNewBuffer > 0) {
                    dwBufferUsed = dwNewBuffer;
                    dwItemCount ++;
                }
            }
            else {
                dwNewBuffer = 0;

            }
        }
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_MACHINE;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwItemCount > 0) {
            dwBufferUsed ++;
        }
        if (dwBufferUsed > 0) {
            if (pBuffer && (dwBufferUsed <= * pcchBufferSize)) {
                RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            }
            else {
                if (pBuffer) RtlCopyMemory(pBuffer,
                                           LocalBuffer,
                                           (* pcchBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                pdhStatus = PDH_MORE_DATA;
            }
        }
        * pcchBufferSize = dwBufferUsed;
    }

Cleanup:
    G_FREE(LocalBuffer);
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumCachedObjectItems(
    PPDHI_LOG_MACHINE  MachineList,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
)
{
    PDH_STATUS          pdhStatus       = ERROR_SUCCESS;
    DWORD               dwItemCount     = 0;
    LPWSTR              szFullInstance  = NULL;
    DWORD               dwFullInstance  = SMALL_BUFFER_SIZE;
    LPWSTR              szLocMachine    = (LPWSTR) szMachineName;
    PPDHI_INSTANCE      pInstance;
    PPDHI_INST_LIST     pInstList;
    PPDHI_LOG_MACHINE   pMachine        = NULL;
    PPDHI_LOG_OBJECT    pObject         = NULL;
    PPDHI_LOG_COUNTER   pCounter        = NULL;

    UNREFERENCED_PARAMETER(dwDetailLevel);
    UNREFERENCED_PARAMETER(dwFlags);

    if (szLocMachine == NULL) szLocMachine = (LPWSTR) szStaticLocalMachineName;

    for (pMachine = MachineList; pMachine != NULL; pMachine = pMachine->next) {
        if (lstrcmpiW(pMachine->szMachine, szLocMachine) == 0) break;
    }

    if (pMachine != NULL) {
        pObject = PdhiFindLogObject(pMachine, & (pMachine->ObjTable), (LPWSTR) szObjectName, FALSE);
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_MACHINE;
        pObject   = NULL;
    }

    if (pObject != NULL) {
        WCHAR szIndexNumber[20];

        szFullInstance = G_ALLOC(dwFullInstance * sizeof(WCHAR));
        if (szFullInstance == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }

        for (pCounter = pObject->CtrList; pCounter != NULL; pCounter = pCounter->next) {
            pdhStatus = PdhiFindCounterInstList(CounterTable, pCounter->szCounter, & pInstList);
            if (pdhStatus != ERROR_SUCCESS) continue;

            if (pCounter->szInstance != NULL && pCounter->szInstance[0] != L'\0') {
                if (pCounter->szParent != NULL && pCounter->szParent[0] != L'\0') {
                    swprintf(szFullInstance, L"%ws%ws%ws",
                            pCounter->szParent, L"/", pCounter->szInstance);
                }
                else {
                    lstrcpynW(szFullInstance, pCounter->szInstance, dwFullInstance);
                }
                if (pCounter->dwInstance > 0) {
                    ZeroMemory(szIndexNumber, 20 * sizeof(WCHAR));
                    _ultow(pCounter->dwInstance, szIndexNumber, 10);
                    lstrcatW(szFullInstance, L"#");
                    lstrcatW(szFullInstance, szIndexNumber);
                }
                pdhStatus = PdhiFindInstance(& pInstList->InstList, szFullInstance, TRUE, & pInstance);
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwItemCount ++;
            }
        }
    }
    else if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PDH_CSTATUS_NO_OBJECT;
    }
    if (dwItemCount > 0) {
        // then the routine was successful. Errors that occurred
        // while scanning will be ignored as long as at least
        // one entry was successfully read

        pdhStatus = ERROR_SUCCESS;
    }

Cleanup:
    G_FREE(szFullInstance);
    return pdhStatus;
}

int
PdhiComparePmLogInstance(
    PPDHI_LOG_COUNTER pCounter,
    LPWSTR            szInstance,
    DWORD             dwInstance,
    LPWSTR            szParent,
    BOOL              bUpdate
)
{
    int   iResult = 0;

    if ((pCounter->szInstance != NULL && pCounter->szInstance[0] != L'\0')
                    && (szInstance != NULL && szInstance[0] != L'\0')) {
        iResult = lstrcmpiW(szInstance, pCounter->szInstance);
    }
    else if ((pCounter->szInstance != NULL && pCounter->szInstance[0] != L'\0')
                    && (szInstance == NULL || szInstance[0] == L'\0')) {
        iResult = -1;
    }
    else if ((pCounter->szInstance == NULL || pCounter->szInstance[0] == L'\0')
                    && (szInstance != NULL && szInstance[0] != L'\0')) {
        iResult = 1;
    }
    if (iResult != 0) goto Cleanup;

    iResult = (dwInstance < pCounter->dwInstance) ? (-1) : ((dwInstance > pCounter->dwInstance) ? (1) : (0));
    if (iResult != 0) goto Cleanup;

    if ((pCounter->szParent != NULL && pCounter->szParent[0] != L'\0')
                    && (szParent != NULL && szParent[0] != L'\0')) {
        iResult = lstrcmpiW(szParent, pCounter->szParent);
    }
    else if ((pCounter->szParent != NULL && pCounter->szParent[0] != L'\0')
                    && (szParent == NULL || szParent[0] == L'\0')) {
        iResult = -1;
    }
    else if ((pCounter->szParent == NULL || pCounter->szParent[0] == L'\0')
                    && (szParent != NULL && szParent[0] != L'\0')) {
        iResult = 1;
    }

Cleanup:
    return iResult;
}

PPDHI_LOG_COUNTER
PdhiFindPmCounterInstance(
    PPDHI_LOG_OBJECT pObject,
    LPWSTR           szCounter,
    DWORD            dwCounterType,
    DWORD            dwDefaultScale,
    LPWSTR           szInstance,
    DWORD            dwInstance,
    LPWSTR           szParent,
    DWORD            dwParent,
    LPDWORD          pdwIndex,
    BOOL             bInstance,
    BOOL             bInsert
)
{
    PPDHI_LOG_COUNTER   pCounter = NULL;
    PPDHI_LOG_COUNTER   pNode    = NULL;
    PPDHI_LOG_COUNTER * pStack[MAX_BTREE_DEPTH];
    PPDHI_LOG_COUNTER * pLink;
    int                 dwStack = 0;
    PPDHI_LOG_COUNTER   pParent;
    PPDHI_LOG_COUNTER   pSibling;
    PPDHI_LOG_COUNTER   pChild;
    int                 iCompare;

    if (bInstance) {
        pStack[dwStack ++] = & (pObject->InstTable);
        pCounter = pObject->InstTable;
    }
    else {
        pStack[dwStack ++] = & (pObject->CtrTable);
        pCounter = pObject->CtrTable;
    }
    while (pCounter != NULL) {
        if (bInstance) {
            iCompare = PdhiComparePmLogInstance(pCounter, szInstance, dwInstance, szParent, bInsert);
        }
        else {
            iCompare = lstrcmpiW(szCounter, pCounter->szCounter);
        }
        if (iCompare < 0) {
            pStack[dwStack ++] = & (pCounter->left);
            pCounter           = pCounter->left;
        }
        else if (iCompare > 0) {
            pStack[dwStack ++] = & (pCounter->right);
            pCounter            = pCounter->right;
        }
        else {
            break;
        }
    }

    if (bInsert) {
        if (pCounter == NULL) {
            DWORD dwCounterLen  = lstrlenW(szCounter) + 1;
            DWORD dwInstanceLen = 0;
            DWORD dwParentLen   = 0;
            DWORD dwBufSize     = sizeof(PDHI_LOG_COUNTER) + sizeof(WCHAR) * dwCounterLen;
            if (szInstance != NULL) {
                dwInstanceLen = lstrlenW(szInstance) + 1;
                dwBufSize    += (sizeof(WCHAR) * dwInstanceLen);
            }
            else {
                dwBufSize += sizeof(WCHAR);
            }
            if (szParent != NULL) {
                dwParentLen   = lstrlenW(szParent) + 1;
                dwBufSize    += (sizeof(WCHAR) * dwParentLen);
            }
            else {
                dwBufSize += sizeof(WCHAR);
            }

            pCounter = G_ALLOC(dwBufSize);
            if (pCounter == NULL) goto Cleanup;

            if (bInstance) {
                pCounter->next    = pObject->InstList;
                pObject->InstList = pCounter;
            }
            else {
                pCounter->next    = pObject->CtrList;
                pObject->CtrList  = pCounter;
            }
            pCounter->bIsRed      = TRUE;
            pCounter->left        = NULL;
            pCounter->right       = NULL;
            pCounter->dwParent    = dwParent;
            pCounter->TimeStamp   = 0;
            pCounter->dwInstance  = dwInstance;
            pCounter->dwCounterID = (* pdwIndex);
            if (! bInstance) {
                pCounter->dwCounterType  = dwCounterType;
                pCounter->dwDefaultScale = dwDefaultScale;
            }

            if (szCounter == NULL || szCounter[0] == L'\0') {
                pCounter->szCounter = NULL;
            }
            else {
                pCounter->szCounter = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER));
                lstrcpynW(pCounter->szCounter, szCounter, dwCounterLen);
            }
            if (szInstance == NULL || szInstance[0] == L'\0') {
                pCounter->szInstance = NULL;
            }
            else {
                pCounter->szInstance = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER)
                                                                    + sizeof(WCHAR) * dwCounterLen);
                lstrcpynW(pCounter->szInstance, szInstance, dwInstanceLen);
            }

            if (szParent == NULL || szParent[0] == L'\0') {
                pCounter->szParent = NULL;
            }
            else {
                if (pCounter->szInstance != NULL) {
                    pCounter->szParent = (LPWSTR) (((PCHAR) pCounter)
                            + sizeof(PDHI_LOG_COUNTER) + sizeof(WCHAR) * (dwCounterLen + dwInstanceLen));
                }
                else {
                    pCounter->szParent = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER)
                                                                      + sizeof(WCHAR) * dwCounterLen);
                }
                lstrcpynW(pCounter->szParent, szParent, dwParentLen);
            }

            pLink   = pStack[-- dwStack];
            * pLink = pCounter;

            pChild  = NULL;
            pNode   = pCounter;
            while (dwStack > 0) {
                pLink   = pStack[-- dwStack];
                pParent = * pLink;
                if (! pParent->bIsRed) {
                    pSibling = (pParent->left == pNode) ? pParent->right : pParent->left;
                    if (pSibling && pSibling->bIsRed) {
                        pNode->bIsRed    = FALSE;
                        pSibling->bIsRed = FALSE;
                        pParent->bIsRed  = TRUE;
                    }
                    else {
                        if (pChild && pChild->bIsRed) {
                            if (pChild == pNode->left) {
                                if (pNode == pParent->left) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pNode->right;
                                    pNode->right     = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pChild->left;
                                    pChild->left     = pParent;
                                    pNode->left      = pChild->right;
                                    pChild->right    = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                            else {
                                if (pNode == pParent->right) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pNode->left;
                                    pNode->left      = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pChild->right;
                                    pChild->right    = pParent;
                                    pNode->right     = pChild->left;
                                    pChild->left     = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                        }
                        break;
                    }
                }
                pChild = pNode;
                pNode  = pParent;
            }
            if (bInstance) {
                pObject->InstTable->bIsRed = FALSE;
            }
            else {
                pObject->CtrTable->bIsRed = FALSE;
            }
        }
        else if (bInstance) {
            pCounter->dwCounterType ++;
            if (pCounter->dwCounterType > pCounter->dwDefaultScale) {
                pCounter->dwDefaultScale = pCounter->dwCounterType;
            }
        }
    }
    else if (pCounter != NULL) {
        * pdwIndex = pCounter->dwCounterID;
    }

Cleanup:
    return pCounter;
}

PDH_FUNCTION
PdhiBuildPmLogIndexTable(
    PPLAYBACKLOG pPmLog
)
{
    PDH_STATUS     Status      = ERROR_SUCCESS;
    PLOGHEADER     pLogHeader  = (PLOGHEADER) pPmLog->pHeader;
    PLOGINDEXBLOCK pIndexBlock = NULL;
    DWORD          dwOffset    = pLogHeader->iLength;
    DWORD          dwIndex     = 0;
    int            i;

    if (dwOffset == sizeof(LOGHEADER)) {
        while (dwOffset != 0) {
            pIndexBlock = (PLOGINDEXBLOCK) PointerSeek(pLogHeader, dwOffset);
            dwIndex    += pIndexBlock->iNumIndexes;
            dwOffset    = pIndexBlock->lNextBlockOffset;
        }
        pPmLog->dwLastIndex = dwIndex;
        G_FREE(pPmLog->LogIndexTable);
        pPmLog->LogIndexTable = G_ALLOC(dwIndex * sizeof(PLOGINDEX));
        if (pPmLog->LogIndexTable == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        dwIndex  = 0;
        dwOffset = pLogHeader->iLength;
        while (dwOffset != 0) {
            pIndexBlock = (PLOGINDEXBLOCK) PointerSeek(pLogHeader, dwOffset);
            for (i = 0; i < pIndexBlock->iNumIndexes; i ++) {
                pPmLog->LogIndexTable[dwIndex + i] = & (pIndexBlock->aIndexes[i]);
            }
            dwIndex    += pIndexBlock->iNumIndexes;
            dwOffset    = pIndexBlock->lNextBlockOffset;
        }
    }
    else {
        Status = PDH_INVALID_ARGUMENT;
    }

Cleanup:
    if (Status != ERROR_SUCCESS) {
        G_FREE(pPmLog->LogIndexTable);
        pPmLog->dwLastIndex    = 0;
        pPmLog->dwCurrentIndex = 0;
    }
    return Status;
}

void
PdhiFreeCounterStringNode(
    PPDHI_PM_STRING pString,
    DWORD           dwLevel
)
{
    if (pString != NULL) {
        if (pString->left != NULL) {
            PdhiFreeCounterStringNode(pString->left, dwLevel + 1);
        }
        if (pString->right != NULL) {
            PdhiFreeCounterStringNode(pString->right, dwLevel + 1);
        }
        G_FREE(pString);
    }
}

void
PdhiFreePmMachineList(
    PPLAYBACKLOG pPmLog
)
{
    PPMLOG_COUNTERNAMES pMachine = pPmLog->pFirstCounterNameTables;
    PPMLOG_COUNTERNAMES pTmpMachine;

    while (pMachine != NULL) {
        pTmpMachine = pMachine;
        pMachine    = pTmpMachine->pNext;
        PdhiFreeCounterStringNode(pTmpMachine->StringTree, 0);
        G_FREE(pTmpMachine);
    }
}

PPDHI_PM_STRING
PdhiFindPmString(
    PPMLOG_COUNTERNAMES pMachine,
    LPCWSTR             szString,
    LPDWORD             pdwIndex,
    BOOL                bInsert
)
{
    PDH_STATUS        Status   = ERROR_SUCCESS;
    PPDHI_PM_STRING * pStack[MAX_BTREE_DEPTH];
    int               iStack   = 0;
    int               iCompare = 0;
    PPDHI_PM_STRING   pString  = pMachine->StringTree;
    PPDHI_PM_STRING * pLink;
    PPDHI_PM_STRING   pNode;
    PPDHI_PM_STRING   pParent;
    PPDHI_PM_STRING   pSibling;
    PPDHI_PM_STRING   pChild;

    pStack[iStack ++] = & pMachine->StringTree;
    while (pString != NULL) {
        iCompare = lstrcmpiW(szString, pString->szString);
        if (iCompare > 0) {
            if (iStack >= MAX_BTREE_DEPTH) {
                Status = PDH_UNABLE_READ_LOG_HEADER;
                break;
            }
            pStack[iStack ++] = & (pString->right);
            pString           = pString->right;
        }
        else if (iCompare < 0) {
            if (iStack >= MAX_BTREE_DEPTH) {
                Status = PDH_UNABLE_READ_LOG_HEADER;
                break;
            }
            pStack[iStack ++] = & (pString->left);
            pString           = pString->left;
        }
        else {
            break;
        }
    }

    if (Status != ERROR_SUCCESS) goto Cleanup;

    if (pString != NULL) {
        if (pdwIndex != NULL) {
            * pdwIndex = pString->dwIndex;
        }
    }
    else if (bInsert && pdwIndex != NULL) {
        pString = G_ALLOC(sizeof(PDHI_PM_STRING));
        if (pString != NULL) {
            pString->szString  = (LPWSTR) szString;
            pString->dwIndex   = * pdwIndex;
            pString->bIsRed    = TRUE;
            pString->left      = NULL;
            pString->right     = NULL;

            pLink   = pStack[-- iStack];
            * pLink = pString;
            pNode   = pString;
            pChild  = NULL;

            while (iStack > 0) {
                pLink   = pStack[-- iStack];
                pParent = * pLink;
                if (! pParent->bIsRed) {
                    pSibling = (pParent->left == pNode) ? pParent->right : pParent->left;
                    if (pSibling && pSibling->bIsRed) {
                        pNode->bIsRed    = FALSE;
                        pSibling->bIsRed = FALSE;
                        pParent->bIsRed  = TRUE;
                    }
                    else {
                        if (pChild && pChild->bIsRed) {
                            if (pChild == pNode->left) {
                                if (pNode == pParent->left) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pNode->right;
                                    pNode->right     = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pChild->left;
                                    pChild->left     = pParent;
                                    pNode->left      = pChild->right;
                                    pChild->right    = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                            else {
                                if (pNode == pParent->right) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pNode->left;
                                    pNode->left      = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pChild->right;
                                    pChild->right    = pParent;
                                    pNode->right     = pChild->left;
                                    pChild->left     = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                        }
                        break;
                    }
                }
                pChild = pNode;
                pNode  = pParent;
            }
            pMachine->StringTree->bIsRed = FALSE;
        }
        else {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }

Cleanup:
    if (Status != ERROR_SUCCESS) SetLastError(Status);
    return pString;
}

PDH_FUNCTION
PdhiBuildPmLogStringTable(
    PPLAYBACKLOG        pPmLog,
    PLOGFILECOUNTERNAME pLogName,
    PPMLOG_COUNTERNAMES pMachine,
    long                lSize
)
{
    PDH_STATUS          Status   = ERROR_SUCCESS;
    PPDHI_PM_STRING     pString;
    LPWSTR              szName;
    DWORD               dwName;
    DWORD               dwIndex;
    long                lUsed    = 0;

    if (lSize > pLogName->lUnmatchCounterNames
                   || pLogName->lCurrentCounterNameOffset < 0
                   || pLogName->lCurrentCounterNameOffset >= pPmLog->llFileSize
                   || pLogName->lCurrentCounterNameOffset + pLogName->lUnmatchCounterNames > pPmLog->llFileSize) {
        Status = PDH_UNABLE_READ_LOG_HEADER;
    }
    else if (pLogName->lBaseCounterNameOffset > 0) {
        PLOGFILECOUNTERNAME pBaseName = (PLOGFILECOUNTERNAME)
                                        PointerSeek(pPmLog->pHeader, pLogName->lBaseCounterNameOffset);
        Status = PdhiBuildPmLogStringTable(pPmLog, pBaseName, pMachine, pLogName->lMatchLength);
    }
    if (Status != ERROR_SUCCESS) goto Cleanup;

    szName = (LPWSTR) PointerSeek(pPmLog->pHeader, pLogName->lCurrentCounterNameOffset);
    while (Status == ERROR_SUCCESS && lUsed <= lSize && szName[0] != L'\0') {
        dwIndex = wcstoul(szName, NULL, 10);
        if (dwIndex > 0 && dwIndex <= pMachine->dwLastIndex) {
            dwName  = lstrlenW(szName) + 1;
            lUsed  += (sizeof(WCHAR) * dwName);
            if (lUsed <= lSize) {
                szName += dwName;
                pMachine->szNameTable[dwIndex] = szName;
                pString = PdhiFindPmString(pMachine, szName, & dwIndex, TRUE);
                if (pString == NULL) Status = GetLastError();
            }
        }
        dwName  = lstrlenW(szName) + 1;
        lUsed  += (sizeof(WCHAR) * dwName);
        szName += dwName;
    }

Cleanup:
    return Status;
}

DWORD
PdhiLookupLogPerfIndexByName(
    PPLAYBACKLOG  pPlaybackLog,
    LPCWSTR       szMachineName,
    DWORD         dwLangId,
    DWORD         dwLastId,
    LPCWSTR       szNameBuffer
)
{
    DWORD               dwIndex  = 0;
    PDH_STATUS          Status   = PDH_CSTATUS_NO_MACHINE;
    PPMLOG_COUNTERNAMES pMachine = pPlaybackLog->pFirstCounterNameTables;

    while (pMachine != NULL) {
        if (lstrcmpiW(szMachineName, pMachine->szSystemName) == 0) break;
        pMachine = pMachine->pNext;
    }
    if (pMachine != NULL) {
        PPDHI_PM_STRING pString = PdhiFindPmString(pMachine, szNameBuffer, & dwIndex, FALSE);
        if (pString == NULL) {
            Status  = GetLastError();
            dwIndex = wcstoul(szNameBuffer, NULL, 10);
        }
    }
    if (dwIndex == 0) SetLastError(Status);
    return dwIndex;
}

LPCWSTR
PdhiLookupLogPerfNameByIndex(
    PPLAYBACKLOG  pPlaybackLog,
    LPCWSTR       szMachineName,
    DWORD         dwLangId,
    DWORD         dwIndex
)
{
    PPMLOG_COUNTERNAMES pMachine = pPlaybackLog->pFirstCounterNameTables;
    LPWSTR              szReturn = NULL;
    static WCHAR        szNumber[16];

    while (pMachine != NULL) {
        if (lstrcmpiW(szMachineName, pMachine->szSystemName) == 0) break;
        pMachine = pMachine->pNext;
    }
    if (pMachine != NULL) {
        if (dwIndex <= pMachine->dwLastIndex && dwLangId == pMachine->dwLangId) {
            szReturn = pMachine->szNameTable[dwIndex];
        }
        if (szReturn == NULL) {
            SetLastError(PDH_CSTATUS_NO_OBJECT);
            ZeroMemory(szNumber, sizeof(szNumber));
            _ltow(dwIndex, szNumber, 10);
            szReturn = szNumber;
        }
    }
    else {
        SetLastError(PDH_CSTATUS_NO_MACHINE);
    }
    return (LPCWSTR) szReturn;
}

PDH_FUNCTION
PdhiCachePerfDataBlock(
    PPLAYBACKLOG pPmLog,
    PLOGINDEX    pIndex
)
{
    PDH_STATUS               Status = ERROR_SUCCESS;
    PPERF_DATA_BLOCK         pBlock;
    PPERF_OBJECT_TYPE        pObject;
    PPERF_COUNTER_DEFINITION pCounter;
    int                      i;
    PVOID                    pEndObject;
    LPWSTR                   szMachine;
    LPWSTR                   szLogMachine    = NULL;
    LPWSTR                   szObject;
    DWORD                    dwObjects;
    PPDHI_LOG_MACHINE        pLoggedMachine  = NULL;
    PPDHI_LOG_OBJECT         pLoggedObject   = NULL;
    PPMLOG_COUNTERNAMES      pCounterTable   = NULL;

    for (i = 0; i < pIndex->iSystemsLogged; i ++) {
        if (i == 0) {
            pBlock = (PPERF_DATA_BLOCK) PointerSeek(pPmLog->pHeader, pIndex->lDataOffset);
        }
        else {
            pBlock = (PPERF_DATA_BLOCK) PointerSeek(pBlock, pBlock->TotalByteLength);
        }
        if (pBlock->TotalByteLength <= sizeof(PERF_DATA_BLOCK) || pBlock->HeaderLength <= sizeof(PERF_DATA_BLOCK)) {
            continue;
        }
        dwObjects  = pBlock->NumObjectTypes;
        pEndObject = PointerSeek(pBlock, pBlock->TotalByteLength);
        szMachine  = (LPWSTR) PointerSeek(pBlock, sizeof(PERF_DATA_BLOCK));

        G_FREE(szLogMachine);
        szLogMachine = G_ALLOC((lstrlenW(szMachine) + 3) * sizeof(WCHAR));
        if (szLogMachine == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            break;
        }
        swprintf(szLogMachine, L"\\\\%ws", szMachine);

        pLoggedMachine = PdhiFindLogMachine(& pPmLog->MachineList, szLogMachine, TRUE);
        if (pLoggedMachine == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            break;
        }

        pCounterTable = pPmLog->pFirstCounterNameTables;
        while (pCounterTable != NULL) {
            if (lstrcmpiW(pCounterTable->szSystemName, szLogMachine) == 0) break;
            pCounterTable = pCounterTable->pNext;
        }
        if (pCounterTable == NULL) continue;

        pObject = FirstObject(pBlock);
        while ((pObject != NULL) && ((PVOID) pObject < pEndObject) && (dwObjects > 0)) {
            dwObjects --;
            if (pObject->TotalByteLength > sizeof(PERF_OBJECT_TYPE)
                            && pObject->DefinitionLength > sizeof(PERF_OBJECT_TYPE)
                            && pObject->ObjectNameTitleIndex <= pCounterTable->dwLastIndex) {
                szObject = (LPWSTR) PdhiLookupLogPerfNameByIndex(pPmLog,
                                                                 szLogMachine,
                                                                 pCounterTable->dwLangId,
                                                                 pObject->ObjectNameTitleIndex);
                if (szObject != NULL) {
                    pLoggedObject = PdhiFindLogObject(pLoggedMachine,
                                                      & pLoggedMachine->ObjTable,
                                                      szObject,
                                                      TRUE);
                    if (pLoggedObject == NULL) {
                        Status = PDH_MEMORY_ALLOCATION_FAILURE;
                        break;
                    }
                    pLoggedObject->bNeedExpand = TRUE;
                    pLoggedObject->dwObject    = pObject->ObjectNameTitleIndex;
                }
            }
            pObject = (dwObjects > 0) ? NextObject(pObject) : NULL;
        }
    }

    G_FREE(szLogMachine);
    return Status;
}

PDH_FUNCTION
PdhiCachePmLogHeader(
    PPLAYBACKLOG pPmLog
)
{
    PDH_STATUS   Status           = ERROR_SUCCESS;
    PLOGINDEX  * IndexTable;
    DWORD        i;
    int          iMaxSystemLogged = -1;
    DWORD        dwIndex          = 0;

    if (pPmLog == NULL) {
        Status = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }
    else if (pPmLog->pFirstCounterNameTables != NULL && pPmLog->MachineList != NULL) {
        goto Cleanup;
    }
    IndexTable = pPmLog->LogIndexTable;
    for (i = 0; i < pPmLog->dwLastIndex; i ++) {
        // Ignore first uFlags 0x00000000 and LogFileIndexBookmark index entries.
        //
        if ((IndexTable[i]->uFlags & LogFileIndexCounterName) != 0) {
            // For LogFileIndexCounterName index entries, cache counter name/explain string table.
            if (IndexTable[i]->lDataOffset < pPmLog->llFileSize) {
                PLOGFILECOUNTERNAME pLogName = (PLOGFILECOUNTERNAME)
                                               PointerSeek(pPmLog->pHeader, IndexTable[i]->lDataOffset);
                PPMLOG_COUNTERNAMES pMachine = pPmLog->pFirstCounterNameTables;

                while (pMachine != NULL) {
                    if (lstrcmpiW(pMachine->szSystemName, pLogName->szComputer) == 0) break;
                }
                if (pMachine == NULL) {
                    pMachine = (PPMLOG_COUNTERNAMES) G_ALLOC(
                                    sizeof(PMLOG_COUNTERNAMES) + sizeof(LPWSTR) * (pLogName->dwLastCounterId + 1));
                    if (pMachine != NULL) {
                        pMachine->szSystemName = pLogName->szComputer;
                        pMachine->szNameTable  = PointerSeek(pMachine, sizeof(PMLOG_COUNTERNAMES));
                        pMachine->dwLangId     = pLogName->dwLangId;
                        pMachine->dwLastIndex  = pLogName->dwLastCounterId;
                        pMachine->pNext        = pPmLog->pFirstCounterNameTables;
                        pPmLog->pFirstCounterNameTables = pMachine;
                    }
                    else {
                        Status = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
                if (Status == ERROR_SUCCESS) {
                    Status = PdhiBuildPmLogStringTable(pPmLog, pLogName, pMachine, pLogName->lUnmatchCounterNames);
                }
            }
            else {
                Status = PDH_UNABLE_READ_LOG_HEADER;
            }
            if (Status != ERROR_SUCCESS) break;
        }
        else if ((IndexTable[i]->uFlags & LogFileIndexData) != 0) {
            // Process first LogFileIndexData block for initial machine-object cache structure.
            //
            if (IndexTable[i]->iSystemsLogged > iMaxSystemLogged) {
                iMaxSystemLogged = IndexTable[i]->iSystemsLogged;
                dwIndex          = i;
            }
        }
    }
    if (Status == ERROR_SUCCESS) {
        Status = (iMaxSystemLogged > 0) ? PdhiCachePerfDataBlock(pPmLog, IndexTable[dwIndex])
                                        : PDH_UNABLE_READ_LOG_HEADER;
    }
Cleanup:
    return Status;
}

PPERF_DATA_BLOCK
PdhiDataFromIndex(
    PPLAYBACKLOG  pPlaybackLog,
    PLOGINDEX     pLogIndex,
    LPCWSTR       lpszSystemName
)
{
    PPERF_DATA_BLOCK pPerfData;
    PPERF_DATA_BLOCK pRtnBlock            = NULL;
    LPWSTR           szLoggedComputerName = NULL;
    int       iNumSystem ;

    // Note: NULL lpszSystemName means return first logged system name
    //       at the specified index.
    pPerfData = PointerSeek(pPlaybackLog->pHeader, pLogIndex->lDataOffset);

    for (iNumSystem = 0; iNumSystem < pLogIndex->iSystemsLogged; iNumSystem ++) {
        if (pPerfData && pPerfData->Signature[0] == (WCHAR)'P' &&
                         pPerfData->Signature[1] == (WCHAR)'E' &&
                         pPerfData->Signature[2] == (WCHAR)'R' &&
                         pPerfData->Signature[3] == (WCHAR)'F') {
            szLoggedComputerName = (LPWSTR) PointerSeek(pPerfData, pPerfData->SystemNameOffset);
            if (lpszSystemName == NULL) {
                pRtnBlock = pPerfData;
                break;
            }
            else if (lstrlenW(lpszSystemName) > 2 && lpszSystemName[0] == L'\\' && lpszSystemName[1] == L'\\') {
                if (lstrcmpiW(szLoggedComputerName, & (lpszSystemName[2])) == 0) {
                    pRtnBlock = pPerfData;
                    break;
                }
            }
            else if (lstrcmpiW(szLoggedComputerName, lpszSystemName) == 0) {
                pRtnBlock = pPerfData;
                break;
            }
            pPerfData = (PPERFDATA)((PBYTE) pPerfData + pPerfData->TotalByteLength);
        }
        else {
            break;
        }
    }
    return pRtnBlock;
}

PPERF_OBJECT_TYPE
PdhiFindPerfObject(
    PPERF_DATA_BLOCK pBlock,
    DWORD            dwObject
)
{
    DWORD             dwCount = pBlock->NumObjectTypes;
    PVOID             ptrEnd  = PointerSeek(pBlock, pBlock->TotalByteLength);
    PPERF_OBJECT_TYPE pObject = FirstObject(pBlock);

    while (pObject != NULL && ((PVOID) pObject < ptrEnd) && dwCount > 0) {
        dwCount --;
        if (pObject->ObjectNameTitleIndex == dwObject) break;
        pObject = (dwCount > 0) ? NextObject(pObject) : NULL;
        if ((PVOID) pObject >= ptrEnd) pObject = NULL;
    }
    return pObject;
}

PDH_FUNCTION
PdhiCachePmLogObject(
    PPLAYBACKLOG pPmLog,
    LPWSTR       szMachineName,
    LPWSTR       szObjectName
)
{
    PDH_STATUS                Status        = ERROR_SUCCESS;
    PPMLOG_COUNTERNAMES       pCounterTable = NULL;
    PPDHI_LOG_MACHINE         pLogMachine   = PdhiFindLogMachine(& pPmLog->MachineList, szMachineName, FALSE);
    PPDHI_LOG_OBJECT          pLogObject    = NULL;
    PPDHI_LOG_COUNTER         pLogCounter   = NULL;
    PPDHI_LOG_COUNTER         pLogInst;
    PPDHI_LOG_COUNTER         pLogInstHead;
    PPERF_DATA_BLOCK          pBlock;
    PPERF_OBJECT_TYPE         pObject;
    PPERF_OBJECT_TYPE         pParentObject;
    PPERF_COUNTER_DEFINITION  pCounter;
    PPERF_INSTANCE_DEFINITION pInstance;
    PPERF_INSTANCE_DEFINITION pParentInstance;
    LPWSTR                    szCounter;
    LPWSTR                    szInstance;
    LPWSTR                    szParent;
    DWORD                     dwInstance;
    DWORD                     dwParent;
    BOOL                      bInstance     = FALSE;
    DWORD                     i;
    PVOID                     ptrEnd;
    DWORD                     dwCount;
    DWORD                     dwCounterID;

    if (pLogMachine != NULL) {
        pLogObject = PdhiFindLogObject(pLogMachine, & pLogMachine->ObjTable, szObjectName, FALSE);
    }
    if (pLogObject == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else if (pLogObject->bNeedExpand) {
        pCounterTable = pPmLog->pFirstCounterNameTables;
        while (pCounterTable != NULL) {
            if (lstrcmpiW(pCounterTable->szSystemName, szMachineName) == 0) break;
            pCounterTable = pCounterTable->pNext;
        }
        if (pCounterTable == NULL) {
            Status = PDH_INVALID_ARGUMENT;
            goto Cleanup;
        }

        for (i = 0; i < pPmLog->dwLastIndex; i ++) {
            pBlock = PdhiDataFromIndex(pPmLog, pPmLog->LogIndexTable[i], szMachineName);
            if (pBlock == NULL) continue;

            pObject = PdhiFindPerfObject(pBlock, pLogObject->dwObject);
            if (pObject == NULL) {
                continue;
            }
            else if (pObject->TotalByteLength <= sizeof(PERF_OBJECT_TYPE)
                    || pObject->DefinitionLength <= sizeof(PERF_OBJECT_TYPE)) {
                continue;
            }

            dwCount  = pObject->NumCounters;
            ptrEnd   = PointerSeek(pObject, pObject->DefinitionLength);
            pCounter = FirstCounter(pObject);
            while (pCounter != NULL && ((PVOID) pCounter < ptrEnd) && dwCount > 0) {
                dwCount --;
                szCounter = (LPWSTR) PdhiLookupLogPerfNameByIndex(pPmLog,
                                                                  szMachineName,
                                                                  pCounterTable->dwLangId,
                                                                  pCounter->CounterNameTitleIndex);
                if (szCounter != NULL) {
                    pLogCounter = PdhiFindPmCounterInstance(pLogObject,
                                                            szCounter,
                                                            pCounter->CounterType,
                                                            pCounter->DefaultScale,
                                                            NULL,
                                                            0,
                                                            NULL,
                                                            pCounter->CounterOffset,
                                                            & pCounter->CounterNameTitleIndex,
                                                            FALSE,
                                                            TRUE);
                    if (pLogCounter == NULL) {
                        Status = PDH_MEMORY_ALLOCATION_FAILURE;
                        break;
                    }
                    else if (pCounter->CounterType  & PERF_TIMER_100NS) {
                        pLogCounter->TimeBase = (LONGLONG) 10000000;
                    }
                    else if (pCounter->CounterType  & PERF_OBJECT_TIMER) {
                        // then get the time base freq from the object
                        pLogCounter->TimeBase = pObject->PerfFreq.QuadPart;
                    }
                    else { // if (pPerfCounter->CounterType & PERF_TIMER_TICK or other)
                        pLogCounter->TimeBase = pBlock->PerfFreq.QuadPart;
                    }
                }
                pCounter = NextCounter(pCounter);
                if ((PVOID) pCounter >= ptrEnd) pCounter = NULL;
            }
            if (Status != ERROR_SUCCESS) continue;

            dwCount   = pObject->NumInstances;
            bInstance = (dwCount != PERF_NO_INSTANCES) && (dwCount != 0);
            if (bInstance) {
                for (pLogCounter = pLogObject->InstList; pLogCounter != NULL; pLogCounter = pLogCounter->next) {
                    pLogCounter->dwCounterType = 0;
                }

                ptrEnd    = PointerSeek(pObject, pObject->TotalByteLength);
                pInstance = FirstInstance(pObject);
                while (pInstance != NULL && ((PVOID) pInstance < ptrEnd) && dwCount > 0) {
                    dwCount --;

                    szInstance = (pInstance->NameOffset != 0) ? (LPWSTR) PointerSeek(pInstance, pInstance->NameOffset)
                                                              : NULL;
                    dwInstance  = pInstance->UniqueID;
                    szParent    = NULL;
                    dwParent    = PERF_NO_UNIQUE_ID;
                    dwCounterID = 0;
                    if (pInstance->ParentObjectTitleIndex != 0) {
                        pParentObject = PdhiFindPerfObject(pBlock, pInstance->ParentObjectTitleIndex);
                        if (pParentObject != NULL && pParentObject->TotalByteLength > sizeof(PERF_OBJECT_TYPE)
                                                  && pParentObject->DefinitionLength > sizeof(PERF_OBJECT_TYPE)) {
                            pParentInstance = GetInstance(pParentObject, pInstance->ParentObjectInstance);
                            if (pParentInstance != NULL) {
                                szParent    = (pParentInstance->NameOffset != 0)
                                            ? (LPWSTR) PointerSeek(pParentInstance, pParentInstance->NameOffset) : NULL;
                                dwParent    = pParentInstance->UniqueID;
                                dwCounterID = 1;
                            }
                        }
                    }
                    if (PdhiFindPmCounterInstance(pLogObject, NULL, 0, 0,
                                    szInstance, dwInstance, szParent, dwParent, & dwCounterID, TRUE, TRUE) == NULL) {
                        Status = PDH_MEMORY_ALLOCATION_FAILURE;
                        break;
                    }

                    pInstance = NextInstance(pInstance);
                    if ((PVOID) pInstance >= ptrEnd) pInstance = NULL;
                }

            }

            if (pObject->NumInstances == PERF_NO_INSTANCES) break;
        }

        pLogInstHead          = pLogObject->InstList;
        pLogObject->InstList  = NULL;
        pLogObject->InstTable = NULL;
        for (pLogInst = pLogInstHead; pLogInst != NULL; pLogInst = pLogInst->next) {
            if (pLogInst->dwInstance != 0 && pLogInst->dwInstance != PERF_NO_UNIQUE_ID) {
                PdhiFindPmCounterInstance(pLogObject,
                                          NULL,
                                          0,
                                          0,
                                          pLogInst->szInstance,
                                          pLogInst->dwInstance,
                                          pLogInst->szParent,
                                          pLogInst->dwParent,
                                          & pLogInst->dwCounterID,
                                          TRUE,
                                          TRUE);
            }
            else {
                for (i = 0; i < pLogInst->dwDefaultScale; i ++) {
                    PdhiFindPmCounterInstance(pLogObject,
                                              NULL,
                                              0,
                                              0,
                                              pLogInst->szInstance,
                                              i,
                                              pLogInst->szParent,
                                              pLogInst->dwParent,
                                              & pLogInst->dwCounterID,
                                              TRUE,
                                              TRUE);
                }
            }
        }
        while (pLogInstHead != NULL) {
            pLogInst     = pLogInstHead;
            pLogInstHead = pLogInst->next;
            G_FREE(pLogInst);
        }

        pLogObject->bNeedExpand = FALSE;
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiRewindPmLog(
    PPDHI_LOG    pLog,
    PPLAYBACKLOG pPmLog
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    if (pPmLog->dwFirstIndex == 0) {
        PLOGINDEX  pIndex = NULL;
        DWORD      i;
        for (i = 0; i < pPmLog->dwLastIndex; i ++) {
            pIndex = pPmLog->LogIndexTable[i];
            if ((pIndex->uFlags & LogFileIndexData) != 0) break;
        }

        if (i < pPmLog->dwLastIndex) {
            pPmLog->dwFirstIndex = i;
        }
    }
    if (pPmLog->dwFirstIndex != pPmLog->dwCurrentIndex) {
        pLog->dwLastRecordRead = pPmLog->dwFirstIndex;
        pPmLog->dwCurrentIndex = pPmLog->dwFirstIndex;
        pLog->pLastRecordRead  = PointerSeek(pPmLog->pHeader,
                                             pPmLog->LogIndexTable[pPmLog->dwFirstIndex]->lDataOffset);
    }
    return Status;
}

PDH_FUNCTION
PdhiOpenInputPerfmonLog(
    PPDHI_LOG pLog
)
{
    PDH_STATUS   pdhStatus  = ERROR_SUCCESS;
    PPLAYBACKLOG pPmPbLog   = (PPLAYBACKLOG) pLog->pPerfmonInfo;

    pLog->StreamFile = (FILE *) ((DWORD_PTR) (-1));

    // map file as a memory array for reading

    if (pLog->hMappedLogFile != NULL && pLog->lpMappedFileBase != NULL) {
        pLog->dwLastRecordRead = 0;
        pLog->pLastRecordRead  = NULL;
        pLog->pPerfmonInfo     = G_ALLOC(sizeof(PLAYBACKLOG));
        if (pLog->pPerfmonInfo != NULL) {
            pPmPbLog   = (PPLAYBACKLOG) pLog->pPerfmonInfo;
            // assumes structure was 0-init'd on allocation
            pPmPbLog->llFileSize              = pLog->llFileSize;
            pPmPbLog->szFilePath              = pLog->szLogFileName;
            pPmPbLog->pHeader                 = pLog->lpMappedFileBase;
            pPmPbLog->iTotalTics              = 1;
            pPmPbLog->dwFirstIndex            = 0;
            pPmPbLog->MachineList             = NULL;
            pPmPbLog->pFirstCounterNameTables = NULL;
            pdhStatus = PdhiBuildPmLogIndexTable(pPmPbLog);
            if (pdhStatus == ERROR_SUCCESS) {
                pdhStatus = PdhiRewindPmLog(pLog, pPmPbLog);
            }
        }
        else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }
    else {
        // return PDH Error
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiClosePerfmonLog(
    PPDHI_LOG pLog,
    DWORD     dwFlags
)
{
    PDH_STATUS   pdhStatus    = ERROR_SUCCESS;
    PPLAYBACKLOG pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;

    DBG_UNREFERENCED_PARAMETER(dwFlags);

    if (pPlaybackLog != NULL) {
        G_FREE(pPlaybackLog->LogIndexTable);
        PdhiFreeLogMachineTable(& pPlaybackLog->MachineList);
        PdhiFreePmMachineList(pPlaybackLog);
        G_FREE(pLog->pPerfmonInfo);
        pLog->pPerfmonInfo = NULL;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetPerfmonLogCounterInfo(
    PPDHI_LOG       pLog,
    PPDHI_COUNTER   pCounter
)
{
    PDH_STATUS        pdhStatus    = PDH_LOG_FILE_OPEN_ERROR;
    PPLAYBACKLOG      pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;
    PPDHI_LOG_MACHINE pLogMachine  = NULL;
    PPDHI_LOG_OBJECT  pLogObject   = NULL;
    PPDHI_LOG_COUNTER pLogCounter  = NULL;
    PPDHI_LOG_COUNTER pLogInstance = NULL;
    DWORD             dwCounter;

    PPERF_DATA_BLOCK           pPerfData              = NULL;
    PPERF_OBJECT_TYPE          pObjectDef;
    PPERF_COUNTER_DEFINITION   pPerfCounter;
    PPERF_INSTANCE_DEFINITION  pInstanceDef;
    DWORD                      dwObjectId             = 0;
    LOGPOSITION                LogPosition;
    LOGINDEX                 * pLogIndex;
    LPWSTR                   * pCounterNames          = NULL;
    DWORD                      dwLastCounterNameIndex = 0;
    BOOL                       bObjectNumber          = FALSE;

    if (pPlaybackLog != NULL) {
        pdhStatus = PdhiCachePmLogHeader(pPlaybackLog);
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiCachePmLogObject(pPlaybackLog,
                                             pCounter->pCounterPath->szMachineName,
                                             pCounter->pCounterPath->szObjectName);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pLogMachine = PdhiFindLogMachine(& pPlaybackLog->MachineList, pCounter->pCounterPath->szMachineName, FALSE);
        pCounter->pThisRawItemList = (LPVOID) pLogMachine;
        if (pLogMachine != NULL) {
            pLogObject = PdhiFindLogObject(
                            pLogMachine, & pLogMachine->ObjTable, pCounter->pCounterPath->szObjectName, FALSE);
            pCounter->pLastRawItemList = (LPVOID) pLogObject;
            if (pLogObject == NULL) {
                pdhStatus = PDH_CSTATUS_NO_OBJECT;
            }
        }
        else {
            pdhStatus = PDH_CSTATUS_NO_MACHINE;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pLogCounter  = PdhiFindPmCounterInstance(pLogObject,
                                                 pCounter->pCounterPath->szCounterName,
                                                 0,
                                                 0,
                                                 NULL,
                                                 0,
                                                 NULL,
                                                 0,
                                                 & dwCounter,
                                                 FALSE,
                                                 FALSE);
        pCounter->pThisObject = (LPVOID) pLogCounter;
        if (pCounter->pCounterPath->szInstanceName != NULL) {
            pLogInstance = PdhiFindPmCounterInstance(pLogObject,
                                                     NULL,
                                                     0,
                                                     0,
                                                     pCounter->pCounterPath->szInstanceName,
                                                     pCounter->pCounterPath->dwIndex,
                                                     pCounter->pCounterPath->szParentName,
                                                     0,
                                                     & dwCounter,
                                                     TRUE,
                                                     FALSE);
            pCounter->pLastObject = (LPVOID) pLogInstance;
        }
    }
    if (pLogCounter != NULL) {
        if (pCounter->pCounterPath->szInstanceName != NULL) {
            if (pLogInstance == NULL) {
                pdhStatus = PDH_CSTATUS_NO_INSTANCE;
            }
        }
        pCounter->plCounterInfo.dwObjectId           = pLogObject->dwObject;
        if (pLogInstance) {
            pCounter->plCounterInfo.lInstanceId      = (pLogInstance->szInstance == NULL)
                                                     ? pLogInstance->dwInstance : PERF_NO_UNIQUE_ID;
            pCounter->plCounterInfo.dwParentObjectId = pLogInstance->dwParent;
        }
        else {
            pCounter->plCounterInfo.lInstanceId      = PERF_NO_UNIQUE_ID;
            pCounter->plCounterInfo.dwParentObjectId = PERF_NO_UNIQUE_ID;
        }
        pCounter->plCounterInfo.szInstanceName       = pCounter->pCounterPath->szInstanceName;
        pCounter->plCounterInfo.szParentInstanceName = pCounter->pCounterPath->szParentName;
        pCounter->plCounterInfo.dwCounterId          = pLogCounter->dwCounterID;
        pCounter->plCounterInfo.dwCounterType        = pLogCounter->dwCounterType;
        pCounter->plCounterInfo.dwCounterSize        = pLogCounter->dwInstance;
        pCounter->plCounterInfo.lDefaultScale        = pLogCounter->dwDefaultScale;
        pCounter->TimeBase                           = pLogCounter->TimeBase;
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_COUNTER;
    }

    return pdhStatus;    
}

PDH_FUNCTION
PdhiEnumMachinesFromPerfmonLog(
    PPDHI_LOG pLog,
    LPVOID    pBuffer,
    LPDWORD   pcchBufferSize,
    BOOL      bUnicodeDest
)
{
    PDH_STATUS   pdhStatus    = PDH_LOG_FILE_OPEN_ERROR;
    PPLAYBACKLOG pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;

    if (pPlaybackLog != NULL) {
        pdhStatus = PdhiCachePmLogHeader(pPlaybackLog);
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiEnumCachedMachines(pPlaybackLog->MachineList, pBuffer, pcchBufferSize, bUnicodeDest);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectsFromPerfmonLog(
    PPDHI_LOG pLog,
    LPCWSTR   lpszSystemName,
    LPVOID    pBuffer,
    LPDWORD   pcchBufferSize,
    DWORD     dwDetailLevel,
    BOOL      bUnicodeDest
)
{
    PDH_STATUS   pdhStatus    = PDH_LOG_FILE_OPEN_ERROR;
    PPLAYBACKLOG pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;

    if (pPlaybackLog != NULL) {
        pdhStatus = PdhiCachePmLogHeader(pPlaybackLog);
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiEnumCachedObjects(
                    pPlaybackLog->MachineList, lpszSystemName, pBuffer, pcchBufferSize, dwDetailLevel, bUnicodeDest);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectItemsFromPerfmonLog(
    PPDHI_LOG          pLog,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
)
{
    PDH_STATUS   pdhStatus    = PDH_LOG_FILE_OPEN_ERROR;
    PPLAYBACKLOG pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;

    DBG_UNREFERENCED_PARAMETER(dwFlags);
    DBG_UNREFERENCED_PARAMETER(dwDetailLevel);

    if (pPlaybackLog != NULL) {
        pdhStatus = PdhiCachePmLogHeader(pPlaybackLog);
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiCachePmLogObject(pPlaybackLog, (LPWSTR) szMachineName, (LPWSTR) szObjectName);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        PPDHI_LOG_MACHINE pMachine       = NULL;
        PPDHI_LOG_OBJECT  pObject        = NULL;
        PPDHI_LOG_COUNTER pCtr           = NULL;
        PPDHI_LOG_COUNTER pInst          = NULL;
        PPDHI_INST_LIST   pFirstInstList = NULL;
        PPDHI_INST_LIST   pInstList      = NULL;
        PPDHI_INSTANCE    pInstance      = NULL;
        LONG              nCounterCount  = 0;
        LONG              nInstanceCount = 0;

        pMachine = PdhiFindLogMachine(& pPlaybackLog->MachineList, (LPWSTR) szMachineName, FALSE);
        if (pMachine == NULL) {
            pdhStatus = PDH_CSTATUS_NO_MACHINE;
        }
        else {
            pObject = PdhiFindLogObject(pMachine, & (pMachine->ObjTable), (LPWSTR) szObjectName, FALSE);
            if (pObject == NULL) {
                pdhStatus = PDH_CSTATUS_NO_OBJECT;
            }
        }
        if (pdhStatus == ERROR_SUCCESS) {
            for (pCtr = pObject->CtrList; pCtr != NULL; pCtr = pCtr->next) {
                pdhStatus = PdhiFindCounterInstList(CounterTable, pCtr->szCounter, & pInstList);
                if (pdhStatus != ERROR_SUCCESS) {
                    continue;
                }
                else {
                    nCounterCount ++;
                    if (pFirstInstList == NULL) {
                        pFirstInstList = pInstList;
                    }
                }
            }

            if (pFirstInstList != NULL) {
                pInst = pObject->InstList;
                if (pInst != NULL && pInst != PDH_INVALID_POINTER) {
                    LPWSTR szFullInstance = G_ALLOC(SMALL_BUFFER_SIZE * sizeof(WCHAR));
                    if (szFullInstance != NULL) {
                        while (pInst != NULL) {
                            ZeroMemory(szFullInstance, SMALL_BUFFER_SIZE * sizeof(WCHAR));
                            if (pInst->szInstance != NULL) {
                                if (pInst->dwCounterID != 0) {
                                    if (pInst->szParent != NULL) {
                                        if (pInst->dwInstance != 0 && pInst->dwInstance != PERF_NO_UNIQUE_ID) {
                                            swprintf(szFullInstance, L"%ws%ws%ws#%u",
                                                    pInst->szParent, cszSlash, pInst->szInstance, pInst->dwInstance);
                                        }
                                        else {
                                            swprintf(szFullInstance, L"%ws%ws%ws",
                                                    pInst->szParent, cszSlash, pInst->szInstance);
                                        }
                                    }
                                    else {
                                        if (pInst->dwInstance != 0 && pInst->dwInstance != PERF_NO_UNIQUE_ID) {
                                            swprintf(szFullInstance, L"%u%ws%ws#%u",
                                                    pInst->dwParent, cszSlash, pInst->szInstance, pInst->dwInstance);
                                        }
                                        else {
                                            swprintf(szFullInstance, L"%u%ws%ws",
                                                    pInst->dwParent, cszSlash, pInst->szInstance);
                                        }
                                    }
                                }
                                else if (pInst->dwInstance != 0 && pInst->dwInstance != PERF_NO_UNIQUE_ID) {
                                    swprintf(szFullInstance, L"%ws#%u",
                                            pInst->szInstance, pInst->dwInstance);
                                }
                                else {
                                    lstrcpynW(szFullInstance, pInst->szInstance, SMALL_BUFFER_SIZE - 1);
                                }
                            }
                            else if (pInst->dwCounterID != 0) {
                                if (pInst->szParent != NULL) {
                                    swprintf(szFullInstance, L"%ws%ws%u",
                                            pInst->szParent, cszSlash, pInst->dwInstance);
                                }
                                else {
                                    swprintf(szFullInstance, L"%u%ws%u",
                                            pInst->dwParent, cszSlash, pInst->dwInstance);
                                }
                            }
                            else {
                                swprintf(szFullInstance, L"%u", pInst->dwInstance);
                            }

                            pdhStatus = PdhiFindInstance(& pFirstInstList->InstList, szFullInstance, TRUE, & pInstance);
                            if (pdhStatus == ERROR_SUCCESS) {
                                nInstanceCount ++;
                            }
                            pInst = pInst->next;
                        }
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
            }

            if (nCounterCount == 0 && nInstanceCount == 0) {
                if (pdhStatus == ERROR_SUCCESS) {
                    pdhStatus = PDH_CSTATUS_NO_OBJECT;
                }
            }
            else if (pdhStatus != PDH_MORE_DATA) {
                // then the routine was successful. Errors that occurred
                // while scanning will be ignored as long as at least
                // one entry was successfully read

                pdhStatus = ERROR_SUCCESS;
            }
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetMatchingPerfmonLogRecord(
    PPDHI_LOG   pLog,
    LONGLONG  * pStartTime,
    LPDWORD     pdwIndex
)
{
    PDH_STATUS       pdhStatus    = ERROR_SUCCESS;
    PPLAYBACKLOG     pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;
    DWORD            dwThisIndex  = 0;
    DWORD            dwLastIndex  = 0;
    LONGLONG         llThisTime   = 0;
    PPERF_DATA_BLOCK pPerfData;
    FILETIME         ftGMT;

    if (pPlaybackLog == NULL) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;    // log is invalid
    }
    else {
        dwLastIndex = pPlaybackLog->dwFirstIndex;
        for (dwThisIndex = pPlaybackLog->dwFirstIndex; dwThisIndex < pPlaybackLog->dwLastIndex; dwThisIndex ++) {
            pPerfData = (PPERF_DATA_BLOCK) PointerSeek(
                    pPlaybackLog->pHeader, pPlaybackLog->LogIndexTable[dwThisIndex]->lDataOffset);
            if (pPerfData != NULL) {
                SystemTimeToFileTime(& pPerfData->SystemTime, & ftGMT);
                FileTimeToLocalFileTime(& ftGMT, (FILETIME *) & llThisTime);

                if (llThisTime == * pStartTime) {
                    // record found
                    break;
                }
                else if (llThisTime > * pStartTime) {
                    // go back one
                    dwThisIndex = dwLastIndex;
                    break;
                }
                else {
                    dwLastIndex = dwThisIndex;
                    // go to the next one
                }
            }
            else {
                dwLastIndex = dwThisIndex;
                // go to the next one
            }
        }
        if (dwThisIndex == pPlaybackLog->dwLastIndex) {
            // then there's no more records in the log
            pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (pdwIndex != NULL) * pdwIndex = dwThisIndex;
        if (pLog->dwLastRecordRead != dwThisIndex) {
            pLog->dwLastRecordRead       = dwThisIndex;
            pPlaybackLog->dwCurrentIndex = dwThisIndex;
            pLog->pLastRecordRead        = PointerSeek(pPlaybackLog->pHeader,
                                                       pPlaybackLog->LogIndexTable[dwThisIndex]->lDataOffset);
        }
    }
    return pdhStatus;
}

DWORD
PdhiGetPmBaseCounterOffset(
    PPDHI_LOG_COUNTER pCounter,
    PPERF_OBJECT_TYPE pPerfObject
)
{
    DWORD dwReturn = pCounter->dwInstance;

    if (pCounter->dwInstance == 0) {
        PPERF_COUNTER_DEFINITION pPerfCounter = FirstCounter(pPerfObject);
        DWORD                    dwCounter    = pPerfObject->NumCounters;
        PVOID                    pEndGuard    = PointerSeek(pPerfObject, pPerfObject->DefinitionLength);

        while (pPerfCounter != NULL && dwCounter > 0) {
            dwCounter --;
            if (pPerfCounter->CounterNameTitleIndex == pCounter->dwCounterID) {
                pPerfCounter = NextCounter(pPerfCounter);
                if (pPerfCounter == NULL) break;
                if ((((LPVOID) pPerfCounter) < pEndGuard)
                                && ((pPerfCounter->CounterType & PERF_COUNTER_BASE) != 0)) {
                    dwReturn = pPerfCounter->CounterOffset;
                    break;
                }
            }
            if (((LPVOID) pPerfCounter) < pEndGuard) {
                pPerfCounter = NextCounter(pPerfCounter);
            }
            if (((LPVOID) pPerfCounter) >= pEndGuard) pPerfCounter = NULL;
        }
        pCounter->dwInstance = dwReturn;
    }
    return dwReturn;
}

PDH_FUNCTION
PdhiGetCounterValueFromPerfmonLog(
    PPDHI_LOG        pLog,
    DWORD            dwIndex,
    PPDHI_COUNTER    pCounter,
    PPDH_RAW_COUNTER pValue
)
{
    PDH_STATUS                pdhStatus    = ERROR_SUCCESS;
    PPLAYBACKLOG              pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;
    PLOGINDEX                 pIndex       = NULL;
    PPERF_DATA_BLOCK          pPerfData    = NULL;
    PPERF_OBJECT_TYPE         pPerfObject  = NULL;
    PPERF_INSTANCE_DEFINITION pPerfInst    = NULL;
    PPERF_COUNTER_BLOCK       pCtrBlock    = NULL;
    LPVOID                    pEndGuard;
    PPDHI_LOG_MACHINE         pLogMachine  = (PPDHI_LOG_MACHINE) pCounter->pThisRawItemList;
    PPDHI_LOG_OBJECT          pLogObject   = (PPDHI_LOG_OBJECT)  pCounter->pLastRawItemList;
    PPDHI_LOG_COUNTER         pLogCounter  = (PPDHI_LOG_COUNTER) pCounter->pThisObject;
    PPDHI_LOG_COUNTER         pLogInstance = (PPDHI_LOG_COUNTER) pCounter->pLastObject;
    BOOL                      bReturn;
    DWORD                     LocalCType;
    DWORD                   * pdwData;
    UNALIGNED LONGLONG      * pllData;
    LPVOID                    pData        = NULL;
    FILETIME                  ftGMT;

    if (pPlaybackLog == NULL) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;    // log is invalid
    }
    else if (dwIndex < pPlaybackLog->dwFirstIndex) {
        // invalid dwIndex value
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (dwIndex >= pPlaybackLog->dwLastIndex) {
        pdhStatus = PDH_NO_MORE_DATA;
    }
    else if (pLogMachine == NULL || pLogObject == NULL || pLogCounter == NULL) {
        pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
    }
    else {
        if (pLog->dwLastRecordRead != dwIndex) {
            pLog->dwLastRecordRead       = dwIndex;
            pPlaybackLog->dwCurrentIndex = dwIndex;
            pLog->pLastRecordRead        = PointerSeek(pPlaybackLog->pHeader,
                                                       pPlaybackLog->LogIndexTable[dwIndex]->lDataOffset);
        }
        pIndex = pPlaybackLog->LogIndexTable[dwIndex];
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // find a matching system...
        if (pLogMachine->pBlock != NULL && pLogMachine->dwIndex == dwIndex) {
            pPerfData = pLogMachine->pBlock;
        }
        else {
            pPerfData = PdhiDataFromIndex(pPlaybackLog, pIndex, pCounter->pCounterPath->szMachineName);
            pLogMachine->pBlock  = pPerfData;
            pLogMachine->dwIndex = dwIndex;
        }

        if (pPerfData == NULL) {
            pdhStatus            = PDH_CSTATUS_NO_MACHINE;
            pLogObject->pObjData = NULL;
            pLogObject->dwIndex  = dwIndex;
        }
        else if (pLogObject->pObjData != NULL && pLogObject->dwIndex == dwIndex) {
            pPerfObject = pLogObject->pObjData;
        }
        else {
            pEndGuard           = PointerSeek(pPerfData, pPerfData->TotalByteLength);
            pPerfObject         = PdhiFindPerfObject(pPerfData, pLogObject->dwObject);
            pLogObject->dwIndex = dwIndex;
            if (pPerfObject != NULL && ((LPVOID) pPerfObject) < pEndGuard) {
                pLogObject->pObjData = pPerfObject;
            }
            else {
                pLogObject->pObjData = NULL;
                pdhStatus            = PDH_CSTATUS_NO_OBJECT;
            }
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pEndGuard = PointerSeek(pPerfObject, pPerfObject->TotalByteLength);
        if (pPerfObject->NumInstances == PERF_NO_INSTANCES) {
            pCtrBlock = (PPERF_COUNTER_BLOCK) PointerSeek(pPerfObject, pPerfObject->DefinitionLength);
            if (pCtrBlock != NULL && ((LPVOID) pCtrBlock) < pEndGuard) {
                pData = PointerSeek(pCtrBlock, pLogCounter->dwParent);
                if (pData >= pEndGuard) pData = NULL;
            }
        }
        else if (pLogInstance != NULL) {
            if (pLogInstance->szCounter != NULL && pLogInstance->dwCounterType == dwIndex) {
                pCtrBlock = (PPERF_COUNTER_BLOCK) pLogInstance->szCounter;
            }
            else {
                if (pCounter->plCounterInfo.lInstanceId == PERF_NO_UNIQUE_ID
                                && pCounter->pCounterPath->szInstanceName != NULL) {
                    pPerfInst = GetInstanceByName(pPerfData,
                                                  pPerfObject,
                                                  pCounter->pCounterPath->szInstanceName,
                                                  pCounter->pCounterPath->szParentName,
                                                  pCounter->pCounterPath->dwIndex);
                    if (pPerfInst == NULL && pCounter->pCounterPath->szInstanceName[0] >= L'0'
                                          && pCounter->pCounterPath->szInstanceName[0] <= L'9') {
                        LONG lInstanceId = (LONG) _wtoi(pCounter->pCounterPath->szInstanceName);
                        pPerfInst        = GetInstanceByUniqueId(pPerfObject, lInstanceId);
                    }
                }
                else {
                    pPerfInst = GetInstanceByUniqueId(pPerfObject, pCounter->plCounterInfo.lInstanceId);
                }
                if (((LPVOID) pPerfInst) >= pEndGuard) pPerfInst = NULL;
                if (pPerfInst != NULL) {
                    pCtrBlock = (PPERF_COUNTER_BLOCK) PointerSeek(pPerfInst, pPerfInst->ByteLength);
                    if (((LPVOID) pCtrBlock) >= pEndGuard) pCtrBlock = NULL;
                }
                pLogInstance->szCounter     = (LPVOID) pCtrBlock;
                pLogInstance->dwCounterType = dwIndex;
            }

            if (pCtrBlock != NULL) {
                pData = PointerSeek(pCtrBlock, pLogCounter->dwParent);
                if (pData >= pEndGuard) pData = NULL;
            }
            else {
                pdhStatus = PDH_CSTATUS_NO_INSTANCE;
            }
        }
        else {
            pdhStatus = PDH_CSTATUS_NO_INSTANCE;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (pData == NULL) {
            pdhStatus = PDH_INVALID_DATA;
        }
        else {
            // assume success
            bReturn = TRUE;

            // convert system time in GMT to Local File time
            SystemTimeToFileTime(& pPerfData->SystemTime, & ftGMT);
            FileTimeToLocalFileTime(& ftGMT, & pValue->TimeStamp);

            pValue->MultiCount = 1; // unless changed

            // load counter value based on counter type
            LocalCType = pCounter->plCounterInfo.dwCounterType;
            switch (LocalCType) {
            //
            // these counter types are loaded as:
            //      Numerator = Counter data from perf data block
            //      Denominator = Perf Time from perf data block
            //      (the time base is the PerfFreq)
            //
            case PERF_COUNTER_COUNTER:
            case PERF_COUNTER_QUEUELEN_TYPE:
            case PERF_SAMPLE_COUNTER:
                pValue->FirstValue  = (LONGLONG) (* (DWORD *) pData);
                pValue->SecondValue = pPerfData->PerfTime.QuadPart;
                break;

            case PERF_OBJ_TIME_TIMER:
                pValue->FirstValue  = (LONGLONG) (* (DWORD *) pData);
                pValue->SecondValue = pPerfObject->PerfTime.QuadPart;
                break;

            case PERF_COUNTER_100NS_QUEUELEN_TYPE:
                pllData             = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue  = * pllData;
                pValue->SecondValue = pPerfData->PerfTime100nSec.QuadPart;
                break;

            case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
                pllData             = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue  = * pllData;
                pValue->SecondValue = pPerfObject->PerfTime.QuadPart;
                break;

            case PERF_COUNTER_TIMER:
            case PERF_COUNTER_TIMER_INV:
            case PERF_COUNTER_BULK_COUNT:
            case PERF_COUNTER_MULTI_TIMER:
            case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
                pllData             = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue  = * pllData;
                pValue->SecondValue = pPerfData->PerfTime.QuadPart;
                if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                    pValue->MultiCount = (DWORD) * ++ pllData;
                }
                break;
            //
            //  These counters do not use any time reference
            //
            case PERF_COUNTER_RAWCOUNT:
            case PERF_COUNTER_RAWCOUNT_HEX:
                pValue->FirstValue  = (LONGLONG) (* (DWORD *) pData);
                pValue->SecondValue = 0;
                break;

            case PERF_COUNTER_LARGE_RAWCOUNT:
            case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
                pValue->FirstValue  = * (LONGLONG *) pData;
                pValue->SecondValue = 0;
                break;
            //
            //  These counters use the 100 Ns time base in thier calculation
            //
            case PERF_100NSEC_TIMER:
            case PERF_100NSEC_TIMER_INV:
            case PERF_100NSEC_MULTI_TIMER:
            case PERF_100NSEC_MULTI_TIMER_INV:
                pllData             = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue  = * pllData;
                pValue->SecondValue = pPerfData->PerfTime100nSec.QuadPart;
                if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                    ++ pllData;
                    pValue->MultiCount = * (DWORD *) pllData;
                }
                break;
            //
            //  These counters use two data points, the one pointed to by
            //  pData and the one immediately after
            //
            case PERF_SAMPLE_FRACTION:
            case PERF_RAW_FRACTION:
                pdwData            = (DWORD *) pData;
                pValue->FirstValue = (LONGLONG) (* pdwData);
                // find the pointer to the base value in the structure
                PdhiGetPmBaseCounterOffset(pLogCounter, pPerfObject);
                if (pLogCounter->dwInstance > 0) {
                    pData               = PointerSeek(pCtrBlock, pLogCounter->dwInstance);
                    pdwData             = (DWORD *) pData;
                    pValue->SecondValue = (LONGLONG) (* pdwData);
                }
                else {
                    // unable to locate base value
                    pValue->SecondValue = 0;
                    bReturn             = FALSE;
                }
                break;

            case PERF_PRECISION_SYSTEM_TIMER:
            case PERF_PRECISION_100NS_TIMER:
            case PERF_PRECISION_OBJECT_TIMER:
                pllData            = (LONGLONG *) pData;
                pValue->FirstValue = * pllData;
                // find the pointer to the base value in the structure
                PdhiGetPmBaseCounterOffset(pLogCounter, pPerfObject);
                if (pLogCounter->dwInstance > 0) {
                    pData               = PointerSeek(pCtrBlock, pLogCounter->dwInstance);
                    pllData             = (LONGLONG *) pData;
                    pValue->SecondValue = * pllData;
                }
                else {
                    // unable to locate base value
                    pValue->SecondValue = 0;
                    bReturn             = FALSE;
                }
                break;

            case PERF_AVERAGE_TIMER:
            case PERF_AVERAGE_BULK:
                // counter (numerator) is a LONGLONG, while the
                // denominator is just a DWORD
                pllData            = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue = * pllData;
                PdhiGetPmBaseCounterOffset(pLogCounter, pPerfObject);
                if (pLogCounter->dwInstance > 0) {
                    pData               = PointerSeek(pCtrBlock, pLogCounter->dwInstance);
                    pdwData             = (DWORD *) pData;
                    pValue->SecondValue = * pdwData;
                }
                else {
                    pValue->SecondValue = 0;
                    bReturn             = FALSE;
                }
                break;
            //
            //  These counters are used as the part of another counter
            //  and as such should not be used, but in case they are
            //  they'll be handled here.
            //
            case PERF_SAMPLE_BASE:
            case PERF_AVERAGE_BASE:
            case PERF_COUNTER_MULTI_BASE:
            case PERF_RAW_BASE:
                pValue->FirstValue  = 0;
                pValue->SecondValue = 0;
                break;

            case PERF_ELAPSED_TIME:
                // this counter type needs the object perf data as well
                pValue->SecondValue = pPerfObject->PerfTime.QuadPart;
                pCounter->TimeBase  = pPerfObject->PerfFreq.QuadPart;
                pllData            = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue = *pllData;
                break;
            //
            //  These counters are not supported by this function (yet)
            //
            case PERF_COUNTER_TEXT:
            case PERF_COUNTER_NODATA:
            case PERF_COUNTER_HISTOGRAM_TYPE:
                pValue->FirstValue  = 0;
                pValue->SecondValue = 0;
                break;

            default:
                // an unidentified counter was returned so
                pValue->FirstValue  = 0;
                pValue->SecondValue = 0;
                bReturn             = FALSE;
                break;
            }
            pValue->CStatus = PDH_CSTATUS_VALID_DATA;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetTimeRangeFromPerfmonLog(
    PPDHI_LOG       pLog,
    LPDWORD         pdwNumEntries,
    PPDH_TIME_INFO  pInfo,
    LPDWORD         pdwBufferSize
)
/*++
    the first entry in the buffer returned is the total time range covered
    in the file, if there are multiple time blocks in the log file, then
    subsequent entries will identify each segment in the file.
--*/
{
    PDH_STATUS       pdhStatus     = ERROR_SUCCESS;
    PPLAYBACKLOG     pPlaybackLog  = (PLAYBACKLOG *) pLog->pPerfmonInfo;
    PDH_TIME_INFO    LocalTimeInfo = {0,0,0}; 
    PPERF_DATA_BLOCK pPerfData;
    FILETIME         ftGMT;

    if (pPlaybackLog == NULL) {
        pdhStatus = PDH_INVALID_HANDLE;    // log is invalid
    }
    else {
        pPerfData = (PPERF_DATA_BLOCK) PointerSeek(
                pPlaybackLog->pHeader, pPlaybackLog->LogIndexTable[pPlaybackLog->dwFirstIndex]->lDataOffset);
        if (pPerfData != NULL) {
            SystemTimeToFileTime(& pPerfData->SystemTime, & ftGMT);
            FileTimeToLocalFileTime(& ftGMT, (FILETIME *) & LocalTimeInfo.StartTime);
        }
        else {
            pdhStatus = PDH_NO_DATA;
        }

        pPerfData = (PPERF_DATA_BLOCK) PointerSeek(
                pPlaybackLog->pHeader, pPlaybackLog->LogIndexTable[pPlaybackLog->dwLastIndex - 1]->lDataOffset);
        if (pPerfData != NULL) {
            SystemTimeToFileTime(& pPerfData->SystemTime, & ftGMT);
            FileTimeToLocalFileTime(& ftGMT, (FILETIME *) & LocalTimeInfo.EndTime);
        }
        else {
            pdhStatus = PDH_NO_DATA;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        LocalTimeInfo.SampleCount = pPlaybackLog->dwLastIndex - pPlaybackLog->dwFirstIndex;
        if (pInfo != NULL && * pdwBufferSize >= sizeof(PDH_TIME_INFO)) {
            * pdwNumEntries = 1;
            * pInfo         = LocalTimeInfo;
            * pdwBufferSize = sizeof(PDH_TIME_INFO);
            pdhStatus       = ERROR_SUCCESS;
        }
        else {
            * pdwBufferSize = sizeof(PDH_TIME_INFO);
            pdhStatus       = PDH_MORE_DATA;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiReadRawPerfmonLogRecord(
    PPDHI_LOG             pLog,
    FILETIME            * ftRecord,
    PPDH_RAW_LOG_RECORD   pBuffer,
    LPDWORD               pdwBufferLength
)
{
    PDH_STATUS  pdhStatus = PDH_NOT_IMPLEMENTED;

    DBG_UNREFERENCED_PARAMETER(pLog);
    DBG_UNREFERENCED_PARAMETER(ftRecord);
    DBG_UNREFERENCED_PARAMETER(pBuffer);
    DBG_UNREFERENCED_PARAMETER(pdwBufferLength);

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log_pm.h ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    log_pm.h

Abstract:
    <abstract>
--*/

#ifndef _LOG_PM_H_
#define _LOG_PM_H_

#include <windows.h>
#include <winperf.h>
#include "strings.h"

// Filetimes are in 100NS units
#define FILETIMES_PER_SECOND     10000000

typedef PERF_DATA_BLOCK * PPERFDATA;

//BEGIN definitions included from PERFMON\sizes.h
#define MAX_SYSTEM_NAME_LENGTH  128
//END definitions included from PERFMON\sizes.h

#define LogFileIndexData          0x01
#define LogFileIndexBookmark      0x02
#define LogFileIndexCounterName  0x010

#define PlayingBackLog()           (PlaybackLog.iStatus == iPMStatusPlaying)
#define IsDataIndex(pIndex)        (pIndex->uFlags & LogFileIndexData)
#define IsBookmarkIndex(pIndex)    (pIndex->uFlags & LogFileIndexBookmark)
#define IsCounterNameIndex(pIndex) (pIndex->uFlags & LogFileIndexCounterName)

#define MAX_BTREE_DEPTH     40
#define PDH_INVALID_POINTER ((LPVOID) -1)

typedef struct _PDHI_LOG_MACHINE_NODE  PDHI_LOG_MACHINE,  * PPDHI_LOG_MACHINE;
typedef struct _PDHI_LOG_OBJECT_NODE   PDHI_LOG_OBJECT,   * PPDHI_LOG_OBJECT;
typedef struct _PDHI_LOG_COUNTER_NODE  PDHI_LOG_COUNTER,  * PPDHI_LOG_COUNTER;

struct _PDHI_LOG_MACHINE_NODE {
    PPDHI_LOG_MACHINE  next;
    PPDHI_LOG_OBJECT   ObjTable;
    PPDHI_LOG_OBJECT   ObjList;
    LPWSTR             szMachine;
    PPERF_DATA_BLOCK   pBlock;
    DWORD              dwIndex;
};

struct _PDHI_LOG_OBJECT_NODE {
    PPDHI_LOG_COUNTER  CtrTable;
    PPDHI_LOG_COUNTER  CtrList;
    PPDHI_LOG_COUNTER  InstTable;
    PPDHI_LOG_COUNTER  InstList;
    PPDHI_LOG_OBJECT   left;
    PPDHI_LOG_OBJECT   right;
    PPDHI_LOG_OBJECT   next;
    LPWSTR             szObject;
    PPERF_OBJECT_TYPE  pObjData;
    DWORD              dwObject;
    DWORD              dwIndex;
    BOOL               bIsRed;
    BOOL               bNeedExpand;
};

struct _PDHI_LOG_COUNTER_NODE {
    PPDHI_LOG_COUNTER  left;
    PPDHI_LOG_COUNTER  right;
    PPDHI_LOG_COUNTER  next;
    ULONGLONG          TimeStamp;
    LONGLONG           TimeBase;
    LPWSTR             szCounter;
    LPWSTR             szInstance;
    LPWSTR             szParent;
    DWORD              dwCounterID;
    DWORD              dwCounterType;
    DWORD              dwDefaultScale;
    DWORD              dwInstance;
    DWORD              dwParent;
    BOOL               bIsRed;
};

//BEGIN definitions included from PERFMON\typedefs.h
typedef struct _COUNTERTEXT {
    struct  _COUNTERTEXT * pNextTable;
    DWORD                  dwLangId;
    DWORD                  dwLastId;
    DWORD                  dwCounterSize;
    DWORD                  dwHelpSize;
    LPWSTR               * TextString;
    LPWSTR                 HelpTextString;
} COUNTERTEXT, * PCOUNTERTEXT;

typedef struct PERFSYSTEMSTRUCT {
    struct  PERFSYSTEMSTRUCT * pSystemNext;
    WCHAR                      sysName[MAX_SYSTEM_NAME_LENGTH+1];
    HKEY                       sysDataKey;
    COUNTERTEXT                CounterInfo;
    DWORD                      FailureTime;
    LPWSTR                     lpszValue;
    BOOL                       bSystemNoLongerNeeded;
    BOOL                       bSystemCounterNameSaved;
    // the following used by perf data thread
    DWORD                      dwThreadID;
    HANDLE                     hThread;
    DWORD                      StateData;
    HANDLE                     hStateDataMutex;
    HANDLE                     hPerfDataEvent;
    PPERFDATA                  pSystemPerfData;
    // mainly used by Alert to report system up/down   
    DWORD                      dwSystemState;
    // system version
    DWORD                      SysVersion;
} PERFSYSTEM, * PPERFSYSTEM, ** PPPERFSYSTEM;

//======================================//
// Log File Data Types                  //
//======================================//
#define LogFileSignatureLen      6
#define LogFileBlockMaxIndexes   100

typedef struct LOGHEADERSTRUCT { // LOGHEADER
    WCHAR  szSignature[LogFileSignatureLen];
    int    iLength;
    WORD   wVersion;
    WORD   wRevision;
    long   lBaseCounterNameOffset;
} LOGHEADER, * PLOGHEADER;

typedef struct LOGINDEXSTRUCT { // LOGINDEX
    UINT       uFlags;
    SYSTEMTIME SystemTime;
    long       lDataOffset;
    int        iSystemsLogged;
} LOGINDEX, * PLOGINDEX;

#define LogIndexSignatureLen  7
#define LogIndexSignature     L"Index "
#define LogIndexSignature1    "Perfmon Index"

typedef struct LOGFILEINDEXBLOCKSTRUCT {
    WCHAR    szSignature[LogIndexSignatureLen];
    int      iNumIndexes ;
    LOGINDEX aIndexes[LogFileBlockMaxIndexes];
    DWORD    lNextBlockOffset ;
} LOGINDEXBLOCK, * PLOGINDEXBLOCK;

typedef struct LOGPOSITIONSTRUCT {
    PLOGINDEXBLOCK pIndexBlock;
    int            iIndex;
    int            iPosition;
} LOGPOSITION, * PLOGPOSITION;

//======================================//
// Bookmark Data Type                   //
//======================================//
#define BookmarkCommentLen    256

typedef struct PDH_BOOKMARKSTRUCT {
    struct PDH_BOOKMARKSTRUCT * pBookmarkNext;
    SYSTEMTIME                  SystemTime;
    WCHAR                       szComment[BookmarkCommentLen];
    int                         iTic;
} PDH_BOOKMARK, * PPDH_BOOKMARK, ** PPPDH_BOOKMARK;

typedef struct _LOGFILECOUNTERNAME {
    WCHAR  szComputer[MAX_SYSTEM_NAME_LENGTH];
    DWORD  dwLastCounterId;
    DWORD  dwLangId;
    long   lBaseCounterNameOffset;
    long   lCurrentCounterNameOffset;
    long   lMatchLength;
    long   lUnmatchCounterNames;
} LOGFILECOUNTERNAME, * PLOGFILECOUNTERNAME, ** PPLOGFILECOUNTERNAME;

typedef struct COUNTERNAMESTRUCT {
    struct COUNTERNAMESTRUCT * pCounterNameNext;
    LOGFILECOUNTERNAME         CounterName;
    LPWSTR                     pRemainNames;
} LOGCOUNTERNAME, * PLOGCOUNTERNAME;

typedef struct _PDHI_PM_STRING PDHI_PM_STRING, * PPDHI_PM_STRING;
struct _PDHI_PM_STRING {
    PPDHI_PM_STRING left;
    PPDHI_PM_STRING right;
    LPWSTR          szString;
    DWORD           dwIndex;
    BOOL            bIsRed;
};

typedef struct _PMLOG_COUNTERNAMES PMLOG_COUNTERNAMES, * PPMLOG_COUNTERNAMES;
struct _PMLOG_COUNTERNAMES {
    PPMLOG_COUNTERNAMES   pNext;
    LPWSTR                szSystemName;
    LPWSTR              * szNameTable;
    PPDHI_PM_STRING       StringTree;
    DWORD                 dwLangId;
    DWORD                 dwLastIndex;
};

typedef struct PLAYBACKLOGSTRUCT {
    LONGLONG            llFileSize;
    LPWSTR              szFilePath;
    PLOGHEADER          pHeader;
    PPMLOG_COUNTERNAMES pFirstCounterNameTables;
    PPDHI_LOG_MACHINE   MachineList;
    PLOGINDEX         * LogIndexTable;
    DWORD               dwFirstIndex;
    DWORD               dwLastIndex;
    DWORD               dwCurrentIndex;

    int                 iTotalTics;
    int                 iSelectedTics;
    LOGPOSITION         BeginIndexPos;
    LOGPOSITION         EndIndexPos;
    LOGPOSITION         StartIndexPos;
    LOGPOSITION         StopIndexPos;
    LOGPOSITION         LastIndexPos; // pos of last index read
    PPDH_BOOKMARK       pBookmarkFirst;
    LPWSTR              pBaseCounterNames;
    long                lBaseCounterNameSize;
    long                lBaseCounterNameOffset;
    PLOGCOUNTERNAME     pLogCounterNameFirst;
} PLAYBACKLOG, * PPLAYBACKLOG;

PDH_FUNCTION
PdhiOpenInputPerfmonLog(
    PPDHI_LOG pLog
);

PDH_FUNCTION
PdhiClosePerfmonLog(
    PPDHI_LOG pLog,
    DWORD     dwFlags
);

PDH_FUNCTION
PdhiGetPerfmonLogCounterInfo(
    PPDHI_LOG     pLog,
    PPDHI_COUNTER pCounter
);

PDH_FUNCTION
PdhiEnumMachinesFromPerfmonLog(
    PPDHI_LOG pLog,
    LPVOID    pBuffer,
    LPDWORD   lpdwBufferSize,
    BOOL      bUnicodeDest
);

PDH_FUNCTION
PdhiEnumObjectsFromPerfmonLog(
    PPDHI_LOG pLog,
    LPCWSTR   szMachineName,
    LPVOID    mszObjectList,
    LPDWORD   pcchBufferSize,
    DWORD     dwDetailLevel,
    BOOL      bUnicode
);

PDH_FUNCTION
PdhiEnumObjectItemsFromPerfmonLog(
    PPDHI_LOG          hDataSource,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
);

PDH_FUNCTION
PdhiGetMatchingPerfmonLogRecord(
    PPDHI_LOG   pLog,
    LONGLONG  * pStartTime,
    LPDWORD     pdwIndex
);

PDH_FUNCTION
PdhiGetCounterValueFromPerfmonLog(
    PPDHI_LOG        hLog,
    DWORD            dwIndex,
    PPDHI_COUNTER    pCounter,
    PPDH_RAW_COUNTER pValue
);

PDH_FUNCTION
PdhiGetTimeRangeFromPerfmonLog(
    PPDHI_LOG       hLog,
    LPDWORD         pdwNumEntries,
    PPDH_TIME_INFO  pInfo,
    LPDWORD         dwBufferSize
);

PDH_FUNCTION
PdhiReadRawPerfmonLogRecord(
    PPDHI_LOG             pLog,
    FILETIME            * ftRecord,
    PPDH_RAW_LOG_RECORD   pBuffer,
    LPDWORD               pdwBufferLength
);

#endif   // _LOG_PM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log_wmi.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    log_wmi.c

Abstract:

    <abstract>

--*/

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <pdh.h>
#include "pdhidef.h"
#include "perfdata.h"
#include "log_bin.h"
#include "log_wmi.h"
#include "strings.h"
#include "pdhmsg.h"
#pragma warning ( disable : 4201 )
#include <initguid.h>
#include <wmistr.h>
#include <ntwmi.h>
#pragma warning ( default : 4201 )

GUID PdhTransactionGuid = // 933f3bb3-943e-490d-9ced-3cbb14c14479
{ 0x933f3bb3, 0x943e, 0x490d, 0x9c, 0xed, 0x3c, 0xbb, 0x14, 0xc1, 0x44, 0x79 };

PDHI_BINARY_LOG_RECORD_HEADER PdhNullCounterHeader = {
        BINLOG_TYPE_DATA_PSEUDO, 48 };
PDH_RAW_COUNTER PdhNullCounter = {
        0,          // CStatus
        { 0, 0 },   // TimeStamp
        0,          // FirstValue
        0,          // SecondValue
        0           // MultiCount
};

#define PDH_MAX_LOGFILES               32
#define PDH_MAX_PATH                 1024
#define PDH_BLOCK_BUFFER_SIZE        8000
#define PDH_WMI_BUFFER_SIZE          64
#define PDH_WMI_BUFFER_SIZE_BYTE     64 * 1024

#define PDH_LOG_HEADER_EVENT         0x20
#define PDH_LOG_DATA_BLOCK_EVENT     0x22
#define PDH_LOG_CATALOG_LIST_EVENT   0x23
#define PDH_LOG_COUNTER_STRING_EVENT 0x24
#define PDH_EVENT_VERSION              60
#define PDH_WMI_MAX_BUFFERS           512
#define PDH_WMI_DEFAULT_BUFFERS        32
#define PDH_WMI_BUFFER_INCREMENT       16

#define PDH_RESOURCE_NAME L"MofResource"

#define TIME_DELTA                 100000

TRACEHANDLE PdhTraceRegistrationHandle = (TRACEHANDLE) 0;

// For PDH WMI event trace logfile output
//
typedef struct _PDH_WMI_LOG_INFO {
    DWORD       dwLogVersion;       // version stamp
    DWORD       dwFlags;            // option flags
} PDH_WMI_LOG_INFO, *PPDH_WMI_LOG_INFO;

typedef struct _PDH_EVENT_TRACE_PROPERTIES {
    EVENT_TRACE_PROPERTIES LoggerInfo;
    WCHAR                  LoggerName[PDH_MAX_PATH];
    WCHAR                  LogFileName[PDH_MAX_PATH];
    GUID                   LogFileGuid;
    LONGLONG               TimeStamp;
    LPWSTR                 MachineList;
    DWORD                  MachineListSize;
    BOOLEAN                bHeaderEvent;
} PDH_EVENT_TRACE_PROPERTIES, * PPDH_EVENT_TRACE_PROPERTIES;

typedef struct _PDH_WMI_EVENT_TRACE {
    EVENT_TRACE_HEADER EventHeader;
    MOF_FIELD          MofFields[4];
} PDH_WMI_EVENT_TRACE, * PPDH_WMI_EVENT_TRACE;

// For PDH WMI event trace logfile input
//
typedef enum _PDH_PROCESS_TRACE_STATE {
    PdhProcessTraceNormal,
    PdhProcessTraceRewind,
    PdhProcessTraceComplete,
    PdhProcessTraceEnd,
    PdhProcessTraceExit
} PDH_PROCESS_TRACE_STATE;

typedef struct _PDH_WMI_PERF_MACHINE {
    LIST_ENTRY Entry;
    LIST_ENTRY  LogObjectList;
    LPWSTR     pszBuffer;
    DWORD      dwLastId;
    DWORD      dwBufSize;
    LPWSTR   * ptrStrAry;
} PDH_WMI_PERF_MACHINE, * PPDH_WMI_PERF_MACHINE;

typedef struct _PDH_WMI_PERF_OBJECT {
    LIST_ENTRY       Entry;
    DWORD            dwObjectId;
    LPWSTR           szObjectName;
    PVOID            ptrBuffer;
} PDH_WMI_PERF_OBJECT, * PPDH_WMI_PERF_OBJECT;

typedef struct _PDH_COUNTER_PATH {
    LIST_ENTRY  Entry;
    ULONGLONG   TimeStamp;
    PVOID       CounterPathBuffer;
    ULONG       CounterPathSize;
    ULONG       CounterCount;
} PDH_COUNTER_PATH, * PPDH_COUNTER_PATH;

typedef struct _PDH_WMI_LOGFILE_INFO {
    GUID        LogFileGuid;
    LIST_ENTRY  CounterPathList;
    LIST_ENTRY  PerfMachineList;
    ULONGLONG   TimeStart;
    ULONGLONG   TimeEnd;
    ULONGLONG   TimeFreq;
    ULONGLONG   TimePrev;
    PVOID       DataBlock;
    ULONG       ValidEntries;
    ULONG       DataBlockSize;
    ULONG       DataBlockAlloc;
    ULONG       ulNumDataBlocks;
    ULONG       ulDataBlocksCopied;
    ULONG       ulCounters;
} PDH_WMI_LOGFILE_INFO, * PPDH_WMI_LOGFILE_INFO;

typedef struct _PDH_LOGGER_CONTEXT {
    PDH_WMI_LOGFILE_INFO    LogInfo[PDH_MAX_LOGFILES];
    TRACEHANDLE             LogFileHandle[PDH_MAX_LOGFILES];
    LPWSTR                  LogFileName[PDH_MAX_LOGFILES];
    ULONGLONG               TimeFreq;
    HANDLE                  hThreadWork;
    HANDLE                  hSyncPDH;
    HANDLE                  hSyncWMI;
    PVOID                   CounterPathBuffer;
    PVOID                   tmpBuffer;
    PDH_PROCESS_TRACE_STATE LoggerState;
    ULONG                   LogFileCount;
    ULONG                   LoggerCount;
    ULONG                   RefCount;
    DWORD                   dwThread;
    BOOLEAN                 bCounterPathChanged;
    BOOLEAN                 bFirstDataBlockRead;
    BOOLEAN                 bDataBlockProcessed;
    BOOLEAN                 bFirstRun;
} PDH_LOGGER_CONTEXT, * PPDH_LOGGER_CONTEXT;

PPDH_LOGGER_CONTEXT ContextTable[PDH_MAX_LOGFILES];
DWORD               ContextCount = 0;
HANDLE              hPdhContextMutex;

typedef struct _PDH_DATA_BLOCK_TRANSFER {
    ULONGLONG  CurrentTime;
    PVOID      pRecord;
    DWORD      dwCurrentSize;
    PDH_STATUS Status;
} PDH_DATA_BLOCK_TRANSFER, * PPDH_DATA_BLOCK_TRANSFER;

PDH_DATA_BLOCK_TRANSFER DataBlockInfo = { 0, NULL, 0, ERROR_SUCCESS };

void
GuidToString(PWCHAR s, LPGUID piid)
{
    swprintf(s, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
             piid->Data1,
             piid->Data2,
             piid->Data3,
             piid->Data4[0],
             piid->Data4[1],
             piid->Data4[2],
             piid->Data4[3],
             piid->Data4[4],
             piid->Data4[5],
             piid->Data4[6],
             piid->Data4[7]);
}

PPDH_LOGGER_CONTEXT
PdhWmiGetCurrentContext(
    IN DWORD dwLine)
{
    PPDH_LOGGER_CONTEXT CurrentContext = NULL;
    DWORD               dwThread       = GetCurrentThreadId();
    DWORD               i;

    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex) == ERROR_SUCCESS) {
        for (i = 0; i < ContextCount; i ++) {
            if (ContextTable[i]->dwThread == dwThread) {
                CurrentContext = ContextTable[i];
                break;
            }
        }
        RELEASE_MUTEX(hPdhContextMutex);
    }

    return CurrentContext;
}

DWORD
PdhWmiGetLoggerContext(
    IN DWORD               dwLine,
    IN PPDH_LOGGER_CONTEXT pLoggerContext)
{
    DWORD i = ContextCount;

    if (pLoggerContext != NULL) {
        if (WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex) == ERROR_SUCCESS) {
            for (i = 0; i < ContextCount; i ++) {
                if (ContextTable[i] == pLoggerContext) {
                    break;
                }
            }
            RELEASE_MUTEX(hPdhContextMutex);
        }
    }

    return i;
}

#define GetCurrentContext() PdhWmiGetCurrentContext(__LINE__)
#define GetLoggerContext(X) PdhWmiGetLoggerContext(__LINE__,X)

#if 0
PDH_FUNCTION
PdhiBuildEmptyBlock(
    IN  PPDHI_LOG   pLog,
    IN  LONGLONG    TimeStamp,
    OUT ULONG     * lenMofData,
    OUT PVOID     * ptrMofData)
{
    PDH_STATUS     pdhStatus    = ERROR_SUCCESS;
    PPDHI_COUNTER  pThisCounter;

    PPDHI_BINARY_LOG_RECORD_HEADER pLogCounterBuffer = NULL;
    PPDHI_BINARY_LOG_RECORD_HEADER pThisLogCounter   = NULL;
    PPDH_RAW_COUNTER               pSingleCounter;
    PPDHI_RAW_COUNTER_ITEM_BLOCK   pMultiCounter;
    PPERF_DATA_BLOCK               pObjectCounter;
    DWORD                          dwBufSize         = 0;

    if (pLog->pQuery == NULL || pLog->pQuery->pCounterListHead == NULL) {
        pdhStatus = PDH_NO_DATA;
        goto Cleanup;
    }

    pThisCounter = pLog->pQuery->pCounterListHead;
    do {

        DWORD   dwType  = (pThisCounter->dwFlags & PDHIC_COUNTER_OBJECT)
                        ? (PDHIC_COUNTER_OBJECT)
                        : (  (pThisCounter->dwFlags & PDHIC_MULTI_INSTANCE)
                           ? (PDHIC_MULTI_INSTANCE) : (0));
        DWORD   dwCtrBufSize = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
        DWORD   dwNewSize;
        int     nItem;

        switch (dwType) {
        case PDHIC_MULTI_INSTANCE:
            dwCtrBufSize += sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK);
            break;

        case PDHIC_COUNTER_OBJECT:
            dwCtrBufSize += sizeof(PERF_DATA_BLOCK);
            break;

        default:
            dwCtrBufSize += sizeof(PDH_RAW_COUNTER);
            break;
        }

        if (pLogCounterBuffer == NULL) {
            dwBufSize = (dwCtrBufSize + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            pLogCounterBuffer = G_ALLOC(dwBufSize);

            if (pLogCounterBuffer == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            }
            pThisLogCounter = (PPDHI_BINARY_LOG_RECORD_HEADER)
                              (  ((PUCHAR) pLogCounterBuffer)
                               + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
        }
        else {
            PPDHI_BINARY_LOG_RECORD_HEADER ptrTemp = pLogCounterBuffer;
            dwNewSize         = (dwBufSize + dwCtrBufSize);
            pLogCounterBuffer = G_REALLOC(ptrTemp, dwNewSize);
            if (pLogCounterBuffer == NULL) {
                G_FREE(ptrTemp);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            }
            pThisLogCounter   = (PPDHI_BINARY_LOG_RECORD_HEADER)
                                ((LPBYTE) pLogCounterBuffer + dwBufSize);
            dwBufSize        += (USHORT) dwCtrBufSize;
        }

        assert (dwCtrBufSize < 0x00010000);
        pThisLogCounter->dwLength = LOWORD(dwCtrBufSize);

        if (dwType == PDHIC_COUNTER_OBJECT) {
            FILETIME tmpFileTime;
            pThisLogCounter->dwType = BINLOG_TYPE_DATA_LOC_OBJECT;
            pObjectCounter = (PPERF_DATA_BLOCK)
                             ((LPBYTE) pThisLogCounter +
                                       sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            pObjectCounter->Signature[0]     = L'P';
            pObjectCounter->Signature[1]     = L'E';
            pObjectCounter->Signature[2]     = L'R';
            pObjectCounter->Signature[3]     = L'F';
            pObjectCounter->LittleEndian     = TRUE;
            pObjectCounter->Version          = PERF_DATA_VERSION;
            pObjectCounter->Revision         = PERF_DATA_REVISION;
            pObjectCounter->TotalByteLength  = sizeof(PERF_DATA_BLOCK);
            pObjectCounter->NumObjectTypes   = 1;
            pObjectCounter->DefaultObject    = pThisCounter->plCounterInfo.dwObjectId;
            pObjectCounter->SystemNameLength = 0;
            pObjectCounter->SystemNameOffset = 0;
            pObjectCounter->HeaderLength     = sizeof(PERF_DATA_BLOCK);

            pObjectCounter->PerfTime.QuadPart         = 0;
            pObjectCounter->PerfFreq.QuadPart         = 0;
            pObjectCounter->PerfTime100nSec.QuadPart  = 0;

            tmpFileTime.dwLowDateTime  = LODWORD(TimeStamp);
            tmpFileTime.dwHighDateTime = HIDWORD(TimeStamp);
            FileTimeToSystemTime(& tmpFileTime, & pObjectCounter->SystemTime);
        }
        else if (dwType == PDHIC_MULTI_INSTANCE) {
            pThisLogCounter->dwType = BINLOG_TYPE_DATA_MULTI;
            pMultiCounter = (PPDHI_RAW_COUNTER_ITEM_BLOCK)
                            ((LPBYTE) pThisLogCounter +
                                      sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            ZeroMemory(pMultiCounter, sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK));
            pMultiCounter->CStatus   = ERROR_SUCCESS;
            pMultiCounter->TimeStamp.dwLowDateTime  = LODWORD(TimeStamp);
            pMultiCounter->TimeStamp.dwHighDateTime = HIDWORD(TimeStamp);
        }
        else {
            pThisLogCounter->dwType = BINLOG_TYPE_DATA_SINGLE;
            pSingleCounter = (PPDH_RAW_COUNTER)
                             ((LPBYTE) pThisLogCounter +
                                       sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            ZeroMemory(pSingleCounter, sizeof(PDH_RAW_COUNTER));
            pSingleCounter->CStatus   = ERROR_SUCCESS;
            pSingleCounter->TimeStamp.dwLowDateTime  = LODWORD(TimeStamp);
            pSingleCounter->TimeStamp.dwHighDateTime = HIDWORD(TimeStamp);
        }

        pThisCounter = pThisCounter->next.flink; // go to next in list

    } while (pThisCounter != pLog->pQuery->pCounterListHead);

    if (pLogCounterBuffer) {
        pLogCounterBuffer->dwType   = BINLOG_TYPE_DATA;
        pLogCounterBuffer->dwLength = dwBufSize;
    }

Cleanup:
    * lenMofData = dwBufSize;
    * ptrMofData = pLogCounterBuffer;
    return pdhStatus;
}
#endif

PDH_FUNCTION
PdhWmiTraceEvent(
    IN PPDHI_LOG pLog,
    IN ULONG     PdhEventType,
    IN ULONGLONG TimeStamp,
    IN ULONG     lenMofData,
    IN PVOID     ptrMofData);

PDH_FUNCTION
PdhiBuildPerfCounterList(
    IN  PPDHI_LOG  pLog,
    IN  PPDH_EVENT_TRACE_PROPERTIES LoggerInfo,
    IN  PPDHI_COUNTER               pCounter)
{
    PDH_STATUS      Status    = ERROR_SUCCESS;
    PPERF_MACHINE   pMachine  = pCounter->pQMachine->pMachine;
    LPWSTR        * pString   = pMachine->szPerfStrings;
    BYTE          * pType     = pMachine->typePerfStrings;
    DWORD           dwLastId  = pMachine->dwLastPerfString;
    DWORD           i;
    DWORD           dwBufSize = 0;
    LPWSTR          pszBuffer = NULL;
    LPWSTR          pszCurrent;
    BOOLEAN         bNewEvent = TRUE;

    if (LoggerInfo->MachineList != NULL) {
        pszCurrent = LoggerInfo->MachineList;
        while (* pszCurrent != L'\0') {
            if (lstrcmpiW(pszCurrent, pMachine->szName) == 0) {
                // Machine Perf Counter List already there, bail out.
                //
                goto Cleanup;
            }
            pszCurrent += (lstrlenW(pszCurrent) + 1);
        }
    }

    if (LoggerInfo->MachineList != NULL) {
        LPWSTR pszTemp = LoggerInfo->MachineList;
        LoggerInfo->MachineList = G_REALLOC( pszTemp,
                sizeof(WCHAR) * (LoggerInfo->MachineListSize + (lstrlenW(pMachine->szName) + 1)));
        if (LoggerInfo->MachineList != NULL) {
            pszCurrent = LoggerInfo->MachineList
                       + (LoggerInfo->MachineListSize - 1);
            LoggerInfo->MachineListSize += (lstrlenW(pMachine->szName) + 1);
        }
        else {
            G_FREE(pszTemp);
        }
    }
    else {
        LoggerInfo->MachineListSize = (lstrlenW(pMachine->szName) + 2);
        LoggerInfo->MachineList =
                        G_ALLOC(sizeof(WCHAR) * LoggerInfo->MachineListSize);
        if (LoggerInfo->MachineList != NULL) {
            pszCurrent = LoggerInfo->MachineList;
        }
    }
    if (LoggerInfo->MachineList == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    lstrcpyW(pszCurrent, pMachine->szName);

    dwBufSize = sizeof(WCHAR) * (lstrlenW(pMachine->szName) + 1);
    pszBuffer = (LPWSTR) G_ALLOC(PDH_BLOCK_BUFFER_SIZE);
    if (pszBuffer == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    __try {
        WCHAR szIndex[10];
        DWORD dwNewSize = 0;

        for (i = 0; i < dwLastId; i ++) {

            if (pString[i] == NULL || pType[i] != STR_COUNTER) continue;
            ZeroMemory(szIndex, sizeof(WCHAR) * 10);
            _ltow(i, szIndex, 10);
            dwNewSize = sizeof(WCHAR) * (  lstrlenW(szIndex) + 1
                                        + lstrlenW(pString[i]) + 1);

            if (dwBufSize + dwNewSize >= PDH_BLOCK_BUFFER_SIZE) {
                Status = PdhWmiTraceEvent(pLog,
                                          PDH_LOG_COUNTER_STRING_EVENT,
                                          LoggerInfo->TimeStamp - 1,
                                          dwBufSize,
                                          pszBuffer);
                bNewEvent = TRUE;
            }
            if (bNewEvent) {
                ZeroMemory(pszBuffer, PDH_BLOCK_BUFFER_SIZE);
                lstrcpyW(pszBuffer, pMachine->szName);
                pszCurrent  = pszBuffer + (lstrlenW(pszBuffer) + 1);
                dwBufSize   = sizeof(WCHAR) * (lstrlenW(pMachine->szName) + 1);
                bNewEvent   = FALSE;
            }
            lstrcpyW(pszCurrent, szIndex);
            pszCurrent += (lstrlenW(pszCurrent) + 1);
            lstrcpyW(pszCurrent, pString[i]);
            pszCurrent += (lstrlenW(pszCurrent) + 1);
            dwBufSize  += dwNewSize;
        }
        Status = PdhWmiTraceEvent(pLog,
                                  PDH_LOG_COUNTER_STRING_EVENT,
                                  LoggerInfo->TimeStamp - 1,
                                  dwBufSize,
                                  pszBuffer);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

Cleanup:
    if (pszBuffer != NULL) {
        G_FREE(pszBuffer);
    }
    return Status;
}

PDH_FUNCTION
PdhiBuildLogHeaderBlock(
    IN  PPDHI_LOG   pLog,
    IN  PPDH_EVENT_TRACE_PROPERTIES LoggerInfo)
{
    PDH_STATUS         Status       = ERROR_SUCCESS;
    PVOID              ptrOutBuffer = NULL;
    PVOID              ptrTemp;
    PPDH_WMI_LOG_INFO  pLogInfo     = NULL;
    DWORD              SizeAlloc    = sizeof(PDH_WMI_LOG_INFO);
    DWORD              NewSizeAlloc;

    PPDHI_COUNTER          pThisCounter;
    PPDHI_COUNTER          pThisCounterHead;
    DWORD                  dwPathBufSize;
    PPDHI_LOG_COUNTER_PATH pLogCounter;
    LONG                   lBufOffset;
    PWCHAR                 pBufferBase;

    ptrOutBuffer = G_ALLOC(sizeof(PDH_WMI_LOG_INFO));
    if (ptrOutBuffer == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    pLogInfo = (PPDH_WMI_LOG_INFO) ptrOutBuffer;
    pLogInfo->dwLogVersion = WMILOG_VERSION;
    pLogInfo->dwFlags      = pLog->dwLogFormat;

    pThisCounter = pThisCounterHead = (pLog->pQuery)
                                    ? (pLog->pQuery->pCounterListHead)
                                    : (NULL);
    if (pThisCounter != NULL) {
        do {
            dwPathBufSize = sizeof(PDHI_LOG_COUNTER_PATH) + sizeof(DWORD);
            if (pThisCounter->pCounterPath->szMachineName != NULL) {
                dwPathBufSize += sizeof(WCHAR) * (1 +
                        lstrlenW(pThisCounter->pCounterPath->szMachineName));
            }
            if (pThisCounter->pCounterPath->szObjectName != NULL) {
                dwPathBufSize += sizeof(WCHAR) * (1 +
                        lstrlenW(pThisCounter->pCounterPath->szObjectName));
            }
            if (pThisCounter->dwFlags & PDHIC_COUNTER_OBJECT) {
                Status = PdhiBuildPerfCounterList(
                                 pLog, LoggerInfo, pThisCounter);
                if (Status != ERROR_SUCCESS) {
                    goto Cleanup;
                }
            }
            if (pThisCounter->pCounterPath->szInstanceName != NULL) {
                dwPathBufSize += sizeof(WCHAR) * (1 +
                    lstrlenW(pThisCounter->pCounterPath->szInstanceName));
            }
            if (pThisCounter->pCounterPath->szParentName != NULL) {
                dwPathBufSize += sizeof(WCHAR) * (1 +
                    lstrlenW(pThisCounter->pCounterPath->szParentName));
            }
            if (pThisCounter->pCounterPath->szCounterName != NULL) {
                dwPathBufSize += sizeof(WCHAR) * (1 +
                    lstrlenW(pThisCounter->pCounterPath->szCounterName));
            }
            dwPathBufSize = QWORD_MULTIPLE(dwPathBufSize);

            NewSizeAlloc  = SizeAlloc + dwPathBufSize;
            ptrTemp       = ptrOutBuffer;
            ptrOutBuffer  = G_REALLOC(ptrTemp, NewSizeAlloc);
            if (ptrOutBuffer == NULL) {
                G_FREE(ptrTemp);
                Status = PDH_MEMORY_ALLOCATION_FAILURE;
                goto Cleanup;
            }
            pLogCounter   = (PPDHI_LOG_COUNTER_PATH)
                            (((LPBYTE) ptrOutBuffer) + SizeAlloc);
            SizeAlloc     = NewSizeAlloc;

            RtlZeroMemory(pLogCounter, dwPathBufSize);
            pLogCounter->dwLength      = dwPathBufSize;
            pLogCounter->dwFlags       = pThisCounter->dwFlags;
            pLogCounter->dwUserData    = pThisCounter->dwUserData;
            if (pThisCounter->dwFlags & PDHIC_COUNTER_OBJECT) {
                pLogCounter->dwCounterType = PDHIC_COUNTER_OBJECT;
                pLogCounter->lDefaultScale = 0;
                pLogCounter->dwIndex       = 0;
            }
            else {
                pLogCounter->dwCounterType =
                                pThisCounter->plCounterInfo.dwCounterType;
                pLogCounter->lDefaultScale =
                                pThisCounter->plCounterInfo.lDefaultScale;
                pLogCounter->dwIndex       =
                                pThisCounter->pCounterPath->dwIndex;
            }
            pLogCounter->llTimeBase    = pThisCounter->TimeBase;

            // if this is a wild card path, then move the strings up
            // 1 dword in the buffer allowing the first DWORD of the
            // the buffer to contain the offset into the catalog
            // of the instances found in this log file. This list
            // will be built after the log is closed.

            lBufOffset = 0; // in WORDS (not bytes)
            if (pThisCounter->pCounterPath->szInstanceName != NULL) {
                if (* pThisCounter->pCounterPath->szInstanceName == SPLAT_L) {
                    lBufOffset = sizeof(DWORD);
                }
            }
#if DBG
            if (lBufOffset > 0)
                * (LPDWORD) (& pLogCounter->Buffer[0]) = 0x12345678;
#endif

            if (pThisCounter->pCounterPath->szMachineName != NULL) {
                pLogCounter->lMachineNameOffset = lBufOffset;
                pBufferBase = (PWCHAR)
                        ((LPBYTE) & pLogCounter->Buffer[0] + lBufOffset);
                lstrcpyW(pBufferBase,
                         pThisCounter->pCounterPath->szMachineName);
                lBufOffset += sizeof(WCHAR) * (1 +
                        lstrlenW(pThisCounter->pCounterPath->szMachineName));
            }
            else {
                pLogCounter->lMachineNameOffset = (LONG) -1;
            }
            if (pThisCounter->pCounterPath->szObjectName != NULL) {
                pLogCounter->lObjectNameOffset = lBufOffset;
                pBufferBase = (PWCHAR)
                        ((LPBYTE) & pLogCounter->Buffer[0] + lBufOffset);
                lstrcpyW(pBufferBase,
                         pThisCounter->pCounterPath->szObjectName);
                lBufOffset += sizeof(WCHAR) * (1 +
                        lstrlenW(pThisCounter->pCounterPath->szObjectName));
            }
            else {
                pLogCounter->lObjectNameOffset = (LONG) -1;
            }
            if (pThisCounter->pCounterPath->szInstanceName != NULL) {
                pLogCounter->lInstanceOffset = lBufOffset;
                pBufferBase = (PWCHAR)
                        ((LPBYTE) & pLogCounter->Buffer[0] + lBufOffset);
                lstrcpyW(pBufferBase,
                         pThisCounter->pCounterPath->szInstanceName);
                lBufOffset += sizeof(WCHAR) * (1 +
                        lstrlenW(pThisCounter->pCounterPath->szInstanceName));
            }
            else {
                pLogCounter->lInstanceOffset = (LONG) -1;
            }
            if (pThisCounter->pCounterPath->szParentName != NULL) {
                pLogCounter->lParentOffset = lBufOffset;
                pBufferBase = (PWCHAR)
                        ((LPBYTE) & pLogCounter->Buffer[0] + lBufOffset);
                lstrcpyW(pBufferBase,
                         pThisCounter->pCounterPath->szParentName);
                lBufOffset += sizeof(WCHAR) * (1 +
                        lstrlenW(pThisCounter->pCounterPath->szParentName));
            }
            else {
                pLogCounter->lParentOffset = (LONG) -1;
            }

            if (pThisCounter->pCounterPath->szCounterName != NULL) {
                pLogCounter->lCounterOffset = lBufOffset;
                pBufferBase = (PWCHAR)
                        ((LPBYTE) & pLogCounter->Buffer[0] + lBufOffset);
                lstrcpyW(pBufferBase,
                         pThisCounter->pCounterPath->szCounterName);
                lBufOffset += sizeof(WCHAR) * (1 +
                        lstrlenW(pThisCounter->pCounterPath->szCounterName));
            }
            else {
                pLogCounter->lCounterOffset = (LONG) -1;
            }

            pThisCounter = pThisCounter->next.flink;

        } while (pThisCounter != pThisCounterHead);
    }

    if (Status == ERROR_SUCCESS) {
        Status = PdhWmiTraceEvent(pLog,
                                  PDH_LOG_HEADER_EVENT,
                                  LoggerInfo->TimeStamp - 1,
                                  SizeAlloc,
                                  ptrOutBuffer);
    }

Cleanup:
    if (ptrOutBuffer) {
        G_FREE(ptrOutBuffer);
    }
    return Status;
}

PDH_FUNCTION
PdhWmiTraceEvent(
    IN PPDHI_LOG pLog,
    IN ULONG     PdhEventType,
    IN ULONGLONG TimeStamp,
    IN ULONG     lenMofData,
    IN PVOID     ptrMofData)
{
    PDH_STATUS Status = PDH_INVALID_HANDLE;

    if (   (pLog->dwLogFormat & PDH_LOG_WRITE_ACCESS)
        && ((TRACEHANDLE) pLog->hLogFileHandle != (TRACEHANDLE) 0)) {

        PDH_WMI_EVENT_TRACE         Wnode;
        PPDH_EVENT_TRACE_PROPERTIES LoggerInfo =
                (PPDH_EVENT_TRACE_PROPERTIES) pLog->lpMappedFileBase;
        DWORD dwNumEvents     = (lenMofData / PDH_BLOCK_BUFFER_SIZE);
        DWORD dwCurrentEvent  = 1;
        PVOID ptrCurrentMof   = ptrMofData;
        BOOL  bIncreaseBuffer = TRUE;

        if (lenMofData > PDH_BLOCK_BUFFER_SIZE * dwNumEvents) {
            dwNumEvents ++;
        }

        for (Status = ERROR_SUCCESS, dwCurrentEvent = 1;
             (Status == ERROR_SUCCESS) && (dwCurrentEvent <= dwNumEvents);
             dwCurrentEvent ++) {
            USHORT sMofLen = (lenMofData > PDH_BLOCK_BUFFER_SIZE)
                           ? (PDH_BLOCK_BUFFER_SIZE) : ((USHORT) lenMofData);
            RtlZeroMemory(& Wnode, sizeof(PDH_WMI_EVENT_TRACE));
            Wnode.EventHeader.Size       = sizeof(PDH_WMI_EVENT_TRACE);
            Wnode.EventHeader.Class.Type = (UCHAR) PdhEventType;
            Wnode.EventHeader.Class.Version = PDH_EVENT_VERSION;
            Wnode.EventHeader.GuidPtr    = (ULONGLONG) & PdhTransactionGuid;
            Wnode.EventHeader.Flags      = WNODE_FLAG_TRACED_GUID
                                         | WNODE_FLAG_USE_GUID_PTR
                                         | WNODE_FLAG_USE_MOF_PTR
                                         | WNODE_FLAG_USE_TIMESTAMP;
            if (   PdhEventType == PDH_LOG_HEADER_EVENT
                || PdhEventType == PDH_LOG_COUNTER_STRING_EVENT) {
                Wnode.EventHeader.Flags  |= WNODE_FLAG_PERSIST_EVENT;
            }
            Wnode.EventHeader.TimeStamp.QuadPart = TimeStamp;
            Wnode.MofFields[0].Length  = sizeof(GUID);
            Wnode.MofFields[0].DataPtr = (ULONGLONG) & LoggerInfo->LogFileGuid;
            Wnode.MofFields[1].Length  = sizeof(DWORD);
            Wnode.MofFields[1].DataPtr = (ULONGLONG) & dwCurrentEvent;
            Wnode.MofFields[2].Length  = sizeof(DWORD);
            Wnode.MofFields[2].DataPtr = (ULONGLONG) & dwNumEvents;
            Wnode.MofFields[3].Length  = sMofLen;
            Wnode.MofFields[3].DataPtr = (ULONGLONG) ptrCurrentMof;

            bIncreaseBuffer = TRUE;
            while (bIncreaseBuffer == TRUE) {
                Status = TraceEvent((TRACEHANDLE) pLog->hLogFileHandle,
                                    (PEVENT_TRACE_HEADER) & Wnode);
                if (Status == ERROR_NOT_ENOUGH_MEMORY) {
                    if (LoggerInfo->LoggerInfo.MaximumBuffers >= PDH_WMI_MAX_BUFFERS) {
                        bIncreaseBuffer = FALSE;
                    }
                    else {
                        EVENT_TRACE_PROPERTIES tmpLoggerInfo;
                        LoggerInfo->LoggerInfo.MaximumBuffers += PDH_WMI_BUFFER_INCREMENT;
                        RtlCopyMemory(& tmpLoggerInfo,
                                      & LoggerInfo->LoggerInfo,
                                      sizeof(EVENT_TRACE_PROPERTIES));
                        tmpLoggerInfo.Wnode.BufferSize  = sizeof(EVENT_TRACE_PROPERTIES);
                        tmpLoggerInfo.LoggerNameOffset  = 0;
                        tmpLoggerInfo.LogFileNameOffset = 0;
                        Status = ControlTraceW((TRACEHANDLE) pLog->hLogFileHandle,
                                               LoggerInfo->LoggerName,
                                               (PEVENT_TRACE_PROPERTIES) & tmpLoggerInfo,
                                               EVENT_TRACE_CONTROL_UPDATE);
                        DebugPrint((1, "UpdateTrace(0x%08X,%d)(%d,0x%08X)\n",
                                pLog->hLogFileHandle,
                                LoggerInfo->LoggerInfo.MaximumBuffers,
                                Status,
                                Status));
                        bIncreaseBuffer = (Status == ERROR_SUCCESS || Status == ERROR_MORE_DATA) ? (TRUE) : (FALSE);
                    }
                }
                else {
                    bIncreaseBuffer = FALSE;
                }
            }
            if (Status != ERROR_SUCCESS) {
                DebugPrint((1, "PdhWmiTraceEvent(0x%08X,%d,%d/%d,%d,0x%08X,%I64d) fails (%d,0x%08X)\n",
                        pLog->hLogFileHandle,
                        PdhEventType,
                        dwCurrentEvent,
                        dwNumEvents,
                        sMofLen,
                        Wnode.EventHeader.Flags,
                        Wnode.EventHeader.TimeStamp.QuadPart,
                        Status,
                        Status));
            }

            if (Status == ERROR_SUCCESS) {
                lenMofData -= sMofLen;
                ptrCurrentMof = (PVOID) (((LPBYTE) ptrCurrentMof) + sMofLen);
            }
        }
    }
    return Status;
}

ULONG whextoi(WCHAR *s)
{
    long len;
    ULONG num, base, hex;

    if (s == NULL || s[0] == L'\0') {
        return 0;
    }
    len = (long) wcslen(s); // we expect all strings to be less than MAXSTR
    if (len == 0) {
        return 0;
    }

    hex  = 0;
    base = 1;
    num  = 0;
    while (-- len >= 0) {
        if (s[len] >= L'0' && s[len] <= L'9')
            num = s[len] - L'0';
        else if (s[len] >= L'a' && s[len] <= L'f')
            num = (s[len] - L'a') + 10;
        else if (s[len] >= L'A' && s[len] <= L'F')
            num = (s[len] - L'A') + 10;
        else
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

PDH_FUNCTION
PdhiCheckWmiLogFileType(
    IN  LPCWSTR LogFileName,
    IN  LPDWORD LogFileType)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HANDLE     hFile     = NULL;

    hFile = CreateFileW(LogFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
    }
    else {
        BYTE  TraceBuffer[PDH_WMI_BUFFER_SIZE_BYTE];
        ULONG ByteRead = 0;
        INT   bResult = ReadFile(hFile,
                                 (LPVOID) TraceBuffer,
                                 PDH_WMI_BUFFER_SIZE_BYTE,
                                 & ByteRead,
                                 NULL);
        if (bResult > 0 && ByteRead == PDH_WMI_BUFFER_SIZE_BYTE) {
            PWMI_BUFFER_HEADER    BufferHeader;
            PTRACE_LOGFILE_HEADER LogFileHeader;

            BufferHeader  = (PWMI_BUFFER_HEADER) TraceBuffer;
            LogFileHeader = (PTRACE_LOGFILE_HEADER)
                            (TraceBuffer + sizeof(WMI_BUFFER_HEADER)
                                         + sizeof(SYSTEM_TRACE_HEADER));
            if (   BufferHeader->Wnode.BufferSize == PDH_WMI_BUFFER_SIZE_BYTE
                && LogFileHeader->BufferSize == PDH_WMI_BUFFER_SIZE_BYTE) {
                // preassume that this is PDH event trace counter logfile
                //
                * LogFileType = PDH_LOG_TYPE_BINARY;
            }
            else {
                * LogFileType = PDH_LOG_TYPE_UNDEFINED;
            }
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhWmiGetLoggerName(
    IN PPDHI_LOG                   pLog,
    IN PPDH_EVENT_TRACE_PROPERTIES LoggerInfo)
{
    PDH_STATUS Status = ERROR_SUCCESS;
    BYTE       TraceBuffer[PDH_WMI_BUFFER_SIZE_BYTE]; // read in the first trace buffer
    HANDLE     hFile;
    ULONG      ByteRead = 0;

    hFile = CreateFileW(LoggerInfo->LogFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
        Status = PDH_LOG_FILE_OPEN_ERROR;
    }
    else {
        INT bResult =
            ReadFile(hFile, (LPVOID) TraceBuffer, PDH_WMI_BUFFER_SIZE_BYTE, & ByteRead, NULL);
        if (bResult == 0 || ByteRead != PDH_WMI_BUFFER_SIZE_BYTE) {
            Status = PDH_LOG_FILE_OPEN_ERROR;
        }
        CloseHandle(hFile);
    }

    if (Status == ERROR_SUCCESS) {
        PTRACE_LOGFILE_HEADER pHeader = (PTRACE_LOGFILE_HEADER)
                        (TraceBuffer + sizeof(WMI_BUFFER_HEADER) + sizeof(SYSTEM_TRACE_HEADER));
        if (pHeader->BuffersWritten > 1) {
            UINT    i;
            WCHAR   strTmp[PDH_MAX_PATH];
            LPWSTR  LoggerName = (LPWSTR) (((LPBYTE) pHeader) + sizeof(TRACE_LOGFILE_HEADER));

            lstrcpynW(LoggerInfo->LoggerName, LoggerName, PDH_MAX_PATH);
            wcsncpy(strTmp, LoggerName, 8);
            strTmp[8] = L'\0';
            LoggerInfo->LogFileGuid.Data1 = whextoi(strTmp);

            wcsncpy(strTmp, & LoggerName[9], 4);
            strTmp[4] = L'\0';
            LoggerInfo->LogFileGuid.Data2 = (USHORT) whextoi(strTmp);

            wcsncpy(strTmp, & LoggerName[14], 4);
            strTmp[4] = L'\0';
            LoggerInfo->LogFileGuid.Data3 = (USHORT) whextoi(strTmp);

            for (i = 0; i < 2; i ++) {
                wcsncpy(strTmp, & LoggerName[19 + (i * 2)], 2);
                strTmp[2] = L'\0';
                LoggerInfo->LogFileGuid.Data4[i] = (UCHAR) whextoi(strTmp);
            }

            for (i = 2; i < 8; i ++) {
                wcsncpy(strTmp, & LoggerName[20 + (i * 2)], 2);
                strTmp[2] = L'\0';
                LoggerInfo->LogFileGuid.Data4[i] = (UCHAR) whextoi(strTmp);
            }
        }
        else {
            // Only 1 trace buffer written, no PDH events yet.
            // It is safe to discard this one and create a new one.
            //
            Status = PDH_LOG_FILE_OPEN_ERROR;
            DebugPrint((1,"PdhWmiGetLoggerName(0x%08X,0x%08X,0x%08X,\"%ws\")\n",
                    Status, pLog, LoggerInfo, LoggerInfo->LogFileName));
        }
    }
    return Status;
}

PDH_FUNCTION
PdhiOpenOutputWmiLog(
    IN PPDHI_LOG pLog)
{
    PDH_STATUS                  Status = PDH_LOG_FILE_CREATE_ERROR;
    PPDH_EVENT_TRACE_PROPERTIES LoggerInfo;

    pLog->lpMappedFileBase = G_ALLOC(sizeof(PDH_EVENT_TRACE_PROPERTIES));
    if (pLog->lpMappedFileBase == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    LoggerInfo = (PPDH_EVENT_TRACE_PROPERTIES) pLog->lpMappedFileBase;
    RtlZeroMemory(LoggerInfo, sizeof(PDH_EVENT_TRACE_PROPERTIES));

    // Start PDH kernel logger
    //
    LoggerInfo->LoggerInfo.Wnode.BufferSize  =
                                    sizeof(PDH_EVENT_TRACE_PROPERTIES);
    LoggerInfo->LoggerInfo.Wnode.Flags       = WNODE_FLAG_TRACED_GUID;
    LoggerInfo->LoggerInfo.Wnode.ClientContext = EVENT_TRACE_CLOCK_SYSTEMTIME;
    LoggerInfo->LoggerInfo.BufferSize        = PDH_WMI_BUFFER_SIZE;
    LoggerInfo->LoggerInfo.LoggerNameOffset  = sizeof(EVENT_TRACE_PROPERTIES);
    LoggerInfo->LoggerInfo.LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)
                                             + sizeof(WCHAR) * PDH_MAX_PATH;
    _wfullpath(LoggerInfo->LogFileName, pLog->szLogFileName, PDH_MAX_PATH);
    if (   !(pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR)
        &&  (pLog->dwLogFormat & PDH_LOG_OPT_APPEND)) {
        Status = PdhWmiGetLoggerName(pLog, LoggerInfo);
        if (Status != ERROR_SUCCESS) {
            // if cannot get LogFileGuid from logfile, erase the old one
            // and create new one
            //
            RPC_STATUS rpcStatus = UuidCreate(& LoggerInfo->LogFileGuid);
            GuidToString(LoggerInfo->LoggerName, & LoggerInfo->LogFileGuid);
        }
        else {
            LoggerInfo->LoggerInfo.LogFileMode |= EVENT_TRACE_FILE_MODE_APPEND;
        }
    }
    else {
        RPC_STATUS rpcStatus = UuidCreate(& LoggerInfo->LogFileGuid);
        GuidToString(LoggerInfo->LoggerName, & LoggerInfo->LogFileGuid);
    }

    if (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR) {
        LoggerInfo->LoggerInfo.LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR;
    }
    else {
        LoggerInfo->LoggerInfo.LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;
    }
    LoggerInfo->LoggerInfo.LogFileMode |= EVENT_TRACE_USE_PAGED_MEMORY;

    if (pLog->llMaxSize == 0) {
        LoggerInfo->LoggerInfo.MaximumFileSize = 0;
    }
    else {
        LoggerInfo->LoggerInfo.MaximumFileSize =
                               (ULONG) ((pLog->llMaxSize / 1024) / 1024);
    }
    LoggerInfo->LoggerInfo.MaximumBuffers = PDH_WMI_DEFAULT_BUFFERS;

    LoggerInfo->bHeaderEvent = FALSE;
    Status = StartTraceW((PTRACEHANDLE) & pLog->hLogFileHandle,
                         LoggerInfo->LoggerName,
                         (PEVENT_TRACE_PROPERTIES) LoggerInfo);

    if (Status != ERROR_SUCCESS) {
        DebugPrint((1, "StartTraceW(%ws,%ws,0x%08X,%I64d) fails (0x%08X,%c)\n",
                    LoggerInfo->LoggerName,
                    LoggerInfo->LogFileName,
                    LoggerInfo->LoggerInfo.LogFileMode,
                    pLog->llMaxSize,
                    Status,
                    LoggerInfo->bHeaderEvent ? 'T' : 'F'));
    }

Cleanup:
    if (Status != ERROR_SUCCESS) {
        if (pLog->lpMappedFileBase) {
            G_FREE(pLog->lpMappedFileBase);
            pLog->lpMappedFileBase = NULL;
        }
        Status = PDH_LOG_FILE_CREATE_ERROR;
    }
    return Status;
}

PDH_FUNCTION
PdhiWriteWmiLogRecord (
    IN  PPDHI_LOG     pLog,
    IN  SYSTEMTIME  * stTimeStamp,
    IN  LPCWSTR       szUserString
)
{
    PDH_STATUS                     pdhStatus         = ERROR_SUCCESS;
    PPDHI_BINARY_LOG_RECORD_HEADER pLogCounterBuffer = NULL;
    PPDHI_BINARY_LOG_RECORD_HEADER pThisLogCounter   = NULL;
    PPDH_RAW_COUNTER               pSingleCounter;
    PPDHI_RAW_COUNTER_ITEM_BLOCK   pMultiCounter;
    PPDHI_COUNTER                  pThisCounter;
    PPERF_DATA_BLOCK               pObjectCounter;
    DWORD                          dwBufSize         = 0;
    ULONGLONG                      TimeStamp         = 0;
    FILETIME                       tFileTime;

    PPDH_EVENT_TRACE_PROPERTIES LoggerInfo =
            (PPDH_EVENT_TRACE_PROPERTIES) pLog->lpMappedFileBase;

    DBG_UNREFERENCED_PARAMETER(szUserString);

    SystemTimeToFileTime(stTimeStamp, & tFileTime);
    pThisCounter = pLog->pQuery ? pLog->pQuery->pCounterListHead : NULL;
    if (pThisCounter == NULL) {
        return PDH_NO_DATA;
    }

    do {
        DWORD   dwType  = (pThisCounter->dwFlags & PDHIC_COUNTER_OBJECT)
                        ? (PDHIC_COUNTER_OBJECT)
                        : (  (pThisCounter->dwFlags & PDHIC_MULTI_INSTANCE)
                           ? (PDHIC_MULTI_INSTANCE) : (0));
        DWORD   dwCtrBufSize = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
        DWORD   dwNewSize;
        int     nItem;

        switch (dwType) {
        case PDHIC_MULTI_INSTANCE:
            if (pThisCounter->pThisRawItemList) {
                dwCtrBufSize += pThisCounter->pThisRawItemList->dwLength;
            }
            else {
                dwCtrBufSize += sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK);
            }
            break;

        case PDHIC_COUNTER_OBJECT:
            if (pThisCounter->pThisObject) {
                dwCtrBufSize += pThisCounter->pThisObject->TotalByteLength;
            }
            else {
                dwCtrBufSize += sizeof(PERF_DATA_BLOCK);
            }
            break;

        default:
            dwCtrBufSize += sizeof(PDH_RAW_COUNTER);
            break;
        }

        if (dwCtrBufSize > 0) {
            // extend buffer to accomodate this new counter
            //
            if (pLogCounterBuffer == NULL) {
                // add in room for the master record header
                // then allocate the first one
                //
                dwBufSize = (dwCtrBufSize + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                pLogCounterBuffer = G_ALLOC(dwBufSize);

                // set counter data pointer to just after the master
                // record header
                //
                if (pLogCounterBuffer == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    break;
                }
                pThisLogCounter = (PPDHI_BINARY_LOG_RECORD_HEADER)
                                  (  ((PUCHAR) pLogCounterBuffer)
                                   + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                assert (dwCtrBufSize < 0x00010000);
                pThisLogCounter->dwLength = LOWORD(dwCtrBufSize);
            }
            else  {
                PPDHI_BINARY_LOG_RECORD_HEADER ptrTemp = pLogCounterBuffer;
                dwNewSize         = (dwBufSize + dwCtrBufSize);
                pLogCounterBuffer = G_REALLOC(ptrTemp, dwNewSize);
                if (pLogCounterBuffer == NULL) {
                    G_FREE(ptrTemp);
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    break;
                }
                pThisLogCounter   = (PPDHI_BINARY_LOG_RECORD_HEADER)
                                    ((LPBYTE) pLogCounterBuffer + dwBufSize);
                dwBufSize        += dwCtrBufSize;
                assert (dwCtrBufSize < 0x00010000);
                pThisLogCounter->dwLength = LOWORD(dwCtrBufSize);
            }
        }

        if (dwType == PDHIC_COUNTER_OBJECT) {
            FILETIME LocFileTime;
            pThisLogCounter->dwType = BINLOG_TYPE_DATA_LOC_OBJECT;
            pObjectCounter = (PPERF_DATA_BLOCK)
                             ((LPBYTE) pThisLogCounter +
                              sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            if (pThisCounter->pThisObject) {
                RtlCopyMemory(pObjectCounter,
                              pThisCounter->pThisObject,
                              pThisCounter->pThisObject->TotalByteLength);
                SystemTimeToFileTime(& pThisCounter->pThisObject->SystemTime,
                                     & LocFileTime);
            }
            else {
                if (TimeStamp != 0) {
                    LocFileTime.dwLowDateTime  = LODWORD(TimeStamp);
                    LocFileTime.dwHighDateTime = HIDWORD(TimeStamp);
                }
                else {
                    LocFileTime = tFileTime;
                }

                pObjectCounter->Signature[0]     = L'P';
                pObjectCounter->Signature[1]     = L'E';
                pObjectCounter->Signature[2]     = L'R';
                pObjectCounter->Signature[3]     = L'F';
                pObjectCounter->LittleEndian     = TRUE;
                pObjectCounter->Version          = PERF_DATA_VERSION;
                pObjectCounter->Revision         = PERF_DATA_REVISION;
                pObjectCounter->TotalByteLength  = sizeof(PERF_DATA_BLOCK);
                pObjectCounter->NumObjectTypes   = 1;
                pObjectCounter->DefaultObject    = pThisCounter->plCounterInfo.dwObjectId;
                pObjectCounter->SystemNameLength = 0;
                pObjectCounter->SystemNameOffset = 0;
                pObjectCounter->HeaderLength     = sizeof(PERF_DATA_BLOCK);

                pObjectCounter->PerfTime.QuadPart         = 0;
                pObjectCounter->PerfFreq.QuadPart         = 0;
                pObjectCounter->PerfTime100nSec.QuadPart  = 0;
                FileTimeToSystemTime(& LocFileTime,
                                     & pObjectCounter->SystemTime);
            }
            TimeStamp = MAKELONGLONG(LocFileTime.dwLowDateTime,
                                     LocFileTime.dwHighDateTime);
        }
        else if (dwType == PDHIC_MULTI_INSTANCE) {
            // multiple counter
            //
            pThisLogCounter->dwType = BINLOG_TYPE_DATA_MULTI;
            pMultiCounter = (PPDHI_RAW_COUNTER_ITEM_BLOCK)
                            ((LPBYTE) pThisLogCounter +
                                  sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            if (pThisCounter->pThisRawItemList) {
                RtlCopyMemory(pMultiCounter,
                              pThisCounter->pThisRawItemList,
                              pThisCounter->pThisRawItemList->dwLength);
            }
            else {
                FILETIME LocFileTime;
                if (TimeStamp != 0) {
                    LocFileTime.dwLowDateTime  = LODWORD(TimeStamp);
                    LocFileTime.dwHighDateTime = HIDWORD(TimeStamp);
                }
                else {
                    LocFileTime = tFileTime;
                }
                ZeroMemory(pMultiCounter,
                           sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK));
                pMultiCounter->CStatus = PDH_CSTATUS_INVALID_DATA;
                pMultiCounter->TimeStamp.dwLowDateTime =
                                        LocFileTime.dwLowDateTime;
                pMultiCounter->TimeStamp.dwHighDateTime =
                                        LocFileTime.dwHighDateTime;
            }
            TimeStamp = MAKELONGLONG(pMultiCounter->TimeStamp.dwLowDateTime,
                                 pMultiCounter->TimeStamp.dwHighDateTime);
        }
        else {
            pThisLogCounter->dwType = BINLOG_TYPE_DATA_SINGLE;
            pSingleCounter = (PPDH_RAW_COUNTER)
                             ((LPBYTE) pThisLogCounter +
                                 sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            RtlCopyMemory(  pSingleCounter,
                          & pThisCounter->ThisValue,
                            sizeof(PDH_RAW_COUNTER));
            if (pSingleCounter->CStatus != ERROR_SUCCESS) {
                if (TimeStamp != 0) {
                    pSingleCounter->TimeStamp.dwLowDateTime =
                                    LODWORD(TimeStamp);
                    pSingleCounter->TimeStamp.dwHighDateTime =
                                    HIDWORD(TimeStamp);
                }
                else {
                    pSingleCounter->TimeStamp.dwLowDateTime =
                                    tFileTime.dwLowDateTime;
                    pSingleCounter->TimeStamp.dwHighDateTime =
                                    tFileTime.dwHighDateTime;
                }
            }
            TimeStamp = (ULONGLONG) MAKELONGLONG(
                            pSingleCounter->TimeStamp.dwLowDateTime,
                            pSingleCounter->TimeStamp.dwHighDateTime);
        }
        pThisCounter = pThisCounter->next.flink; // go to next in list

    } while (pThisCounter != pLog->pQuery->pCounterListHead);

    if (TimeStamp == 0) {
        TimeStamp = MAKELONGLONG(tFileTime.dwLowDateTime,
                                 tFileTime.dwHighDateTime);
    }

    if (pdhStatus == ERROR_SUCCESS && pLogCounterBuffer) {
        pLogCounterBuffer->dwType   = BINLOG_TYPE_DATA;
        pLogCounterBuffer->dwLength = dwBufSize;
        LoggerInfo->TimeStamp = TimeStamp;

        if (! LoggerInfo->bHeaderEvent) {
            ULONG HeaderMofLength = 0;
            PVOID HeaderMofData   = NULL;
            ULONG EventType;

            if (LoggerInfo->LoggerInfo.LogFileMode
                                & EVENT_TRACE_FILE_MODE_APPEND) {
#if 0
                pdhStatus = PdhiBuildEmptyBlock(pLog,
                                                LoggerInfo->TimeStamp - 1,
                                                & HeaderMofLength,
                                                & HeaderMofData);
                if (pdhStatus == ERROR_SUCCESS) {
                    pdhStatus = PdhWmiTraceEvent(pLog,
                                                 PDH_LOG_DATA_BLOCK_EVENT,
                                                 LoggerInfo->TimeStamp - 1,
                                                 HeaderMofLength,
                                                 HeaderMofData);
                }
                if (HeaderMofData) {
                    G_FREE(HeaderMofData);
                }
#endif
            }
            else {
                pdhStatus = PdhiBuildLogHeaderBlock(pLog, LoggerInfo);
            }
            LoggerInfo->bHeaderEvent = TRUE;
        }
    }

    if (pdhStatus == ERROR_SUCCESS && pLogCounterBuffer) {
        pdhStatus = PdhWmiTraceEvent(pLog,
                                     PDH_LOG_DATA_BLOCK_EVENT,
                                     TimeStamp,
                                     dwBufSize,
                                     (PVOID)  pLogCounterBuffer);
    }
    if (pLogCounterBuffer != NULL) {
        G_FREE(pLogCounterBuffer);
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteWmiLogHeader (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szUserCaption)
{
    UNREFERENCED_PARAMETER (pLog);
    UNREFERENCED_PARAMETER (szUserCaption);
    return ERROR_SUCCESS;
}


PDH_FUNCTION
PdhiCloseWmiLog(
    IN  PPDHI_LOG   pLog,
    IN  DWORD       dwFlags)
{
    PDH_STATUS Status = PDH_INVALID_ARGUMENT;

    UNREFERENCED_PARAMETER (pLog);
    UNREFERENCED_PARAMETER (dwFlags);

    if (pLog->dwLogFormat & PDH_LOG_WRITE_ACCESS) {

        if ((TRACEHANDLE) pLog->hLogFileHandle != (TRACEHANDLE) 0) {
            PPDH_EVENT_TRACE_PROPERTIES LoggerInfo =
                        (PPDH_EVENT_TRACE_PROPERTIES) pLog->lpMappedFileBase;
            if (LoggerInfo == NULL) {
                Status = PDH_INVALID_HANDLE;
            }
            else {
                ULONG HeaderMofLength = 0;
                PVOID HeaderMofData   = NULL;
#if 0
                Status = PdhiBuildEmptyBlock(pLog,
                                             LoggerInfo->TimeStamp,
                                             & HeaderMofLength,
                                             & HeaderMofData);
                if (Status == ERROR_SUCCESS) {
                    Status = PdhWmiTraceEvent(pLog,
                                              PDH_LOG_DATA_BLOCK_EVENT,
                                              LoggerInfo->TimeStamp + 1,
                                              HeaderMofLength,
                                              HeaderMofData);
                }
                if (HeaderMofData) {
                    G_FREE(HeaderMofData);
                }
#endif
                Status = ControlTraceW((TRACEHANDLE) pLog->hLogFileHandle,
                                       LoggerInfo->LoggerName,
                                       (PEVENT_TRACE_PROPERTIES) LoggerInfo,
                                       EVENT_TRACE_CONTROL_STOP);
                if (Status != ERROR_SUCCESS) {
                    DebugPrint((1, "StopTrace(0x%08X,%ws,%ws) fails (%d)\n",
                            pLog->hLogFileHandle,
                            LoggerInfo->LoggerName,
                            LoggerInfo->LogFileName,
                            Status,
                            Status));
                }
                if (LoggerInfo->MachineList != NULL) {
                    G_FREE(LoggerInfo->MachineList);
                }
                G_FREE(pLog->lpMappedFileBase);
                pLog->lpMappedFileBase = NULL;
            }

            pLog->hLogFileHandle = INVALID_HANDLE_VALUE;

            if (PdhTraceRegistrationHandle != (TRACEHANDLE) 0) {
                Status = UnregisterTraceGuids(PdhTraceRegistrationHandle);
                if (Status != ERROR_SUCCESS) {
                    DebugPrint((4,
                            "UnregisterTraceGuid(0x%08X) fails (%d,0x%08X)\n",
                            PdhTraceRegistrationHandle,
                            Status,
                            Status));
                }
            }
        }
        else {
            Status = PDH_INVALID_HANDLE;
        }
    }
    else if (pLog->dwLogFormat & PDH_LOG_READ_ACCESS) {
        ULONG               i;
        DWORD               dwExitCode;
        PPDH_LOGGER_CONTEXT CurrentContext =
                                (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
        DWORD               dwContext = GetLoggerContext(CurrentContext);

        if (dwContext < ContextCount) {
            Status = WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex);
            if (Status == ERROR_SUCCESS) {
                CurrentContext->RefCount --;
                if (CurrentContext->RefCount > 0) {
                    RELEASE_MUTEX(hPdhContextMutex);
                    return ERROR_SUCCESS;
                }
            }
            else {
                return Status;
            }
            if (dwContext != ContextCount - 1) {
                ContextTable[dwContext] = ContextTable[ContextCount - 1];
            }
            ContextCount --;
            ContextTable[ContextCount] = NULL;
            RELEASE_MUTEX(hPdhContextMutex);

            if (CurrentContext->hThreadWork != NULL
                && CurrentContext->hThreadWork != INVALID_HANDLE_VALUE) {
                if (GetExitCodeThread(CurrentContext->hThreadWork, & dwExitCode)
                        && dwExitCode == STILL_ACTIVE) {
                    CurrentContext->LoggerState = PdhProcessTraceEnd;
                    SetEvent(CurrentContext->hSyncWMI);
                    while (CurrentContext->LoggerState != PdhProcessTraceExit) {
                        _sleep(1);
                    }
                    if (TerminateThread(CurrentContext->hThreadWork, 0)) {
                        WaitForSingleObject(CurrentContext->hThreadWork, INFINITE);
                    }
                }
            }

            if (CurrentContext->hSyncWMI != NULL) {
                CloseHandle(CurrentContext->hSyncWMI);
            }
            if (CurrentContext->hSyncPDH != NULL) {
                CloseHandle(CurrentContext->hSyncPDH);
            }

            for (i = 0; i < CurrentContext->LoggerCount; i ++) {
                if (! IsListEmpty(& CurrentContext->LogInfo[i].CounterPathList)) {
                    PLIST_ENTRY PathHead =
                                & CurrentContext->LogInfo[i].CounterPathList;
                    PLIST_ENTRY PathNext = PathHead->Flink;
                    PPDH_COUNTER_PATH pCounterPath;

                    while (PathHead != PathNext) {
                        pCounterPath = CONTAINING_RECORD(PathNext,
                                                         PDH_COUNTER_PATH,
                                                         Entry);
                        PathNext     = PathNext->Flink;
                        RemoveEntryList(& pCounterPath->Entry);
                        G_FREE(pCounterPath->CounterPathBuffer);
                        G_FREE(pCounterPath);
                    }
                }
                if (! IsListEmpty(& CurrentContext->LogInfo[i].PerfMachineList)) {
                    PLIST_ENTRY PathHead =
                                & CurrentContext->LogInfo[i].PerfMachineList;
                    PLIST_ENTRY PathNext = PathHead->Flink;
                    PPDH_WMI_PERF_MACHINE pPerfMachine;

                    while (PathHead != PathNext) {
                        pPerfMachine = CONTAINING_RECORD(PathNext,
                                                         PDH_WMI_PERF_MACHINE,
                                                         Entry);
                        PathNext     = PathNext->Flink;
                        RemoveEntryList(& pPerfMachine->Entry);
                        if (! IsListEmpty(& pPerfMachine->LogObjectList)) {
                            PLIST_ENTRY pHead =
                                & pPerfMachine->LogObjectList;
                            PLIST_ENTRY pNext = pHead->Flink;
                            PPDH_WMI_PERF_OBJECT pPerfObject;

                            while (pHead != pNext) {
                                pPerfObject = CONTAINING_RECORD(
                                    pNext, PDH_WMI_PERF_OBJECT, Entry);
                                pNext       = pNext->Flink;
                                RemoveEntryList(& pPerfObject->Entry);
                                G_FREE(pPerfObject->ptrBuffer);
                                G_FREE(pPerfObject);
                            }
                        }
                        G_FREE(pPerfMachine->pszBuffer);
                        G_FREE(pPerfMachine->ptrStrAry);
                        G_FREE(pPerfMachine);
                    }
                }
                if (CurrentContext->LogInfo[i].DataBlock) {
                    G_FREE(CurrentContext->LogInfo[i].DataBlock);
                }
            }
            if (CurrentContext->tmpBuffer) {
                G_FREE(CurrentContext->tmpBuffer);
            }
            if (CurrentContext->CounterPathBuffer) {
                G_FREE(CurrentContext->CounterPathBuffer);
            }
            G_FREE(pLog->lpMappedFileBase);
            pLog->lpMappedFileBase = NULL;
            pLog->pLastRecordRead  = NULL;

            Status = ERROR_SUCCESS;
        }
        else {
            Status = PDH_INVALID_HANDLE;
        }
    }
    return Status;
}

PDH_FUNCTION
PdhiAddWmiLogFileGuid(
    PPDH_LOGGER_CONTEXT CurrentContext,
    LPGUID              pGuid)
{
    PDH_STATUS Status = ERROR_SUCCESS;
    ULONG      i;

    for (i = 0; i < CurrentContext->LoggerCount; i ++) {
        if (IsEqualGUID(pGuid, & CurrentContext->LogInfo[i].LogFileGuid))
            break;
    }
    if (i == CurrentContext->LoggerCount) {
        CurrentContext->LogInfo[i].LogFileGuid = * pGuid;
        CurrentContext->LoggerCount ++;
        if (CurrentContext->LoggerCount > CurrentContext->LogFileCount) {
            DebugPrint((4, "LogFileCount(%d) LoggerCount(%d) mismatch\n",
                    CurrentContext->LoggerCount,
                    CurrentContext->LogFileCount));
        }
    }
    return Status;
}

ULONG
PdhiFindLogFileGuid(
    PPDH_LOGGER_CONTEXT CurrentContext,
    LPGUID              pGuid)
{
    ULONG i;

    for (i = 0; i < CurrentContext->LoggerCount; i ++) {
        if (IsEqualGUID(pGuid, & CurrentContext->LogInfo[i].LogFileGuid))
            break;
    }
    return i;
}

ULONGLONG
PdhWmiGetDataBlockTimeStamp(
    PPDH_LOGGER_CONTEXT CurrentContext,
    PEVENT_TRACE        pEvent,
    BOOLEAN             bFirstRun)
{
    PVOID     pDataBlock = pEvent->MofData;
    ULONGLONG TimeStamp  = pEvent->Header.TimeStamp.QuadPart;

    if (TimeStamp > 0) {
        LPGUID pLogFileGuid = (LPGUID) pDataBlock;
        ULONG  i;

        for (i = 0; i < CurrentContext->LoggerCount; i ++) {
            if (IsEqualGUID(  pLogFileGuid,
                            & CurrentContext->LogInfo[i].LogFileGuid)) {
                break;
            }
        }

        if (i < CurrentContext->LoggerCount) {
            if (bFirstRun) {
                if (   pEvent->Header.Class.Version < PDH_EVENT_VERSION
                    || CurrentContext->LogInfo[i].TimePrev < TimeStamp) {
                    CurrentContext->LogInfo[i].ValidEntries ++;
                }
                if (CurrentContext->LogInfo[i].TimeStart == 0) {
                    CurrentContext->LogInfo[i].TimeStart = TimeStamp;
                    CurrentContext->LogInfo[i].TimePrev  = TimeStamp;
                }
                else {
                    // no need to update StartTime.
                    // Always assume the first trace event has the StartTime.
                    //
                    if (CurrentContext->LogInfo[i].TimeEnd < TimeStamp) {
                        CurrentContext->LogInfo[i].TimeEnd = TimeStamp;
                    }

                    if (  (TimeStamp - CurrentContext->LogInfo[i].TimePrev)
                        < (CurrentContext->LogInfo[i].TimeFreq)) {
                        CurrentContext->LogInfo[i].TimeFreq =
                                TimeStamp - CurrentContext->LogInfo[i].TimePrev;
                    }
                    CurrentContext->LogInfo[i].TimePrev = TimeStamp;
                }
            }
            else {
                assert(CurrentContext->LogInfo[i].TimePrev  <= TimeStamp);
                assert(CurrentContext->LogInfo[i].TimeStart <= TimeStamp);
                assert(CurrentContext->LogInfo[i].TimeEnd   >= TimeStamp);
                CurrentContext->LogInfo[i].TimePrev = TimeStamp;
            }
        }
    }
    return TimeStamp;
}

PDH_FUNCTION
PdhiWmiComputeCounterBlocks(
    PPDH_LOGGER_CONTEXT CurrentContext,
    PEVENT_TRACE        pEvent)
{
    LPGUID     pLogFileGuid;
    PDH_STATUS Status       = ERROR_SUCCESS;
    PVOID      pDataBlock;
    ULONG      i;
    ULONG      ulNumDataBlocks;
    ULONG      ulDataBlocksCopied;
    ULONG      ulBufferSize;
    ULONG      ulBlockIndex;
    BOOLEAN    bOldEvent;

    if (CurrentContext == NULL || pEvent == NULL) {
        return PDH_INVALID_DATA;
    }

    bOldEvent    = (pEvent->Header.Class.Version < PDH_EVENT_VERSION);
    pLogFileGuid = (LPGUID) pEvent->MofData;
    if (pLogFileGuid == NULL) {
        return PDH_INVALID_DATA;
    }
    for (i = 0; i < CurrentContext->LoggerCount; i ++) {
        if (IsEqualGUID(pLogFileGuid,
                        & CurrentContext->LogInfo[i].LogFileGuid)) {
            break;
        }
    }
    if (i == CurrentContext->LoggerCount) {
        return PDH_INVALID_DATA;
    }

    ulNumDataBlocks    = CurrentContext->LogInfo[i].ulNumDataBlocks;
    ulDataBlocksCopied = CurrentContext->LogInfo[i].ulDataBlocksCopied;

    if (ulNumDataBlocks > 0 && ulNumDataBlocks == ulDataBlocksCopied) {
        if (CurrentContext->LogInfo[i].DataBlock != NULL) {
            G_FREE(CurrentContext->LogInfo[i].DataBlock);
            CurrentContext->LogInfo[i].DataBlock = NULL;
        }
        goto Cleanup;
    }

    if (ulNumDataBlocks == 0) {
        if (bOldEvent) {
            ulNumDataBlocks = 1;
            ulBufferSize    = pEvent->MofLength;
        }
        else {
            ulNumDataBlocks = * (DWORD *) (  ((LPBYTE) pEvent->MofData)
                                           + sizeof(GUID) + sizeof(DWORD));
            ulBufferSize    = ulNumDataBlocks * PDH_BLOCK_BUFFER_SIZE
                            + sizeof(GUID);
        }

        if (CurrentContext->LogInfo[i].DataBlock != NULL) {
            G_FREE(CurrentContext->LogInfo[i].DataBlock);
            CurrentContext->LogInfo[i].DataBlock = NULL;
        }
        CurrentContext->LogInfo[i].DataBlock = G_ALLOC(ulBufferSize);
        if (CurrentContext->LogInfo[i].DataBlock == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }

        CurrentContext->LogInfo[i].ulNumDataBlocks    = ulNumDataBlocks;
        CurrentContext->LogInfo[i].ulDataBlocksCopied = 0;
        CurrentContext->LogInfo[i].DataBlockAlloc     = ulBufferSize;
    }

    if (bOldEvent) {
        RtlCopyMemory(CurrentContext->LogInfo[i].DataBlock,
                      pEvent->MofData,
                      pEvent->MofLength);
    }
    else {
        ulBlockIndex = * (DWORD *) (((LPBYTE) pEvent->MofData) + sizeof(GUID));
        pDataBlock = (PVOID)
                     (  ((LPBYTE) CurrentContext->LogInfo[i].DataBlock)
                      + sizeof(GUID)
                      + PDH_BLOCK_BUFFER_SIZE * (ulBlockIndex - 1));
        RtlCopyMemory(pDataBlock,
                      (PVOID) (((LPBYTE) pEvent->MofData)
                              + sizeof(GUID) + sizeof(DWORD) + sizeof(DWORD)),
                      pEvent->MofLength - sizeof(GUID)
                              - sizeof(DWORD) - sizeof(DWORD));
    }
    CurrentContext->LogInfo[i].ulDataBlocksCopied ++;

    if (CurrentContext->LogInfo[i].ulDataBlocksCopied >=
            CurrentContext->LogInfo[i].ulNumDataBlocks) {
        DWORD   dwTotal;
        DWORD   dwCurrent;
        DWORD   dwCounters  = 0;
        BOOLEAN bValidBlock = TRUE;
        PPDHI_BINARY_LOG_RECORD_HEADER pCurrent;

        PPDHI_BINARY_LOG_RECORD_HEADER pMasterRec;
        pDataBlock = CurrentContext->LogInfo[i].DataBlock;
        pMasterRec = (PPDHI_BINARY_LOG_RECORD_HEADER)
                     ((LPBYTE) pDataBlock + sizeof(GUID));
        dwTotal    = pMasterRec->dwLength;
        pCurrent   = pMasterRec;
        dwCurrent  = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
        while (bValidBlock && dwCurrent < dwTotal) {
            pCurrent   = (PPDHI_BINARY_LOG_RECORD_HEADER)
                         ((LPBYTE) pMasterRec + dwCurrent);
            if (LOWORD(pCurrent->dwType) != BINLOG_START_WORD) {
                bValidBlock = FALSE;
            }
            else {
                dwCurrent += pCurrent->dwLength;
                dwCounters ++;
            }
        }
        if (bValidBlock) {
            CurrentContext->LogInfo[i].ulCounters += dwCounters;
        }
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiAddCounterPathRecord(
    PPDH_LOGGER_CONTEXT CurrentContext,
    PEVENT_TRACE        pEvent,
    LPGUID              pLogFileGuid,
    ULONG               BufferSize,
    PVOID               pBuffer,
    ULONGLONG           TimeStamp,
    DWORD               dwIndex,
    DWORD               dwCount,
    BOOLEAN           * pNeedUpdate)
{
    PPDH_COUNTER_PATH pNewCounter;
    ULONG             i;
    PVOID             pCounterPath;

    i = PdhiFindLogFileGuid(CurrentContext, pLogFileGuid);
    if (i == CurrentContext->LoggerCount) {
        return PDH_INVALID_DATA;
    }

    if (pEvent->Header.Class.Version >= PDH_EVENT_VERSION) {
        if (   CurrentContext->LogInfo[i].DataBlock
            && CurrentContext->LogInfo[i].ulNumDataBlocks != dwCount) {
            G_FREE(CurrentContext->LogInfo[i].DataBlock);
            CurrentContext->LogInfo[i].DataBlock = NULL;
        }
        if (CurrentContext->LogInfo[i].DataBlock == NULL) {
            CurrentContext->LogInfo[i].DataBlock =
                    G_ALLOC(PDH_BLOCK_BUFFER_SIZE * dwCount);
            if (CurrentContext->LogInfo[i].DataBlock == NULL) {
                return PDH_MEMORY_ALLOCATION_FAILURE;
            }
            CurrentContext->LogInfo[i].DataBlockAlloc     = PDH_BLOCK_BUFFER_SIZE * dwCount;
            CurrentContext->LogInfo[i].DataBlockSize      = 0;
            CurrentContext->LogInfo[i].ulNumDataBlocks    = dwCount;
            CurrentContext->LogInfo[i].ulDataBlocksCopied = 0;
        }

        pCounterPath = (PVOID) (  ((LPBYTE) CurrentContext->LogInfo[i].DataBlock)
                                + (dwIndex - 1) * PDH_BLOCK_BUFFER_SIZE);
        if (BufferSize > PDH_BLOCK_BUFFER_SIZE) {
            BufferSize = PDH_BLOCK_BUFFER_SIZE;
        }
        RtlCopyMemory(pCounterPath, pBuffer, BufferSize);
        CurrentContext->LogInfo[i].ulDataBlocksCopied ++;
        CurrentContext->LogInfo[i].DataBlockSize += BufferSize;

        if (  CurrentContext->LogInfo[i].ulDataBlocksCopied
            < CurrentContext->LogInfo[i].ulNumDataBlocks) {
            return ERROR_SUCCESS;
        }

        pCounterPath = (PVOID) (((LPBYTE) CurrentContext->LogInfo[i].DataBlock)
                                + sizeof(PDH_WMI_LOG_INFO));
        BufferSize   = CurrentContext->LogInfo[i].DataBlockSize
                                - sizeof(PDH_WMI_LOG_INFO);
    }

    if (! IsListEmpty(& CurrentContext->LogInfo[i].CounterPathList)) {
        PLIST_ENTRY PathHead = & CurrentContext->LogInfo[i].CounterPathList;
        PLIST_ENTRY PathNext = PathHead->Flink;

        while (PathHead != PathNext) {
            pNewCounter = CONTAINING_RECORD(PathNext,
                                            PDH_COUNTER_PATH,
                                            Entry);
            PathNext    = PathNext->Flink;
            if (TimeStamp == pNewCounter->TimeStamp) {
                // CounterPath record is already in the list
                //
                return ERROR_SUCCESS;
            }
        }
    }

    pNewCounter = G_ALLOC(sizeof(PDH_COUNTER_PATH));
    if (pNewCounter == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    pNewCounter->TimeStamp   = TimeStamp;
    pNewCounter->CounterPathBuffer = G_ALLOC(BufferSize);
    if (pNewCounter->CounterPathBuffer == NULL) {
        G_FREE(pNewCounter);
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }
    pNewCounter->CounterPathSize = BufferSize;
    if (pEvent->Header.Class.Version >= PDH_EVENT_VERSION) {
        RtlCopyMemory(pNewCounter->CounterPathBuffer, pCounterPath, BufferSize);
    }
    else {
        RtlCopyMemory(pNewCounter->CounterPathBuffer, pBuffer, BufferSize);
    }

    pNewCounter->CounterCount = 0;
    {
        PPDHI_LOG_COUNTER_PATH pPath = pNewCounter->CounterPathBuffer;
        ULONG dwProcessed = 0;

        while (dwProcessed < BufferSize) {
            pNewCounter->CounterCount ++;
            dwProcessed += pPath->dwLength;
            pPath = (PPDHI_LOG_COUNTER_PATH)
                    (((LPBYTE) pPath) + pPath->dwLength);
        }
    }

    InsertTailList(& CurrentContext->LogInfo[i].CounterPathList,
                   & pNewCounter->Entry);
    * pNeedUpdate = TRUE;

    if (pEvent->Header.Class.Version >= PDH_EVENT_VERSION) {
        G_FREE(CurrentContext->LogInfo[i].DataBlock);
        CurrentContext->LogInfo[i].DataBlock          = NULL;
        CurrentContext->LogInfo[i].DataBlockAlloc     = 0;
        CurrentContext->LogInfo[i].DataBlockSize      = 0;
        CurrentContext->LogInfo[i].ulNumDataBlocks    = 0;
        CurrentContext->LogInfo[i].ulDataBlocksCopied = 0;
    }

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiAddPerfMachine(
    IN PPDH_LOGGER_CONTEXT CurrentContext,
    IN PVOID               pMofDataBlock,
    IN DWORD               dwMofLength)
{
    PDH_STATUS Status         = ERROR_SUCCESS;
    LPGUID     pLogFileGuid   = (LPGUID) pMofDataBlock;
    LPWSTR     pszMachineName = (LPWSTR) (((LPBYTE) pMofDataBlock)
                              + sizeof(GUID) + sizeof(DWORD) + sizeof(DWORD));
    DWORD      dwBufSize      = dwMofLength
                              - sizeof(GUID) - sizeof(DWORD) - sizeof(DWORD);
    ULONG      i;
    LPWSTR     pszTmpBuffer;
    DWORD      dwThisId;
    DWORD      dwBufUsed;

    PPDH_WMI_PERF_MACHINE pCurrentMachine = NULL;
    BOOLEAN               bNewMachine     = TRUE;

    i = PdhiFindLogFileGuid(CurrentContext, pLogFileGuid);
    if (i == CurrentContext->LoggerCount) {
        Status = PDH_INVALID_DATA;
        goto Cleanup;
    }

    if (! IsListEmpty(& CurrentContext->LogInfo[i].PerfMachineList)) {
        PLIST_ENTRY pHead = & CurrentContext->LogInfo[i].PerfMachineList;
        PLIST_ENTRY pNext = pHead->Flink;
        while (pNext != pHead) {
            PPDH_WMI_PERF_MACHINE pMachine =
                    CONTAINING_RECORD(pNext, PDH_WMI_PERF_MACHINE, Entry);
            if (lstrcmpiW(pMachine->pszBuffer, pszMachineName) == 0) {
                pCurrentMachine = pMachine;
                bNewMachine     = FALSE;
                break;
            }
            pNext = pNext->Flink;
        }
    }

    if (bNewMachine) {
        pCurrentMachine = G_ALLOC(sizeof(PDH_WMI_PERF_MACHINE));
        if (pCurrentMachine == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        InsertTailList(& CurrentContext->LogInfo[i].PerfMachineList,
                       & pCurrentMachine->Entry);
        pCurrentMachine->pszBuffer = G_ALLOC(dwBufSize);
        if (pCurrentMachine->pszBuffer == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        RtlCopyMemory(pCurrentMachine->pszBuffer, pszMachineName, dwBufSize);
        pCurrentMachine->dwBufSize = dwBufSize;
        InitializeListHead(& pCurrentMachine->LogObjectList);
    }
    else {
        pszTmpBuffer    = pCurrentMachine->pszBuffer;
        dwBufSize      -= (sizeof(WCHAR) * (lstrlenW(pszMachineName) + 1));
        pszMachineName += (lstrlenW(pszMachineName) + 1);
        pCurrentMachine->pszBuffer = G_ALLOC(
                pCurrentMachine->dwBufSize + dwBufSize);
        if (pCurrentMachine->pszBuffer == NULL) {
            pCurrentMachine->pszBuffer = pszTmpBuffer;
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        RtlCopyMemory(pCurrentMachine->pszBuffer,
                      pszTmpBuffer,
                      pCurrentMachine->dwBufSize);
        G_FREE(pszTmpBuffer);
        pszTmpBuffer = (LPWSTR)
                       (  ((LPBYTE) pCurrentMachine->pszBuffer)
                        + pCurrentMachine->dwBufSize);
        RtlCopyMemory(pszTmpBuffer, pszMachineName, dwBufSize);
        pCurrentMachine->dwBufSize += dwBufSize;
    }
    dwBufSize = pCurrentMachine->dwBufSize;

    pCurrentMachine->dwLastId = 0;
    i            = lstrlenW(pCurrentMachine->pszBuffer) + 1;
    pszTmpBuffer = pCurrentMachine->pszBuffer + i;
    dwBufUsed    = sizeof(WCHAR) * i;
    while ((dwBufUsed < dwBufSize) && (* pszTmpBuffer)) {
        do {
            dwThisId = wcstoul(pszTmpBuffer, NULL, 10);
            if (dwThisId > pCurrentMachine->dwLastId) {
                pCurrentMachine->dwLastId = dwThisId;
            }
            i = lstrlenW(pszTmpBuffer) + 1;
            dwBufUsed += (sizeof(WCHAR) * i);
            if (dwBufUsed < dwBufSize) {
                pszTmpBuffer += i;
            }
        }
        while ((dwThisId == 0) && (* pszTmpBuffer)
                               && dwBufUsed < dwBufSize);

        i = lstrlenW(pszTmpBuffer) + 1;
        dwBufUsed += (sizeof(WCHAR) * i);
        if ((* pszTmpBuffer) && (dwBufUsed < dwBufSize)) {
            pszTmpBuffer += i;
        }
    }

    if (pCurrentMachine->dwLastId == 0) {
        Status = PDH_CANNOT_READ_NAME_STRINGS;
        goto Cleanup;
    }

    if (! bNewMachine) {
        G_FREE(pCurrentMachine->ptrStrAry);
        pCurrentMachine->ptrStrAry = NULL;
    }
    pCurrentMachine->ptrStrAry =
                G_ALLOC(sizeof(LPWSTR) * (pCurrentMachine->dwLastId + 1));
    if (pCurrentMachine->ptrStrAry == NULL) {
        Status = PDH_CANNOT_READ_NAME_STRINGS;
        goto Cleanup;
    }

    i            = lstrlenW(pCurrentMachine->pszBuffer) + 1;
    pszTmpBuffer = pCurrentMachine->pszBuffer + i;
    dwBufUsed    = sizeof(WCHAR) * i;
    while ((dwBufUsed < dwBufSize) && (* pszTmpBuffer)) {
        do {
            dwThisId = wcstoul(pszTmpBuffer, NULL, 10);
            i = lstrlenW(pszTmpBuffer) + 1;
            dwBufUsed += (sizeof(WCHAR) * i);
            if (dwBufUsed < dwBufSize) {
                pszTmpBuffer += i;
            }
        }
        while ((dwThisId == 0) && (* pszTmpBuffer)
                               && dwBufUsed < dwBufSize);

        if (dwThisId > 0 && dwThisId <= pCurrentMachine->dwLastId) {
            pCurrentMachine->ptrStrAry[dwThisId] = pszTmpBuffer;
        }

        i = lstrlenW(pszTmpBuffer) + 1;
        dwBufUsed += (sizeof(WCHAR) * i);
        if ((* pszTmpBuffer) && (dwBufUsed < dwBufSize)) {
            pszTmpBuffer += i;
        }
    }

Cleanup:
    if (Status != ERROR_SUCCESS) {
        if (bNewMachine) {
            if (pCurrentMachine != NULL) {
                if (pCurrentMachine->pszBuffer != NULL) {
                    G_FREE(pCurrentMachine->pszBuffer);
                }
                RemoveEntryList(& pCurrentMachine->Entry);
                G_FREE(pCurrentMachine);
            }
        }
        else if (pCurrentMachine != NULL) {
            if (pCurrentMachine->pszBuffer != NULL) {
                G_FREE(pCurrentMachine->pszBuffer);
            }
            RemoveEntryList(& pCurrentMachine->Entry);
            G_FREE(pCurrentMachine);
        }
    }
    return Status;
}

PDH_FUNCTION
PdhiGetCounterPathRecord(
    IN PPDH_LOGGER_CONTEXT CurrentContext,
    IN PVOID               pRecord,
    IN ULONG               dwMaxSize)
{
    PDH_STATUS Status = ERROR_SUCCESS;
    DWORD CurrentSize = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

    if (CurrentContext->bCounterPathChanged) {
        PPDHI_BINARY_LOG_HEADER_RECORD pBinLogHeader = NULL;
        PVOID pCounterPath;
        ULONG i;

        if (CurrentContext->CounterPathBuffer) {
            G_FREE(CurrentContext->CounterPathBuffer);
        }
        CurrentContext->CounterPathBuffer = G_ALLOC(CurrentSize);
        if (CurrentContext->CounterPathBuffer == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }

        for (i = 0; i < CurrentContext->LoggerCount; i ++) {
            if (! IsListEmpty(& CurrentContext->LogInfo[i].CounterPathList)) {
                PLIST_ENTRY  PathHead =
                                & CurrentContext->LogInfo[i].CounterPathList;
                PLIST_ENTRY  PathNext = PathHead->Flink;
                PPDH_COUNTER_PATH pCurrentPath;

                while (Status == ERROR_SUCCESS && PathNext != PathHead) {
                    PVOID ptrTemp;

                    pCurrentPath = CONTAINING_RECORD(PathNext,
                                                     PDH_COUNTER_PATH,
                                                     Entry);
                    PathNext = PathNext->Flink;

                    ptrTemp = CurrentContext->CounterPathBuffer;
                    CurrentContext->CounterPathBuffer = G_REALLOC(
                            ptrTemp, CurrentSize + pCurrentPath->CounterPathSize);
                    if (CurrentContext->CounterPathBuffer == NULL) {
                        G_FREE(ptrTemp);
                        Status = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }

                    pCounterPath  = (PVOID) (((PUCHAR)
                            CurrentContext->CounterPathBuffer) + CurrentSize);
                    RtlCopyMemory(pCounterPath,
                                  pCurrentPath->CounterPathBuffer,
                                  pCurrentPath->CounterPathSize);
                    CurrentSize += pCurrentPath->CounterPathSize;
                }
            }
        }
        pBinLogHeader = (PPDHI_BINARY_LOG_HEADER_RECORD)
                        CurrentContext->CounterPathBuffer;
        RtlZeroMemory(pBinLogHeader, sizeof(PDHI_BINARY_LOG_HEADER_RECORD));
        pBinLogHeader->RecHeader.dwType  = BINLOG_TYPE_CATALOG_LIST;
        pBinLogHeader->Info.dwLogVersion = BINLOG_VERSION;

        pBinLogHeader->RecHeader.dwLength = CurrentSize;
        CurrentContext->bCounterPathChanged = FALSE;
    }
    else if (CurrentContext->CounterPathBuffer == NULL) {
        return PDH_ENTRY_NOT_IN_LOG_FILE;
    }
    else {
        CurrentSize = ((PPDHI_BINARY_LOG_HEADER_RECORD)
                        CurrentContext->CounterPathBuffer)->RecHeader.dwLength;
    }

    if (pRecord != NULL) {
        if (dwMaxSize < CurrentSize) {
            CurrentSize = dwMaxSize;
            Status = PDH_MORE_DATA;
        }
        RtlCopyMemory(pRecord, CurrentContext->CounterPathBuffer, CurrentSize);
    }

Cleanup:
    return Status;
}

ULONG
WINAPI
PdhWmiFirstBufferCallback(
    PEVENT_TRACE_LOGFILEW LogFile)
{
    UNREFERENCED_PARAMETER(LogFile);
    return TRUE;
}

ULONG
WINAPI
PdhWmiBufferCallback(
    PEVENT_TRACE_LOGFILEW LogFile)
{
    ULONG               bResult;
    PPDH_LOGGER_CONTEXT CurrentContext;

    UNREFERENCED_PARAMETER(LogFile);
    CurrentContext = GetCurrentContext();
    bResult  = (CurrentContext && CurrentContext->LoggerState == PdhProcessTraceNormal)
             ? (TRUE) : (FALSE);
    return bResult;
}

void
WINAPI
PdhWmiFirstEventCallback(
    PEVENT_TRACE pEvent)
{
    DWORD               dwMofHeader;
    DWORD               dwCurrentBlock;
    DWORD               dwTotalBlocks;
    PPDH_LOGGER_CONTEXT CurrentContext;

    CurrentContext = GetCurrentContext();
    if (pEvent == NULL) {
        goto Cleanup;
    }
    else if (IsEqualGUID(& pEvent->Header.Guid, & EventTraceGuid)) {
        goto Cleanup;
    }
    else if (! IsEqualGUID(& pEvent->Header.Guid, & PdhTransactionGuid)) {
        goto Cleanup;
    }
    else if (CurrentContext == NULL) {
        goto Cleanup;
    }

    dwMofHeader = (pEvent->Header.Class.Version >= PDH_EVENT_VERSION)
                ? (sizeof(GUID) + sizeof(DWORD) + sizeof(DWORD))
                : (sizeof(GUID));

    switch (pEvent->Header.Class.Type) {
    case PDH_LOG_HEADER_EVENT:
        assert(pEvent->MofLength >= sizeof(PDH_WMI_LOG_INFO) + sizeof(GUID));
        PdhiAddWmiLogFileGuid(CurrentContext, (LPGUID) pEvent->MofData);
        if (pEvent->Header.Class.Version >= PDH_EVENT_VERSION) {
            dwCurrentBlock = * (DWORD *)
                    (((LPBYTE) pEvent->MofData) + sizeof(GUID));
            dwTotalBlocks  = * (DWORD *)
                    (((LPBYTE) pEvent->MofData) + sizeof(GUID) + sizeof(DWORD));
            PdhiAddCounterPathRecord(
                    CurrentContext,
                    pEvent,
                    (LPGUID) pEvent->MofData,
                    pEvent->MofLength - dwMofHeader,
                    (PVOID) (((PUCHAR) pEvent->MofData) + dwMofHeader),
                    pEvent->Header.TimeStamp.QuadPart,
                    dwCurrentBlock,
                    dwTotalBlocks,
                    & CurrentContext->bCounterPathChanged);
        }
        else {
            dwCurrentBlock = dwTotalBlocks = 1;
            PdhiAddCounterPathRecord(
                    CurrentContext,
                    pEvent,
                    (LPGUID) pEvent->MofData,
                    pEvent->MofLength - sizeof(GUID) - sizeof(PDH_WMI_LOG_INFO),
                    (PVOID) (((PUCHAR) pEvent->MofData)
                            + sizeof(GUID) + sizeof(PDH_WMI_LOG_INFO)),
                    pEvent->Header.TimeStamp.QuadPart,
                    dwCurrentBlock,
                    dwTotalBlocks,
                    & CurrentContext->bCounterPathChanged);
        }
        break;

    case PDH_LOG_DATA_BLOCK_EVENT:
        PdhWmiGetDataBlockTimeStamp(CurrentContext, pEvent, TRUE);
        PdhiWmiComputeCounterBlocks(CurrentContext, pEvent);
        break;

    case PDH_LOG_COUNTER_STRING_EVENT:
        PdhiAddWmiLogFileGuid(CurrentContext, (LPGUID) pEvent->MofData);
        PdhiAddPerfMachine(CurrentContext, pEvent->MofData, pEvent->MofLength);
        break;

    default:
        DebugPrint((4, "PdhWmiFirstEventCallback(), unknown EventType %d\n",
                pEvent->Header.Class.Type));
        break;
    }

Cleanup:
    return;
}

void
WINAPI
PdhWmiEventCallback(
    PEVENT_TRACE pEvent)
{
    LPGUID              pLogFileGuid;
    ULONG               iLogFile;
    BOOLEAN             bNotifyPDH      = FALSE;
    ULONGLONG           EventTime       = 0;
    ULONGLONG           EventTimePrev   = 0;
    DWORD               dwNumDataBlocks = 0;
    DWORD               dwBlockIndex    = 0;
    DWORD               dwBufferSize    = 0;
    PPDH_LOGGER_CONTEXT CurrentContext  = GetCurrentContext();

    if (CurrentContext == NULL) {
        goto Cleanup;
    }

    if (pEvent == NULL) {
        DebugPrint((4, "PdhWmiEventCallback() with NULL PEVENT_TRACE\n"));
        goto Cleanup;
    }
    else if (IsEqualGUID(& pEvent->Header.Guid, & EventTraceGuid)) {
        goto Cleanup;
    }
    else if ((CurrentContext->LoggerState != PdhProcessTraceNormal) ||
             (! IsEqualGUID(& pEvent->Header.Guid, & PdhTransactionGuid))) {
        goto Cleanup;
    }

    switch (pEvent->Header.Class.Type) {
    case PDH_LOG_HEADER_EVENT:
    case PDH_LOG_COUNTER_STRING_EVENT:
        // counter path information has been collected during the first run
        //
        break;

    case PDH_LOG_DATA_BLOCK_EVENT:
        pLogFileGuid  = (LPGUID) pEvent->MofData;
        iLogFile      = PdhiFindLogFileGuid(CurrentContext, pLogFileGuid);

        if (iLogFile >= CurrentContext->LoggerCount) {
            break;
        }

        EventTimePrev = CurrentContext->LogInfo[iLogFile].TimePrev;
        EventTime     = PdhWmiGetDataBlockTimeStamp(CurrentContext, pEvent, FALSE);
        if (EventTime == 0 || EventTimePrev > EventTime) {
            break;
        }

        if (   pEvent->Header.Class.Version < PDH_EVENT_VERSION
            || EventTimePrev < EventTime) {
            dwNumDataBlocks = * (DWORD *) (  ((LPBYTE) pEvent->MofData)
                                           + sizeof(GUID) + sizeof(DWORD));
            dwBufferSize = (pEvent->Header.Class.Version >= PDH_EVENT_VERSION)
                    ? (dwNumDataBlocks * PDH_BLOCK_BUFFER_SIZE + sizeof(GUID))
                    : (pEvent->MofLength);

            if (CurrentContext->LogInfo[iLogFile].DataBlock == NULL) {
                CurrentContext->LogInfo[iLogFile].DataBlock = G_ALLOC(dwBufferSize);
            }
            else if (   CurrentContext->LogInfo[iLogFile].DataBlockAlloc
                     < dwBufferSize) {
                PVOID ptrTemp = CurrentContext->LogInfo[iLogFile].DataBlock;
                CurrentContext->LogInfo[iLogFile].DataBlock = G_REALLOC(ptrTemp, dwBufferSize);
                if (CurrentContext->LogInfo[iLogFile].DataBlock == NULL) {
                    G_FREE(ptrTemp);
                }
            }
            if (   (CurrentContext->LogInfo[iLogFile].DataBlock != NULL)
                && (pEvent->Header.Class.Version >= PDH_EVENT_VERSION)) {
                RtlCopyMemory(CurrentContext->LogInfo[iLogFile].DataBlock,
                              pLogFileGuid,
                              sizeof(GUID));
                CurrentContext->LogInfo[iLogFile].DataBlockSize   = sizeof(GUID);
                CurrentContext->LogInfo[iLogFile].DataBlockAlloc  = dwBufferSize;
                CurrentContext->LogInfo[iLogFile].ulNumDataBlocks = dwNumDataBlocks;
                CurrentContext->LogInfo[iLogFile].ulDataBlocksCopied = 0;
            }
        }

        dwBlockIndex = * (DWORD *) (((LPBYTE) pEvent->MofData) + sizeof(GUID));
        if (CurrentContext->LogInfo[iLogFile].DataBlock != NULL) {
            if (pEvent->Header.Class.Version >= PDH_EVENT_VERSION) {
                PVOID ptrDataBlock = (PVOID)
                        (  ((LPBYTE) CurrentContext->LogInfo[iLogFile].DataBlock)
                         + sizeof(GUID)
                         + PDH_BLOCK_BUFFER_SIZE * (dwBlockIndex - 1));
                RtlCopyMemory(ptrDataBlock,
                              (PVOID) (((LPBYTE) pEvent->MofData)
                                  + sizeof(GUID) + sizeof(DWORD) + sizeof(DWORD)),
                              pEvent->MofLength - sizeof(GUID)
                                  - sizeof(DWORD) - sizeof(DWORD));
                CurrentContext->LogInfo[iLogFile].ulDataBlocksCopied ++;
                CurrentContext->LogInfo[iLogFile].DataBlockSize +=
                        pEvent->MofLength - sizeof(GUID)
                                          - sizeof(DWORD) - sizeof(DWORD);
            }
            else {
                RtlCopyMemory(CurrentContext->LogInfo[iLogFile].DataBlock,
                              pEvent->MofData,
                              pEvent->MofLength);
                CurrentContext->LogInfo[iLogFile].DataBlockSize = pEvent->MofLength;
            }
        }

        if (pEvent->Header.Class.Version < PDH_EVENT_VERSION) {
            if (DataBlockInfo.CurrentTime == (ULONGLONG) 0) {
                // no CurrentTime comparison, just get the data block
                //
                DataBlockInfo.CurrentTime = EventTime;
            }

            if (DataBlockInfo.CurrentTime <= EventTime) {
                DataBlockInfo.pRecord =
                        CurrentContext->LogInfo[iLogFile].DataBlock;
                DataBlockInfo.dwCurrentSize = pEvent->MofLength;
                DataBlockInfo.Status        = ERROR_SUCCESS;
                bNotifyPDH = TRUE;
                CurrentContext->bDataBlockProcessed = FALSE;
            }
        }
        else if (   CurrentContext->LogInfo[iLogFile].ulDataBlocksCopied
                 >= CurrentContext->LogInfo[iLogFile].ulNumDataBlocks) {
            if (DataBlockInfo.CurrentTime == (ULONGLONG) 0) {
                // no CurrentTime comparison, just get the data block
                //
                DataBlockInfo.CurrentTime = EventTime;
            }

            if (DataBlockInfo.CurrentTime <= EventTime) {
                DataBlockInfo.pRecord       =
                        CurrentContext->LogInfo[iLogFile].DataBlock;
                DataBlockInfo.dwCurrentSize =
                        CurrentContext->LogInfo[iLogFile].DataBlockSize;
                DataBlockInfo.Status        = ERROR_SUCCESS;
                bNotifyPDH = TRUE;
                CurrentContext->bDataBlockProcessed = FALSE;
            }
        }
        break;

    default:
        DebugPrint((4, "PdhWmiEventCallback(), unknown EventType %d\n",
                pEvent->Header.Class.Type));
        break;
    }

Cleanup:
    if (bNotifyPDH) {
        // Signal that we get the current DataBlock event, then wait for next
        // DataBlock requests.
        //
        SetEvent(CurrentContext->hSyncPDH);
        WaitForSingleObject(CurrentContext->hSyncWMI, INFINITE);
    }
}

PDH_FUNCTION
PdhProcessLog(
    PPDH_LOGGER_CONTEXT CurrentContext)
{
    PDH_STATUS  Status = ERROR_SUCCESS;
    LONG        i;

    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return PDH_INVALID_HANDLE;
    }
    CurrentContext->bFirstRun = TRUE;
    CurrentContext->dwThread  = GetCurrentThreadId();

    do {
        CurrentContext->LoggerState         = PdhProcessTraceNormal;
        CurrentContext->bFirstDataBlockRead = FALSE;
        CurrentContext->bDataBlockProcessed = FALSE;
        for (i = 0; i < (LONG) CurrentContext->LoggerCount; i ++) {
            CurrentContext->LogInfo[i].TimePrev = 0;
            if (CurrentContext->LogInfo[i].DataBlock) {
                G_FREE(CurrentContext->LogInfo[i].DataBlock);
                CurrentContext->LogInfo[i].DataBlock = NULL;
            }
            CurrentContext->LogInfo[i].DataBlockSize = 0;
        }

        RtlZeroMemory(& DataBlockInfo, sizeof(PDH_DATA_BLOCK_TRANSFER));
        Status = ProcessTrace(CurrentContext->LogFileHandle,
                              CurrentContext->LogFileCount,
                              NULL,
                              NULL);
        if (Status != ERROR_SUCCESS && Status != ERROR_CANCELLED) {
            DebugPrint((4, "ProcessTrace(0x%08X,%d) fails (%d,0x%08X)\n",
                    CurrentContext,
                    CurrentContext->LogFileCount,
                    Status,
                    Status));
        }

        if (CurrentContext->bFirstRun) {
            CurrentContext->bFirstRun   = FALSE;
            CurrentContext->LoggerState = PdhProcessTraceRewind;
            CurrentContext->TimeFreq    = CurrentContext->LogInfo[0].TimeFreq;
            for (i = 1; i < (LONG) CurrentContext->LogFileCount; i ++) {
                if (  CurrentContext->TimeFreq
                    > CurrentContext->LogInfo[i].TimeFreq) {
                    CurrentContext->TimeFreq =
                                    CurrentContext->LogInfo[i].TimeFreq;
                }
            }
        }
        else if (CurrentContext->LoggerState == PdhProcessTraceNormal) {
            CurrentContext->LoggerState = PdhProcessTraceComplete;
            DataBlockInfo.Status = PDH_END_OF_LOG_FILE;

            // Wake up PDH main thread so that PdhiReadNextWmiRecord() will
            // notice END_OF_LOG_FILE condition. Wait PDH main thread to wake
            // me up and rewind logger. After wake up, LoggerState should
            // be reset to PdhProcessTraceNormal.
            //
            SetEvent(CurrentContext->hSyncPDH);
            Status = WaitForSingleObject(CurrentContext->hSyncWMI,
                                         INFINITE);
            assert(CurrentContext->LoggerState == PdhProcessTraceRewind);
        }

        for (i = 0; i < (LONG) CurrentContext->LogFileCount; i ++) {
            Status = CloseTrace(CurrentContext->LogFileHandle[i]);
            if (Status != ERROR_SUCCESS) {
                DebugPrint((4, "CloseTrace(%d,%ws) fails (%d,0x%08X)\n",
                        CurrentContext->LogFileHandle[i],
                        CurrentContext->LogFileName[i],
                        Status,
                        Status));
            }
        }

        if (CurrentContext->LoggerState == PdhProcessTraceRewind) {
            EVENT_TRACE_LOGFILEW EvmFile;

            for (i = 0; i < (LONG) CurrentContext->LogFileCount; i ++) {
                RtlZeroMemory(& EvmFile, sizeof(EVENT_TRACE_LOGFILE));
                EvmFile.BufferCallback = PdhWmiBufferCallback;
                EvmFile.EventCallback  = PdhWmiEventCallback;
                EvmFile.LogFileName    = CurrentContext->LogFileName[i];

                CurrentContext->LogFileHandle[i] = OpenTraceW(& EvmFile);

                if (   CurrentContext->LogFileHandle[i] == 0
                    || CurrentContext->LogFileHandle[i] ==
                                (TRACEHANDLE) INVALID_HANDLE_VALUE) {
                    DebugPrint((4,"OpenTraceW(%d,%ws) fails\n",
                            i,
                            CurrentContext->LogFileName[i]));

                    while (--i >= 0) {
                        CloseTrace(CurrentContext->LogFileHandle[i]);
                    }

                    Status = PDH_LOG_FILE_OPEN_ERROR;
                    DataBlockInfo.Status = PDH_LOG_FILE_OPEN_ERROR;
                    SetEvent(CurrentContext->hSyncPDH);
                    goto Cleanup;
                }
            }
        }

    } while (CurrentContext->LoggerState == PdhProcessTraceRewind);

Cleanup:
    CurrentContext->LoggerState = PdhProcessTraceExit;
    return Status;
}

PDH_FUNCTION
PdhiOpenInputWmiLog(
    IN PPDHI_LOG pLog)
{
    PDH_STATUS           Status         = ERROR_SUCCESS;
    PPDHI_LOG            pLogCurrent    = pLog;
    PPDH_LOGGER_CONTEXT  CurrentContext;
    EVENT_TRACE_LOGFILEW EvmFile;
    WCHAR                LogFileName[PDH_MAX_PATH];
    LONG                 i;
    DWORD                ThreadId;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (CurrentContext != NULL) {
        if (GetLoggerContext(CurrentContext) < ContextCount) {
            CurrentContext->RefCount ++;
            pLog->lpMappedFileBase = (PVOID) CurrentContext;
            return ERROR_SUCCESS;
        }
        else {
            DebugPrint((4, "PdhiOpenInputWmiLog(0x%08X,0x%08X,0x%08X)\n",
                    pLog,
                    pLog->lpMappedFileBase,
                    CurrentContext));
            return PDH_INVALID_ARGUMENT;
        }
    }

    CurrentContext = (PPDH_LOGGER_CONTEXT) G_ALLOC(sizeof(PDH_LOGGER_CONTEXT));
    if (CurrentContext == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    pLog->lpMappedFileBase = (PVOID) CurrentContext;
    RtlZeroMemory(CurrentContext, sizeof(PDH_LOGGER_CONTEXT));


    for (i = 0; i < PDH_MAX_LOGFILES && pLogCurrent; i ++) {
        CurrentContext->LogFileName[i] = pLogCurrent->szLogFileName;
        pLogCurrent                    = pLogCurrent->NextLog;
    }
    CurrentContext->LogFileCount = i;
    CurrentContext->LoggerCount  = 0;

    for (i = 0; i < (LONG) CurrentContext->LogFileCount; i ++) {
        InitializeListHead(& CurrentContext->LogInfo[i].CounterPathList);
        InitializeListHead(& CurrentContext->LogInfo[i].PerfMachineList);
    }
    CurrentContext->RefCount = 1;
    CurrentContext->hSyncWMI = CreateEvent(NULL, FALSE, FALSE, NULL);
    CurrentContext->hSyncPDH = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (CurrentContext->hSyncWMI == NULL || CurrentContext->hSyncPDH == NULL) {
        Status = PDH_INVALID_HANDLE;
        goto Cleanup;
    }

    Status = WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex);
    if (Status == ERROR_SUCCESS) {
        if (ContextCount < PDH_MAX_LOGFILES) {
            ContextTable[ContextCount] = CurrentContext;
            ContextCount ++;
        }
        else {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        RELEASE_MUTEX(hPdhContextMutex);
    }
    if (Status != ERROR_SUCCESS) {
        goto Cleanup;
    }

    for (i = 0; i < (LONG) CurrentContext->LogFileCount; i ++) {
        RtlZeroMemory(& EvmFile, sizeof(EVENT_TRACE_LOGFILE));
        EvmFile.BufferCallback = PdhWmiFirstBufferCallback;
        EvmFile.EventCallback  = PdhWmiFirstEventCallback;
        EvmFile.LogFileName    = LogFileName;
        _wfullpath(EvmFile.LogFileName,
                   CurrentContext->LogFileName[i],
                   PDH_MAX_PATH);
        CurrentContext->LogFileHandle[i] = OpenTraceW(& EvmFile);
        if (   CurrentContext->LogFileHandle[i] == 0
            || CurrentContext->LogFileHandle[i] ==
                       (TRACEHANDLE) INVALID_HANDLE_VALUE) {
            DebugPrint((4,"OpenTraceW(%d,%ws) fails\n",
                    i,
                    CurrentContext->LogFileName[i]));

            while (--i >= 0) {
                CloseTrace(CurrentContext->LogFileHandle[i]);
            }

            Status = PDH_LOG_FILE_OPEN_ERROR;
            goto Cleanup;
        }
    }

    CurrentContext->hThreadWork = CreateThread(
                     NULL,
                     0,
                     (LPTHREAD_START_ROUTINE) PdhProcessLog,
                     CurrentContext,
                     0,
                     (LPDWORD) & ThreadId);
    if (CurrentContext->hThreadWork == NULL) {
        Status = GetLastError();
        DebugPrint((4, "CreateThread() fails (%d,0x%08X)\n",
                Status, Status));
        for (i = 0; i < (LONG) CurrentContext->LogFileCount; i ++) {
            Status = CloseTrace(CurrentContext->LogFileHandle[i]);
            if (Status != ERROR_SUCCESS) {
                DebugPrint((4, "CloseTrace(0x%08X,%ws) fails (%d,0x%08X)\n",
                        CurrentContext->LogFileHandle[i],
                        CurrentContext->LogFileName[i],
                        Status,
                        Status));
            }
        }
        goto Cleanup;
    }

    WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);

Cleanup:
    if (Status != ERROR_SUCCESS) {
        if (CurrentContext != NULL) {
            DWORD dwContext = GetLoggerContext(CurrentContext);
            if (dwContext < ContextCount) {
                if (   WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex)
                    == ERROR_SUCCESS) {
                    if (dwContext != ContextCount - 1) {
                        ContextTable[dwContext] = ContextTable[ContextCount - 1];
                    }
                    ContextTable[ContextCount - 1] = NULL;
                    ContextCount --;
                    RELEASE_MUTEX(hPdhContextMutex);
                }
                else {
                    ContextTable[dwContext] = NULL;
                }
            }
            if (CurrentContext->hSyncWMI) {
                CloseHandle(CurrentContext->hSyncWMI);
            }
            if (CurrentContext->hSyncPDH) {
                CloseHandle(CurrentContext->hSyncPDH);
            }
            G_FREE(CurrentContext);
            CurrentContext = NULL;
        }
        pLog->lpMappedFileBase = NULL;
    }
    return Status;
}

PDH_FUNCTION
PdhiRewindWmiLog(
    IN PPDHI_LOG pLog)
{
    PDH_STATUS          Status  = PDH_INVALID_HANDLE;
    PPDH_LOGGER_CONTEXT CurrentContext;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) < ContextCount) {
        CurrentContext->LoggerState = PdhProcessTraceRewind;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        Status = ERROR_SUCCESS;
    }

    return Status;
}

PDH_FUNCTION
PdhiReadWmiHeaderRecord(
    IN PPDHI_LOG pLog,
    IN LPVOID    pRecord,
    IN DWORD     dwMaxSize)
{
    PDH_STATUS          Status   = ERROR_SUCCESS;
    PPDH_LOGGER_CONTEXT CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;

    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return PDH_INVALID_HANDLE;
    }

    // Wait until logfiles are scaned first to collect
    // 1) Counter Path information
    // 2) Time Range information
    //
    while (CurrentContext->bFirstRun) {
        _sleep(1);
    }

    Status = PdhiGetCounterPathRecord(CurrentContext, pRecord, dwMaxSize);
    pLog->pLastRecordRead = CurrentContext->CounterPathBuffer;
    return Status;
}

PDH_FUNCTION
PdhiBuildDataBlock(
    IN PPDHI_LOG pLog,
    IN ULONGLONG TimeStamp)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    LONG       Offset    = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
    LONG       CopySize;
    LONG       CheckSize;
    ULONG      i;
    LONG       CurrentSize = PDH_WMI_BUFFER_SIZE_BYTE;

    PPDH_LOGGER_CONTEXT            CurrentContext;
    PPDHI_BINARY_LOG_RECORD_HEADER pHeader;
    PVOID                          pBlock;
    PPDHI_BINARY_LOG_RECORD_HEADER pCounterHeader;
    PPDH_RAW_COUNTER               pSingleCounter;
    PPDHI_LOG_COUNTER_PATH         pCounterPath;

    BOOLEAN bValidBlock;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return PDH_INVALID_HANDLE;
    }

    if (CurrentContext->tmpBuffer != NULL) {
        G_FREE(CurrentContext->tmpBuffer);
        CurrentContext->tmpBuffer = NULL;
    }
    pHeader = (PPDHI_BINARY_LOG_RECORD_HEADER) 
              G_ALLOC(PDH_WMI_BUFFER_SIZE_BYTE);
    if (pHeader == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }
    pHeader->dwType = BINLOG_TYPE_DATA;

    for (i = 0; i < CurrentContext->LoggerCount; i ++) {
        CopySize = CurrentContext->LogInfo[i].DataBlockSize
                 - sizeof(GUID) - sizeof(PDHI_BINARY_LOG_RECORD_HEADER);

        bValidBlock = TRUE;

        if (Offset + CopySize > CurrentSize) {
            while (Offset + CopySize > CurrentSize) {
                CurrentSize += PDH_WMI_BUFFER_SIZE_BYTE;
            }
            CurrentContext->tmpBuffer = pHeader;
            pHeader = G_REALLOC(CurrentContext->tmpBuffer, CurrentSize);
            if (pHeader == NULL) {
                G_FREE(CurrentContext->tmpBuffer);
                CurrentContext->tmpBuffer = NULL;
                return PDH_MEMORY_ALLOCATION_FAILURE;
            }
            CurrentContext->tmpBuffer = NULL;
        }
        pBlock   = (PVOID) (((PUCHAR) pHeader) + Offset);

        if (   (CurrentContext->LogInfo[i].DataBlock)
            && (CopySize > 0)
            && (   DataBlockInfo.CurrentTime
                <= CurrentContext->LogInfo[i].TimeEnd)) {

            CheckSize = sizeof(GUID);
            while (bValidBlock && CheckSize < CopySize) {
                pCounterHeader = (PPDHI_BINARY_LOG_RECORD_HEADER)
                        (((PUCHAR) CurrentContext->LogInfo[i].DataBlock) + CheckSize);
                if (LOWORD(pCounterHeader->dwType) == BINLOG_START_WORD) {
                    CheckSize += pCounterHeader->dwLength;
                }
                else {
                    bValidBlock = FALSE;
                }
            }
        }
        else {
            bValidBlock = FALSE;
        }

        if (bValidBlock == TRUE) {
            RtlCopyMemory(
                pBlock,
                (PVOID) (  ((PUCHAR) CurrentContext->LogInfo[i].DataBlock)
                         + sizeof(GUID)
                         + sizeof(PDHI_BINARY_LOG_RECORD_HEADER)),
                CopySize);
            Offset += CopySize;
        }
        else {
            // need to sneak in pseudo counter block
            //
            PVOID             pCounterBlock;
            ULONG             BlockSize = 0;
            ULONG             j;

            for (j = 0; j < CurrentContext->LogInfo[i].ulCounters; j ++) {
                pBlock       = (PVOID) (((PUCHAR) pHeader) + Offset);
                RtlCopyMemory(pBlock,
                              & PdhNullCounterHeader,
                              sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                pSingleCounter = (PPDH_RAW_COUNTER) (((PUCHAR) pBlock)
                                + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                RtlCopyMemory(pSingleCounter,
                              & PdhNullCounter,
                              sizeof(PDH_RAW_COUNTER));
                pSingleCounter->TimeStamp.dwLowDateTime  = LODWORD(TimeStamp);
                pSingleCounter->TimeStamp.dwHighDateTime = HIDWORD(TimeStamp);
                Offset         = Offset + sizeof(PDH_RAW_COUNTER)
                               + sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
            }
        }
    }
    pHeader->dwLength = Offset;
    CurrentContext->tmpBuffer = pHeader;

    return pdhStatus;
}

PDH_FUNCTION
PdhiReadNextWmiRecord(
    IN PPDHI_LOG pLog,
    IN LPVOID    pRecord,
    IN DWORD     dwMaxSize,
    IN BOOLEAN   bAllCounter)
{
    PDH_STATUS          Status = ERROR_SUCCESS;
    PPDH_LOGGER_CONTEXT CurrentContext;
    ULONGLONG           CurrentTime;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        Status = PDH_INVALID_HANDLE;
        goto Cleanup;
    }

    // Wait until logfiles are scaned first to collect
    // 1) Counter Path information
    // 2) Time Range information
    //
    while (CurrentContext->bFirstRun) {
        _sleep(1);
    }

    if (CurrentContext->LoggerState == PdhProcessTraceComplete) {
        CurrentContext->LoggerState = PdhProcessTraceRewind;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        Status = PDH_END_OF_LOG_FILE;
        goto Cleanup;
    }

    if (! CurrentContext->bFirstDataBlockRead) {
        CurrentContext->bFirstDataBlockRead = TRUE;
        CurrentContext->bDataBlockProcessed = TRUE;
    }
    else if (! CurrentContext->bDataBlockProcessed) {
        CurrentContext->bDataBlockProcessed = TRUE;
    }
    else {
        DataBlockInfo.CurrentTime = (ULONGLONG) 0;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
    }

    if (CurrentContext->LoggerState == PdhProcessTraceComplete) {
        CurrentContext->LoggerState = PdhProcessTraceRewind;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        Status = PDH_END_OF_LOG_FILE;
        goto Cleanup;
    }

    if (bAllCounter && CurrentContext->LogFileCount > 1) {
        CurrentTime = DataBlockInfo.CurrentTime;

        while (   (CurrentContext->LoggerState != PdhProcessTraceComplete)
               && (DataBlockInfo.CurrentTime - CurrentTime <= TIME_DELTA)) {
            DataBlockInfo.CurrentTime = (ULONGLONG) 0;
            SetEvent(CurrentContext->hSyncWMI);
            WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        }

        CurrentContext->bDataBlockProcessed = FALSE;
        Status = DataBlockInfo.Status;
        if (Status == ERROR_SUCCESS) {
            Status = PdhiBuildDataBlock(pLog, CurrentTime);
        }
        if (Status == ERROR_SUCCESS) {
            pLog->pLastRecordRead = CurrentContext->tmpBuffer;
        }
    }
    else {
        if (bAllCounter) {
            pLog->pLastRecordRead =
                    (((PUCHAR) DataBlockInfo.pRecord) + sizeof(GUID));
        }
        else {
            pLog->pLastRecordRead = ((PUCHAR) DataBlockInfo.pRecord);
        }
        CurrentContext->bDataBlockProcessed = TRUE;
        Status = DataBlockInfo.Status;
    }

    if (Status == ERROR_SUCCESS) {
        if (dwMaxSize < DataBlockInfo.dwCurrentSize - sizeof(GUID)) {
            Status = PDH_MORE_DATA;
        }
        if (pRecord) {
            RtlCopyMemory(pRecord,
                     pLog->pLastRecordRead,
                     (Status == ERROR_SUCCESS) ? (DataBlockInfo.dwCurrentSize)
                                               : (dwMaxSize));
        }
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiReadTimeWmiRecord(
    IN PPDHI_LOG pLog,
    IN ULONGLONG TimeStamp,
    IN LPVOID    pRecord,
    IN DWORD     dwMaxSize)
{
    PDH_STATUS          Status      = ERROR_SUCCESS;
    PPDH_LOGGER_CONTEXT CurrentContext;
    BOOLEAN             TimeInRange = FALSE;
    BOOLEAN             bRewind     = TRUE;
    ULONG               i;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        Status = PDH_INVALID_HANDLE;
        goto Cleanup;
    }

    if (TimeStamp == MIN_TIME_VALUE) {
        TimeStamp = CurrentContext->LogInfo[0].TimeStart;
    }
    if (TimeStamp == MAX_TIME_VALUE) {
        TimeStamp = CurrentContext->LogInfo[0].TimeEnd;
    }
    for (i = 0; i < (ULONG) CurrentContext->LoggerCount; i ++) {
        if (   TimeStamp >= CurrentContext->LogInfo[i].TimeStart
            && TimeStamp <= CurrentContext->LogInfo[i].TimeEnd) {
            TimeInRange = TRUE;
            break;
        }
    }

    if (! TimeInRange) {
        Status = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    // Wait until logfiles are scaned first to collect
    // 1) Counter Path information
    // 2) Time Range information
    //
    while (CurrentContext->bFirstRun) {
        _sleep(1);
    }

    if (CurrentContext->LoggerState == PdhProcessTraceComplete) {
        CurrentContext->LoggerState = PdhProcessTraceRewind;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        Status = PDH_END_OF_LOG_FILE;
        goto Cleanup;
    }

ReScan:
    if (! CurrentContext->bFirstDataBlockRead) {
        CurrentContext->bFirstDataBlockRead = TRUE;
        CurrentContext->bDataBlockProcessed = TRUE;
    }
    else if (! CurrentContext->bDataBlockProcessed) {
        CurrentContext->bDataBlockProcessed = TRUE;
    }
    else {
        DataBlockInfo.CurrentTime = 0;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
    }

    if (CurrentContext->LoggerState == PdhProcessTraceComplete) {
        CurrentContext->LoggerState = PdhProcessTraceRewind;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        Status = PDH_END_OF_LOG_FILE;
        goto Cleanup;
    }
    else if (DataBlockInfo.CurrentTime > TimeStamp) {
        if (bRewind) {
            bRewind = FALSE;
            CurrentContext->LoggerState = PdhProcessTraceRewind;
            SetEvent(CurrentContext->hSyncWMI);
            WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
            goto ReScan;
        }
    }

    while (   (CurrentContext->LoggerState != PdhProcessTraceComplete)
           && ((  ((LONGLONG) TimeStamp)
                - ((LONGLONG) DataBlockInfo.CurrentTime))
                > TIME_DELTA)) {
        DataBlockInfo.CurrentTime = (ULONGLONG) 0;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
    }

    CurrentContext->bDataBlockProcessed = TRUE;
    Status = DataBlockInfo.Status;
    if (Status == ERROR_SUCCESS) {
        Status = PdhiBuildDataBlock(pLog, TimeStamp);
    }
    if (Status == ERROR_SUCCESS) {
        pLog->pLastRecordRead = CurrentContext->tmpBuffer;
    }

    if (Status == ERROR_SUCCESS) {
        if (dwMaxSize < DataBlockInfo.dwCurrentSize - sizeof(GUID)) {
            Status = PDH_MORE_DATA;
        }
        if (pRecord) {
            RtlCopyMemory(pRecord,
                     (((PUCHAR) DataBlockInfo.pRecord) + sizeof(GUID)),
                     (Status == ERROR_SUCCESS) ? (DataBlockInfo.dwCurrentSize)
                                               : (dwMaxSize));
        }
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiGetTimeRangeFromWmiLog (
    IN PPDHI_LOG      pLog,
    IN LPDWORD        pdwNumEntries,
    IN PPDH_TIME_INFO pInfo,
    IN LPDWORD        pdwBufferSize)
{
    PDH_STATUS          Status = ERROR_SUCCESS;
    PPDH_LOGGER_CONTEXT CurrentContext;
    ULONG               i;
    ULONGLONG           StartTime;
    ULONGLONG           EndTime;
    ULONG               EntryCount;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return PDH_INVALID_HANDLE;
    }

    // Wait until logfiles are scaned first to collect
    // 1) Counter Path information
    // 2) Time Range information
    //
    while (CurrentContext->bFirstRun) {
        _sleep(1);
    }

    for (StartTime  = CurrentContext->LogInfo[0].TimeStart,
         EndTime    = CurrentContext->LogInfo[0].TimeEnd,
         EntryCount = CurrentContext->LogInfo[0].ValidEntries,
         i = 1;
         i < CurrentContext->LoggerCount;
         i ++) {
        if (   StartTime == 0
            || (   CurrentContext->LogInfo[i].TimeStart != 0
                && StartTime > CurrentContext->LogInfo[i].TimeStart)) {
            StartTime = CurrentContext->LogInfo[i].TimeStart;
        }
        if (EndTime   < CurrentContext->LogInfo[i].TimeEnd)
            EndTime   = CurrentContext->LogInfo[i].TimeEnd;
        EntryCount   += CurrentContext->LogInfo[i].ValidEntries;
    }

    if (* pdwBufferSize >=  sizeof(PDH_TIME_INFO)) {
        * (LONGLONG *) (& pInfo->StartTime) = StartTime;
        * (LONGLONG *) (& pInfo->EndTime)   = EndTime;
        pInfo->SampleCount                  = EntryCount;
        * pdwBufferSize                     = sizeof(PDH_TIME_INFO);
        * pdwNumEntries                     = 1;
    }
    else {
        Status = PDH_MORE_DATA;
    }

    return Status;
}

PPDH_WMI_PERF_MACHINE
PdhWmiGetLogNameTable(
    IN  PPDHI_LOG pLog,
    IN  LPCWSTR   szMachineName,
    IN  DWORD     dwLangId
)
{
    PPDH_WMI_PERF_MACHINE pReturnMachine = NULL;
    PPDH_LOGGER_CONTEXT   CurrentContext;
    DWORD                 i;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return NULL;
    }

    for (i = 0;
         pReturnMachine == NULL && i < CurrentContext->LoggerCount;
         i ++) {
        if (! IsListEmpty(& CurrentContext->LogInfo[i].PerfMachineList)) {
            PLIST_ENTRY pHead = & CurrentContext->LogInfo[i].PerfMachineList;
            PLIST_ENTRY pNext = pHead->Flink;
            while (pNext != pHead) {
                PPDH_WMI_PERF_MACHINE pMachine =
                        CONTAINING_RECORD(pNext, PDH_WMI_PERF_MACHINE, Entry);
                if (lstrcmpiW(pMachine->pszBuffer, szMachineName) == 0) {
                    pReturnMachine = pMachine;
                    break;
                }
                pNext = pNext->Flink;
            }
        }
    }
    return pReturnMachine;
}

PPDH_WMI_PERF_OBJECT
PdhWmiAddPerfObject(
    IN  PPDHI_LOG        pLog,
    IN  LPCWSTR          szMachineName,
    IN  DWORD            dwLangId,
    IN  LPCWSTR          szObjectName,
    IN  DWORD            dwObjectId,
    IN  PPERF_DATA_BLOCK pDataBlock
)
{
    PPDH_WMI_PERF_OBJECT  pPerfObject  = NULL;
    PPDH_WMI_PERF_MACHINE pPerfMachine =
                    PdhWmiGetLogNameTable(pLog, szMachineName, dwLangId);

    PLIST_ENTRY           pHead;
    PLIST_ENTRY           pNext;
    PPDH_WMI_PERF_OBJECT  pCurrentObj;

    if (pPerfMachine == NULL) {
        SetLastError(PDH_ENTRY_NOT_IN_LOG_FILE);
        goto Cleanup;
    }

    pHead = & pPerfMachine->LogObjectList;
    pNext = pHead->Flink;
    while (pNext != pHead) {
        pCurrentObj = CONTAINING_RECORD(pNext, PDH_WMI_PERF_OBJECT, Entry);
        if (lstrcmpiW(pCurrentObj->szObjectName, szObjectName) == 0) {
            pPerfObject = pCurrentObj;
            break;
        }
        pNext = pNext->Flink;
    }

    if (pPerfObject != NULL) {
        goto Cleanup;
    }

    pPerfObject = G_ALLOC(sizeof(PDH_WMI_PERF_OBJECT));
    if (pPerfObject == NULL) {
        SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
        goto Cleanup;
    }
    pPerfObject->ptrBuffer = G_ALLOC(pDataBlock->TotalByteLength
                           + sizeof(WCHAR) * (lstrlenW(szObjectName) + 1));
    if (pPerfObject->ptrBuffer == NULL) {
        G_FREE(pPerfObject);
        SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
        goto Cleanup;
    }
    pPerfObject->dwObjectId = dwObjectId;
    RtlCopyMemory(pPerfObject->ptrBuffer,
                  pDataBlock,
                  pDataBlock->TotalByteLength);
    pPerfObject->szObjectName = (LPWSTR)
            (((LPBYTE) pPerfObject->ptrBuffer) + pDataBlock->TotalByteLength);
    lstrcpyW(pPerfObject->szObjectName, szObjectName);
    InsertTailList(& pPerfMachine->LogObjectList, & pPerfObject->Entry);

Cleanup:
    return pPerfObject;
}

DWORD
PdhWmiGetLogPerfIndexByName(
    IN  PPDHI_LOG pLog,
    IN  LPCWSTR   szMachineName,
    IN  DWORD     dwLangId,
    IN  LPCWSTR   szNameBuffer
)
{
    PPDH_WMI_PERF_MACHINE pMachine;
    DWORD                 dwLastIndex;
    LPWSTR              * pNameArray;
    DWORD                 dwIndex;

    SetLastError(ERROR_SUCCESS);

    pMachine = PdhWmiGetLogNameTable(pLog, szMachineName, dwLangId);
    if (pMachine != NULL && pMachine->ptrStrAry != NULL) {
        dwLastIndex = pMachine->dwLastId;
        pNameArray  = pMachine->ptrStrAry;

        for (dwIndex = 1; dwIndex <= dwLastIndex; dwIndex ++) {
            if (lstrcmpiW(szNameBuffer, pNameArray[dwIndex]) == 0) {
                if ((dwIndex & 0x00000001) == 0) {
                    // counter name index should be even integer
                    //
                    break;
                }
            }
        }

        if (dwIndex > dwLastIndex) {
            SetLastError(PDH_STRING_NOT_FOUND);
            dwIndex = 0;
        }
    }
    else {
        SetLastError(PDH_ENTRY_NOT_IN_LOG_FILE);
        dwIndex = 0;
    }

    return dwIndex;
}

LPWSTR
PdhWmiGetLogPerfNameByIndex (
    IN  PPDHI_LOG pLog,
    IN  LPCWSTR   szMachineName,
    IN  DWORD     dwLangId,
    IN  DWORD     dwIndex
)
{
    PPDH_WMI_PERF_MACHINE pMachine;
    LPWSTR                pszReturnName = NULL;
    LPWSTR              * pNameArray;
    static WCHAR          szNumber[16];

    pMachine = PdhWmiGetLogNameTable(pLog, szMachineName, dwLangId);
    if (pMachine != NULL && pMachine->ptrStrAry != NULL
                         && dwIndex < pMachine->dwLastId) {
        pNameArray    = pMachine->ptrStrAry;
        pszReturnName = pNameArray[dwIndex];
    }

    if (pszReturnName == NULL) {
        // unable to find name string, return numeric index string
        //
        memset(szNumber, 0, sizeof (szNumber));
        _ltow(dwIndex, szNumber, 10);
        pszReturnName = szNumber;
    }
    return pszReturnName;
}

PPDHI_BINARY_LOG_RECORD_HEADER
PdhiGetWmiSubRecord(
    IN PPDHI_LOG                      pLog,
    IN PPDHI_BINARY_LOG_RECORD_HEADER pRecord,
    IN DWORD                          dwRecordId,
    IN LPGUID                         LogFileGuid)
{
    PPDHI_BINARY_LOG_RECORD_HEADER pThisRecord;
    PPDH_LOGGER_CONTEXT            CurrentContext;

    DWORD dwRecordType;
    DWORD dwRecordLength;
    DWORD dwBytesProcessed;
    DWORD dwThisSubRecordId;
    DWORD dwLocalIndex;
    ULONG i;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return (NULL);
    }

    dwLocalIndex = dwRecordId;
    for (i = 0; i < CurrentContext->LoggerCount; i ++) {
        PLIST_ENTRY pHead = & CurrentContext->LogInfo[i].CounterPathList;
        if (! IsListEmpty(pHead)) {
            PLIST_ENTRY pNext = pHead->Flink;
            PPDH_COUNTER_PATH pCounterPath =
                    CONTAINING_RECORD(pNext, PDH_COUNTER_PATH, Entry);
            if (dwLocalIndex <= pCounterPath->CounterCount) {
                break;
            }
            dwLocalIndex -= pCounterPath->CounterCount;
        }
    }
    assert(i < CurrentContext->LoggerCount);

    __try {
        if (   (i >= CurrentContext->LoggerCount)
            || (! IsEqualGUID(  LogFileGuid,
                              & CurrentContext->LogInfo[i].LogFileGuid))) {
            // binary log record does not contain intended object's counter
            //
            return NULL;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

    dwRecordType   = ((PPDHI_BINARY_LOG_RECORD_HEADER) pRecord)->dwType;
    dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER) pRecord)->dwLength;

    pThisRecord = (PPDHI_BINARY_LOG_RECORD_HEADER)
                  (((LPBYTE) pRecord) + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
    dwBytesProcessed = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);

    if (dwBytesProcessed < dwRecordLength) {
        dwThisSubRecordId = 1;
        while (dwThisSubRecordId < dwLocalIndex) {
            if ((WORD)(pThisRecord->dwType & 0x0000FFFF) == BINLOG_START_WORD) {
                dwBytesProcessed += pThisRecord->dwLength;
                pThisRecord = (PPDHI_BINARY_LOG_RECORD_HEADER)
                              (((LPBYTE)pThisRecord) + pThisRecord->dwLength);
                if (dwBytesProcessed >= dwRecordLength) {
                    break;
                }
                else {
                    dwThisSubRecordId ++;
                }
            }
            else {
                break;
            }
        }
    }
    else {
        dwThisSubRecordId = 0;
    }

    if (dwThisSubRecordId == dwLocalIndex) {
        if ((WORD)(pThisRecord->dwType & 0x0000FFFF) != BINLOG_START_WORD) {
            pThisRecord = NULL;
        }
    }
    else {
        pThisRecord = NULL;
    }

    return pThisRecord;
}

PDH_FUNCTION
PdhWmiEnumObjectItemsFromDataBlock(
    IN PPDHI_LOG          pLog,
    IN PPERF_DATA_BLOCK   pDataBlock,
    IN LPCWSTR            szMachineName,
    IN LPCWSTR            szObjectName,
    IN DWORD              dwObjectId,
    IN DWORD              dwLangId,
    IN PDHI_COUNTER_TABLE CounterTable
)
{
    PDH_STATUS         Status     = ERROR_SUCCESS;
    PERF_OBJECT_TYPE * pObjectDef = GetObjectDefByTitleIndex(pDataBlock, dwObjectId);
    PERF_COUNTER_DEFINITION  * pCountDef;
    PERF_INSTANCE_DEFINITION * pInstDef;

    DWORD  dwItems;
    LPWSTR szItemName;
    DWORD  dwItemLen;
    WCHAR  szInstanceName[1024];

    PPDHI_INST_LIST pInstList      = NULL;
    PPDHI_INSTANCE  pInstance      = NULL;
    PPDHI_INST_LIST pFirstInstList = NULL;

    PPDH_WMI_PERF_OBJECT pPerfObj;

    if (pObjectDef == NULL) {
        Status = PDH_ENTRY_NOT_IN_LOG_FILE;
        goto Cleanup;
    }
    pPerfObj = PdhWmiAddPerfObject(pLog,
                                   szMachineName,
                                   9,
                                   szObjectName,
                                   dwObjectId,
                                   pDataBlock);
    if (pPerfObj == NULL) {
        Status = GetLastError();
        goto Cleanup;
    }

    dwItems   = 0;
    pCountDef = FirstCounter(pObjectDef);
    while (dwItems < (DWORD) pObjectDef->NumCounters) {
        szItemName = PdhWmiGetLogPerfNameByIndex(
                        pLog,
                        szMachineName,
                        dwLangId,
                        pCountDef->CounterNameTitleIndex);
        Status = PdhiFindCounterInstList(
                CounterTable, szItemName, & pInstList);
        if (Status == ERROR_SUCCESS && pFirstInstList == NULL
                                    && pInstList != NULL) {
            pFirstInstList = pInstList;
        }
        dwItems ++;
        pCountDef  = NextCounter(pCountDef);
    }

    if (pFirstInstList == NULL) {
        Status = PDH_NO_COUNTERS;
        goto Cleanup;
    }

    if (pObjectDef->NumInstances != PERF_NO_INSTANCES) {
        dwItems  = 0;
        pInstDef = FirstInstance(pObjectDef);
        while (dwItems < (DWORD) pObjectDef->NumInstances) {
            ZeroMemory(szInstanceName, sizeof(WCHAR) * 1024);
            dwItemLen = GetFullInstanceNameStr(
                            pDataBlock,
                            pObjectDef,
                            pInstDef,
                            szInstanceName);
            if (dwItemLen > 0) {
                Status = PdhiFindInstance(
                         & pFirstInstList->InstList,
                         szInstanceName,
                         (lstrcmpiW(szInstanceName, L"_Total") == 0) ? FALSE : TRUE,
                         & pInstance);
            }
            dwItems ++;
            pInstDef  = NextInstance(pInstDef);
        }
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiEnumObjectItemsFromWmiLog (
    IN PPDHI_LOG          pLog,
    IN LPCWSTR            szMachineName,
    IN LPCWSTR            szObjectName,
    IN PDHI_COUNTER_TABLE CounterTable,
    IN DWORD              dwDetailLevel,
    IN DWORD              dwFlags
)
{
    DWORD       dwTempBufferSize;
    LPVOID      pTempBuffer = NULL;
    LPVOID      ptrTemp;
    PDH_STATUS  pdhStatus   = ERROR_SUCCESS;

    PPDHI_BINARY_LOG_HEADER_RECORD  pHeader;
    PPDHI_LOG_COUNTER_PATH          pPath;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;
    PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;
    PPDHI_RAW_COUNTER_ITEM          pDataItem;

    DWORD       dwBytesProcessed;
    LONG        nItemCount = 0;
    LPBYTE      pFirstChar;
    LPWSTR      szThisMachineName  = NULL;
    LPWSTR      szThisObjectName   = NULL;
    LPWSTR      szThisCounterName  = NULL;
    LPWSTR      szThisInstanceName = NULL;
    LPWSTR      szThisParentName;
    WCHAR       szCompositeInstance[1024];
    DWORD       dwRecordLength;
    BOOL        bCopyThisObject;
    BOOL        bMachineDataBlockScaned = FALSE;
    BOOL        bInstanceListScanned = FALSE;
    DWORD       dwIndex;
    DWORD       dwDataItemIndex;

    DWORD            dwObjectId;
    PPERF_DATA_BLOCK pPerfBlock;

    PPDHI_INST_LIST pInstList      = NULL;
    PPDHI_INSTANCE  pInstance      = NULL;

    PPDH_LOGGER_CONTEXT CurrentContext;

    UNREFERENCED_PARAMETER (dwDetailLevel);
    UNREFERENCED_PARAMETER (dwFlags);

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        pdhStatus = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    if (pLog->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLog->dwMaxRecordSize = 0x010000;
    }

    dwTempBufferSize = pLog->dwMaxRecordSize;
    pTempBuffer = G_ALLOC(dwTempBufferSize);
    if (pTempBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    // read in the catalog record

    pdhStatus = PdhiReadWmiHeaderRecord(pLog, pTempBuffer, dwTempBufferSize);
    while (pdhStatus == PDH_MORE_DATA) {
        if (* (WORD *) pTempBuffer == BINLOG_START_WORD) {
            dwTempBufferSize = ((DWORD *) pTempBuffer)[1];
            if (dwTempBufferSize < pLog->dwMaxRecordSize) {
                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
            }
            else {
                pLog->dwMaxRecordSize = dwTempBufferSize;
            }
        }
        else {
            pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
        }

        ptrTemp     = pTempBuffer;
        pTempBuffer = G_REALLOC(ptrTemp, dwTempBufferSize);
        if (pTempBuffer == NULL) {
            G_FREE(ptrTemp);
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        if (pdhStatus == PDH_MORE_DATA) {
            pdhStatus = PdhiReadWmiHeaderRecord(
                                pLog, pTempBuffer, dwTempBufferSize);
        }
    }

    if (pdhStatus != ERROR_SUCCESS) {
        goto Cleanup;
    }

    pHeader        = (PPDHI_BINARY_LOG_HEADER_RECORD) pTempBuffer;
    dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER) pTempBuffer)->dwLength;

    pPath = (PPDHI_LOG_COUNTER_PATH)
            ((LPBYTE) pTempBuffer + sizeof(PDHI_BINARY_LOG_HEADER_RECORD));
    dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

    dwIndex = 0;
    while (dwBytesProcessed < dwRecordLength) {
        bCopyThisObject  = FALSE;
        szThisObjectName = NULL;
        dwIndex ++;
        pFirstChar       = (LPBYTE) & pPath->Buffer[0];

        if (pPath->lMachineNameOffset >= 0L) {
            szThisMachineName = (LPWSTR) (  (LPBYTE) pFirstChar
                                          + pPath->lMachineNameOffset);
            if (lstrcmpiW(szThisMachineName, szMachineName) == 0) {
                if (pPath->dwFlags & PDHIC_COUNTER_BLOCK) {
                    if (bMachineDataBlockScaned == FALSE) {
                        bCopyThisObject         = TRUE;
                        bMachineDataBlockScaned = TRUE;
                    }
                }
                else if (pPath->lObjectNameOffset >= 0) {
                    szThisObjectName = (LPWSTR) (  (LPBYTE) pFirstChar
                                                 + pPath->lObjectNameOffset);
                    if (lstrcmpiW(szThisObjectName, szObjectName) == 0) {
                        bCopyThisObject = TRUE;
                    }
                }
            }
        }
        else if (pPath->lObjectNameOffset >= 0) {
            szThisObjectName = (LPWSTR) (  (LPBYTE) pFirstChar
                                         + pPath->lObjectNameOffset);
            if (lstrcmpiW(szThisObjectName, szObjectName) == 0) {
                bCopyThisObject = TRUE;
            }
        }

        dwObjectId = 0;
        if (bCopyThisObject) {
            if (   (pPath->dwFlags & PDHIC_COUNTER_OBJECT)
                || (pPath->dwFlags & PDHIC_COUNTER_BLOCK)) {
                dwObjectId = PdhWmiGetLogPerfIndexByName(
                        pLog, szMachineName, 9, szObjectName);
                if (dwObjectId == 0) {
                    dwObjectId = wcstoul(szObjectName, NULL, 10);
                    if (dwObjectId == 0) {
                        szThisCounterName = NULL;
                        bCopyThisObject   = FALSE;
                    }
                }
            }
            else if (pPath->lCounterOffset > 0) {
                szThisCounterName = (LPWSTR) (  (LPBYTE)pFirstChar
                                              + pPath->lCounterOffset);
            }
            else {
                szThisCounterName = NULL;
                bCopyThisObject   = FALSE;
            }
        }

        if (bCopyThisObject) {
            if (dwObjectId == 0) {
                pdhStatus = PdhiFindCounterInstList(
                            CounterTable,
                            szThisCounterName,
                            & pInstList);
                if (pdhStatus == ERROR_SUCCESS && pInstList != NULL) {
                    nItemCount ++;
                }
            }

            if (pPath->lInstanceOffset >= 0) {
                szThisInstanceName = (LPWSTR) (  (LPBYTE) pFirstChar
                                               + pPath->lInstanceOffset);
            }

            if (   dwObjectId > 0
                || (pInstList != NULL && szThisInstanceName != NULL)) {
                if (szThisInstanceName && * szThisInstanceName != SPLAT_L) {
                    if (pPath->lParentOffset >= 0) {
                        szThisParentName = (LPWSTR)
                            ((LPBYTE) pFirstChar + pPath->lParentOffset);
                        lstrcpyW(szCompositeInstance, szThisParentName);
                        lstrcatW(szCompositeInstance, cszSlash);
                        lstrcatW(szCompositeInstance, szThisInstanceName);
                    }
                    else {
                        lstrcpyW(szCompositeInstance, szThisInstanceName);
                    }

                    if (pPath->dwIndex > 0 && pPath->dwIndex != PERF_NO_UNIQUE_ID) {
                            lstrcatW(szCompositeInstance, L"#");
                            _ltow(pPath->dwIndex,
                                  (LPWSTR)(  szCompositeInstance
                                           + lstrlenW(szCompositeInstance)),
                                  10L);
                    }
                    pdhStatus = PdhiFindInstance(
                            & pInstList->InstList,
                            szCompositeInstance,
                            (lstrcmpiW(szCompositeInstance, L"_Total") == 0)
                                            ? FALSE : TRUE,
                            & pInstance);
                    if (pdhStatus == ERROR_SUCCESS && pInstance != NULL) {
                        nItemCount ++;
                    }
                }
                else if (dwObjectId > 0 || !bInstanceListScanned) {
                    pdhStatus = PdhiRewindWmiLog(pLog);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pdhStatus = PdhiReadNextWmiRecord(
                                                pLog, NULL, 0, FALSE);
                        while (   pdhStatus == ERROR_SUCCESS
                               || pdhStatus == PDH_MORE_DATA) {
                            PdhiResetInstanceCount(CounterTable);
                            pdhStatus = ERROR_SUCCESS;
                            pThisMasterRecord =
                                    (PPDHI_BINARY_LOG_RECORD_HEADER)
                                    (  ((PUCHAR) pLog->pLastRecordRead)
                                     + sizeof(GUID));
                            pThisSubRecord = PdhiGetWmiSubRecord(
                                    pLog,
                                    pThisMasterRecord,
                                    dwIndex,
                                    (LPGUID)(pLog->pLastRecordRead));

                            if (pThisSubRecord == NULL) {
                                // this data record does not contain
                                // counter record for selected object,
                                // skip to next one.
                                //
                                pdhStatus = PdhiReadNextWmiRecord(
                                                pLog, NULL, 0, FALSE);
                                continue;
                            }

                            if (pThisSubRecord->dwType == BINLOG_TYPE_DATA_OBJECT
                                    || pThisSubRecord->dwType == BINLOG_TYPE_DATA_LOC_OBJECT) {
                                pPerfBlock = (PPERF_DATA_BLOCK)
                                        ((LPBYTE)pThisSubRecord +
                                    sizeof (PDHI_BINARY_LOG_RECORD_HEADER));

                                pdhStatus = PdhWmiEnumObjectItemsFromDataBlock(
                                                pLog,
                                                pPerfBlock,
                                                szMachineName,
                                                szObjectName,
                                                dwObjectId,
                                                9,
                                                CounterTable);
                                if (pdhStatus == PDH_ENTRY_NOT_IN_LOG_FILE) {
                                    pdhStatus = ERROR_SUCCESS;
                                }
                            }
                            else {
                                pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK)
                                        ((LPBYTE)pThisSubRecord +
                                    sizeof (PDHI_BINARY_LOG_RECORD_HEADER));

                                if (pDataBlock->dwLength > 0) {
                                    for (dwDataItemIndex = 0;
                                         dwDataItemIndex < pDataBlock->dwItemCount;
                                         dwDataItemIndex++) {
                                         pDataItem = & pDataBlock->pItemArray[dwDataItemIndex];
                                         szThisInstanceName = (LPWSTR)
                                                 (((LPBYTE) pDataBlock) + pDataItem->szName);
                                        pdhStatus = PdhiFindInstance(
                                                & pInstList->InstList,
                                                szThisInstanceName,
                                                (lstrcmpiW(szThisInstanceName, L"_Total") == 0)
                                                                ? FALSE : TRUE,
                                                & pInstance);
                                        if (pdhStatus == ERROR_SUCCESS) {
                                            nItemCount++;
                                        }
                                    }
                                }
                            }

                            if (pdhStatus != ERROR_SUCCESS) {
                                break;
                            }
                            else {
                                pdhStatus = PdhiReadNextWmiRecord(pLog, NULL, 0, FALSE);
                            }
                        }
                        if (pdhStatus == PDH_END_OF_LOG_FILE) {
                            pdhStatus = ERROR_SUCCESS;
                        }
                        if (pdhStatus == ERROR_SUCCESS) {
                            bInstanceListScanned = TRUE;
                        }
                    }
                }
            }
        }
        ZeroMemory(szCompositeInstance, sizeof(szCompositeInstance));
        dwBytesProcessed += pPath->dwLength;
        pPath             = (PPDHI_LOG_COUNTER_PATH) (  (LPBYTE) pPath
                                                      + pPath->dwLength);
    }

    if ((nItemCount > 0) && (pdhStatus != PDH_INSUFFICIENT_BUFFER)
                         && (pdhStatus != PDH_MORE_DATA)) {
            pdhStatus = ERROR_SUCCESS;
    }

Cleanup:
    if (pTempBuffer != NULL)
        G_FREE(pTempBuffer);

    return pdhStatus;
}

PDH_FUNCTION
PdhiGetWmiLogCounterInfo(
    IN  PPDHI_LOG       pLog,
    IN  PPDHI_COUNTER   pCounter)
{
    PDH_STATUS Status          = ERROR_SUCCESS;
    DWORD      dwObjectId      = PdhWmiGetLogPerfIndexByName(
                                         pLog,
                                         pCounter->pCounterPath->szMachineName,
                                         9,
                                         pCounter->pCounterPath->szObjectName);
    DWORD      dwCounterId     = wcstoul(pCounter->pCounterPath->szCounterName,
                                         NULL, 10);
    PPDH_WMI_PERF_MACHINE      pMachine    = NULL;
    PPDH_WMI_PERF_OBJECT       pObject     = NULL;
    PLIST_ENTRY                pHead;
    PLIST_ENTRY                pNext;
    PPERF_DATA_BLOCK           pDataBlock  = NULL;
    PERF_OBJECT_TYPE         * pPerfObject = NULL;
    DWORD                      dwItems     = 0;
    PERF_COUNTER_DEFINITION  * pPerfCounter;
    PERF_INSTANCE_DEFINITION * pPerfInstance;
    PPDH_LOGGER_CONTEXT        CurrentContext;

    BOOL                  bNeedEnumerate = TRUE;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) < ContextCount) {
        pMachine = PdhWmiGetLogNameTable(pLog,
                                         pCounter->pCounterPath->szMachineName,
                                         9);
        if (pMachine == NULL) {
            Status = PDH_ENTRY_NOT_IN_LOG_FILE;
            goto Cleanup;
        }
        pHead = & pMachine->LogObjectList;
        pNext = pHead->Flink;
        while (pNext != pHead) {
            pObject = CONTAINING_RECORD(pNext, PDH_WMI_PERF_OBJECT, Entry);
            if (pObject->dwObjectId == dwObjectId) {
                bNeedEnumerate = FALSE;
                break;
            }
            pNext = pNext->Flink;
        }

        if (bNeedEnumerate) {
            DWORD dwCounterSize  = 0;
            DWORD dwInstanceSize = 0;
            Status = PdhiEnumLoggedObjectItems(
                        (HLOG) pLog,
                        pCounter->pCounterPath->szMachineName,
                        pCounter->pCounterPath->szObjectName,
                        NULL,
                        & dwCounterSize,
                        NULL,
                        & dwInstanceSize,
                        0,
                        0,
                        TRUE);
            if (Status != ERROR_SUCCESS && Status != PDH_MORE_DATA
                                        && Status != PDH_INSUFFICIENT_BUFFER) {
                goto Cleanup;
            }
            Status = ERROR_SUCCESS;
        }
    }
    else {
        Status = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    if (dwObjectId == 0) {
        dwObjectId = wcstoul(pCounter->pCounterPath->szObjectName, NULL, 10);
        if (dwObjectId != 0) {
            Status = ERROR_SUCCESS;
        }
        else {
            Status = PDH_ENTRY_NOT_IN_LOG_FILE;
        }
    }
    else {
        Status = ERROR_SUCCESS;
    }

    if (Status != ERROR_SUCCESS) {
        goto Cleanup;
    }

    pMachine    = PdhWmiGetLogNameTable(pLog,
                                        pCounter->pCounterPath->szMachineName,
                                        9);
    if (pMachine == NULL) {
        Status = PDH_ENTRY_NOT_IN_LOG_FILE;
        goto Cleanup;
    }
    pHead = & pMachine->LogObjectList;
    pNext = pHead->Flink;
    while (pNext != pHead) {
        PPDH_WMI_PERF_OBJECT pThisObject = CONTAINING_RECORD(
                pNext, PDH_WMI_PERF_OBJECT, Entry);
        if (pThisObject->dwObjectId == dwObjectId) {
            pObject = pThisObject;
            break;
        }
        pNext = pNext->Flink;
    }
    if (pObject == NULL) {
        Status = PDH_ENTRY_NOT_IN_LOG_FILE;
        goto Cleanup;
    }

    pDataBlock = (PPERF_DATA_BLOCK) pObject->ptrBuffer;
    if (pDataBlock == NULL) {
        Status = PDH_ENTRY_NOT_IN_LOG_FILE;
        goto Cleanup;
    }
    pPerfObject = GetObjectDefByTitleIndex(pDataBlock, dwObjectId);
    if (pPerfObject == NULL) {
        Status = PDH_CSTATUS_NO_OBJECT;
        goto Cleanup;
    }

    dwItems      = 0;
    pPerfCounter = FirstCounter(pPerfObject);
    while (dwItems < pPerfObject->NumCounters) {
        if (   pPerfCounter->CounterNameTitleIndex > 0
            && pPerfCounter->CounterNameTitleIndex <= pMachine->dwLastId) {
            if (lstrcmpiW(pCounter->pCounterPath->szCounterName,
                      pMachine->ptrStrAry[pPerfCounter->CounterNameTitleIndex])
                    == 0) {
                break;
            }
            if (   dwCounterId != 0
                && dwCounterId == pPerfCounter->CounterNameTitleIndex) {
                break;
            }
        }
        dwItems ++;
        if (dwItems < pPerfObject->NumCounters) {
            pPerfCounter = NextCounter(pPerfCounter);
            if (pPerfCounter == NULL) {
                break;
            }
        }
        else {
            pPerfCounter = NULL;
        }
    }
    if (dwItems == pPerfObject->NumCounters) {
        pPerfCounter = NULL;
    }
    if (pPerfCounter == NULL) {
        Status = PDH_CSTATUS_NO_OBJECT;
        goto Cleanup;
    }

    pCounter->plCounterInfo.dwObjectId    = dwObjectId;
    pCounter->plCounterInfo.dwCounterId   = pPerfCounter->CounterNameTitleIndex;
    pCounter->plCounterInfo.dwCounterType = pPerfCounter->CounterType;
    pCounter->plCounterInfo.dwCounterSize = pPerfCounter->CounterSize;
    pCounter->plCounterInfo.lDefaultScale = pPerfCounter->DefaultScale;
    if (pCounter->plCounterInfo.dwCounterType  & PERF_TIMER_100NS) {
        pCounter->TimeBase = (LONGLONG) 10000000;
    }
    else if (pCounter->plCounterInfo.dwCounterType  & PERF_OBJECT_TIMER) {
        pCounter->TimeBase = pPerfObject->PerfFreq.QuadPart;
    }
    else {
        pCounter->TimeBase = pDataBlock->PerfFreq.QuadPart;
    }

    if (pPerfObject->NumInstances == PERF_NO_INSTANCES) {
        pCounter->plCounterInfo.lInstanceId          = 0;
        pCounter->plCounterInfo.szInstanceName       = NULL;
        pCounter->plCounterInfo.dwParentObjectId     = 0;
        pCounter->plCounterInfo.szParentInstanceName = NULL;
    }
    else {
        pPerfInstance = FirstInstance(pPerfObject);
        if (pPerfInstance->UniqueID == PERF_NO_UNIQUE_ID) {
            pCounter->plCounterInfo.lInstanceId    = PERF_NO_UNIQUE_ID;
            pCounter->plCounterInfo.szInstanceName = pCounter->pCounterPath->szInstanceName;
            pCounter->plCounterInfo.dwParentObjectId = (DWORD)PERF_NO_UNIQUE_ID;
            pCounter->plCounterInfo.szParentInstanceName = pCounter->pCounterPath->szParentName;
        }
        else {
            LONG    lTempId;
            if (pCounter->pCounterPath->szInstanceName != NULL) {
                lTempId = wcstoul(pCounter->pCounterPath->szInstanceName,
                                  NULL,
                                  10);
            }
            else {
                lTempId = 0;
            }
            pCounter->plCounterInfo.lInstanceId    = lTempId;
            pCounter->plCounterInfo.szInstanceName = NULL;

            if (pCounter->pCounterPath->szParentName != NULL) {
                lTempId = wcstoul(pCounter->pCounterPath->szParentName,
                                  NULL,
                                  10);
            }
            else {
                lTempId = 0;
            }
            pCounter->plCounterInfo.dwParentObjectId = lTempId;
            pCounter->plCounterInfo.szParentInstanceName = NULL;
        }
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiGetWmiLogFileSize(
    IN PPDHI_LOG  pLog,
    IN LONGLONG * llSize)
{
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    LONGLONG            SizeSum   = 0;
    DWORD               dwFileSizeLow;
    DWORD               dwFileSizeHigh;
    DWORD               dwError;
    HANDLE              hFile;

    if (pLog->dwLogFormat & PDH_LOG_WRITE_ACCESS) {
        PPDH_EVENT_TRACE_PROPERTIES LoggerInfo =
                        (PPDH_EVENT_TRACE_PROPERTIES) pLog->lpMappedFileBase;
        if (LoggerInfo != NULL && LoggerInfo->LogFileName != NULL
                               && LoggerInfo->LogFileName[0] != L'\0') {
            hFile = CreateFileW(
                    LoggerInfo->LogFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
            if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
                DWORD Win32Error = GetLastError();
                switch (Win32Error) {
                case ERROR_FILE_NOT_FOUND:
                    pdhStatus = PDH_FILE_NOT_FOUND;
                    break;

                case ERROR_ALREADY_EXISTS:
                    pdhStatus = PDH_FILE_ALREADY_EXISTS;
                    break;

                default:
                    pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                    break;
                }
            }
            else {
                dwFileSizeLow = GetFileSize(hFile, & dwFileSizeHigh);
                if (   (dwFileSizeLow == 0xFFFFFFFF)
                    && ((dwError = GetLastError()) != NO_ERROR)) {
                    pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                }
                else {
                    if (dwFileSizeHigh != 0) {
                        SizeSum += (dwFileSizeHigh << (sizeof(DWORD) * 8));
                    }
                    SizeSum += dwFileSizeLow;
                }
                CloseHandle(hFile);
            }
        }
        else {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    else {
        PPDH_LOGGER_CONTEXT CurrentContext =
                        (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
        if (GetLoggerContext(CurrentContext) < ContextCount) {
            LONG     i;

            for (i = 0, hFile = NULL, dwFileSizeLow = 0, dwFileSizeHigh = 0;
                 (pdhStatus == ERROR_SUCCESS)
                        && (i < (LONG) CurrentContext->LogFileCount);
                  i ++, hFile = NULL, dwFileSizeLow = 0, dwFileSizeHigh = 0) {
                hFile = CreateFileW(
                        CurrentContext->LogFileName[i],
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
                if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
                    DWORD Win32Error = GetLastError();
                    switch (Win32Error) {
                    case ERROR_FILE_NOT_FOUND:
                        pdhStatus = PDH_FILE_NOT_FOUND;
                        break;

                    case ERROR_ALREADY_EXISTS:
                        pdhStatus = PDH_FILE_ALREADY_EXISTS;
                        break;

                    default:
                        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                        break;
                    }
                    break;
                }
                dwFileSizeLow = GetFileSize(hFile, & dwFileSizeHigh);
                if (   (dwFileSizeLow == 0xFFFFFFFF)
                    && ((dwError = GetLastError()) != NO_ERROR)) {
                    pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                }
                else {
                    if (dwFileSizeHigh != 0) {
                        SizeSum = SizeSum + (dwFileSizeHigh << (sizeof(DWORD) * 8));
                    }
                    SizeSum += dwFileSizeLow;
                }
                CloseHandle(hFile);
            }
        }
        else {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            * llSize = SizeSum;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log_text.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    log_text.c

Abstract:

    <abstract>

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <mbctype.h>
#include <pdh.h>
#include "pdhidef.h"
#include "log_text.h"
#include "pdhmsg.h"
#include "strings.h"    

#pragma warning ( disable : 4213)

#define TAB_DELIMITER   '\t'
#define COMMA_DELIMITER ','
#define DOUBLE_QUOTE    '\"'
#define VALUE_BUFFER_SIZE   32

LPCSTR  PdhiszFmtTimeStamp = "\"%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%3.3d\"";
LPCSTR  PdhiszFmtStringValue =  "%c\"%s\"";
LPCSTR  PdhiszFmtRealValue =    "%c\"%.20g\"";
TIME_ZONE_INFORMATION TimeZone;
// LPCSTR  PdhiszTimeStampLabel = " Sample Time\"";
// DWORD   PdhidwTimeStampLabelLength  = 13;

extern  LPCSTR  PdhiszRecordTerminator;
extern  DWORD   PdhidwRecordTerminatorLength;

#define TEXTLOG_TYPE_ID_RECORD  1
#define TEXTLOG_HEADER_RECORD   1
#define TEXTLOG_FIRST_DATA_RECORD   2

#define TIME_FIELD_COUNT        7
#define TIME_FIELD_BUFF_SIZE    24
DWORD   dwTimeFieldOffsetList[TIME_FIELD_COUNT] = {2, 5, 10, 13, 16, 19, 23};

#define MAX_TEXT_FILE_SIZE ((LONGLONG)0x0000000077FFFFFF)

PDH_FUNCTION
PdhiBuildFullCounterPath(
    IN  BOOL               bMachine,
    IN  PPDHI_COUNTER_PATH pCounterPath,
    IN  LPWSTR             szObjectName,
    IN  LPWSTR             szCounterName,
    IN  LPWSTR             szFullPath
);

STATIC_BOOL
PdhiDateStringToFileTimeA (
    IN  LPSTR   szDateTimeString,
    IN  LPFILETIME  pFileTime
);

STATIC_DWORD
PdhiGetStringFromDelimitedListA (
    IN  LPSTR   szInputString,
    IN  DWORD   dwItemIndex,
    IN  CHAR    cDelimiter,
    IN  DWORD   dwFlags,
    IN  LPSTR   szOutputString,
    IN  DWORD   cchBufferLength
);

STATIC_PDH_FUNCTION
PdhiReadOneTextLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  DWORD   dwRecordId,
    IN  LPSTR   szRecord,
    IN  DWORD   dwMaxSize
);

STATIC_BOOL
PdhiDateStringToFileTimeA (
    IN  LPSTR   szDateTimeString,
    IN  LPFILETIME  pFileTime
)
{
    CHAR    mszTimeFields[TIME_FIELD_BUFF_SIZE];
    DWORD   dwThisField;
    LONG    lValue;
    SYSTEMTIME  st;

    // make string into msz
    lstrcpynA (mszTimeFields, szDateTimeString, TIME_FIELD_BUFF_SIZE);
    for (dwThisField = 0; dwThisField < TIME_FIELD_COUNT; dwThisField++) {
        mszTimeFields[dwTimeFieldOffsetList[dwThisField]] = 0;
    }

    // read string into system time structure
    dwThisField = 0;
    st.wDayOfWeek = 0;
    lValue = atol(&mszTimeFields[0]);
    st.wMonth = LOWORD(lValue);
    lValue = atol(&mszTimeFields[dwTimeFieldOffsetList[dwThisField++]+1]);
    st.wDay = LOWORD(lValue);
    lValue = atol(&mszTimeFields[dwTimeFieldOffsetList[dwThisField++]+1]);
    st.wYear = LOWORD(lValue);
    lValue = atol(&mszTimeFields[dwTimeFieldOffsetList[dwThisField++]+1]);
    st.wHour = LOWORD(lValue);
    lValue = atol(&mszTimeFields[dwTimeFieldOffsetList[dwThisField++]+1]);
    st.wMinute = LOWORD(lValue);
    lValue = atol(&mszTimeFields[dwTimeFieldOffsetList[dwThisField++]+1]);
    st.wSecond = LOWORD(lValue);
    lValue = atol(&mszTimeFields[dwTimeFieldOffsetList[dwThisField++]+1]);
    st.wMilliseconds = LOWORD(lValue);

    return SystemTimeToFileTime (&st, pFileTime);
}

#define PDHI_GSFDL_REMOVE_QUOTES    0x00000001
#define PDHI_GSFDL_REMOVE_NONPRINT  0x00000002
STATIC_DWORD
PdhiGetStringFromDelimitedListA (
    IN  LPSTR   szInputString,
    IN  DWORD   dwItemIndex,
    IN  CHAR    cDelimiter,
    IN  DWORD   dwFlags,
    IN  LPSTR   szOutputString,
    IN  DWORD   cchBufferLength
)
{
    DWORD   dwCurrentIndex = 0;
    LPSTR   szCurrentItem;
    LPSTR   szSrcPtr, szDestPtr;
    DWORD   dwReturn       = 0;
    BOOL    bInsideQuote   = FALSE;

    // go to desired entry in string, 0 = first entry
    szCurrentItem = szInputString;

    while (dwCurrentIndex < dwItemIndex) {
        // goto next delimiter or terminator
        while (* szCurrentItem != cDelimiter || bInsideQuote) {
            if (* szCurrentItem == 0) break;
            else if (* szCurrentItem == DOUBLEQUOTE_A) {
                bInsideQuote = ! bInsideQuote;
            }
            szCurrentItem ++;
        }
        if (* szCurrentItem != 0) szCurrentItem ++;
        dwCurrentIndex++;
    }
    if (*szCurrentItem != 0) {
        // then copy to the user's buffer, as long as it fits
        szSrcPtr     = szCurrentItem;
        szDestPtr    = szOutputString;
        dwReturn     = 0;
        bInsideQuote = FALSE;

        while (   (dwReturn < cchBufferLength)
               && (* szSrcPtr != 0)
               && (* szSrcPtr != cDelimiter || bInsideQuote)) {
            if (* szSrcPtr == DOUBLEQUOTE_A) {
                bInsideQuote = ! bInsideQuote;
                if (dwFlags & PDHI_GSFDL_REMOVE_QUOTES) {
                    // skip the quote
                    szSrcPtr ++;
                    continue;
                }
            }

            if (dwFlags & PDHI_GSFDL_REMOVE_NONPRINT) {
                if ((UCHAR) * szSrcPtr < (UCHAR) ' ') {
                    // skip the control char
                    szSrcPtr ++;
                    continue;
                }
            }

            // copy character
            * szDestPtr ++ = * szSrcPtr ++;
            dwReturn ++; // increment length
        }
        if (dwReturn > 0) {
            * szDestPtr = 0; // add terminator char
        }
    }
    return dwReturn;
}

STATIC_PDH_FUNCTION 
PdhiReadOneTextLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  DWORD   dwRecordId,
    IN  LPSTR   szRecord,
    IN  DWORD   dwMaxSize
)
// reads the specified record from the log file and returns it as an ANSI
// character string
{
    LPSTR   szTempBuffer;
    LPSTR   szOldBuffer;
    LPSTR   szTempBufferPtr;
    LPSTR   szReturn;
    PDH_STATUS  pdhStatus;
    int     nFileError = 0;
    DWORD   dwRecordLength;
    DWORD   dwBytesRead = 0;

    if (pLog->dwMaxRecordSize == 0) {
        // initialize with a default value
        dwRecordLength = SMALL_BUFFER_SIZE;
    } else {
        // use current maz record size max.
        dwRecordLength = pLog->dwMaxRecordSize;
    }

    szTempBuffer = G_ALLOC (dwRecordLength);
    if (szTempBuffer == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }
    // position file pointer to desired record;

    if (dwRecordId == pLog->dwLastRecordRead) {
        // then return the current record from the cached buffer
        if ((DWORD)lstrlenA((LPSTR)pLog->pLastRecordRead) < dwMaxSize) {
            lstrcpyA(szRecord, (LPSTR)pLog->pLastRecordRead);
            pdhStatus = ERROR_SUCCESS;
        } else {
            pdhStatus = PDH_MORE_DATA;
        }
        // free temp buffer
        if (szTempBuffer != NULL) {
            G_FREE (szTempBuffer);
        }
    } else {
        if ((dwRecordId < pLog->dwLastRecordRead) || (pLog->dwLastRecordRead == 0)){
            // the desired record is before the current position
            // or the counter has been reset so we have to
            // go to the beginning of the file and read up to the specified
            // record.
            pLog->dwLastRecordRead = 0;
            rewind (pLog->StreamFile);
        }

        // free old buffer
        if (pLog->pLastRecordRead != NULL) {
            G_FREE (pLog->pLastRecordRead);
            pLog->pLastRecordRead = NULL;
        }

        // now seek to the desired entry
        do {
            szReturn = fgets (szTempBuffer, dwRecordLength, pLog->StreamFile);
            if (szReturn == NULL) {
                if (!feof(pLog->StreamFile)) {
                    nFileError = ferror (pLog->StreamFile);
                }
                break; // end of file
            } else {
                // see if an entire record was read
                dwBytesRead = lstrlenA(szTempBuffer);
                // see if the last char is a new line
                if ((dwBytesRead > 0) &&
                    (szTempBuffer[dwBytesRead-1] != '\r') &&
                    (szTempBuffer[dwBytesRead-1] != '\n')) {
                    // then if the record size is the same as the buffer
                    // or there's more text in this record...
                    // just to be safe, we'll realloc the buffer and try
                    // reading some more
                    while (dwBytesRead == dwRecordLength-1) {
                        dwRecordLength += SMALL_BUFFER_SIZE;
                        szOldBuffer = szTempBuffer;
                        szTempBuffer = G_REALLOC (szOldBuffer, dwRecordLength);
                        if (szTempBuffer == NULL) {
                            G_FREE(szOldBuffer);
                            pLog->dwLastRecordRead = 0;
                            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            goto Cleanup;
                        }
                        // position read pointer at end of bytes already read
                        szTempBufferPtr = szTempBuffer + dwBytesRead;

                        szReturn = fgets (szTempBufferPtr,
                            dwRecordLength - dwBytesRead,
                            pLog->StreamFile);
                        if (szReturn == NULL) {
                            if (!feof(pLog->StreamFile)) {
                                nFileError = ferror (pLog->StreamFile);
                            }
                            break; // end of file
                        } else {
                            // the BytesRead value already includes the NULL
                            dwBytesRead += lstrlenA(szTempBufferPtr);
                        }
                    } // end while finding the end of the record
                    // update the record length
                    // add one byte to the length read to prevent entering the
                    // recalc loop on records of the same size
                    dwRecordLength = dwBytesRead + 1;
                    szOldBuffer = szTempBuffer;
                    szTempBuffer = G_REALLOC (szOldBuffer, dwRecordLength);
                    if (szTempBuffer == NULL) {
                        G_FREE(szOldBuffer);
                        pLog->dwLastRecordRead = 0;
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                    assert (szTempBuffer != NULL);
                } // else the whole record fit
            }

        } while (++pLog->dwLastRecordRead < dwRecordId);

        // update the max record length for the log file.
        if (dwRecordLength> pLog->dwMaxRecordSize) {
            pLog->dwMaxRecordSize = dwRecordLength;
        }

        // if the desired one was found then return it
        if (szReturn != NULL) {
            // then a record was read so update the cached values and return
            // the data
            pLog->pLastRecordRead = (LPVOID)szTempBuffer;

            // copy to the caller's buffer
            if (dwBytesRead < dwMaxSize) {
                lstrcpyA(szRecord, (LPSTR)pLog->pLastRecordRead);
                pdhStatus = ERROR_SUCCESS;
            } else {
                pdhStatus = PDH_MORE_DATA;
            }
        } else {
            // reset the pointers and buffers
            pLog->dwLastRecordRead = 0;
            G_FREE (szTempBuffer);
            pdhStatus = PDH_END_OF_LOG_FILE;
        }
    }

Cleanup:
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetTextLogCounterInfo (
    IN  PPDHI_LOG       pLog,
    IN  PPDHI_COUNTER   pCounter
)
{
    PDH_STATUS  pdhStatus;
    LPSTR       szReturn;
    CHAR        cDelim;
    CHAR        szTemp[4];
    LPSTR       szAnsiCounterPath = NULL;
    LPSTR       szAnsiCounter     = NULL;
    LPWSTR      szUnicodeCounter  = NULL;
    DWORD       dwIndex;
    LPSTR       szThisItem;
    DWORD       dwPathLength;
    DWORD       dwBufferLength;
    DWORD       dwItemLength;
    DWORD       dwInstanceId = 0;
    BOOL        bNoMachine   = FALSE;

    if (lstrcmpiW(pCounter->pCounterPath->szMachineName, L"\\\\.") == 0) {
        bNoMachine = TRUE;
    }

    // allocate extra space for DBCS characters
    //
    dwPathLength = lstrlenW(pCounter->pCounterPath->szMachineName)  + 1
                 + lstrlenW(pCounter->pCounterPath->szObjectName)   + 1
                 + lstrlenW(pCounter->pCounterPath->szParentName)   + 4 
                 + lstrlenW(pCounter->pCounterPath->szInstanceName) + 2
                 + lstrlenW(pCounter->pCounterPath->szCounterName)  + 1;
    if ((lstrlenW(pCounter->szFullName) + 1) > (LONG) dwPathLength) {
        dwPathLength = lstrlenW(pCounter->szFullName) + 1;
    }
    szAnsiCounterPath = G_ALLOC(dwPathLength * 3 * sizeof(CHAR));
    szAnsiCounter     = G_ALLOC(dwPathLength * 3 * sizeof(CHAR));
    szUnicodeCounter  = G_ALLOC(dwPathLength * sizeof(WCHAR));
    if (szAnsiCounterPath == NULL || szUnicodeCounter == NULL
                                  || szAnsiCounter == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    } else {
        PdhiBuildFullCounterPath((bNoMachine ? FALSE : TRUE),
                                 pCounter->pCounterPath,
                                 pCounter->pCounterPath->szObjectName,
                                 pCounter->pCounterPath->szCounterName,
                                 szUnicodeCounter);
        WideCharToMultiByte(_getmbcp(),
                            0,
                            pCounter->szFullName,
                            lstrlenW(pCounter->szFullName),
                            szAnsiCounterPath,
                            dwPathLength,
                            NULL,
                            NULL);
        WideCharToMultiByte(_getmbcp(),
                            0,
                            szUnicodeCounter,
                            lstrlenW(szUnicodeCounter),
                            szAnsiCounter,
                            dwPathLength,
                            NULL,
                            NULL);
    }

    szReturn = &szTemp[0]; // for starters
    // read the log file's header record
    pdhStatus = PdhiReadOneTextLogRecord (
        pLog,
        TEXTLOG_HEADER_RECORD,
        szReturn,
        1); // we're lying to prevent copying the record.
    // what's in szReturn is not important since we'll be reading the
    // data from the "last Record read" buffer

    if (pLog->dwLastRecordRead == TEXTLOG_HEADER_RECORD) {
        cDelim = (CHAR)((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ?
            COMMA_DELIMITER : TAB_DELIMITER);

        // then the seek worked and we can use the buffer
        dwBufferLength =
            lstrlenA((LPSTR)pLog->pLastRecordRead) + 1;
        szReturn = G_ALLOC (dwBufferLength * sizeof(CHAR));
        if (szReturn != NULL) {
            lstrcpyA (szReturn, (LPSTR)pLog->pLastRecordRead);
            dwIndex = 0;
            szThisItem = NULL;
            while ((dwItemLength = PdhiGetStringFromDelimitedListA(
                    (LPSTR)pLog->pLastRecordRead,
                    ++dwIndex,
                    cDelim,
                    PDHI_GSFDL_REMOVE_QUOTES | PDHI_GSFDL_REMOVE_NONPRINT,
                    szReturn,
                    dwBufferLength)) != 0) {
                if (lstrcmpiA(szReturn, szAnsiCounterPath) == 0) {
                    szThisItem = szReturn;
                    break;
                }
                else if (lstrcmpiA(szReturn, szAnsiCounter) == 0) {
                    // then this is the desired counter
                    if (dwInstanceId < pCounter->pCounterPath->dwIndex) {
                        dwInstanceId ++;
                    }
                    else {
                        szThisItem = szReturn;
                        break;
                    }
                }
            }
            if (szThisItem != NULL) {
                if (bNoMachine) {
                    pCounter->pCounterPath->szMachineName = NULL;
                }
                // this is a valid counter so update the fields
                // for Text logs, none of this info is used
                pCounter->plCounterInfo.dwObjectId = 0;
                pCounter->plCounterInfo.lInstanceId = dwInstanceId;
                pCounter->plCounterInfo.szInstanceName = NULL;
                pCounter->plCounterInfo.dwParentObjectId = 0;
                pCounter->plCounterInfo.szParentInstanceName = NULL;
                // this data is used by the log file readers
                pCounter->plCounterInfo.dwCounterId = dwIndex;
                pCounter->plCounterInfo.dwCounterType = PERF_DOUBLE_RAW;
                pCounter->plCounterInfo.dwCounterSize = 8;
                pdhStatus = ERROR_SUCCESS;
            } else {
                // counter not found
                pdhStatus = PDH_CSTATUS_NO_COUNTER;
            }
            G_FREE (szReturn);
        } else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    } else {
        // unable to read header from log file
        pdhStatus = PDH_UNABLE_READ_LOG_HEADER;
    }

Cleanup:
    if (szAnsiCounterPath) G_FREE(szAnsiCounterPath);
    if (szAnsiCounter)     G_FREE(szAnsiCounter);
    if (szUnicodeCounter)  G_FREE(szUnicodeCounter);

    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenInputTextLog (
    IN  PPDHI_LOG   pLog
)
{
    PDH_STATUS  pdhStatus;

        // open a stream handle for easy C RTL I/O
        pLog->StreamFile = _wfopen (pLog->szLogFileName, (LPCWSTR)L"rt");
        if (pLog->StreamFile == NULL ||
                        pLog->StreamFile == (FILE *)((DWORD_PTR)(-1))) {
            pLog->StreamFile = (FILE *)((DWORD_PTR) (-1));
            pdhStatus        = PDH_LOG_FILE_OPEN_ERROR;
        } else {
            pdhStatus = ERROR_SUCCESS;
        }
    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenOutputTextLog (
    IN  PPDHI_LOG   pLog
)
{
    PDH_STATUS  pdhStatus;

    pLog->StreamFile = (FILE *)((DWORD_PTR)(-1));
    pLog->dwRecord1Size = 0;
    pdhStatus = ERROR_SUCCESS;

    return pdhStatus;
}

PDH_FUNCTION
PdhiCloseTextLog (
    IN  PPDHI_LOG   pLog,
    IN  DWORD       dwFlags
)
{
    PDH_STATUS  pdhStatus;

    UNREFERENCED_PARAMETER (dwFlags);

    if (pLog->StreamFile != NULL &&
                    pLog->StreamFile != (FILE *)((DWORD_PTR)(-1))) {
       fclose (pLog->StreamFile);
       pLog->StreamFile = (FILE *)((DWORD_PTR)(-1));
    }
    pdhStatus = ERROR_SUCCESS;
    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteTextLogHeader (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szUserCaption
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    PPDHI_COUNTER   pThisCounter;
    CHAR            cDelim;
    CHAR            szLeadDelim[4];
    DWORD           dwLeadSize;
    CHAR            szTrailDelim[4];
    DWORD           dwTrailSize;
    DWORD           dwBytesWritten;
    LPSTR           szCounterPath  = NULL;
    LPWSTR          wszCounterPath = NULL;
    LPSTR           szLocalCaption = NULL;
    DWORD           dwCaptionSize = 0;
    BOOL            bDefaultCaption;

    LPSTR           szOutputString = NULL;
    LPSTR           szTmpString;
    DWORD           dwStringBufferSize = 0;
    DWORD           dwStringBufferUsed = 0;
    DWORD           dwNewStringLen;

    szCounterPath  = G_ALLOC(MEDIUM_BUFFER_SIZE * sizeof(CHAR));
    wszCounterPath = G_ALLOC(MEDIUM_BUFFER_SIZE * sizeof(WCHAR));
    szOutputString = G_ALLOC(MEDIUM_BUFFER_SIZE * sizeof(CHAR));
    if (szCounterPath == NULL || wszCounterPath == NULL
                              || szOutputString == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    dwStringBufferSize = MEDIUM_BUFFER_SIZE;

    cDelim = (CHAR)((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ? COMMA_DELIMITER :
            TAB_DELIMITER);

    szLeadDelim[0] = cDelim;
    szLeadDelim[1] = DOUBLE_QUOTE;
    szLeadDelim[2] = 0;
    szLeadDelim[3] = 0;
    dwLeadSize = 2 * sizeof(szLeadDelim[0]);

    szTrailDelim[0] = DOUBLE_QUOTE;
    szTrailDelim[1] = 0;
    szTrailDelim[2] = 0;
    szTrailDelim[3] = 0;
    dwTrailSize = 1 * sizeof(szTrailDelim[0]);

    // we'll assume the buffer allocated is large enough to hold the timestamp 
    // and 1st counter name. After that we'll test the size first.

    lstrcpyA(szOutputString, szTrailDelim);
    lstrcatA(szOutputString, 
             (LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV ?
                                szCsvLogFileHeader : szTsvLogFileHeader));

    {
        // Add TimeZone information
        //
        DWORD dwReturn = GetTimeZoneInformation(&TimeZone);
        CHAR  strTimeZone[MAX_PATH];

        if (dwReturn != TIME_ZONE_ID_INVALID) {
            if (dwReturn == TIME_ZONE_ID_DAYLIGHT) {
                sprintf(strTimeZone, " (%ws)(%d)",
                        TimeZone.DaylightName,
                        TimeZone.Bias + TimeZone.DaylightBias);
            }
            else {
                sprintf(strTimeZone, " (%ws)(%d)",
                        TimeZone.StandardName,
                        TimeZone.Bias + TimeZone.StandardBias);
            }
            lstrcatA(szOutputString, strTimeZone);
            pLog->dwRecord1Size = 1;
        }
    }

    lstrcatA(szOutputString, szTrailDelim);
    lstrlenA(szOutputString);

    // get buffer size here
    dwStringBufferUsed = lstrlenA(szOutputString);

    // check each counter in the list of counters for this query and
    // write them to the file

    // output the path names
    pThisCounter = pLog->pQuery ? pLog->pQuery->pCounterListHead : NULL;

    if (pThisCounter != NULL) {
        do {
            // get the counter path information from the counter
            ZeroMemory(wszCounterPath, sizeof(WCHAR) * MEDIUM_BUFFER_SIZE);
            ZeroMemory(szCounterPath,  sizeof(CHAR)  * MEDIUM_BUFFER_SIZE);

            PdhiBuildFullCounterPath(TRUE,
                                     pThisCounter->pCounterPath,
                                     pThisCounter->pCounterPath->szObjectName,
                                     pThisCounter->pCounterPath->szCounterName,
                                     wszCounterPath);
            WideCharToMultiByte(_getmbcp(),
                                0,
                                wszCounterPath,
                                lstrlenW(wszCounterPath),
                                (LPSTR) szCounterPath,
                                MEDIUM_BUFFER_SIZE,
                                NULL,
                                NULL);
            dwNewStringLen = lstrlenA(szCounterPath);
            dwNewStringLen += dwLeadSize;
            dwNewStringLen += dwTrailSize;

            if ((dwNewStringLen + dwStringBufferUsed) >= dwStringBufferSize) {
                dwStringBufferSize += SMALL_BUFFER_SIZE;
                szTmpString = szOutputString;
                szOutputString = G_REALLOC (szTmpString, dwStringBufferSize);
                if (szOutputString == NULL) {
                    G_FREE(szTmpString);
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    break; // out of DO loop
                }
            } else {
                // mem alloc ok, so continue
            }

            lstrcatA (szOutputString, szLeadDelim);
            if (pdhStatus == ERROR_SUCCESS) {
                lstrcatA (szOutputString, szCounterPath);
            } else {
                // just write the delimiters and no string inbetween
            }
            lstrcatA (szOutputString, szTrailDelim);

            dwStringBufferUsed += dwNewStringLen;

            pThisCounter = pThisCounter->next.flink; // go to next in list
        } while (pThisCounter != pLog->pQuery->pCounterListHead);
    }

    // test to see if the caller wants to append user strings to the log

    if (((pLog->dwLogFormat & PDH_LOG_OPT_MASK) == PDH_LOG_OPT_USER_STRING) &&
        (pdhStatus == ERROR_SUCCESS)) { 
        // they want to write user data  so  see if they've passed in a
        // caption string
        if (szUserCaption != NULL) {
            dwCaptionSize = lstrlenW (szUserCaption) + 1;
            // allocate larger buffer to accomodate DBCS characters
            dwCaptionSize = dwCaptionSize * 3 * sizeof (CHAR);

            szLocalCaption = (LPSTR) G_ALLOC (dwCaptionSize);
            if (szLocalCaption != NULL) {
                memset(szLocalCaption, 0, dwCaptionSize);
                dwCaptionSize = WideCharToMultiByte(
                                _getmbcp(),
                                0,
                                szUserCaption,
                                lstrlenW(szUserCaption),
                                szLocalCaption,
                                dwCaptionSize,
                                NULL,
                                NULL);
                bDefaultCaption = FALSE;
            } else {
                bDefaultCaption = TRUE;
            }
        } else {
            bDefaultCaption = TRUE;
        }

        if (bDefaultCaption) {
            szLocalCaption = (LPSTR)caszDefaultLogCaption;
            dwCaptionSize = lstrlenA (szLocalCaption);
        }

        dwNewStringLen = (DWORD)dwCaptionSize;
        dwNewStringLen += dwLeadSize;
        dwNewStringLen += dwTrailSize;

        if ((dwNewStringLen + dwStringBufferUsed) >= dwStringBufferSize) {
            dwStringBufferSize += SMALL_BUFFER_SIZE;
            szTmpString = szOutputString;
            szOutputString = G_REALLOC (szTmpString, dwStringBufferSize);
            if (szOutputString == NULL) {
                G_FREE(szTmpString);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        } else {
            // mem alloc ok, so continue
        }

        if (pdhStatus == ERROR_SUCCESS) {
            lstrcatA (szOutputString, szLeadDelim);
#pragma warning (disable : 4701 )    // szLocalCaption is initialized above
            lstrcatA (szOutputString, szLocalCaption);
#pragma warning (default : 4701)    
            lstrcatA (szOutputString, szTrailDelim);

        }

        dwStringBufferUsed += dwNewStringLen;
        if (!bDefaultCaption) {
            G_FREE (szLocalCaption);
        }

    }

    if (pdhStatus == ERROR_SUCCESS) {

        if ((PdhidwRecordTerminatorLength + dwStringBufferUsed) >= dwStringBufferSize) {
            dwStringBufferSize += PdhidwRecordTerminatorLength;
            szTmpString = szOutputString;
            szOutputString = G_REALLOC (szTmpString, dwStringBufferSize);
            if (szOutputString == NULL) {
                G_FREE(szTmpString);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        } else {
            // mem alloc ok, so continue
        }

        if (pdhStatus == ERROR_SUCCESS) {

            lstrcatA (szOutputString, PdhiszRecordTerminator);
            dwStringBufferUsed += PdhidwRecordTerminatorLength;

            // write  the record
            if (!WriteFile (pLog->hLogFileHandle,
                (LPCVOID)szOutputString,
                dwStringBufferUsed,
                &dwBytesWritten,
                NULL)) {
                pdhStatus = GetLastError();
            } else if (pLog->pQuery->hLog == H_REALTIME_DATASOURCE || pLog->pQuery->hLog == H_WBEM_DATASOURCE) {
                FlushFileBuffers(pLog->hLogFileHandle);
            }

            if (dwStringBufferUsed > pLog->dwMaxRecordSize) {
                // then update the buffer size
                pLog->dwMaxRecordSize = dwStringBufferUsed;
            }
        }
    }

Cleanup:
    if (szCounterPath  != NULL) G_FREE(szCounterPath);
    if (wszCounterPath != NULL) G_FREE(wszCounterPath);
    if (szOutputString != NULL) G_FREE(szOutputString);

    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteTextLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  SYSTEMTIME  *stTimeStamp,
    IN  LPCWSTR     szUserString
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    PPDHI_COUNTER   pThisCounter;
    CHAR            cDelim;
    DWORD           dwBytesWritten;
    DWORD           dwBufferSize;
    CHAR            szValueBuffer[VALUE_BUFFER_SIZE];
    PDH_FMT_COUNTERVALUE    pdhValue;

    DWORD           dwUserStringSize;
    LPSTR           szLocalUserString = NULL;
    BOOL            bDefaultUserString;

    LPSTR           szOutputString = NULL;
    DWORD           dwStringBufferSize = 0;
    DWORD           dwStringBufferUsed = 0;
    DWORD           dwNewStringLen;
    SYSTEMTIME      lstTimeStamp;

    LARGE_INTEGER   liFileSize;

    dwStringBufferSize = (MEDIUM_BUFFER_SIZE > pLog->dwMaxRecordSize ? 
        MEDIUM_BUFFER_SIZE : pLog->dwMaxRecordSize);

    szOutputString = G_ALLOC (dwStringBufferSize);
    if (szOutputString == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    cDelim = (CHAR)((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ? COMMA_DELIMITER :
            TAB_DELIMITER);

    // format and write the time stamp title
    lstTimeStamp = * stTimeStamp;

    dwStringBufferUsed = sprintf (szOutputString, PdhiszFmtTimeStamp,
            lstTimeStamp.wMonth, lstTimeStamp.wDay, lstTimeStamp.wYear,
            lstTimeStamp.wHour, lstTimeStamp.wMinute, lstTimeStamp.wSecond,
            lstTimeStamp.wMilliseconds);

    // check each counter in the list of counters for this query and
    // write them to the file

    pThisCounter = pLog->pQuery ? pLog->pQuery->pCounterListHead : NULL;

    if (pThisCounter != NULL) {
        // lock the query while we read the data so the values
        // written to the log will all be from the same sample
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pThisCounter->pOwner->hMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            do {
                // get the formatted value from the counter

                // compute and format current value
                pdhStatus = PdhiComputeFormattedValue (
                    pThisCounter->CalcFunc,
                    pThisCounter->plCounterInfo.dwCounterType,
                    pThisCounter->lScale,
                    PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                    &pThisCounter->ThisValue,
                    &pThisCounter->LastValue,
                    &pThisCounter->TimeBase,
                    0L,
                    &pdhValue);

                if ((pdhStatus == ERROR_SUCCESS) &&
                    ((pdhValue.CStatus == PDH_CSTATUS_VALID_DATA) ||
                     (pdhValue.CStatus == PDH_CSTATUS_NEW_DATA))) {
                    // then this is a valid data value so print it
                    dwBufferSize = sprintf (szValueBuffer,
                        PdhiszFmtRealValue, cDelim, pdhValue.doubleValue);
                } else {
                    // invalid data so show a blank data value
                    dwBufferSize = sprintf (szValueBuffer, PdhiszFmtStringValue, cDelim, caszSpace);
                    // reset error
                    pdhStatus = ERROR_SUCCESS;
                }

                dwNewStringLen = dwBufferSize;

                if ((dwNewStringLen+dwStringBufferUsed) >= dwStringBufferSize) {
                    LPTSTR szNewString;
                    dwStringBufferSize += SMALL_BUFFER_SIZE;
                    szNewString = G_REALLOC (szOutputString, dwStringBufferSize);
                    if (szNewString == NULL) {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        break; // out of DO loop
                    }
                    else {
                        szOutputString = szNewString;
                    }
                }

                if (pdhStatus != PDH_MEMORY_ALLOCATION_FAILURE) {
                    lstrcatA (szOutputString, szValueBuffer);
                    dwStringBufferUsed += dwNewStringLen;
                }

                // goto the next counter in the list
                pThisCounter = pThisCounter->next.flink; // go to next in list
            } while (pThisCounter != pLog->pQuery->pCounterListHead);
            // free (i.e. unlock) the query
            RELEASE_MUTEX(pThisCounter->pOwner->hMutex);
        }
    }

    if (pdhStatus == PDH_MEMORY_ALLOCATION_FAILURE) // cannot go further
        goto  endLogText;

    // test to see if the caller wants to append user strings to the log

    if ((pLog->dwLogFormat & PDH_LOG_OPT_MASK) == PDH_LOG_OPT_USER_STRING) {
        // they want to write user data  so  see if they've passed in a
        // display string
        if (szUserString != NULL) {
            // get size in chars
            dwUserStringSize = lstrlenW (szUserString) + 1;
            // allocate larger buffer to accomodate DBCS characters
            dwUserStringSize = dwUserStringSize * 3 * sizeof(CHAR);
            szLocalUserString = (LPSTR) G_ALLOC (dwUserStringSize);
            if (szLocalUserString != NULL) {
                memset(szLocalUserString, 0, dwUserStringSize);
                dwUserStringSize = WideCharToMultiByte(
                                _getmbcp(),
                                0,
                                szUserString,
                                lstrlenW(szUserString),
                                szLocalUserString,
                                dwUserStringSize,
                                NULL,
                                NULL);
                bDefaultUserString = FALSE;
            } else {
                bDefaultUserString = TRUE;
            }
        } else {
            bDefaultUserString = TRUE;
        }

        if (bDefaultUserString) {
            szLocalUserString = (LPSTR)caszSpace;
            dwUserStringSize = lstrlenA (szLocalUserString);
        }

#pragma warning (disable : 4701) // szLocalUserString is init'd above
        dwBufferSize = sprintf (szValueBuffer,
            PdhiszFmtStringValue, cDelim, szLocalUserString);
#pragma warning (default : 4701)    

        dwNewStringLen = dwBufferSize;

        if ((dwNewStringLen + dwStringBufferUsed) >= dwStringBufferSize) {
            LPTSTR szNewString;

            dwStringBufferSize += SMALL_BUFFER_SIZE;
            szNewString = G_REALLOC (szOutputString, dwStringBufferSize);
            if (szNewString == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else {
                szOutputString = szNewString;
            }
        }

        if (pdhStatus != PDH_MEMORY_ALLOCATION_FAILURE) {
            lstrcatA (szOutputString, szValueBuffer);
            dwStringBufferUsed += dwNewStringLen;
        }

        if (!bDefaultUserString) {
            G_FREE (szLocalUserString);
        }

    }

    if (pdhStatus == PDH_MEMORY_ALLOCATION_FAILURE)
        goto endLogText;

    if ((PdhidwRecordTerminatorLength + dwStringBufferUsed) >= dwStringBufferSize) {
        LPTSTR szNewString;
        dwStringBufferSize += PdhidwRecordTerminatorLength;
        szNewString = G_REALLOC (szOutputString, dwStringBufferSize);
        if (szNewString == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            szOutputString = szNewString;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        lstrcatA (szOutputString, PdhiszRecordTerminator);
        dwStringBufferUsed += PdhidwRecordTerminatorLength;

        liFileSize.LowPart = GetFileSize (
            pLog->hLogFileHandle,
            (LPDWORD)&liFileSize.HighPart);
        // add in new record to see if it will fit.
        liFileSize.QuadPart += dwStringBufferUsed;
        // test for maximum allowable filesize
        if (liFileSize.QuadPart <= MAX_TEXT_FILE_SIZE) {

            // write  the record terminator
            if (!WriteFile (pLog->hLogFileHandle,
                (LPCVOID)szOutputString,
                dwStringBufferUsed,
                &dwBytesWritten,
                NULL)) {
                pdhStatus = GetLastError ();
            } else if (pLog->pQuery->hLog == H_REALTIME_DATASOURCE || pLog->pQuery->hLog == H_WBEM_DATASOURCE) {
                FlushFileBuffers(pLog->hLogFileHandle);
            }
        } else {
            pdhStatus = ERROR_LOG_FILE_FULL;
        } 

        if (dwStringBufferUsed> pLog->dwMaxRecordSize) {
            // then update the buffer size
            pLog->dwMaxRecordSize = dwStringBufferUsed;
        }
    }

    endLogText: 
    G_FREE (szOutputString);

    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumMachinesFromTextLog (
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    BOOL        bUnicodeDest
)
{
    PDH_STATUS  pdhStatus;
    PDH_STATUS  pdhBuffStatus = ERROR_SUCCESS;
    LPSTR       szBuffer;
    CHAR        szTemp[4];
    CHAR        cDelim;
    PPDH_COUNTER_PATH_ELEMENTS_A    pInfo;
    DWORD       dwInfoBufferSize;
    DWORD       dwBufferUsed;
    DWORD       dwNewBuffer;
    DWORD       dwIndex;
    DWORD       dwItemLength;
    DWORD       dwBufferLength;
    DWORD       dwItemCount = 0;
    LPVOID      LocalBuffer = NULL;
    LPVOID      TempBuffer;
    DWORD       LocalBufferSize = 0;

    LocalBuffer = G_ALLOC(MEDIUM_BUFFER_SIZE);
    if (LocalBuffer == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }
    LocalBufferSize = MEDIUM_BUFFER_SIZE;
    memset(LocalBuffer, 0, MEDIUM_BUFFER_SIZE);
    if (pBuffer) {
        memset(pBuffer, 0, * lpdwBufferSize);
    }

    pInfo = (PPDH_COUNTER_PATH_ELEMENTS_A) G_ALLOC (MEDIUM_BUFFER_SIZE);
    if (pInfo == NULL) {
        G_FREE(LocalBuffer);
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    szBuffer = &szTemp[0];

    // what's in szReturn is not important since we'll be reading the
    // data from the "last Record read" buffer

    pdhStatus = PdhiReadOneTextLogRecord (
        pLog,
        TEXTLOG_HEADER_RECORD,
        szBuffer,
        1); // we're lying to prevent copying the record.

    if (pLog->dwLastRecordRead == TEXTLOG_HEADER_RECORD) {
        // then the seek worked and we can use the buffer
        cDelim = (CHAR)((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ?
            COMMA_DELIMITER : TAB_DELIMITER);

        dwBufferLength = lstrlenA((LPSTR)pLog->pLastRecordRead)+1;
        szBuffer = G_ALLOC (dwBufferLength);
        if (szBuffer != NULL) {
            dwBufferUsed = 0;
            dwIndex = 0;
            while ((dwItemLength = PdhiGetStringFromDelimitedListA(
                (LPSTR)pLog->pLastRecordRead,
                ++dwIndex,
                cDelim,
                PDHI_GSFDL_REMOVE_QUOTES | PDHI_GSFDL_REMOVE_NONPRINT,
                szBuffer,
                dwBufferLength)) != 0) {

                if (dwItemLength > 0) {
                    dwInfoBufferSize = MEDIUM_BUFFER_SIZE;
                    // parse the path, pull the machine name out and
                    memset(pInfo, 0, MEDIUM_BUFFER_SIZE);
                    pdhStatus = PdhParseCounterPathA (
                        szBuffer,
                        pInfo,
                        &dwInfoBufferSize,
                        0);

                    if (pdhStatus == ERROR_SUCCESS) {
                        if (szBuffer[1] != '\\') {
                            pInfo->szMachineName[0] = '.';
                            pInfo->szMachineName[1] = '\0';
                        }
                        // add it to the list if it will fit
                        if (pInfo->szMachineName != NULL) {
                            // include sizeof delimiter char
                            dwNewBuffer = (lstrlenA (pInfo->szMachineName) + 1) *
                                (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR));

                            while (  LocalBufferSize
                                   < (dwBufferUsed + dwNewBuffer)) {
                                TempBuffer = LocalBuffer;
                                LocalBuffer = G_REALLOC(TempBuffer,
                                        LocalBufferSize + MEDIUM_BUFFER_SIZE);
                                if (LocalBuffer == NULL) {
                                    G_FREE(szBuffer);
                                    G_FREE(TempBuffer);
                                    G_FREE(pInfo);
                                    return PDH_MEMORY_ALLOCATION_FAILURE;
                                }
                                LocalBufferSize += MEDIUM_BUFFER_SIZE;
                            }
                            dwNewBuffer = AddUniqueStringToMultiSz (
                                    (LPVOID) LocalBuffer,
                                    pInfo->szMachineName,
                                    bUnicodeDest);
                        } else {
                            dwNewBuffer = 0;
                        }

                        if (dwNewBuffer > 0) {
                            // string was added so update size used.
                            dwBufferUsed = dwNewBuffer
                                         * (bUnicodeDest ? sizeof(WCHAR)
                                                         : sizeof(CHAR));
                            dwItemCount++;
                        }
                    }
                }
            }
            if (dwItemCount > 0) {
                // then the routine was successful. Errors that occurred
                // while scanning will be ignored as long as at least
                // one entry was successfully read

                pdhStatus = pdhBuffStatus;
            }

            // update the buffer used or required.
            if (pBuffer && dwBufferUsed <= * lpdwBufferSize) {
                RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed);
            }
            else {
                if (pBuffer)
                    RtlCopyMemory(pBuffer, LocalBuffer, * lpdwBufferSize);
                dwBufferUsed += (bUnicodeDest) ? sizeof(WCHAR) : sizeof(CHAR);
                pdhStatus = PDH_MORE_DATA;
            }
            *lpdwBufferSize = dwBufferUsed;

            G_FREE (szBuffer);
        } else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    } else {
        // unable to read header record
       pdhStatus = PDH_UNABLE_READ_LOG_HEADER;
    }
    G_FREE (pInfo);
    G_FREE(LocalBuffer);
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectsFromTextLog (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szMachineName,
    IN  LPVOID      pBuffer,
    IN  LPDWORD     pcchBufferSize,
    IN  DWORD       dwDetailLevel,
    IN  BOOL        bUnicodeDest
)
{
    PDH_STATUS  pdhStatus;
    PDH_STATUS  pdhBuffStatus = ERROR_SUCCESS;
    LPSTR       szBuffer;
    CHAR        szTemp[4];
    CHAR        cDelim;
    PPDH_COUNTER_PATH_ELEMENTS_A    pInfo;
    DWORD       dwInfoBufferSize;
    DWORD       dwBufferUsed;
    DWORD       dwNewBuffer;
    DWORD       dwIndex;
    DWORD       dwItemLength;
    DWORD       dwBufferLength;
    WCHAR       wszMachineName[MAX_PATH];
    DWORD       dwMachineNameLength;
    DWORD       dwItemCount = 0;
    LPVOID      LocalBuffer = NULL;
    LPVOID      TempBuffer;
    DWORD       LocalBufferSize = 0;

    UNREFERENCED_PARAMETER (dwDetailLevel);

    pInfo = (PPDH_COUNTER_PATH_ELEMENTS_A) G_ALLOC (MEDIUM_BUFFER_SIZE);
    if (pInfo == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }
    szBuffer = &szTemp[0];

    LocalBuffer = G_ALLOC(MEDIUM_BUFFER_SIZE);
    if (LocalBuffer == NULL) {
        G_FREE(pInfo);
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }
    memset(LocalBuffer, 0, MEDIUM_BUFFER_SIZE);
    LocalBufferSize = MEDIUM_BUFFER_SIZE;
    if (pBuffer) {
        memset(pBuffer, 0, * pcchBufferSize);
    }

    // what's in szReturn is not important since we'll be reading the
    // data from the "last Record read" buffer

    pdhStatus = PdhiReadOneTextLogRecord (
        pLog,
        TEXTLOG_HEADER_RECORD,
        szBuffer,
        1); // we're lying to prevent copying the record.

    if (pLog->dwLastRecordRead == TEXTLOG_HEADER_RECORD) {
        // then the seek worked and we can use the buffer
        cDelim = (CHAR)((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ?
            COMMA_DELIMITER : TAB_DELIMITER);

        dwBufferLength = lstrlenA((LPSTR)pLog->pLastRecordRead)+1;
        szBuffer = G_ALLOC (dwBufferLength);
        if (szBuffer != NULL) {
            dwBufferUsed = 0;
            dwIndex = 0;
            while ((dwItemLength = PdhiGetStringFromDelimitedListA(
                (LPSTR)pLog->pLastRecordRead,
                ++dwIndex,
                cDelim,
                PDHI_GSFDL_REMOVE_QUOTES | PDHI_GSFDL_REMOVE_NONPRINT,
                szBuffer,
                dwBufferLength)) != 0) {

                if (dwItemLength > 0) {
                    dwInfoBufferSize = MEDIUM_BUFFER_SIZE;
                    // parse the path, pull the machine name out and
                    memset(pInfo, 0, MEDIUM_BUFFER_SIZE);
                    pdhStatus = PdhParseCounterPathA (
                        szBuffer,
                        pInfo,
                        &dwInfoBufferSize,
                        0);

                    if (pdhStatus == ERROR_SUCCESS) {
                        if (szBuffer[1] != '\\') {
                            pInfo->szMachineName[0] = '.';
                            pInfo->szMachineName[1] = '\0';
                        }
                        // add it to the list if it will fit and it's from
                        // the desired machine
                        memset(wszMachineName, 0, sizeof(WCHAR) * MAX_PATH);
                        dwMachineNameLength = MAX_PATH;
                        MultiByteToWideChar(_getmbcp(),
                                            0,
                                            pInfo->szMachineName,
                                            lstrlenA(pInfo->szMachineName),
                                            (LPWSTR) wszMachineName,
                                            dwMachineNameLength);
                        if (lstrcmpiW(szMachineName, wszMachineName) == 0) {
                            dwNewBuffer = (lstrlenA (pInfo->szObjectName) + 1) *
                                (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR));

                            while (  LocalBufferSize
                                   < (dwBufferUsed + dwNewBuffer)) {
                                TempBuffer = LocalBuffer;
                                LocalBuffer = G_REALLOC(TempBuffer,
                                        LocalBufferSize + MEDIUM_BUFFER_SIZE);
                                if (LocalBuffer == NULL) {
                                    G_FREE(szBuffer);
                                    G_FREE(TempBuffer);
                                    G_FREE(pInfo);
                                    return PDH_MEMORY_ALLOCATION_FAILURE;
                                }
                                LocalBufferSize += MEDIUM_BUFFER_SIZE;
                            }

                            dwNewBuffer = AddUniqueStringToMultiSz (
                                    (LPVOID) LocalBuffer,
                                    pInfo->szObjectName,
                                    bUnicodeDest);

                            if (dwNewBuffer > 0) {
                                // string was added so update size used.
                                dwBufferUsed = dwNewBuffer
                                             * (bUnicodeDest ? sizeof(WCHAR)
                                                             : sizeof(CHAR));
                                dwItemCount++;
                            }
                        }
                    }
                }
            }

            if (dwItemCount > 0) {
                // then the routine was successful. Errors that occurred
                // while scanning will be ignored as long as at least
                // one entry was successfully read
                pdhStatus = pdhBuffStatus;
            }

            // copy buffer size used or required

            if (pBuffer && dwBufferUsed <= * pcchBufferSize) {
                RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed);
            }
            else {
                if (pBuffer)
                    RtlCopyMemory(pBuffer, LocalBuffer, * pcchBufferSize);
                dwBufferUsed += (bUnicodeDest) ? sizeof(WCHAR) : sizeof(CHAR);
                pdhStatus = PDH_MORE_DATA;
            }

            * pcchBufferSize = dwBufferUsed;

            G_FREE (szBuffer);
        } else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }
    G_FREE (pInfo);
    G_FREE(LocalBuffer);
    return pdhStatus;
}

ULONG HashCounter(
    LPWSTR szCounterName
)
{
    ULONG       h = 0;
    ULONG       a = 31415;  //a, b, k are primes
    const ULONG k = 16381;
    const ULONG b = 27183;
    LPWSTR      szThisChar;

    if (szCounterName) {
        for (szThisChar = szCounterName; * szThisChar; szThisChar ++) {
            h = (a * h + ((ULONG) (* szThisChar))) % k;
            a = a * b % (k - 1);
        }
    }
    return (h % HASH_TABLE_SIZE);
}

void
PdhiInitCounterHashTable(
    IN PDHI_COUNTER_TABLE pTable
)
{
    ZeroMemory(pTable, sizeof(PDHI_COUNTER_TABLE));
}

void
PdhiResetInstanceCount(
    IN PDHI_COUNTER_TABLE pTable
)
{
    PLIST_ENTRY     pHeadInst;
    PLIST_ENTRY     pNextInst;
    PPDHI_INSTANCE  pInstance;
    PPDHI_INST_LIST pInstList;
    DWORD           i;

    for (i = 0; i < HASH_TABLE_SIZE; i ++) {
        pInstList = pTable[i];
        while (pInstList != NULL) {
            if (! IsListEmpty(& pInstList->InstList)) {
                pHeadInst = & pInstList->InstList;
                pNextInst = pHeadInst->Flink;
                while (pNextInst != pHeadInst) {
                    pInstance = CONTAINING_RECORD(
                                    pNextInst, PDHI_INSTANCE, Entry);
                    pInstance->dwCount = 0;
                    pNextInst = pNextInst->Flink;
                }
            }
            pInstList = pInstList->pNext;
        }
    }
}

PDH_FUNCTION
PdhiFindCounterInstList(
    IN  PDHI_COUNTER_TABLE pHeadList,
    IN  LPWSTR             szCounter,
    OUT PPDHI_INST_LIST  * pInstList
)
{
    PDH_STATUS      Status     = ERROR_SUCCESS;
    ULONG           lIndex     = HashCounter(szCounter);
    PPDHI_INST_LIST pLocalList = pHeadList[lIndex];
    PPDHI_INST_LIST pRtnList   = NULL;

    * pInstList = NULL;
    while (pLocalList != NULL) {
        if (lstrcmpiW(pLocalList->szCounter, szCounter) == 0) {
            pRtnList = pLocalList;
            break;
        }
        pLocalList = pLocalList->pNext;
    }

    if (pRtnList == NULL) {
        pRtnList = G_ALLOC(sizeof(PDHI_INST_LIST) +
                   sizeof(WCHAR) * (lstrlenW(szCounter) + 1));
        if (pRtnList == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        pRtnList->szCounter = (LPWSTR)
                        (((LPBYTE) pRtnList) + sizeof(PDHI_INST_LIST));
        lstrcpyW(pRtnList->szCounter, szCounter);
        InitializeListHead(& pRtnList->InstList);

        pRtnList->pNext   = pHeadList[lIndex];
        pHeadList[lIndex] = pRtnList;
    }

Cleanup:
    if (Status == ERROR_SUCCESS) {
        * pInstList = pRtnList;
    }
    return Status;
}

PDH_FUNCTION
PdhiFindInstance(
    IN  PLIST_ENTRY      pHeadInst,
    IN  LPWSTR           szInstance,
    IN  BOOLEAN          bUpdateCount,
    OUT PPDHI_INSTANCE * pInstance
)
{
    PDH_STATUS      Status = ERROR_SUCCESS;
    PLIST_ENTRY     pNextInst;
    PPDHI_INSTANCE  pLocalInst;
    PPDHI_INSTANCE  pRtnInst = NULL;

    * pInstance = NULL;

    if (! IsListEmpty(pHeadInst)) {
        pNextInst = pHeadInst->Flink;
        while (pNextInst != pHeadInst) {
            pLocalInst = CONTAINING_RECORD(pNextInst, PDHI_INSTANCE, Entry);
            if (lstrcmpiW(pLocalInst->szInstance, szInstance) == 0) {
                pRtnInst = pLocalInst;
                break;
            }
            pNextInst = pNextInst->Flink;
        }
    }

    if (pRtnInst == NULL) {
        pRtnInst = G_ALLOC(sizeof(PDHI_INSTANCE) +
                           sizeof(WCHAR) * (lstrlenW(szInstance) + 1));
        if (pRtnInst == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        pRtnInst->szInstance = (LPWSTR)
                        (((LPBYTE) pRtnInst) + sizeof(PDHI_INSTANCE));
        lstrcpyW(pRtnInst->szInstance, szInstance);
        pRtnInst->dwCount = pRtnInst->dwTotal = 0;
        InsertTailList(pHeadInst, & pRtnInst->Entry);
    }

    if (bUpdateCount) {
        pRtnInst->dwCount ++;
        if (pRtnInst->dwCount > pRtnInst->dwTotal) {
            pRtnInst->dwTotal = pRtnInst->dwCount;
        }
    }
    else if (pRtnInst->dwCount == 0) {
        pRtnInst->dwCount = pRtnInst->dwTotal = 1;
    }

Cleanup:
    if (Status == ERROR_SUCCESS) {
        * pInstance = pRtnInst;
    }
    return Status;
}

DWORD
AddStringToMultiSz(
    IN  LPVOID  mszDest,
    IN  LPWSTR  szSource,
    IN  BOOL    bUnicodeDest
)
{
    LPVOID szDestElem;
    DWORD  dwReturnLength;
    LPSTR  aszSource = NULL;
    DWORD  dwLength;

    if ((mszDest == NULL) || (szSource == NULL)
                          || (* szSource == L'\0')) {
        return 0;
    }

    if (!bUnicodeDest) {
        dwLength = lstrlenW(szSource) + 1;
        aszSource = G_ALLOC(dwLength * 3 * sizeof(CHAR));
        if (aszSource != NULL) {
            WideCharToMultiByte(_getmbcp(),
                                0,
                                szSource,
                                lstrlenW(szSource),
                                aszSource,
                                dwLength,
                                NULL,
                                NULL);
            dwReturnLength = 1;
        }
        else {
            dwReturnLength = 0;
        }
    }
    else {
        dwReturnLength = 1;
    }

    if (dwReturnLength > 0) {
        for (szDestElem = mszDest;
             (bUnicodeDest ? (* (LPWSTR) szDestElem != L'\0')
                           : (* (LPSTR)  szDestElem != '\0'));
                ) {
            if (bUnicodeDest) {
                szDestElem = (LPVOID) ((LPWSTR) szDestElem
                           + (lstrlenW((LPCWSTR) szDestElem) + 1));
            }
            else {
                szDestElem = (LPVOID) ((LPSTR) szDestElem
                           + (lstrlenA((LPCSTR) szDestElem) + 1));
            }
        }

        if (bUnicodeDest) {
            lstrcpyW ((LPWSTR)szDestElem, szSource);
            szDestElem = (LPVOID)((LPWSTR)szDestElem + lstrlenW(szSource) + 1);
            * ((LPWSTR)szDestElem) = L'\0';
            dwReturnLength = (DWORD)((LPWSTR)szDestElem - (LPWSTR)mszDest);
        }
        else {
            lstrcpyA ((LPSTR)szDestElem, aszSource);
            szDestElem = (LPVOID)((LPSTR)szDestElem + lstrlenA(szDestElem) + 1);
            * ((LPSTR)szDestElem) = '\0';
            dwReturnLength = (DWORD)((LPSTR)szDestElem - (LPSTR)mszDest);
        }
    }

    if (aszSource != NULL) {
        G_FREE (aszSource);
    }

    return (DWORD) dwReturnLength;
}

PDH_FUNCTION
PdhiEnumObjectItemsFromTextLog (
    IN  PPDHI_LOG          pLog,
    IN  LPCWSTR            szMachineName,
    IN  LPCWSTR            szObjectName,
    IN  PDHI_COUNTER_TABLE CounterTable,
    IN  DWORD              dwDetailLevel,
    IN  DWORD              dwFlags
)
{
    PDH_STATUS  pdhStatus;
    PDH_STATUS  pdhBuffStatus = ERROR_SUCCESS;
    LPSTR       szBuffer;
    CHAR        szTemp[4];
    CHAR        cDelim;
    PPDH_COUNTER_PATH_ELEMENTS_A    pInfo = NULL;
    DWORD       dwInfoBufferSize;
    DWORD       dwIndex;
    DWORD       dwItemLength;
    DWORD       dwBufferLength;
    WCHAR       wszMachineName[MAX_PATH];
    WCHAR       wszObjectName[MAX_PATH];
    WCHAR       wszCounterName[MAX_PATH];
    WCHAR       wszInstanceName[MAX_PATH];
    CHAR        szFullInstanceName[MAX_PATH];
    DWORD       dwMachineNameLength;
    DWORD       dwObjectNameLength;
    DWORD       dwCounterNameLength;
    DWORD       dwInstanceNameLength;
    DWORD       dwItemCount = 0;
    CHAR        szIndexNumber[20];

    PPDHI_INSTANCE  pInstance;
    PPDHI_INST_LIST pInstList;

    UNREFERENCED_PARAMETER (dwDetailLevel);
    UNREFERENCED_PARAMETER (dwFlags);

    pInfo = (PPDH_COUNTER_PATH_ELEMENTS_A) G_ALLOC (MEDIUM_BUFFER_SIZE);
    if (pInfo == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    szBuffer = & szTemp[0];

    // what's in szReturn is not important since we'll be reading the
    // data from the "last Record read" buffer

    pdhStatus = PdhiReadOneTextLogRecord (
        pLog,
        TEXTLOG_HEADER_RECORD,
        szBuffer,
        1); // we're lying to prevent copying the record.

    if (pLog->dwLastRecordRead == TEXTLOG_HEADER_RECORD) {
        // then the seek worked and we can use the buffer
        cDelim = (CHAR)((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ?
            COMMA_DELIMITER : TAB_DELIMITER);

        dwBufferLength = pLog->dwMaxRecordSize+1;
        szBuffer = G_ALLOC (dwBufferLength);
        if (szBuffer != NULL) {
            dwIndex = 0;
            while ((dwItemLength = PdhiGetStringFromDelimitedListA(
                        (LPSTR)pLog->pLastRecordRead,
                        ++dwIndex,
                        cDelim,
                        PDHI_GSFDL_REMOVE_QUOTES | PDHI_GSFDL_REMOVE_NONPRINT,
                        szBuffer,
                        dwBufferLength)) != 0) {
                if (dwItemLength > 0) {
                    dwInfoBufferSize = MEDIUM_BUFFER_SIZE;
                    // parse the path, pull the machine name out and
                    memset(pInfo, 0, MEDIUM_BUFFER_SIZE);
                    pdhStatus = PdhParseCounterPathA (
                                szBuffer,
                                pInfo,
                                &dwInfoBufferSize,
                                0);

                    if (pdhStatus == ERROR_SUCCESS) {
                        if (szBuffer[1] != '\\') {
                            pInfo->szMachineName[0] = '.';
                            pInfo->szMachineName[1] = '\0';
                        }
                        // add it to the list if it will fit and it's from
                        // the desired machine
                        memset(wszMachineName, 0, sizeof(WCHAR) * MAX_PATH);
                        dwMachineNameLength = MAX_PATH;
                        MultiByteToWideChar(_getmbcp(),
                                            0,
                                            pInfo->szMachineName,
                                            lstrlenA(pInfo->szMachineName),
                                            (LPWSTR) wszMachineName,
                                            dwMachineNameLength);
                        if (lstrcmpiW(wszMachineName, szMachineName) == 0) {
                            memset(wszObjectName, 0, sizeof(WCHAR) * MAX_PATH);
                            dwObjectNameLength = MAX_PATH;
                            MultiByteToWideChar(_getmbcp(),
                                                0,
                                                pInfo->szObjectName,
                                                lstrlenA(pInfo->szObjectName),
                                                (LPWSTR) wszObjectName,
                                                dwObjectNameLength);
                            if (lstrcmpiW(wszObjectName, szObjectName) == 0) {
                                memset(wszCounterName, 0, sizeof(WCHAR) * MAX_PATH);
                                dwCounterNameLength = MAX_PATH;
                                MultiByteToWideChar(_getmbcp(),
                                                    0,
                                                    pInfo->szCounterName,
                                                    lstrlenA(pInfo->szCounterName),
                                                    (LPWSTR) wszCounterName,
                                                    dwCounterNameLength);
                                pdhBuffStatus = PdhiFindCounterInstList(
                                            CounterTable,
                                            wszCounterName,
                                            & pInstList);
                                if (pdhBuffStatus != ERROR_SUCCESS) {
                                    continue;
                                }

                                if (   pInfo->szInstanceName != NULL
                                    && pInfo->szInstanceName[0] != '\0') {
                                    if (pInfo->szParentInstance == NULL) {
                                        // then the name is just the instance
                                        szFullInstanceName[0] = 0;
                                    } else {
                                        // we need to build the instance string from
                                        // the parent and the child
                                        lstrcpyA (szFullInstanceName,
                                            pInfo->szParentInstance);
                                        lstrcatA (szFullInstanceName, caszSlash);
                                    }

                                    lstrcatA (szFullInstanceName,
                                        pInfo->szInstanceName);

                                    if ((LONG)pInfo->dwInstanceIndex > 0) {
                                        // append instance index to instance name if it's > 0
                                        szIndexNumber[0] = POUNDSIGN_A;
                                        _ultoa (pInfo->dwInstanceIndex, &szIndexNumber[1], 10);
                                        lstrcatA (szFullInstanceName, szIndexNumber);
                                    }

                                    memset(wszInstanceName, 0, sizeof(WCHAR) * MAX_PATH);
                                    dwInstanceNameLength = MAX_PATH;
                                    MultiByteToWideChar(_getmbcp(),
                                                        0,
                                                        szFullInstanceName,
                                                        lstrlenA(szFullInstanceName),
                                                        (LPWSTR) wszInstanceName,
                                                        dwInstanceNameLength);
                                    pdhBuffStatus = PdhiFindInstance(
                                            & pInstList->InstList,
                                            wszInstanceName,
                                            TRUE,
                                            & pInstance);
                                }

                                if (pdhBuffStatus == ERROR_SUCCESS) {
                                    dwItemCount++;
                                }
                            } // else not this object
                        } // else not this machine
                    }
                }
            }

            if (dwItemCount > 0) {
                // then the routine was successful. Errors that occurred
                // while scanning will be ignored as long as at least
                // one entry was successfully read
                pdhStatus = pdhBuffStatus;
            }

            G_FREE (szBuffer);
        } else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }

Cleanup:
    if (pInfo) {
        G_FREE (pInfo);
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiGetMatchingTextLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  LONGLONG    *pStartTime,
    IN  LPDWORD     pdwIndex
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    CHAR        szSmallBuffer[MAX_PATH];
    DWORD       dwRecordId = TEXTLOG_FIRST_DATA_RECORD;
    CHAR        cDelim;
    FILETIME    RecordTimeStamp;
    LONGLONG    RecordTimeValue;
    LONGLONG    LastTimeValue = 0;

    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode
    cDelim = (CHAR)((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ?
        COMMA_DELIMITER : TAB_DELIMITER);

    if ((*pStartTime & 0xFFFFFFFF00000000) == 0xFFFFFFFF00000000) {
        dwRecordId = (DWORD)(*pStartTime & 0x00000000FFFFFFFF);
        LastTimeValue = *pStartTime;
        if (dwRecordId == 0) return PDH_ENTRY_NOT_IN_LOG_FILE;
    } else {
        dwRecordId = TEXTLOG_FIRST_DATA_RECORD;
    }

    pdhStatus = PdhiReadOneTextLogRecord (
        pLog,
        dwRecordId,
        szSmallBuffer,
        1); // to prevent copying the record

    while (   pdhStatus == ERROR_SUCCESS
           || pdhStatus == PDH_MORE_DATA
           || pdhStatus == PDH_INSUFFICIENT_BUFFER) {
        if (PdhiGetStringFromDelimitedListA(
                (LPSTR)pLog->pLastRecordRead,
                0,  // timestamp is first entry
                cDelim,
                PDHI_GSFDL_REMOVE_QUOTES | PDHI_GSFDL_REMOVE_NONPRINT,
                szSmallBuffer,
                MAX_PATH) > 0) {
            // convert ASCII timestamp to LONGLONG value for comparison
            PdhiDateStringToFileTimeA (szSmallBuffer, &RecordTimeStamp);
            RecordTimeValue = MAKELONGLONG(RecordTimeStamp.dwLowDateTime,
                                           RecordTimeStamp.dwHighDateTime);
            if ((*pStartTime == RecordTimeValue) || (*pStartTime == 0)) {
                // found the match so bail here
                LastTimeValue = RecordTimeValue;
                break;
            } else if (RecordTimeValue > *pStartTime) {
                // then this is the first record > than the desired time
                // so the desired value is the one before this one
                // unless it's the first data record of the log
                if (dwRecordId > TEXTLOG_FIRST_DATA_RECORD) {
                    dwRecordId--;
                } else {
                    // this hasnt' been initialized yet.
                    LastTimeValue = RecordTimeValue;
                }
                break;
            } else {
                // save value for next trip through loop
                LastTimeValue = RecordTimeValue;
                // advance record counter and try the next entry
                dwRecordId++;
            }
        } else {
            // no timestamp field so ignore this record.
        }
        // read the next record in the file
        pdhStatus = PdhiReadOneTextLogRecord (
            pLog,
            dwRecordId,
            szSmallBuffer,
            1); // to prevent copying the record
    }
    if (   pdhStatus == ERROR_SUCCESS
        || pdhStatus == PDH_MORE_DATA
        || pdhStatus == PDH_INSUFFICIENT_BUFFER) {
        // then dwRecordId is the desired entry
        *pdwIndex = dwRecordId;
        *pStartTime = LastTimeValue;
        pdhStatus = ERROR_SUCCESS;
    } else {
        pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetCounterValueFromTextLog (
    IN  PPDHI_LOG           pLog,
    IN  DWORD               dwIndex,
    IN  PERFLIB_COUNTER     *pPath,
    IN  PPDH_RAW_COUNTER    pValue
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    CHAR        szSmallBuffer[MAX_PATH];
    CHAR        cDelim;
    FILETIME    RecordTimeStamp;
    DOUBLE      dValue;


    memset (&RecordTimeStamp, 0, sizeof(RecordTimeStamp));
    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode
    cDelim = (CHAR)((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ?
        COMMA_DELIMITER : TAB_DELIMITER);

    pdhStatus = PdhiReadOneTextLogRecord (
            pLog,
            dwIndex,
            szSmallBuffer,
            1); // to prevent copying the record

    if (   pdhStatus == ERROR_SUCCESS
        || pdhStatus == PDH_MORE_DATA
        || pdhStatus == PDH_INSUFFICIENT_BUFFER) {
        // the specified entry in the log is the dwCounterId value
        // in the perflib buffer
        if (PdhiGetStringFromDelimitedListA (
                (LPSTR)pLog->pLastRecordRead,
                0,  // timestamp is first entry
                cDelim,
                PDHI_GSFDL_REMOVE_QUOTES | PDHI_GSFDL_REMOVE_NONPRINT,
                szSmallBuffer,
                MAX_PATH) > 0) {
            // convert time stamp string to FileTime value
            PdhiDateStringToFileTimeA (szSmallBuffer, &RecordTimeStamp);
        } else {
            RecordTimeStamp.dwLowDateTime  = 0;
            RecordTimeStamp.dwHighDateTime = 0;
        }

        if (PdhiGetStringFromDelimitedListA(
                (LPSTR) pLog->pLastRecordRead,
                pPath->dwCounterId,
                cDelim,
                PDHI_GSFDL_REMOVE_QUOTES | PDHI_GSFDL_REMOVE_NONPRINT,
                szSmallBuffer,
                MAX_PATH) > 0) {
            // convert ASCII value to Double Float
            if (szSmallBuffer[0] >= '0' && szSmallBuffer[0] <= '9') {
                dValue = atof(szSmallBuffer);
                pValue->CStatus = PDH_CSTATUS_VALID_DATA;
            }
            else {
                dValue = 0.0;
                pValue->CStatus = PDH_CSTATUS_NO_INSTANCE;
            }
            pdhStatus = ERROR_SUCCESS;
            pValue->TimeStamp = RecordTimeStamp;
            (double)pValue->FirstValue = dValue;
            pValue->SecondValue = 0;
            pValue->MultiCount = 1;
        } else {
            pdhStatus = ERROR_SUCCESS;
            // update counter buffer
            pValue->CStatus = PDH_CSTATUS_INVALID_DATA;
            pValue->TimeStamp = RecordTimeStamp;
            (double)pValue->FirstValue = (double)0.0f;
            pValue->SecondValue = 0;
            pValue->MultiCount = 1;
        }
    } else {
        if (pdhStatus == PDH_END_OF_LOG_FILE) {
            pdhStatus = PDH_NO_MORE_DATA;
        }
        // unable to find entry in the log file
        pValue->CStatus = PDH_CSTATUS_INVALID_DATA;
        pValue->TimeStamp = RecordTimeStamp;
        (double)pValue->FirstValue = (double)0.0f;
        pValue->SecondValue = 0;
        pValue->MultiCount = 1;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetTimeRangeFromTextLog (
    IN  PPDHI_LOG       pLog,
    IN  LPDWORD         pdwNumEntries,
    IN  PPDH_TIME_INFO  pInfo,
    IN  LPDWORD         pdwBufferSize
)
/*++
    the first entry in the buffer returned is the total time range covered
    in the file, if there are multiple time blocks in the log file, then
    subsequent entries will identify each segment in the file.
--*/
{
    PDH_STATUS  pdhStatus;
    LONGLONG    llStartTime = MAX_TIME_VALUE;
    LONGLONG    llEndTime = MIN_TIME_VALUE;
    LONGLONG    llThisTime = 0;
    CHAR        cDelim;

    DWORD       dwThisRecord = TEXTLOG_FIRST_DATA_RECORD;
    DWORD       dwValidEntries = 0;

    CHAR        szSmallBuffer[MAX_PATH];
    
    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode
    cDelim = (CHAR)((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ?
        COMMA_DELIMITER : TAB_DELIMITER);

    pdhStatus = PdhiReadOneTextLogRecord (
            pLog,
            dwThisRecord,
            szSmallBuffer,
            1); // to prevent copying the record

    while (pdhStatus == ERROR_SUCCESS
           || pdhStatus == PDH_MORE_DATA
           || pdhStatus == PDH_INSUFFICIENT_BUFFER) {
        if (PdhiGetStringFromDelimitedListA (
                (LPSTR)pLog->pLastRecordRead,
                0,  // timestamp is first entry
                cDelim,
                PDHI_GSFDL_REMOVE_QUOTES | PDHI_GSFDL_REMOVE_NONPRINT,
                szSmallBuffer,
                MAX_PATH) > 0) {
            // convert ASCII timestamp to LONGLONG value for comparison
            PdhiDateStringToFileTimeA (szSmallBuffer, (LPFILETIME)&llThisTime);
            if (llThisTime < llStartTime) {
                llStartTime = llThisTime;
            }
            if (llThisTime > llEndTime) {
                llEndTime = llThisTime;
            }
            dwValidEntries++;
        } else {
            // no timestamp field so ignore this record.
        }
        // read the next record in the file
        pdhStatus = PdhiReadOneTextLogRecord (
            pLog,
            ++dwThisRecord,
            szSmallBuffer,
            1); // to prevent copying the record
    }

    if (pdhStatus == PDH_END_OF_LOG_FILE) {
        // then the whole file was read so update the args.
        if (*pdwBufferSize >=  sizeof(PDH_TIME_INFO)) {
            *(LONGLONG *)(&pInfo->StartTime) = llStartTime;
            *(LONGLONG *)(&pInfo->EndTime) = llEndTime;
            pInfo->SampleCount = dwValidEntries;
            *pdwBufferSize = sizeof(PDH_TIME_INFO);
            *pdwNumEntries = 1;
        } else {
            pdhStatus = PDH_MORE_DATA;
        }
        pdhStatus = ERROR_SUCCESS;
    } else {
        pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiReadRawTextLogRecord (
    IN  PPDHI_LOG    pLog,
    IN  FILETIME     *ftRecord,
    IN  PPDH_RAW_LOG_RECORD     pBuffer,
    IN  LPDWORD                 pdwBufferLength
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    LONGLONG    llStartTime;
    DWORD       dwIndex = 0;
    DWORD       dwSizeRequired;
    DWORD       dwLocalRecordLength; // including terminating NULL

    llStartTime = *(LONGLONG *)ftRecord;

    pdhStatus = PdhiGetMatchingTextLogRecord (
        pLog,
        &llStartTime,
        &dwIndex);

    // copy results from internal log buffer if it'll fit.

    if (pdhStatus == ERROR_SUCCESS) {
        dwLocalRecordLength =
            (lstrlenA ((LPSTR)pLog->pLastRecordRead)) * sizeof (CHAR);
        dwSizeRequired =
              sizeof (PDH_RAW_LOG_RECORD) - sizeof (UCHAR)
            + dwLocalRecordLength;

        if (*pdwBufferLength >= dwSizeRequired) {
            pBuffer->dwRecordType = (DWORD)(LOWORD(pLog->dwLogFormat));
            pBuffer->dwItems = dwLocalRecordLength;
            // copy it
            memcpy (&pBuffer->RawBytes[0], pLog->pLastRecordRead,
                dwLocalRecordLength);
            pBuffer->dwStructureSize = dwSizeRequired;

        } else {
            pdhStatus = PDH_MORE_DATA;
        }

        *pdwBufferLength = dwSizeRequired;
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhiListHeaderFromTextLog (
    IN  PPDHI_LOG   pLogFile,
    IN  LPVOID      pBufferArg,
    IN  LPDWORD     pcchBufferSize,
    IN  BOOL        bUnicode
)
{
    LPVOID      pTempBuffer = NULL;
    LPVOID      pOldBuffer;
    DWORD       dwTempBufferSize;
    CHAR        szLocalPathBuffer[MAX_PATH];

    DWORD       dwIndex;
    DWORD       dwBufferRemaining;
    LPVOID      pNextChar;
    DWORD       dwReturnSize;

    CHAR        cDelimiter;

    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    // read the header record and enum the machine name from the entries

    if (pLogFile->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLogFile->dwMaxRecordSize = 0x010000;
    }

    dwTempBufferSize = pLogFile->dwMaxRecordSize;
    pTempBuffer = G_ALLOC (dwTempBufferSize);
    assert (pTempBuffer != NULL);
    if (pTempBuffer == NULL) {
        assert (GetLastError() == ERROR_SUCCESS);
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    cDelimiter = (CHAR)((LOWORD(pLogFile->dwLogFormat) == PDH_LOG_TYPE_CSV) ?
        COMMA_DELIMITER : TAB_DELIMITER);

    // read in the catalog record

    while ((pdhStatus = PdhiReadOneTextLogRecord (pLogFile, TEXTLOG_HEADER_RECORD,
            pTempBuffer, dwTempBufferSize)) != ERROR_SUCCESS) {
        if ((pdhStatus == PDH_INSUFFICIENT_BUFFER) || (pdhStatus == PDH_MORE_DATA)){ 
            // read the 1st WORD to see if this is a valid record
            pLogFile->dwMaxRecordSize *= 2;
            // realloc a new buffer
            pOldBuffer  = pTempBuffer;
            pTempBuffer = G_REALLOC (pOldBuffer, dwTempBufferSize);
            assert (pTempBuffer != NULL);

            if (pTempBuffer == NULL) {
                // return memory error
                G_FREE(pOldBuffer);
                assert (GetLastError() == ERROR_SUCCESS);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            } 
        } else {
            // some other error was returned so
            // return error from read function
            break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // parse header record into MSZ
        dwIndex = 1;
        dwBufferRemaining = *pcchBufferSize;
        pNextChar = pBufferArg;
        // initialize first character in buffer
        if (bUnicode) {
            *(PWCHAR)pNextChar = 0;
        } else {
            *(LPBYTE)pNextChar = 0;
        }

        do {
            dwReturnSize = PdhiGetStringFromDelimitedListA (
                (LPSTR)pTempBuffer,
                dwIndex,
                cDelimiter,
                PDHI_GSFDL_REMOVE_QUOTES | PDHI_GSFDL_REMOVE_NONPRINT,
                szLocalPathBuffer,
                MAX_PATH);
            if (dwReturnSize > 0) {
                // copy to buffer
                if (dwReturnSize < dwBufferRemaining) {
                    if (bUnicode) {
                        MultiByteToWideChar(_getmbcp(),
                                            0,
                                            szLocalPathBuffer,
                                            lstrlenA(szLocalPathBuffer),
                                            (LPWSTR) pNextChar,
                                            dwReturnSize);
                        pNextChar = (LPVOID)((PWCHAR)pNextChar + dwReturnSize);
                        *(PWCHAR)pNextChar = 0;
                        pNextChar = (LPVOID)((PWCHAR)pNextChar + 1);
                    } else {
                        lstrcpyA ((LPSTR)pNextChar, szLocalPathBuffer);
                        pNextChar = (LPVOID)((LPBYTE)pNextChar + dwReturnSize);
                        *(LPBYTE)pNextChar = 0;
                        pNextChar = (LPVOID)((PCHAR)pNextChar + 1);
                    }
                    dwBufferRemaining -= dwReturnSize;
                } else {
                    pdhStatus = PDH_MORE_DATA;
                }
                dwIndex++;
            }
        } while (dwReturnSize > 0); // end loop
        // add MSZ terminator
        if (1 < dwBufferRemaining) {
            if (bUnicode) {
                *(PWCHAR)pNextChar = 0;
                pNextChar = (LPVOID)((PWCHAR)pNextChar + 1);
            } else {
                *(LPBYTE)pNextChar = 0;
                pNextChar = (LPVOID)((PCHAR)pNextChar + 1);
            }
            dwBufferRemaining -= dwReturnSize;
            pdhStatus = ERROR_SUCCESS;
        } else {
            pdhStatus = PDH_MORE_DATA;
        }
    }
    if (pTempBuffer) G_FREE(pTempBuffer);

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log_text.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    log_text.h

Abstract:

    <abstract>

--*/

#ifndef _LOG_TEXT_H_
#define _LOG_TEXT_H_

PDH_FUNCTION
PdhiOpenInputTextLog (
    IN  PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiOpenOutputTextLog (
    IN  PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiCloseTextLog (
    IN  PPDHI_LOG   pLog,
    IN  DWORD       dwFlags
);

PDH_FUNCTION
PdhiGetTextLogCounterInfo (
    IN  PPDHI_LOG       pLog,
    IN  PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiWriteTextLogHeader (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szUserCaption
);

PDH_FUNCTION
PdhiWriteTextLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  SYSTEMTIME  *pTimeStamp,
    IN  LPCWSTR     szUserString
);

PDH_FUNCTION
PdhiEnumMachinesFromTextLog (
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    BOOL        bUnicodeDest
);

PDH_FUNCTION
PdhiEnumObjectsFromTextLog (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szMachineName,
    IN  LPVOID      mszObjectList,
    IN  LPDWORD     pcchBufferSize,
    IN  DWORD       dwDetailLevel,
    IN  BOOL        bUnicode
);

PDH_FUNCTION
PdhiEnumObjectItemsFromTextLog (
    IN  PPDHI_LOG          hDataSource,
    IN  LPCWSTR            szMachineName,
    IN  LPCWSTR            szObjectName,
    IN  PDHI_COUNTER_TABLE CounterTable,
    IN  DWORD              dwDetailLevel,
    IN  DWORD              dwFlags
);

PDH_FUNCTION
PdhiGetMatchingTextLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  LONGLONG    *pStartTime,
    IN  LPDWORD     pdwIndex
);

PDH_FUNCTION
PdhiGetCounterValueFromTextLog (
    IN  PPDHI_LOG   hLog,
    IN  DWORD       dwIndex,
    IN  PERFLIB_COUNTER     *pPath,
    IN  PPDH_RAW_COUNTER    pValue
);

PDH_FUNCTION
PdhiGetTimeRangeFromTextLog (
    IN  PPDHI_LOG       hLog,
    IN  LPDWORD         pdwNumEntries,
    IN  PPDH_TIME_INFO  pInfo,
    IN  LPDWORD         dwBufferSize
);

PDH_FUNCTION
PdhiReadRawTextLogRecord (
    IN  PPDHI_LOG    pLog,
    IN  FILETIME     *ftRecord,
    IN  PPDH_RAW_LOG_RECORD     pBuffer,
    IN  LPDWORD                 pdwBufferLength
);

PDH_FUNCTION
PdhiListHeaderFromTextLog (
    IN  PPDHI_LOG   pLogFile,
    IN  LPVOID      pBufferArg,
    IN  LPDWORD     pcchBufferSize,
    IN  BOOL        bUnicode
);

#endif   // _LOG_TEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log_wmi.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    log_wmi.h

Abstract:

    <abstract>

--*/

#ifndef _LOG_WMI_H_
#define _LOG_WMI_H_

#define WMILOG_VERSION ((DWORD) (0x000006FF))

PDH_FUNCTION
PdhiOpenInputWmiLog (
    IN  PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiOpenOutputWmiLog (
    IN  PPDHI_LOG   pLog
);

//PDH_FUNCTION
//PdhiOpenUpdateBinaryLog (
//    IN  PPDHI_LOG   pLog
//);

//PDH_FUNCTION
//PdhiUpdateBinaryLogFileCatalog (
//    IN  PPDHI_LOG   pLog
//);

PDH_FUNCTION
PdhiCloseWmiLog (
    IN  PPDHI_LOG   pLog,
    IN  DWORD       dwFlags
);

PDH_FUNCTION
PdhiGetWmiLogFileSize(
    IN PPDHI_LOG  pLog,
    IN LONGLONG * llSize
);

PDH_FUNCTION
PdhiWriteWmiLogHeader (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szUserCaption
);

PDH_FUNCTION
PdhiWriteWmiLogRecord (
    IN  PPDHI_LOG     pLog,
    IN  SYSTEMTIME  * stTimeStamp,
    IN  LPCWSTR       szUserString
);

PDH_FUNCTION
PdhiRewindWmiLog(
    IN PPDHI_LOG pLog
);

PDH_FUNCTION
PdhiReadWmiHeaderRecord(
    IN PPDHI_LOG pLog,
    IN LPVOID    pRecord,
    IN DWORD     dwMaxSize
);

PDH_FUNCTION
PdhiReadNextWmiRecord(
    IN PPDHI_LOG pLog,
    IN LPVOID    pRecord,
    IN DWORD     dwMaxSize,
    IN BOOLEAN   bAllCounter
);

PDH_FUNCTION
PdhiReadTimeWmiRecord(
    IN PPDHI_LOG pLog,
    IN ULONGLONG TimeStamp,
    IN LPVOID    pRecord,
    IN DWORD     dwMaxSize
);

PDH_FUNCTION
PdhiGetTimeRangeFromWmiLog (
    IN  PPDHI_LOG       hLog,
    IN  LPDWORD         pdwNumEntries,
    IN  PPDH_TIME_INFO  pInfo,
    IN  LPDWORD         pdwBufferSize
);

PDH_FUNCTION
PdhiEnumObjectItemsFromWmiLog (
    IN PPDHI_LOG          pLog,
    IN LPCWSTR            szMachineName,
    IN LPCWSTR            szObjectName,
    IN PDHI_COUNTER_TABLE CounterTable,
    IN DWORD              dwDetailLevel,
    IN DWORD              dwFlags
);

PDH_FUNCTION
PdhiGetWmiLogCounterInfo (
    IN  PPDHI_LOG       pLog,
    IN  PPDHI_COUNTER   pCounter
);

#endif   // _LOG_WMI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log_sql.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    log_SQL.h

Abstract:

    <abstract>

--*/

#ifndef _LOG_SQL_H_
#define _LOG_SQL_H_

PDH_FUNCTION
PdhiOpenInputSQLLog (
    IN  PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiOpenOutputSQLLog (
    IN  PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiCloseSQLLog (
    IN  PPDHI_LOG   pLog,
    IN  DWORD       dwFlags
);

PDH_FUNCTION
ReportSQLError (
	IN  PPDHI_LOG	pLog,
	signed short	rc,
	void *			hstmt,
	DWORD			dwEventNumber
);

PDH_FUNCTION
PdhiGetSQLLogCounterInfo (
    IN  PPDHI_LOG       pLog,
    IN  PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiWriteSQLLogHeader (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szUserCaption
);

PDH_FUNCTION
PdhiWriteSQLLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  SYSTEMTIME  *pTimeStamp,
    IN  LPCWSTR     szUserString
);


PDH_FUNCTION
PdhiEnumMachinesFromSQLLog (
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    BOOL        bUnicodeDest
);


PDH_FUNCTION
PdhiEnumObjectsFromSQLLog (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR     szMachineName,
    IN  LPVOID      mszObjectList,
    IN  LPDWORD     pcchBufferSize,
    IN  DWORD       dwDetailLevel,
    IN  BOOL        bUnicode
);


PDH_FUNCTION
PdhiEnumObjectItemsFromSQLLog (
    IN  PPDHI_LOG          hDataSource,
    IN  LPCWSTR            szMachineName,
    IN  LPCWSTR            szObjectName,
    IN  PDHI_COUNTER_TABLE CounterTable,
    IN  DWORD              dwDetailLevel,
    IN  DWORD              dwFlags
);

PDH_FUNCTION
PdhiGetMatchingSQLLogRecord (
    IN  PPDHI_LOG   pLog,
    IN  LONGLONG    *pStartTime,
    IN  LPDWORD     pdwIndex
);

PDH_FUNCTION
PdhiGetCounterValueFromSQLLog (
    IN  PPDHI_LOG   hLog,
    IN  DWORD       dwIndex,
    IN  PPDHI_COUNTER      pPath,
    IN  PPDH_RAW_COUNTER    pValue
);

PDH_FUNCTION
PdhiGetTimeRangeFromSQLLog (
    IN  PPDHI_LOG       hLog,
    IN  LPDWORD         pdwNumEntries,
    IN  PPDH_TIME_INFO  pInfo,
    IN  LPDWORD         dwBufferSize
);

PDH_FUNCTION
PdhiReadRawSQLLogRecord (
    IN  PPDHI_LOG    pLog,
    IN  FILETIME     *ftRecord,
    IN  PPDH_RAW_LOG_RECORD     pBuffer,
    IN  LPDWORD                 pdwBufferLength
);

PDH_FUNCTION
PdhiListHeaderFromSQLLog (
    IN  PPDHI_LOG    pLog,
    IN  LPVOID		 mszHeaderList,
    IN  LPDWORD      pcchHeaderListSize,
    IN  BOOL		 bUnicode
);

#endif   // _LOG_SQL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\relog.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <pdh.h>
#include <pdhp.h>

#include "pdhidef.h"
#include "log_bin.h"
#include "log_wmi.h"
#include "log_text.h"
#include "log_sql.h"
#include "strings.h"
#include "pdhmsg.h"

BOOL __stdcall
IsValidLogHandle (
    IN  HLOG    hLog    
);

PDH_FUNCTION
PdhiWriteRelogRecord(
    IN  PPDHI_LOG   pLog,
    IN  SYSTEMTIME  *st
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    LPWSTR szUserString = NULL;

    pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);

    if (pdhStatus == ERROR_SUCCESS) {

        switch (LOWORD(pLog->dwLogFormat)) {
            case PDH_LOG_TYPE_CSV:
            case PDH_LOG_TYPE_TSV:
                pdhStatus =PdhiWriteTextLogRecord (
                                  pLog,
                                  st,
                                  (LPCWSTR)szUserString);
                break;

            case PDH_LOG_TYPE_RETIRED_BIN:
                pdhStatus =PdhiWriteBinaryLogRecord (
                                  pLog, 
                                  st,
                                  (LPCWSTR)szUserString);
                break;

            case PDH_LOG_TYPE_BINARY:
                pdhStatus = PdhiWriteWmiLogRecord(
                                  pLog,
                                  st,
                                  (LPCWSTR) szUserString);
                break;
            case PDH_LOG_TYPE_SQL:
                pdhStatus =PdhiWriteSQLLogRecord (
                                  pLog,
                                  st,
                                  (LPCWSTR)szUserString);
                break;

            case PDH_LOG_TYPE_PERFMON:
            default:
                pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                break;
        }

        RELEASE_MUTEX (pLog->hLogMutex);
    } 
 
    return pdhStatus;
}

PDH_FUNCTION
PdhRelogA(
        HLOG    hLogIn,
        PPDH_RELOG_INFO_A pRelogInfo
    )
{
    HRESULT hr;

    PDH_RELOG_INFO_W RelogInfo;
    
    memcpy( &RelogInfo, pRelogInfo, sizeof(PDH_RELOG_INFO_A) );
    RelogInfo.strLog = NULL;

    if( NULL != pRelogInfo->strLog ){
        
        RelogInfo.strLog = (LPWSTR)G_ALLOC( 
            (strlen(pRelogInfo->strLog)+1) * sizeof(WCHAR) );
        
        if( RelogInfo.strLog ){
        
            mbstowcs( 
                    RelogInfo.strLog, 
                    pRelogInfo->strLog, 
                    (strlen(pRelogInfo->strLog)+1) 
                );
        }
    }

    hr = PdhRelogW( hLogIn, &RelogInfo );

    G_FREE( RelogInfo.strLog );

    return hr;
}

PDH_FUNCTION
PdhRelogW( 
        HLOG    hLogIn,
        PPDH_RELOG_INFO_W pRelogInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HLOG      hLogOut;
    PPDHI_LOG pLogIn;
    PPDHI_LOG pLogOut;

    SYSTEMTIME      ut;
    FILETIME        lt;
    ULONG           nSampleCount = 0;
    ULONG           nSamplesWritten = 0;

    if( IsValidLogHandle(hLogIn) ){

        HCOUNTER hCounter;
        HQUERY hQuery;
        ULONG nRecordSkip;

        pLogIn = (PPDHI_LOG)hLogIn;

        pdhStatus = PdhOpenLogW(
                pRelogInfo->strLog, 
                pRelogInfo->dwFlags,
                &pRelogInfo->dwFileFormat, 
                (HQUERY)pLogIn->pQuery,
                0,
                NULL,
                &hLogOut
            );

        if( pdhStatus == ERROR_SUCCESS ){
            
            DWORD dwNumEntries = 1;
            DWORD dwBufferSize = sizeof(PDH_TIME_INFO);
            PDH_TIME_INFO TimeInfo;

            ZeroMemory( &TimeInfo, sizeof( PDH_TIME_INFO ) );

            pLogOut= (PPDHI_LOG)hLogOut;
            hQuery = (HQUERY)(pLogIn->pQuery);
            
            pdhStatus = PdhGetDataSourceTimeRangeH (
                                hLogIn,
                                &dwNumEntries,
                                &TimeInfo,
                                &dwBufferSize
                            );

            if( pRelogInfo->TimeInfo.StartTime == 0 || 
                pRelogInfo->TimeInfo.StartTime < TimeInfo.StartTime ){

                pLogIn->pQuery->TimeRange.StartTime = TimeInfo.StartTime;
                pRelogInfo->TimeInfo.StartTime = TimeInfo.StartTime;
            }else{
                pLogIn->pQuery->TimeRange.StartTime = pRelogInfo->TimeInfo.StartTime;
            }

            if( pRelogInfo->TimeInfo.EndTime == 0 || 
                pRelogInfo->TimeInfo.EndTime > TimeInfo.EndTime ){

                pLogIn->pQuery->TimeRange.EndTime = TimeInfo.EndTime;
                pRelogInfo->TimeInfo.EndTime = TimeInfo.EndTime;
            }else{
                pLogIn->pQuery->TimeRange.EndTime = pRelogInfo->TimeInfo.EndTime;
            }

            nRecordSkip = pRelogInfo->TimeInfo.SampleCount >= 1 ? pRelogInfo->TimeInfo.SampleCount : 1;
        
            while( ERROR_SUCCESS == pdhStatus ){
    
                pdhStatus = PdhiCollectQueryData( (PPDHI_QUERY)hQuery, (LONGLONG *)&lt);
                FileTimeToSystemTime (&lt, &ut);

                if( nSampleCount++ % nRecordSkip ){
                    continue;
                }

                if( ERROR_SUCCESS == pdhStatus ){
                    pdhStatus = PdhiWriteRelogRecord( pLogOut, &ut );
                    nSamplesWritten++;
                }
                else if (PDH_NO_DATA == pdhStatus) {
                    // Reset pdhStatus. PDH_NO_DATA means that there are no new counter data
                    // for collected counters. Skip current record and continue.
                    //

                    pdhStatus = ERROR_SUCCESS;
                }
            }

            //
            // Check for valid exit status codes
            //
            if( PDH_NO_MORE_DATA == pdhStatus ){
                pdhStatus = ERROR_SUCCESS;
            }
            
            if( ERROR_SUCCESS == pdhStatus ){
                pdhStatus = PdhCloseLog( hLogOut, 0 );
            }else{
                PdhCloseLog( hLogOut, 0 );
            }
            ((PPDHI_QUERY)hQuery)->hOutLog = NULL;
        }
    
    }else{
        pdhStatus = PDH_INVALID_HANDLE;
    }
    
    pRelogInfo->TimeInfo.SampleCount = nSamplesWritten;

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhpla\plogman.cpp ===
/*****************************************************************************\

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winbase.h>
#include <userenv.h>

#include <wmistr.h>
#include <evntrace.h>

#include <pdh.h>
#include <pdhp.h>
#include <pdhmsg.h>

#include <wincrypt.h>

#include <shlwapi.h>

#include "plogman.h"
#include "pdhdlgs.h"

HANDLE hPdhPlaMutex = NULL;

/*****************************************************************************\
    Strings            
\*****************************************************************************/

// Common
LPCWSTR szCollection =          L"Collection Name";
LPCWSTR szKey =                 L"Key";
LPCWSTR szRunAs =               L"Run As";
LPCWSTR szSysmonLog =           L"SysmonLog";
LPCWSTR szCurrentState =        L"Current State";
LPCWSTR szLogType =             L"Log Type";
LPCWSTR szLogBaseName =         L"Log File Base Name";
LPCWSTR szStart =               L"Start";
LPCWSTR szStop =                L"Stop";
LPCWSTR szRestart =             L"Restart";
LPCWSTR szLogMaxSize =          L"Log File Max Size";
LPCWSTR szCurrentLogFile =      L"Current Log File Name";
LPCWSTR szLogSerialNumber =     L"Log File Serial Number";
LPCWSTR szLogAutoFormat =       L"Log File Auto Format";
LPCWSTR szComment =             L"Comment";
LPCWSTR szEOFCmd =              L"EOF Command File";
LPCWSTR szLogFolder =           L"Log File Folder";
LPCWSTR szLogFileType =         L"Log File Type";
LPCWSTR szRepeatSchedule =      L"Repeat Schedule";
LPCWSTR szRepeatScheduleBegin = L"Repeat Schedule Start";
LPCWSTR szRepeatScheduleEnd =   L"Repeat Schedule Stop";
LPCWSTR szCreateNewFile =       L"Create New File";
LPCWSTR szDatastoreAttributes = L"Data Store Attributes";

// Trace
LPCWSTR szTraceProviderCount =  L"Trace Provider Count";
LPCWSTR szTraceBufferSize =     L"Trace Buffer Size";
LPCWSTR szTraceBufferMin =      L"Trace Buffer Min Count";
LPCWSTR szTraceBufferMax =      L"Trace Buffer Max Count";
LPCWSTR szTraceFlushInterval =  L"Trace Buffer Flush Interval";
LPCWSTR szTraceFlags =          L"Trace Flags";
LPCWSTR szTraceProviderList =   L"Trace Provider List";
LPCWSTR szTraceProviderFlags =  L"Trace Provider Flags";
LPCWSTR szTraceProviderLevels = L"Trace Provider Levels";
LPCWSTR szTraceMode =           L"Trace Mode";
LPCWSTR szTraceLoggerName =     L"Trace Logger Name";

// Performance
LPCWSTR szPerfCounterList =     L"Counter List";
LPCWSTR szSqlBaseName =         L"Sql Log Base Name";
LPCWSTR szSampleInterval =      L"Sample Interval";

/*****************************************************************************/

PDH_FUNCTION
PlaiErrorToPdhStatus( DWORD dwStatus )
{
    switch( dwStatus ){
    case ERROR_SUCCESS:                 return ERROR_SUCCESS;
    case ERROR_FILE_NOT_FOUND:          return PDH_PLA_COLLECTION_NOT_FOUND;
    case ERROR_SERVICE_ALREADY_RUNNING: return PDH_PLA_COLLECTION_ALREADY_RUNNING;
    case ERROR_DIRECTORY:               return PDH_PLA_ERROR_FILEPATH;
    case ERROR_OUTOFMEMORY:             return PDH_MEMORY_ALLOCATION_FAILURE;
    case ERROR_NOT_ENOUGH_MEMORY:       return PDH_MEMORY_ALLOCATION_FAILURE;
    case ERROR_NO_DATA:                 return PDH_NO_DATA;
    case ERROR_ACCESS_DENIED:           return PDH_ACCESS_DENIED;
    case E_FAIL:                        return PDH_WBEM_ERROR;
    case WBEM_E_ACCESS_DENIED:          return PDH_ACCESS_DENIED;
    default:                            return PDH_INVALID_DATA;
    }
}

ULONG 
PlaMszStrLenA( LPSTR mszString )
{
    ULONG nLength = 0;
    ULONG nTotalLength = 0;
    LPSTR strScan = mszString;
    
    if( mszString == NULL ){
        return 0;
    }
    while( *strScan != '\0' ){
        nLength = (strlen( strScan )+1);
        strScan += nLength;
        nTotalLength += nLength;
    }
    
    return (nTotalLength*sizeof(char) + (sizeof(char) * 2));
}

ULONG 
PlaMszStrLenW( LPWSTR mszString )
{
    ULONG nLength = 0;
    ULONG nTotalLength = 0;
    LPTSTR strScan = mszString;
    
    if( mszString == NULL ){
        return 0;
    }
    while( *strScan != L'\0' ){
        nLength = (wcslen( strScan )+1);
        strScan += nLength;
        nTotalLength += nLength;
    }
    
    return (nTotalLength*sizeof(WCHAR) + (sizeof(WCHAR)));
}

_inline BOOL 
PlaiIsStringEmpty( LPWSTR str )
{
    if( NULL == str ){
        return TRUE;
    }
    if( L'\0' == *str ){
        return TRUE;
    }

    return FALSE;
}

_inline BOOL 
PlaiIsCharWhitespace( WCHAR ch )
{
    switch( ch ){
    case L' ':
    case L'\r':
    case L'\n':
    case L'\t':
        return TRUE;
    default:
        return FALSE;
    }
}

PDH_FUNCTION 
Plaiatow( LPSTR strA, LPWSTR &strW )
{
    if( NULL == strA ){
        strW = NULL;
        return ERROR_SUCCESS;
    }

    strW = (LPWSTR)G_ALLOC( (strlen(strA)+1) * sizeof(WCHAR) );
    if( strW ){
        mbstowcs( strW, strA, (strlen(strA)+1) );
        return ERROR_SUCCESS;
    }

    strW = NULL;
    return PDH_MEMORY_ALLOCATION_FAILURE;
}

ULONG 
Plaihextoi( LPWSTR s )
{
    long len;
    ULONG num, base, hex;

    if ( PlaiIsStringEmpty( s ) ) {
        return 0;
    }
    
    len = (long) wcslen(s);
    
    if (len == 0) {
        return 0;
    }

    hex  = 0;
    base = 1;
    num  = 0;

    while (-- len >= 0) {
        if (s[len] >= L'0' && s[len] <= L'9'){
            num = s[len] - L'0';
        }else if (s[len] >= L'a' && s[len] <= L'f'){
            num = (s[len] - L'a') + 10;
        }else if (s[len] >= L'A' && s[len] <= L'F'){
            num = (s[len] - L'A') + 10;
        }else if( s[len] == L'x' || s[len] == L'X'){
            break;
        }else{
            continue;
        }

        hex += num * base;
        base = base * 16;
    }

    return hex;
}

PDH_FUNCTION
PlaiTranslateKernelFlags( LPDWORD pdwInternal, LPDWORD pdwReal )
{
    if( *pdwReal & EVENT_TRACE_FLAG_PROCESS ){
        *pdwInternal |= PLA_TLI_ENABLE_PROCESS_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_THREAD ){
        *pdwInternal |= PLA_TLI_ENABLE_THREAD_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS ){
        *pdwInternal |= PLA_TLI_ENABLE_MEMMAN_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS ){
        *pdwInternal |= PLA_TLI_ENABLE_MEMMAN_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_DISK_IO ){
        *pdwInternal |= PLA_TLI_ENABLE_DISKIO_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_NETWORK_TCPIP ){
        *pdwInternal |= PLA_TLI_ENABLE_NETWORK_TCPIP_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_DISK_FILE_IO ){
        *pdwInternal |= PLA_TLI_ENABLE_FILEIO_TRACE;
    }

    return ERROR_SUCCESS;
}

BOOL
PlaiIsLocalComputer( LPWSTR strComputer )
{    
    if( NULL == strComputer ){
        return TRUE;
    }else{
        LPWSTR str = strComputer;

        WCHAR buffer[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1; 
        BOOL bResult;
        
        bResult = GetComputerName( buffer, &dwSize );
        
        if( bResult ){
        
            while( *str == L'\\' ){
                str++;
            }

            return (_wcsicmp( buffer, str ) == 0);

        }else{
            return TRUE;
        }
    }

    return FALSE;
}

/*****************************************************************************/

DWORD
PlaiUpdateServiceMode( LPTSTR strComputer )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    BOOL            bStatus;
    PDH_STATUS      pdhStatus;
    SC_HANDLE       hSC = NULL;
    SC_HANDLE       hService = NULL;
    QUERY_SERVICE_CONFIG*    pServiceConfig = NULL;
    DWORD dwSize = 0;
    BOOL bAutoStart = FALSE;
    PDH_PLA_INFO_W  info;

    LPWSTR mszCollections = NULL;

    pdhStatus = PdhPlaEnumCollections( strComputer, &dwSize, mszCollections );

    if( ERROR_SUCCESS == pdhStatus || PDH_INSUFFICIENT_BUFFER == pdhStatus ){
        
        mszCollections = (LPWSTR)G_ALLOC( dwSize * sizeof(TCHAR) );
        
        if( mszCollections ){
            
            LPTSTR strCollection;
        
            pdhStatus = PdhPlaEnumCollections( strComputer, &dwSize, mszCollections );
            if( ERROR_SUCCESS == pdhStatus && NULL != mszCollections ){
            
                dwSize = sizeof( PDH_PLA_INFO_W );
                strCollection = mszCollections;
                
                while( *strCollection != L'\0' ){
                    
                    info.dwMask = PLA_INFO_FLAG_BEGIN;
                    strCollection += ( wcslen( strCollection ) + 1 );
                    pdhStatus = PdhPlaGetInfoW( strCollection, strComputer, &dwSize, &info );
                
                    if( ERROR_SUCCESS == pdhStatus ){

                        if( (info.dwMask & PLA_INFO_FLAG_BEGIN) && 
                            info.ptLogBeginTime.dwAutoMode != PLA_AUTO_MODE_NONE ){

                            bAutoStart = TRUE;
                            break;
                        }
                    }
                }
            }
        }else{ 
            dwStatus = ERROR_OUTOFMEMORY;
        }
    }else{
        dwStatus = ERROR_FILE_NOT_FOUND;
    }

    if( ERROR_SUCCESS != dwStatus ){
        goto cleanup;
    }


    hSC = OpenSCManager ( strComputer, NULL, GENERIC_READ );

    if (hSC == NULL) {
        dwStatus = GetLastError();
        goto cleanup;
    }
    
    BOOL bUpdate = FALSE;

    dwSize = 4096;
    pServiceConfig = (QUERY_SERVICE_CONFIG*)G_ALLOC( dwSize );
    if( NULL == pServiceConfig ){
        dwStatus = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    ZeroMemory( pServiceConfig, dwSize );

    hService = OpenService (
                        hSC, 
                        szSysmonLog,
                        SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG | SERVICE_START 
                    );

    if( NULL == hService ){
        dwStatus = GetLastError();
        goto cleanup;
    }

    bStatus = QueryServiceConfig (
                        hService, 
                        pServiceConfig,
                        dwSize, 
                        &dwSize
                    );
    if( !bStatus ){
        dwStatus = GetLastError();
        goto cleanup;
    }

    if ( bAutoStart ) {
        if ( SERVICE_DEMAND_START == pServiceConfig->dwStartType ) {
            bUpdate = TRUE;
        }
    } else {
        if ( SERVICE_AUTO_START == pServiceConfig->dwStartType ) {
            bUpdate = TRUE;
        }
    }

    if( bUpdate ){

        SC_ACTION  ServiceControlAction[3];
        SERVICE_FAILURE_ACTIONS  FailActions;

        bStatus = ChangeServiceConfig (
                        hService,
                        SERVICE_NO_CHANGE,
                        (bAutoStart ? SERVICE_AUTO_START : SERVICE_DEMAND_START),
                        SERVICE_NO_CHANGE,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL 
                    );

        if( !bStatus ){
            dwStatus = GetLastError();
            goto cleanup;
        }

        ZeroMemory( ServiceControlAction, sizeof(SC_ACTION) * 3 );
        ZeroMemory( &FailActions, sizeof(SERVICE_FAILURE_ACTIONS) );

        if ( bAutoStart ) {
            ServiceControlAction[0].Type = SC_ACTION_RESTART;
            ServiceControlAction[1].Type = SC_ACTION_RESTART;
            ServiceControlAction[2].Type = SC_ACTION_RESTART;
        } else {
            ServiceControlAction[0].Type = SC_ACTION_NONE;
            ServiceControlAction[1].Type = SC_ACTION_NONE;
            ServiceControlAction[2].Type = SC_ACTION_NONE;
        }

        FailActions.dwResetPeriod = 60;
        FailActions.cActions = 3;
        FailActions.lpsaActions = ServiceControlAction;

        bStatus = ChangeServiceConfig2(
                            hService,
                            SERVICE_CONFIG_FAILURE_ACTIONS,
                            &FailActions 
                        );

        if ( ! bStatus ) {
            dwStatus = GetLastError();
        }
    }

cleanup:
    G_FREE( mszCollections );
    G_FREE( pServiceConfig );
    if( NULL != hService ){
        CloseServiceHandle (hService);
    }
    if( NULL != hSC ){
        CloseServiceHandle (hSC);
    }

    return dwStatus;
}

DWORD 
PlaiGetServiceState ( 
    LPCWSTR szComputerName,
    DWORD&  rdwState 
    )
{
    DWORD dwStatus = ERROR_SUCCESS;

    SERVICE_STATUS  ssData;
    SC_HANDLE       hSC;
    SC_HANDLE       hLogService;
    
    rdwState = 0;       // Error by default.

    // open SC database
    hSC = OpenSCManagerW ( szComputerName, NULL, SC_MANAGER_CONNECT);

    if (hSC != NULL) {
     
        // open service
        hLogService = OpenServiceW (
                        hSC, 
                        szSysmonLog,
                        SERVICE_INTERROGATE );
    
        if (hLogService != NULL) {
            if ( ControlService (
                    hLogService, 
                    SERVICE_CONTROL_INTERROGATE,
                    &ssData)) {

                rdwState = ssData.dwCurrentState;
            } else {
                dwStatus = GetLastError();
                rdwState = SERVICE_STOPPED;
            }

            CloseServiceHandle (hLogService);
        
        } else {
            dwStatus = GetLastError();
        }

        CloseServiceHandle (hSC);
    } else {
        dwStatus = GetLastError();
    }

    if ( ERROR_SERVICE_NOT_ACTIVE == dwStatus || ERROR_SERVICE_REQUEST_TIMEOUT == dwStatus ) {
        rdwState = SERVICE_STOPPED;
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;
}

PDH_FUNCTION
PlaiSynchronize( LPCWSTR szComputerName )
{
    // If the service is running, tell it to synchronize itself,
    // Check the state afterwards to see if it got the message.
    // If stop pending or stopped, wait until the service is
    // stopped and then attempt to start it.  The service 
    // synchronizes itself from the registry when it is started.

    // Return ERROR_SUCCESS for success, other for failure.

    SC_HANDLE   hSC = NULL;
    SC_HANDLE   hLogService = NULL;
    SERVICE_STATUS  ssData;
    DWORD       dwCurrentState;
    DWORD       dwTimeout = 25;
    DWORD       dwStatus = ERROR_SUCCESS;

    dwStatus = PlaiGetServiceState ( szComputerName, dwCurrentState );

    if ( ERROR_SUCCESS == dwStatus && 0 != dwCurrentState ) {
        // open SC database
        hSC = OpenSCManagerW ( szComputerName, NULL, SC_MANAGER_CONNECT);

        if ( NULL != hSC ) {
            // open service
            hLogService = OpenServiceW (
                            hSC, 
                            szSysmonLog,
                            SERVICE_USER_DEFINED_CONTROL 
                            | SERVICE_START );
    
            if ( NULL != hLogService ) {

                if ( ( SERVICE_STOPPED != dwCurrentState ) 
                        && ( SERVICE_STOP_PENDING != dwCurrentState ) ) {

                    // Wait 100 milliseconds before synchronizing service,
                    // to ensure that registry values are written.
                    _sleep ( 100 );

                    ControlService ( 
                        hLogService, 
                        PLA_SERVICE_CONTROL_SYNCHRONIZE, 
                        &ssData);
                
                    dwCurrentState = ssData.dwCurrentState;
                }

                // Make sure that the ControlService call reached the service
                // while it was in run state.
                if ( ( SERVICE_STOPPED == dwCurrentState ) 
                    || ( SERVICE_STOP_PENDING == dwCurrentState ) ) {

                    if ( SERVICE_STOP_PENDING == dwCurrentState ) {
                        // wait for the service to stop before starting it.
                        while ( --dwTimeout && ERROR_SUCCESS == dwStatus ) {
                            dwStatus = PlaiGetServiceState ( szComputerName, dwCurrentState );
                            if ( SERVICE_STOP_PENDING == dwCurrentState ) {
                                _sleep(200);
                            } else {
                                break;
                            }
                        }
                    }
                    dwTimeout = 25;
                    if ( SERVICE_STOPPED == dwCurrentState ) {
                        if ( StartService (hLogService, 0, NULL) ) {
                            // wait for the service to start or stop 
                            // before returning
                            while ( --dwTimeout && ERROR_SUCCESS == dwStatus ) {
                                dwStatus = PlaiGetServiceState ( szComputerName, dwCurrentState );
                                if ( SERVICE_START_PENDING == dwCurrentState ) {
                                    _sleep(200);
                                } else {
                                    break;
                                }
                            }
                        } else {
                            dwStatus = GetLastError();
                        }
                    }
                }
            }
            CloseServiceHandle ( hLogService );

        } else {
            dwStatus = GetLastError();
        }

        CloseServiceHandle (hSC);

    } else {
        dwStatus = GetLastError();
    }

    if( 0 == dwCurrentState || ERROR_SUCCESS != dwStatus ){
        return PDH_PLA_SERVICE_ERROR;
    }

    return ERROR_SUCCESS;
}

/*****************************************************************************\

    PdhPlaSchedule
    
    Sets the start/stop attributes of a log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
        
        DWORD fType
                PLA_AUTO_MODE_NONE      Sets schedule to manual start if pInfo->StartTime is non-zero
                                        Sets schedule to manula stop if pInfo->EndTime is non-zero and
                                        
                                        Stops logger if it is running


                PLA_AUTO_MODE_AT        Uses pInfo for start and end times

                PLA_AUTO_MODE_AFTER     Sets the logger to run for a specified
                                        period.  Does not start the logger.
                                        Uses pInfo->SampleCount for interval type
                                            PLA_TT_UTYPE_SECONDS
                                            PLA_TT_UTYPE_MINUTES
                                            PLA_TT_UTYPE_HOURS
                                            PLA_TT_UTYPE_DAYS

         PPDH_TIME_INFO pInfo
                Start and Stop times

    Return:
        PDH_INVALID_ARGUMENT
                A required argument is missing or incorrect.
        PDH_PLA_COLLECTION_ALREADY_RUNNING
                The Query is currently running, no action taken
        PDH_PLA_ERROR_SCHEDULE_OVERLAP
                The start and stop times overlap.
        PDH_PLA_COLLECTION_NOT_FOUND
                Query does not exist
        PDH_PLA_ERROR_SCHEDULE_ELAPSED
                The end time has elapsed
        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION 
PlaiSchedule( 
        LPWSTR strComputer,
        HKEY   hkeyQuery,
        DWORD  fType,
        PPDH_TIME_INFO pInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    PLA_TIME_INFO   stiData;
    DWORD           dwRegValue;

    RegFlushKey( hkeyQuery );

    // Make sure its not already running
    pdhStatus = PlaiReadRegistryDwordValue(
                    hkeyQuery, 
                    szCurrentState, 
                    &dwRegValue );
    
    if( ERROR_SUCCESS == pdhStatus  ){
        if( PLA_QUERY_RUNNING == dwRegValue ){
            DWORD dwState;
            PlaiGetServiceState( strComputer, dwState );
            if( dwState != SERVICE_STOPPED ){
                RegCloseKey( hkeyQuery );
                return PDH_PLA_COLLECTION_ALREADY_RUNNING;
            }
        }
    }

    memset (&stiData, 0, sizeof(stiData));

    switch( fType ){
    case PLA_AUTO_MODE_NONE:
        stiData.wDataType = PLA_TT_DTYPE_DATETIME;
        stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
        
        PlaiRemoveRepeat( hkeyQuery );

        stiData.llDateTime = MIN_TIME_VALUE;
        if( pInfo->StartTime ){
            stiData.wTimeType = PLA_TT_TTYPE_START;
            pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStart, &stiData );    
        }

        if( pInfo->EndTime ){
            stiData.wTimeType = PLA_TT_TTYPE_STOP;
            pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
        }

        break;
    case PLA_AUTO_MODE_AT:
        {
            SYSTEMTIME      stLocalTime;
            FILETIME        ftLocalTime;
            LONGLONG        llLocalTime;

            // get local time
            GetLocalTime (&stLocalTime);
            SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
                            
            llLocalTime = 
                (((ULONGLONG) ftLocalTime.dwHighDateTime) << 32) + 
                ftLocalTime.dwLowDateTime;

            if( pInfo->StartTime && pInfo->EndTime ){
                if( pInfo->StartTime > pInfo->EndTime ){
                    return PDH_PLA_ERROR_SCHEDULE_OVERLAP;
                }
            }

            stiData.wDataType = PLA_TT_DTYPE_DATETIME;
            stiData.dwAutoMode = PLA_AUTO_MODE_AT;

            if( pInfo->StartTime ){

                stiData.wTimeType = PLA_TT_TTYPE_START;
                stiData.llDateTime = pInfo->StartTime;
                pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStart, &stiData );
                if( ! pInfo->EndTime && pInfo->StartTime < llLocalTime ){
                    PLA_TIME_INFO   stiStopData;
                    pdhStatus = PlaiReadRegistryPlaTime( hkeyQuery, szStop, &stiStopData );
                    if( ERROR_SUCCESS == pdhStatus && stiStopData.dwAutoMode == PLA_AUTO_MODE_NONE ){
                        stiStopData.llDateTime = MAX_TIME_VALUE;
                        PlaiWriteRegistryPlaTime( hkeyQuery, szStop, &stiStopData );
                    }
                }else if( ! pInfo->EndTime ){
                    PLA_TIME_INFO   stiStopData;
                    pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStop, &stiStopData );
                    if( ERROR_SUCCESS == pdhStatus ){
                        if( PLA_AUTO_MODE_NONE == stiStopData.dwAutoMode ){
                            stiData.wTimeType = PLA_TT_TTYPE_STOP;
                            stiData.llDateTime = MAX_TIME_VALUE;
                            stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
                            pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
                        }
                    }

                }
            }

            if( pInfo->EndTime ){
                if( pInfo->EndTime < llLocalTime ){
                    return PDH_PLA_ERROR_SCHEDULE_ELAPSED;
                }
                stiData.wTimeType = PLA_TT_TTYPE_STOP;
                stiData.llDateTime = pInfo->EndTime;
                pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
            }                
    
        }
        break;
    case PLA_AUTO_MODE_AFTER:
        stiData.wTimeType = PLA_TT_TTYPE_STOP;
        stiData.wDataType = PLA_TT_DTYPE_UNITS;
        stiData.dwAutoMode = PLA_AUTO_MODE_AFTER;
        stiData.dwValue = (DWORD)pInfo->EndTime;
        stiData.dwUnitType = pInfo->SampleCount;
        pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
        break;
    default:
        return PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PlaiRemoveRepeat( HKEY hkeyQuery )
{
    PLA_TIME_INFO info;
    PDH_STATUS pdhStatus;

    ZeroMemory( &info, sizeof( PLA_TIME_INFO ) );
    pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szRepeatSchedule, &info );    
    
    return pdhStatus;
}

PDH_FUNCTION 
PdhPlaScheduleA(
        LPSTR strName, 
        LPSTR strComputer,
        DWORD fType,
        PPDH_TIME_INFO pInfo
    )
{
    PDH_STATUS pdhStatus;
    LPWSTR wstrName = NULL;
    LPWSTR wstrComputer = NULL;

    VALIDATE_QUERY( strName );

    pdhStatus = Plaiatow( strComputer, wstrComputer );
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = Plaiatow( strName, wstrName );
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PdhPlaScheduleW( wstrName, wstrComputer, fType, pInfo );
        }
    }
   
    G_FREE( wstrComputer );
    G_FREE( wstrName );
    
    return pdhStatus;
}

PDH_FUNCTION 
PdhPlaScheduleW( 
        LPWSTR strName, 
        LPWSTR strComputer,
        DWORD  fType,
        PPDH_TIME_INFO pInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;

    VALIDATE_QUERY( strName );

    pdhStatus = PlaiConnectAndLockQuery ( strComputer, strName, hkeyQuery );

    if( ERROR_SUCCESS == pdhStatus ){
     
        pdhStatus = PlaiSchedule( strComputer, hkeyQuery, fType, pInfo );                
        RELEASE_MUTEX(hPdhPlaMutex);
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PlaiSynchronize( strComputer );
        PlaiUpdateServiceMode( strComputer );
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaGetSchedule


    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
        
    Return:

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhPlaGetScheduleA(
        LPSTR strName, 
        LPSTR strComputer,
        LPDWORD pdwTypeStart,
        LPDWORD pdwTypeStop,
        PPDH_TIME_INFO pInfo
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaGetScheduleW(
        LPWSTR strName, 
        LPWSTR strComputer,
        LPDWORD pdwTypeStart,
        LPDWORD pdwTypeStop,
        PPDH_TIME_INFO pInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;
    BOOL bMutex = FALSE;

    VALIDATE_QUERY( strName );

    pdhStatus = PlaiConnectAndLockQuery ( strComputer, strName, hkeyQuery, FALSE );

    if ( ERROR_SUCCESS == pdhStatus ) {
        PLA_TIME_INFO   ptiStartInfo;
        PLA_TIME_INFO   ptiStopInfo;
        PLA_TIME_INFO   ptiRepeatInfo;
        
        ZeroMemory( pInfo, sizeof(PDH_TIME_INFO) );

        bMutex = TRUE;
        
        pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szRepeatSchedule, &ptiRepeatInfo );
        if( ERROR_SUCCESS == pdhStatus && PLA_AUTO_MODE_CALENDAR == ptiRepeatInfo.dwAutoMode ){
            *pdwTypeStart = PLA_AUTO_MODE_CALENDAR;
            pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szRepeatScheduleBegin, &ptiStartInfo );
            if( ERROR_SUCCESS != pdhStatus ){
                pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStart, &ptiStartInfo );
            }
            CHECK_STATUS( pdhStatus );

            pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szRepeatScheduleEnd, &ptiStopInfo );
            if( ERROR_SUCCESS != pdhStatus ){
                pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStop, &ptiStopInfo );
            }
            CHECK_STATUS( pdhStatus );
            *pdwTypeStop = ptiStopInfo.dwAutoMode;
        }else{
            pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStart, &ptiStartInfo );
            CHECK_STATUS( pdhStatus );
            *pdwTypeStart = ptiStartInfo.dwAutoMode;

            pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStop, &ptiStopInfo );
            CHECK_STATUS( pdhStatus );
            *pdwTypeStop = ptiStopInfo.dwAutoMode;
        }

        pInfo->StartTime = ptiStartInfo.llDateTime;
        pInfo->EndTime = ptiStopInfo.llDateTime;
        
    }

cleanup:
    if( bMutex ){
        RELEASE_MUTEX(hPdhPlaMutex);
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }
    
    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaStart

    Starts a log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
        
    Return:

        PDH_PLA_COLLECTION_ALREADY_RUNNING
                The Query is currently running, no action taken

        PDH_INVALID_ARGUMENT
                The query does not exist

        PDH_PLA_ERROR_SCHEDULE_ELAPSED
                The query was scheduled to stop in the past, no action taken

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhPlaStartA( LPSTR strName, LPSTR strComputer )
{
    PDH_STATUS pdhStatus;
    LPWSTR wstrName = NULL;
    LPWSTR wstrComputer = NULL;

    VALIDATE_QUERY( strName );

    pdhStatus = Plaiatow( strComputer, wstrComputer );
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = Plaiatow( strName, wstrName );
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PdhPlaStartW( wstrName, wstrComputer );
        }
    }
   
    G_FREE( wstrComputer );
    G_FREE( wstrName );

    return pdhStatus;
}

PDH_FUNCTION
PdhPlaStartW( LPWSTR strName, LPWSTR strComputer )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;

    VALIDATE_QUERY( strName );

    pdhStatus = PlaiConnectAndLockQuery ( strComputer, strName, hkeyQuery );

    if ( ERROR_SUCCESS == pdhStatus ) {
        PLA_TIME_INFO   stiData;
        PLA_TIME_INFO   stiStopData;
        DWORD           dwRegValue;
   
        // Make sure its not already running
        pdhStatus = PlaiReadRegistryDwordValue(
                        hkeyQuery, 
                        szCurrentState, 
                        &dwRegValue );
        
        if( ERROR_SUCCESS == pdhStatus ){
            if( PLA_QUERY_RUNNING == dwRegValue ){
                DWORD dwState;
                PlaiGetServiceState( strComputer, dwState );
                if( dwState != SERVICE_STOPPED ){
                    RegCloseKey( hkeyQuery );
                    RELEASE_MUTEX(hPdhPlaMutex);
                    return PDH_PLA_COLLECTION_ALREADY_RUNNING;
                }
            }
        }

        //Make sure it was not set to stop in the past
        pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStop, &stiStopData );

        if( ERROR_SUCCESS == pdhStatus ) {
            if ( PLA_AUTO_MODE_AT == stiStopData.dwAutoMode ) {
                SYSTEMTIME      stLocalTime;
                FILETIME        ftLocalTime;
                LONGLONG        llLocalTime;

                // get local time
                GetLocalTime (&stLocalTime);
                SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
        
                llLocalTime = 
                    (((ULONGLONG) ftLocalTime.dwHighDateTime) << 32) + 
                    ftLocalTime.dwLowDateTime;

                if ( llLocalTime > stiStopData.llDateTime ) {
                    RELEASE_MUTEX(hPdhPlaMutex);
                    RegCloseKey( hkeyQuery );
                    return PDH_PLA_ERROR_SCHEDULE_ELAPSED;
                }
            }
        }
        
        memset (&stiData, 0, sizeof(stiData));
        stiData.wTimeType = PLA_TT_TTYPE_START;
        stiData.wDataType = PLA_TT_DTYPE_DATETIME;
        stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
        stiData.llDateTime = MIN_TIME_VALUE;
        
        PlaiRemoveRepeat( hkeyQuery );
        
        pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStart, &stiData );
        
        if( PLA_AUTO_MODE_NONE == stiStopData.dwAutoMode ){
            stiData.wTimeType = PLA_TT_TTYPE_STOP;
            stiData.llDateTime = MAX_TIME_VALUE;
            pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
        }

        if ( ERROR_SUCCESS == pdhStatus ) {
            dwRegValue = PLA_QUERY_START_PENDING;
            pdhStatus = PlaiWriteRegistryDwordValue ( 
                        hkeyQuery, 
                        szCurrentState, 
                        &dwRegValue );
        }

        // Set LastModified
        if ( ERROR_SUCCESS == pdhStatus ) { 
            pdhStatus = PlaiWriteRegistryLastModified ( hkeyQuery );
        }

        RELEASE_MUTEX(hPdhPlaMutex);

        // Start the service on the target machine
        if ( ERROR_SUCCESS == pdhStatus ) { 

            pdhStatus = PlaiSynchronize( strComputer );
            
            if( ERROR_SUCCESS == pdhStatus ){
                DWORD dwTimeOut = 25;
                while( --dwTimeOut > 0 ){
                    pdhStatus = PlaiReadRegistryDwordValue(
                                hkeyQuery, 
                                szCurrentState, 
                                &dwRegValue
                            );
                    if( ERROR_SUCCESS == pdhStatus && dwRegValue != PLA_QUERY_RUNNING ){
                        pdhStatus = PDH_PLA_ERROR_NOSTART;
                    }else{
                        pdhStatus = ERROR_SUCCESS;
                        break;
                    }
                    _sleep(200);
                }
            }

        }   

    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaStop

    Stops a log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
        
    Return:

        PDH_INVALID_ARGUMENT
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/


PDH_FUNCTION
PdhPlaStopA( LPSTR strName, LPSTR strComputer )
{
    PDH_STATUS pdhStatus;
    LPWSTR wstrName = NULL;
    LPWSTR wstrComputer = NULL;
    
    VALIDATE_QUERY( strName );


    pdhStatus = Plaiatow( strComputer, wstrComputer );
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = Plaiatow( strName, wstrName );
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PdhPlaStopW( wstrName, wstrComputer );
        }
    }
   
    G_FREE( wstrComputer );
    G_FREE( wstrName );

    return pdhStatus;
}

PDH_FUNCTION
PdhPlaStopW( LPWSTR strName, LPWSTR strComputer )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;

    VALIDATE_QUERY( strName );

    pdhStatus = PlaiConnectAndLockQuery( strComputer, strName, hkeyQuery );

    if ( ERROR_SUCCESS == pdhStatus ) {
        PLA_TIME_INFO stiData;
        DWORD dwRestartMode = 0;
        DWORD dwState;

        pdhStatus = PlaiReadRegistryDwordValue(
                        hkeyQuery, 
                        szCurrentState, 
                        &dwState );
        
        if( ERROR_SUCCESS == pdhStatus ){
            if( PLA_QUERY_STOPPED != dwState ){
                PlaiGetServiceState( strComputer, dwState );
                if( dwState == SERVICE_STOPPED ){
                    dwState = PLA_QUERY_STOPPED;
                    PlaiWriteRegistryDwordValue ( hkeyQuery, szCurrentState, &dwState );
                }
            }
        }
        
        // If query is set to restart on end, clear the restart flag.
        pdhStatus = PlaiReadRegistryDwordValue ( hkeyQuery, szRestart, &dwRestartMode );

        if ( ERROR_SUCCESS == pdhStatus && PLA_AUTO_MODE_NONE != dwRestartMode ) {
            dwRestartMode = PLA_AUTO_MODE_NONE;
            pdhStatus = PlaiWriteRegistryDwordValue ( hkeyQuery, szRestart, &dwRestartMode );
        }

        PlaiRemoveRepeat( hkeyQuery );

        // Set stop mode to manual, stop time to MIN_TIME_VALUE
        if ( ERROR_SUCCESS == pdhStatus ) {
            memset (&stiData, 0, sizeof(stiData));
            stiData.wTimeType = PLA_TT_TTYPE_STOP;
            stiData.wDataType = PLA_TT_DTYPE_DATETIME;
            stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
            stiData.llDateTime = MIN_TIME_VALUE;

            pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
        }

        // If start time mode set to manual, set the value to MAX_TIME_VALUE
        if ( ERROR_SUCCESS == pdhStatus ) {
            pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStart, &stiData );

            if ( ERROR_SUCCESS == pdhStatus && PLA_AUTO_MODE_NONE == stiData.dwAutoMode ) {
                stiData.llDateTime = MAX_TIME_VALUE;
                pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStart, &stiData );
            }
        }

        PlaiWriteRegistryLastModified ( hkeyQuery );
        RELEASE_MUTEX(hPdhPlaMutex);

        if ( ERROR_SUCCESS == pdhStatus ) { 
            pdhStatus = PlaiSynchronize ( strComputer );
        }

    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaCreate

    Creates a new log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

        DWORD fType 
                PLA_COUNTER_LOG 
                PLA_TRACE_LOG                
    Return:

        ERROR_ALREADY_EXISTS
                The Query is currently running, no action taken

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiInitializeNewQuery(
    HKEY            hkeyLogQueries,
    HKEY&           rhKeyQuery,
    LPCWSTR         strComputer,
    LPCWSTR         strName 
    )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD   dwDisposition = 0;
    DWORD   dwValue;
    PLA_TIME_INFO   stiData;
    PLA_VERSION version;

    pdhStatus = PdhiPlaGetVersion( strComputer, &version );

    if( ERROR_SUCCESS == pdhStatus && version.dwBuild > 2195 ){

        GUID guid;
        UNICODE_STRING strGUID;

        dwStatus = UuidCreate( &guid );
        if( !( dwStatus == RPC_S_OK || dwStatus == RPC_S_UUID_LOCAL_ONLY ) ){
            return PlaiErrorToPdhStatus( dwStatus );
        }

        dwStatus = RtlStringFromGUID( guid, &strGUID );
        if( ERROR_SUCCESS != dwStatus ){
            return PlaiErrorToPdhStatus( dwStatus );
        }
    
        dwStatus = RegCreateKeyExW (
                hkeyLogQueries,
                strGUID.Buffer,
                0,
                NULL, 
                0,
                KEY_READ | KEY_WRITE,
                NULL,
                &rhKeyQuery,
                &dwDisposition
            );

        RtlFreeUnicodeString( &strGUID );
        pdhStatus = PlaiErrorToPdhStatus( dwStatus );
    }else{

        dwStatus = RegCreateKeyExW (
                hkeyLogQueries,
                strName,
                0,
                NULL, 
                0,
                KEY_READ | KEY_WRITE,
                NULL,
                &rhKeyQuery,
                &dwDisposition
            );
        pdhStatus = PlaiErrorToPdhStatus( dwStatus );
    }
    

    if ( ERROR_SUCCESS == pdhStatus ) {
        
        PlaiWriteRegistryStringValue( rhKeyQuery, szCollection, REG_SZ, strName, 0 );

        dwValue = PLA_QUERY_STOPPED;
        pdhStatus = PlaiWriteRegistryDwordValue ( 
                    rhKeyQuery, 
                    szCurrentState, 
                    &dwValue );

        if ( ERROR_SUCCESS == pdhStatus ) {
            // Initialize the log type to "new" to indicate partially created logs
            
            dwValue = PLA_NEW_LOG;
            pdhStatus = PlaiWriteRegistryDwordValue (
                        rhKeyQuery,
                        szLogType,
                        &dwValue );
            
            PlaiWriteRegistryStringValue( rhKeyQuery, szLogBaseName, REG_SZ, strName, 0 );

            memset (&stiData, 0, sizeof(stiData));
            stiData.wTimeType = PLA_TT_TTYPE_START;
            stiData.wDataType = PLA_TT_DTYPE_DATETIME;
            stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
            stiData.llDateTime = MIN_TIME_VALUE;

            pdhStatus = PlaiWriteRegistryPlaTime ( rhKeyQuery, szStart, &stiData );

            stiData.wTimeType = PLA_TT_TTYPE_STOP;
            pdhStatus = PlaiWriteRegistryPlaTime ( rhKeyQuery, szStop, &stiData );
            
            memset (&stiData, 0, sizeof(stiData));
            stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
            PlaiWriteRegistryPlaTime( rhKeyQuery, szCreateNewFile, &stiData );

            dwValue = 0;
            PlaiWriteRegistryDwordValue( rhKeyQuery, szRestart, &dwValue );
        
            dwValue = PLA_QUERY_STOPPED;
            PlaiWriteRegistryDwordValue( rhKeyQuery, szCurrentState, &dwValue );
        
            dwValue = PLA_DISK_MAX_SIZE;
            PlaiWriteRegistryDwordValue( rhKeyQuery, szLogMaxSize, &dwValue );
            
            dwValue = 1;
            PlaiWriteRegistryDwordValue( rhKeyQuery, szLogSerialNumber, &dwValue );
            
            dwValue = 1;
            PlaiWriteRegistryDwordValue( rhKeyQuery, szLogAutoFormat, &dwValue );
        
            PlaiWriteRegistryStringValue( rhKeyQuery, szComment, REG_SZ, NULL, 0 );

            PlaiWriteRegistryStringValue( rhKeyQuery, szEOFCmd, REG_SZ, NULL, 0 );

            if( PlaiIsStringEmpty( (LPWSTR)strComputer ) ){
                LPWSTR strDrive = _wgetenv( L"SystemDrive" );
                if( strDrive != NULL && wcslen(strDrive) < 5 ){
                    WCHAR buffer[16];
                    wsprintf( buffer, L"%s\\PerfLogs", strDrive );
                    PlaiWriteRegistryStringValue( rhKeyQuery, szLogFolder, REG_SZ, buffer, 0 );
                }
            }else{
                PlaiWriteRegistryStringValue( rhKeyQuery, szLogFolder, REG_SZ, L"%SystemDrive%\\PerfLogs", 0 );
            }
        }
    } 

    return pdhStatus;
}

PDH_FUNCTION
PlaiCreateCounterQuery( HKEY hkeyQuery )
{
    PDH_STATUS pdhStatus;
    DWORD dwValue;

    dwValue = PLA_BIN_FILE;
    pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogFileType, &dwValue );
    
    PLA_TIME_INFO   stiData;

    stiData.wTimeType = PLA_TT_TTYPE_SAMPLE;
    stiData.dwAutoMode = PLA_AUTO_MODE_AFTER;
    stiData.wDataType = PLA_TT_DTYPE_UNITS;
    stiData.dwUnitType = PLA_TT_UTYPE_SECONDS;
    stiData.dwValue = 0x000F;
    
    pdhStatus = PlaiWriteRegistryPlaTime( hkeyQuery, szSampleInterval, &stiData );

    PlaiWriteRegistryStringValue( hkeyQuery, szPerfCounterList, REG_MULTI_SZ, NULL, 0 );

    pdhStatus = PlaiWriteRegistryLastModified ( hkeyQuery );

    dwValue = PLA_DATASTORE_SIZE_KB|PLA_DATASTORE_APPEND;
    PlaiWriteRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &dwValue );
    PlaiWriteRegistryStringValue(hkeyQuery, szPerfCounterList, REG_MULTI_SZ, NULL, 0 );

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PlaiCreateTraceQuery( HKEY hkeyQuery )
{
    PDH_STATUS pdhStatus;
    DWORD dwValue;

    dwValue = 0;
    pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceProviderCount, &dwValue );
    
    dwValue = 128;
    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferSize, &dwValue );
    
    dwValue = 8;
    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferMin, &dwValue );
    
    dwValue = 32;
    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferMax, &dwValue );
    
    dwValue = 0;
    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceFlushInterval, &dwValue );

    dwValue = 0;
    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceMode, &dwValue );

    PlaiWriteRegistryStringValue( hkeyQuery, szTraceProviderList, REG_MULTI_SZ, NULL, 0 );

    dwValue = 
        PLA_TLI_ENABLE_KERNEL_TRACE |
        PLA_TLI_ENABLE_PROCESS_TRACE |
        PLA_TLI_ENABLE_THREAD_TRACE |
        PLA_TLI_ENABLE_DISKIO_TRACE |
        PLA_TLI_ENABLE_NETWORK_TCPIP_TRACE;

    dwValue = PLA_DATASTORE_SIZE_MB|PLA_DATASTORE_APPEND;
    PlaiWriteRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &dwValue );

    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceFlags, &dwValue );
    
    dwValue = PLA_SEQ_TRACE_FILE;
    PlaiWriteRegistryDwordValue( hkeyQuery, szLogFileType, &dwValue );

    PlaiWriteRegistryLastModified ( hkeyQuery );

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhPlaCreateA( LPSTR /*strName*/, LPSTR /*strComputer*/, PPDH_PLA_INFO_A /*pInfo*/ )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaCreateW( LPWSTR strName, LPWSTR strComputer, PPDH_PLA_INFO_W pInfo )
{
    PDH_STATUS pdhStatus;
    PDH_STATUS pdhWarning = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;
    HKEY    rhkeyLogQueries = NULL;
    BOOL    bMutex = FALSE;

    VALIDATE_QUERY( strName );

    pdhStatus = PlaiScanForInvalidChar( strName );
    CHECK_STATUS(pdhStatus);

    pdhStatus = PlaiConnectAndLockQuery( strComputer, strName, hkeyQuery );

    if( ERROR_SUCCESS == pdhStatus ){
        bMutex = TRUE;
        pdhStatus = PDH_PLA_ERROR_ALREADY_EXISTS;
        goto cleanup;
    }
 
    pdhStatus = PdhPlaValidateInfoW( strName, strComputer, pInfo );
    switch( SEVERITY(pdhStatus) ){
    case STATUS_SEVERITY_ERROR:
        goto cleanup;
    case STATUS_SEVERITY_WARNING:
        pdhWarning = pdhStatus;
        pdhStatus = ERROR_SUCCESS;
    }

    pdhStatus = PlaiConnectToRegistry( strComputer, rhkeyLogQueries, TRUE );

    if( ERROR_SUCCESS == pdhStatus ){
        DWORD dwStatus;
        dwStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhPlaMutex);
    
        if( ERROR_SUCCESS == dwStatus || WAIT_ABANDONED == dwStatus ){
            bMutex = TRUE;
            pdhStatus = PlaiInitializeNewQuery (
                            rhkeyLogQueries,
                            hkeyQuery,
                            strComputer,
                            strName
                            );

            switch( pInfo->dwType ){
            case PLA_COUNTER_LOG:
                pdhStatus = PlaiCreateCounterQuery( hkeyQuery );
                break;

            case PLA_TRACE_LOG:
                pdhStatus = PlaiCreateTraceQuery( hkeyQuery );
                break;
            }
        }else{
            pdhStatus = PlaiErrorToPdhStatus( dwStatus );
        }
    }

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PlaiSetInfo( strComputer, hkeyQuery, pInfo );
    }

    if( bMutex ){
        RELEASE_MUTEX(hPdhPlaMutex);
        bMutex = FALSE;
    }

    if( ERROR_SUCCESS == pdhStatus && (pInfo->dwMask & PLA_INFO_FLAG_USER) ){
        pdhStatus = PdhPlaSetRunAsW( strName, strComputer, pInfo->strUser, pInfo->strPassword );
    }
    
    if( ERROR_SUCCESS == pdhStatus ){
        DWORD dwStatus;
        dwStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhPlaMutex);
        if( ERROR_SUCCESS == dwStatus || WAIT_ABANDONED == dwStatus ){
            DWORD dwValue;
            bMutex = TRUE;
            switch( pInfo->dwType ){
            case PLA_COUNTER_LOG:
                dwValue = PLA_COUNTER_LOG;
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogType, &dwValue );
                break;

            case PLA_TRACE_LOG:
                dwValue = PLA_TRACE_LOG;
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogType, &dwValue );
                break;
            }
        }else{
            pdhStatus = PlaiErrorToPdhStatus( dwStatus );
        }

    }

cleanup:
    if( bMutex ){
        RELEASE_MUTEX(hPdhPlaMutex);
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }
    
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PlaiSynchronize( strComputer );
        if( ERROR_SUCCESS == pdhStatus && (pInfo->dwMask & PLA_INFO_FLAG_BEGIN) ){

            PlaiUpdateServiceMode( strComputer );
        }
    }else if( PDH_PLA_ERROR_ALREADY_EXISTS != pdhStatus ){
        PdhPlaDeleteW( strName, strComputer );
    }

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = pdhWarning;
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaDelete

    Deletes an existing log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
    Return:

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhPlaDeleteA( LPSTR strName, LPSTR strComputer )
{
    PDH_STATUS pdhStatus;
    LPWSTR wstrName = NULL;
    LPWSTR wstrComputer = NULL;
    
    VALIDATE_QUERY( strName );

    pdhStatus = Plaiatow( strComputer, wstrComputer );
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = Plaiatow( strName, wstrName );
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PdhPlaDeleteW( wstrName, wstrComputer );
        }
    }
   
    G_FREE( wstrComputer );
    G_FREE( wstrName );

    return pdhStatus;
}

PDH_FUNCTION
PdhPlaDeleteW( LPWSTR strName, LPWSTR strComputer )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PDH_STATUS pdhStatus;
    HKEY  hkeyLogQueries = NULL;
                
    VALIDATE_QUERY( strName );

    pdhStatus = PlaiConnectToRegistry ( strComputer, hkeyLogQueries, TRUE );

    if( ERROR_SUCCESS == pdhStatus ){

        dwStatus = WAIT_FOR_AND_LOCK_MUTEX( hPdhPlaMutex );

        if( ERROR_SUCCESS == dwStatus || WAIT_ABANDONED == dwStatus ){
            DWORD nCollections = 0;
            DWORD nMaxSubKeyLength = 0;

            dwStatus = RegQueryInfoKey(
                        hkeyLogQueries,
                        NULL,
                        NULL,
                        NULL,
                        &nCollections,
                        &nMaxSubKeyLength,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL 
                    );

            if( ERROR_SUCCESS == dwStatus ){
            
                LPWSTR strCollection;
                LPWSTR strQueryName = NULL;
                DWORD dwQueryName = 0;
                HKEY hkeyQuery = NULL;

                DWORD dwSize = (sizeof(WCHAR)*(nMaxSubKeyLength+1));

                strCollection = (LPWSTR)G_ALLOC( dwSize );

                if( strCollection ){
                    BOOL bFound = FALSE;                
                    for( ULONG i = 0; i<nCollections; i++ ){
                        dwStatus = RegEnumKey( hkeyLogQueries, i, strCollection, dwSize );
                        if( ERROR_SUCCESS == dwStatus ) {

                            dwStatus = RegOpenKeyExW (
                                    hkeyLogQueries,
                                    strCollection,
                                    0,
                                    KEY_READ | KEY_WRITE,
                                    &hkeyQuery 
                                );

                            if( ERROR_SUCCESS == dwStatus && !PlaiIsStringEmpty( strCollection ) ){
                                if( !_wcsicmp( strCollection, strName ) ){
                                    bFound = TRUE;
                                }else{

                                    PlaiReadRegistryStringValue( hkeyQuery, szCollection, READ_REG_MUI, &strQueryName, &dwQueryName );
                            
                                    if( !PlaiIsStringEmpty( strQueryName ) ){
                                        if( !_wcsicmp( strQueryName, strName ) ){
                                            bFound = TRUE;
                                        }
                                    }
                                }

                                if( bFound ){

                                    DWORD dwState;
                                    dwStatus = PlaiReadRegistryDwordValue(
                                                    hkeyQuery, 
                                                    szCurrentState, 
                                                    &dwState );
    
                                    if( ERROR_SUCCESS == dwStatus ){
                                        if( PLA_QUERY_RUNNING == dwState ){
                                            PlaiGetServiceState( strComputer, dwState );
                                            if( dwState != SERVICE_STOPPED ){
                                                dwStatus = ERROR_SERVICE_ALREADY_RUNNING;
                                            }
                                        }
                                    }
                                    
                                    if( ERROR_SUCCESS == dwStatus ){
                                        RegCloseKey( hkeyQuery );
                                        dwStatus = RegDeleteKey( hkeyLogQueries, strCollection ); 
                                    }

                                    break;
                                }

                                dwStatus = ERROR_FILE_NOT_FOUND;

                                if ( NULL != hkeyQuery ) {
                                    RegCloseKey ( hkeyQuery );
                                }
                            }
                        }
                    }

                    G_FREE( strQueryName );
                    G_FREE( strCollection );

                }else{
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            }
        }

        RegCloseKey ( hkeyLogQueries );

        RELEASE_MUTEX(hPdhPlaMutex);
    }else{        
        return pdhStatus;
    }

    if( ERROR_SUCCESS == dwStatus ){
        PlaiSynchronize( strComputer );
        PlaiUpdateServiceMode( strComputer );
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

/*****************************************************************************\

    PdhPlaSetItemList

    Sets the list of Items for a log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

        LPTSTR  mszItems
                Multistring of the Items for the query to collect.  Any 
                existing Items will be overwritten.

        ULONG   length
                Length of the mszItems buffer

    Return:

        PDH_INVALID_ARGUMENT
                The query does not exist or pItems->dwType != Log Type

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiIsKernel( LPWSTR mszGuid, BOOL* pbKernel, ULONG* pnCount )
{
    DWORD dwStatus;
    LPTSTR strGuid = mszGuid;
    UNICODE_STRING strKernel;
        
    *pbKernel = FALSE;
    *pnCount = 0;

    dwStatus = RtlStringFromGUID( SystemTraceControlGuid, &strKernel );
    
    if( ERROR_SUCCESS != dwStatus ){
        return PlaiErrorToPdhStatus( dwStatus );
    }
    
    if( NULL != mszGuid ){
        while( *strGuid != L'\0' ){
            if( ! wcscmp( strGuid, strKernel.Buffer ) ){
                *pbKernel = TRUE;
            }
            strGuid += (wcslen( strGuid) + 1 );
            (*pnCount)++;
        }
    }
    
    RtlFreeUnicodeString( &strKernel );
    
    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiSetItemList(
        HKEY    hkeyQuery,
        PPDH_PLA_ITEM_W pItems
    )
{
    PDH_STATUS pdhStatus;
        
    DWORD dwValue;
    pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogType, &dwValue );

    if( ERROR_SUCCESS == pdhStatus && 
        (dwValue != pItems->dwType && 
        PLA_NEW_LOG != dwValue) ){

        pdhStatus = PDH_PLA_ERROR_TYPE_MISMATCH;
    }

    if( ERROR_SUCCESS == pdhStatus ){
        
        switch( pItems->dwType ){
        case PLA_TRACE_LOG:
            {
                BOOL bKernel;
                ULONG nCount;
                pdhStatus = PlaiIsKernel( pItems->strProviders, &bKernel, &nCount );
                if( ERROR_SUCCESS != pdhStatus ){
                    return pdhStatus;
                }
                if( bKernel ){
                
                    if( nCount == 1 ){
                        DWORD dwFlags = Plaihextoi( pItems->strFlags );
                        DWORD dwInternal = 0;

                        pdhStatus = PlaiTranslateKernelFlags( &dwInternal, &dwFlags );

                        pdhStatus = PlaiWriteRegistryDwordValue( 
                                    hkeyQuery, 
                                    szTraceFlags, 
                                    &dwInternal
                                );
                    
                        pdhStatus = PlaiWriteRegistryStringValue( 
                                    hkeyQuery, 
                                    szTraceProviderList, 
                                    REG_MULTI_SZ, 
                                    NULL, 
                                    0
                                );
                        

                    }else{
                        return PDH_INVALID_ARGUMENT;
                    }
                }else{
                    DWORD dwFlags = 0;

                    pdhStatus = PlaiWriteRegistryDwordValue( 
                                hkeyQuery, 
                                szTraceFlags, 
                                &dwFlags 
                            );

                    pdhStatus = PlaiWriteRegistryStringValue( 
                                hkeyQuery, 
                                szTraceProviderList, 
                                REG_MULTI_SZ, 
                                pItems->strProviders, 
                                PlaMszStrLenW( pItems->strProviders )
                            );
                }

                pdhStatus = PlaiWriteRegistryStringValue( 
                            hkeyQuery, 
                            szTraceProviderFlags, 
                            REG_MULTI_SZ, 
                            pItems->strFlags, 
                            PlaMszStrLenW( pItems->strFlags )
                        );

                pdhStatus = PlaiWriteRegistryStringValue( 
                            hkeyQuery, 
                            szTraceProviderLevels, 
                            REG_MULTI_SZ, 
                            pItems->strLevels, 
                            PlaMszStrLenW( pItems->strLevels )
                        );

            break;
            }
        case PLA_COUNTER_LOG:
            {
                if( PLA_ENGLISH ){

                    pdhStatus = PlaiWriteRegistryStringValue( 
                                hkeyQuery, 
                                szPerfCounterList, 
                                REG_MULTI_SZ, 
                                pItems->strCounters, 
                                PlaMszStrLenW( pItems->strCounters )
                            );

                }else{

                    LPWSTR strCounter = pItems->strCounters;

                    pdhStatus = PlaiWriteRegistryStringValue( 
                            hkeyQuery, 
                            szPerfCounterList, 
                            REG_MULTI_SZ, 
                            L"\0", 
                            sizeof(WCHAR) 
                        );

                    if( ERROR_SUCCESS == pdhStatus && NULL != strCounter ){

                        PDH_PLA_ITEM_W Counter;
                        Counter.dwType = PLA_COUNTER_LOG;
                        while( *strCounter != L'\0' ){
                            Counter.strCounters = strCounter;
                            pdhStatus = PlaiAddItem( hkeyQuery, &Counter );
                            if( ERROR_SUCCESS != pdhStatus ){
                                break;
                            }
                            strCounter += (wcslen(strCounter)+1);
                        }
                    }

                }
            }
            break;
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhPlaSetItemListA(
        LPSTR  /*strName*/,
        LPSTR  /*strComputer*/,
        PPDH_PLA_ITEM_A  /*pItems*/
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaSetItemListW(
        LPWSTR  strName,
        LPWSTR  strComputer,
        PPDH_PLA_ITEM_W pItems
    )
{
    PDH_STATUS pdhStatus;
    HKEY hkeyQuery = NULL;

    VALIDATE_QUERY( strName );

    pdhStatus = PlaiConnectAndLockQuery( strComputer, strName, hkeyQuery );

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PlaiSetItemList( hkeyQuery, pItems );        
    }

    RELEASE_MUTEX(hPdhPlaMutex);

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaAddItem

    Sets the list of items ( counters or providers ) for a log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

        LPTSTR  strItem
                A single item to be added to the list of Items or providers
                the query will collect

    Return:
        PDH_MEMORY_ALLOCATION_FAILURE
                The total list of items will not fit in the available 
                memory.

        PDH_PLA_COLLECTION_NOT_FOUND
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION 
PlaiRegAddItem(
        HKEY    hkeyQuery,
        LPCWSTR  strList,
        LPWSTR  strItem
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    
    LPWSTR  strOldList = NULL;
    LPWSTR  strNewList = NULL;

    DWORD   dwNewDataSize = ( wcslen( strItem ) ) * sizeof(WCHAR);
    DWORD   dwOldDataSize = 0;
    DWORD   dwTermSize = sizeof(WCHAR) * 2;
    
    if( PlaiIsStringEmpty( strItem ) ){
        return PDH_INVALID_ARGUMENT;
    }

    if( ERROR_SUCCESS == pdhStatus ){

        pdhStatus = PlaiReadRegistryStringValue( hkeyQuery, strList, 0, &strOldList, &dwOldDataSize );
    
        strNewList = (LPWSTR)G_ALLOC( dwOldDataSize + dwNewDataSize + dwTermSize);

        if( NULL == strNewList ){
            G_FREE( strOldList );
            return PDH_MEMORY_ALLOCATION_FAILURE;
        }

        ZeroMemory( strNewList, dwOldDataSize + dwNewDataSize + dwTermSize );

        if( dwOldDataSize ){
            memcpy( strNewList, strOldList, dwOldDataSize );
            memcpy( (((PUCHAR)strNewList) + (dwOldDataSize-sizeof(WCHAR))), strItem, dwNewDataSize );
        }else{
            memcpy( strNewList, strItem, dwNewDataSize );
        }
        
        pdhStatus = PlaiWriteRegistryStringValue( 
                hkeyQuery, 
                strList, 
                REG_MULTI_SZ, 
                strNewList, 
                (dwOldDataSize + dwNewDataSize + sizeof(WCHAR)) 
            );
    }

    G_FREE( strOldList );
    G_FREE( strNewList );
 
    return pdhStatus;
}

PDH_FUNCTION
PlaiAddItem( 
        HKEY hkeyQuery,
        PPDH_PLA_ITEM_W pItem 
    )
{
    PDH_STATUS pdhStatus;
    DWORD dwValue;

    pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogType, &dwValue );

    if( ERROR_SUCCESS == pdhStatus && dwValue != pItem->dwType ){
        pdhStatus = PDH_PLA_ERROR_TYPE_MISMATCH;
    }
    if( ERROR_SUCCESS == pdhStatus ){
        switch( pItem->dwType ){
        case PLA_TRACE_LOG:
            {
                BOOL bKernel;
                ULONG nCount;
                pdhStatus = PlaiIsKernel( pItem->strProviders, &bKernel, &nCount );
                if( ERROR_SUCCESS == pdhStatus ){
                    if( bKernel ){
                        DWORD dwFlags = Plaihextoi( pItem->strFlags );
                
                        pdhStatus = PlaiWriteRegistryDwordValue( 
                                    hkeyQuery, 
                                    szTraceFlags, 
                                    &dwFlags
                                );
                
                        pdhStatus = PlaiWriteRegistryStringValue( 
                                    hkeyQuery, 
                                    szTraceProviderList, 
                                    REG_MULTI_SZ, 
                                    NULL,
                                    0
                                );
                    }else{
                        DWORD dwFlags = 0;
                        pdhStatus = PlaiWriteRegistryDwordValue( 
                                    hkeyQuery, 
                                    szTraceFlags, 
                                    &dwFlags
                                );

                        pdhStatus = PlaiRegAddItem( hkeyQuery, szTraceProviderList, pItem->strProviders );
                        if( ERROR_SUCCESS == pdhStatus ){
                            pdhStatus = PlaiRegAddItem( hkeyQuery, szTraceProviderFlags, pItem->strFlags );
                            if( ERROR_SUCCESS == pdhStatus ){
                                pdhStatus = PlaiRegAddItem( hkeyQuery, szTraceProviderLevels, pItem->strLevels );
                            }
                        }
                    }
                }
            }
            break;
        case PLA_COUNTER_LOG:
            {
                if( PLA_ENGLISH ){
                    pdhStatus = PlaiRegAddItem( hkeyQuery, szPerfCounterList, pItem->strCounters );
                }else{
                    LPWSTR strLocaleCounter = pItem->strCounters;
                    LPWSTR strEnglishCounter = NULL;
                    DWORD dwSize = MAX_PATH;
                
                    strEnglishCounter = (LPWSTR)G_ALLOC( dwSize*sizeof(WCHAR) );
                    if( NULL != strEnglishCounter ){

                        pdhStatus = PdhTranslate009CounterW( strLocaleCounter, strEnglishCounter, &dwSize );
                        if( PDH_MORE_DATA == pdhStatus ){
                            LPTSTR strBuffer = (LPWSTR)G_REALLOC( strEnglishCounter, (dwSize*sizeof(WCHAR)) );
                            if( NULL != strBuffer ){
                                strEnglishCounter = strBuffer;
                                pdhStatus = PdhTranslate009CounterW( strLocaleCounter, strEnglishCounter, &dwSize );
                            }else{
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                        }
                        if( ERROR_SUCCESS == pdhStatus ){
                            pdhStatus = PlaiRegAddItem( hkeyQuery, szPerfCounterList, strEnglishCounter );
                        }else{
                            pdhStatus = PlaiRegAddItem( hkeyQuery, szPerfCounterList, pItem->strCounters );
                        }
        
                        G_FREE( strEnglishCounter );
                    }else{
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }

            }
        }
    }

    return pdhStatus;
}

PDH_FUNCTION 
PdhPlaAddItemA(
        LPSTR  strName,
        LPSTR  strComputer,
        PPDH_PLA_ITEM_A pItem
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION 
PdhPlaAddItemW(
        LPWSTR  strName,
        LPWSTR  strComputer,
        PPDH_PLA_ITEM_W pItem
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;
    
    VALIDATE_QUERY( strName );

    pdhStatus = PlaiConnectAndLockQuery( strComputer, strName, hkeyQuery );

    if( ERROR_SUCCESS == pdhStatus ){
        
        pdhStatus = PlaiAddItem( hkeyQuery, pItem );

        RELEASE_MUTEX(hPdhPlaMutex);
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaRemoveAllItems

    Removes all entries for the list of Items the log query will collect

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

    Return:
        PDH_INVALID_ARGUMENT
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/


PDH_FUNCTION
PdhPlaRemoveAllItemsA( LPSTR strName, LPSTR strComputer )
{
    PDH_STATUS pdhStatus;
    LPWSTR wstrName = NULL;
    LPWSTR wstrComputer = NULL;

    VALIDATE_QUERY( strName );
    
    pdhStatus = Plaiatow( strComputer, wstrComputer );
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = Plaiatow( strName, wstrName );
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PdhPlaRemoveAllItemsW( wstrName, wstrComputer );
        }
    }
   
    G_FREE( wstrComputer );
    G_FREE( wstrName );

    return pdhStatus;
}

PDH_FUNCTION 
PdhPlaRemoveAllItemsW(
        LPWSTR strName,
        LPWSTR strComputer
    )
{
    PDH_STATUS pdhStatus;
    HKEY    hkeyQuery = NULL;

    VALIDATE_QUERY( strName );

    pdhStatus = PlaiConnectAndLockQuery( strComputer, strName, hkeyQuery );
    
    if( ERROR_SUCCESS == pdhStatus ){
        DWORD dwValue;
        pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogType, &dwValue );
        
        if( ERROR_SUCCESS == pdhStatus ){
            
            switch( dwValue ){
            case PLA_TRACE_LOG:
                pdhStatus = PlaiWriteRegistryStringValue( 
                            hkeyQuery, 
                            szTraceProviderList, 
                            REG_MULTI_SZ, L"\0", 
                            sizeof(WCHAR) 
                        );
                pdhStatus = PlaiWriteRegistryStringValue( 
                            hkeyQuery, 
                            szTraceProviderFlags, 
                            REG_MULTI_SZ, L"\0", 
                            sizeof(WCHAR) 
                        );
                pdhStatus = PlaiWriteRegistryStringValue( 
                            hkeyQuery, 
                            szTraceProviderLevels, 
                            REG_MULTI_SZ, L"\0", 
                            sizeof(WCHAR) 
                        );
                break;
            case PLA_COUNTER_LOG:
                pdhStatus = PlaiWriteRegistryStringValue( 
                            hkeyQuery, 
                            szPerfCounterList, 
                            REG_MULTI_SZ, 
                            L"\0", 
                            sizeof(WCHAR) 
                        );
                break;
            }
        }
    
        RELEASE_MUTEX(hPdhPlaMutex);
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    return pdhStatus;
}


/*****************************************************************************\

    PdhPlaGetInfo

    Fills the PDH_PLA_INFO structure with the properties of the requested 
    log query.

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

        PPDH_PLA_INFO pInfo
                Information block

    Return:
        PDH_INVALID_ARGUMENT
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiAssignInfoString(
    LPWSTR strName,
    HKEY hkeyQuery, 
    PPDH_PLA_INFO_W pInfo, 
    LPDWORD dwTotalSize,
    LPWSTR& strCopy,
    DWORD dwBufferSize,
    DWORD dwMask,
    DWORD dwQueryMask,
    LPCTSTR szKey, 
    DWORD dwRegFlag
    )
{
    
    LPWSTR strKeyValue = NULL;
    LPWSTR strInfo = NULL;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwKeySize = 0;
    BOOL bRead = TRUE;
    
    VALIDATE_QUERY( strName );
    
    if( pInfo != NULL ){
        if( !(dwQueryMask & dwMask) ){
            bRead = FALSE;
        }
    }

    if( bRead ){
        pdhStatus = PlaiReadRegistryStringValue( hkeyQuery, szKey, dwRegFlag, &strKeyValue, &dwKeySize );
        
        if( (ERROR_SUCCESS == pdhStatus) && 
            (!PlaiIsStringEmpty(strKeyValue)) && 
            (dwKeySize > sizeof(WCHAR)) ){

            *dwTotalSize += dwKeySize;

        }else if( dwMask == PLA_INFO_FLAG_USER ){
            
            G_FREE( strKeyValue );
            strKeyValue = (LPWSTR)G_ALLOC(PLA_ACCOUNT_BUFFER*sizeof(WCHAR) );
            
            if( strKeyValue != NULL ){
                dwKeySize = LoadStringW( 
                        (HINSTANCE)ThisDLLHandle, 
                        IDS_DEFAULT_ACCOUNT, 
                        strKeyValue, 
                        PLA_ACCOUNT_BUFFER 
                    );
                
                if( dwKeySize ){
                    dwKeySize = BYTE_SIZE( strKeyValue ) + sizeof(WCHAR);
                    *dwTotalSize += dwKeySize;
                }
            }else{
                bRead = FALSE;
            }
            
        }else if( (dwMask == PLA_INFO_FLAG_LOGGERNAME) || 
                  ((dwMask == PLA_INFO_FLAG_FILENAME) && (ERROR_SUCCESS != pdhStatus)) ){

            dwKeySize = BYTE_SIZE( strName ) + sizeof(WCHAR);
            *dwTotalSize += dwKeySize;
            strKeyValue = (LPWSTR)G_ALLOC(dwKeySize);
            if( NULL != strKeyValue && !PlaiIsStringEmpty( strName ) ){
                wcscpy( strKeyValue, strName );
            }else{
                bRead = FALSE;
            }

        }else{
            dwKeySize = 0;
        }
    }

    if( pInfo != NULL && bRead ){
        if( dwKeySize && (dwBufferSize >= *dwTotalSize) ){
            memcpy( (void*)strCopy, (void*)strKeyValue, dwKeySize );
            strInfo = strCopy;
            strCopy = (LPWSTR)((PUCHAR)strCopy + dwKeySize );
        }
        
        switch( dwMask ){
        case PLA_INFO_FLAG_COUNTERS:
            pInfo->dwMask |= PLA_INFO_FLAG_COUNTERS;
            pInfo->Perf.piCounterList.strCounters = strInfo;
            break;
        case PLA_INFO_FLAG_SQLNAME: 
            pInfo->dwMask |= PLA_INFO_FLAG_SQLNAME;
            pInfo->strSqlName = strInfo;
            break;
        case PLA_INFO_FLAG_FILENAME:
            pInfo->dwMask |= PLA_INFO_FLAG_FILENAME;
            pInfo->strBaseFileName = strInfo;
            break;
        case PLA_INFO_FLAG_PROVIDERS:
            pInfo->dwMask |= PLA_INFO_FLAG_PROVIDERS;
            pInfo->Trace.piProviderList.strProviders = strInfo;
            break;
        case PLA_INFO_FLAG_LOGGERNAME:
            pInfo->dwMask |= PLA_INFO_FLAG_LOGGERNAME;
            pInfo->Trace.strLoggerName = strInfo;
            break;
        case PLA_INFO_FLAG_USER:
            pInfo->dwMask |= PLA_INFO_FLAG_USER;
            pInfo->strUser = strInfo;
            break;
        case PLA_INFO_FLAG_DEFAULTDIR:
            pInfo->dwMask |= PLA_INFO_FLAG_DEFAULTDIR;
            pInfo->strDefaultDir = strInfo;
            break;
        }
    }
        
    G_FREE( strKeyValue );
    
    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhPlaGetInfoA(
        LPSTR /*strName*/,
        LPSTR /*strComputer*/,
        LPDWORD /*pdwBufferSize*/,
        PPDH_PLA_INFO_A /*pInfo*/
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaGetInfoW(
        LPWSTR strName,
        LPWSTR strComputer,
        LPDWORD pdwBufferSize,
        PPDH_PLA_INFO_W pInfo
    )
{
    PDH_STATUS pdhStatus;
    HKEY hkeyQuery = NULL;
    DWORD dwSize = 0;
    LPWSTR strCopy = NULL;
    LPWSTR strKey = NULL; 
    DWORD  dwKeySize = 0;
    DWORD dwMask = 0;

    VALIDATE_QUERY( strName );

    pdhStatus = PlaiConnectAndLockQuery( strComputer, strName, hkeyQuery, FALSE );

    if( ERROR_SUCCESS == pdhStatus ){
        
        if( NULL != pInfo ){
            dwMask = pInfo->dwMask;
            pInfo->dwMask = 0;
        }

        DWORD dwType = 0;
        dwSize = sizeof(PDH_PLA_INFO_W);
        
        if( pInfo == NULL ){
            *pdwBufferSize = 0;
        }else{
            strCopy = (LPWSTR)( (PUCHAR)pInfo+ sizeof(PDH_PLA_INFO_W) );
        }

        PlaiReadRegistryDwordValue( hkeyQuery, szLogType, &dwType );
        
        if( pInfo != NULL ){
            if( dwMask & PLA_INFO_FLAG_TYPE ){
                pInfo->dwMask |= PLA_INFO_FLAG_TYPE;
                pInfo->dwType = dwType;
            }
            if( dwMask & PLA_INFO_FLAG_AUTOFORMAT ){
                pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogAutoFormat, &pInfo->dwAutoNameFormat );
                if( ERROR_SUCCESS == pdhStatus ){
                    pInfo->dwMask |= PLA_INFO_FLAG_AUTOFORMAT;
                }
            }
            if( dwMask & PLA_INFO_FLAG_SRLNUMBER ){
                pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogSerialNumber, &pInfo->dwLogFileSerialNumber );
                if( ERROR_SUCCESS == pdhStatus ){
                    pInfo->dwMask |= PLA_INFO_FLAG_SRLNUMBER;
                }
            }
            if( dwMask & PLA_INFO_FLAG_REPEAT ){
                pdhStatus = PlaiReadRegistryPlaTime( hkeyQuery, szRepeatSchedule, &pInfo->ptRepeat );
                if( ERROR_SUCCESS == pdhStatus ){
                    pInfo->dwMask |= PLA_INFO_FLAG_REPEAT;
                }
            }
            if( dwMask & PLA_INFO_FLAG_STATUS ){
                pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szCurrentState, &pInfo->dwStatus );
                if( ERROR_SUCCESS == pdhStatus ){
                    pInfo->dwMask |= PLA_INFO_FLAG_STATUS;
                }
            }
            if( dwMask & PLA_INFO_FLAG_FORMAT ){
                pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogFileType, &pInfo->dwFileFormat );
                if( ERROR_SUCCESS == pdhStatus ){
                    pInfo->dwMask |= PLA_INFO_FLAG_FORMAT;
                }
            }
            if( dwMask & PLA_INFO_FLAG_DATASTORE ){
                pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &pInfo->dwDatastoreAttributes );
                if( ERROR_SUCCESS == pdhStatus ){
                    pInfo->dwMask |= PLA_INFO_FLAG_DATASTORE;
                }
            }
            if( dwMask & PLA_INFO_FLAG_CRTNEWFILE ){
                pdhStatus = PlaiReadRegistryPlaTime( hkeyQuery, szCreateNewFile, &pInfo->ptCreateNewFile);
                if( ERROR_SUCCESS == pdhStatus ){
                    pInfo->dwMask |= PLA_INFO_FLAG_CRTNEWFILE;
                }
            }
            if( dwMask & PLA_INFO_FLAG_END ){
                pdhStatus = PlaiReadRegistryPlaTime( hkeyQuery, szStop, &pInfo->ptLogEndTime );
                if( ERROR_SUCCESS == pdhStatus ){
                    pInfo->dwMask |= PLA_INFO_FLAG_END;
                }
            }
            if( dwMask & PLA_INFO_FLAG_BEGIN ){
                pdhStatus = PlaiReadRegistryPlaTime( hkeyQuery, szStart, &pInfo->ptLogBeginTime );
                if( ERROR_SUCCESS == pdhStatus ){
                    pInfo->dwMask |= PLA_INFO_FLAG_BEGIN;
                }
            }
        }   
        
        pdhStatus = PlaiAssignInfoString( strName, hkeyQuery, pInfo, &dwSize, strCopy, *pdwBufferSize, 
            PLA_INFO_FLAG_FILENAME, dwMask, szLogBaseName, READ_REG_MUI );
                
        pdhStatus = PlaiAssignInfoString( strName, hkeyQuery, pInfo, &dwSize, strCopy, *pdwBufferSize, 
            PLA_INFO_FLAG_USER, dwMask, szRunAs, 0 );
        
        pdhStatus = PlaiAssignInfoString( strName, hkeyQuery, pInfo, &dwSize, strCopy, *pdwBufferSize, 
            PLA_INFO_FLAG_DEFAULTDIR, dwMask, szLogFolder, READ_REG_MUI );

        switch( dwType ){
        case PLA_TRACE_LOG:   // Trace Fields
            if( NULL != pInfo ){
                if( dwMask & PLA_INFO_FLAG_MODE ){
                    pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szTraceMode, &pInfo->Trace.dwMode );
                    if( ERROR_SUCCESS == pdhStatus ){
                        pInfo->dwMask |= PLA_INFO_FLAG_MODE;
                    }
                }
                if( dwMask & PLA_INFO_FLAG_BUFFERSIZE ){
                    pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szTraceBufferSize, &pInfo->Trace.dwBufferSize );
                    if( ERROR_SUCCESS == pdhStatus ){
                        pInfo->dwMask |= PLA_INFO_FLAG_BUFFERSIZE;
                    }
                }
                if( dwMask & PLA_INFO_FLAG_PROVIDERS ){
                    pInfo->Trace.piProviderList.dwType = PLA_TRACE_LOG;
                }
            }
            pdhStatus = PlaiAssignInfoString( strName, hkeyQuery, pInfo, &dwSize, strCopy, *pdwBufferSize, 
                    PLA_INFO_FLAG_PROVIDERS, dwMask, szTraceProviderList, 0 );

            pdhStatus = PlaiAssignInfoString( strName, hkeyQuery, pInfo, &dwSize, strCopy, *pdwBufferSize, 
                    PLA_INFO_FLAG_LOGGERNAME, dwMask, szTraceLoggerName, 0 );
            break;

        case PLA_COUNTER_LOG:  // Performance Fields
            if( NULL != pInfo ){
                if( dwMask & PLA_INFO_FLAG_COUNTERS ){
                    pInfo->Perf.piCounterList.dwType = PLA_COUNTER_LOG;
                }
            }
            pdhStatus = PlaiAssignInfoString( strName, hkeyQuery, pInfo, &dwSize, strCopy, *pdwBufferSize, 
                    PLA_INFO_FLAG_COUNTERS, dwMask, szPerfCounterList, 0 );

            pdhStatus = PlaiAssignInfoString( strName, hkeyQuery, pInfo, &dwSize, strCopy, *pdwBufferSize, 
                    PLA_INFO_FLAG_SQLNAME, dwMask, szSqlBaseName, 0 );
            break;
        }

        RELEASE_MUTEX(hPdhPlaMutex);
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    *pdwBufferSize = dwSize;

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaSetInfo
    
    Sets the information in the log query to the parameters in the 
    PDH_PLA_INFO block according to the info mask.

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

        PPDH_PLA_INFO pInfo
                Information block

    Return:
        PDH_INVALID_ARGUMENT
                The query does not exist or pInfo is NULL

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiSetInfo(
    LPWSTR strComputer,
    HKEY hkeyQuery,
    PPDH_PLA_INFO_W pInfo
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwType = 0;
    DWORD dwFormat = 0;
    DWORD dwDatastoreAttributes = 0;

    // General Fields
    if( pInfo->dwMask & PLA_INFO_FLAG_AUTOFORMAT ){
        pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogAutoFormat, &pInfo->dwAutoNameFormat );
    }
    if( pInfo->dwMask & PLA_INFO_FLAG_REPEAT ){
        pdhStatus = PlaiWriteRegistryPlaTime( hkeyQuery, szRepeatSchedule, &pInfo->ptRepeat );
    }
    if( pInfo->dwMask & PLA_INFO_FLAG_RUNCOMMAND ){
        pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szEOFCmd, REG_SZ, pInfo->strCommandFileName, 0 );
    }
    if( pInfo->dwMask & PLA_INFO_FLAG_CRTNEWFILE ){
        pdhStatus = PlaiWriteRegistryPlaTime( hkeyQuery, szCreateNewFile, &pInfo->ptCreateNewFile );
    }
    if( pInfo->dwMask & PLA_INFO_FLAG_MAXLOGSIZE ){
        pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogMaxSize, &pInfo->dwMaxLogSize );
    }
    if( pInfo->dwMask & (PLA_INFO_FLAG_SQLNAME|PLA_INFO_FLAG_FILENAME|PLA_INFO_FLAG_DEFAULTDIR) ){
        if( pInfo->dwMask & PLA_INFO_FLAG_FORMAT ){
            dwFormat = pInfo->dwFileFormat;
            pdhStatus = ERROR_SUCCESS;
        }else{
            pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogFileType, &dwFormat );
        }
        if( (ERROR_SUCCESS == pdhStatus) && (PLA_SQL_LOG == dwFormat) ){
            if( pInfo->dwMask & PLA_INFO_FLAG_SQLNAME ){
                pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szSqlBaseName, REG_SZ, pInfo->strSqlName, 0 );
            }else if( pInfo->dwMask & PLA_INFO_FLAG_FILENAME ){
                pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szSqlBaseName, REG_SZ, pInfo->strBaseFileName, 0 );
            }else if( pInfo->dwMask & PLA_INFO_FLAG_DEFAULTDIR ){
                pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szSqlBaseName, REG_SZ, pInfo->strDefaultDir, 0 );
            }
        }else{
            if( pInfo->dwMask & PLA_INFO_FLAG_SQLNAME ){
                pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szSqlBaseName, REG_SZ, pInfo->strSqlName, 0 );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_FILENAME ){
                pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szLogBaseName, REG_SZ, pInfo->strBaseFileName, 0 );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_DEFAULTDIR ){
                pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szLogFolder, REG_SZ, pInfo->strDefaultDir, 0 );
            }
        }
    }
    if( pInfo->dwMask & PLA_INFO_FLAG_TYPE ){
        // Do not write it to the registry because it may be a new collection
        dwType = pInfo->dwType;
    }else{
        PlaiReadRegistryDwordValue( hkeyQuery, szLogType, &dwType );
    }


    switch( dwType ){
    case PLA_TRACE_LOG:   // Trace Fields
        if( pInfo->dwMask & PLA_INFO_FLAG_FORMAT ){
            dwFormat = pInfo->dwFileFormat;
            switch( dwFormat ){
            case PLA_BIN_FILE:        dwFormat = PLA_SEQ_TRACE_FILE; break;
            case PLA_BIN_CIRC_FILE:   dwFormat = PLA_CIRC_TRACE_FILE; break;
            }
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogFileType, &dwFormat );
        }else{
            PlaiReadRegistryDwordValue( hkeyQuery, szLogFileType, &dwFormat );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_DATASTORE ){
            if( ! (pInfo->dwDatastoreAttributes & PLA_DATASTORE_APPEND_MASK ) ){
                if( dwFormat == PLA_SEQ_TRACE_FILE ){
                    pInfo->dwDatastoreAttributes |= PLA_DATASTORE_APPEND;
                }else{
                    pInfo->dwDatastoreAttributes |= PLA_DATASTORE_OVERWRITE;
                }
            }
            if( ! (pInfo->dwDatastoreAttributes & PLA_DATASTORE_SIZE_MASK ) ){
                pInfo->dwDatastoreAttributes |= PLA_DATASTORE_SIZE_MB;
            }
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &pInfo->dwDatastoreAttributes );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_BUFFERSIZE ){
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferSize, &pInfo->Trace.dwBufferSize );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_MINBUFFERS ){
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferMin, &pInfo->Trace.dwMinimumBuffers );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_MAXBUFFERS ){
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferMax, &pInfo->Trace.dwMaximumBuffers );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_FLUSHTIMER ){
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceFlushInterval, &pInfo->Trace.dwFlushTimer );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_MODE ){
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceMode, &pInfo->Trace.dwMode );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_LOGGERNAME ){
            pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szTraceLoggerName, REG_SZ, pInfo->Trace.strLoggerName, 0 );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_PROVIDERS ){
            pdhStatus = PlaiSetItemList( hkeyQuery, &pInfo->Trace.piProviderList );
        }
        break;

    case PLA_COUNTER_LOG:  // Performance Fields
        if( pInfo->dwMask & PLA_INFO_FLAG_FORMAT ){
            dwFormat = pInfo->dwFileFormat;
            switch( dwFormat ){
            case PLA_CIRC_TRACE_FILE: dwFormat = PLA_BIN_CIRC_FILE; break;
            case PLA_SEQ_TRACE_FILE:  dwFormat = PLA_BIN_FILE; break;
            }
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogFileType, &dwFormat );
        }else{
            PlaiReadRegistryDwordValue( hkeyQuery, szLogFileType, &dwFormat );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_DATASTORE ){
            if( PLA_SQL_LOG == dwFormat ){
                pInfo->dwDatastoreAttributes = (pInfo->dwDatastoreAttributes & 0xFFFFFF00) | 
                                                PLA_DATASTORE_APPEND | PLA_DATASTORE_SIZE_ONE_RECORD;
            }else{
                if( ! (pInfo->dwDatastoreAttributes & PLA_DATASTORE_APPEND_MASK ) ){
                    if( dwFormat == PLA_BIN_FILE ){
                        dwDatastoreAttributes |= PLA_DATASTORE_APPEND;  
                    }else{
                        dwDatastoreAttributes |= PLA_DATASTORE_OVERWRITE;  
                    }
                }
                if( ! (pInfo->dwDatastoreAttributes & PLA_DATASTORE_SIZE_MASK ) ){
                    dwDatastoreAttributes |= PLA_DATASTORE_SIZE_KB;
                }
            }
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &pInfo->dwDatastoreAttributes );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_MAXLOGSIZE ){
            DWORD dwMaxSize = pInfo->dwMaxLogSize;
            PlaiReadRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &dwDatastoreAttributes );
            if( (dwDatastoreAttributes & PLA_DATASTORE_SIZE_MASK) == PLA_DATASTORE_SIZE_KB ){
                dwMaxSize *= 1024;
            }
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogMaxSize, &dwMaxSize );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_INTERVAL ){
            pdhStatus = PlaiWriteRegistryPlaTime( hkeyQuery, szSampleInterval, &pInfo->Perf.ptSampleInterval );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_COUNTERS ){
            pdhStatus = PlaiSetItemList( hkeyQuery, &pInfo->Perf.piCounterList );
        }
        break;

    case PLA_ALERT:
        break;
    }

    if( (pInfo->dwMask & PLA_INFO_FLAG_BEGIN) || (pInfo->dwMask & PLA_INFO_FLAG_END) ){
        PDH_TIME_INFO info;
        ZeroMemory( &info, sizeof(PDH_TIME_INFO) );

        if(pInfo->dwMask & PLA_INFO_FLAG_BEGIN){
            info.StartTime = pInfo->ptLogBeginTime.llDateTime;
        }

        if(pInfo->dwMask & PLA_INFO_FLAG_END){
            info.EndTime = pInfo->ptLogEndTime.llDateTime;
        }

        pdhStatus = PlaiSchedule( 
                strComputer, 
                hkeyQuery,
                PLA_AUTO_MODE_AT, 
                &info 
            );
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhPlaSetInfoA(
    LPSTR /*strName*/,
    LPSTR /*strComputer*/,
    PPDH_PLA_INFO_A /*pInfo*/
)
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaSetInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
)
{
    PDH_STATUS pdhStatus;
    PDH_STATUS pdhWarning = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;
    VALIDATE_QUERY( strName );
    
    if( NULL == pInfo ){
        return PDH_INVALID_ARGUMENT;
    }

    pdhStatus = PdhPlaValidateInfoW( strName, strComputer, pInfo );
    switch( SEVERITY(pdhStatus) ){
    case STATUS_SEVERITY_ERROR:
        goto cleanup;
    case STATUS_SEVERITY_WARNING:
        pdhWarning = pdhStatus;
        pdhStatus = ERROR_SUCCESS;
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_USER ){
        pdhStatus = PdhPlaSetRunAs( strName, strComputer, pInfo->strUser, pInfo->strPassword );
    }
    CHECK_STATUS(pdhStatus);
    
    pdhStatus = PlaiConnectAndLockQuery( strComputer, strName, hkeyQuery );
    
    if( ERROR_SUCCESS == pdhStatus ){
        
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PlaiSetInfo( strComputer, hkeyQuery, pInfo );
        }
    
        PlaiWriteRegistryLastModified ( hkeyQuery );
        RELEASE_MUTEX(hPdhPlaMutex);

        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PlaiSynchronize( strComputer );
            if( ERROR_SUCCESS == pdhStatus && (pInfo->dwMask & PLA_INFO_FLAG_BEGIN) ){

                PlaiUpdateServiceMode( strComputer );
            }

        }
    }

cleanup:
    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = pdhWarning;
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaValidateInfo

    Checks the PDH_PLA_INFO structure for valid fields.  Only checks the fields
    specified by the mask.  Returns on first invalid field and set the mask
    to the invalid field

    Arguments:

        LPTSTR  strName 
                Log Name, if NULL checks for valid argument only
        
        LPTSTR  strComputer
                Computer to connect to
        
        PPDH_PLA_INFO pInfo
                Information block

    Return:
        
        PDH_INVALID_ARGUMENT
            One of the fields is invalid.  Specified by the pInfo->dwMask
        
        PDH_LOG_TYPE_NOT_FOUND
            There is a mismatch between log type and specified parameters

        PDH_INVALID_ARGUMENT
            Arguments passed are not valid

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiCheckFile( LPWSTR strFileLocation, BOOL bDirOnly )
{
    DWORD dwFile;
    DWORD dwStatus = ERROR_SUCCESS;
    LPWSTR strFile = NULL;

    if( strFileLocation == NULL ){
        return PDH_INVALID_ARGUMENT;
    }

    dwFile = BYTE_SIZE( strFileLocation );
    strFile = (LPWSTR)G_ALLOC( dwFile+sizeof(WCHAR) );
    if( NULL == strFile ){
        dwStatus = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
    wcscpy( strFile, strFileLocation );

    if( bDirOnly ){
        LPWSTR sz = strFile;
        sz += wcslen( strFile );
        while( sz > strFile ){
            if( *sz == L'\\' ){
                *sz = L'\0';
                break;
            }
            sz--;
        }
    }

    dwFile = GetFileAttributes( strFile );
    
    if( (DWORD)-1 == dwFile ){
        dwStatus = GetLastError();
    }

    if( ERROR_SUCCESS == dwStatus && bDirOnly ){
        if( ! (dwFile & FILE_ATTRIBUTE_DIRECTORY) ){
            dwStatus = ERROR_DIRECTORY;
        }
    }

cleanup:
    G_FREE( strFile );
    
    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PdhPlaValidateInfoA(
        LPSTR /*strName*/,
        LPSTR /*strComputer*/,
        PPDH_PLA_INFO_A /*pInfo*/
    )
{
    return PDH_NOT_IMPLEMENTED;
}

#define VALIDATE_TYPE( type, flag )                 \
if( dwType != PLA_NEW_LOG && dwType != type ){      \
    dwErrorMask |= flag;                            \
    bTypeMismatch = TRUE;                           \
}else{                                              \
    dwType = type;                                  \
}                                                   \


PDH_FUNCTION
PdhPlaValidateInfoW(
        LPWSTR strName,
        LPWSTR strComputer,
        PPDH_PLA_INFO_W pInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwWarningMask = 0;
    DWORD dwErrorMask = 0;
    DWORD dwType = PLA_NEW_LOG;
    DWORD dwFormat = 0;
    PVOID pBuffer = NULL;
    PPDH_PLA_INFO_W pCurrentInfo = NULL;
    BOOL bTypeMismatch = FALSE;

    if( NULL == pInfo ){
        return PDH_INVALID_ARGUMENT;
    }

    if( strName != NULL ){
        DWORD dwInfoSize = 0;
        
        if( wcslen( strName ) > PLA_MAX_COLLECTION_NAME ){
            pdhStatus = PDH_PLA_ERROR_NAME_TOO_LONG;
        }
        CHECK_STATUS(pdhStatus);

        pdhStatus = PdhPlaGetInfoW( strName, strComputer, &dwInfoSize, pCurrentInfo );
        if( ERROR_SUCCESS == pdhStatus ){
            pCurrentInfo = (PPDH_PLA_INFO)G_ALLOC(dwInfoSize);
            if( NULL != pCurrentInfo ){
                pCurrentInfo->dwMask = PLA_INFO_FLAG_ALL;
                pdhStatus = PdhPlaGetInfoW( strName, strComputer, &dwInfoSize, pCurrentInfo );
            
                if( pCurrentInfo->dwMask & PLA_INFO_FLAG_USER ){
                    if( !PlaiIsStringEmpty( pCurrentInfo->strUser ) ){
                        WCHAR buffer[PLA_ACCOUNT_BUFFER];
                        LoadStringW( (HINSTANCE)ThisDLLHandle, IDS_DEFAULT_ACCOUNT, buffer, PLA_ACCOUNT_BUFFER );
                        if( ! (pInfo->dwMask & PLA_INFO_FLAG_USER) && wcscmp( buffer, pCurrentInfo->strUser ) != 0 ){
                            pdhStatus = PDH_ACCESS_DENIED;
                        }
                    }
                }

                if( pCurrentInfo->dwMask & PLA_INFO_FLAG_TYPE ){
                    dwType = pCurrentInfo->dwType;
                }
            }
            CHECK_STATUS(pdhStatus);
        }else{
            // collection does not exist yet
            pdhStatus = ERROR_SUCCESS;
        }
    }
    
    if( pInfo->dwMask & PLA_INFO_FLAG_FORMAT ){
        dwFormat = pInfo->dwFileFormat;
        switch( (pInfo->dwFileFormat&0x0000FFFF) ){
        case PLA_CSV_FILE:
        case PLA_TSV_FILE:
        case PLA_BIN_FILE:
        case PLA_BIN_CIRC_FILE:
        case PLA_CIRC_TRACE_FILE:
        case PLA_SEQ_TRACE_FILE:
        case PLA_SQL_LOG:
            break;
        default:
            dwErrorMask |= PLA_INFO_FLAG_FORMAT;
        }
    }else if( NULL != pCurrentInfo ){
        if( pCurrentInfo->dwMask & PLA_INFO_FLAG_FORMAT ){
            dwFormat = pCurrentInfo->dwFileFormat;
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_TYPE ){
        
        VALIDATE_TYPE( pInfo->dwType, PLA_INFO_FLAG_TYPE );

        switch( pInfo->dwType ){
        case PLA_COUNTER_LOG:
        case PLA_TRACE_LOG:
        case PLA_ALERT:
            break;
        default:
            dwErrorMask |= PLA_INFO_FLAG_TYPE;
        }

        dwType = pInfo->dwType;
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_COUNTERS ){
        PPDH_COUNTER_PATH_ELEMENTS pdhElements = NULL;

        VALIDATE_TYPE( PLA_COUNTER_LOG, PLA_INFO_FLAG_COUNTERS );

        __try {
            LPWSTR strCounter = pInfo->Perf.piCounterList.strCounters;
            DWORD dwCounters = 0;
            if( NULL == strCounter ){
                dwErrorMask |= PLA_INFO_FLAG_COUNTERS;
            }else{
                pBuffer = G_ALLOC(1024);
                pdhElements = (PPDH_COUNTER_PATH_ELEMENTS)pBuffer;

                if( pdhElements == NULL ){
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                CHECK_STATUS(pdhStatus);

                while( *strCounter != L'\0' ){
                    DWORD dwSize = (DWORD)G_SIZE(pBuffer);
                    ZeroMemory( pdhElements, dwSize );
                    pdhStatus = PdhParseCounterPath( strCounter, pdhElements, &dwSize, 0 );
                    switch(pdhStatus){
                    case PDH_MORE_DATA:
                    case PDH_MEMORY_ALLOCATION_FAILURE:
                    case PDH_INSUFFICIENT_BUFFER:
                    case ERROR_SUCCESS:
                        pdhStatus = ERROR_SUCCESS;
                        break;
                    default:
                        pInfo->dwReserved1 = dwCounters;
                        dwErrorMask |= PLA_INFO_FLAG_COUNTERS;
                    }
                    if( ERROR_SUCCESS != pdhStatus ){
                        pdhStatus = ERROR_SUCCESS;
                        break;
                    }
                    dwCounters++;
                    strCounter += (wcslen(strCounter)+1);
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_COUNTERS;
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_PROVIDERS ){

        VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_PROVIDERS );

        __try {
            LPWSTR strProvider = pInfo->Trace.piProviderList.strProviders;
            if( NULL == strProvider ){
                dwErrorMask |= PLA_INFO_FLAG_PROVIDERS;
            }else{
                while( *strProvider != L'\0' ){
                    strProvider += (wcslen(strProvider)+1);
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_PROVIDERS;
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_DEFAULTDIR ){
        __try {
            ULONG dwSize;
            dwSize = wcslen( pInfo->strDefaultDir );
            if( dwSize > MAX_PATH ){
                dwErrorMask |= PLA_INFO_FLAG_DEFAULTDIR;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_DEFAULTDIR;
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_FILENAME ){
        __try {
            ULONG dwSize;
            dwSize = wcslen( pInfo->strBaseFileName );
            if( dwSize > PLA_MAX_COLLECTION_NAME ){
                dwErrorMask |= PLA_INFO_FLAG_FILENAME;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_FILENAME;
        }
    }

    if( pInfo->dwMask & PLA_INFO_CREATE_FILENAME ){
        DWORD dwSize = MAX_PATH;
        WCHAR buffer[MAX_PATH];
        __try {
            DWORD dwOriginalType = 0;
            BOOL bHaveType = (pInfo->dwMask & PLA_INFO_FLAG_TYPE);
            if( ! bHaveType ){
                pInfo->dwMask |= PLA_INFO_FLAG_TYPE;
                dwOriginalType = pInfo->dwType;
                pInfo->dwType = dwType;
            }
            pdhStatus = PdhPlaGetLogFileNameW( strName, strComputer, pInfo, 0, &dwSize, buffer );
            if( !bHaveType ){
                pInfo->dwMask &= ~PLA_INFO_FLAG_TYPE;
                pInfo->dwType = dwOriginalType;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwWarningMask |= PLA_INFO_FLAG_FILENAME;
        }
        switch( pdhStatus ){
        case ERROR_SUCCESS:
            {
                if( PlaiIsLocalComputer( strComputer ) ){
                    if( PLA_SQL_LOG != dwFormat ){
                        pdhStatus = PlaiCheckFile( buffer, TRUE );
                        if( ERROR_SUCCESS != pdhStatus ){
                            dwWarningMask |= PLA_INFO_FLAG_FILENAME;
                            pdhStatus = ERROR_SUCCESS;
                        }
                    }
                }
            }
        case PDH_INVALID_ARGUMENT:
        case PDH_PLA_VALIDATION_ERROR:
        case PDH_INSUFFICIENT_BUFFER:
            pdhStatus = ERROR_SUCCESS;
            break;
        case PDH_PLA_ERROR_FILEPATH:
        default:
            dwErrorMask |= PLA_INFO_FLAG_FILENAME;
            pdhStatus = ERROR_SUCCESS;
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_MODE ){

        VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_MODE );

        switch( pInfo->Trace.dwMode & 0x0000000F ){
        case EVENT_TRACE_FILE_MODE_NONE:
        case EVENT_TRACE_FILE_MODE_SEQUENTIAL:
        case EVENT_TRACE_FILE_MODE_CIRCULAR:
        case EVENT_TRACE_FILE_MODE_NEWFILE:
            break;
        default:
            dwErrorMask = PLA_INFO_FLAG_MODE;
        }
        if( (pInfo->Trace.dwMode & EVENT_TRACE_REAL_TIME_MODE) &&
            (pInfo->Trace.dwMode & EVENT_TRACE_PRIVATE_LOGGER_MODE ) ){

            dwErrorMask |= PLA_INFO_FLAG_MODE;
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_REPEAT ){
        
        LONGLONG llBegin = 0;
        LONGLONG llEnd = 0;
        PPDH_PLA_INFO_W pCheckInfo;
        
        if( pInfo->ptRepeat.dwAutoMode == PLA_AUTO_MODE_CALENDAR ){
            if( pInfo->dwMask & PLA_INFO_FLAG_BEGIN ){
                pCheckInfo = pInfo;
            }else{
                pCheckInfo = pCurrentInfo;
            }

            if( NULL != pCheckInfo ){
                if( pCheckInfo->dwMask & PLA_INFO_FLAG_BEGIN ){
                    if( pCheckInfo->ptLogBeginTime.dwAutoMode != PLA_AUTO_MODE_AT ){
                        dwErrorMask |= PLA_INFO_FLAG_REPEAT;
                    }else{
                        llBegin = pCheckInfo->ptLogBeginTime.llDateTime;
                    }
                }        
            }
            
            if( pInfo->dwMask & PLA_INFO_FLAG_END ){
                pCheckInfo = pInfo;
            }else{
                pCheckInfo = pCurrentInfo;
            }

            if( NULL != pCheckInfo ){
                if( pCheckInfo->dwMask & PLA_INFO_FLAG_END ){
                    if( pCheckInfo->ptLogEndTime.dwAutoMode != PLA_AUTO_MODE_AT ){
                        dwErrorMask |= PLA_INFO_FLAG_REPEAT;
                    }else{
                        llEnd = pCheckInfo->ptLogEndTime.llDateTime;
                    }
                }        
            }
        
            if( 0 == llBegin || 0 == llEnd || ((llEnd - llBegin) >= FILE_TICS_PER_DAY) ){
                dwErrorMask |= PLA_INFO_FLAG_REPEAT;
            }
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_DATASTORE ){
        switch( pInfo->dwDatastoreAttributes & PLA_DATASTORE_APPEND_MASK ){
        case 0:
        case PLA_DATASTORE_APPEND:
            if( (dwType == PLA_TRACE_LOG && dwFormat != PLA_SEQ_TRACE_FILE ) ||
                (dwType == PLA_COUNTER_LOG && dwFormat != PLA_BIN_FILE ) ){
                
                dwErrorMask |= PLA_INFO_FLAG_DATASTORE;
            }
            break;
        case PLA_DATASTORE_OVERWRITE:
            if( dwFormat == PLA_SQL_LOG ){
                dwErrorMask |= PLA_INFO_FLAG_DATASTORE;
            }
            break;
        default:
            dwErrorMask |= PLA_INFO_FLAG_DATASTORE;
        }

        switch( pInfo->dwDatastoreAttributes & PLA_DATASTORE_SIZE_MASK ){
        case 0:
        case PLA_DATASTORE_SIZE_ONE_RECORD:
        case PLA_DATASTORE_SIZE_MB:
        case PLA_DATASTORE_SIZE_KB:
            break;
        default:
            dwErrorMask |= PLA_INFO_FLAG_DATASTORE;
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_SQLNAME ){

        VALIDATE_TYPE( PLA_COUNTER_LOG, PLA_INFO_FLAG_SQLNAME );     

        if( dwFormat != 0 && dwFormat != PLA_SQL_LOG ){
            dwErrorMask |= PLA_INFO_FLAG_SQLNAME;
        }else{
            dwFormat = PLA_SQL_LOG;
        }
        
        __try {
            wcslen( pInfo->strSqlName );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_SQLNAME;
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_LOGGERNAME ){
        
        VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_LOGGERNAME );
        
        __try {
            wcslen( pInfo->Trace.strLoggerName );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_LOGGERNAME;
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_USER ){
        __try {
            wcslen( pInfo->strUser );
            if( NULL != pInfo->strPassword ){
                wcslen( pInfo->strPassword );
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_USER;
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_INTERVAL ){
        LONGLONG llMS;

        VALIDATE_TYPE( PLA_COUNTER_LOG, PLA_INFO_FLAG_INTERVAL );

        pdhStatus = PlaTimeInfoToMilliSeconds (&pInfo->Perf.ptSampleInterval, &llMS );

        // 45 days in milliseconds = 1000*60*60*24*45 = 0xE7BE2C00
        if( (ERROR_SUCCESS != pdhStatus) || (llMS > (0xE7BE2C00)) || (llMS < 1000) ){
            dwErrorMask |= PLA_INFO_FLAG_INTERVAL;
            pdhStatus = ERROR_SUCCESS;
        }
    }
    
    if( pInfo->dwMask & PLA_INFO_FLAG_BUFFERSIZE ){

        VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_BUFFERSIZE );

        if( pInfo->Trace.dwBufferSize < 1 || pInfo->Trace.dwBufferSize > 1024 ){
            dwErrorMask |= PLA_INFO_FLAG_BUFFERSIZE;
        }
    }
    
    if( pInfo->dwMask & PLA_INFO_FLAG_MINBUFFERS ){

        VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_MINBUFFERS );

        if( pInfo->Trace.dwMinimumBuffers < 2 || pInfo->Trace.dwMinimumBuffers > 400 ){
            dwErrorMask |= PLA_INFO_FLAG_MINBUFFERS;
        }
    }
    
    if( pInfo->dwMask & PLA_INFO_FLAG_MAXBUFFERS ){
        
        VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_MAXBUFFERS );

        if( pInfo->Trace.dwMaximumBuffers < 2 || pInfo->Trace.dwMaximumBuffers > 400 ){
            dwErrorMask |= PLA_INFO_FLAG_MAXBUFFERS;
        }
    }
    
    if( pInfo->dwMask & PLA_INFO_FLAG_FLUSHTIMER ){

        VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_FLUSHTIMER );
        
        if( pInfo->Trace.dwFlushTimer < 1 ){
            dwErrorMask |= PLA_INFO_FLAG_FLUSHTIMER;
        }
    }
    
    if( pInfo->dwMask & PLA_INFO_FLAG_MAXLOGSIZE ){
        if( pInfo->dwMaxLogSize != PLA_DISK_MAX_SIZE ){
            if( dwType == PLA_COUNTER_LOG ){
                if( !( pInfo->dwMaxLogSize >= 1 && pInfo->dwMaxLogSize < 0x00000400) ){
                    dwErrorMask = PLA_INFO_FLAG_MAXLOGSIZE;
                }
            }else{
                if( !(pInfo->dwMaxLogSize >=1 && pInfo->dwMaxLogSize < 0xFFFFFFFF) ){
                    dwErrorMask |= PLA_INFO_FLAG_MAXLOGSIZE;
                }
            }      
        }
    }
    
    if( pInfo->dwMask & PLA_INFO_FLAG_AUTOFORMAT ){
        switch( pInfo->dwAutoNameFormat ){
        case PLA_SLF_NAME_NONE:
        case PLA_SLF_NAME_MMDDHH:
        case PLA_SLF_NAME_NNNNNN:
        case PLA_SLF_NAME_YYYYDDD:
        case PLA_SLF_NAME_YYYYMM:
        case PLA_SLF_NAME_YYYYMMDD:
        case PLA_SLF_NAME_YYYYMMDDHH:
        case PLA_SLF_NAME_MMDDHHMM:
            break;
        default:
            dwErrorMask |= PLA_INFO_FLAG_AUTOFORMAT;
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_RUNCOMMAND ){
        __try {
            wcslen( pInfo->strCommandFileName );
            if( NULL == strComputer ){
                if( PLA_SQL_LOG != dwFormat ){
                    pdhStatus = PlaiCheckFile( pInfo->strCommandFileName, FALSE );
                    if( ERROR_SUCCESS != pdhStatus ){
                        dwWarningMask |= PLA_INFO_FLAG_RUNCOMMAND;
                        pdhStatus = ERROR_SUCCESS;
                    }
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask = PLA_INFO_FLAG_RUNCOMMAND;
        }
    }

cleanup:
    G_FREE( pBuffer );
    G_FREE( pCurrentInfo );

    if( 0 != dwWarningMask ){
        pInfo->dwReserved2 = dwWarningMask;
        pdhStatus = PDH_PLA_VALIDATION_WARNING;
    }

    if( 0 != dwErrorMask ){
        pInfo->dwMask = dwErrorMask;
        if( dwErrorMask & PLA_INFO_FLAG_FILENAME ){
            pdhStatus = PDH_PLA_ERROR_FILEPATH;
        }else{
            pdhStatus = PDH_PLA_VALIDATION_ERROR;
        }
    }

    if( TRUE == bTypeMismatch ){
        pdhStatus = PDH_PLA_ERROR_TYPE_MISMATCH;
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhiPlaRunAs
    
    Authenticate as saved user

    Arguments:
        
        LPTSTR  strKey
                Guid string 
        
    Return:
        PDH_INVALID_ARGUMENT
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhiPlaRunAs( 
    LPWSTR strName,
    LPWSTR strComputer,
    HANDLE* hToken
)
{
    PDH_STATUS pdhStatus;
    LPWSTR  strKey = NULL;
    LPWSTR  strRunAs = NULL;
    DWORD   dwKeySize = 0;
    DWORD   dwSize = 0;
    HKEY    hkeyQuery = NULL;
    HANDLE  hUserToken = NULL;
    
    VALIDATE_QUERY( strName );

    if( hToken != NULL ){
        *hToken = NULL;
    }

    pdhStatus = PlaiConnectAndLockQuery( strComputer, strName, hkeyQuery );
        
    if( ERROR_SUCCESS == pdhStatus ){

        pdhStatus = PlaiReadRegistryStringValue( hkeyQuery, szRunAs, 0, &strRunAs, &dwSize );

        if( PDH_PLA_COLLECTION_NOT_FOUND == pdhStatus || PlaiIsStringEmpty(strRunAs) ){
            // The key is missing so return success
            pdhStatus = ERROR_SUCCESS;
            goto cleanup;
        }

        if( ERROR_SUCCESS == pdhStatus ){

            BOOL bResult;

            DATA_BLOB crypt;
            DATA_BLOB data;
            
            LPWSTR strUser = NULL;
            LPWSTR strDomain = NULL;
            LPWSTR strPassword = NULL;
            LPWSTR strScan = strRunAs;

            strUser = strScan;

            while( *strScan != L'\0' ){

                if( *strScan == L'\\' ){
                    *strScan = L'\0';
                    strScan++;
                    strDomain = strUser;
                    strUser = strScan;
                    break;
                }
                
                strScan++;
            }

            pdhStatus = PlaiReadRegistryStringValue( hkeyQuery, szKey, 0, &strKey, &dwKeySize );

            if( ERROR_SUCCESS == pdhStatus && !PlaiIsStringEmpty( strKey ) ){
    
                HANDLE hNetToken = NULL;

                crypt.cbData = dwKeySize;
                crypt.pbData = (BYTE*)strKey;

                bResult= LogonUserW(
                        L"NetworkService",
                        L"NT AUTHORITY",
                        L"",
                        LOGON32_LOGON_SERVICE,
                        LOGON32_PROVIDER_WINNT50,
                        &hNetToken
                    );

                if( bResult == TRUE ){
                    bResult = ImpersonateLoggedOnUser( hNetToken );
                }

                if( bResult != TRUE ){
                    pdhStatus = PlaiErrorToPdhStatus( GetLastError() );
                }

                bResult = CryptUnprotectData( &crypt, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &data );

                if( bResult == FALSE ){
                    pdhStatus = PlaiErrorToPdhStatus( GetLastError() );
                }else{
                    strPassword = (LPWSTR)data.pbData;
                    pdhStatus = ERROR_SUCCESS;
                }

                bResult = RevertToSelf();
                if( NULL != hNetToken ){
                    CloseHandle(hNetToken);
                }
                
            }else{
                strPassword = _T("");
            }

            if( ERROR_SUCCESS == pdhStatus ){

                bResult= LogonUserW(
                        strUser,
                        strDomain,
                        strPassword,
                        LOGON32_LOGON_NETWORK_CLEARTEXT,
                        LOGON32_PROVIDER_DEFAULT,
                        &hUserToken
                    );

                if( bResult == TRUE ){
                    bResult = ImpersonateLoggedOnUser( hUserToken );
                    CloseHandle( hUserToken );

                    if( bResult == TRUE ){
                        bResult= LogonUserW(
                                strUser,
                                strDomain,
                                strPassword,
                                LOGON32_LOGON_INTERACTIVE,
                                LOGON32_PROVIDER_DEFAULT,
                                &hUserToken
                            );

                        if( bResult && hToken != NULL ){
                            *hToken = hUserToken;
                        }
                    }
                }

                if( bResult == FALSE ){
                    pdhStatus = PlaiErrorToPdhStatus( GetLastError() );
                }

                if( NULL != strPassword ){
                    ZeroMemory( data.pbData, data.cbData );
                }

                if( data.pbData ){
                    LocalFree( data.pbData );
                }
            }
        }
    }

cleanup:

    RELEASE_MUTEX(hPdhPlaMutex);
    
    G_FREE( strRunAs );
    G_FREE( strKey );

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaSetRunAs
    
    Set the security for to run as when the log is active

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
        
        LPTSTR  strUser
                User to run as
        
        LPTSTR  strPassword
                Users password

    Return:
        PDH_INVALID_ARGUMENT
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/

BOOL
PlaiIsNetworkService( BOOL bLogon )
{
    //
    // If bLogon is TRUE this function will try to Impersonate the
    // NetworkService if you is not already running that way.
    // RevertToSelf() should be called after you are done being the
    // NetworkService
    //

    DWORD   dwStatus = ERROR_SUCCESS;
    BOOL    bResult;
    HKEY    hkeyQuery = NULL;
    HANDLE  hProcess;
    PSID    NetworkService = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    HANDLE hToken = NULL;
    DWORD  dwSize;
    PTOKEN_OWNER pOwnerInfo = NULL;

    bResult = OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken );

    if( bResult ){

        bResult = GetTokenInformation( hToken, TokenOwner, NULL, 0, &dwSize );
        dwStatus = GetLastError();

        if( ERROR_INSUFFICIENT_BUFFER == dwStatus ){

            pOwnerInfo = (PTOKEN_OWNER)G_ALLOC(dwSize);
            if( NULL == pOwnerInfo ) {
                bResult = FALSE;
                goto cleanup;
            }

            bResult = GetTokenInformation( 
                                hToken, 
                                TokenOwner, 
                                pOwnerInfo, 
                                dwSize, 
                                &dwSize 
                            );

            if( bResult ) {
            
                bResult = AllocateAndInitializeSid(
                                    &NtAuthority,
                                    1,
                                    SECURITY_NETWORK_SERVICE_RID,
                                    0,0,0,0,0,0,0,
                                    &NetworkService
                                );
            }
        }else{
            bResult = FALSE;
            goto cleanup;
        }
    }
    
    if( bResult ){
        bResult = EqualSid( NetworkService, pOwnerInfo->Owner );
    }
    
    if( (!bResult) && bLogon ){
        HANDLE hNetwork = NULL;
 
        bResult= LogonUserW(
                L"NetworkService",
                L"NT AUTHORITY",
                L"",
                LOGON32_LOGON_SERVICE,
                LOGON32_PROVIDER_WINNT50,
                &hNetwork
            );

        if( bResult ){
            bResult = ImpersonateLoggedOnUser( hNetwork );
        }

        if( INVALID_HANDLE_VALUE != hNetwork ){
            CloseHandle( hNetwork );
        }
    }

cleanup:
    G_FREE( pOwnerInfo );

    if( INVALID_HANDLE_VALUE != hToken ){
        CloseHandle( hToken );
    }

    if( NULL != NetworkService){
        FreeSid(NetworkService);
    }

    return bResult;
}

PDH_FUNCTION
PlaiSetRunAs(
    HKEY hkeyQuery,
    LPWSTR strUser,
    LPWSTR strPassword
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    BOOL    bResult = FALSE;
    WCHAR buffer[PLA_ACCOUNT_BUFFER];

    if( LoadStringW( (HINSTANCE)ThisDLLHandle, IDS_DEFAULT_ACCOUNT, buffer, PLA_ACCOUNT_BUFFER ) ){
        bResult = ( wcscmp( buffer, strUser ) == 0 );
    }

    if( strPassword == NULL || bResult ){

        pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szKey, REG_SZ, NULL, 0 );
        if( bResult ){
            pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szRunAs, REG_SZ, NULL, 0 );
        }

    }else{

        DATA_BLOB data;
        DATA_BLOB crypt;
        HANDLE hToken = NULL;

        bResult = PlaiIsNetworkService(TRUE);

        if( bResult != TRUE ){
            pdhStatus = PlaiErrorToPdhStatus( GetLastError() );
        }
        
        if( ERROR_SUCCESS == pdhStatus ){
            
            data.cbData = BYTE_SIZE( strPassword ) + (DWORD)sizeof(UNICODE_NULL);

            data.pbData = (BYTE*)strPassword;

            bResult = CryptProtectData(
                    &data,
                    NULL, NULL, NULL, 0,
                    CRYPTPROTECT_UI_FORBIDDEN,
                    &crypt
                );

            if( bResult == TRUE ){

                DWORD dwStatus = RegSetValueEx( hkeyQuery, szKey, 0, REG_BINARY, crypt.pbData, crypt.cbData );

                pdhStatus = PlaiErrorToPdhStatus( dwStatus );
            
                if( crypt.pbData ){
                    LocalFree(crypt.pbData);
                }

            }else{
                pdhStatus = PlaiErrorToPdhStatus( GetLastError() );
            }

            RevertToSelf();
        }
    }

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szRunAs, REG_SZ, strUser, 0 );
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiPlaSetRunAs(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
)
{
    //
    // Only make this call if you are sure you have no better chance
    // of being logged on as the NetworkService account.  If you are
    // not the NetworkService and can not log on as the NetworkService
    // this call will fail.
    //

    PDH_STATUS pdhStatus;
    HKEY    hkeyQuery = NULL;

    VALIDATE_QUERY( strName );
    pdhStatus = PlaiConnectAndLockQuery( strComputer, strName, hkeyQuery );

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PlaiSetRunAs( hkeyQuery, strUser, strPassword );
        RELEASE_MUTEX(hPdhPlaMutex);
    }        

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }
    
    return pdhStatus;
}

PDH_FUNCTION
PdhPlaSetRunAsA(
    LPSTR /*strName*/,
    LPSTR /*strComputer*/,
    LPSTR /*strUser*/,
    LPSTR /*strPassword*/
)
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaSetRunAsW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    BOOL    bResult;

    VALIDATE_QUERY( strName );

    bResult = PlaiIsNetworkService(TRUE);

    if( bResult ){
        bResult = PlaiIsLocalComputer( strComputer );
    }

    if( bResult ){

        pdhStatus = PdhiPlaSetRunAs( strName, strComputer, strUser, strPassword );

        RevertToSelf();

    }else{
        pdhStatus = PdhPlaWbemSetRunAs( strName, strComputer, strUser, strPassword );
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaEnumCollections
    
    Set the security for to run as when the log is active

    Arguments:
              
        LPTSTR  strComputer
                Computer to connect to
        
        LPDWORD pdwBufferSizer
                [IN] Size of buffer in TCHAR's pointed to by mszCollections.  
                [OUT] Size required or number of characters written.
        
        LPTSTR  mszCollections
                Multistring of the existing collections.

    Return:
         ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhPlaEnumCollectionsA( 
        LPSTR   /*strComputer*/,
        LPDWORD /*pdwBufferSize*/,
        LPSTR   /*mszCollections*/
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaEnumCollectionsW( 
        LPWSTR strComputer,
        LPDWORD pdwBufferSize,
        LPWSTR mszCollections
    )
{
    DWORD dwStatus;
    PDH_STATUS pdhStatus;
    HKEY  hkeyQueries = NULL;
    DWORD dwTotalLength = 0;

    DWORD nCollections = 0;
    DWORD nMaxSubKeyLength = 0;
    DWORD dwSize;
    LPWSTR strCollection;
    LPWSTR str;

    dwStatus = WAIT_FOR_AND_LOCK_MUTEX( hPdhPlaMutex );
    if( dwStatus != ERROR_SUCCESS && dwStatus != WAIT_ABANDONED ){
        return PlaiErrorToPdhStatus( dwStatus );
    }

    pdhStatus = PlaiConnectToRegistry( strComputer, hkeyQueries, TRUE, FALSE );
    CHECK_STATUS( pdhStatus );

    dwStatus = RegQueryInfoKey(
                hkeyQueries,
                NULL,
                NULL,
                NULL,
                &nCollections,
                &nMaxSubKeyLength,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL 
            );
    CHECK_STATUS( dwStatus );

    dwSize = (sizeof(WCHAR)*(nMaxSubKeyLength+1));

    strCollection = (LPWSTR)G_ALLOC( dwSize );

    if( strCollection ){
        
        if( mszCollections != NULL && pdwBufferSize > 0 ){
            ZeroMemory( mszCollections, *pdwBufferSize * sizeof(WCHAR) );
            str = mszCollections;
        }

        for( ULONG i = 0; i<nCollections && ERROR_SUCCESS == dwStatus; i++ ){
            LPWSTR strQueryName = NULL;
            DWORD dwQueryName = 0;

            dwStatus = RegEnumKey( hkeyQueries, i, strCollection, dwSize );
            
            if( ERROR_SUCCESS == dwStatus ){

                HKEY hkeyQuery = NULL;

                dwStatus = RegOpenKeyExW (
                            hkeyQueries,
                            strCollection,
                            0,
                            KEY_READ,
                            &hkeyQuery                            
                        );

                if( ERROR_SUCCESS == dwStatus ){

                    pdhStatus = PlaiReadRegistryStringValue( 
                                hkeyQuery, 
                                szCollection, 
                                READ_REG_MUI, 
                                &strQueryName, 
                                &dwQueryName 
                            );

                    if( pdhStatus == ERROR_SUCCESS && 
                        strQueryName != NULL && 
                        dwQueryName > sizeof(WCHAR) ){

                        dwTotalLength += dwQueryName;
                        if( NULL != mszCollections && dwTotalLength < *pdwBufferSize ){
                            wcscpy( str, strQueryName );
                            str += ( wcslen(str) + 1 );
                        }

                    }else{
                        pdhStatus = ERROR_SUCCESS;
                        dwTotalLength += wcslen( strCollection ) + 1;
                        if( NULL != mszCollections && dwTotalLength < *pdwBufferSize ){
                            wcscpy( str, strCollection );
                            str += ( wcslen(str) + 1 );
                        }
                    }
                    G_FREE( strQueryName );
                }

                if( NULL != hkeyQuery ){
                    RegCloseKey( hkeyQuery );
                }
            }
        }
        
        G_FREE( strCollection );
        if( ERROR_SUCCESS == dwStatus ){
            if( (dwTotalLength + 1) > *pdwBufferSize ){
                pdhStatus = PDH_INSUFFICIENT_BUFFER;
            }
            *pdwBufferSize = dwTotalLength + 1;
        }

    }else{
        dwStatus = ERROR_OUTOFMEMORY;
    }

cleanup:
    RELEASE_MUTEX( hPdhPlaMutex );

    if ( NULL != hkeyQueries ) {
        RegCloseKey ( hkeyQueries );
    }

    if( ERROR_SUCCESS == pdhStatus ){
        return PlaiErrorToPdhStatus( dwStatus );
    }else{
        return pdhStatus;
    }
}

/*****************************************************************************\

    PlaTimeInfoToMilliSeconds
    
    Converts the PLA_TIME_INFO structure to ms in a LONGLONG

    Arguments:
        
        PLA_TIME_INFO* pTimeInfo

        LONGLONG* pllmsecs
              

    Return:
        PDH_INVALID_ARGUMENT
            The pTimeInfo->wDataType is not PLA_TT_DTYPE_UNITS

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaTimeInfoToMilliSeconds (
    PLA_TIME_INFO* pTimeInfo,
    LONGLONG* pllmsecs)
{
    if( PLA_TT_DTYPE_UNITS != pTimeInfo->wDataType ){
        return PDH_INVALID_ARGUMENT;
    }

    switch (pTimeInfo->dwUnitType) {
        case PLA_TT_UTYPE_SECONDS:
            *pllmsecs = pTimeInfo->dwValue;
            break;
        case PLA_TT_UTYPE_MINUTES:
            *pllmsecs = pTimeInfo->dwValue * PLA_SECONDS_IN_MINUTE;
            break;

        case PLA_TT_UTYPE_HOURS:
            *pllmsecs = pTimeInfo->dwValue * PLA_SECONDS_IN_HOUR;
            break;

        case PLA_TT_UTYPE_DAYS:
            *pllmsecs = pTimeInfo->dwValue * PLA_SECONDS_IN_DAY;
            break;

        default:
            *pllmsecs = 0;
    }

    *pllmsecs *= 1000;

    return ERROR_SUCCESS;
}

/*****************************************************************************\

    PdhiPlaFormatBlanks
    
    Replaces blanks with the character specified by:
    
    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SysmonLog\Replace Blanks
    
    Arguments:
        

    Return:
        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhiPlaFormatBlanksA( LPSTR strComputer, LPSTR strFormat )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhiPlaFormatBlanksW( LPWSTR strComputer, LPWSTR strFormat )
{
    HKEY hkey = NULL;
    LPWSTR strScan = strFormat;
    PDH_STATUS pdhStatus;
    LPWSTR strBlank = NULL;
    DWORD dwSize = 0;

    if( PlaiIsStringEmpty( strFormat ) ){
        return ERROR_SUCCESS;
    }
        
    pdhStatus = PlaiConnectToRegistry( strComputer, hkey, FALSE );
    CHECK_STATUS( pdhStatus );

    pdhStatus = PlaiReadRegistryStringValue( 
                    hkey, 
                    L"Replace Blanks", 
                    READ_REG_MUI, 
                    &strBlank, 
                    &dwSize 
                );

    if( ERROR_SUCCESS != pdhStatus || PlaiIsStringEmpty( strBlank ) ){
        pdhStatus = ERROR_SUCCESS;
        goto cleanup;
    }

    __try {
        while( *strScan != L'\0' ){
            if( *strScan == L' ' ){
                *strScan = *strBlank;
            }
            strScan++;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

cleanup:
    if( hkey != NULL ){
        RegCloseKey ( hkey );
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaGetLogFileName
    

    Arguments:
        

    Return:
        PDH_PLA_ERROR_FILEPATH
            Not all needed fields we set in the passed info block
        
        ERROR_INVALID_NAME
            The final path contains invalid characters

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiScanForInvalidChar( LPWSTR strScan )
{
    LPWSTR strCheck = strScan;

    if( PlaiIsStringEmpty( strScan ) ){
        return PDH_INVALID_ARGUMENT;
    }

    if( PlaiIsCharWhitespace( *strCheck ) ){
        return PDH_PLA_ERROR_FILEPATH;
    }

    if( PlaiIsCharWhitespace( strCheck[wcslen(strCheck)-1] ) ){
        return PDH_PLA_ERROR_FILEPATH;
    }

    while( *strCheck != L'\0' ){
        switch( *strCheck ){
        case L'?':
        case L'*':
        case L'|':
        case L'<':
        case L'>':
        case L'/':
        case L'\"':
            return PDH_PLA_ERROR_FILEPATH;
        case L'\\':
            if( strCheck > strScan ){
                if( PlaiIsCharWhitespace( *((WCHAR*)strCheck-1)) ){
                    return PDH_PLA_ERROR_FILEPATH;
                }
            }
        }
        strCheck++;
    }
    
    return ERROR_SUCCESS;
}

long PlaiJulianDate( SYSTEMTIME st )
{
    long day = 0;
    BOOL bLeap = FALSE;
    
    static int cDaysInMonth[] = 
        { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    for( int i = 0; i < st.wMonth - 1 && i<12; i++ ){
        day += cDaysInMonth[i];
    }

    day += st.wDay;

    if( st.wYear % 400 == 0){
        bLeap = TRUE;
    }else if( st.wYear % 100 == 0){
        bLeap = FALSE;
    }else if( st.wYear % 4 ){
        bLeap = TRUE;
    }

    if( st.wMonth > 2 && bLeap ){
        day++;
    }

    return day;
}

PDH_FUNCTION
PlaiGetLogFileName(
    DWORD dwFlags,
    PPDH_PLA_INFO_W pInfo,
    LPDWORD pdwBufferSize,
    LPWSTR strFileName
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwExpanded = 0;
    WCHAR buffer[128];
    LPWSTR strExpand;
    DWORD dwSize;
    DWORD dwSwitch;

    SYSTEMTIME  st;
    GetLocalTime (&st);
    
    LPWSTR strWhack = L"\\";
    LPWSTR strUnder = L"_";
    DWORD dwTotalSize = 0;
    LPWSTR strLocalFileName = NULL;
    LPWSTR strBaseFileName = NULL;
    LPWSTR strDefaultDir = NULL;
    LPWSTR strSQL = L"";
    TCHAR strBuffer[MAX_PATH];
    
    if( pInfo->dwMask & PLA_INFO_FLAG_FILENAME ){
        strBaseFileName = pInfo->strBaseFileName;
    }
    if( pInfo->dwMask & PLA_INFO_FLAG_DEFAULTDIR ){
        strDefaultDir = pInfo->strDefaultDir;
    }

    if( (pInfo->dwMask & PLA_INFO_FLAG_FORMAT) && 
        pInfo->dwFileFormat == PLA_SQL_LOG ){
        
        if( (pInfo->dwMask & PLA_INFO_FLAG_SQLNAME) && 
            ! PlaiIsStringEmpty( pInfo->strSqlName ) ){

            strDefaultDir = pInfo->strSqlName;
        }else{
            strDefaultDir = strBaseFileName;
        }

        strBaseFileName = L"";

        if( ! PlaiIsStringEmpty( strDefaultDir ) ){
            
            BOOL bBang = FALSE;
            BOOL bLogSet = FALSE;

            LPWSTR strLogSet = wcsstr( strDefaultDir, L"!" );
            
            if( ! PlaiIsStringEmpty( strLogSet ) ){
                bBang = TRUE;
                if( wcslen( strLogSet ) > 1 ){
                    bLogSet = TRUE;
                }
            }
            
            if( pInfo->dwAutoNameFormat != PLA_SLF_NAME_NONE ){
                if( !bLogSet ){
                    strUnder = L"";
                }
            }else if( ! bLogSet ){
                pdhStatus = PDH_INVALID_ARGUMENT;
                goto cleanup;
            }

            if( ! bLogSet && ! bBang ){
                strWhack = L"!";
            }else{
                strWhack = L"";
            }

            if( StrCmpNI( strDefaultDir, L"SQL:", 4 ) != 0 ){
                strSQL = L"SQL:";
            }
        }else{
            pdhStatus = PDH_INVALID_ARGUMENT;
            goto cleanup;
        }

    }else{
        WCHAR fname[_MAX_FNAME];
        WCHAR ext[_MAX_EXT];

        if( PlaiIsStringEmpty( strDefaultDir ) ){
            strDefaultDir = L"%SystemDrive%\\PerfLogs";
        }else if( strDefaultDir[wcslen(strDefaultDir)-1] == L'\\' ){
            strWhack = L"";
        }

        if( PlaiIsStringEmpty( strBaseFileName ) ){
            if( (pInfo->dwMask & PLA_INFO_FLAG_AUTOFORMAT) && 
                PLA_SLF_NAME_NONE == pInfo->dwAutoNameFormat ){

                pdhStatus = PDH_INVALID_ARGUMENT;
                goto cleanup;
            }else{
                strBaseFileName = L"";
                strUnder = L"";
            }
        }

        _wsplitpath( strBaseFileName, NULL, NULL, fname, ext );
        
        if( _wcsicmp( ext, L".etl" ) == 0 ||
            _wcsicmp( ext, L".blg" ) == 0 ||
            _wcsicmp( ext, L".csv" ) == 0 ||
            _wcsicmp( ext, L".tsv" ) == 0 ){

            if( wcslen( fname ) < _MAX_PATH ){
                wcscpy( strBuffer, fname );
                strBaseFileName = strBuffer;
            }
        }

    }

    dwTotalSize = 32 * sizeof( WCHAR );  // padding for cnf suffix and sql prefix
    dwTotalSize += BYTE_SIZE( strBaseFileName );
    dwTotalSize += BYTE_SIZE( strDefaultDir );

    strLocalFileName = (LPWSTR)G_ALLOC( dwTotalSize );

    if( NULL == strLocalFileName ){
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto cleanup;
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_AUTOFORMAT ){
        dwSwitch = pInfo->dwAutoNameFormat;
    }else{
        // default
        dwSwitch = PLA_SLF_NAME_NONE;
    }
    
    switch( dwSwitch ){
    case PLA_SLF_NAME_NONE:
        wsprintf( strLocalFileName, L"%s%s%s%s", 
            strSQL, strDefaultDir, strWhack, strBaseFileName ); 
        break;
    case PLA_SLF_NAME_MMDDHH:
        wsprintf( strLocalFileName, L"%s%s%s%s%s%02d%02d%02d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wMonth, st.wDay, st.wHour ); 
        break;
    case PLA_SLF_NAME_NNNNNN:
        wsprintf( strLocalFileName, L"%s%s%s%s%s%06d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, pInfo->dwLogFileSerialNumber );
        break;
    case PLA_SLF_NAME_YYYYDDD:
        wsprintf( strLocalFileName, L"%s%s%s%s%s%04d%03d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wYear, PlaiJulianDate( st ) );
        break;
    case PLA_SLF_NAME_YYYYMM:
        wsprintf( strLocalFileName, L"%s%s%s%s%s%04d%02d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wYear, st.wMonth );
        break;
    case PLA_SLF_NAME_YYYYMMDD:
        wsprintf( strLocalFileName, L"%s%s%s%s%s%04d%02d%02d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wYear, st.wMonth, st.wDay );
        break;
    case PLA_SLF_NAME_YYYYMMDDHH:
        wsprintf( strLocalFileName, L"%s%s%s%s%s%04d%02d%02d%02d",
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wYear, st.wMonth, st.wDay, st.wHour );
        break;
    case PLA_SLF_NAME_MMDDHHMM:
        wsprintf( strLocalFileName, L"%s%s%s%s%s%02d%02d%02d%02d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wMonth, st.wDay, st.wHour, st.wMinute ); 
        break;
    }

    if( (pInfo->dwMask & PLA_INFO_FLAG_CRTNEWFILE) && 
        PLA_AUTO_MODE_NONE != pInfo->ptCreateNewFile.dwAutoMode ){
        
        dwFlags |= PLA_FILENAME_USE_SUBEXT;

        // default the CNF number.
        if ( 0 == pInfo->dwReserved1 ) {
            pInfo->dwReserved1 = 1;
        }
    }

    if( dwFlags & PLA_FILENAME_USE_SUBEXT ){
        if( dwFlags & PLA_FILENAME_GET_SUBFMT ){
            wcscat( strLocalFileName, L"_%03d" );
        }else if( dwFlags & PLA_FILENAME_GET_SUBXXX ){
            wcscat( strLocalFileName, L"_xxx" );
        }else{
            swprintf( buffer, L"_%03d", pInfo->dwReserved1 );
            wcscat( strLocalFileName, buffer );
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_FORMAT ){
        dwSwitch = (pInfo->dwFileFormat & 0x0000FFFF);
    }else{
        dwSwitch = PLA_NUM_FILE_TYPES;
    }
    switch( dwSwitch ){
    case PLA_CSV_FILE:
        wcscat( strLocalFileName, L".csv" );
        break;
    case PLA_TSV_FILE:
        wcscat( strLocalFileName, L".tsv" );
        break;
    case PLA_BIN_FILE:
    case PLA_BIN_CIRC_FILE:
        wcscat( strLocalFileName, L".blg" );
        break;
    case PLA_CIRC_TRACE_FILE:
    case PLA_SEQ_TRACE_FILE:
        wcscat( strLocalFileName, L".etl" );
        break;
    case PLA_SQL_LOG:
        break;
    }

    if( NULL == strFileName ){
        strExpand = buffer;
        dwSize = 128;
        pdhStatus = PDH_INSUFFICIENT_BUFFER;
    }else{
        strExpand = strFileName;
        dwSize = (*pdwBufferSize)/sizeof(WCHAR);
    }
    
    dwExpanded = ExpandEnvironmentStrings( strLocalFileName, strExpand, dwSize );

    if( dwExpanded == 0 ){
        DWORD dwStatus = GetLastError();
        pdhStatus = PlaiErrorToPdhStatus( dwStatus );
    }else{
        dwTotalSize = dwExpanded * sizeof(WCHAR);
        if( NULL != strFileName && *pdwBufferSize < dwTotalSize ){
            pdhStatus = PDH_INSUFFICIENT_BUFFER;
        }else{
            pdhStatus = PlaiScanForInvalidChar( strExpand );
        }
    }

cleanup:

    G_FREE( strLocalFileName );
    *pdwBufferSize = dwTotalSize;
    
    return pdhStatus;
}

PDH_FUNCTION
PdhPlaGetLogFileNameA(
    LPSTR strName,
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo,
    DWORD dwFlags,
    LPDWORD pdwBufferSize,
    LPSTR strFileName
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaGetLogFileNameW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo,
    DWORD dwFlags,
    LPDWORD pdwBufferSize,
    LPWSTR strFileName
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PPDH_PLA_INFO_W pLocalInfo = NULL;
    LPWSTR strFolder = NULL;
    LPWSTR strLocalFileName = NULL;
    DWORD dwSize;

    if( pInfo == NULL ){
        
        DWORD dwInfoSize = 0;
        
        pdhStatus = PdhPlaGetInfoW( strName, strComputer, &dwInfoSize, pLocalInfo );
        CHECK_STATUS(pdhStatus);

        pLocalInfo = (PPDH_PLA_INFO)G_ALLOC(dwInfoSize);
        if( NULL != pLocalInfo ){
            
            ZeroMemory( pLocalInfo, dwInfoSize );

            pLocalInfo->dwMask = PLA_INFO_CREATE_FILENAME;

            pdhStatus = PdhPlaGetInfoW( strName, strComputer, &dwInfoSize, pLocalInfo );
            CHECK_STATUS(pdhStatus);
        }else{
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto cleanup;
        }
    
    
    }else{

        pLocalInfo = (PPDH_PLA_INFO)G_ALLOC(sizeof(PDH_PLA_INFO) );

        if( NULL != pLocalInfo ){
            memcpy( pLocalInfo, pInfo, sizeof(PDH_PLA_INFO) );
        }else{
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto cleanup;
        }
    }

    if( !(pLocalInfo->dwMask & PLA_INFO_FLAG_TYPE) || PLA_ALERT == pLocalInfo->dwType ){

        if( *pdwBufferSize > sizeof(WCHAR) && strFileName != NULL ){
            strFileName[0] = L'\0';
        }
        *pdwBufferSize = sizeof(WCHAR);
        goto cleanup;
    }

    if( ((dwFlags & PLA_FILENAME_CURRENTLOG) ||
        ((pLocalInfo->dwMask & PLA_INFO_FLAG_STATUS) && 
        PLA_QUERY_RUNNING == pLocalInfo->dwStatus)) && 
        !(dwFlags & PLA_FILENAME_CREATEONLY) ){

        if( NULL != strName ){
        
            HKEY    hkeyQuery = NULL;
        
            pdhStatus = PlaiConnectAndLockQuery ( strComputer, strName, hkeyQuery, FALSE );
        
            if( ERROR_SUCCESS == pdhStatus ){
    
                dwSize = 0;
                pdhStatus = PlaiReadRegistryStringValue( hkeyQuery, szCurrentLogFile, 0, &strLocalFileName, &dwSize );
                
                RELEASE_MUTEX(hPdhPlaMutex);
                
                if( NULL != hkeyQuery ){
                    RegCloseKey( hkeyQuery );
                }
            
                if( pdhStatus == ERROR_SUCCESS ){
                    if( strFileName != NULL && *pdwBufferSize >= dwSize ){
                        wcscpy( strFileName, strLocalFileName );
                    }else{
                        if( NULL != strFileName ){
                            pdhStatus = PDH_INSUFFICIENT_BUFFER;
                        }
                    }
                    *pdwBufferSize = dwSize;
                    goto cleanup;
                }
            }
        }
    }

    if( !(pLocalInfo->dwMask & PLA_INFO_FLAG_DEFAULTDIR) || 
        PlaiIsStringEmpty( pLocalInfo->strDefaultDir ) ){
        
        HKEY hkeyLogs = NULL;
            
        pdhStatus = PlaiConnectToRegistry( strComputer, hkeyLogs, FALSE );
        CHECK_STATUS( pdhStatus );

        dwSize = 0;
        pdhStatus = PlaiReadRegistryStringValue( 
                        hkeyLogs, 
                        L"DefaultLogFileFolder", 
                        READ_REG_MUI, 
                        &strFolder, 
                        &dwSize 
                    );
        if( hkeyLogs != NULL ){
            RegCloseKey ( hkeyLogs );
        }
        CHECK_STATUS(pdhStatus);

        pLocalInfo->strDefaultDir = strFolder;
        pLocalInfo->dwMask |= PLA_INFO_FLAG_DEFAULTDIR;
    }    

    pdhStatus = PlaiGetLogFileName( dwFlags, pLocalInfo, pdwBufferSize, strFileName );
    
    if(ERROR_SUCCESS == pdhStatus){ 
        pdhStatus = PdhiPlaFormatBlanksW( strComputer, strFileName );
    }

cleanup:
   
    G_FREE( pLocalInfo );
    G_FREE( strFolder );
    G_FREE( strLocalFileName );

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhui\browsdlg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    browsdlg.h

Abstract:

    data types and definitions used by counter browser dialog functions

--*/
#ifndef _BROWSDLG_H_
#define _BROWSDLG_H_

typedef struct _PDHI_BROWSE_DLG_INFO {
    PPDH_BROWSE_DLG_CONFIG_W    pWideStruct;
    PPDH_BROWSE_DLG_CONFIG_A    pAnsiStruct;
    HLOG                        hDataSource;
} PDHI_BROWSE_DLG_INFO, *PPDHI_BROWSE_DLG_INFO;

typedef struct _PDHI_BROWSE_DIALOG_DATA {
    PPDHI_BROWSE_DLG_INFO pDlgData;
    WCHAR   szLastMachineName[MAX_PATH];
    BOOL    bShowIndex;
    BOOL    bWildCardInstances;
    BOOL    bSelectAllInstances;
    BOOL    bSelectAllCounters;
    BOOL    bIncludeMachineInPath;
    BOOL    bLocalCountersOnly;
    BOOL    bSelectMultipleCounters;
    BOOL    bAddMultipleCounters;
    BOOL    bHideDetailLevel;
    BOOL    bInitializePath;
    BOOL    bDisableMachineSelection;
    BOOL    bIncludeCostlyObjects;
    BOOL    bShowObjects;
    WPARAM  wpLastMachineSel;
    DWORD   dwCurrentDetailLevel;
} PDHI_BROWSE_DIALOG_DATA, *PPDHI_BROWSE_DIALOG_DATA;

typedef struct _PDHI_DETAIL_INFO {
    DWORD   dwLevelValue;
    DWORD   dwStringResourceId;
} PDHI_DETAIL_INFO, FAR * LPPDHI_DETAIL_INFO;

INT_PTR
CALLBACK
BrowseCounterDlgProc (
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

#endif // _BROWSDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhui\browsdlg.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    browsdlg.c

Abstract:

    counter name browsing dialog box functions

Revision History

    Bob Watson (a-robw) Oct-95  Created

--*/
#include <windows.h>
#include <winperf.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include "mbctype.h"
#include "pdhidef.h"
#include "pdhdlgs.h"
#include "pdh.h"
#include "browsdlg.h"
#include "resource.h"
#include "expldlg.h"
#include "pdhui.h"

#pragma warning ( disable : 4213)

//
//  Constants used in this module
//
#define MACHINE_LIST_SIZE   1024
#define OBJECT_LIST_SIZE    4096
#define COUNTER_LIST_SIZE   8192
#define INSTANCE_LIST_SIZE  8192

// global data strings to load into combo box to select counter filtering level

ULONG
PdhiBrowseraulControlIdToHelpIdMap[] =
{
    IDC_USE_LOCAL_MACHINE,      IDH_USE_LOCAL_MACHINE,
    IDC_SELECT_MACHINE,         IDH_SELECT_MACHINE,
    IDC_MACHINE_COMBO,          IDH_MACHINE_COMBO,
    IDC_COUNTER_DETAIL_COMBO,   IDH_COUNTER_DETAIL_COMBO,
    IDC_OBJECT_COMBO,           IDH_OBJECT_COMBO,
    IDC_ALL_COUNTERS,           IDH_ALL_COUNTERS,
    IDC_USE_COUNTER_LIST,       IDH_USE_COUNTER_LIST,
    IDC_COUNTER_LIST,           IDH_COUNTER_LIST,
    IDC_ALL_INSTANCES,          IDH_ALL_INSTANCES,
    IDC_USE_INSTANCE_LIST,      IDH_USE_INSTANCE_LIST,
    IDC_INSTANCE_LIST,          IDH_INSTANCE_LIST,
    IDC_EXPLAIN_BTN,            IDH_EXPLAIN_BTN,
    IDC_OBJECT_LIST,            IDH_OBJECT_LIST,
    0,0
};

PDHI_DETAIL_INFO PdhiDetailInfo[] = {
    {PERF_DETAIL_NOVICE,    IDS_DETAIL_NOVICE},
    {PERF_DETAIL_ADVANCED,  IDS_DETAIL_ADVANCED},
    {PERF_DETAIL_EXPERT,    IDS_DETAIL_EXPERT},
    {PERF_DETAIL_WIZARD,    IDS_DETAIL_WIZARD},
    {0,0}
};

static  HWND    hExplainDlg = NULL;

static  DWORD   dwCounterListSize;
static  DWORD   dwInstanceListSize;

//
//  Function references
//
STATIC_BOOL
PdhiLoadMachineObjects (
    IN  HWND    hDlg,
    IN  BOOL    bRefresh
);

STATIC_BOOL
PdhiLoadCountersAndInstances (
    IN  HWND    hDlg
);

STATIC_BOOL
PdhiBrowseCtrDlg_MACHINE_BUTTON (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiLoadNewMachine (
    IN  HWND    hDlg,
    IN  LPCWSTR szNewMachineName
    );

STATIC_DWORD
PdhiLoadDetailLevelCombo (
    IN  HWND    hDlg,
    IN  DWORD   dwInitialLevel
);

STATIC_BOOL
PdhiSelectItemsInPath (
    IN  HWND    hDlg
);

STATIC_BOOL
PdhiLoadKnownMachines (
    IN  HWND    hDlg
);

STATIC_PDH_FUNCTION
PdhiCompileSelectedCountersT (
    IN  HWND    hDlg,
    IN  LPVOID  pUsersPathBuffer,
    IN  DWORD   cchUsersPathLength,
    IN  BOOL    bUnicode
);

STATIC_PDH_FUNCTION
PdhiCompileSelectedCountersW (
    IN  HWND    hDlg,
    IN  LPWSTR  szUsersPathBuffer,
    IN  DWORD   cchUsersPathLength
);

STATIC_PDH_FUNCTION
PdhiCompileSelectedCountersA (
    IN  HWND    hDlg,
    IN  LPSTR   szUsersPathBuffer,
    IN  DWORD   cchUsersPathLength
);

STATIC_PDH_FUNCTION
PdhiCompileSelectedObjectsT (
    IN  HWND    hDlg,
    IN  LPVOID  pUsersPathBuffer,
    IN  DWORD   cchUsersPathLength,
    IN  BOOL    bUnicode
);

STATIC_PDH_FUNCTION
PdhiCompileSelectedObjectsW (
    IN  HWND    hDlg,
    IN  LPWSTR  szUsersPathBuffer,
    IN  DWORD   cchUsersPathLength
);

STATIC_PDH_FUNCTION
PdhiCompileSelectedObjectsA (
    IN  HWND    hDlg,
    IN  LPSTR   szUsersPathBuffer,
    IN  DWORD   cchUsersPathLength
);

STATIC_BOOL
PdhiBrowseCtrDlg_MACHINE_COMBO (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiBrowseCtrDlg_OBJECT_COMBO (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiBrowseCtrDlg_COUNTER_LIST (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiBrowseCtrDlg_OBJECT_LIST (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiBrowseCtrDlg_DETAIL_COMBO (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiBrowseCtrDlg_INSTANCE_BUTTON (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiBrowseCtrDlg_COUNTER_BUTTON (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiBrowseCtrDlg_OK (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiBrowseCtrDlg_CANCEL (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiBrowseCtrDlg_EXPLAIN_BTN (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiBrowseCtrDlg_HELP_BTN (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
);

STATIC_BOOL
PdhiBrowseCtrDlg_WM_INITDIALOG (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

STATIC_BOOL
PdhiBrowseCtrDlg_WM_COMPAREITEM (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

STATIC_BOOL
PdhiBrowseCtrDlg_WM_COMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

STATIC_BOOL
PdhiBrowseCtrDlg_WM_SYSCOMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

STATIC_BOOL
PdhiBrowseCtrDlg_WM_CLOSE (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

STATIC_BOOL
PdhiBrowseCtrDlg_WM_DESTROY (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

__inline
PDH_STATUS
PdhiCopyString(
    LPBYTE  * pszNextString,
    LPWSTR    szWorkBuffer,
    LPDWORD   pdwRemaining,
    BOOL      bUnicode
)
{
    PDH_STATUS pdhStatus    = ERROR_SUCCESS;
    DWORD      dwSize       = 0;
    DWORD      dwRemaining  = * pdwRemaining;
    LPBYTE     szNextString = * pszNextString;

    if (bUnicode) {
        dwSize = lstrlenW(szWorkBuffer);
        if (dwSize < dwRemaining) {
            lstrcpyW ((LPWSTR) szNextString, szWorkBuffer);
            szNextString += dwSize * sizeof(WCHAR);
            * ((LPWSTR) szNextString) = L'\0';
            szNextString += sizeof(WCHAR);
        } else {
            pdhStatus = PDH_MORE_DATA;
        }
        dwSize ++;
    }
    else {
        dwSize    = dwRemaining;
        pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                    szWorkBuffer,
                    (LPSTR) szNextString,
                    & dwSize);
        if (pdhStatus == ERROR_SUCCESS) {
            szNextString = szNextString
                         + sizeof(CHAR) * (lstrlenA((LPSTR) szNextString) + 1);
        }
    }

    if (dwRemaining >= dwSize) {
        dwRemaining -= dwSize;
    } else {
        dwRemaining = 0;
        pdhStatus   = PDH_MORE_DATA;
    }

    * pdwRemaining  = dwRemaining;
    * pszNextString = szNextString;
    return pdhStatus;
}


STATIC_BOOL
PdhiLoadNewMachine (
    IN  HWND    hDlg,
    IN  LPCWSTR szNewMachineName
)
/*++

Routine Description:

    Connects to a new machine and loads the necessary performance data
        from that machine.

Arguments:

    IN  HWND    hDlg
        Handle to dialog box containing the combo & list boxes to fill

    IN  LPCWSTR szNewMachineName
        Machine name to open and obtain data from

Return Value:

    TRUE new machine connected and data loaded

    FALSE unable to connect to machine or obtain performance data from it.


--*/
{
    HWND        hWndMachineCombo;
    PPDHI_BROWSE_DIALOG_DATA    pData;
    LONG        lMatchIndex;
    PDH_STATUS  status;
    int         mbStatus;
    BOOL        bReturn = FALSE;
    DWORD       dwDataSourceType;
    LPWSTR      szMsg;

    // acquire the data block associated with this dialog instance
    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
        // invalid data block, unable to continue
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return FALSE;
    }

    // get window handle of the dialog box
    hWndMachineCombo = GetDlgItem (hDlg, IDC_MACHINE_COMBO);

    // not in list so try to add it as long as the data source
    // is "Current Activity" (ie. == NULL)  For Log Files, only
    // the machines listed may be selected.
    dwDataSourceType = DataSourceTypeH(pData->pDlgData->hDataSource);
    if (dwDataSourceType != DATA_SOURCE_LOGFILE) {
        status = PdhConnectMachineW (szNewMachineName);

        if (status == ERROR_SUCCESS) {
            // if successful, add string to combo box
            lMatchIndex = (LONG)SendMessageW (hWndMachineCombo, CB_ADDSTRING,
                0, (LPARAM)szNewMachineName);
            SendMessageW (hWndMachineCombo, CB_SETCURSEL,
                (WPARAM)lMatchIndex, 0);
            // update other controls in this dialog
            PdhiLoadMachineObjects (hDlg, FALSE);   // no need to update since it was just connected
            PdhiLoadCountersAndInstances (hDlg);
            SendMessageW (hDlg, WM_COMMAND,
                MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                (LPARAM)GetDlgItem(hDlg, IDC_COUNTER_LIST));

            bReturn = TRUE;
        } else {
            szMsg = GetStringResource (IDS_ERR_UNABLE_TO_CONNECT);
            if (szMsg != NULL) {
                mbStatus = MessageBoxW (hDlg, szMsg, NULL,
                    MB_ICONEXCLAMATION | MB_TASKMODAL | MB_OK);
                if (mbStatus == IDCANCEL) {
                    SetFocus(GetDlgItem(hDlg, IDC_MACHINE_COMBO));
                } else {
                    SendMessageW (hWndMachineCombo, CB_SETCURSEL,
                        pData->wpLastMachineSel, 0);
                }
                G_FREE (szMsg);
            } else {
                MessageBeep (MB_ICONEXCLAMATION);
            }
            bReturn = FALSE;
        }
    } else {
        szMsg = GetStringResource (IDS_ERR_MACHINE_NOT_IN_LOGFILE);
        if (szMsg != NULL) {
            mbStatus = MessageBoxW (hDlg,
                szMsg, NULL,
                MB_ICONEXCLAMATION | MB_TASKMODAL | MB_OK);

            G_FREE (szMsg);
        } else {
            MessageBeep (MB_ICONEXCLAMATION);
        }
        // re-select the last machine

        lMatchIndex = (long)SendMessageW (hWndMachineCombo,
            CB_FINDSTRINGEXACT,(WPARAM)-1,
            (LPARAM)pData->szLastMachineName);
        SendMessageW (hWndMachineCombo, CB_SETCURSEL,
            (WPARAM)lMatchIndex, 0);
        bReturn = FALSE;
    }

    return bReturn;
}

STATIC_BOOL
PdhiSelectItemsInPath (
    IN  HWND    hDlg
)
/*++

Routine Description:

    Selects the items in the list box based on the counter path
        string in the shared buffer.

Arguments:

    IN  HWND    hDlg
        Handle to the dialog window containing the controls

Return Value:

    TRUE if successful,
    FALSE if not

--*/
{
    // regular stack variables
    PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElementsW;
    PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElementsA;
    PDH_STATUS          status;
    PPDHI_BROWSE_DIALOG_DATA    pData;
    BOOL                bReturn = FALSE;
    DWORD               dwBufferSize;
    HWND                hWndMachineCombo;
    HWND                hWndObjectCombo;
    HWND                hWndCounterList;
    HWND                hWndInstanceList;
    LONG                lIndex;
    WCHAR               wszMachineName[MAX_PATH];

    // reset the last error value
    SetLastError (ERROR_SUCCESS);

    // get this dialog's user data
    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);

    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return bReturn;
    }

    hWndMachineCombo = GetDlgItem (hDlg, IDC_MACHINE_COMBO);
    hWndObjectCombo = GetDlgItem (hDlg, IDC_OBJECT_COMBO);
    hWndCounterList = GetDlgItem (hDlg, IDC_COUNTER_LIST);
    hWndInstanceList = GetDlgItem (hDlg, IDC_INSTANCE_LIST);

    // Call the right conversion function based on user's buffer

    if (pData->pDlgData->pWideStruct != NULL) {
        // UNICODE/ wide characters
        dwBufferSize = MAX_PATH * 2 * sizeof (WCHAR);
        pCounterPathElementsW = (PDH_COUNTER_PATH_ELEMENTS_W *)
            G_ALLOC(dwBufferSize);

        if (pCounterPathElementsW == NULL) {
            SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
            return bReturn;
        }
        status = PdhParseCounterPathW (
            pData->pDlgData->pWideStruct->szReturnPathBuffer,
            pCounterPathElementsW,
            &dwBufferSize,
            0);

        if (status == ERROR_SUCCESS) {
            // select entry in each list box
            // select machine entry. Load machine if necessary

            lIndex = (LONG)SendMessageW (hWndMachineCombo, CB_FINDSTRINGEXACT,
                (WPARAM)-1, (LPARAM)pCounterPathElementsW->szMachineName);
            if (lIndex == CB_ERR) {
                // try adding the machine
                if (!PdhiLoadNewMachine (hDlg, pCounterPathElementsW->szMachineName)) {
                    // give up
                    bReturn = FALSE;
                } else {
                    // the correct machine has been selected
                }
            } else {
                // the machine has been found so select it
                SendMessageW (hWndMachineCombo, CB_SETCURSEL,
                    (WPARAM)lIndex, 0);
                // update other fields
                PdhiLoadMachineObjects (hDlg, FALSE);   // no need to update since it was just connected
            }

            // select the current object
            lIndex = (LONG)SendMessageW (hWndObjectCombo, CB_FINDSTRING,
                (WPARAM)-1, (LPARAM)pCounterPathElementsW->szObjectName);
            if (lIndex != CB_ERR) {
                SendMessageW (hWndObjectCombo, CB_SETCURSEL,
                    (WPARAM)lIndex, 0);
                // update the counters for this object
                PdhiLoadCountersAndInstances (hDlg);
                // now select the counter
                lIndex = (LONG)SendMessageW (hWndCounterList, LB_FINDSTRING,
                    (WPARAM)-1, (LPARAM)pCounterPathElementsW->szCounterName);
                if (lIndex != LB_ERR) {
                    if (pData->bSelectMultipleCounters) {
                        SendMessageW (hWndCounterList, LB_SETSEL, FALSE, (LPARAM)-1);
                        SendMessageW (hWndCounterList, LB_SETSEL, TRUE, lIndex);
                        SendMessageW (hWndCounterList, LB_SETCARETINDEX,
                            (WPARAM)lIndex, MAKELPARAM(FALSE, 0));
                    } else {
                        SendMessageW (hWndCounterList, LB_SETCURSEL, lIndex, 0);
                    }
                    // display explain text if necessary
                    SendMessageW (hDlg, WM_COMMAND,
                        MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                        (LPARAM)GetDlgItem(hDlg, IDC_COUNTER_LIST));

                    bReturn = TRUE;
                } else {
                    // unable to locate counter
                    bReturn = FALSE;
                }
            } else {
                // unable to locate the selected object
                bReturn = FALSE;
            }
        } // else unable to read path so exit

        G_FREE (pCounterPathElementsW);
    } else {
        // ANSI characters

        dwBufferSize = MAX_PATH * 2 * sizeof (CHAR);
        pCounterPathElementsA = (PDH_COUNTER_PATH_ELEMENTS_A *)G_ALLOC(
            dwBufferSize);

        if (pCounterPathElementsA == NULL) {
            SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
            return bReturn;
        }
        status = PdhParseCounterPathA (
            pData->pDlgData->pAnsiStruct->szReturnPathBuffer,
            pCounterPathElementsA,
            &dwBufferSize,
            0);

        if (status == ERROR_SUCCESS) {
            // select entry in each list box
            // select machine entry. Load machine if necessary

            lIndex = (LONG)SendMessageA (hWndMachineCombo, CB_FINDSTRINGEXACT,
                (WPARAM)-1, (LPARAM)pCounterPathElementsA->szMachineName);
            if (lIndex == CB_ERR) {
                // try adding the machine
                // convert ansi buffer to wide char first
                MultiByteToWideChar(_getmbcp(),
                                    0,
                                    pCounterPathElementsA->szMachineName,
                                    lstrlenA(pCounterPathElementsA->szMachineName),
                                    wszMachineName,
                                    MAX_PATH);
                if (!PdhiLoadNewMachine (hDlg, wszMachineName)) {
                    // give up
                    bReturn = FALSE;
                } else {
                    // the correct machine has been selected
                }
            } else {
                // the machine has been found so select it
                SendMessageA (hWndMachineCombo, CB_SETCURSEL,
                    (WPARAM)lIndex, 0);
                // update other fields
                PdhiLoadMachineObjects (hDlg, FALSE);   // no need to update since it was just connected
            }

            // select the current object
            lIndex = (LONG)SendMessageA (hWndObjectCombo, CB_FINDSTRING,
                (WPARAM)-1, (LPARAM)pCounterPathElementsA->szObjectName);
            if (lIndex != CB_ERR) {
                SendMessageA (hWndObjectCombo, CB_SETCURSEL,
                    (WPARAM)lIndex, 0);
                // update the counters for this object
                PdhiLoadCountersAndInstances (hDlg);
                // now select the counter
                lIndex = (LONG)SendMessageA (hWndCounterList, LB_FINDSTRING,
                    (WPARAM)-1, (LPARAM)pCounterPathElementsA->szCounterName);
                if (lIndex != LB_ERR) {
                    if (pData->bSelectMultipleCounters) {
                        SendMessageA (hWndCounterList, LB_SETSEL, FALSE, (LPARAM)-1);
                        SendMessageA (hWndCounterList, LB_SETSEL, TRUE, lIndex);
                        SendMessageA (hWndCounterList, LB_SETCARETINDEX,
                            (WPARAM)lIndex, MAKELPARAM(FALSE, 0));
                    } else {
                        SendMessageA (hWndCounterList, LB_SETCURSEL, lIndex, 0);
                    }
                    // display explain text if necessary
                    SendMessage (hDlg, WM_COMMAND,
                        MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                        (LPARAM)GetDlgItem(hDlg, IDC_COUNTER_LIST));

                    bReturn = TRUE;
                } else {
                    // unable to locate counter
                    bReturn = FALSE;
                }
            } else {
                // unable to locate the selected object
                bReturn = FALSE;
            }
        } // else unable to read path so exit

        G_FREE (pCounterPathElementsA);
    }

    return bReturn;
}

STATIC_DWORD
PdhiLoadDetailLevelCombo (
    IN  HWND    hDlg,
    IN  DWORD   dwInitialLevel
)
/*++

Routine Description:

    Loads the Detail Level Combo box with the strings and ID's
        defined by the PdhiDetailInfo string array above.

Arguments:

    IN  HWND    hDlg
        Handle to the dialog box containing the combo box

    IN  DWORD   dwInitialLevel
        the intitial detail level to select in the combo box.

Return Value:

    Returns the selected level or 0 if an error ocurred.

--*/
{
    HWND    hWndCombo;
    DWORD   dwIndex;
    DWORD   dwStringLength;
    DWORD   dwDefaultIndex = 0;
    DWORD   dwSelectedLevel = 0;
    DWORD   dwThisCbIndex;

    WCHAR   szTempBuffer[MAX_PATH]; // for loading string resource

    hWndCombo = GetDlgItem (hDlg, IDC_COUNTER_DETAIL_COMBO);

    // load all combo box strings from static data array defined above
    for (dwIndex = 0; PdhiDetailInfo[dwIndex].dwLevelValue > 0; dwIndex++) {
        // load the string resource for this string
        dwStringLength = LoadStringW (ThisDLLHandle,
            PdhiDetailInfo[dwIndex].dwStringResourceId,
            szTempBuffer, MAX_PATH);
        if (dwStringLength == 0) {
            // unable to read the string in, so
            // substitute the value for the string
            _ltow (PdhiDetailInfo[dwIndex].dwLevelValue,
                szTempBuffer, 10);
        }
        // load the strings into the combo box in the same order they
        // were described in the array above
        dwThisCbIndex = (DWORD)SendMessageW (hWndCombo, CB_INSERTSTRING,
            (WPARAM)-1, (LPARAM)szTempBuffer);

        // set the initial CB entry to the highest item <= to the
        // desired default level
        if (dwThisCbIndex != CB_ERR) {
            // set item data to be the corresponding detail level
            SendMessageW (hWndCombo, CB_SETITEMDATA, (WPARAM)dwThisCbIndex,
                (LPARAM)PdhiDetailInfo[dwIndex].dwLevelValue);
            // save default selection if it matches.
            if (PdhiDetailInfo[dwIndex].dwLevelValue <= dwInitialLevel) {
                dwDefaultIndex = dwThisCbIndex;
                dwSelectedLevel = PdhiDetailInfo[dwIndex].dwLevelValue;
            }
        }
    }

    // select desired default entry

    SendMessageW (hWndCombo, CB_SETCURSEL, (WPARAM)dwDefaultIndex, 0);

    return dwSelectedLevel;
}

STATIC_BOOL
PdhiLoadKnownMachines (
    IN  HWND    hDlg
)
/*++

Routine Description:

    Get the list of machines that are currently connected and disply
        them in the machine list box.

Arguments:

    IN  HWND    hDlg
        Handle to the dialog window containing the controls

Return Value:

    TRUE if successful,
    FALSE if not

--*/
{
    // big stack variables
    WCHAR               mszMachineList[MACHINE_LIST_SIZE];

    // regular stack variables
    LPWSTR              szThisMachine;
    DWORD               dwLength;
    PDH_STATUS          status;
    HWND                hMachineListWnd;
    HCURSOR             hOldCursor;
    PPDHI_BROWSE_DIALOG_DATA    pData;
    BOOL                bReturn = FALSE;

    // get this dialog's user data
    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return bReturn;
    }

    // clear the machine list buffer
    memset (&mszMachineList[0], 0, (MACHINE_LIST_SIZE * sizeof (WCHAR)));

    // display wait cursor since this is potentially time consuming
    hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

    // get window handle to Machine list combo box
    hMachineListWnd = GetDlgItem (hDlg, IDC_MACHINE_COMBO);

    // clear machine combo box
    SendMessageW (hMachineListWnd, CB_RESETCONTENT, 0, 0);

    // get list of connected machines from PDH library
    dwLength = MACHINE_LIST_SIZE;
    status = PdhEnumMachinesHW (
        pData->pDlgData->hDataSource,
        &mszMachineList[0],
        &dwLength);

    if (status == ERROR_SUCCESS) {
        // update the combo box
        // go through MSZ and load each string into combo box
        for (szThisMachine = &mszMachineList[0];
            *szThisMachine != 0;
            szThisMachine += lstrlenW(szThisMachine)+1) {
            // add to the list box and let the list box sort them
            SendMessageW (hMachineListWnd, CB_ADDSTRING, 0,
                (LPARAM)szThisMachine);
        }
        // select the first item in the list (as the initial selection)
        SendMessageW (hMachineListWnd, CB_SETCURSEL, 0, 0);

        // the "current" machine has not been defined, then
        // do it now
        GetWindowTextW(hMachineListWnd, (LPWSTR)pData->szLastMachineName,
            MAX_PATH);

        bReturn = TRUE;
    } else {
        // no machines, so select local button and disable the edit window
        CheckRadioButton (hDlg, IDC_USE_LOCAL_MACHINE, IDC_SELECT_MACHINE,
            IDC_USE_LOCAL_MACHINE);
        PdhiBrowseCtrDlg_MACHINE_BUTTON (hDlg, BN_CLICKED,
            GetDlgItem (hDlg, IDC_USE_LOCAL_MACHINE));
        bReturn = TRUE;
    }
    // restore cursor
    SetCursor (hOldCursor);

    // return status of function
    return bReturn;
}

STATIC_BOOL
PdhiLoadMachineObjects (
    IN  HWND    hDlg,
    IN  BOOL    bRefresh
)
/*++

Routine Description:

    For the currently selected machine, load the object list box
        with the objects supported by that machine. If the bRefresh
        flag is TRUE, then query the system for the current perf data
        before loading the list box.

Arguments:

    IN  HWND    hDlg
        Window handle of parent dialog box

    IN  BOOL    bRefresh
        TRUE = Query performance data of system before updating
        FALSE = Use the current system perf data to load the objects from

Return Value:

    TRUE if successful,
    FALSE if not

--*/
{
    // big stack variables
    WCHAR   szMachineName[MAX_PATH];
    WCHAR   szDefaultObject[MAX_PATH];
    LPWSTR  mszObjectList = NULL;

    // regular stack variables
    DWORD   dwObjectListLength = OBJECT_LIST_SIZE;
    DWORD   dwLength;
    LPWSTR  szThisObject;
    HCURSOR hOldCursor;
    HWND    hObjectListWnd;
    PPDHI_BROWSE_DIALOG_DATA    pData;
    PDH_STATUS    pdhStatus;
    DWORD    dwReturn;
    DWORD   dwDetailLevel;
    LPWSTR  szMsg;
    LRESULT nEntry;
    DWORD   dwFlags;

    // get the pointer to the dialog's user data
    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return FALSE;
    }

    mszObjectList = G_ALLOC (dwObjectListLength * sizeof(WCHAR));
    if (mszObjectList == NULL) {
        return FALSE;
    }


    // save old cursor and display wait cursor
    hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

    if (!pData->bShowObjects) {
        // get window handle to combo box control
        hObjectListWnd = GetDlgItem (hDlg, IDC_OBJECT_COMBO);
    } else {
        hObjectListWnd = GetDlgItem (hDlg, IDC_OBJECT_LIST);
    }
    // get current machine name
    GetDlgItemTextW (hDlg, IDC_MACHINE_COMBO, szMachineName, MAX_PATH);
    if (lstrcmpW(szMachineName, pData->szLastMachineName) != 0) {

#ifdef _DEBUG
        // to catch any snafus during debugging & development
        MessageBoxW(hDlg, cszNameDontMatch,
            cszNotice, MB_OK);
#endif
        lstrcpyW (pData->szLastMachineName, szMachineName);
    }

    if (!pData->bShowObjects) {
        // first clear out any old contents
        SendMessageW (hObjectListWnd, CB_RESETCONTENT, 0, 0);
    } else {
        SendMessageW (hObjectListWnd, LB_RESETCONTENT, 0, 0);
    }

    // get object list from the PDH
    dwDetailLevel = pData->dwCurrentDetailLevel;
    dwDetailLevel |= pData->bIncludeCostlyObjects ? PERF_DETAIL_COSTLY : 0;
    dwLength = dwObjectListLength;
    
    pdhStatus = PdhEnumObjectsHW (
        pData->pDlgData->hDataSource,
        szMachineName, mszObjectList, &dwLength,
        dwDetailLevel, bRefresh);
    while (   pdhStatus == PDH_MORE_DATA
           || pdhStatus == PDH_INSUFFICIENT_BUFFER) {
        // then realloc and try again, but only once
        G_FREE (mszObjectList);
        dwObjectListLength = dwLength;
        mszObjectList = G_ALLOC (dwObjectListLength * sizeof(WCHAR));
        if (mszObjectList == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        } else {
            pdhStatus = PdhEnumObjectsHW (
                pData->pDlgData->hDataSource,
                szMachineName, mszObjectList, &dwLength,
                dwDetailLevel, bRefresh);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        EnableWindow (hObjectListWnd, TRUE);
        // load object list to the list (combo) box
        for (szThisObject = &mszObjectList[0];
            *szThisObject != 0;
            szThisObject += lstrlenW(szThisObject) + 1) {
            if (pData->bShowObjects) {
                DWORD dwCounterListLength  = 0;
                DWORD dwInstanceListLength = 0;
                pdhStatus = PdhEnumObjectItemsHW (
                            pData->pDlgData->hDataSource,
                            szMachineName,
                            szThisObject,
                            NULL,
                            & dwCounterListLength,
                            NULL,
                            & dwInstanceListLength,
                            PERF_DETAIL_WIZARD,
                            0);
                if (   pdhStatus != ERROR_SUCCESS
                    && pdhStatus != PDH_MORE_DATA
                    && pdhStatus != PDH_INSUFFICIENT_BUFFER) {
                    dwInstanceListLength = 0;
                }
                if (dwInstanceListLength == 0 || dwInstanceListLength > 2) {
                    // send to list box control
                    nEntry = SendMessageW(hObjectListWnd, LB_ADDSTRING, 0,
                                    (LPARAM) szThisObject);
                    dwFlags = 0;
                    if (dwInstanceListLength > 2) {
                        dwFlags |= PDH_OBJECT_HAS_INSTANCES;
                    }
                    SendMessageW(hObjectListWnd,
                                 LB_SETITEMDATA,
                                 (WPARAM) nEntry,
                                 (LPARAM) dwFlags);                
                }
                pdhStatus = ERROR_SUCCESS;
            } else {
                // send to combo box
                // add each string...
                SendMessageW(hObjectListWnd, CB_ADDSTRING, 0,
                                    (LPARAM)szThisObject);
            }
        }

        if (!pData->bShowObjects) {
            // get default Object
            dwLength = MAX_PATH;
            pdhStatus = PdhGetDefaultPerfObjectHW (
                pData->pDlgData->hDataSource,
                szMachineName,
                szDefaultObject,
                &dwLength);

            if (pdhStatus == ERROR_SUCCESS) {
                // and select it if it's present (which it should be)
                dwReturn = (DWORD)SendMessageW (hObjectListWnd, CB_SELECTSTRING,
                    (WPARAM)-1, (LPARAM)szDefaultObject);
                if (dwReturn == CB_ERR) pdhStatus = PDH_CSTATUS_NO_OBJECT;
            }
            if (pdhStatus != ERROR_SUCCESS) {
                // default object not found in list so select the first one
                SendMessageW (hObjectListWnd, CB_SETCURSEL, 0, 0);
            }
        }
    } else {
        // unable to obtain object list so display message and disable list
        szMsg = GetStringResource (IDS_BRWS_NO_OBJECTS);
        if (szMsg != NULL) {
            if (!pData->bShowObjects) {
                SendMessageW (hObjectListWnd, CB_ADDSTRING, 0, (LPARAM)szMsg);
            } else {
                SendMessageW (hObjectListWnd, LB_ADDSTRING, 0, (LPARAM)szMsg);
            }
            G_FREE (szMsg);
            EnableWindow (hObjectListWnd, FALSE);       
        }
    }

    // restore cursor
    SetCursor (hOldCursor);

    if (mszObjectList != NULL) G_FREE (mszObjectList);
    // return status
    return (pdhStatus == ERROR_SUCCESS) ? (TRUE) : (FALSE);
}

STATIC_BOOL
PdhiLoadCountersAndInstances (
    IN  HWND    hDlg
)
/*++

Routine Description:

    Load the counters and instances of the selected object on the
        current machine

Arguments:

    IN  HWND    hDlg
        Window handle of the dialog box containing these controls

Return Value:

    TRUE if successful,
    FALSE if not

--*/
{
    // big Stack variables
    WCHAR   szMachineName[MAX_PATH];
    WCHAR   szObjectName[MAX_PATH];
    WCHAR   szDefaultCounter[MAX_PATH];
    WCHAR   szInstanceString[MAX_PATH];

    // regular Stack variables
    LPWSTR  szIndexStringPos;
    DWORD   dwCounterLen;
    DWORD   dwDefaultIndex;
    DWORD   dwCounterListLength;
    DWORD   dwInstanceListLength;
    DWORD   dwInstanceMatch;
    DWORD   dwInstanceIndex;
    DWORD   dwInstanceCount;
    LPWSTR  szThisItem;
    HWND    hWndCounterListBox;
    HWND    hWndInstanceListBox;
    HCURSOR hOldCursor;
    PPDHI_BROWSE_DIALOG_DATA    pData;
    PDH_STATUS    pdhStatus;
    LPWSTR  mszCounterList = NULL;
    LPWSTR  mszInstanceList = NULL;
    LPWSTR  mszTmpList;
    LPWSTR  szMsg;
    HDC     hDcListBox;
    SIZE    Size;
    LONG    dwHorizExtent;

    // get the pointer to the dialog's user data
    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return FALSE;
    }

    hWndCounterListBox  = GetDlgItem (hDlg, IDC_COUNTER_LIST);
    hWndInstanceListBox = GetDlgItem (hDlg, IDC_INSTANCE_LIST);
    if (hWndCounterListBox == NULL || hWndInstanceListBox == NULL) {
        SetLastError(PDH_INVALID_HANDLE);
        return FALSE;
    }

    // save current cursor and display wait cursor
    hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

    // get current machine & object name
    GetDlgItemTextW(hDlg, IDC_MACHINE_COMBO, szMachineName, MAX_PATH);
    GetDlgItemTextW(hDlg, IDC_OBJECT_COMBO, szObjectName, MAX_PATH);
#ifdef _DEBUG
    if (lstrcmpW(szMachineName, pData->szLastMachineName) != 0) {
        MessageBoxW(hDlg, cszNameDontMatch,
            cszNotice, MB_OK);
    }
#endif

    // get object list

    mszCounterList = G_ALLOC (dwCounterListSize * sizeof(WCHAR));
    if (mszCounterList != NULL) {
        dwCounterListLength = dwCounterListSize;
    } else {
        return FALSE;
    }

    mszInstanceList = G_ALLOC (dwInstanceListSize * sizeof(WCHAR));
    if (mszInstanceList != NULL) {
        dwInstanceListLength = dwInstanceListSize;
    } else {
        G_FREE (mszCounterList);
        return FALSE;
    }

    pdhStatus = PdhEnumObjectItemsHW(pData->pDlgData->hDataSource,
                                     szMachineName,
                                     szObjectName,
                                     mszCounterList,
                                     & dwCounterListLength,
                                     mszInstanceList,
                                     & dwInstanceListLength,
                                     pData->dwCurrentDetailLevel,
                                     0);
    while (   pdhStatus == PDH_MORE_DATA
           || pdhStatus == PDH_INSUFFICIENT_BUFFER) {

        // enlarge the buffer if necessary
        if (dwCounterListLength > dwCounterListSize) {
            mszTmpList = mszCounterList;
            mszCounterList = G_REALLOC (mszCounterList, (dwCounterListLength * sizeof(WCHAR)));
            if (mszCounterList != NULL) {
                dwCounterListSize = dwCounterListLength;
            } else {
                G_FREE (mszTmpList);
                G_FREE (mszInstanceList);
                return FALSE;
            }
        } else {
            // reset the buffer size values
            dwCounterListLength = dwCounterListSize;
        }


        if (dwInstanceListLength > dwInstanceListSize) {
            mszTmpList = mszInstanceList;
            mszInstanceList = G_REALLOC (mszInstanceList, (dwInstanceListLength * sizeof(WCHAR)));
            if (mszInstanceList != NULL) {
                dwInstanceListSize = dwInstanceListLength;
            } else {
                G_FREE (mszTmpList);
                G_FREE (mszCounterList);
                return FALSE;
            }
        } else {
            // reset the buffer size values
            dwInstanceListLength = dwInstanceListSize;
        }

        // retry the call
        pdhStatus = PdhEnumObjectItemsHW(pData->pDlgData->hDataSource,
                                         szMachineName,
                                         szObjectName,
                                         mszCounterList,
                                         & dwCounterListLength,
                                         mszInstanceList,
                                         & dwInstanceListLength,
                                         pData->dwCurrentDetailLevel,
                                         0);
    }


    if (pdhStatus == ERROR_SUCCESS) {
        //reset contents of both list boxes

        SendMessageW (hWndCounterListBox, LB_RESETCONTENT, 0, 0);
        SendMessageW (hWndInstanceListBox, LB_RESETCONTENT, 0, 0);

        // enable both list boxes

        EnableWindow (hWndInstanceListBox, TRUE);
        EnableWindow (hWndCounterListBox, TRUE);

        // now fill 'em up
        // start with the counters
        hDcListBox = GetDC(hWndCounterListBox);
        if (hDcListBox == NULL)
            return FALSE;

        dwHorizExtent = 0;

        for (szThisItem = mszCounterList;
            *szThisItem != 0;
            szThisItem += lstrlenW(szThisItem) + 1) {

            if (GetTextExtentPoint32W(hDcListBox, szThisItem,
                lstrlenW(szThisItem), &Size)) {
                if (Size.cx > dwHorizExtent) {
                    dwHorizExtent = Size.cx;
                    SendMessageW (hWndCounterListBox, 
                        LB_SETHORIZONTALEXTENT, (WPARAM)dwHorizExtent, 0);
                }
            }
            SendMessageW (hWndCounterListBox, LB_ADDSTRING,
                0, (LPARAM)szThisItem);
        }

        ReleaseDC (hWndCounterListBox, hDcListBox);

        // once the list box has been loaded see if we want to keep it
        // enabled. It's filled regardless just so the user can see some
        // of the entries, even if they have this disabled by the "all"
        // counter button

        if (pData->bSelectAllCounters) {
            // disable instance list
            EnableWindow(hWndCounterListBox, FALSE);
        } else {
            // set the default selection if there are entries in the
            // list box and use the correct message depending on the
            // selection options
            // set the default counter
            dwCounterLen = MAX_PATH;
            pdhStatus = PdhGetDefaultPerfCounterHW (
                pData->pDlgData->hDataSource,
                szMachineName,
                szObjectName,
                szDefaultCounter,
                &dwCounterLen);

            if (pdhStatus != ERROR_SUCCESS) {
                dwDefaultIndex = 0;
            } else {
                dwDefaultIndex = (DWORD)SendMessageW (hWndCounterListBox,
                    LB_FINDSTRINGEXACT,
                    (WPARAM)-1, (LPARAM)szDefaultCounter);
                if (dwDefaultIndex == LB_ERR) dwDefaultIndex = 0;
            }

            if (pData->bSelectMultipleCounters) {
                SendMessageW (hWndCounterListBox, LB_SETSEL, TRUE, dwDefaultIndex);
                SendMessageW (hWndCounterListBox, LB_SETCARETINDEX,
                    (WPARAM)dwDefaultIndex, MAKELPARAM(FALSE, 0));
            } else {
                SendMessageW (hWndCounterListBox, LB_SETCURSEL, dwDefaultIndex, 0);
            }
        }
        // now the instance list
        if (dwInstanceListLength > 0) {
            // there's at least one entry, so prepare the list box
            // enable the list box and the instance radio buttons on the
            //  assumption that they will be used. this is tested later.
            EnableWindow (hWndInstanceListBox, TRUE);
            EnableWindow (GetDlgItem (hDlg, IDC_INSTANCE_CAPTION), TRUE);
            EnableWindow (GetDlgItem (hDlg, IDC_ALL_INSTANCES), TRUE);
            EnableWindow (GetDlgItem (hDlg, IDC_USE_INSTANCE_LIST), TRUE);

            dwInstanceCount = 0;

            // load instance entries
            hDcListBox = GetDC(hWndInstanceListBox);
            if (hDcListBox == NULL)
                return FALSE;
            dwHorizExtent = 0;
            for (szThisItem = mszInstanceList;
                *szThisItem != 0;
                szThisItem += lstrlenW(szThisItem) + 1) {
                // see if the index number should be displayed
                if (pData->bShowIndex) {
                    // if so, it must be derived,
                    // this is accomplished by making an index entry starting
                    // at 1, and looking for a match in the current entries.
                    // if a match is found, then the index is incremented and
                    // the process is repeated until the specified
                    // instance is not found. The first value not found is
                    // then the index entry for that item.
                    //
                    // first see if there's an undecorated one in the list box
                    // if not then add this one
                    lstrcpyW (szInstanceString, szThisItem);
                    dwInstanceMatch = (DWORD)-1;
                    dwInstanceMatch = (DWORD)SendMessageW (
                            hWndInstanceListBox, LB_FINDSTRINGEXACT,
                            (WPARAM)dwInstanceMatch, (LPARAM)szInstanceString);
                    if (dwInstanceMatch == LB_ERR) {
                        // then this is the first one so add it in the 
                        // undecorated form 
                        if (GetTextExtentPoint32W(hDcListBox, szInstanceString,
                            lstrlenW(szThisItem), &Size)) {
                            if (Size.cx > dwHorizExtent) {
                                dwHorizExtent = Size.cx;
                                SendMessageW (hWndInstanceListBox, 
                                    LB_SETHORIZONTALEXTENT, (WPARAM)dwHorizExtent, 0);
                            }
                        }
                        SendMessageW (hWndInstanceListBox, LB_ADDSTRING, 0,
                            (LPARAM)szInstanceString);
                    } else {
                        // there's already a plain one, so increment through
                        // the index values and find one that's not in the
                        // list already

                        dwInstanceIndex = 1;
                        dwInstanceMatch = (DWORD)-1;

                        // find the index of this instance
                        lstrcpyW (szInstanceString, szThisItem);
                        lstrcatW (szInstanceString, cszPoundSign);
                        szIndexStringPos = &szInstanceString[lstrlenW(szInstanceString)];
                        do {
                            _ltow ((long)dwInstanceIndex++, szIndexStringPos, 10);
                            dwInstanceMatch = (DWORD)SendMessageW (
                                hWndInstanceListBox, LB_FINDSTRINGEXACT,
                                (WPARAM)dwInstanceMatch, (LPARAM)szInstanceString);
                        } while (dwInstanceMatch != LB_ERR);
                        // add the last entry checked (the first one not found)
                        // to the list box now.
                        if (GetTextExtentPoint32W(hDcListBox, szInstanceString,
                            lstrlenW(szThisItem), &Size)) {
                            if (Size.cx > dwHorizExtent) {
                                dwHorizExtent = Size.cx;
                                SendMessageW (hWndInstanceListBox, 
                                    LB_SETHORIZONTALEXTENT, (WPARAM)dwHorizExtent, 0);
                            }
                        }
                        SendMessageW (hWndInstanceListBox, LB_ADDSTRING, 0,
                            (LPARAM)szInstanceString);
                    }
                } else {
                    // index values are not required so just add the string
                    // to the list box
                    if (GetTextExtentPoint32W(hDcListBox, szInstanceString,
                        lstrlenW(szThisItem), &Size)) {
                        if (Size.cx > dwHorizExtent) {
                            dwHorizExtent = Size.cx;
                            SendMessageW (hWndInstanceListBox, 
                                LB_SETHORIZONTALEXTENT, (WPARAM)dwHorizExtent, 0);
                        }
                    }
                    SendMessageW (hWndInstanceListBox, LB_ADDSTRING, 0,
                        (LPARAM)szThisItem);
                }
                dwInstanceCount++;
            }

            ReleaseDC (hWndInstanceListBox, hDcListBox);

            if (dwInstanceCount == 0) {
                // disable the OK/Add button, since this object has no
                // current instances to monitor
                EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
                szMsg = GetStringResource (IDS_BRWS_NO_INSTANCES);
                if (szMsg != NULL) {
                    SendMessageW (hWndInstanceListBox, LB_ADDSTRING, 0,
                        (LPARAM)szMsg);
                    G_FREE (szMsg);
                }
                EnableWindow (GetDlgItem (hDlg, IDC_INSTANCE_CAPTION), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_ALL_INSTANCES), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_USE_INSTANCE_LIST), FALSE);
                EnableWindow (hWndInstanceListBox, FALSE);
            } else {
                // enable the OK/Add button since there is some monitorable
                // instance(s)
                EnableWindow (GetDlgItem(hDlg, IDOK), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_INSTANCE_CAPTION), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_ALL_INSTANCES), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_USE_INSTANCE_LIST), TRUE);
                EnableWindow (hWndInstanceListBox, TRUE);
            }
            // once the list box has been loaded see if we want to keep it
            // enabled. It's filled regardless just so the user can see some
            // of the entries, even if they have this disabled by the "all"
            // instance button

            if (pData->bSelectAllInstances) {
                // disable instance list
                EnableWindow(hWndInstanceListBox, FALSE);
            } else {
                // set the default selection if there are entries in the
                // list box and use the correct message depending on the
                // selection options
                if ((dwInstanceCount > 0) &&
                    (SendMessageW (hWndInstanceListBox, LB_GETCOUNT, 0, 0) !=
                    LB_ERR)) {
                    if (pData->bSelectMultipleCounters) {
                        SendMessageW (hWndInstanceListBox, LB_SETSEL, TRUE, 0);
                    } else {
                        SendMessageW (hWndInstanceListBox, LB_SETCURSEL, 0, 0);
                    }
                }
            }
        } else  {
            // there are no instances of this counter so display the
            // string and disable the buttons and the list box
            EnableWindow (hWndInstanceListBox, FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_INSTANCE_CAPTION), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_ALL_INSTANCES), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_USE_INSTANCE_LIST), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDOK), TRUE);
        }
    } else {
        // unable to retrieve the counters and instances so
        // clear and then...
        SendMessageW (hWndCounterListBox, LB_RESETCONTENT, 0, 0);
        SendMessageW (hWndInstanceListBox, LB_RESETCONTENT, 0, 0);
        // disable the windows
        szMsg = GetStringResource (IDS_BRWS_NO_INSTANCES);
        if (szMsg != NULL) {
            SendMessageW (hWndInstanceListBox, LB_ADDSTRING, 0,
                (LPARAM)szMsg);
            G_FREE (szMsg);
        }
        szMsg = GetStringResource (IDS_BRWS_NO_COUNTERS);
        if (szMsg != NULL) {
            SendMessageW (hWndCounterListBox, LB_ADDSTRING, 0,
                (LPARAM)szMsg);
            G_FREE (szMsg);
        }
        EnableWindow (hWndInstanceListBox, FALSE);
        EnableWindow (hWndCounterListBox, FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_ALL_INSTANCES), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_USE_INSTANCE_LIST), FALSE);
        EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
    }

    if (mszCounterList != NULL) G_FREE(mszCounterList);
    if (mszInstanceList != NULL) G_FREE(mszInstanceList);

    // restore the cursor to it's original shape
    SetCursor (hOldCursor);

    // return status
    return TRUE;
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedObjectsT (
    IN  HWND    hDlg,
    IN  LPVOID  pUsersPathBuffer,
    IN  DWORD   cchUsersPathLength,
    IN  BOOL    bUnicode
)
/*++

Routine Description:

    Scans the selected objects, counter, instances and builds a multi-SZ
        string containing the expanded path of all the selections, unless
        the wild card syntax is specified.

Arguments:

    IN  HWND    hDlg
        Window Handle of Dialog containing the controls

    IN  LPVOID  pUsersPathBuffer
        pointer to the caller's buffer that will receive the MSZ string

    IN  DWORD   cchUsersPathLength
        size of caller's buffer in characters

    IN  BOOL    bUnicode
        size of characters to return: TRUE = WCHAR, FALSE = CHAR

Return Value:

    WIN32 Status of function completion
        ERROR_SUCCESS if successful


--*/
{
    // big Stack Variables

    static WCHAR   lszMachineName[MAX_PATH];
    static WCHAR   lszObjectName[MAX_PATH];
    static WCHAR   lszInstanceName[SMALL_BUFFER_SIZE];
    static WCHAR   lszCounterName[SMALL_BUFFER_SIZE];
    static WCHAR   szWorkBuffer[SMALL_BUFFER_SIZE];

    // regular Stack Variables
    LRESULT iNumEntries;
    int     iThisEntry;
    LRESULT iCurSelState;
    LRESULT iTextLen;
    
    LRESULT dwObjectFlags;

    DWORD   dwBufferRemaining;

    DWORD   dwSize1;

    PDH_COUNTER_PATH_ELEMENTS_W lszPath;
    LPVOID  szCounterStart;

    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    PPDHI_BROWSE_DIALOG_DATA    pData;

    // get pointer to dialog user data
    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return PDH_NO_DIALOG_DATA;
    }

    // clear user's string
    if (pUsersPathBuffer != NULL) {
        // clear first four bytes of string
        *((LPDWORD)pUsersPathBuffer) = 0;
        dwBufferRemaining = cchUsersPathLength;
        szCounterStart = pUsersPathBuffer;
    } else {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_INVALID_BUFFER);
#endif
        return PDH_INVALID_BUFFER; // no point in continuing if the caller doesn't have a buffer
    }

    // each counter path string is built by setting the elements of
    // the counter data structure and then calling the MakeCounterPath
    // function to build the string

    // build base string using selected machine & objects from list

    if (pData->bIncludeMachineInPath) {
        lszPath.szMachineName = &lszMachineName[0];
        memset (lszMachineName, 0, sizeof(lszMachineName));
        GetDlgItemTextW (hDlg, IDC_MACHINE_COMBO, lszMachineName, MAX_PATH);
    } else {
        lszPath.szMachineName = NULL;
    }

    // Get number of objects currently listed in the list box

    iNumEntries = SendMessageW(GetDlgItem(hDlg, IDC_OBJECT_LIST), LB_GETCOUNT, 0, 0);
    if (iNumEntries != LB_ERR) {
        // check each one and add selected ones to the list
        lszInstanceName[0] = SPLAT_L;
        lszInstanceName[1] = 0;

        lszCounterName[0] = SPLAT_L;
        lszCounterName[1] = 0;

        lszPath.szCounterName = lszCounterName; // wildcard counter entry
        lszPath.szParentInstance = NULL;        // no parent instances
        lszPath.dwInstanceIndex = ((DWORD)-1);  // no index numbers

        for (iThisEntry = 0; iThisEntry < iNumEntries; iThisEntry++) {
            iCurSelState = SendMessageW(GetDlgItem(hDlg, IDC_OBJECT_LIST),
                LB_GETSEL, (WPARAM)iThisEntry, 0);
            if (iCurSelState > 0) {
                // then get the string and add it to the list
                iTextLen = SendMessageW(GetDlgItem(hDlg, IDC_OBJECT_LIST), 
                    LB_GETTEXTLEN, iThisEntry, 0);
                if ((iTextLen < MAX_PATH) && (iTextLen != LB_ERR)) {
                    // the string and it's null will fit so fetch it
                    iTextLen = SendMessageW(GetDlgItem(hDlg, IDC_OBJECT_LIST), 
                        LB_GETTEXT, iThisEntry, (LPARAM)lszObjectName);
                    dwObjectFlags = SendMessage (GetDlgItem(hDlg, IDC_OBJECT_LIST),
                        LB_GETITEMDATA, (WPARAM)iThisEntry, 0);
                    if (iTextLen != LB_ERR) {
                        // build path elements
                        lszPath.szObjectName = lszObjectName;
                        if (dwObjectFlags & PDH_OBJECT_HAS_INSTANCES) {
                            lszPath.szInstanceName = lszInstanceName;
                        } else {
                            lszPath.szInstanceName = NULL;
                        }
                        dwSize1 = sizeof (szWorkBuffer) / sizeof (WCHAR);
                        pdhStatus = PdhMakeCounterPathW (&lszPath,
                                szWorkBuffer,
                                & dwSize1,
                                0);
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }

                    if (pdhStatus == ERROR_SUCCESS) {
                        // add the string if there's room
                        pdhStatus = PdhiCopyString(& ((LPBYTE) szCounterStart),
                                        szWorkBuffer,
                                        & dwBufferRemaining,
                                        bUnicode);
                    }
                } else {
                    // unable to read the string (to big or List Box error)
                }
            } // else, item isn't selected so skip

        } // end for each item in the list box

        if (bUnicode) {
            *((LPWSTR)szCounterStart)++ = 0; // terminate MSZ
        } else {
            *((LPSTR)szCounterStart)++ = 0; // terminate MSZ
        }
    } else {
        // no items in the list
    }

    return pdhStatus;
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedObjectsW (
    IN  HWND    hDlg,
    IN  LPWSTR  szUsersPathBuffer,
    IN  DWORD   cchUsersPathLength
)
{
    return PdhiCompileSelectedObjectsT (
        hDlg,
        (LPVOID)szUsersPathBuffer,
        cchUsersPathLength,
        TRUE);
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedObjectsA (
    IN  HWND    hDlg,
    IN  LPSTR   szUsersPathBuffer,
    IN  DWORD   cchUsersPathLength
)
{
    return PdhiCompileSelectedObjectsT (
        hDlg,
        (LPVOID)szUsersPathBuffer,
        cchUsersPathLength,
        FALSE);
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedCountersT (
    IN  HWND    hDlg,
    IN  LPVOID  pUsersPathBuffer,
    IN  DWORD   cchUsersPathLength,
    IN  BOOL    bUnicode
)
/*++

Routine Description:

    Scans the selected objects, counter, instances and builds a multi-SZ
        string containing the expanded path of all the selections, unless
        the wild card syntax is specified.

Arguments:

    IN  HWND    hDlg
        Window Handle of Dialog containing the controls

    IN  LPVOID  pUsersPathBuffer
        pointer to the caller's buffer that will receive the MSZ string

    IN  DWORD   cchUsersPathLength
        size of caller's buffer in characters

    IN  BOOL    bUnicode
        size of characters to return: TRUE = WCHAR, FALSE = CHAR

Return Value:

    WIN32 Status of function completion
        ERROR_SUCCESS if successful


--*/
{
    // big Stack Variables

    static WCHAR lszMachineName[MAX_PATH];
    static WCHAR lszObjectName[MAX_PATH];
    static WCHAR lszInstanceName[SMALL_BUFFER_SIZE];
    static WCHAR lszParentInstance[SMALL_BUFFER_SIZE];
    static WCHAR lszCounterName[SMALL_BUFFER_SIZE];
    static WCHAR szWorkBuffer[SMALL_BUFFER_SIZE];

    // regular Stack Variables
    DWORD   dwBufferRemaining;

    DWORD   dwCountCounters;
    DWORD   dwThisCounter;
    DWORD   dwCountInstances;
    DWORD   dwThisInstance;

    DWORD   dwSize1, dwSize2;

    PDH_COUNTER_PATH_ELEMENTS_W lszPath;
    LPVOID  szCounterStart;

    HWND    hWndCounterList;
    HWND    hWndInstanceList;

    BOOL    bSel;

    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    PPDHI_BROWSE_DIALOG_DATA    pData;

    // get pointer to dialog user data
    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return PDH_NO_DIALOG_DATA;
    }

    // clear user's string
    if (pUsersPathBuffer != NULL) {
        // clear first four bytes of string
        *((LPDWORD)pUsersPathBuffer) = 0;
        dwBufferRemaining = cchUsersPathLength;
        szCounterStart = pUsersPathBuffer;
    } else {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_INVALID_BUFFER);
#endif
        return PDH_INVALID_BUFFER; // no point in continuing if the caller doesn't have a buffer
    }

    // each counter path string is built by setting the elements of
    // the counter data structure and then calling the MakeCounterPath
    // function to build the string

    // build base string using selected machine and object

    if (pData->bIncludeMachineInPath) {
        lszPath.szMachineName = &lszMachineName[0];
        memset (lszMachineName, 0, sizeof(lszMachineName));
        GetDlgItemTextW (hDlg, IDC_MACHINE_COMBO, lszMachineName, MAX_PATH);
    } else {
        lszPath.szMachineName = NULL;
    }

    lszPath.szObjectName = &lszObjectName[0];
    memset (lszObjectName, 0, sizeof(lszObjectName));
    GetDlgItemTextW (hDlg, IDC_OBJECT_COMBO, lszObjectName, MAX_PATH);

    hWndCounterList = GetDlgItem (hDlg, IDC_COUNTER_LIST);
    hWndInstanceList = GetDlgItem (hDlg, IDC_INSTANCE_LIST);

    if (pData->bSelectMultipleCounters) {
        if (pData->bWildCardInstances && pData->bSelectAllInstances) {
            if (IsWindowEnabled(GetDlgItem (hDlg, IDC_ALL_INSTANCES))) {
                // then this object has instances and we want ALL of them
                lszPath.szInstanceName = &lszInstanceName[0];
                memset (lszInstanceName, 0, sizeof(lszInstanceName));
                lstrcpyW (lszInstanceName, cszSplat);
                lszPath.szParentInstance = NULL;
                lszPath.dwInstanceIndex = (DWORD)-1;
            } else {
                // this object has no instances
                lszPath.szInstanceName = NULL;
                lszPath.szParentInstance = NULL;
                lszPath.dwInstanceIndex = (DWORD)-1;
            }
            // make a counter path for each selected counter
            dwCountCounters = (DWORD)SendMessageW (hWndCounterList, LB_GETCOUNT, 0, 0);
            if (pData->bSelectAllCounters) {
                lszPath.szCounterName = &lszCounterName[0];
                lstrcpyW (lszPath.szCounterName, cszSplat);
                dwSize1 = sizeof (szWorkBuffer) / sizeof (WCHAR);
                pdhStatus = PdhMakeCounterPathW (&lszPath,
                        szWorkBuffer,
                        &dwSize1,
                        0);

                if (pdhStatus == ERROR_SUCCESS) {
                    // add the string if there's room
                    pdhStatus = PdhiCopyString(& ((LPBYTE) szCounterStart),
                                    szWorkBuffer,
                                    & dwBufferRemaining,
                                    bUnicode);
                }
            } else {
                for (dwThisCounter = 0; dwThisCounter < dwCountCounters; dwThisCounter++) {
                    if (SendMessageW (hWndCounterList, LB_GETSEL, (WPARAM)dwThisCounter, 0)) {
                        lszPath.szCounterName = &lszCounterName[0];
                        memset (lszCounterName, 0, sizeof(lszCounterName));
                        SendMessageW (hWndCounterList, LB_GETTEXT,
                            (WPARAM)dwThisCounter, (LPARAM)lszCounterName);

                        dwSize1 = sizeof (szWorkBuffer) / sizeof (WCHAR);
                        pdhStatus = PdhMakeCounterPathW (&lszPath,
                            szWorkBuffer,
                            &dwSize1,
                            0);

                        if (pdhStatus == ERROR_SUCCESS) {
                            // add the string if there's room
                            pdhStatus = PdhiCopyString(
                                            & ((LPBYTE) szCounterStart),
                                            szWorkBuffer,
                                            & dwBufferRemaining,
                                            bUnicode);
                        } else {
                            // skip this counter since it could not be formed correctly
                            continue;
                        }
                    } // end if this counter was selected
                } // end for each counter in object list box
            } 
        } else {
            // get selected instances from list
            dwCountCounters = (DWORD)SendMessageW (hWndCounterList, LB_GETCOUNT, 0, 0);
            for (dwThisCounter = 0; dwThisCounter < dwCountCounters; dwThisCounter++) {
                bSel = (BOOL) SendMessageW (hWndCounterList, LB_GETSEL, (WPARAM)dwThisCounter, 0);
                if (bSel || pData->bSelectAllCounters ) {
                    lszPath.szCounterName = &lszCounterName[0];
                    memset (lszCounterName, 0, sizeof(lszCounterName));
                    SendMessageW (hWndCounterList, LB_GETTEXT,
                        (WPARAM)dwThisCounter, (LPARAM)lszCounterName);

                    if (IsWindowEnabled(hWndInstanceList) || pData->bSelectAllInstances) {
                        dwCountInstances = (DWORD)SendMessageW (hWndInstanceList,
                            LB_GETCOUNT, 0, 0);
                        for (dwThisInstance = 0; dwThisInstance < dwCountInstances; dwThisInstance++) {
                            if (SendMessageW (hWndInstanceList, LB_GETSEL,
                                (WPARAM)dwThisInstance, 0) || pData->bSelectAllInstances) {
                                lszPath.szInstanceName = &lszInstanceName[0];
                                memset (lszInstanceName, 0, sizeof(lszInstanceName));
                                SendMessageW (hWndInstanceList, LB_GETTEXT,
                                    (WPARAM)dwThisInstance, (LPARAM)lszInstanceName);

                                lszPath.szParentInstance = &lszParentInstance[0];
                                memset (lszParentInstance, 0, sizeof(lszParentInstance));

                                dwSize1 = dwSize2 = MAX_PATH;
                                pdhStatus = PdhParseInstanceNameW (lszInstanceName,
                                    lszInstanceName,
                                    &dwSize1,
                                    lszParentInstance,
                                    &dwSize2,
                                    &lszPath.dwInstanceIndex);

                                if (pdhStatus == ERROR_SUCCESS) {
                                    // parse instance name adds in the default index if one is
                                    // not present. so if it's not wanted, this will remove it
                                    if (!pData->bShowIndex) {
                                        lszPath.dwInstanceIndex = (DWORD)-1;
                                    } else {
                                        // only add in the instance # if it's not 0
                                        if (lszPath.dwInstanceIndex == 0) {
                                            lszPath.dwInstanceIndex = (DWORD)-1;
                                        }
                                    }

                                    if (dwSize1 > 1) {
                                        lszPath.szInstanceName = &lszInstanceName[0];
                                    } else {
                                        lszPath.szInstanceName = NULL;
                                    }
                                    if (dwSize2 > 1) {
                                        lszPath.szParentInstance = &lszParentInstance[0];
                                    } else {
                                        lszPath.szParentInstance = NULL;
                                    }
                                } else {
                                    // ignore the instances
                                    lszPath.szInstanceName = NULL;
                                    lszPath.szParentInstance = NULL;
                                }

                                dwSize1 = sizeof (szWorkBuffer) / sizeof (WCHAR);
                                pdhStatus = PdhMakeCounterPathW (&lszPath,
                                    szWorkBuffer,
                                    &dwSize1,
                                    0);

                                if (pdhStatus == ERROR_SUCCESS) {
                                    pdhStatus = PdhiCopyString(
                                                & ((LPBYTE) szCounterStart),
                                                szWorkBuffer,
                                                & dwBufferRemaining,
                                                bUnicode);
                                } else {
                                    // unable to make counter path so skip
                                }
                            } // end if instance is selected
                        } // end for each instance in list
                    } else {
                        // this counter has no instances so process now
                        lszPath.szInstanceName = NULL;
                        lszPath.szParentInstance = NULL;
                        lszPath.dwInstanceIndex = (DWORD)-1;

                        dwSize1 = sizeof (szWorkBuffer) / sizeof (WCHAR);
                        pdhStatus = PdhMakeCounterPathW (&lszPath,
                                szWorkBuffer,
                                &dwSize1,
                                0);

                        if (pdhStatus == ERROR_SUCCESS) {
                            pdhStatus = PdhiCopyString(
                                            & ((LPBYTE) szCounterStart),
                                            szWorkBuffer,
                                            & dwBufferRemaining,
                                            bUnicode);
                        } else {
                            // unable to create a path so skip and continue
                        }
                    } // end if counter has instances
                } // else counter is not selected
            } // end for each counter in list
        } // end if not wild card instances
        if (bUnicode) {
            *((LPWSTR)szCounterStart)++ = 0; // terminate MSZ
        } else {
            *((LPSTR)szCounterStart)++ = 0; // terminate MSZ
        }
    } else {
        // only single selections are allowed
        if (pData->bWildCardInstances && pData->bSelectAllInstances) {
            lszPath.szInstanceName = &lszInstanceName[0];
            memset (lszInstanceName, 0, sizeof(lszInstanceName));
            lstrcpyW (lszInstanceName, cszSplat);
            lszPath.szParentInstance = NULL;
            lszPath.dwInstanceIndex = (DWORD)-1;

            dwThisCounter = (DWORD)SendMessageW (hWndCounterList, LB_GETCURSEL, 0, 0);
            if (dwThisCounter != LB_ERR) {
                lszPath.szCounterName = &lszCounterName[0];
                memset (lszCounterName, 0, sizeof(lszCounterName));
                SendMessageW (hWndCounterList, LB_GETTEXT,
                    (WPARAM)dwThisCounter, (LPARAM)lszCounterName);


                dwSize1 = sizeof (szWorkBuffer) / sizeof (WCHAR);
                pdhStatus = PdhMakeCounterPathW (&lszPath,
                    szWorkBuffer,
                    &dwSize1,
                    0);

                if (pdhStatus == ERROR_SUCCESS) {
                    pdhStatus = PdhiCopyString(& ((LPBYTE) szCounterStart),
                                    szWorkBuffer,
                                    & dwBufferRemaining,
                                    bUnicode);
                } else {
                    // unable to make counter path so skip
                }
            } //end if counter was found in list box
        } else {
            // get selected instance from list
            dwThisCounter = (DWORD)SendMessageW (hWndCounterList, LB_GETCURSEL, 0, 0);
            if (dwThisCounter != LB_ERR) {
                lszPath.szCounterName = &lszCounterName[0];
                memset (lszCounterName, 0, sizeof(lszCounterName));
                SendMessageW (hWndCounterList, LB_GETTEXT,
                    (WPARAM)dwThisCounter, (LPARAM)lszCounterName);

                if (IsWindowEnabled(hWndInstanceList)) {
                    dwThisInstance = (DWORD)SendMessageW (hWndInstanceList,
                        LB_GETCURSEL, 0, 0);
                    if (dwThisInstance == LB_ERR) {
                        // instance not found so select 0
                        dwThisInstance = 0;
                    }
                    lszPath.szInstanceName = &lszInstanceName[0];
                    memset (lszInstanceName, 0, sizeof(lszInstanceName));
                    SendMessageW (hWndInstanceList, LB_GETTEXT,
                        (WPARAM)dwThisInstance, (LPARAM)lszInstanceName);

                    lszPath.szParentInstance = &lszParentInstance[0];
                    memset (lszParentInstance, 0, sizeof(lszParentInstance));

                    dwSize1 = dwSize2 = MAX_PATH;
                    pdhStatus = PdhParseInstanceNameW (lszInstanceName,
                        lszInstanceName,
                        &dwSize1,
                        lszParentInstance,
                        &dwSize2,
                        &lszPath.dwInstanceIndex);

                    if (pdhStatus == ERROR_SUCCESS ) {
                        // parse instance name adds in the default index of one is
                        // not present. so if it's not wanted, this will remove it
                        if (!pData->bShowIndex) {
                            lszPath.dwInstanceIndex = (DWORD)-1;
                        }
                        // size values include trailing NULL char so
                        // strings must be > 1 char in length to have some
                        // text since a length of 1 would imply only a
                        // NULL character.
                        if (dwSize1 > 1) {
                            lszPath.szInstanceName = &lszInstanceName[0];
                        } else {
                            lszPath.szInstanceName = NULL;
                        }
                        if (dwSize2 > 1) {
                            lszPath.szParentInstance = &lszParentInstance[0];
                        } else {
                            lszPath.szParentInstance = NULL;
                        }
                    } else {
                        // skip this instance
                        lszPath.szParentInstance = NULL;
                        lszPath.szInstanceName = NULL;
                        lszPath.dwInstanceIndex = (DWORD)-1;
                     }
                } else {
                    // this counter has no instances so process now
                    lszPath.szInstanceName = NULL;
                    lszPath.szParentInstance = NULL;
                    lszPath.dwInstanceIndex = (DWORD)-1;
                } // end if counter has instances

                dwSize1 = sizeof (szWorkBuffer) / sizeof (WCHAR);
                pdhStatus = PdhMakeCounterPathW (&lszPath,
                    szWorkBuffer,
                    &dwSize1,
                    0);

                if (pdhStatus == ERROR_SUCCESS) {
                    pdhStatus = PdhiCopyString(& ((LPBYTE) szCounterStart),
                                    szWorkBuffer,
                                    & dwBufferRemaining,
                                    bUnicode);
                } else {
                    // unable to build a counter path so skip
                }
            } // end if counter found
        } // end if not wild card instances
    }
    if (bUnicode) {
        *((LPWSTR)szCounterStart)++ = 0; // terminate MSZ
    } else {
        *((LPSTR)szCounterStart)++ = 0; // terminate MSZ
    }
    return pdhStatus;
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedCountersW (
    IN  HWND    hDlg,
    IN  LPWSTR  szUsersPathBuffer,
    IN  DWORD   cchUsersPathLength
)
/*++

Routine Description:

    UNICODE function wrapper for base function which scans the selected
        objects, counter, instances and builds a multi-SZ string containing
        the expanded path of all the selections, unless the wild card
        syntax is specified.

Arguments:

    IN  HWND    hDlg
        Window Handle of Dialog containing the controls

    IN  LPWSTR  szUsersPathBuffer
        pointer to the caller's buffer that will receive the MSZ
        wide characters string

    IN  DWORD   cchUsersPathLength
        size of caller's buffer in characters

Return Value:

    WIN32 Status of function completion
        ERROR_SUCCESS if successful

--*/
{
    return PdhiCompileSelectedCountersT (
        hDlg,
        (LPVOID)szUsersPathBuffer,
        cchUsersPathLength,
        TRUE);
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedCountersA (
    IN  HWND    hDlg,
    IN  LPSTR   szUsersPathBuffer,
    IN  DWORD   cchUsersPathLength
)
/*++

Routine Description:

    ANSI function wrapper for base function which scans the selected
        objects, counter, instances and builds a multi-SZ string containing
        the expanded path of all the selections, unless the wild card
        syntax is specified.

Arguments:

    IN  HWND    hDlg
        Window Handle of Dialog containing the controls

    IN  LPsSTR  szUsersPathBuffer
        pointer to the caller's buffer that will receive the MSZ
        single-byte characters string

    IN  DWORD   cchUsersPathLength
        size of caller's buffer in characters

Return Value:

    WIN32 Status of function completion
        ERROR_SUCCESS if successful

--*/
{
    return PdhiCompileSelectedCountersT (
        hDlg,
        (LPVOID)szUsersPathBuffer,
        cchUsersPathLength,
        FALSE);
}

STATIC_BOOL
PdhiBrowseCtrDlg_MACHINE_COMBO (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows messags sent by the Machine selection combo box

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the control

    IN  WORD    wNotifyMsg
        Notification message sent by the control

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    WCHAR   szNewMachineName[MAX_PATH];
    HWND    hWndMachineCombo = hWndControl;
    long    lMatchIndex;
    HCURSOR hOldCursor;
    PPDHI_BROWSE_DIALOG_DATA    pData;

    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return FALSE;
    }

    switch (wNotifyMsg) {
        case CBN_KILLFOCUS:
            // the user has left the control so see if there's a new
            // machine name that will need to be connected to and loaded

            // display the wait cursor as this could take a while
            hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

            // Get current combo box text
            GetWindowTextW (hWndMachineCombo, szNewMachineName, MAX_PATH);

            // see if it's in the combo box already

            lMatchIndex = (long)SendMessageW (hWndMachineCombo,
                CB_FINDSTRINGEXACT,(WPARAM)-1, (LPARAM)szNewMachineName);

            // if name is in list, then select it and initialize the dialog
            // update the current counter list & data block for this machine
            // in the process.
            if (lMatchIndex != CB_ERR) {
                // this name is already in the list so see if it's the same as the last selected machine
                if (lstrcmpiW (szNewMachineName, pData->szLastMachineName) != 0) {
                    // this is a different machine so  update the display
                    SendMessageW (hWndMachineCombo, CB_SETCURSEL,
                        (WPARAM)lMatchIndex, 0);
                    PdhiLoadMachineObjects (hDlg, TRUE);
                    PdhiLoadCountersAndInstances (hDlg);
                    // display explain text if necessary
                    SendMessageW (hDlg, WM_COMMAND,
                        MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                        (LPARAM)GetDlgItem(hDlg, IDC_COUNTER_LIST));

                    lstrcpyW (pData->szLastMachineName, szNewMachineName);
                } else {
                    // they just reselected this machine so nothing to do
                }
            } else {
                if (PdhiLoadNewMachine (hDlg, szNewMachineName)) {
                    // new machine loaded and selected so save the name.
                    lstrcpyW (pData->szLastMachineName, szNewMachineName);
                }
            }
            SetCursor (hOldCursor);
            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
PdhiBrowseCtrDlg_MACHINE_BUTTON (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows message that occurs when one of the
        machine context selection buttons in pressed in the dialog

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls

    IN  WORD    wNotifyMsg
        Notification message sent by the button

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    BOOL    bMode;
    PPDHI_BROWSE_DIALOG_DATA    pData;
    HWND    hWndMachineCombo;

    UNREFERENCED_PARAMETER (hWndControl);

    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return FALSE;
    }

    switch (wNotifyMsg) {
        case BN_CLICKED:
            // select the current display and processing mode based
            // on the button that his currently checked.
            bMode = !(BOOL)IsDlgButtonChecked(hDlg, IDC_USE_LOCAL_MACHINE);
            EnableWindow(GetDlgItem(hDlg, IDC_MACHINE_COMBO), bMode);
            if (!bMode) {
                hWndMachineCombo = GetDlgItem(hDlg, IDC_MACHINE_COMBO);
                // then this is a Local machine query so
                // make sure the machine name is set to the local machine
                SetWindowTextW (hWndMachineCombo, szStaticLocalMachineName);
                PdhiBrowseCtrDlg_MACHINE_COMBO (hDlg, CBN_KILLFOCUS, hWndMachineCombo);
            }
            pData->bIncludeMachineInPath = bMode;
            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
PdhiBrowseCtrDlg_OBJECT_COMBO (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows messags sent by the Object selection combo box.

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the control

    IN  WORD    wNotifyMsg
        Notification message sent by the control

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case CBN_SELCHANGE:
            PdhiLoadCountersAndInstances (hDlg);

            SendMessageW (hDlg, WM_COMMAND,
                MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                (LPARAM)GetDlgItem(hDlg, IDC_COUNTER_LIST));

            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
PdhiBrowseCtrDlg_COUNTER_LIST (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows messags sent by the Object selection combo box.

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the control

    IN  WORD    wNotifyMsg
        Notification message sent by the control

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    WCHAR   szMachineName[MAX_PATH];
    WCHAR   szObjectName[MAX_PATH];
    WCHAR   szCounterName[MAX_PATH];
    WCHAR   szDisplayString[MAX_PATH*2];
    LPWSTR  szExplainText = NULL;
    BOOL    bFreeExplain  = FALSE;
    LONG    lIndex;

    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case LBN_SELCHANGE:
            if (hExplainDlg != NULL) {
                // get machine name
                 GetDlgItemTextW (hDlg, IDC_MACHINE_COMBO,
                    szMachineName, MAX_PATH);
                // get object name
                 GetDlgItemTextW (hDlg, IDC_OBJECT_COMBO,
                    szObjectName, MAX_PATH);
                // get counter name
                // depending on list box type
                lIndex = (LONG)SendDlgItemMessageW (hDlg, IDC_COUNTER_LIST,
                    LB_GETCARETINDEX, 0, 0);
                if (lIndex != LB_ERR) {
                    lIndex = (LONG)SendDlgItemMessageW (hDlg, IDC_COUNTER_LIST,
                        LB_GETTEXT, (WPARAM)lIndex, (LPARAM)&szCounterName[0]);
                    // get help string

                    if (dwPdhiLocalDefaultDataSource == DATA_SOURCE_WBEM) {
                        PDH_STATUS Status    = PDH_MORE_DATA;
                        DWORD      dwExplain = 0;

                        szExplainText = NULL;
                        while (Status == PDH_MORE_DATA) {
                            dwExplain += MAX_PATH;
                            if (szExplainText != NULL) {
                                G_FREE(szExplainText);
                            }
                            szExplainText = G_ALLOC(dwExplain * sizeof(WCHAR));
                            if (szExplainText == NULL) {
                                bFreeExplain = FALSE;
                                Status = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                            else {
                                bFreeExplain = TRUE;
                                Status = PdhiGetWbemExplainText(
                                        szMachineName,
                                        szObjectName,
                                        szCounterName,
                                        szExplainText,
                                        & dwExplain);
                            }
                        }
                        if (Status != ERROR_SUCCESS) {
                            if (bFreeExplain) {
                                bFreeExplain = FALSE;
                                G_FREE(szExplainText);
                            }
                            szExplainText = NULL;
                        }
                    }
                    else {
                        szExplainText = PdhiGetExplainText(
                                szMachineName, szObjectName, szCounterName);
                    }

                    lstrcpyW(szDisplayString, szMachineName);
                    lstrcatW(szDisplayString, cszBackSlash);
                    lstrcatW(szDisplayString, szObjectName);
                    lstrcatW(szDisplayString, cszBackSlash);
                    lstrcatW(szDisplayString, szCounterName);

                } else {
                    szExplainText = NULL;
                    szDisplayString[0] = 0;
                }
                // send to explain dialog
                SendMessageW (hExplainDlg, EDM_UPDATE_EXPLAIN_TEXT,
                    0, (LPARAM)szExplainText);
                SendMessageW (hExplainDlg, EDM_UPDATE_TITLE_TEXT,
                    0, (LPARAM)szDisplayString);
            }
            if (bFreeExplain && szExplainText != NULL) {
                G_FREE(szExplainText);
            }
            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
PdhiBrowseCtrDlg_OBJECT_LIST (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows messags sent by the Object selection combo box.

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the control

    IN  WORD    wNotifyMsg
        Notification message sent by the control

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    WCHAR   szMachineName[MAX_PATH];
    WCHAR   szObjectName[MAX_PATH];
    WCHAR   szDisplayString[MAX_PATH*2];
    LPWSTR  szExplainText = NULL;
    BOOL    bFreeExplain  = FALSE;
    LONG    lIndex;

    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case LBN_SELCHANGE:
            if (hExplainDlg != NULL) {
                // get machine name
                 GetDlgItemTextW (hDlg, IDC_MACHINE_COMBO,
                    szMachineName, MAX_PATH);
                // get object name depending on list box type
                lIndex = (LONG)SendDlgItemMessageW (hDlg, IDC_OBJECT_LIST,
                    LB_GETCARETINDEX, 0, 0);
                if (lIndex != LB_ERR) {
                    lIndex = (LONG)SendDlgItemMessageW (hDlg, IDC_OBJECT_LIST,
                        LB_GETTEXT, (WPARAM)lIndex, (LPARAM)&szObjectName[0]);
                    // get help string

                    if (dwPdhiLocalDefaultDataSource == DATA_SOURCE_WBEM) {
                        PDH_STATUS Status    = PDH_MORE_DATA;
                        DWORD      dwExplain = 0;

                        szExplainText = NULL;
                        while (Status == PDH_MORE_DATA) {
                            dwExplain += MAX_PATH;
                            if (szExplainText != NULL) {
                                G_FREE(szExplainText);
                            }
                            szExplainText = G_ALLOC(dwExplain * sizeof(WCHAR));
                            if (szExplainText == NULL) {
                                bFreeExplain = FALSE;
                                Status = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                            else {
                                bFreeExplain = TRUE;
                                Status = PdhiGetWbemExplainText(
                                        szMachineName,
                                        szObjectName,
                                        NULL,
                                        szExplainText,
                                        & dwExplain);
                            }
                        }
                        if (Status != ERROR_SUCCESS) {
                            if (bFreeExplain) {
                                bFreeExplain = FALSE;
                                G_FREE(szExplainText);
                            }
                            szExplainText = NULL;
                        }
                    }
                    else {
                        szExplainText = PdhiGetExplainText(
                                szMachineName, szObjectName, NULL);
                    }

                    lstrcpyW(szDisplayString, szMachineName);
                    lstrcatW(szDisplayString, cszBackSlash);
                    lstrcatW(szDisplayString, szObjectName);

                } else {
                    szExplainText = NULL;
                    szDisplayString[0] = 0;
                }
                // send to explain dialog
                SendMessageW (hExplainDlg, EDM_UPDATE_EXPLAIN_TEXT,
                    0, (LPARAM)szExplainText);
                SendMessageW (hExplainDlg, EDM_UPDATE_TITLE_TEXT,
                    0, (LPARAM)szDisplayString);
            }
            if (bFreeExplain && szExplainText != NULL) {
                G_FREE(szExplainText);
            }
            return TRUE;

        default:
            return FALSE;
    }
}


STATIC_BOOL
PdhiBrowseCtrDlg_DETAIL_COMBO (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows messags sent by the Detail Level Combo box.

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the control

    IN  WORD    wNotifyMsg
        Notification message sent by the control

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    DWORD   dwCurSel;
    PPDHI_BROWSE_DIALOG_DATA    pData;

    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return FALSE;
    }

    switch (wNotifyMsg) {
        case CBN_SELCHANGE:
            dwCurSel = (DWORD)SendMessageW (hWndControl, CB_GETCURSEL, 0, 0);
            if (dwCurSel != CB_ERR) {
                pData->dwCurrentDetailLevel = (DWORD)SendMessageW (hWndControl,
                    CB_GETITEMDATA, (WPARAM)dwCurSel, 0);
                // update all the windows to show the new level
                PdhiLoadMachineObjects (hDlg, FALSE);
                PdhiLoadCountersAndInstances (hDlg);
                // display explain text if necessary
                SendMessageW (hDlg, WM_COMMAND,
                    MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                    (LPARAM)GetDlgItem(hDlg, IDC_COUNTER_LIST));

            }

            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
PdhiBrowseCtrDlg_INSTANCE_BUTTON (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows messags sent by the Instance configuration
        selection buttons

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the control

    IN  WORD    wNotifyMsg
        Notification message sent by the control

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    BOOL    bMode;
    HWND    hWndInstanceList;
    PPDHI_BROWSE_DIALOG_DATA    pData;

    UNREFERENCED_PARAMETER (hWndControl);

    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return FALSE;
    }

    switch (wNotifyMsg) {
        case BN_CLICKED:
            bMode = (BOOL)IsDlgButtonChecked(hDlg, IDC_ALL_INSTANCES);
            hWndInstanceList = GetDlgItem(hDlg, IDC_INSTANCE_LIST);
            // if "Select ALL" then clear list box selections and disable
            // the list box
            if (bMode) {
                SendMessageW (hWndInstanceList, LB_SETSEL, FALSE, (LPARAM)-1);
            } else {
                LRESULT dwCountInstance =
                            SendMessage(hWndInstanceList, LB_GETCOUNT, 0, 0);
                LRESULT dwThisInstance  = 0;
                BOOL  bSelection      = FALSE;

                for (dwThisInstance = 0;
                     ! bSelection && dwThisInstance < dwCountInstance;
                     dwThisInstance ++) {
                    bSelection = (BOOL) SendMessage(hWndInstanceList,
                                                    LB_GETSEL,
                                                    (WPARAM) dwThisInstance,
                                                    0);
                }
                if (! bSelection) {
                    SendMessageW (hWndInstanceList, LB_SETSEL, TRUE, (LPARAM)0);
                }
            }
            EnableWindow(hWndInstanceList, !bMode);
            pData->bSelectAllInstances = bMode;
            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
PdhiBrowseCtrDlg_COUNTER_BUTTON (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows messags sent by the Instance configuration
        selection buttons

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the control

    IN  WORD    wNotifyMsg
        Notification message sent by the control

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    BOOL    bMode;
    HWND    hWndCounterList;
    PPDHI_BROWSE_DIALOG_DATA    pData;

    UNREFERENCED_PARAMETER (hWndControl);

    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return FALSE;
    }

    switch (wNotifyMsg) {
        case BN_CLICKED:
            bMode = (BOOL)IsDlgButtonChecked(hDlg, IDC_ALL_COUNTERS);
            hWndCounterList = GetDlgItem(hDlg, IDC_COUNTER_LIST);
            // if "Select ALL" then clear list box selections and disable
            // the list box
            if (bMode) {
                SendMessageW (hWndCounterList, LB_SETSEL, FALSE, (LPARAM)-1);
            } else {
                LRESULT dwCountCounter =
                            SendMessage(hWndCounterList, LB_GETCOUNT, 0, 0);
                LRESULT dwThisCounter  = 0;
                BOOL  bSelection     = FALSE;

                for (dwThisCounter = 0;
                     ! bSelection && dwThisCounter < dwCountCounter;
                     dwThisCounter ++) {
                    bSelection = (BOOL) SendMessage(hWndCounterList,
                                                    LB_GETSEL,
                                                    (WPARAM) dwThisCounter,
                                                    0);
                }
                if (! bSelection) {
                    PDH_STATUS pdhStatus      = ERROR_SUCCESS;
                    DWORD      dwCounterName  = MAX_PATH;
                    DWORD      dwCounterIndex = 0;
                    WCHAR      szMachineName[MAX_PATH + 1];
                    WCHAR      szObjectName[MAX_PATH + 1];
                    WCHAR      szCounterName[MAX_PATH + 1];

                    GetDlgItemTextW(hDlg,
                                    IDC_MACHINE_COMBO,
                                    szMachineName
                                   , MAX_PATH);
                    GetDlgItemTextW(hDlg,
                                    IDC_OBJECT_COMBO,
                                    szObjectName,
                                    MAX_PATH);
                    pdhStatus = PdhGetDefaultPerfCounterHW (
                                pData->pDlgData->hDataSource,
                                szMachineName,
                                szObjectName,
                                szCounterName,
                                & dwCounterName);
                    if (pdhStatus == ERROR_SUCCESS) {
                        dwCounterIndex = (DWORD) SendMessageW(
                                    hWndCounterList,
                                    LB_FINDSTRINGEXACT,
                                    (WPARAM) -1,
                                    (LPARAM) szCounterName);
                        if (dwCounterIndex == LB_ERR) {
                            dwCounterIndex = 0;
                        }
                    }

                    SendMessageW(hWndCounterList,
                                 LB_SETSEL,
                                 TRUE,
                                 (LPARAM) dwCounterIndex);
                }
            }
            EnableWindow(hWndCounterList, !bMode);
            pData->bSelectAllCounters = bMode;
            return TRUE;

        default:
            return FALSE;
    }
}

#pragma warning ( disable : 4127 )
STATIC_BOOL
PdhiBrowseCtrDlg_OK (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the currently selected counter and instance strings to
        build a list of selected paths strings in the user's supplied
        buffer. This buffer will either be processed by a call back
        string or the dialog box will be terminated allowing the
        calling function to continue processing the returned strings.

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls

    IN  WORD    wNotifyMsg
        Notification message sent by the button

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    HCURSOR             hOldCursor;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwArg;
    PDH_STATUS          pdhStatus;
    PPDHI_BROWSE_DIALOG_DATA    pData;
    PPDHI_BROWSE_DLG_INFO       pDlgData;

    HWND                hWndFocus;
    HWND                hWndMachine;

    UNREFERENCED_PARAMETER (hWndControl);

    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return FALSE;
    }

    pDlgData = pData->pDlgData;

    hWndFocus = GetFocus();
    hWndMachine = GetDlgItem (hDlg, IDC_MACHINE_COMBO);

    if (hWndFocus == hWndMachine) {
        //special case to make sure the dialog has the current machine data
        PdhiBrowseCtrDlg_MACHINE_COMBO (hDlg, CBN_KILLFOCUS, hWndMachine);
        SetFocus (hWndControl);
    }

    switch (wNotifyMsg) {
        case BN_CLICKED:
            // display wait cursor while this is being processed
            hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

            while (TRUE) {
                if (pData->bShowObjects) {
                    // then return object spec(s) using selected perf objects
                    if (pDlgData->pWideStruct != NULL) {
                        // use wide character function
                        pdhStatus = PdhiCompileSelectedObjectsW (hDlg,
                            pDlgData->pWideStruct->szReturnPathBuffer,
                            pDlgData->pWideStruct->cchReturnPathLength);
                        pCallBack = pDlgData->pWideStruct->pCallBack;
                        dwArg = pDlgData->pWideStruct->dwCallBackArg;
                        pDlgData->pWideStruct->CallBackStatus = pdhStatus;
                    } else if (pDlgData->pAnsiStruct != NULL) {
                        // use ansi char functions
                        pdhStatus = PdhiCompileSelectedObjectsA (hDlg,
                            pDlgData->pAnsiStruct->szReturnPathBuffer,
                            pDlgData->pAnsiStruct->cchReturnPathLength);
                        pCallBack = pDlgData->pAnsiStruct->pCallBack;
                        dwArg = pDlgData->pAnsiStruct->dwCallBackArg;
                        pDlgData->pAnsiStruct->CallBackStatus = pdhStatus;
                    } else {
                        // do nothing
                        pCallBack = NULL;
                        dwArg = 0;
                    }
                } else {
                    // return selected counters & instances
                    // process these string until it works. (note, this
                    // could cause an infinite loop if the callback
                    // function is not working correctly (i.e. always
                    // returning PDH_RETRY, for example)
                    if (pDlgData->pWideStruct != NULL) {
                        // use wide character function
                        pdhStatus = PdhiCompileSelectedCountersW (hDlg,
                            pDlgData->pWideStruct->szReturnPathBuffer,
                            pDlgData->pWideStruct->cchReturnPathLength);
                        pCallBack = pDlgData->pWideStruct->pCallBack;
                        dwArg = pDlgData->pWideStruct->dwCallBackArg;
                        pDlgData->pWideStruct->CallBackStatus = pdhStatus;
                    } else if (pDlgData->pAnsiStruct != NULL) {
                        // use ansi char functions
                        pdhStatus = PdhiCompileSelectedCountersA (hDlg,
                            pDlgData->pAnsiStruct->szReturnPathBuffer,
                            pDlgData->pAnsiStruct->cchReturnPathLength);
                        pCallBack = pDlgData->pAnsiStruct->pCallBack;
                        dwArg = pDlgData->pAnsiStruct->dwCallBackArg;
                        pDlgData->pAnsiStruct->CallBackStatus = pdhStatus;
                    } else {
                        // do nothing
                        pCallBack = NULL;
                        dwArg = 0;
                    }

                }
                if (pCallBack != NULL) {
                    pdhStatus = (*pCallBack)(dwArg);
                } else {
                    pdhStatus = ERROR_SUCCESS;
                }

                // see if the callback wants to try again
                if (pdhStatus != PDH_RETRY) {
                    break;
                }
            } // end while (retry loop)

            // if the caller only wants to give the user ONE chance to
            // add counters, then end the dialog now.
            if (!pData->bAddMultipleCounters) {
                EndDialog (hDlg, IDOK);
            }
            SetCursor (hOldCursor);
            return TRUE;

        default:
            return FALSE;
    }
}
#pragma warning ( default : 4127 )

STATIC_BOOL
PdhiBrowseCtrDlg_CANCEL (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows messages that occur when the cancel button
        is pressed.

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls

    IN  WORD    wNotifyMsg
        Notification message sent by the button

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case BN_CLICKED:
            EndDialog (hDlg, IDCANCEL);
            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
PdhiBrowseCtrDlg_EXPLAIN_BTN (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows message that occurs when the help button
        is pressed. (This feature is not currently implemented)

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls

    IN  WORD    wNotifyMsg
        Notification message sent by the button

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    HWND                     hFocusWnd;
    PPDHI_BROWSE_DIALOG_DATA pData =
            (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER (wNotifyMsg);

    if (hExplainDlg == NULL) {
        hFocusWnd = GetFocus();
        // create a modeless dialog to display the explain text
        hExplainDlg = CreateDialogW (
            ThisDLLHandle,
            MAKEINTRESOURCEW(IDD_EXPLAIN_DLG),
            hDlg,
            (DLGPROC)ExplainTextDlgProc);

        SetFocus(hFocusWnd);
        EnableWindow (hWndControl, FALSE);
    }

    if (pData->bShowObjects) {
        SendMessageW(hDlg,
                     WM_COMMAND,
                     MAKEWPARAM(IDC_OBJECT_LIST, LBN_SELCHANGE),
                     (LPARAM) GetDlgItem(hDlg, IDC_OBJECT_LIST));
    }
    else {
        SendMessageW(hDlg,
                     WM_COMMAND,
                     MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                     (LPARAM) GetDlgItem(hDlg, IDC_COUNTER_LIST));
    }


    return TRUE;
}

STATIC_BOOL
PdhiBrowseCtrDlg_HELP_BTN (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows message that occurs when the network button
        is pressed. (This feature is not currently implemented)

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls

    IN  WORD    wNotifyMsg
        Notification message sent by the button

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    LPWSTR  szMsg;

    UNREFERENCED_PARAMETER (wNotifyMsg);
    UNREFERENCED_PARAMETER (hWndControl);

    szMsg = GetStringResource (IDS_ERR_NO_HELP);
    if (szMsg != NULL) {
        MessageBoxW (hDlg, szMsg, szMsg, MB_OK);
        G_FREE (szMsg);
    } else {
        MessageBeep (MB_ICONEXCLAMATION);
    }
    return TRUE;
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_INITDIALOG (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the windows message that occurs just before the dialog
        box is displayed for the first time.

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls

    IN  WORD    wParam
        

    IN  HWND    lParam
        Pointer to dialog box data block

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    PPDHI_BROWSE_DIALOG_DATA    pData;
    PPDHI_BROWSE_DLG_INFO       pDlgData;

    HCURSOR hOldCursor;
    LPWSTR  szMsg;

    UNREFERENCED_PARAMETER (wParam);

    // reset the last error value
    SetLastError (ERROR_SUCCESS);

    hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

    pData = (PPDHI_BROWSE_DIALOG_DATA)G_ALLOC(
        sizeof(PDHI_BROWSE_DIALOG_DATA));

    if (pData == NULL) {
        SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
        EndDialog (hDlg, IDCANCEL);
        return TRUE;
    }

    // initialize local static variables
    dwCounterListSize = COUNTER_LIST_SIZE;
    dwInstanceListSize = INSTANCE_LIST_SIZE;

    // save user data

    pDlgData = (PPDHI_BROWSE_DLG_INFO) lParam;
    pData->pDlgData = (PPDHI_BROWSE_DLG_INFO) lParam;

    SetWindowLongPtrW (hDlg, DWLP_USER, (LONG_PTR)pData);

    // load configuration flags from user data

    if (pData->pDlgData->pWideStruct != NULL) {
        // use wide structure
        pData->bShowIndex =
            (BOOL)pDlgData->pWideStruct->bIncludeInstanceIndex;
        pData->bSelectMultipleCounters =
            !(BOOL)pDlgData->pWideStruct->bSingleCounterPerAdd;
        pData->bAddMultipleCounters =
            !(BOOL)pDlgData->pWideStruct->bSingleCounterPerDialog;
        pData->bLocalCountersOnly =
            (BOOL)pDlgData->pWideStruct->bLocalCountersOnly;
        pData->bIncludeMachineInPath = !pData->bLocalCountersOnly;
        pData->bWildCardInstances =
            (BOOL)pDlgData->pWideStruct->bWildCardInstances;
        pData->bHideDetailLevel =
            (BOOL)pDlgData->pWideStruct->bHideDetailBox;
        if (pDlgData->pWideStruct->szDialogBoxCaption != NULL) {
            SetWindowTextW (hDlg, pDlgData->pWideStruct->szDialogBoxCaption);
        }
        pData->dwCurrentDetailLevel =
            pDlgData->pWideStruct->dwDefaultDetailLevel;
        pData->bDisableMachineSelection =
            (BOOL)pDlgData->pWideStruct->bDisableMachineSelection;
        pData->bInitializePath =
            (BOOL)pDlgData->pWideStruct->bInitializePath;
        pData->bIncludeCostlyObjects =
            (BOOL)pDlgData->pWideStruct->bIncludeCostlyObjects;
        pData->bShowObjects =
            (BOOL)pDlgData->pWideStruct->bShowObjectBrowser;
    } else if (pData->pDlgData->pAnsiStruct != NULL) {
        // use Ansi struct
        pData->bShowIndex =
            (BOOL)pDlgData->pAnsiStruct->bIncludeInstanceIndex;
        pData->bSelectMultipleCounters =
            !(BOOL)pDlgData->pAnsiStruct->bSingleCounterPerAdd;
        pData->bAddMultipleCounters =
            !(BOOL)pDlgData->pAnsiStruct->bSingleCounterPerDialog;
        pData->bLocalCountersOnly =
            (BOOL)pDlgData->pAnsiStruct->bLocalCountersOnly;
        pData->bIncludeMachineInPath = !pData->bLocalCountersOnly;
        pData->bWildCardInstances =
            (BOOL)pDlgData->pAnsiStruct->bWildCardInstances;
        pData->bHideDetailLevel =
            (BOOL)pDlgData->pAnsiStruct->bHideDetailBox;
        if (pDlgData->pAnsiStruct->szDialogBoxCaption != NULL) {
            SetWindowTextA (hDlg, pDlgData->pAnsiStruct->szDialogBoxCaption);
        }
        pData->dwCurrentDetailLevel =
            pDlgData->pAnsiStruct->dwDefaultDetailLevel;
        pData->bDisableMachineSelection =
            (BOOL)pDlgData->pAnsiStruct->bDisableMachineSelection;
        pData->bInitializePath =
            (BOOL)pDlgData->pAnsiStruct->bInitializePath;
        pData->bIncludeCostlyObjects =
            (BOOL)pDlgData->pAnsiStruct->bIncludeCostlyObjects;
        pData->bShowObjects =
            (BOOL)pDlgData->pAnsiStruct->bShowObjectBrowser;
    } else {
        // bad data so bail out
        EndDialog (hDlg, IDCANCEL);
        G_FREE(pData);
        return TRUE;
    }

    // selecting objects implies multiple selections
    if (pData->bShowObjects) {
        pData->bSelectMultipleCounters = TRUE;
    }
    // limit text to machine name
    SendDlgItemMessageW (hDlg, IDC_MACHINE_COMBO, EM_LIMITTEXT, MAX_PATH, 0);

    // set check boxes to the caller defined setting

    if (pData->bLocalCountersOnly) {
        // then only the local counters button is selected and enabled
        EnableWindow (GetDlgItem(hDlg, IDC_SELECT_MACHINE), FALSE);
    }

    CheckRadioButton (hDlg, IDC_USE_LOCAL_MACHINE, IDC_SELECT_MACHINE,
        (pData->bIncludeMachineInPath ? IDC_SELECT_MACHINE : IDC_USE_LOCAL_MACHINE));
    EnableWindow (GetDlgItem(hDlg, IDC_MACHINE_COMBO),
        (pData->bIncludeMachineInPath ? TRUE : FALSE));

    if (!pData->bShowObjects) {
        // these controls aren't found in the Object browser
        CheckRadioButton (hDlg, IDC_ALL_INSTANCES, IDC_USE_INSTANCE_LIST,
            IDC_USE_INSTANCE_LIST);
        pData->bSelectAllInstances = FALSE;

        CheckRadioButton (hDlg, IDC_ALL_COUNTERS, IDC_USE_COUNTER_LIST,
            IDC_USE_COUNTER_LIST);
        pData->bSelectAllCounters = FALSE;
    }

    // set button text strings to reflect mode of dialog
    if (pData->bAddMultipleCounters) {
        szMsg = GetStringResource (IDS_BRWS_ADD);
        if (szMsg != NULL) {
            SetWindowTextW(GetDlgItem(hDlg, IDOK), (LPCWSTR)szMsg);
            G_FREE (szMsg);
        }
        szMsg = GetStringResource (IDS_BRWS_CLOSE);
        if (szMsg != NULL) {
            SetWindowTextW(GetDlgItem(hDlg, IDCANCEL), (LPCWSTR)szMsg);
            G_FREE (szMsg);
        }
    } else {
        szMsg = GetStringResource (IDS_BRWS_OK);
        if (szMsg != NULL) {
            SetWindowTextW(GetDlgItem(hDlg, IDOK), (LPCWSTR)szMsg);
            G_FREE (szMsg);
        }
        szMsg = GetStringResource (IDS_BRWS_CANCEL);
        if (szMsg != NULL) {
            SetWindowTextW(GetDlgItem(hDlg, IDCANCEL), (LPCWSTR)szMsg);
            G_FREE (szMsg);
        }
    }

    // see if the data source supports detail levels
    if (!PdhiDataSourceHasDetailLevelsH (pData->pDlgData->hDataSource)) {
        //then set detail to wizard and hide the combo box
        pData->bHideDetailLevel = TRUE;
        pData->dwCurrentDetailLevel = PERF_DETAIL_WIZARD;
    }

    // hide detail combo box if desired
    if (pData->bHideDetailLevel) {
        ShowWindow (GetDlgItem(hDlg, IDC_COUNTER_DETAIL_CAPTION), SW_HIDE);
        ShowWindow (GetDlgItem(hDlg, IDC_COUNTER_DETAIL_COMBO), SW_HIDE);
        // make sure this is a "legal" value
        switch (pData->dwCurrentDetailLevel) {
            case PERF_DETAIL_NOVICE:
            case PERF_DETAIL_EXPERT:
            case PERF_DETAIL_ADVANCED:
            case PERF_DETAIL_WIZARD:
                // these are OK
                break;

            default:
                // default is to show all
                pData->dwCurrentDetailLevel = PERF_DETAIL_WIZARD;
                break;
        }
    } else {
        // load the combo box entries
        pData->dwCurrentDetailLevel = PdhiLoadDetailLevelCombo (
            hDlg, pData->dwCurrentDetailLevel);
    }

    // connect to this machine
    if (pData->pDlgData->hDataSource == H_REALTIME_DATASOURCE) {
        PdhConnectMachineW(NULL);   // Null is local machine
    }

    PdhiLoadKnownMachines(hDlg);    // load machine list
    PdhiLoadMachineObjects(hDlg, TRUE); // load object list
    if (!pData->bShowObjects) {
        // these controls don't exist in the object browser
        PdhiLoadCountersAndInstances(hDlg);
    }

    if (pData->bShowObjects) {
        // display explain text if necessary
        SendMessageW (hDlg, WM_COMMAND,
            MAKEWPARAM(IDC_OBJECT_LIST, LBN_SELCHANGE),
            (LPARAM)GetDlgItem(hDlg, IDC_OBJECT_LIST));
    } else {
        // display explain text if necessary
        SendMessageW (hDlg, WM_COMMAND,
            MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
            (LPARAM)GetDlgItem(hDlg, IDC_COUNTER_LIST));
    }

    if (pData->bInitializePath) {
        PdhiSelectItemsInPath(hDlg);
    }

    // hide the machine selection buttons and disable the
    // machine combo box if selected (after the connection has been
    // made, of course)

    if (pData->bDisableMachineSelection) {
        ShowWindow (GetDlgItem(hDlg, IDC_USE_LOCAL_MACHINE), SW_HIDE);
        ShowWindow (GetDlgItem(hDlg, IDC_SELECT_MACHINE), SW_HIDE);
        EnableWindow (GetDlgItem(hDlg, IDC_MACHINE_COMBO), FALSE);
        ShowWindow (GetDlgItem(hDlg, IDC_MACHINE_CAPTION), SW_SHOW);
    } else {
        EnableWindow (GetDlgItem(hDlg, IDC_MACHINE_COMBO), TRUE);
        ShowWindow (GetDlgItem(hDlg, IDC_MACHINE_CAPTION), SW_HIDE);
    }
    pData->wpLastMachineSel = 0;

    hExplainDlg = NULL;

    SetCursor (hOldCursor);
    return TRUE;  // return TRUE unless you set the focus to a control
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_COMPAREITEM (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the windows message that are generated when a combo 
        box is searched

Arguments:

    IN  HWND    hDlg
        Window handle to the dialog box window

    IN  WPARAM  wParam
        HIWORD  is the notification message ID
        LOWORD  is the control ID of the control issuing the command

    IN  LPARAM  lParam
        the pointer to a compare item structure

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    LPCOMPAREITEMSTRUCT pCIS = (LPCOMPAREITEMSTRUCT) lParam;

    LPWSTR  szString1;
    LPWSTR  szString2;
    int     nResult;

    UNREFERENCED_PARAMETER (hDlg);

    if (wParam == IDC_MACHINE_COMBO) {
        // then process this 
        szString1 = (LPWSTR)pCIS->itemData1;
        szString2 = (LPWSTR)pCIS->itemData2;
        if ((szString1 != NULL) && (szString2 != NULL)) {
            nResult = lstrcmpiW (szString1, szString2);
        } else {
            nResult = 0;
        }
        if (nResult < 0) {
            // string 1 < string 2
            return (BOOL)-1;
        } else if (nResult > 0) {
            // string 1 > string 2
            return (BOOL)1;
        } else {
            // nResult must == 0
            // string 1 == string 2
            return (BOOL)0;
        }
    } else {
        // who knows?
        return (BOOL) 0;
    }
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_COMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the windows message that occurs when the user interacts
        with the dialog box

Arguments:

    IN  HWND    hDlg
        Window handle to the dialog box window

    IN  WPARAM  wParam
        HIWORD  is the notification message ID
        LOWORD  is the control ID of the control issuing the command

    IN  LPARAM  lParam
        The window handle of the controle issuing the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    WORD    wNotifyMsg;

    wNotifyMsg = HIWORD(wParam);

    switch (LOWORD(wParam)) {   // select on the control ID
        case IDC_USE_LOCAL_MACHINE:
        case IDC_SELECT_MACHINE:
            return PdhiBrowseCtrDlg_MACHINE_BUTTON (hDlg, wNotifyMsg, (HWND)lParam);

        case IDC_MACHINE_COMBO:
            return PdhiBrowseCtrDlg_MACHINE_COMBO (hDlg, wNotifyMsg, (HWND)lParam);

        case IDC_OBJECT_COMBO:
            return PdhiBrowseCtrDlg_OBJECT_COMBO (hDlg, wNotifyMsg, (HWND)lParam);

        case IDC_ALL_INSTANCES:
        case IDC_USE_INSTANCE_LIST:
            return PdhiBrowseCtrDlg_INSTANCE_BUTTON (hDlg, wNotifyMsg, (HWND)lParam);

        case IDC_ALL_COUNTERS:
        case IDC_USE_COUNTER_LIST:
            return PdhiBrowseCtrDlg_COUNTER_BUTTON (hDlg, wNotifyMsg, (HWND)lParam);

        case IDC_COUNTER_LIST:
            return PdhiBrowseCtrDlg_COUNTER_LIST (hDlg, wNotifyMsg, (HWND)lParam);
        case IDC_OBJECT_LIST:
            return PdhiBrowseCtrDlg_OBJECT_LIST (hDlg, wNotifyMsg, (HWND)lParam);

        case IDC_COUNTER_DETAIL_COMBO:
            return PdhiBrowseCtrDlg_DETAIL_COMBO (hDlg, wNotifyMsg, (HWND)lParam);

        case IDOK:
            return PdhiBrowseCtrDlg_OK (hDlg, wNotifyMsg, (HWND)lParam);

        case IDCANCEL:
            return PdhiBrowseCtrDlg_CANCEL (hDlg, wNotifyMsg, (HWND)lParam);

        case IDC_EXPLAIN_BTN:
            return PdhiBrowseCtrDlg_EXPLAIN_BTN (hDlg, wNotifyMsg, (HWND)lParam);

        case IDC_HELP_BTN:
            return PdhiBrowseCtrDlg_HELP_BTN (hDlg, wNotifyMsg, (HWND)lParam);

        default:
            return FALSE;
    }
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_SYSCOMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the windows message that occurs when the user selects an
        item from the system menu

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls

    IN  WPARAM  wParam
        menu ID of item selected

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    UNREFERENCED_PARAMETER(lParam);

    switch (wParam) {
        case SC_CLOSE:
            EndDialog (hDlg, IDOK);
            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_CLOSE (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the windows message that occurs when the dialog box
        is closed. No processing is needed so this function merely returns.

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    UNREFERENCED_PARAMETER (lParam);
    UNREFERENCED_PARAMETER (wParam);
    UNREFERENCED_PARAMETER (hDlg);

    return TRUE;
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_DESTROY (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the windows message that occurs just before the window
        is destroyed. Any memory allocations made are now freed.

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    PPDHI_BROWSE_DIALOG_DATA    pData;

    UNREFERENCED_PARAMETER (lParam);
    UNREFERENCED_PARAMETER (wParam);

    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
#if PDHI_REPORT_CODE_ERRORS
        REPORT_EVENT (EVENTLOG_ERROR_TYPE, PDH_EVENT_CATEGORY_DEBUG, PDH_NO_DIALOG_DATA);
#endif
        return FALSE;
    }

    G_FREE (pData); // free memory block
    return TRUE;
}

INT_PTR
CALLBACK
BrowseCounterDlgProc (
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes all windows messages that are sent to the dialog box window.
        This function is the main dispatching function for the processing
        of these messages.

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    
    INT  iCtrlID;
    BOOL bReturn = FALSE;
    iCtrlID = GetDlgCtrlID ( (HWND) wParam );
    
    switch (message) { 
        case WM_INITDIALOG:
            return PdhiBrowseCtrDlg_WM_INITDIALOG (hDlg, wParam, lParam);

        case WM_COMMAND:
            return PdhiBrowseCtrDlg_WM_COMMAND (hDlg, wParam, lParam);

        case WM_SYSCOMMAND:
            return PdhiBrowseCtrDlg_WM_SYSCOMMAND (hDlg, wParam, lParam);

        case WM_CLOSE:
            return PdhiBrowseCtrDlg_WM_CLOSE (hDlg, wParam, lParam);

        case WM_DESTROY:
            return PdhiBrowseCtrDlg_WM_DESTROY (hDlg, wParam, lParam);

        case WM_COMPAREITEM:
            return PdhiBrowseCtrDlg_WM_COMPAREITEM (hDlg, wParam, lParam);

        case EDM_EXPLAIN_DLG_CLOSING:
            hExplainDlg = NULL;
           EnableWindow (GetDlgItem(hDlg, IDC_EXPLAIN_BTN), TRUE);
            return TRUE;

        case WM_CONTEXTMENU:
                if ( 0 != iCtrlID ) {
                    TCHAR pszHelpFilePath[MAX_PATH * 2];
                    UINT nLen;

                    nLen = GetWindowsDirectory(pszHelpFilePath, 2*MAX_PATH);
                    lstrcpy(& pszHelpFilePath[nLen], _T("\\help\\sysmon.hlp"));
                    bReturn = WinHelp(
                            (HWND) wParam,
                            pszHelpFilePath,
                            HELP_CONTEXTMENU,
                            (DWORD_PTR) PdhiBrowseraulControlIdToHelpIdMap);
                }
                return bReturn;

        case WM_HELP:
            {
                // Only display help for known context IDs.
                TCHAR pszHelpFilePath[MAX_PATH * 2];
                UINT nLen;
                LPHELPINFO pInfo = NULL;
                pInfo = (LPHELPINFO)lParam;

                for (nLen = 0;
                     PdhiBrowseraulControlIdToHelpIdMap[nLen] != 0;
                     nLen +=2) {
                    if (    (INT) PdhiBrowseraulControlIdToHelpIdMap[nLen]
                         == pInfo->iCtrlId) {
                        break;
                    }
                }
                if (PdhiBrowseraulControlIdToHelpIdMap[nLen] != 0) {
                    nLen = GetWindowsDirectory(pszHelpFilePath, 2*MAX_PATH);
                    if ( nLen == 0 ) {
                        // Report error.
                    }

                    lstrcpy(&pszHelpFilePath[nLen], _T("\\help\\sysmon.hlp") );
                    if (pInfo->iContextType == HELPINFO_WINDOW){
                        bReturn = WinHelp ( 
                                pInfo->hItemHandle,
                                pszHelpFilePath,
                                HELP_WM_HELP,
                                (DWORD_PTR) PdhiBrowseraulControlIdToHelpIdMap);
                    }
                }
                else {
                    bReturn = FALSE;
                }
                return bReturn;
            } 
    
        default:
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhpla\regutil.cpp ===
/*****************************************************************************\

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <assert.h>
#include <windows.h>
#include <string.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <pdh.h>

#include <pdhp.h>
#include <ntsecapi.h>

#include <shlwapi.h>
#include <shlwapip.h>

#include "plogman.h"

PDH_FUNCTION
PlaiReadRegistryPlaTime (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    PPLA_TIME_INFO  pstiData
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    PLA_TIME_INFO   slqLocal;

    memset (&slqLocal, 0, sizeof(PLA_TIME_INFO));

    dwStatus = RegQueryValueExW (
        hKey,
        cwszValueName,
        NULL,
        &dwType,
        NULL,
        &dwBufferSize );

    if ( ERROR_SUCCESS == dwStatus ) {
        if ( (dwBufferSize == sizeof(PLA_TIME_INFO)) && ( REG_BINARY == dwType ) ) {
            // then there's something to read
            dwType = 0;
            dwStatus = RegQueryValueExW (
                hKey,
                cwszValueName,
                NULL,
                &dwType,
                (LPBYTE)&slqLocal,
                &dwBufferSize);
        } else {
            // nothing to read
            dwStatus = ERROR_NO_DATA;
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        *pstiData = slqLocal;
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiWriteRegistryPlaTime (
    HKEY     hKey,
    LPCWSTR cwszValueName,
    PPLA_TIME_INFO  pstiData
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(PLA_TIME_INFO);

    dwStatus = RegSetValueExW (
        hKey,
        cwszValueName,
        0L,
        REG_BINARY,
        (CONST BYTE *)pstiData,
        dwValue);

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiReadRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(DWORD);
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;

    dwStatus = RegQueryValueExW (
        hKey,
        cwszValueName,
        NULL,
        &dwType,
        NULL,
        &dwBufferSize );

    if ( ERROR_SUCCESS == dwStatus ) {
        if ( ( dwBufferSize == sizeof(DWORD) )
                && ( ( REG_DWORD == dwType ) || ( REG_BINARY == dwType ) ) ) {
            // then there's something to read
            dwType = 0;
            dwStatus = RegQueryValueExW (
                hKey,
                cwszValueName,
                NULL,
                &dwType,
                (LPBYTE)&dwValue,
                &dwBufferSize);
        } else {
            // nothing to read
            dwStatus = ERROR_NO_DATA;
        }
    } // else hr has error.

    if ( ERROR_SUCCESS == dwStatus ) {
        *pdwValue = dwValue;
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiWriteRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue
)
{
    DWORD dwType = REG_DWORD;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(DWORD);

    dwStatus = RegSetValueExW (
        hKey,
        cwszValueName,
        0L,
        dwType,
        (CONST BYTE *)pdwValue,
        dwValue);

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiReadRegistryStringValue(
    HKEY    hKey,
    LPCWSTR strKey,
    DWORD   dwFlags,
    LPWSTR* pszBuffer,
    DWORD*  dwBufLen
    )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwDataType;
    DWORD   dwDataSize = 0;
    LPWSTR  pBuffer;
    
    dwStatus = RegQueryValueExW(
             hKey,
             strKey,
             NULL,
             &dwDataType,
             (LPBYTE)NULL,
             (LPDWORD)&dwDataSize
        );

    if( (dwFlags & READ_REG_MUI) ){
        if( dwDataSize < 1024 ){
            dwDataSize = 1024;
        }
        dwStatus = ERROR_SUCCESS;
    }    

    if( ERROR_SUCCESS == dwStatus ){

        pBuffer = *pszBuffer;

        if( pBuffer == NULL || dwDataSize > G_SIZE(pBuffer) ){
            
            if( pBuffer != NULL ){
                pBuffer = (LPWSTR)G_REALLOC( pBuffer, dwDataSize );
            }else{
                pBuffer = (LPWSTR)G_ALLOC( dwDataSize );
            }

            if( pBuffer ){
                *pszBuffer = pBuffer;
            }else{
                G_FREE( (*pszBuffer) );
                return ERROR_OUTOFMEMORY;
            }
        }
        
        if( dwFlags & READ_REG_MUI ){
            WCHAR strKeyIndirect[1024];
            wsprintf( strKeyIndirect, L"%s Indirect", strKey );

            dwStatus = SHLoadRegUIStringW (
                    hKey,
                    strKeyIndirect,
                    *pszBuffer,
                    dwDataSize
                );

            if( ERROR_SUCCESS == dwStatus ){
                *dwBufLen = (DWORD)((char*)&(*pszBuffer)[wcslen(*pszBuffer)]  
                                    - (char*)&(*pszBuffer)[0]);
                *dwBufLen += sizeof(WCHAR);
            }else{
                *dwBufLen = 0;
            }

        }
        if( !(dwFlags & READ_REG_MUI) ||
            ((dwFlags & READ_REG_MUI) && ERROR_SUCCESS != dwStatus) ){
            
            dwStatus = RegQueryValueExW(
                     hKey,
                     strKey,
                     NULL,
                     &dwDataType,
                     (LPBYTE)*pszBuffer,
                     (LPDWORD)&dwDataSize
                );
            
            if( dwStatus == ERROR_SUCCESS ){
                *dwBufLen = dwDataSize;
            }else{
                *dwBufLen = 0;
            }
        }
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiWriteRegistryStringValue (
    HKEY    hKey,
    LPCWSTR cwszValueName,
    DWORD   dwType,
    LPCWSTR pszBuffer,
    DWORD   cbBufferLength
)
{
    //  writes the contents of pszBuffer to szValue under hKey
    
    DWORD  dwStatus = ERROR_SUCCESS;
    CONST BYTE *pLclBuffer;

    if ( NULL == pszBuffer ) {
        // substitute an empty string
        pLclBuffer = (CONST BYTE *)L"\0";
        cbBufferLength = sizeof(WCHAR);
    } else {
        // use args passed in
        pLclBuffer = (CONST BYTE *)pszBuffer;
        if( cbBufferLength == 0 ){
            cbBufferLength = BYTE_SIZE( pszBuffer ) + (DWORD)sizeof(UNICODE_NULL);
        }
    }

    dwStatus = RegSetValueExW (hKey,
        cwszValueName,
        0L,
        dwType,
        (CONST BYTE *)pLclBuffer,
        cbBufferLength );

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiWriteRegistryLastModified( HKEY hkeyQuery )
{
    DWORD dwStatus = ERROR_SUCCESS;

    PLA_TIME_INFO   plqLastModified;
    SYSTEMTIME      stLocalTime;
    FILETIME        ftModified;

    RegFlushKey( hkeyQuery );

    dwStatus = RegQueryInfoKey ( 
                hkeyQuery,
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                &ftModified );

    if( ERROR_SUCCESS != dwStatus ) {
        GetLocalTime (&stLocalTime);
        SystemTimeToFileTime (&stLocalTime, &ftModified);
    }

    plqLastModified.wDataType = PLA_TT_DTYPE_DATETIME;
    plqLastModified.wTimeType = PLA_TT_TTYPE_LAST_MODIFIED;
    plqLastModified.dwAutoMode = PLA_AUTO_MODE_NONE;
    plqLastModified.llDateTime = *(LONGLONG *)&ftModified;

    if( ERROR_SUCCESS == dwStatus ){
        return PlaiWriteRegistryPlaTime (
                            hkeyQuery, 
                            L"Last Modified",
                            &plqLastModified
                        );
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

DWORD 
PlaiCreateQuery( 
        HKEY    hkeyMachine,
        HKEY&   rhkeyLogQueries 
    )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hkeySysmonLog;
    DWORD   dwDisposition;
    
    rhkeyLogQueries = NULL;

    dwStatus = RegOpenKeyExW (
                    hkeyMachine,
                    L"System\\CurrentControlSet\\Services\\SysmonLog",
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkeySysmonLog);
    
    if ( ERROR_SUCCESS == dwStatus ) {
        // Create registry subkey for Log Queries
        dwStatus = RegCreateKeyExW (
                        hkeySysmonLog,
                        L"Log Queries",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &rhkeyLogQueries,
                        &dwDisposition);
    }

    return dwStatus;
}

PDH_FUNCTION
PdhiPlaGetVersion(
    LPCWSTR strComputer,
    PPLA_VERSION pVersion )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hkeyMachine = HKEY_LOCAL_MACHINE;    
    HKEY    hkeyQuery = NULL;
    DWORD   cbBufferSize = 0;
    DWORD   dwType;
    WCHAR   szRegValue[MAX_PATH];
    PLA_VERSION version;

    ZeroMemory( &version, sizeof(PLA_VERSION) );

    if ( NULL != strComputer ) {
        if ( wcslen( strComputer) ) {

            dwStatus = RegConnectRegistryW (
                        strComputer,
                        HKEY_LOCAL_MACHINE,
                        &hkeyMachine 
                    );  
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        dwStatus = RegOpenKeyExW (
                hkeyMachine,
                L"Software\\Microsoft\\Windows NT\\CurrentVersion",
                0,
                KEY_READ,
                &hkeyQuery 
            );

        if( ERROR_SUCCESS == dwStatus ){
            dwStatus = RegQueryValueExW (
                    hkeyQuery,
                    L"CurrentVersion",
                    NULL,
                    &dwType,
                    NULL,
                    &cbBufferSize
                );

            if( ERROR_SUCCESS == dwStatus ) {
                if( (MAX_PATH*sizeof(WCHAR) > cbBufferSize ) && 
                    (sizeof(WCHAR) < cbBufferSize) &&
                    (REG_SZ == dwType ) )
                {
                    ZeroMemory ( szRegValue, MAX_PATH ); 

                    dwStatus = RegQueryValueExW (
                                hkeyQuery,
                                L"CurrentVersion",
                                NULL,
                                &dwType,
                                (LPBYTE)szRegValue,
                                &cbBufferSize
                            );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        version.dwMajorVersion = _wtol ( szRegValue );
                    }
                }
            }
        }

        if( ERROR_SUCCESS == dwStatus ){
            dwStatus = RegQueryValueExW (
                    hkeyQuery,
                    L"CurrentBuildNumber",
                    NULL,
                    &dwType,
                    NULL,
                    &cbBufferSize
                );

            if( ERROR_SUCCESS == dwStatus ) {
                if( (MAX_PATH*sizeof(WCHAR) > cbBufferSize ) && 
                    (sizeof(WCHAR) < cbBufferSize) &&
                    (REG_SZ == dwType ) )
                {
                    ZeroMemory ( szRegValue, MAX_PATH ); 

                    dwStatus = RegQueryValueExW (
                                hkeyQuery,
                                L"CurrentBuildNumber",
                                NULL,
                                &dwType,
                                (LPBYTE)szRegValue,
                                &cbBufferSize
                            );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        version.dwBuild = _wtol ( szRegValue );
                    }
                }
            }
        }
    }

    memcpy( pVersion, &version, sizeof(PLA_VERSION) );
    
    if ( NULL != hkeyMachine ) {
        RegCloseKey ( hkeyMachine );
    }
    
    if( NULL != hkeyQuery ){
        RegCloseKey( hkeyQuery );
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiConnectToRegistry(
    LPCWSTR strComputer,
    HKEY& rhkeyLogQueries,
    BOOL bQueries,
    BOOL bWrite)
{
    DWORD dwStatus = ERROR_SUCCESS;
    HKEY    hkeyMachine = HKEY_LOCAL_MACHINE;    

    if ( NULL != strComputer ) {
        if( wcslen( strComputer ) ){
            dwStatus = RegConnectRegistryW (
                strComputer,
                HKEY_LOCAL_MACHINE,
                &hkeyMachine );        
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        if( bQueries ){
            if ( bWrite ) {
                dwStatus = RegOpenKeyExW (
                    hkeyMachine,
                    L"System\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
                    0,
                    KEY_READ | KEY_WRITE,
                    &rhkeyLogQueries ); 
            }else{
                dwStatus = RegOpenKeyExW (
                    hkeyMachine,
                    L"System\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
                    0,
                    KEY_READ,
                    &rhkeyLogQueries ); 
            }
        }else{
            dwStatus = RegOpenKeyExW (
                hkeyMachine,
                L"System\\CurrentControlSet\\Services\\SysmonLog",
                0,
                KEY_READ,
                &rhkeyLogQueries ); 
        }

        if ( ERROR_SUCCESS != dwStatus ) {
            dwStatus = PlaiCreateQuery( hkeyMachine, rhkeyLogQueries );
        }
    } 
    
    if ( NULL != hkeyMachine ) {
        RegCloseKey ( hkeyMachine );
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiConnectAndLockQuery (
    LPCWSTR strComputer,
    LPCWSTR strQuery,
    HKEY&   rhkeyQuery,
    BOOL    bWrite  )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY  hkeyQuery = NULL;
    HKEY  hkeyLogQueries = NULL;

    rhkeyQuery = NULL;
    dwStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhPlaMutex);
    
    if( ERROR_SUCCESS == dwStatus || WAIT_ABANDONED == dwStatus ){

        pdhStatus = PlaiConnectToRegistry (
                    strComputer,
                    hkeyLogQueries,
                    TRUE,
                    bWrite
                );

        if( ERROR_SUCCESS == pdhStatus ){
            DWORD nCollections = 0;
            DWORD nMaxSubKeyLength = 0;

            dwStatus = RegQueryInfoKey(
                        hkeyLogQueries,
                        NULL,
                        NULL,
                        NULL,
                        &nCollections,
                        &nMaxSubKeyLength,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL 
                    );

            if( ERROR_SUCCESS == dwStatus ){
            
                LPWSTR strCollection;
                LPWSTR strQueryName = NULL;
                DWORD dwQueryName = 0;

                DWORD dwSize = (sizeof(WCHAR)*(nMaxSubKeyLength+1));

                strCollection = (LPWSTR)G_ALLOC( dwSize );

                if( strCollection ){

                    dwStatus = ERROR_FILE_NOT_FOUND;
                    
                    for( ULONG i = 0; i<nCollections; i++ ){
                        dwStatus = RegEnumKey( hkeyLogQueries, i, strCollection, dwSize );
                        if( ERROR_SUCCESS == dwStatus ) {

                            dwStatus = RegOpenKeyExW (
                                    hkeyLogQueries,
                                    strCollection,
                                    0,
                                    bWrite ? KEY_READ | KEY_WRITE : KEY_READ,
                                    &hkeyQuery 
                                );

                            if( ERROR_SUCCESS == dwStatus ){
                                if( !_wcsicmp( strCollection, strQuery ) ){
                                    break;
                                }

                                PlaiReadRegistryStringValue( hkeyQuery, szCollection, READ_REG_MUI, &strQueryName, &dwQueryName );
                            
                                if( strQueryName != NULL && !_wcsicmp( strQueryName, strQuery ) ){
                                    break;
                                }
                                dwStatus = ERROR_FILE_NOT_FOUND;
                                if ( NULL != hkeyQuery ) {
                                    RegCloseKey ( hkeyQuery );
                                }
                            }
                        }
                    }

                    G_FREE( strQueryName );
                    G_FREE( strCollection );

                }else{
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            }
        }

        RegCloseKey ( hkeyLogQueries );

        if( ERROR_SUCCESS != dwStatus || ERROR_SUCCESS != pdhStatus){
            RELEASE_MUTEX( hPdhPlaMutex );
        }else{
            rhkeyQuery = hkeyQuery;
        }
    }

    if( ERROR_SUCCESS != pdhStatus ){
        return pdhStatus;
    }else{
        return PlaiErrorToPdhStatus( dwStatus );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhpla\wmiutil.cpp ===
/*****************************************************************************\

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <assert.h>
#include <windows.h>
#include <tchar.h>
#include <pdh.h>
#include <pdhp.h>
#include <pdhmsg.h>

#include "plogman.h"

PDH_FUNCTION
PdhPlaWbemConnect( LPWSTR strComputer, IWbemClassObject** pWbemClass, IWbemServices** pWbemServices )
{
    HRESULT hr;
    IWbemLocator *pLocator = NULL;
    LPCWSTR szRootOld = L"root\\wmi";
    LPCWSTR szRootNew = L"root\\perfmon";
    LPCWSTR szMask = L"\\\\%s\\%s";
    BSTR bszClass = SysAllocString(L"SysmonLog");
    BSTR bszNamespaceOld = NULL;
    BSTR bszNamespaceNew = NULL;
    LPWSTR buffer = NULL;

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if( S_FALSE == hr ){
        // This thread already called CoInitialize
        hr = ERROR_SUCCESS;
    }

    if( NULL != strComputer ){
        DWORD dwSize = wcslen(szRootNew) + wcslen(strComputer) + wcslen( szMask );
        buffer = (LPWSTR)G_ALLOC( dwSize * sizeof(WCHAR) );
        if( buffer == NULL ){
            hr = ERROR_OUTOFMEMORY;
            goto cleanup;
        }
        swprintf( buffer, szMask, strComputer, szRootOld );
        bszNamespaceOld = SysAllocString( buffer );

        swprintf( buffer, szMask, strComputer, szRootNew );
        bszNamespaceNew = SysAllocString( buffer );
    }else{
        bszNamespaceOld = SysAllocString( szRootOld );
        bszNamespaceNew = SysAllocString( szRootNew );
    }

    *pWbemServices = NULL;
    *pWbemClass = NULL;

    hr = CoCreateInstance(
                CLSID_WbemLocator,
                0,
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator,
                (LPVOID*)&pLocator
            );
    CHECK_STATUS( hr );

    hr = pLocator->ConnectServer(
                bszNamespaceNew,
                NULL,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                pWbemServices
            );

    if( FAILED(hr) ){

        hr = pLocator->ConnectServer(
                    bszNamespaceOld,
                    NULL,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    pWbemServices
                );
    }

    CHECK_STATUS( hr );

    hr = CoSetProxyBlanket(
            *pWbemServices,
            RPC_C_AUTHN_WINNT,
            RPC_C_AUTHZ_NONE,
            NULL,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, 
            EOAC_NONE
        );                     
    CHECK_STATUS( hr );
    
    hr = (*pWbemServices)->GetObject( bszClass, 0, NULL, pWbemClass, NULL);
    CHECK_STATUS( hr );

cleanup:
    if( pLocator != NULL ){
        pLocator->Release();
    }
    if( ERROR_SUCCESS != hr ){
        if( *pWbemClass != NULL ){
            (*pWbemClass)->Release();
            *pWbemClass = NULL;
        }
        if( *pWbemServices != NULL ){
            (*pWbemServices)->Release();
            *pWbemServices = NULL;
        }
    }
    G_FREE( buffer );
    SysFreeString( bszNamespaceOld );
    SysFreeString( bszNamespaceNew );
    SysFreeString( bszClass );
    
    return hr;
}

PDH_FUNCTION
PdhPlaWbemSetRunAs( 
        LPWSTR strName,
        LPWSTR strComputer,
        LPWSTR strUser,
        LPWSTR strPassword
    )
{
    HRESULT hr = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    IWbemClassObject* pWbemClass = NULL;
    IWbemServices* pWbemServices = NULL;

    __try{
    
        BSTR bszMethodName = SysAllocString( L"SetRunAs" );
        BSTR bszUser = SysAllocString(L"User");
        BSTR bszPassword = SysAllocString(L"Password");
        BSTR bszReturn = SysAllocString(L"ReturnValue");
        LPCWSTR szInstanceMask = L"SysmonLog.Name=\"%s\"";

        IWbemClassObject* pOutInst = NULL;
        IWbemClassObject* pInClass = NULL;
        IWbemClassObject* pInInst = NULL;

        VARIANT var;
        CIMTYPE vtType;
        LONG nFlavor;

        LPWSTR buffer = NULL;
        DWORD dwSize = wcslen( szInstanceMask ) + wcslen( strName );
        buffer = (LPWSTR)G_ALLOC( dwSize * sizeof(WCHAR) );
        if( NULL == buffer ){
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto cleanup;
        }
        swprintf( buffer, szInstanceMask, strName );
        BSTR bszInstancePath = SysAllocString( buffer );

        hr = PdhPlaWbemConnect( strComputer, &pWbemClass, &pWbemServices );
        CHECK_STATUS( hr );

        hr = pWbemClass->GetMethod( bszMethodName, 0, &pInClass, NULL); 
        CHECK_STATUS( hr );

        hr = pInClass->SpawnInstance(0, &pInInst);
        CHECK_STATUS( hr );

        var.vt = VT_BSTR;
        var.bstrVal= SysAllocString( strUser );
        hr = pInInst->Put( bszUser, 0, &var, 0);
        VariantClear(&var);
        CHECK_STATUS( hr );

        var.vt = VT_BSTR;
        var.bstrVal= SysAllocString( strPassword );
        hr = pInInst->Put(bszPassword, 0, &var, 0);
        VariantClear(&var);
        CHECK_STATUS( hr );

        hr = pWbemServices->ExecMethod( bszInstancePath, bszMethodName, 0, NULL, pInInst, &pOutInst, NULL);
        CHECK_STATUS( hr );

        if( pOutInst != NULL ){
            hr = pOutInst->Get( bszReturn, 0, &var, &vtType, &nFlavor );
            CHECK_STATUS( hr );

            if( var.vt == VT_I4 ){
                pdhStatus = var.lVal;
            }
            VariantClear(&var);
        }

cleanup:
        if( pWbemClass != NULL ){
            pWbemClass->Release();
        }
        if( pWbemServices != NULL ){
            pWbemServices->Release();
        }
        if( pInInst != NULL ){
            pInInst->Release();
        }
        if( pOutInst != NULL ){
            pOutInst->Release();
        }

        SysFreeString( bszInstancePath );
        SysFreeString( bszMethodName );
        SysFreeString( bszUser );
        SysFreeString( bszPassword );
        SysFreeString( bszReturn );
    
        G_FREE( buffer );

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = GetLastError();
    }

    if( ERROR_SUCCESS != pdhStatus ){
        return pdhStatus;
    }

    return PlaiErrorToPdhStatus( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhui\datasrc.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    datasrc.h

Abstract:

    <abstract>

--*/

#ifndef _DATASRC_H_
#define _DATASRC_H_

typedef struct _PDHI_DATA_SOURCE_INFO {
    DWORD   dwFlags;
    LPWSTR  szDataSourceFile;
    DWORD   cchBufferLength;
} PDHI_DATA_SOURCE_INFO, *PPDHI_DATA_SOURCE_INFO;

#define PDHI_DATA_SOURCE_CURRENT_ACTIVITY   0x00000001
#define PDHI_DATA_SOURCE_LOG_FILE           0x00000002
#define PDHI_DATA_SOURCE_WBEM_NAMESPACE     0x00000004

INT_PTR
CALLBACK
DataSrcDlgProc (
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

#endif //_DATASRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhpla\plogman.h ===
/*****************************************************************************\

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#ifndef _PLOGMAN_H_04262000_
#define _PLOGMAN_H_04262000_

#include "pdhidef.h"

#define _SECOND ((ULONGLONG) 10000000)
#define _MINUTE (60 * _SECOND)
#define _HOUR   (60 * _MINUTE)
#define _DAY    (24 * _HOUR)

#define  VALIDATE_QUERY( x ) if( NULL == x ){ return PDH_INVALID_ARGUMENT; }

#define  PLA_ACCOUNT_BUFFER       256

extern LPCWSTR szCollection;

#define READ_REG_MUI    0x000000001

#define CHECK_STATUS( s )  if( ERROR_SUCCESS != s ){ goto cleanup; }

#define FILE_TICS_PER_DAY  ((LONGLONG)((LONGLONG)10000 * (LONGLONG)1000 * (LONGLONG)86400))
#define PLA_ENGLISH        (PRIMARYLANGID(GetUserDefaultUILanguage())==LANG_ENGLISH)

#define BYTE_SIZE( s )   (s ? ((DWORD)((BYTE*)&s[wcslen(s)]-(BYTE*)&s[0])) : 0)

#define SEVERITY( s )    ((ULONG)s >> 30)

// Registry

PDH_FUNCTION
PlaiReadRegistryPlaTime (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    PPLA_TIME_INFO  pstiData
);

PDH_FUNCTION
PlaiWriteRegistryPlaTime (
    HKEY     hKey,
    LPCWSTR cwszValueName,
    PPLA_TIME_INFO  pstiData
);

PDH_FUNCTION
PlaiReadRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue
);

PDH_FUNCTION
PlaiWriteRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue
);

PDH_FUNCTION
PlaiReadRegistryStringValue(
    HKEY    hKey,
    LPCWSTR strKey,
    DWORD   dwFlags,
    LPWSTR* pszBuffer,
    DWORD*  dwBufLen
    );

PDH_FUNCTION
PlaiWriteRegistryStringValue (
    HKEY    hKey,
    LPCWSTR cwszValueName,
    DWORD   dwType,
    LPCWSTR pszBuffer,
    DWORD   dwBufLen
);

PDH_FUNCTION 
PlaiWriteRegistryLastModified( 
    HKEY hkeyQuery
);

DWORD
PlaiCreateQuery( 
    HKEY    hkeyMachine,
    HKEY&   rhkeyLogQueries 
);

PDH_FUNCTION
PlaiConnectToRegistry(
    LPCWSTR szComputerName,
    HKEY& rhkeyLogQueries,
    BOOL bQueries,
    BOOL bWrite = TRUE
);

PDH_FUNCTION
PlaiConnectAndLockQuery (
    LPCWSTR szComputerName,
    LPCWSTR szQueryName,
    HKEY&   rhkeyQuery,
    BOOL    bWrite = TRUE 
);

// Wbem Functions
PDH_FUNCTION
PdhPlaWbemSetRunAs( 
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

// Internal

PDH_FUNCTION
PlaiErrorToPdhStatus( 
    DWORD dwStatus 
);

PDH_FUNCTION
PlaiSetItemList(
    HKEY    hkeyQuery,
    PPDH_PLA_ITEM_W pItems
);

PDH_FUNCTION
PlaiSetRunAs(
    HKEY hkeyQuery,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION
PlaiRemoveRepeat( 
    HKEY hkeyQuery 
);

PDH_FUNCTION
PlaiSetInfo(
    LPWSTR strComputer,
    HKEY hkeyQuery,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PlaiScanForInvalidChar( 
    LPWSTR strScan 
);

PDH_FUNCTION
PlaiAddItem( 
    HKEY hkeyQuery,
    PPDH_PLA_ITEM_W pItem 
);

#endif //_PLOGMAN_H_04262000_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhui\datasrc.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    datasrc.c

Abstract:

    data source selection dialog box functions

Revision History

    Bob Watson (a-robw) Feb-95  Created

--*/
#include <windows.h>
#include <assert.h>
#include <tchar.h>
#include "mbctype.h"
#include <pdh.h>
#include "pdhidef.h"
#include "pdhdlgs.h"
#include "datasrc.h"
#include "pdhmsg.h"
#include "strings.h"

//
//  Constants used in this module
//
ULONG
PdhiDatasrcaulControlIdToHelpIdMap[] =
{
    IDC_CURRENT_ACTIVITY,       IDH_CURRENT_ACTIVITY,
    IDC_DATA_FROM_LOG_FILE,     IDH_DATA_FROM_LOG_FILE,
    IDC_LOG_FILE_EDIT,          IDH_LOG_FILE_EDIT,
    0,0
};

STATIC_BOOL
DataSrcDlg_RadioButton (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  WORD    wCtrlId
)
{
    int nShowEdit = FALSE;
    int nShowBrowseBtn = FALSE;
    int nShowRegBtn = FALSE;
    int nShowWbemBtn = FALSE;

    switch (wNotifyMsg) {
        case BN_CLICKED:
            switch (wCtrlId) {
                case IDC_CURRENT_ACTIVITY:
                    nShowEdit = FALSE;
                    nShowBrowseBtn = FALSE;
                    nShowRegBtn = TRUE;
                    nShowWbemBtn = TRUE;
                    break;

                case IDC_DATA_FROM_LOG_FILE:
                    nShowEdit = TRUE;
                    nShowBrowseBtn = TRUE;
                    nShowRegBtn = FALSE;
                    nShowWbemBtn = FALSE;
                    break;

                case IDC_PERF_REG:
                case IDC_WBEM_NS:
                    return TRUE;

            }
            EnableWindow (GetDlgItem (hDlg, IDC_LOG_FILE_EDIT), nShowEdit);
            EnableWindow (GetDlgItem (hDlg, IDC_BROWSE_LOG_FILES), nShowBrowseBtn);
            EnableWindow (GetDlgItem (hDlg, IDC_PERF_REG), nShowRegBtn);
            EnableWindow (GetDlgItem (hDlg, IDC_WBEM_NS), nShowWbemBtn);
            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
DataSrcDlg_BROWSE_LOG_FILES (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    WCHAR           szEditBoxString[SMALL_BUFFER_SIZE];
    DWORD           cchStringLen = SMALL_BUFFER_SIZE;

    UNREFERENCED_PARAMETER (hWndControl);
    
    switch (wNotifyMsg) {
        case BN_CLICKED:
            // get the current filename
            SendDlgItemMessageW (hDlg, IDC_LOG_FILE_EDIT, WM_GETTEXT,
                (WPARAM)SMALL_BUFFER_SIZE, (LPARAM)szEditBoxString);

            if (PdhiBrowseDataSource (hDlg, szEditBoxString, &cchStringLen, TRUE)) {
                // then update the edit box and set focus to it.

                SendDlgItemMessageW (hDlg, IDC_LOG_FILE_EDIT, WM_SETTEXT,
                    (WPARAM)0, (LPARAM)szEditBoxString);
            }
            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
DataSrcDlg_OK (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    PPDHI_DATA_SOURCE_INFO  pInfo;
    HCURSOR hOldCursor;
    DWORD   dwFileNameLength;
    LPWSTR  szStringPtr;

    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case BN_CLICKED:
            pInfo = (PPDHI_DATA_SOURCE_INFO)GetWindowLongPtrW (hDlg, DWLP_USER);
            if (pInfo != NULL) {
                hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
                // get data from dialog box
                if (IsDlgButtonChecked (hDlg, IDC_CURRENT_ACTIVITY) == 1) {
                    if (IsDlgButtonChecked (hDlg, IDC_WBEM_NS) == 1) {
                        // then a WBEM Name Space is selected so get the name
                        pInfo->dwFlags = PDHI_DATA_SOURCE_WBEM_NAMESPACE;
                        dwFileNameLength = lstrlenW (cszWMI);
                        if (dwFileNameLength < pInfo->cchBufferLength) {
                            szStringPtr = pInfo->szDataSourceFile;
                            lstrcpyW (pInfo->szDataSourceFile, cszWMI);
                            pInfo->cchBufferLength = dwFileNameLength;
                        } else {
                            // buffer is too small for the file name
                            // so return the required size but no string
                            *pInfo->szDataSourceFile = 0;
                            pInfo->cchBufferLength = dwFileNameLength;
                        }
                    } else if (IsDlgButtonChecked (hDlg, IDC_PERF_REG) == 1) {
                        // then current activity is selected so set flags
                        pInfo->dwFlags = PDHI_DATA_SOURCE_CURRENT_ACTIVITY;
                        *pInfo->szDataSourceFile = 0;
                        pInfo->cchBufferLength = 0;
                    } else {
                        assert (FALSE); // no button is pressed.
                    }
                } else if (IsDlgButtonChecked (hDlg, IDC_DATA_FROM_LOG_FILE) == 1) {
                    // then a log file is selected so get the log file name
                    pInfo->dwFlags = PDHI_DATA_SOURCE_LOG_FILE;
                    dwFileNameLength = (DWORD)SendDlgItemMessageW (hDlg,
                        IDC_LOG_FILE_EDIT, WM_GETTEXTLENGTH, 0, 0);
                    if (dwFileNameLength < pInfo->cchBufferLength) {
                        pInfo->cchBufferLength = (DWORD)SendDlgItemMessageW (hDlg,
                            IDC_LOG_FILE_EDIT, WM_GETTEXT,
                            (WPARAM)pInfo->cchBufferLength,
                            (LPARAM)pInfo->szDataSourceFile);
                    } else {
                        // buffer is too small for the file name
                        // so return the required size but no string
                        *pInfo->szDataSourceFile = 0;
                        pInfo->cchBufferLength = dwFileNameLength;
                    }
                }
                SetCursor (hOldCursor);
                EndDialog (hDlg, IDOK);
            } else {
                // unable to locate data block so no data can be returned.
                EndDialog (hDlg, IDCANCEL);
            }

            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
DataSrcDlg_CANCEL (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case BN_CLICKED:
            EndDialog (hDlg, IDCANCEL);
            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
DataSrcDlg_HELP_BTN (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    UNREFERENCED_PARAMETER (hDlg);
    UNREFERENCED_PARAMETER (wNotifyMsg);
    UNREFERENCED_PARAMETER (hWndControl);

    return FALSE;
}

STATIC_BOOL
DataSrcDlg_WM_INITDIALOG (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    // LPARAM is the pointer to the structure used for the data source info
    BOOL    bReturn = TRUE;
    PPDHI_DATA_SOURCE_INFO  pInfo;
    HCURSOR hOldCursor;
    int     nButton;
    int     nShowEdit;
    int     nShowBrowse;
    int     nShowRegBtn;
    int     nShowWbemBtn;
    HWND    hwndFocus;
    LPWSTR  szDisplayString;

    UNREFERENCED_PARAMETER (wParam);

    hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

    // must have a pointer to the information structure in the LPARAM
    if (lParam == 0) {
        SetLastError (PDH_INVALID_ARGUMENT);
        EndDialog (hDlg, IDCANCEL);
        goto INIT_EXIT;
    }

    pInfo = (PPDHI_DATA_SOURCE_INFO)lParam;
    SetWindowLongPtrW (hDlg, DWLP_USER, (LONG_PTR)pInfo);

    // initialize the dialog box settings

    SendDlgItemMessageW (hDlg, IDC_LOG_FILE_EDIT, EM_LIMITTEXT,
        (WPARAM)MAX_PATH-1, 0);

    if (pInfo->dwFlags & PDHI_DATA_SOURCE_CURRENT_ACTIVITY) {
        // check the correct radio button
        nButton = IDC_PERF_REG;
        nShowEdit = FALSE;
        nShowBrowse = FALSE;
        nShowRegBtn = TRUE;
        nShowWbemBtn = TRUE;
        hwndFocus = GetDlgItem(hDlg, IDC_PERF_REG);
    } else if (pInfo->dwFlags & PDHI_DATA_SOURCE_LOG_FILE) {
        // check the correct radio button
        nButton = IDC_DATA_FROM_LOG_FILE;
        nShowEdit = TRUE;
        nShowBrowse = TRUE;
        nShowRegBtn = FALSE;
        nShowWbemBtn = FALSE;
        // load log file to edit window
        SendDlgItemMessageW (hDlg, IDC_LOG_FILE_EDIT, WM_SETTEXT,
            (WPARAM)0, (LPARAM)pInfo->szDataSourceFile);

        hwndFocus = GetDlgItem(hDlg, IDC_LOG_FILE_EDIT);
    } else if (pInfo->dwFlags & PDHI_DATA_SOURCE_WBEM_NAMESPACE) {
        // check the correct radio button
        nButton = IDC_WBEM_NS;
        nShowEdit = FALSE;
        nShowBrowse = FALSE;
        nShowRegBtn = TRUE;
        nShowWbemBtn = TRUE;
        // if the file name has a "WBEM:" in the front, then remove it
        if (DataSourceTypeW(pInfo->szDataSourceFile) == DATA_SOURCE_WBEM) {
            if (wcsncmp(pInfo->szDataSourceFile,
                        cszWBEM, lstrlenW(cszWBEM)) == 0) {
                szDisplayString = & pInfo->szDataSourceFile[lstrlenW(cszWBEM)];
            }
            else {
                szDisplayString = & pInfo->szDataSourceFile[lstrlenW(cszWMI)];
            }
        } else {
            szDisplayString = &pInfo->szDataSourceFile[0];
        }
        hwndFocus = GetDlgItem(hDlg, IDC_WBEM_NS);
    } else {
        // invalid selection
        SetLastError (PDH_INVALID_ARGUMENT);
        EndDialog (hDlg, IDCANCEL);
        goto INIT_EXIT;
    }

    if (nShowEdit) {
        // if this isn't selected, then set it so that it acts like the
        // default
        CheckRadioButton (hDlg, IDC_PERF_REG, IDC_WBEM_NS,
            IDC_PERF_REG);
        CheckRadioButton (hDlg, IDC_CURRENT_ACTIVITY, IDC_DATA_FROM_LOG_FILE,
            IDC_DATA_FROM_LOG_FILE);
    } else {
        CheckRadioButton (hDlg, IDC_CURRENT_ACTIVITY, IDC_DATA_FROM_LOG_FILE,
            IDC_CURRENT_ACTIVITY);
        CheckRadioButton (hDlg, IDC_PERF_REG, IDC_WBEM_NS,
            nButton);
    }

    // disable the edit window and browser button
    EnableWindow (GetDlgItem (hDlg, IDC_LOG_FILE_EDIT), nShowEdit);
    EnableWindow (GetDlgItem (hDlg, IDC_BROWSE_LOG_FILES), nShowBrowse);
    EnableWindow (GetDlgItem (hDlg, IDC_PERF_REG), nShowRegBtn);
    EnableWindow (GetDlgItem (hDlg, IDC_WBEM_NS), nShowWbemBtn);

    SetFocus (hwndFocus);
    bReturn = FALSE;

INIT_EXIT:
    // restore Cursor
    SetCursor (hOldCursor);

    return bReturn;
}

STATIC_BOOL
DataSrcDlg_WM_COMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    WORD    wNotifyMsg;

    wNotifyMsg = HIWORD(wParam);

    switch (LOWORD(wParam)) {   // select on the control ID
        case IDOK:
            return DataSrcDlg_OK (hDlg, wNotifyMsg, (HWND)lParam);

        case IDCANCEL:
            return DataSrcDlg_CANCEL (hDlg, wNotifyMsg, (HWND)lParam);

        case IDC_HELP_BTN:
            return DataSrcDlg_HELP_BTN (hDlg, wNotifyMsg, (HWND)lParam);

        case IDC_BROWSE_LOG_FILES:
            return DataSrcDlg_BROWSE_LOG_FILES (hDlg, wNotifyMsg, (HWND)lParam);

        case IDC_CURRENT_ACTIVITY:
        case IDC_DATA_FROM_LOG_FILE:
        case IDC_PERF_REG:
        case IDC_WBEM_NS:
            return DataSrcDlg_RadioButton (hDlg, wNotifyMsg, LOWORD(wParam));
        default:
            return FALSE;
    }
}

STATIC_BOOL
DataSrcDlg_WM_SYSCOMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER (lParam);

    switch (wParam) {
        case SC_CLOSE:
            EndDialog (hDlg, IDOK);
            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
DataSrcDlg_WM_CLOSE (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER (hDlg);
    UNREFERENCED_PARAMETER (wParam);
    UNREFERENCED_PARAMETER (lParam);

    return TRUE;
}

STATIC_BOOL
DataSrcDlg_WM_DESTROY (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER (hDlg);
    UNREFERENCED_PARAMETER (wParam);
    UNREFERENCED_PARAMETER (lParam);

    return TRUE;
}

INT_PTR
CALLBACK
DataSrcDlgProc (
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    INT  iCtrlID;
    BOOL bReturn = FALSE;
    iCtrlID = GetDlgCtrlID ( (HWND) wParam );

    switch (message) {
        case WM_INITDIALOG:
            return DataSrcDlg_WM_INITDIALOG (hDlg, wParam, lParam);

        case WM_COMMAND:
            return DataSrcDlg_WM_COMMAND (hDlg, wParam, lParam);

        case WM_SYSCOMMAND:
            return DataSrcDlg_WM_SYSCOMMAND (hDlg, wParam, lParam);

        case WM_CLOSE:
            return DataSrcDlg_WM_CLOSE (hDlg, wParam, lParam);

        case WM_DESTROY:
            return DataSrcDlg_WM_DESTROY (hDlg, wParam, lParam);

        case WM_CONTEXTMENU:
            {
                if ( 0 != iCtrlID ) {
                    TCHAR pszHelpFilePath[MAX_PATH * 2];
                    UINT nLen;

                    nLen = GetWindowsDirectory(pszHelpFilePath, 2*MAX_PATH);
                    lstrcpy(&pszHelpFilePath[nLen], _T("\\help\\sysmon.hlp") );


                    bReturn = WinHelp(
                        (HWND) wParam,
                        pszHelpFilePath,
                        HELP_CONTEXTMENU,
                        (DWORD_PTR) PdhiDatasrcaulControlIdToHelpIdMap);
                }

                return bReturn;
            }

        case WM_HELP:
            {
                
                // Only display help for known context IDs.
                TCHAR pszHelpFilePath[MAX_PATH * 2];
                UINT nLen;
                LPHELPINFO pInfo = NULL;
                pInfo = (LPHELPINFO)lParam;

                nLen = GetWindowsDirectory(pszHelpFilePath, 2*MAX_PATH);
                if ( nLen == 0 ) {
                    // Report error.
                }

                lstrcpy(&pszHelpFilePath[nLen], _T("\\help\\sysmon.hlp") );
                if (pInfo->iContextType == HELPINFO_WINDOW){
                    bReturn = WinHelp ( 
                            pInfo->hItemHandle,
                            pszHelpFilePath,
                            HELP_WM_HELP,
                            (DWORD_PTR) PdhiDatasrcaulControlIdToHelpIdMap);
                }

                return bReturn;
            } 
            

        default:
            return FALSE;
    }
}

PDH_FUNCTION
PdhSelectDataSourceW (
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPWSTR  szDataSource,
    IN  LPDWORD pcchBufferLength
)
{
    PDHI_DATA_SOURCE_INFO   dsInfo;
    WCHAR                   wTest;
    DWORD                   dwTest;
    PDH_STATUS              pdhStatus = ERROR_SUCCESS;
    int                     nDlgBoxStatus;
    LPWSTR                  szLocalPath;
    DWORD                   dwLocalLength = 0;

    // TODO post W2k1: PdhiBrowseDataSource should be in try_except

    if ((szDataSource == NULL) || (pcchBufferLength == NULL))
        pdhStatus = PDH_INVALID_ARGUMENT;
    else {
        // test buffers and access
        __try {
            // test reading length buffer
            dwLocalLength = *pcchBufferLength;
            dwTest = dwLocalLength;

            // try reading & writing to the first and last chars in the buffer
            wTest = szDataSource[0];
            szDataSource[0] = 0;
            szDataSource[0] = wTest;

            dwTest--;
            wTest = szDataSource[dwTest];
            szDataSource[dwTest] = 0;
            szDataSource[dwTest] = wTest;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        szLocalPath = G_ALLOC ((dwLocalLength * sizeof(WCHAR)));

        if (szLocalPath == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        } else {
            // copy the caller's buffer to the local buffer
            memcpy (&szLocalPath[0], szDataSource,
                (dwLocalLength * sizeof(WCHAR)));
        }

        if (pdhStatus == ERROR_SUCCESS) {
            if (dwFlags & PDH_FLAGS_FILE_BROWSER_ONLY) {
                PdhiBrowseDataSource (
                    hWndOwner,
                    (LPVOID)szDataSource,
                    &dwLocalLength,
                    TRUE);
            } else {
                // show the selection dialog as well
                if (*szDataSource == 0) {
                    // then using current activity
                    dsInfo.dwFlags = PDHI_DATA_SOURCE_CURRENT_ACTIVITY;
                } else {
                    if (IsWbemDataSource (szDataSource)) {
                        dsInfo.dwFlags = PDHI_DATA_SOURCE_WBEM_NAMESPACE;
                    } else {
                        dsInfo.dwFlags = PDHI_DATA_SOURCE_LOG_FILE;
                    }
                }
                dsInfo.szDataSourceFile = szLocalPath;
                dsInfo.cchBufferLength = dwLocalLength;

                // call dialog box
                nDlgBoxStatus = (INT)DialogBoxParamW (
                    (HINSTANCE)ThisDLLHandle,
                    MAKEINTRESOURCEW (IDD_DATA_SOURCE),
                    hWndOwner,
                    DataSrcDlgProc,
                    (LPARAM)&dsInfo);

                if (nDlgBoxStatus == IDOK) {
                    pdhStatus = ERROR_SUCCESS;
                    dwLocalLength = dsInfo.cchBufferLength;
                    __try {
                        memcpy (szDataSource, &szLocalPath[0],
                            (dwLocalLength * sizeof(WCHAR)));
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } // else, leave the caller's buffer alone
            }

            if (pdhStatus == ERROR_SUCCESS) {
                __try {
                    *pcchBufferLength = dwLocalLength;
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }

        if (szLocalPath != NULL) {
            G_FREE (szLocalPath);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhSelectDataSourceA (
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPSTR   szDataSource,
    IN  LPDWORD pcchBufferLength
)
{
    CHAR                    cTest;
    DWORD                   dwTest;
    PDH_STATUS              pdhStatus = ERROR_SUCCESS;
    LPWSTR                  szWideBuffer;
    DWORD                   dwLocalLength = 0;

    // TODO post W2k1: PdhiBrowseDataSource should be in try_except

    if ((szDataSource == NULL) || (pcchBufferLength == NULL))
        pdhStatus = PDH_INVALID_ARGUMENT;
    else {
        // test buffers and access
        __try {
            // test reading length buffer
            dwLocalLength = *pcchBufferLength;
            dwTest = dwLocalLength;

            // try reading & writing to the first and last chars in the buffer
            cTest = szDataSource[0];
            szDataSource[0] = 0;
            szDataSource[0] = cTest;

            dwTest--;
            cTest = szDataSource[dwTest];
            szDataSource[dwTest] = 0;
            szDataSource[dwTest] = cTest;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwFlags & PDH_FLAGS_FILE_BROWSER_ONLY) {
            PdhiBrowseDataSource (
                hWndOwner,
                (LPVOID)szDataSource,
                & dwLocalLength,
                FALSE);
        } else {
            // allocate a temporary bufer and convert the ANSI string to a wide
            szWideBuffer = G_ALLOC ((dwLocalLength * sizeof(WCHAR)));
            if (szWideBuffer != NULL) {
                MultiByteToWideChar(_getmbcp(),
                                    0,
                                    szDataSource,
                                    lstrlenA(szDataSource),
                                    (LPWSTR) szWideBuffer,
                                    dwLocalLength);
                pdhStatus = PdhSelectDataSourceW (
                    hWndOwner, dwFlags, szWideBuffer, &dwLocalLength);
                if (pdhStatus == ERROR_SUCCESS) {
                    // if a null string was returned, then set the argument
                    // to null since the conversion routine will not convert
                    // a null wide string to a null ansi string.
                    if (*szWideBuffer == 0) {
                        *szDataSource =  0;
                    } else {
                        pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                szWideBuffer, szDataSource, & dwLocalLength);
                    }
                }
                G_FREE (szWideBuffer);
            } else {
                // unable to allocate temporary buffer
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }

        if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
            __try {
                *pcchBufferLength = dwLocalLength;
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhui\browser.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    browser.c

Abstract:

    counter name browsing functions exposed by the PDH.DLL

--*/
#include <windows.h>
#include <pdh.h>
#include <stdlib.h>
#include <math.h>
#include <mbctype.h>
#include <assert.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhdlgs.h"
#include "perfdata.h"
#include "browsdlg.h"
#include "pdhui.h"

#pragma warning ( disable : 4213)

#ifndef _USE_WBEM_ONLY
#define _USE_WBEM_ONLY 0
#endif

#define    DEFAULT_NULL_DATA_SOURCE     DATA_SOURCE_REGISTRY

PDH_FUNCTION
PdhSetDefaultRealTimeDataSource (
    IN  DWORD   dwDataSourceId
)
{
    DWORD   dwReturn = ERROR_SUCCESS;

    if (dwCurrentRealTimeDataSource <= 0) {
        switch (dwDataSourceId) {
        case DATA_SOURCE_WBEM:
        case DATA_SOURCE_REGISTRY:
            // this is OK so set local variable
            dwPdhiLocalDefaultDataSource = dwDataSourceId;
            break;
        case DATA_SOURCE_LOGFILE:
        default:
            // these are not OK so insert default
            dwReturn = PDH_INVALID_ARGUMENT;
            break;
        }
    } else {
        // a default realtime data source has already been defined
        dwReturn = PDH_CANNOT_SET_DEFAULT_REALTIME_DATASOURCE;
    }
    return dwReturn;
}

DWORD
DataSourceTypeH(
    IN HLOG hDataSource
)
{
    if (hDataSource == H_REALTIME_DATASOURCE) {
#if _USE_WBEM_ONLY
        return DATA_SOURCE_WBEM;
#else
        return dwPdhiLocalDefaultDataSource;
#endif
    }
    else if (hDataSource == H_WBEM_DATASOURCE) {
        return DATA_SOURCE_WBEM;
    }
    else {
        return DATA_SOURCE_LOGFILE;
    }
}

DWORD
DataSourceTypeA (
    IN LPCSTR   szDataSource
)
{
    if (szDataSource == NULL) {
#if _USE_WBEM_ONLY
        return DATA_SOURCE_WBEM;
#else
        //normal
        return dwPdhiLocalDefaultDataSource;
#endif
    } else {
        // see if the prefix to the file name is "WBEM:"
        // indicating this is a WBEM name space instead of a
        // log file name
        // if the file name has a "WBEM:" in the front, then
        // set the flag appropriately

        if (   strncmp(szDataSource, caszWBEM, lstrlenA(caszWBEM)) != 0
            && strncmp(szDataSource, caszWMI,  lstrlenA(caszWMI)) != 0) {
            return DATA_SOURCE_LOGFILE;
        }

        return DATA_SOURCE_WBEM;
    }   
}

DWORD
DataSourceTypeW (
    IN LPCWSTR  szDataSource
)
{
    if (szDataSource == NULL) {
#if _USE_WBEM_ONLY
        return DATA_SOURCE_WBEM;
#else
        //normal
        return dwPdhiLocalDefaultDataSource;
#endif
    } else {
        // see if the prefix to the file name is "WBEM:"
        // indicating this is a WBEM name space instead of a
        // log file name
        // if the file name has a "WBEM:" in the front, then
        // set the flag appropriately
        // Else check if it is "SQL:" prefixed

        if (   wcsncmp(szDataSource, cszWBEM, lstrlenW(cszWBEM)) != 0
            && wcsncmp(szDataSource, cszWMI,  lstrlenW(cszWMI)) != 0) {
            return DATA_SOURCE_LOGFILE;
        }

        return DATA_SOURCE_LOGFILE;
    }
}

PDH_FUNCTION
PdhConnectMachineW (
    IN      LPCWSTR  szMachineName
)
/*++

Routine Description:

  Establishes a connection to the specified machine for reading perforamance
  data from the machine.

Arguments:

    LPCWSTR szMachineName
        The name of the machine to connect to. If this argument is NULL,
        then the local machine is opened.

Return Value:

  PDH Error status value
    ERROR_SUCCESS   indicates the machine was successfully connected and the
        performance data from that machine was loaded.
    PDH_ error code indicates that the machine could not be located or opened.
        The status code indicates the problem.

--*/
{
    PPERF_MACHINE   pMachine    = NULL;
    PDH_STATUS      pdhStatus   = ERROR_SUCCESS;

    DebugPrint((4, "PdhConnectMachineW BEGIN 0x%08X\n", szMachineName));

    if (szMachineName != NULL) {
        __try {
            WCHAR   wChar;
            // test buffer access
            wChar = *szMachineName;
            if (wChar == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine ((LPWSTR)szMachineName, 0);

        if (pMachine != NULL) {
            // then return the machine status
            pdhStatus = pMachine->dwStatus;
            pMachine->dwRefCount--;
            RELEASE_MUTEX (pMachine->hMutex);
        } else {
            // return the status from the GetMachine call
            pdhStatus = GetLastError();
        }
    } // else pass the status to the caller

    DebugPrint((4, "PdhConnectMachineW END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

PDH_FUNCTION
PdhConnectMachineA (
    IN      LPCSTR  szMachineName
)
/*++

Routine Description:

  Establishes a connection to the specified machine for reading perforamance
  data from the machine.

Arguments:

    LPCSTR  szMachineName
        The name of the machine to connect to. If this argument is NULL,
        then the local machine is opened.

Return Value:

  PDH Error status value
    ERROR_SUCCESS   indicates the machine was successfully connected and the
        performance data from that machine was loaded.
    PDH_ error code indicates that the machine could not be located or opened.
        The status code indicates the problem.

--*/
{
    LPWSTR      szWideName      = NULL;
    DWORD       dwNameLength    = 0;
    PDH_STATUS  pdhStatus       = ERROR_SUCCESS;
    PPERF_MACHINE   pMachine    = NULL;


    DebugPrint((4, "PdhConnectMachineA BEGIN 0x%08X\n", szMachineName));

    if (szMachineName != NULL) {
        __try {
            WCHAR   wChar;
            // test buffer access
            wChar = *szMachineName;
            if (wChar != 0) {
                if (pdhStatus == ERROR_SUCCESS) {
                    dwNameLength = lstrlenA (szMachineName);
                } else {
                    dwNameLength = 0;
                }
            } else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        if (pdhStatus == ERROR_SUCCESS) {
            szWideName = G_ALLOC ((dwNameLength+1) * sizeof(WCHAR));
            if (szWideName == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            } else {
                __try {
                    MultiByteToWideChar(_getmbcp(),
                                        0,
                                        szMachineName,
                                        dwNameLength,
                                        szWideName,
                                        dwNameLength + 1);
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
    } else {
        szWideName = NULL;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine (szWideName, 0);

        if (pMachine != NULL) {
            // then return the machine status
            pdhStatus = pMachine->dwStatus;
            pMachine->dwRefCount--;
            RELEASE_MUTEX (pMachine->hMutex);
        } else {
            // return the status from the GetMachine call
            pdhStatus = GetLastError();
        }
    }

    if (szWideName != NULL) G_FREE (szWideName);

    DebugPrint((4, "PdhConnectMachineA END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

STATIC_PDH_FUNCTION
PdhiEnumConnectedMachines (
    IN      LPVOID  pMachineList,
    IN      LPDWORD pcchBufferSize,
    IN      BOOL    bUnicode
)
/*++

Routine Description:

    Builds a MSZ list of the machines currently known by the PDH. This
        list includes machines with open sessions as well as those that
        are off-line.

Arguments:

    IN      LPVOID  pMachineList
            A pointer to the buffer to receive the enumerated machine list.
            The strings written to this buffer will contain the characters
            specified by the bUnicode argument
    IN      LPVOID  pMachineList
            A pointer to the buffer to receive the enumerated machine list.
            The strings written to this buffer will contain the characters
            specified by the bUnicode argument

    IN      LPDWORD pcchBufferSize
            The size of the buffer referenced by pMachineList in characters

    IN      BOOL    bUnicode
            TRUE = UNICODE characters will be written to the pMachineList
                    buffer
            FALSE = ANSI characters will be writtn to the pMachinList buffer

Return Value:

    ERROR_SUCCESS if this the function completes successfully. a PDH error
        value if not.
    PDH_MORE_DATA some entries were returned, but there was not enough
        room in the buffer to store all entries.
    PDH_INSUFFICIENT_BUFFER there was not enough room in the buffer to
        store ANY data
    PDH_INVALID_ARGUMENT unable to write to the size buffers or the
        data buffer

--*/
{
    PPERF_MACHINE   pThisMachine;
    DWORD           dwRequiredLength = 0;
    DWORD           dwMaximumLength;
    DWORD           dwNameLength;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    LPVOID          szNextName;


    DebugPrint((4, "PdhiEnumConnectedMachines BEGIN\n"));
    // reset the last error value
    SetLastError (ERROR_SUCCESS);

    // first walk down list to compute required length

    pThisMachine = pFirstMachine;

    __try {

        // get a local copy of the size and try writing to the variable
        // to test read & write access of args before continuing

        dwMaximumLength = *pcchBufferSize;
        *pcchBufferSize = 0;
        *pcchBufferSize = dwMaximumLength;

        // point to first machine entry in list
        szNextName = pMachineList;

        // walk around entire list
        if (pThisMachine != NULL) {
            do {
                if (bUnicode) {
                    dwNameLength = lstrlenW(pThisMachine->szName) + 1;
                    if (   szNextName != NULL
                        && dwRequiredLength + dwNameLength <= dwMaximumLength) {
                        lstrcpyW ((LPWSTR) szNextName, pThisMachine->szName);
                        (LPBYTE) szNextName += sizeof(WCHAR) * (dwNameLength - 1);
                        * ((LPWSTR) szNextName) ++ = 0;
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }
                else {
                    dwNameLength = (dwRequiredLength <= dwMaximumLength)
                                 ? (dwMaximumLength - dwRequiredLength) : (0);
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                            pThisMachine->szName,
                            (LPSTR) szNextName,
                            & dwNameLength);
                    if (pdhStatus == ERROR_SUCCESS) {
                        (LPBYTE) szNextName += sizeof(CHAR) * dwNameLength;
                    }
                }
                dwRequiredLength += dwNameLength;
                // go to next machine in list
                pThisMachine = pThisMachine->pNext;
            } while (pThisMachine != pFirstMachine);
        } else {
            // no machines in list, so insert an empty string
            if (++dwRequiredLength <= dwMaximumLength) {
                if (bUnicode) {
                    *((LPWSTR)szNextName)++ = 0;
                } else {
                    *((LPSTR)szNextName)++ = 0;
                }
                pdhStatus = ERROR_SUCCESS;
            } else if (dwMaximumLength != 0) {
                // then the buffer is too small
                pdhStatus = PDH_MORE_DATA;
            }
        }
        // all entries have been checked and /or copied
        //  so terminate the MSZ or at least account for the required size
        dwRequiredLength ++;
        if (szNextName != NULL && dwRequiredLength <= dwMaximumLength) {
            if (bUnicode) {
                *((LPWSTR)szNextName)++ = 0;
            } else {
                *((LPSTR)szNextName)++ = 0;
            }
            pdhStatus = ERROR_SUCCESS;
        } else {
            // then the buffer is too small
            pdhStatus = PDH_MORE_DATA;
        }
        //return the required size or size used
        *pcchBufferSize = dwRequiredLength;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    DebugPrint((4, "PdhiEnumConnectedMachines END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumMachinesHW (
    IN HLOG    hDataSource,
    IN LPWSTR  mszMachineList,
    IN LPDWORD pcchBufferSize
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD      dwBufferSize = 0;
    DWORD      dwDataSource = 0;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwDataSource = DataSourceTypeH(hDataSource);

            if (pdhStatus == ERROR_SUCCESS) {
                dwBufferSize = *pcchBufferSize;
            }
            if ((dwBufferSize * sizeof(WCHAR)) >= sizeof(DWORD)) {
                // test writing to the buffers to make sure they are valid
                CLEAR_FIRST_FOUR_BYTES (mszMachineList);
                mszMachineList[dwBufferSize -1] = 0;
            } else if ((dwBufferSize * sizeof(WCHAR)) >= sizeof(WCHAR)) {
                // then just try the first byte
                *mszMachineList = 0;
            } else if (dwBufferSize != 0) {
                // it's smaller than a character so return if not 0
                pdhStatus = PDH_MORE_DATA;
            }
        }
         __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pdhStatus = PdhiEnumConnectedMachines (
                    (LPVOID)mszMachineList,
                    &dwBufferSize,
                    TRUE);
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiEnumWbemMachines (
                    (LPVOID)mszMachineList,
                    &dwBufferSize,
                    TRUE);
                break;

            case DATA_SOURCE_LOGFILE:
                pdhStatus = PdhiEnumLoggedMachines (
                            hDataSource,
                            (LPVOID) mszMachineList,
                            & dwBufferSize,
                            TRUE);
                break;

            default:
                assert (FALSE); // unknown data source type
            }
        }
         __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        RELEASE_MUTEX (hPdhDataMutex);
        __try {
            *pcchBufferSize = dwBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }


    return pdhStatus;
}

PDH_FUNCTION
PdhEnumMachinesW (
    IN      LPCWSTR  szDataSource,
    IN      LPWSTR   mszMachineList,
    IN      LPDWORD  pcchBufferSize
)
/*++

Routine Description:

    Builds a MSZ list of the machines currently known by the PDH. This
        list includes machines with open sessions as well as those that
        are off-line.

Arguments:

    IN      LPCWSTR  szDataSource
            NULL for current real-time data or the name of a log file

    IN      LPWSTR  szMachineList
            A pointer to the buffer to receive the enumerated machine list.
            The strings written to this buffer will contain UNICODE chars

    IN      LPDWORD pcchBufferSize
            The size of the buffer referenced by pMachineList in characters
            The value of the buffer referenced by this pointer may be 0
            if the required size is requested.

Return Value:

    ERROR_SUCCESS if this the function completes successfully. a PDH error
        value if not.
    PDH_MORE_DATA some entries were returned, but there was not enough
        room in the buffer to store all entries.
    PDH_INSUFFICIENT_BUFFER there was not enough room in the buffer to
        store ANY data
    PDH_INVALID_ARGUMENT unable to write to the size buffers or the
        data buffer

--*/
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwDataSource = 0;
    HLOG        hDataSource = H_REALTIME_DATASOURCE;

    DebugPrint((4, "PdhEnumMachinesW BEGIN\n"));
    __try {
        if (szDataSource != NULL) {
            WCHAR       TestChar;
            // test for read access to the name
            TestChar = *szDataSource;
            if (TestChar == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg

        dwDataSource = DataSourceTypeW (szDataSource);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogW(
                    szDataSource,
                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                    & dwLogType,
                    NULL,
                    0,
                    NULL,
                    & hDataSource);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumMachinesHW(hDataSource,
                                      mszMachineList,
                                      pcchBufferSize);

        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }

    DebugPrint((4, "PdhEnumMachinesW END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumMachinesHA (
    IN HLOG hDataSource,
    IN      LPSTR    mszMachineList,
    IN      LPDWORD  pcchBufferSize
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwBufferSize = 0;
    DWORD       dwDataSource = 0;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {        
        __try {
            dwDataSource = DataSourceTypeH(hDataSource);
            dwBufferSize = *pcchBufferSize;
            if (dwBufferSize >= sizeof (DWORD)) {
                // test writing to the buffers to make sure they are valid
                CLEAR_FIRST_FOUR_BYTES (mszMachineList);
                mszMachineList[dwBufferSize -1] = 0;
            } else if (dwBufferSize >= sizeof(CHAR)) {
                *mszMachineList = 0;
            }
        }
         __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pdhStatus = PdhiEnumConnectedMachines (
                    (LPVOID)mszMachineList,
                    &dwBufferSize,
                    FALSE);
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiEnumWbemMachines (
                            (LPVOID)mszMachineList,
                            &dwBufferSize,
                            FALSE);
                break;

            case DATA_SOURCE_LOGFILE:
                pdhStatus = PdhiEnumLoggedMachines (
                            hDataSource,
                            (LPVOID) mszMachineList,
                            & dwBufferSize,
                            FALSE);
                break;

            default:
                assert (FALSE);
            }
        }
         __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX (hPdhDataMutex);
        __try {
            *pcchBufferSize = dwBufferSize;
        }
         __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }


    return pdhStatus;
}

PDH_FUNCTION
PdhEnumMachinesA (
    IN      LPCSTR   szDataSource,
    IN      LPSTR    mszMachineList,
    IN      LPDWORD  pcchBufferSize
)
/*++

Routine Description:

    Builds a MSZ list of the machines currently known by the PDH. This
        list includes machines with open sessions as well as those that
        are off-line.

Arguments:

    IN      LPCSTR  szDataSource
            NULL for current real-time data or the name of a log file

    IN      LPWSTR  szMachineList
            A pointer to the buffer to receive the enumerated machine list.
            The strings written to this buffer will contain UNICODE chars

    IN      LPDWORD pcchBufferSize
            The size of the buffer referenced by pMachineList in characters
            The value of the buffer referenced by this pointer may be 0
            if the required size is requested.

Return Value:

    ERROR_SUCCESS if this the function completes successfully. a PDH error
        value if not.
    PDH_MORE_DATA some entries were returned, but there was not enough
        room in the buffer to store all entries.
    PDH_INSUFFICIENT_BUFFER there was not enough room in the buffer to
        store ANY data
    PDH_INVALID_ARGUMENT unable to write to the size buffers or the
        data buffer

--*/
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwDataSource = 0;
    HLOG        hDataSource = H_REALTIME_DATASOURCE;

    DebugPrint((4, "PdhEnumMachinesA BEGIN\n"));
    __try {
        if (szDataSource != NULL) {
            CHAR       TestChar;
            // test for read access to the name
            TestChar = *szDataSource;
            if (TestChar == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg

        dwDataSource = DataSourceTypeA(szDataSource);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogA(
                    szDataSource,
                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                    & dwLogType,
                    NULL,
                    0,
                    NULL,
                    & hDataSource);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumMachinesHA(hDataSource,
                                      mszMachineList,
                                      pcchBufferSize);

        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }

    DebugPrint((4, "PdhEnumMachinesA END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

#pragma warning ( disable : 4127 )
PDH_FUNCTION
PdhiEnumObjects (
    IN      LPWSTR  szMachineName,
    IN      LPVOID  mszObjectList,
    IN      LPDWORD pcchBufferSize,
    IN      DWORD   dwDetailLevel,
    IN      BOOL    bRefresh,
    IN      BOOL    bUnicode
)
/*++

Routine Description:

    Lists the performance objects found on the specified machine as
        a MSZ list.

Arguments:

    IN      LPWSTR  szMachineName
            The machine to list objects from

    IN      LPVOID  mszObjectList
            a pointer to the  buffer to receive the list of performance
            objects

    IN      LPDWORD pcchBufferSize
            a pointer to the DWORD containing the size of the mszObjectList
            buffer in characters. The characters assumed are determined by
            the bUnicode argument.

    IN      DWORD   dwDetailLevel
            The detail level to use as a filter of objects. All objects
            with a detail level less than or equal to that specified
            by this argument will be returned.

    IN      BOOL    bRefresh
            TRUE = retrive a new perf. data buffer for this machine before
                listing the objects
            FALSE = use the currently cached perf data buffer for this
                machine to enumerate objects

    IN      BOOL    bUnicode
            TRUE = return the listed objects as UNICODE strings
            FALSE = return the listed objects as ANSI strings

Return Value:
    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_INSUFFICIENT_BUFFER is returned when there is not enough
        room in the buffer for ANY data.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.

--*/
{
    PPERF_MACHINE       pMachine;
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    DWORD               NumTypeDef;
    PERF_OBJECT_TYPE    *pObjectDef;
    PERF_OBJECT_TYPE    *pEndOfBuffer;
    DWORD               dwRequiredLength = 0;
    LPVOID              szNextName;
    DWORD               dwNameLength;
    DWORD               dwMaximumLength;
    LPWSTR              szObjNameString;
    WCHAR               wszNumberString[32];
    DWORD               dwGmFlags;
    DWORD               dwLocalDetailLevel;

    DebugPrint((4, "PdhiEnumObjects BEGIN\n"));

    // connect to machine and update data if desired
    if (bRefresh) {
        dwGmFlags = PDH_GM_UPDATE_PERFDATA;
        dwGmFlags |= ((dwDetailLevel & PERF_DETAIL_COSTLY) == PERF_DETAIL_COSTLY) ?
                        PDH_GM_READ_COSTLY_DATA : 0;
    } else {
        dwGmFlags = 0;
    }

    // connect to machine and update data if desired
    pMachine = GetMachine (szMachineName,
        (bRefresh ? PDH_GM_UPDATE_PERFDATA : 0));

    dwMaximumLength = *pcchBufferSize;

    if (pMachine != NULL) {
        if (pMachine->dwStatus == ERROR_SUCCESS) {
            if ((dwDetailLevel & PERF_DETAIL_COSTLY) &&
                !(pMachine->dwMachineFlags & PDHIPM_FLAGS_HAVE_COSTLY)) {
                // then get them
                dwGmFlags = PDH_GM_UPDATE_PERFDATA | PDH_GM_READ_COSTLY_DATA;
                pMachine = GetMachine (szMachineName, dwGmFlags);
            }
        }
    }

    if (pMachine != NULL) {
        // make sure the machine connection is valid
        if (pMachine->dwStatus == ERROR_SUCCESS) {
            dwRequiredLength = 0;
            szNextName = mszObjectList;

            // start walking object list
            pObjectDef = FirstObject(pMachine->pSystemPerfData);
            pEndOfBuffer = (PPERF_OBJECT_TYPE)
                            ((DWORD_PTR)pMachine->pSystemPerfData +
                                pMachine->pSystemPerfData->TotalByteLength);
            if ((pMachine->pSystemPerfData->NumObjectTypes > 0) &&
                (pObjectDef != NULL)) {
                // convert detail level to the PerfLib detail level
                dwLocalDetailLevel = dwDetailLevel & PERF_DETAIL_STANDARD;
                // build list
                NumTypeDef = 0;
                while (1) {
                    // only look at entries matching the desired Detail Level
                    if (pObjectDef->DetailLevel <= dwLocalDetailLevel) {
                        if ( pObjectDef->ObjectNameTitleIndex < pMachine->dwLastPerfString ) {
                            szObjNameString =
                                (LPWSTR)PdhiLookupPerfNameByIndex (
                                    pMachine,
                                    pObjectDef->ObjectNameTitleIndex);
                        } else {
                            // no match since the index is larger that that found
                            // in the data buffer
                            szObjNameString = NULL;
                        }

                        if (szObjNameString == NULL) {
                            // then this object has no string name so use
                            // the object number
                            _ltow (pObjectDef->ObjectNameTitleIndex,
                                wszNumberString, 10);
                            szObjNameString = &wszNumberString[0];
                        }

                        // compute length
                        if (bUnicode) {
                            dwNameLength = lstrlenW(szObjNameString) + 1;
                            if (   szNextName != NULL
                                && dwRequiredLength + dwNameLength <= dwMaximumLength) {
                                lstrcpyW ((LPWSTR)szNextName, szObjNameString);
                                (LPBYTE) szNextName += (dwNameLength - 1)
                                                     * sizeof(WCHAR);
                                * ((LPWSTR) szNextName) ++ = 0;
                            }
                            else {
                                pdhStatus = PDH_MORE_DATA;
                            }
                        }
                        else {
                            dwNameLength = (dwRequiredLength <= dwMaximumLength)
                                         ? (dwMaximumLength - dwRequiredLength)
                                         : (0);
                            pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                        szObjNameString,
                                        (LPSTR) szNextName,
                                        & dwNameLength);
                            if (pdhStatus == ERROR_SUCCESS) {
                                (LPBYTE) szNextName += sizeof(CHAR) * dwNameLength;
                            }
                        }

                        dwRequiredLength += dwNameLength;
                    }  else {
                        // this entry is not correct detail level
                        // so skip & continue
                    }

                    // go to next object in the data block
                    NumTypeDef++;
                    if (NumTypeDef >= pMachine->pSystemPerfData->NumObjectTypes) {
                        // that's enough so break out of the loop
                        break;
                    } else {
                        // goto the next one and make sure it's valid
                        pObjectDef = NextObject(pObjectDef); // get next
                        //make sure next object is legit
                        if (pObjectDef != NULL) {
                            if (pObjectDef->TotalByteLength > 0) {
                                if (pObjectDef >= pEndOfBuffer) {
                                    // looks like we ran off the end of the data buffer
                                    assert (pObjectDef < pEndOfBuffer);
                                    break;
                                }
                            } else {
                                // 0-length object buffer returned
                                assert (pObjectDef->TotalByteLength > 0);
                                break;
                            }
                        } else {
                            // and continue
                            assert (pObjectDef != NULL);
                            break;
                        }
                    }
                }
                // add MSZ terminator to string
                ++dwRequiredLength; // add the size of the MSZ char
                if (pdhStatus == ERROR_SUCCESS) {
                    if (dwRequiredLength <= dwMaximumLength) {
                        if (bUnicode) {
                            *((LPWSTR)szNextName)++ = 0;
                        } else {
                            *((LPSTR)szNextName)++ = 0;
                        }
                        // make sure pointers and lengths stay in sync
                    } else if (dwMaximumLength > 0) {
                        pdhStatus = PDH_MORE_DATA;
                    }
                } else {
                    // leave the current error value
                    // but keep the size of the MSZ Null to the required length
                }
            } else {
                // no objects found for this machine
                dwRequiredLength = 2;
                if (dwMaximumLength > 0) {
                    if (dwRequiredLength <= dwMaximumLength) {
                        if (bUnicode) {
                            *((LPWSTR)szNextName)++ = 0;
                            *((LPWSTR)szNextName)++ = 0;
                        } else {
                            *((LPSTR)szNextName)++ = 0;
                            *((LPSTR)szNextName)++ = 0;
                        }
                        // make sure pointers and lengths stay in sync
                    } else {
                        pdhStatus = ERROR_MORE_DATA;
                    }
                } // else this is just a size request
            }
            // return length info
            *pcchBufferSize = dwRequiredLength;
        } else {
            pdhStatus = pMachine->dwStatus;  // computer off line
        }
        pMachine->dwRefCount--;
        RELEASE_MUTEX (pMachine->hMutex);
    } else {
        pdhStatus = GetLastError(); // computer not found
    }
    DebugPrint((4, "PdhiEnumObjects END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}
#pragma warning ( default : 4127 )

PDH_FUNCTION
PdhEnumObjectsHW (
    IN HLOG    hDataSource,
    IN LPCWSTR szMachineName,
    IN LPWSTR  mszObjectList,
    IN LPDWORD pcchBufferSize,
    IN DWORD   dwDetailLevel,
    IN BOOL    bRefresh
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwBufferSize = 0;
    DWORD       dwDataSource = 0;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwDataSource = DataSourceTypeH(hDataSource);
            if (szMachineName != NULL) {
                if (* szMachineName == 0) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            else {
                // NULL is a valid value
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwBufferSize = * pcchBufferSize;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if ((dwBufferSize * sizeof(WCHAR)) >= sizeof(DWORD)) {
                    // test writing to the buffers to make sure they are valid
                    CLEAR_FIRST_FOUR_BYTES (mszObjectList);
                    mszObjectList[dwBufferSize - 1] = 0;
                }
                else if ((dwBufferSize * sizeof(WCHAR)) >= sizeof(WCHAR)) {
                    mszObjectList[0] = 0;
                }
                else if ((dwBufferSize * sizeof(WCHAR)) != 0) {
                    // then the buffer is too small
                    pdhStatus = PDH_MORE_DATA;
                }
                else {
                    // buffer size of 0 is OK as a query for the required size
                }
            }

        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pdhStatus = PdhiEnumObjects (
                    (LPWSTR)szMachineName,
                    (LPVOID)mszObjectList,
                    &dwBufferSize,
                    dwDetailLevel,
                    bRefresh,
                    TRUE);
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiEnumWbemObjects (
                    (LPWSTR)szMachineName,
                    (LPVOID)mszObjectList,
                    &dwBufferSize,
                    dwDetailLevel,  // not used
                    bRefresh,
                    TRUE);
                break;

            case DATA_SOURCE_LOGFILE:
                pdhStatus = PdhiEnumLoggedObjects (
                            hDataSource,
                            (LPWSTR) szMachineName,
                            (LPVOID) mszObjectList,
                            & dwBufferSize,
                            dwDetailLevel,
                            bRefresh,
                            TRUE);
                break;

            default:
                assert (FALSE);
            }

        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        RELEASE_MUTEX (hPdhDataMutex);
        __try {
            * pcchBufferSize = dwBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectsW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPWSTR  mszObjectList,
    IN      LPDWORD pcchBufferSize,
    IN      DWORD   dwDetailLevel,
    IN      BOOL    bRefresh
)
/*++

Routine Description:

    Lists the performance objects found on the specified machine as
        a MSZ UNICODE string list.

Arguments:

    IN      LPCWSTR  szDataSource
            NULL for current real-time data or the name of a log file

    IN      LPCWSTR  szMachineName
            The machine to list objects from

    IN      LPWSTR mszObjectList
            a pointer to the  buffer to receive the list of performance
            objects

    IN      LPDWORD pcchBufferSize
            a pointer to the DWORD containing the size of the mszObjectList
            buffer in characters.

    IN      DWORD   dwDetailLevel
            The detail level to use as a filter of objects. All objects
            with a detail level less than or equal to that specified
            by this argument will be returned.

    IN      BOOL    bRefresh
            TRUE = retrive a new perf. data buffer for this machine before
                listing the objects
            FALSE = use the currently cached perf data buffer for this
                machine to enumerate objects

Return Value:
    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_INSUFFICIENT_BUFFER is returned when there is not enough
        room in the buffer for ANY data.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_INVALID_ARGUMENT is returned if a required argument is not provided
        or a reserved argument is not NULL

--*/
{
    PDH_STATUS  pdhStatus   = ERROR_SUCCESS;
    DWORD       dwDataSource = 0;
    HLOG        hDataSource = H_REALTIME_DATASOURCE;

    DebugPrint((4, "PdhEnumObjectsW BEGIN\n"));
    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (*szDataSource == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg
            
        dwDataSource = DataSourceTypeW(szDataSource);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogW(
                    szDataSource,
                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                    & dwLogType,
                    NULL,
                    0,
                    NULL,
                    & hDataSource);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumObjectsHW(hDataSource,
                                     szMachineName,
                                     mszObjectList,
                                     pcchBufferSize,
                                     dwDetailLevel,
                                     bRefresh);
        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }

    DebugPrint((4, "PdhEnumObjectsW END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectsHA (
    IN HLOG    hDataSource,
    IN LPCSTR  szMachineName,
    IN LPSTR   mszObjectList,
    IN LPDWORD pcchBufferSize,
    IN DWORD   dwDetailLevel,
    IN BOOL    bRefresh
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    LPWSTR     szWideName;
    DWORD      dwNameLength = 0;
    DWORD      dwDataSource = 0;
    DWORD      dwBufferSize = 0;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwDataSource = DataSourceTypeH(hDataSource);

            if (szMachineName != NULL) {
                // test buffer access
                if (*szMachineName != 0) {
                    if (pdhStatus == ERROR_SUCCESS) {
                        dwNameLength = lstrlenA (szMachineName);
                    }
                    else {
                        dwNameLength = 0;
                    }
                }
                else {
                    // null machine names are not permitted
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            else {
                dwNameLength = 0;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwBufferSize = * pcchBufferSize;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (dwBufferSize >= sizeof (DWORD)) {
                    // test writing to the buffers to make sure they are valid
                    CLEAR_FIRST_FOUR_BYTES (mszObjectList);
                    mszObjectList[dwBufferSize-1] = 0;
                }
                else if (dwBufferSize >= sizeof(CHAR)) {
                    mszObjectList[0] = 0;
                }
            }

        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwNameLength > 0) {
            szWideName = G_ALLOC ((dwNameLength+1) * sizeof(WCHAR));
            if (szWideName == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else {
                __try {
                    MultiByteToWideChar(_getmbcp(),
                                        0,
                                        szMachineName,
                                        dwNameLength,
                                        szWideName,
                                        dwNameLength + 1);
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
        else {
            szWideName = NULL;
        }

        if (pdhStatus == ERROR_SUCCESS) {
            __try {
                switch (dwDataSource) {
                case DATA_SOURCE_REGISTRY:
                    pdhStatus = PdhiEnumObjects (
                            szWideName,
                            (LPVOID)mszObjectList,
                            &dwBufferSize,
                            dwDetailLevel,
                            bRefresh,
                            FALSE);
                    break;

                case DATA_SOURCE_WBEM:
                    pdhStatus = PdhiEnumWbemObjects (
                            (LPWSTR)szWideName,
                            (LPVOID)mszObjectList,
                            &dwBufferSize,
                            dwDetailLevel,  // not used
                            bRefresh,
                            FALSE);
                    break;

                case DATA_SOURCE_LOGFILE:
                    pdhStatus = PdhiEnumLoggedObjects (
                                hDataSource,
                                (LPWSTR) szWideName,
                                (LPVOID) mszObjectList,
                                & dwBufferSize,
                                dwDetailLevel,
                                bRefresh,
                                FALSE);
                    break;

                default:
                    assert (FALSE);
                }
                * pcchBufferSize = dwBufferSize;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        RELEASE_MUTEX (hPdhDataMutex);
        if (szWideName != NULL) G_FREE (szWideName);
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectsA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPSTR   mszObjectList,
    IN      LPDWORD pcchBufferSize,
    IN      DWORD   dwDetailLevel,
    IN      BOOL    bRefresh
)
/*++

Routine Description:

    Lists the performance objects found on the specified machine as
        a MSZ ANSI string list.

Arguments:

    IN      LPCSTR  szDataSource
            NULL for current real-time data or the name of a log file

    IN      LPCSTR  szMachineName
            The machine to list objects from

    IN      LPSTR mszObjectList
            a pointer to the  buffer to receive the list of performance
            objects

    IN      LPDWORD pcchBufferSize
            a pointer to the DWORD containing the size of the mszObjectList
            buffer in characters.

    IN      DWORD   dwDetailLevel
            The detail level to use as a filter of objects. All objects
            with a detail level less than or equal to that specified
            by this argument will be returned.

    IN      BOOL    bRefresh
            TRUE = retrive a new perf. data buffer for this machine before
                listing the objects
            FALSE = use the currently cached perf data buffer for this
                machine to enumerate objects

Return Value:
    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_INSUFFICIENT_BUFFER is returned when there is not enough
        room in the buffer for ANY data.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_INVALID_ARGUMENT is returned if a required argument is not provided
        or a reserved argument is not NULL

--*/
{
    PDH_STATUS  pdhStatus   = ERROR_SUCCESS;
    HLOG        hDataSource = H_REALTIME_DATASOURCE;
    DWORD       dwDataSource = 0;

    DebugPrint((4, "PdhEnumObjectsA BEGIN\n"));
    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (*szDataSource == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg

        dwDataSource = DataSourceTypeA(szDataSource);

    }
     __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {

        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogA(
                    szDataSource,
                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                    & dwLogType,
                    NULL,
                    0,
                    NULL,
                    & hDataSource);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumObjectsHA(hDataSource,
                                     szMachineName,
                                     mszObjectList,
                                     pcchBufferSize,
                                     dwDetailLevel,
                                     bRefresh);
        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }

    DebugPrint((4, "PdhEnumObjectsA END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

STATIC_PDH_FUNCTION
PdhiEnumObjectItems (
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN      LPVOID  mszCounterList,
    IN      LPDWORD pcchCounterListLength,
    IN      LPVOID  mszInstanceList,
    IN      LPDWORD pcchInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags,
    IN      BOOL    bUnicode
)
/*++

Routine Description:

    Lists the items found in the specified performance object on the
        specified machine. Thie includes the performance counters and,
        if supported by the object, the object instances.

Arguments:

    IN      LPCWSTR szMachineName
            The name of the machine to list the objects

    IN      LPCWSTR szObjectName
            the name of the object to list items from

    IN      LPVOID  mszCounterList
            pointer to the buffer that will receive the list of counters
            provided by this object. This argument may be NULL if
            the value of pcchCounterLIstLength is 0.

    IN      LPDWORD pcchCounterListLength
            pointer to a DWORD that contains the size in characters
            of the buffer referenced by mszCounterList. The characters
            assumed are defined by bUnicode.

    IN      LPVOID  mszInstanceList
            pointer to the buffer that will receive the list of instances
            of the specified performance object. This argument may be
            NULL if the value of pcchInstanceListLength is 0.

    IN      LPDWORD pcchInstanceListLength
            pointer to the DWORD containing the size, in characters, of
            the buffer referenced by the mszInstanceList argument. If the
            value in this DWORD is 0, then no data will be written to the
            buffer, only the required size will be returned.

            If the value returned is 0, then this object does not
            return instances, if the value returned is 2, then the
            object supports instances, but does not currently have
            any instances to return  (2 = the size of an MSZ list in
            characters)

    IN      DWORD   dwDetailLevel
            The detail level of the performance items to return. All items
            that are of the specified detail level or less will be
            returned.

    IN      DWORD   dwFlags
            Not Used, must be 0.

    IN      BOOL    bUnicode
            TRUE = UNICODE characters will be written to the pMachineList
                    buffer
            FALSE = ANSI characters will be writtn to the pMachinList buffer

Return Value:

    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_INSUFFICIENT_BUFFER is returned when there is not enough
        room in the buffer for ANY data.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found on the specified machine.

--*/
{
    PPERF_MACHINE       pMachine;
    PDH_STATUS          pdhStatus     = ERROR_SUCCESS;
    PDH_STATUS          pdhCtrStatus  = ERROR_SUCCESS;
    PDH_STATUS          pdhInstStatus = ERROR_SUCCESS;
    DWORD               DefNdx;
    PERF_OBJECT_TYPE    *pObjectDef;
    PERF_COUNTER_DEFINITION *pCounterDef;
    PERF_INSTANCE_DEFINITION *pInstanceDef;
    DWORD               dwReqCounterLength = 0;
    DWORD               dwReqInstanceLength = 0;
    LPVOID              szNextName;
    DWORD               dwNameLength;
    WCHAR               szInstanceName[1024];
    WCHAR               szNumberString[32];
    DWORD               dwMaxInstanceLength;
    DWORD               dwMaxCounterLength;
    LPWSTR              szCounterName;
    DWORD               dwGmFlags;

    DBG_UNREFERENCED_PARAMETER (dwFlags);

    DebugPrint((4, "PdhiEnumObjectItems BEGIN\n"));

    pMachine = GetMachine ((LPWSTR)szMachineName, 0);

    if (pMachine != NULL) {
        if ((dwDetailLevel & PERF_DETAIL_COSTLY) &&
            !(pMachine->dwMachineFlags & PDHIPM_FLAGS_HAVE_COSTLY)) {
            // then get them
            dwGmFlags = PDH_GM_UPDATE_PERFDATA | PDH_GM_READ_COSTLY_DATA;
            pMachine = GetMachine ((LPWSTR)szMachineName, dwGmFlags);
        }
    }

    if (pMachine != NULL) {
        dwMaxCounterLength = *pcchCounterListLength;
        dwMaxInstanceLength = *pcchInstanceListLength;

        // make sure the machine connection is valid
        if (pMachine->dwStatus == ERROR_SUCCESS) {

            pObjectDef = GetObjectDefByName (
                pMachine->pSystemPerfData,
                pMachine->dwLastPerfString,
                pMachine->szPerfStrings,
                szObjectName);

            if (pObjectDef != NULL) {
                // add up counter name sizes
                pCounterDef = FirstCounter (pObjectDef);
                szNextName = mszCounterList;

                for (DefNdx = 0; DefNdx < pObjectDef->NumCounters; DefNdx++) {
                    if (!((pCounterDef->CounterType & PERF_DISPLAY_NOSHOW) &&
                        // this is a hack because this type is not defined correctly
                          (pCounterDef->CounterType != PERF_AVERAGE_BULK)) &&
                         (pCounterDef->DetailLevel <= dwDetailLevel)) {
                        // then this is a visible counter so get its name.
                        if ((pCounterDef->CounterNameTitleIndex > 0) &&
                            (pCounterDef->CounterNameTitleIndex < pMachine->dwLastPerfString)) {
                            // look up name of each object & store size
                            szCounterName =
                                (LPWSTR)PdhiLookupPerfNameByIndex (
                                    pMachine,
                                    pCounterDef->CounterNameTitleIndex);
                        } else {
                            // no matching string found for this index
                            szCounterName = NULL;
                        }
                        if (szCounterName == NULL) {
                            // then use the index numbe for lack of a better
                            // string to use
                            _ltow (pCounterDef->CounterNameTitleIndex,
                                szNumberString, 10);
                            szCounterName = &szNumberString[0];
                        }

                        if (bUnicode) {
                            dwNameLength = lstrlenW(szCounterName) + 1;
                            if (   szNextName != NULL
                                && dwReqCounterLength <= dwMaxCounterLength) {
                                lstrcpyW ((LPWSTR) szNextName, szCounterName);
                                (LPBYTE) szNextName += sizeof(WCHAR) * (dwNameLength - 1);
                                * ((LPWSTR) szNextName) ++ = 0;
                            }
                            else {
                                pdhCtrStatus = PDH_MORE_DATA;
                            }
                        }
                        else {
                            dwNameLength = (dwReqCounterLength <= dwMaxCounterLength)
                                         ? (dwMaxCounterLength - dwReqCounterLength)
                                         : (0);
                            pdhCtrStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                            szCounterName,
                                            (LPSTR) szNextName,
                                            & dwNameLength);
                            if (pdhCtrStatus == ERROR_SUCCESS) {
                                (LPBYTE) szNextName += sizeof(CHAR) * dwNameLength;
                            }
                        }
                        dwReqCounterLength += dwNameLength;
                    } else {
                        // this counter is not displayed either because
                        // it's hidden (e.g. the 2nd part of a 2 part counter
                        // or it's the wrong detail level
                    }
                    pCounterDef = NextCounter(pCounterDef); // get next
                }

                if (DefNdx == 0) {
                    // no counters found so at least one NULL is required
                    dwReqCounterLength += 1;

                    // see if this string will fit
                    if (dwReqCounterLength <= dwMaxCounterLength) {
                        if (bUnicode) {
                            *((LPWSTR)szNextName)++ = 0;
                        } else {
                            *((LPSTR)szNextName)++ = 0;
                        }
                    } else {
                        // more space needed than was reported
                        pdhCtrStatus = PDH_MORE_DATA;
                    }
                }
                // add terminating NULL
                dwReqCounterLength += 1;

                // see if this string will fit
                if (dwReqCounterLength <= dwMaxCounterLength) {
                    if (bUnicode) {
                        *((LPWSTR)szNextName)++ = 0;
                    } else {
                        *((LPSTR)szNextName)++ = 0;
                    }
                } else {
                    // more space needed than was reported
                    pdhCtrStatus = PDH_MORE_DATA;
                }

                // do instances now.

                szNextName = mszInstanceList;

                // add up instance name sizes

                if (pObjectDef->NumInstances != PERF_NO_INSTANCES) {
                    if ((pObjectDef->DetailLevel <= dwDetailLevel) &&
                        (pObjectDef->NumInstances > 0)) {
                        // the object HAS instances and is of the
                        // approrpriate detail level, so list them
                        pInstanceDef = FirstInstance (pObjectDef);

                        for (DefNdx = 0; DefNdx < (DWORD)pObjectDef->NumInstances; DefNdx++) {
                            dwNameLength = GetFullInstanceNameStr(
                                    pMachine->pSystemPerfData,
                                    pObjectDef, pInstanceDef,
                                    szInstanceName);

                            if (dwNameLength > 0) {
                                if (bUnicode) {
                                    // add length of this string + it's null
                                    dwNameLength += 1;
                                    if (   szNextName != NULL
                                        && dwReqInstanceLength + dwNameLength <= dwMaxInstanceLength) {
                                        lstrcpyW ((LPWSTR) szNextName, szInstanceName);
                                        (LPBYTE) szNextName += sizeof(WCHAR) * (dwNameLength - 1);
                                        * ((LPWSTR) szNextName) ++ = 0;
                                    }
                                    else {
                                        pdhInstStatus = PDH_MORE_DATA;
                                    }
                                }
                                else {
                                    dwNameLength = (dwReqInstanceLength <= dwMaxInstanceLength)
                                                 ? (dwMaxInstanceLength - dwReqInstanceLength) : (0);
                                    pdhInstStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                    szInstanceName,
                                                    (LPSTR) szNextName,
                                                    & dwNameLength);
                                    if (pdhInstStatus == ERROR_SUCCESS) {
                                        (LPBYTE) szNextName += sizeof(CHAR) * dwNameLength;
                                    }
                                }
                                dwReqInstanceLength += dwNameLength;
                            }

                            // go to next instance of this object
                            pInstanceDef = NextInstance(pInstanceDef); // get next
                        }
                        // add the terminating NULL char
                        dwReqInstanceLength += 1;
                        if (dwMaxInstanceLength > 0) {
                            // see if this string will fit
                            if (dwReqInstanceLength <= dwMaxInstanceLength) {
                                if (bUnicode) {
                                    *((LPWSTR)szNextName)++ = 0;
                                } else {
                                    *((LPSTR)szNextName)++ = 0;
                                }
                            } else {
                                // more space needed than was reported
                                pdhInstStatus = PDH_MORE_DATA;
                            }
                        }
                    } else {
                        // there are no instances present, but the object does
                        // support instances so return a zero length MSZ (which
                        // actually contains 2 NULL chars
                        dwReqInstanceLength = 2;

                        // see if this string will fit
                        if (dwReqInstanceLength <= dwMaxInstanceLength) {
                            if (bUnicode) {
                                *((LPWSTR)szNextName)++ = 0;
                                *((LPWSTR)szNextName)++ = 0;
                            } else {
                                *((LPSTR)szNextName)++ = 0;
                                *((LPSTR)szNextName)++ = 0;
                            }
                        } else {
                            // more space needed than was reported
                            pdhInstStatus = PDH_MORE_DATA;
                        }
                    }
                } else {
                    // the object has no instances and never will
                    // so return a 0 length and NO string
                    dwReqInstanceLength = 0;
                }
                *pcchCounterListLength = dwReqCounterLength;
                *pcchInstanceListLength = dwReqInstanceLength;

                if (pdhStatus == ERROR_SUCCESS) {
                    pdhStatus = (pdhCtrStatus == ERROR_SUCCESS)
                              ? (pdhInstStatus) : (pdhCtrStatus);
                }
            } else {
                // object not found on this machine
                pdhStatus = PDH_CSTATUS_NO_OBJECT;
            }
        } else {
            // machine is off line
            pdhStatus = pMachine->dwStatus;
        }
        pMachine->dwRefCount--;
        RELEASE_MUTEX (pMachine->hMutex);
    } else {
        pdhStatus = GetLastError();
    }
    DebugPrint((4, "PdhiEnumObjectItems END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectItemsHW (
    IN HLOG    hDataSource,
    IN LPCWSTR szMachineName,
    IN LPCWSTR szObjectName,
    IN LPWSTR  mszCounterList,
    IN LPDWORD pcchCounterListLength,
    IN LPWSTR  mszInstanceList,
    IN LPDWORD pcchInstanceListLength,
    IN DWORD   dwDetailLevel,
    IN DWORD   dwFlags
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwCBufferSize = 0;
    DWORD       dwIBufferSize = 0;
    DWORD       dwDataSource = 0;

    if ((pcchCounterListLength == NULL) || (pcchInstanceListLength == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwDataSource = DataSourceTypeH(hDataSource);

            if (szMachineName != NULL) {
                if (* szMachineName == 0) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (* szObjectName == 0) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                // test writing to the size buffers to make sure they are valid
                dwCBufferSize = *pcchCounterListLength;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if ((dwCBufferSize  * sizeof(WCHAR)) >= sizeof (DWORD)) {
                    //then the buffer must be valid
                    CLEAR_FIRST_FOUR_BYTES (mszCounterList);
                    mszCounterList[dwCBufferSize -1] = 0;
                }
                else if ((dwCBufferSize  * sizeof(WCHAR)) >= sizeof (WCHAR)) {
                    mszCounterList[0]  = 0;
                }
                else if ((dwCBufferSize  * sizeof(WCHAR))  != 0) {
                    // then the buffer is too small
                    pdhStatus = PDH_MORE_DATA;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwIBufferSize = *pcchInstanceListLength;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if ((dwIBufferSize * sizeof(WCHAR)) >= sizeof (DWORD)) {
                    //then the buffer must be valid
                    CLEAR_FIRST_FOUR_BYTES (mszInstanceList);
                    mszInstanceList[dwIBufferSize -1] = 0;
                }
                else if ((dwIBufferSize * sizeof(WCHAR)) >= sizeof(WCHAR)) {
                    mszInstanceList[0] = 0;
                }
                else if ((dwIBufferSize * sizeof(WCHAR)) != 0) {
                    // then the buffer is too small
                    pdhStatus = PDH_MORE_DATA;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (dwFlags != 0L) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pdhStatus = PdhiEnumObjectItems (
                        (LPWSTR)szMachineName,
                        szObjectName,
                        (LPVOID)mszCounterList,
                        &dwCBufferSize,
                        (LPVOID)mszInstanceList,
                        &dwIBufferSize,
                        dwDetailLevel,
                        dwFlags,
                        TRUE);
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiEnumWbemObjectItems (
                        (LPWSTR)szMachineName,
                        szObjectName,
                        (LPVOID)mszCounterList,
                        &dwCBufferSize,
                        (LPVOID)mszInstanceList,
                        &dwIBufferSize,
                        dwDetailLevel,
                        dwFlags,
                        TRUE);
                break;

            case DATA_SOURCE_LOGFILE:
                pdhStatus = PdhiEnumLoggedObjectItems (
                            hDataSource,
                            (LPWSTR) szMachineName,
                            szObjectName,
                            (LPVOID) mszCounterList,
                            & dwCBufferSize,
                            (LPVOID) mszInstanceList,
                            & dwIBufferSize,
                            dwDetailLevel,
                            dwFlags,
                            TRUE);
                break;

            default:
                assert (FALSE);

            }

        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        RELEASE_MUTEX (hPdhDataMutex);
        __try {
            *pcchCounterListLength = dwCBufferSize;
            *pcchInstanceListLength = dwIBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectItemsW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN      LPWSTR  mszCounterList,
    IN      LPDWORD pcchCounterListLength,
    IN      LPWSTR  mszInstanceList,
    IN      LPDWORD pcchInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags
)
/*++

Routine Description:

    Lists the items found in the specified performance object on the
        specified machine. Thie includes the performance counters and,
        if supported by the object, the object instances.

Arguments:
    IN      LPCWSTR  szDataSource
            NULL for current real-time data or the name of a log file

    IN      LPCWSTR szMachineName
            The name of the machine to list the objects

    IN      LPCWSTR szObjectName
            the name of the object to list items from

    IN      LPWSTR  mszCounterList
            pointer to the buffer that will receive the list of counters
            provided by this object. This argument may be NULL if
            the value of pcchCounterLIstLength is 0.

    IN      LPDWORD pcchCounterListLength
            pointer to a DWORD that contains the size in characters
            of the buffer referenced by mszCounterList. The characters
            assumed are defined by bUnicode.

    IN      LPWSTR  mszInstanceList
            pointer to the buffer that will receive the list of instances
            of the specified performance object. This argument may be
            NULL if the value of pcchInstanceListLength is 0.

    IN      LPDWORD pcchInstanceListLength
            pointer to the DWORD containing the size, in characters, of
            the buffer referenced by the mszInstanceList argument. If the
            value in this DWORD is 0, then no data will be written to the
            buffer, only the required size will be returned.

            If the value returned is 0, then this object does not
            return instances, if the value returned is 2, then the
            object supports instances, but does not currently have
            any instances to return  (2 = the size of an MSZ list in
            characters)

    IN      DWORD   dwDetailLevel
            The detail level of the performance items to return. All items
            that are of the specified detail level or less will be
            returned.

    IN      DWORD   dwFlags
            Not Used, must be 0.

Return Value:

    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_INSUFFICIENT_BUFFER is returned when there is not enough
        room in the buffer for ANY data.
    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found on the specified machine.

--*/
{
    PDH_STATUS  pdhStatus   = ERROR_SUCCESS;
    HLOG        hDataSource = H_REALTIME_DATASOURCE;
    DWORD       dwDataSource = 0;

    DebugPrint((4, "PdhEnumObjectItemsW BEGIN\n"));
    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg

        dwDataSource = DataSourceTypeW(szDataSource);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogW(
                    szDataSource,
                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                    & dwLogType,
                    NULL,
                    0,
                    NULL,
                    & hDataSource);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumObjectItemsHW(hDataSource,
                                         szMachineName,
                                         szObjectName,
                                         mszCounterList,
                                         pcchCounterListLength,
                                         mszInstanceList,
                                         pcchInstanceListLength,
                                         dwDetailLevel,
                                         dwFlags);
        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }

    DebugPrint((4, "PdhEnumObjectItemsW END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectItemsHA (
    IN HLOG    hDataSource,
    IN LPCSTR  szMachineName,
    IN LPCSTR  szObjectName,
    IN LPSTR   mszCounterList,
    IN LPDWORD pcchCounterListLength,
    IN LPSTR   mszInstanceList,
    IN LPDWORD pcchInstanceListLength,
    IN DWORD   dwDetailLevel,
    IN DWORD   dwFlags
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwMachineNameLength = 0;
    DWORD       dwObjectNameLength = 0;
    LPWSTR      szWideMachineName = NULL;
    LPWSTR      szWideObjectName = NULL;
    DWORD       dwDataSource = 0;
    DWORD       dwCBufferSize = 0;
    DWORD       dwIBufferSize = 0;

    if ((pcchCounterListLength == NULL) || (pcchInstanceListLength == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwDataSource = DataSourceTypeH(hDataSource);
        
            if (szMachineName != NULL) {
                if (* szMachineName == 0) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else {
                    dwMachineNameLength = lstrlenA(szMachineName);
                }
            }
            else {
                dwMachineNameLength = 0;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (szObjectName != NULL) {
                    if (* szObjectName == 0) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                    else {
                        dwObjectNameLength = lstrlenA(szObjectName);
                    }
                }
                else {
                    // object cannot be NULL
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                // test writing to the size buffers to make sure they are valid
                dwCBufferSize = *pcchCounterListLength;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (dwCBufferSize >= sizeof(DWORD)) {
                    //then the buffer must be valid
                    CLEAR_FIRST_FOUR_BYTES (mszCounterList);
                    mszCounterList[dwCBufferSize - 1] = 0;
                }
                else if (dwCBufferSize >= sizeof(CHAR)) {
                    mszCounterList[0] = 0;
                } 
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwIBufferSize = *pcchInstanceListLength;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (dwIBufferSize >= sizeof(DWORD)) {
                    //then the buffer must be valid
                    CLEAR_FIRST_FOUR_BYTES (mszInstanceList);
                    mszInstanceList[dwIBufferSize - 1] = 0;
                }
                else if (dwIBufferSize >= sizeof(CHAR)) {
                    mszInstanceList[0] = 0;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (dwFlags != 0L) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            if (dwMachineNameLength > 0) {
                szWideMachineName = G_ALLOC(  (dwMachineNameLength + 1)
                                            * sizeof(WCHAR));
                if (szWideMachineName != NULL) {
                    MultiByteToWideChar(_getmbcp(),
                                        0,
                                        szMachineName,
                                        dwMachineNameLength,
                                        szWideMachineName,
                                        dwMachineNameLength + 1);
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
            else {
                szWideMachineName = NULL;
            }
            if (dwObjectNameLength > 0) {
                szWideObjectName = G_ALLOC(  (dwObjectNameLength + 1)
                                           * sizeof(WCHAR));
                if (szWideObjectName != NULL) {
                    MultiByteToWideChar(_getmbcp(),
                                        0,
                                        szObjectName,
                                        dwObjectNameLength,
                                        szWideObjectName,
                                        dwObjectNameLength + 1);
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
            else {
                szWideObjectName = NULL;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                switch (dwDataSource) {
                case DATA_SOURCE_REGISTRY:
                    pdhStatus = PdhiEnumObjectItems (
                                szWideMachineName,
                                szWideObjectName,
                                (LPVOID)mszCounterList,
                                &dwCBufferSize,
                                (LPVOID)mszInstanceList,
                                &dwIBufferSize,
                                dwDetailLevel,
                                dwFlags,
                                FALSE);
                    break;

                case DATA_SOURCE_WBEM:
                   pdhStatus = PdhiEnumWbemObjectItems (
                            (LPWSTR)szWideMachineName,
                            szWideObjectName,
                            (LPVOID)mszCounterList,
                            &dwCBufferSize,
                            (LPVOID)mszInstanceList,
                            &dwIBufferSize,
                            dwDetailLevel,
                            dwFlags,
                            FALSE);
                   break;

                case DATA_SOURCE_LOGFILE:
                    pdhStatus = PdhiEnumLoggedObjectItems (
                                hDataSource,
                                szWideMachineName,
                                szWideObjectName,
                                (LPVOID) mszCounterList,
                                & dwCBufferSize,
                                (LPVOID) mszInstanceList,
                                & dwIBufferSize,
                                dwDetailLevel,
                                dwFlags,
                                FALSE);
                    break;

                default:
                    assert (FALSE);
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        RELEASE_MUTEX (hPdhDataMutex);
        if (szWideMachineName != NULL) G_FREE(szWideMachineName);
        if (szWideObjectName != NULL) G_FREE(szWideObjectName);

        __try {
            * pcchCounterListLength  = dwCBufferSize;
            * pcchInstanceListLength = dwIBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectItemsA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPCSTR  szObjectName,
    IN      LPSTR   mszCounterList,
    IN      LPDWORD pcchCounterListLength,
    IN      LPSTR   mszInstanceList,
    IN      LPDWORD pcchInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags
)
/*++

Routine Description:

    Lists the items found in the specified performance object on the
        specified machine. Thie includes the performance counters and,
        if supported by the object, the object instances.

Arguments:
    IN      LPCSTR  szDataSource
            NULL for current real-time data or the name of a log file

    IN      LPCSTR szMachineName
            The name of the machine to list the objects

    IN      LPCSTR szObjectName
            the name of the object to list items from

    IN      LPSTR  mszCounterList
            pointer to the buffer that will receive the list of counters
            provided by this object. This argument may be NULL if
            the value of pcchCounterLIstLength is 0.

    IN      LPDWORD pcchCounterListLength
            pointer to a DWORD that contains the size in characters
            of the buffer referenced by mszCounterList. The characters
            assumed are defined by bUnicode.

    IN      LPSTR  mszInstanceList
            pointer to the buffer that will receive the list of instances
            of the specified performance object. This argument may be
            NULL if the value of pcchInstanceListLength is 0.

    IN      LPDWORD pcchInstanceListLength
            pointer to the DWORD containing the size, in characters, of
            the buffer referenced by the mszInstanceList argument. If the
            value in this DWORD is 0, then no data will be written to the
            buffer, only the required size will be returned.

            If the value returned is 0, then this object does not
            return instances, if the value returned is 2, then the
            object supports instances, but does not currently have
            any instances to return  (2 = the size of an MSZ list in
            characters)

    IN      DWORD   dwDetailLevel
            The detail level of the performance items to return. All items
            that are of the specified detail level or less will be
            returned.

    IN      DWORD   dwFlags
            Not Used, must be 0.

Return Value:

    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_INSUFFICIENT_BUFFER is returned when there is not enough
        room in the buffer for ANY data.
    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a required temporary
        buffer could not be allocated.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found on the specified machine.

--*/
{
    PDH_STATUS   pdhStatus   = ERROR_SUCCESS;
    HLOG         hDataSource = H_REALTIME_DATASOURCE;
    DWORD        dwDataSource = 0;

    DebugPrint((4, "PdhEnumObjectItemsA BEGIN\n"));
    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg

        dwDataSource = DataSourceTypeA(szDataSource);
        
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogA(
                    szDataSource,
                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                    & dwLogType,
                    NULL,
                    0,
                    NULL,
                    & hDataSource);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumObjectItemsHA(hDataSource,
                                         szMachineName,
                                         szObjectName,
                                         mszCounterList,
                                         pcchCounterListLength,
                                         mszInstanceList,
                                         pcchInstanceListLength,
                                         dwDetailLevel,
                                         dwFlags);
        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }

    DebugPrint((4, "PdhEnumObjectItemsA END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

PDH_FUNCTION
PdhMakeCounterPathW (
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPWSTR                      szFullPathBuffer,
    IN      LPDWORD                     pcchBufferSize,
    IN      DWORD                       dwFlags
)
/*++

Routine Description:

    Constructs a counter path using the elemeents defined in the
        pCounterPathElements structure and returns the path string
        in the buffer provided by the caller. The resulting path
        is not validated.

Arguments:

    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements
                The pointer to the structure containing the
                individual counter path fields that are to be
                assembled in to a path string
    IN      LPWSTR                      szFullPathBuffer
                The buffer to receive the path string. This value
                may be NULL if the value of the DWORD pointed to
                by pcchBufferSize is 0 indicating this is just a
                request for the required buffer size.
    IN      LPDWORD                     pcchBufferSize
                The pointer to the DWORD containing the size
                of the string buffer in characters. On return
                it contains the size of the buffer used in
                characters (including the terminating NULL char).
                If the value is 0 on entry then no data will be
                written to the buffer, but the required size will
                still be returned.
    IN      DWORD                       dwFlags
            if 0, then return the path as a REGISTRY path items
            if PDH_PATH_WBEM_RESULT then return the items in WBEM format
            if PDH_PATH_WBEM_INPUT then assume the input is in WBEM format

Return Value:

    ERROR_SUCCESS if the function completes successfully, otherwise a
        PDH error is returned.
    PDH_INVALID_ARGUMENT is returned when one of the arguments passed
        by the caller is incorrect or not accesible.
    PDH_INSUFFICIENT_BUFFER is returned when the buffer provided is not
        large enough for the path string.

--*/
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    double      dIndex;
    double      dLen;
    DWORD       dwSizeRequired = 0;
    LPWSTR      szNextChar;
    DWORD       dwMaxSize;
    DWORD       dwLocalBufferSize = 0;

    if ((pCounterPathElements == NULL) || (pcchBufferSize == NULL)){
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        __try {
        // test access to the input structure
            if (pCounterPathElements->szMachineName != NULL) {
                WCHAR wChar;
                wChar = *pCounterPathElements->szMachineName;
                // then see if it's accessible
                if (wChar == 0) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } else {
                //NULL is ok for this field
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szObjectName != NULL) {
                    WCHAR wChar;
                    wChar = *pCounterPathElements->szObjectName;
                    // then see if it's accessible
                    if (wChar == 0) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    //NULL is NOT ok for this field
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szInstanceName != NULL) {
                    WCHAR wChar;
                    wChar = *pCounterPathElements->szInstanceName;
                    // then see if it's accessible
                    if (wChar == 0) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    //NULL is ok for this field
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szParentInstance != NULL) {
                    WCHAR wChar;
                    wChar = *pCounterPathElements->szParentInstance;
                    // then see if it's accessible
                    if (wChar == 0) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    //NULL is ok for this field
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szCounterName != NULL) {
                    WCHAR wChar;
                    wChar = *pCounterPathElements->szCounterName;
                    // then see if it's accessible
                    if (wChar == 0) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    //NULL is NOT ok for this field
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            // test the output buffers
            if (pdhStatus == ERROR_SUCCESS) {
                if (pcchBufferSize != NULL) {
                    dwLocalBufferSize = *pcchBufferSize;
                } else {
                    // NULL is NOT OK
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (   (pdhStatus == ERROR_SUCCESS)
                && (szFullPathBuffer == NULL && dwLocalBufferSize > 0)) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if ((szFullPathBuffer != NULL) && (dwLocalBufferSize > 0)) {
                    *szFullPathBuffer = 0;
                    szFullPathBuffer[dwLocalBufferSize - 1] = 0;
                } else {
                    // NULL is OK
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            if (dwFlags == 0) {
                // then process as:
                //      registry path elements in
                //      registry path out

                dwMaxSize = dwLocalBufferSize;

                if (pCounterPathElements->szMachineName != NULL) {
                    dwSizeRequired = lstrlenW (pCounterPathElements->szMachineName);
                    // compare the first two words of the machine name
                    // to see if the double backslash is already present in the string
                    if (*((LPDWORD)(pCounterPathElements->szMachineName)) !=
                        *((LPDWORD)(cszDoubleBackSlash))) {
                            // double backslash not found
                        dwSizeRequired += 2; // to include the backslashes
                    }
                    if (dwMaxSize > 0) {
                        if (dwSizeRequired < dwMaxSize) {
                            if (*((LPDWORD)(pCounterPathElements->szMachineName)) !=
                                *((LPDWORD)(cszDoubleBackSlash))) {
                                    // double backslash not found
                                lstrcpyW (szFullPathBuffer, cszDoubleBackSlash);
                            } else {
                                *szFullPathBuffer = 0;
                            }
                            lstrcatW (szFullPathBuffer, pCounterPathElements->szMachineName);
                            assert ((DWORD)lstrlenW (szFullPathBuffer) == dwSizeRequired);
                        } else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }
                }

                dwSizeRequired += 1; // for delimiting slash
                dwSizeRequired += lstrlenW (pCounterPathElements->szObjectName);
                if (dwMaxSize > 0) {
                    if (dwSizeRequired < dwMaxSize) {
                        lstrcatW (szFullPathBuffer, cszBackSlash);
                        lstrcatW (szFullPathBuffer, pCounterPathElements->szObjectName);
                        assert ((DWORD)lstrlenW (szFullPathBuffer) == dwSizeRequired);
                    } else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }

                if (pCounterPathElements->szInstanceName != NULL) {
                    dwSizeRequired += 1; // for delimiting left paren
                    if (dwMaxSize > 0) {
                        if (dwSizeRequired < dwMaxSize) {
                            lstrcatW (szFullPathBuffer, cszLeftParen);
                            assert ((DWORD)lstrlenW (szFullPathBuffer) == dwSizeRequired);
                        } else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }

                    if (   lstrcmpiW(pCounterPathElements->szInstanceName, cszSplat) != 0
                        && pCounterPathElements->szParentInstance != NULL) {
                        dwSizeRequired += lstrlenW (pCounterPathElements->szParentInstance);
                        dwSizeRequired += 1; // for delimiting slash
                        if (dwMaxSize > 0) {
                            if (dwSizeRequired < dwMaxSize) {
                                lstrcatW (szFullPathBuffer,
                                    pCounterPathElements->szParentInstance);
                                lstrcatW (szFullPathBuffer, cszSlash);
                                assert ((DWORD)lstrlenW (szFullPathBuffer) == dwSizeRequired);
                            } else {
                                pdhStatus = PDH_MORE_DATA;
                            }
                        }
                    }

                    dwSizeRequired += lstrlenW (pCounterPathElements->szInstanceName);
                    if (dwMaxSize > 0) {
                        if (dwSizeRequired < dwMaxSize) {
                            lstrcatW (szFullPathBuffer,
                                pCounterPathElements->szInstanceName);
                            assert ((DWORD)lstrlenW (szFullPathBuffer) == dwSizeRequired);
                        } else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }

                    if (   lstrcmpiW(pCounterPathElements->szInstanceName, cszSplat) != 0
                        && pCounterPathElements->dwInstanceIndex != ((DWORD)-1)) {
                        // the length of the index is computed by getting the log of the number
                        // yielding the largest power of 10 less than or equal to the index.
                        // e.g. the power of 10 of an index value of 356 would 2.0 (which is the
                        // result of (floor(log10(index))). The actual number of characters in
                        // the string would always be 1 greate than that value so 1 is added.
                        // 1 more is added to include the delimiting character

                        dIndex = (double)pCounterPathElements->dwInstanceIndex; // cast to float
                        dLen = floor(log10(dIndex));                    // get integer log
                        dwSizeRequired += (DWORD)dLen;                   // cast to integer
                        dwSizeRequired += 2;                            // increment

                        if (dwMaxSize > 0) {
                            if (dwSizeRequired < dwMaxSize) {
                                szNextChar = &szFullPathBuffer[lstrlenW(szFullPathBuffer)];
                                *szNextChar++ = POUNDSIGN_L;
                                _ltow ((long)pCounterPathElements->dwInstanceIndex, szNextChar, 10);
                                assert ((DWORD)lstrlenW (szFullPathBuffer) == dwSizeRequired);
                            } else {
                                pdhStatus = PDH_MORE_DATA;
                            }
                        }
                    }

                    dwSizeRequired += 1; // for delimiting parenthesis
                    if (dwMaxSize > 0) {
                        if (dwSizeRequired < dwMaxSize) {
                            lstrcatW (szFullPathBuffer, cszRightParen);
                            assert ((DWORD)lstrlenW (szFullPathBuffer) == dwSizeRequired);
                        } else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }
                }

                dwSizeRequired++;   // include delimiting Backslash
                dwSizeRequired += lstrlenW(pCounterPathElements->szCounterName);
                if (dwMaxSize > 0) {
                    if (dwSizeRequired < dwMaxSize) {
                        lstrcatW (szFullPathBuffer, cszBackSlash);
                        lstrcatW (szFullPathBuffer,
                            pCounterPathElements->szCounterName);
                        assert ((DWORD)lstrlenW (szFullPathBuffer) == dwSizeRequired);
                    } else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }

                dwSizeRequired++;   // include trailing Null char

            } else {
                // there is some WBEM component involved so send to WBEM function
                // to figure it out
                pdhStatus = PdhiEncodeWbemPathW (
                    pCounterPathElements,
                    szFullPathBuffer,
                    &dwLocalBufferSize,
                    (LANGID)((dwFlags >> 16) & 0x0000FFFF),
                    (DWORD)(dwFlags & 0x0000FFFF));
            }

            if (pdhStatus == ERROR_SUCCESS && szFullPathBuffer == NULL
                                           && * pcchBufferSize == 0) {
                pdhStatus = PDH_MORE_DATA;
            }
            *pcchBufferSize = dwSizeRequired;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhMakeCounterPathA (
    IN      PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    IN      LPSTR                       szFullPathBuffer,
    IN      LPDWORD                     pcchBufferSize,
    IN      DWORD                       dwFlags
)
/*++

Routine Description:

    Constructs a counter path using the elemeents defined in the
        pCounterPathElements structure and returns the path string
        in the buffer provided by the caller. The resulting path
        is not validated.

Arguments:

    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements
                The pointer to the structure containing the
                individual counter path fields that are to be
                assembled in to a path string
    IN      LPWSTR                      szFullPathBuffer
                The buffer to receive the path string. This value
                may be NULL if the value of the DWORD pointed to
                by pcchBufferSize is 0 indicating this is just a
                request for the required buffer size.
    IN      LPDWORD                     pcchBufferSize
                The pointer to the DWORD containing the size
                of the string buffer in characters. On return
                it contains the size of the buffer used in
                characters (including the terminating NULL char).
                If the value is 0 on entry then no data will be
                written to the buffer, but the required size will
                still be returned.
    IN      DWORD                       dwFlags
            if 0, then return the path as a REGISTRY path items
            if PDH_PATH_WBEM_RESULT then return the items in WBEM format
            if PDH_PATH_WBEM_INPUT then assume the input is in WBEM format

Return Value:

    ERROR_SUCCESS if the function completes successfully, otherwise a
        PDH error is returned.
    PDH_INVALID_ARGUMENT is returned when one of the arguments passed
        by the caller is incorrect or not accesible.
    PDH_INSUFFICIENT_BUFFER is returned when the buffer provided is not
        large enough for the path string.

--*/
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    double      dIndex;
    double      dLen;
    DWORD       dwSizeRequired = 0;
    LPSTR       szNextChar;
    DWORD       dwMaxSize;
    DWORD       dwLocalBufferSize = 0;

    // TODO: Win2K.1 capture pCounterPathElements and szFullPathBuffer

    if ((pCounterPathElements == NULL)|| (pcchBufferSize == NULL)){
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        __try {
            // test access to the input structure
            if (pCounterPathElements->szMachineName != NULL) {
                CHAR cChar;
                cChar = *pCounterPathElements->szMachineName;
                // then see if it's accessible
                if (cChar == 0) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } else {
                //NULL is ok for this field
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szObjectName != NULL) {
                    CHAR cChar;
                    cChar = *pCounterPathElements->szObjectName;
                    // then see if it's accessible
                    if (cChar == 0) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    //NULL is NOT ok for this field
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szInstanceName != NULL) {
                    CHAR cChar;
                    cChar = *pCounterPathElements->szInstanceName;
                    // then see if it's accessible
                    if (cChar == 0) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    //NULL is ok for this field
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szParentInstance != NULL) {
                    CHAR cChar;
                    cChar = *pCounterPathElements->szParentInstance;
                    // then see if it's accessible
                    if (cChar == 0) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    //NULL is ok for this field
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szCounterName != NULL) {
                    CHAR cChar;
                    cChar = *pCounterPathElements->szCounterName;
                    // then see if it's accessible
                    if (cChar == 0) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    //NULL is NOT ok for this field
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            // test the output buffers
            if (pdhStatus == ERROR_SUCCESS) {
                if (pcchBufferSize != NULL) {
                    dwLocalBufferSize = *pcchBufferSize;
                } else {
                    // NULL is NOT OK
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (   (pdhStatus == ERROR_SUCCESS)
                && (szFullPathBuffer == NULL && dwLocalBufferSize > 0)) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                // write to both ends of the buffer if one was sent
                if ((szFullPathBuffer != NULL) && (dwLocalBufferSize > 0)) {
                    *szFullPathBuffer = 0;
                    szFullPathBuffer[dwLocalBufferSize - 1] = 0;
                } else {
                    // NULL is OK
                }
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            if (dwFlags == 0) {
                // this is a registry path in and out

                dwMaxSize = dwLocalBufferSize;

                if (pCounterPathElements->szMachineName != NULL) {
                    dwSizeRequired = lstrlenA (pCounterPathElements->szMachineName);
                    // compare the first two words of the machine name
                    // to see if the double backslash is already present in the string
                    if (*((LPWORD)(pCounterPathElements->szMachineName)) !=
                        *((LPWORD)(caszDoubleBackSlash))) {
                            // double backslash not found
                        dwSizeRequired += 2; // to include the backslashes
                    }
                    if (dwMaxSize > 0) {
                        if (dwSizeRequired < dwMaxSize) {
                            if (*((LPWORD)(pCounterPathElements->szMachineName)) !=
                                *((LPWORD)(caszDoubleBackSlash))) {
                                    // double backslash not found
                                lstrcpyA (szFullPathBuffer, caszDoubleBackSlash);
                            } else {
                                *szFullPathBuffer = 0;
                            }
                            lstrcatA (szFullPathBuffer, pCounterPathElements->szMachineName);
                            assert ((DWORD)lstrlenA (szFullPathBuffer) == dwSizeRequired);
                        } else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }
                }

                dwSizeRequired += 1; // for delimiting slash
                dwSizeRequired += lstrlenA (pCounterPathElements->szObjectName);
                if (dwMaxSize > 0) {
                    if (dwSizeRequired < dwMaxSize) {
                        lstrcatA (szFullPathBuffer, caszBackSlash);
                        lstrcatA (szFullPathBuffer, pCounterPathElements->szObjectName);
                        assert ((DWORD)lstrlenA (szFullPathBuffer) == dwSizeRequired);
                    } else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }

                if (pCounterPathElements->szInstanceName != NULL) {
                    dwSizeRequired += 1; // for delimiting left paren
                    if (dwMaxSize > 0) {
                        if (dwSizeRequired < dwMaxSize) {
                            lstrcatA (szFullPathBuffer, caszLeftParen);
                            assert ((DWORD)lstrlenA (szFullPathBuffer) == dwSizeRequired);
                        } else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }

                    if (pCounterPathElements->szParentInstance != NULL) {
                        dwSizeRequired += lstrlenA (pCounterPathElements->szParentInstance);
                        dwSizeRequired += 1; // for delimiting slash
                        if (dwMaxSize > 0) {
                            if (dwSizeRequired < dwMaxSize) {
                                lstrcatA (szFullPathBuffer,
                                    pCounterPathElements->szParentInstance);
                                lstrcatA (szFullPathBuffer, caszSlash);
                                assert ((DWORD)lstrlenA (szFullPathBuffer) == dwSizeRequired);
                            } else {
                                pdhStatus = PDH_MORE_DATA;
                            }
                        }
                    }

                    dwSizeRequired += lstrlenA (pCounterPathElements->szInstanceName);
                    if (dwMaxSize > 0) {
                        if (dwSizeRequired < dwMaxSize) {
                            lstrcatA (szFullPathBuffer,
                                pCounterPathElements->szInstanceName);
                            assert ((DWORD)lstrlenA (szFullPathBuffer) == dwSizeRequired);
                        } else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }

                    if (pCounterPathElements->dwInstanceIndex != ((DWORD)-1)) {
                        // the length of the index is computed by getting the log of the number
                        // yielding the largest power of 10 less than or equal to the index.
                        // e.g. the power of 10 of an index value of 356 would 2.0 (which is the
                        // result of (floor(log10(index))). The actual number of characters in
                        // the string would always be 1 greate than that value so 1 is added.
                        // 1 more is added to include the delimiting character

                        dIndex = (double)pCounterPathElements->dwInstanceIndex; // cast to float
                        dLen = floor(log10(dIndex));                    // get integer log
                        dwSizeRequired = (DWORD)dLen;                   // cast to integer
                        dwSizeRequired += 2;                            // increment

                        if (dwMaxSize > 0) {
                            if (dwSizeRequired < dwMaxSize) {
                                szNextChar = &szFullPathBuffer[lstrlenA(szFullPathBuffer)];
                                *szNextChar++ = POUNDSIGN_L;
                                _ltoa ((long)pCounterPathElements->dwInstanceIndex, szNextChar, 10);
                                assert ((DWORD)lstrlenA (szFullPathBuffer) == dwSizeRequired);
                            } else {
                                pdhStatus = PDH_MORE_DATA;
                            }
                        }
                    }

                    dwSizeRequired += 1; // for delimiting parenthesis
                    if (dwMaxSize > 0) {
                        if (dwSizeRequired < dwMaxSize) {
                            lstrcatA (szFullPathBuffer, caszRightParen);
                            assert ((DWORD)lstrlenA (szFullPathBuffer) == dwSizeRequired);
                        } else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }
                }

                dwSizeRequired++;   // include delimiting Backslash
                dwSizeRequired += lstrlenA(pCounterPathElements->szCounterName);
                if (szFullPathBuffer != NULL && dwMaxSize > 0) {
                    if (dwSizeRequired < dwMaxSize) {
                        lstrcatA (szFullPathBuffer, caszBackSlash);
                        lstrcatA (szFullPathBuffer,
                            pCounterPathElements->szCounterName);
                        assert ((DWORD)lstrlenA (szFullPathBuffer) == dwSizeRequired);
                    } else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }

                dwSizeRequired++;   // include trailing Null char

            } else {
                // this is a WBEM path so have the WBEM function figure
                // it out
                // there is some WBEM component involved so send to WBEM function
                // to figure it out
                pdhStatus = PdhiEncodeWbemPathA (
                    pCounterPathElements,
                    szFullPathBuffer,
                    &dwLocalBufferSize,
                    (LANGID)((dwFlags >> 16) & 0x0000FFFF),
                    (DWORD)(dwFlags & 0x0000FFFF));
            }
            if (pdhStatus == ERROR_SUCCESS && szFullPathBuffer == NULL
                                           && * pcchBufferSize == 0) {
                pdhStatus = PDH_MORE_DATA;
            }

            *pcchBufferSize = dwSizeRequired;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhParseCounterPathW (
    IN      LPCWSTR                     szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPDWORD                     pcchBufferSize,
    IN      DWORD                       dwFlags
)
/*++

Routine Description:

    Reads a perf counter path string and parses out the
        component fields, returning them in a buffer
        supplied by the calling function.

Arguments:

    IN      LPCWSTR                     szFullPathBuffer
                counter path string to parse.
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements
                pointer to buffer supplied by the caller in
                which the component fields will be written
                This buffer is cast as a structure, however, the
                string data is written to the space after
                the buffer.
    IN      LPDWORD                     pcchBufferSize
                the size of the buffer in BYTES. If specified size
                is 0, then the size is estimated and returned
                in this field and the buffer referenced by the
                agrument above is ignored.
    IN      DWORD                       dwFlags
            if 0, then return the path elements as REGISTRY path items
            if PDH_PATH_WBEM_RESULT then return the items in WBEM format
            if PDH_PATH_WBEM_INPUT then assume the input is in WBEM format

Return Value:

    ERROR_SUCCESS if the function completes successfully, otherwise
        a PDH error if not
    PDH_INVALID_ARGUMENT is returned when an argument is inocrrect or
        this function does not have the necessary access to that arg.
    PDH_INSUFFICIENT_BUFFER is returned when the buffer supplied is not
        large enough to accept the resulting data.
    PDH_INVALID_PATH is returned when the path is not formatted correctly
        and cannot be parsed.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a temporary buffer
        cannot be allocated

--*/
{
    PPDHI_COUNTER_PATH  pLocalCounterPath;
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    DWORD               dwSize;
    LPWSTR              szString;
    DWORD               dwLocalBufferSize;

    // TODO: Win2K.1 capture pCounterPathElements and szFullPathBuffer

    //validate incoming arguments
    if ((szFullPathBuffer == NULL) || (pcchBufferSize == NULL)) {
        return PDH_INVALID_ARGUMENT;
    }
    __try {
        // string cannot be null
        if (*szFullPathBuffer == 0) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        dwLocalBufferSize = *pcchBufferSize;

        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements != NULL) {
                if (dwLocalBufferSize > 0) {
                    // try both "ends" of the buffer to see if an AV occurs
                    *((LPBYTE)pCounterPathElements) = 0;
                    ((LPBYTE)pCounterPathElements)[dwLocalBufferSize - 1] = 0;
                } else {
                    // a 0 length is OK for sizing
                }
            }  // else NULL pointer, which is OK
        }

        if (dwFlags != 0) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        if (pdhStatus == ERROR_SUCCESS) {
            if (dwFlags == 0) {
                // allocate a temporary work buffer
                pLocalCounterPath = G_ALLOC (
                    (sizeof(PDHI_COUNTER_PATH) +
                        (2 * lstrlenW(szFullPathBuffer) + MAX_PATH) * sizeof (WCHAR)));

                if (pLocalCounterPath != NULL) {
                    dwSize = (DWORD)G_SIZE (pLocalCounterPath);
                    if (ParseFullPathNameW (szFullPathBuffer,
                        &dwSize, pLocalCounterPath, FALSE)) {
                        // parsed successfully so load into user's buffer
                        if (dwLocalBufferSize != 0) {
                            // see if there's enough room
                            if (dwLocalBufferSize >= dwSize) {
                                // there's room so copy the data
                                szString = (LPWSTR)&pCounterPathElements[1];

                                if (pLocalCounterPath->szMachineName != NULL) {
                                    pCounterPathElements->szMachineName = szString;
                                    lstrcpyW (szString, pLocalCounterPath->szMachineName);
                                    szString += lstrlenW (szString) + 1;
                                    szString = ALIGN_ON_DWORD (szString);
                                } else {
                                    pCounterPathElements->szMachineName = NULL;
                                }

                                if (pLocalCounterPath->szObjectName != NULL) {
                                    pCounterPathElements->szObjectName = szString;
                                    lstrcpyW (szString, pLocalCounterPath->szObjectName);
                                    szString += lstrlenW (szString) + 1;
                                    szString = ALIGN_ON_DWORD (szString);
                                } else {
                                    pCounterPathElements->szObjectName = NULL;
                                }

                                if (pLocalCounterPath->szInstanceName != NULL) {
                                    pCounterPathElements->szInstanceName = szString;
                                    lstrcpyW (szString, pLocalCounterPath->szInstanceName);
                                    szString += lstrlenW (szString) + 1;
                                    szString = ALIGN_ON_DWORD (szString);

                                    if (pLocalCounterPath->szParentName != NULL) {
                                        pCounterPathElements->szParentInstance = szString;
                                        lstrcpyW (szString, pLocalCounterPath->szParentName);
                                        szString+= lstrlenW (szString) + 1;
                                        szString = ALIGN_ON_DWORD (szString);
                                    } else {
                                        pCounterPathElements->szParentInstance = NULL;
                                    }

                                    pCounterPathElements->dwInstanceIndex =
                                        pLocalCounterPath->dwIndex;

                                } else {
                                    pCounterPathElements->szInstanceName = NULL;
                                    pCounterPathElements->szParentInstance = NULL;
                                    pCounterPathElements->dwInstanceIndex = (DWORD)-1;
                                }

                                if (pLocalCounterPath->szCounterName != NULL) {
                                    pCounterPathElements->szCounterName = szString;
                                    lstrcpyW (szString, pLocalCounterPath->szCounterName);
                                    szString += lstrlenW (szString) + 1;
                                    szString = ALIGN_ON_DWORD (szString);
                                } else {
                                    pCounterPathElements->szCounterName = NULL;
                                }

                                assert ((DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements) == dwSize);

                                dwLocalBufferSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);
                                pdhStatus = ERROR_SUCCESS;
                            } else {
                                // not enough room
                                pdhStatus = PDH_MORE_DATA;
                            }
                        } else {
                            // this is just a size check so return size required
                            dwLocalBufferSize = dwSize;
                            pdhStatus = PDH_MORE_DATA;
                        }
                    } else {
                        // unable to read path
                        pdhStatus = PDH_INVALID_PATH;
                    }
                    G_FREE (pLocalCounterPath);
                } else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            } else {
                pdhStatus = PdhiDecodeWbemPathW (
                    szFullPathBuffer,
                    pCounterPathElements,
                    &dwLocalBufferSize,
                    (LANGID)((dwFlags >> 16) & 0x0000FFFF),
                    (DWORD)(dwFlags & 0x0000FFFF));
            }

        }
        *pcchBufferSize = dwLocalBufferSize;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhParseCounterPathA (
    IN      LPCSTR                      szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    IN      LPDWORD                     pcchBufferSize,
    IN      DWORD                       dwFlags
)
/*++

Routine Description:

    Reads a perf counter path string and parses out the
        component fields, returning them in a buffer
        supplied by the calling function.

Arguments:

    IN      LPCSTR                     szFullPathBuffer
                counter path string to parse.
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements
                pointer to buffer supplied by the caller in
                which the component fields will be written
                This buffer is cast as a structure, however, the
                string data is written to the space after
                the buffer.
    IN      LPDWORD                     pcchBufferSize
                the size of the buffer in BYTES. If specified size
                is 0, then the size is estimated and returned
                in this field and the buffer referenced by the
                agrument above is ignored.
    IN      DWORD                       dwFlags
            if 0, then return the path as a REGISTRY path items
            if PDH_PATH_WBEM_RESULT then return the items in WBEM format
            if PDH_PATH_WBEM_INPUT then assume the input is in WBEM format

Return Value:

    ERROR_SUCCESS if the function completes successfully, otherwise
        a PDH error if not
    PDH_INVALID_ARGUMENT is returned when an argument is inocrrect or
        this function does not have the necessary access to that arg.
    PDH_INSUFFICIENT_BUFFER is returned when the buffer supplied is not
        large enough to accept the resulting data.
    PDH_INVALID_PATH is returned when the path is not formatted correctly
        and cannot be parsed.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a temporary buffer
        cannot be allocated

--*/
{
    PPDHI_COUNTER_PATH  pLocalCounterPath = NULL;
    LPWSTR              wszFullPath = NULL;
    PDH_STATUS          pdhStatus  = ERROR_SUCCESS;
    PDH_STATUS          pdhStatus1 = ERROR_SUCCESS;
    DWORD               dwSize;
    DWORD               dwSizeUsed;
    LPSTR               szString;
    DWORD               dwSizeofFullPath;
    DWORD               dwSizeofLocalCounterPath;
    DWORD               dwLocalBufferSize;

    // TODO: Win2K.1 capture pCounterPathElements and szFullPathBuffer

    //validate incoming arguments
    if ((szFullPathBuffer == NULL) || (pcchBufferSize == NULL)) {
        return PDH_INVALID_ARGUMENT;
    }

    __try {
        // the name must be non null
        if (*szFullPathBuffer == 0) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        // capture buffer size locally
        dwLocalBufferSize = *pcchBufferSize;

        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements != NULL) {
                if (dwLocalBufferSize > 0) {
                    // try both "ends" of the buffer to see if an AV occurs
                    *((LPBYTE)pCounterPathElements) = 0;
                    ((LPBYTE)pCounterPathElements)[dwLocalBufferSize - 1] = 0;
                } else {
                    // a 0 length is OK for sizing
                }
            }  // else NULL pointer, which is OK
        }

        if (dwFlags != 0) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        if (pdhStatus == ERROR_SUCCESS) {
            if (dwFlags == 0) {
                dwSize = lstrlenA(szFullPathBuffer) * sizeof(WCHAR);

                dwSizeofFullPath = dwSize + sizeof(WCHAR);
                dwSizeofFullPath = QWORD_MULTIPLE(dwSizeofFullPath);
       
                dwSizeofLocalCounterPath = 
                    sizeof(PDHI_COUNTER_PATH) +         // room for structure
                        (2 * dwSize * sizeof (WCHAR)) ;   // room for string components
                dwSizeofLocalCounterPath = QWORD_MULTIPLE (dwSizeofLocalCounterPath);

                wszFullPath = G_ALLOC (dwSizeofFullPath + dwSizeofLocalCounterPath);

                if (wszFullPath != NULL) {
                    pLocalCounterPath = (PPDHI_COUNTER_PATH)(
                        (LPBYTE)wszFullPath + dwSizeofFullPath);
                    MultiByteToWideChar(_getmbcp(),
                                        0,
                                        szFullPathBuffer,
                                        lstrlenA(szFullPathBuffer),
                                        (LPWSTR) wszFullPath,
                                        dwSizeofFullPath / sizeof(WCHAR));
                    dwSize = (DWORD) dwSizeofLocalCounterPath;
                    if (ParseFullPathNameW (wszFullPath,
                            &dwSize, pLocalCounterPath, FALSE)) {
                        // parsed successfully so load into user's buffer
                        // adjust dwSize to account for single-byte characters
                        // as they'll be packed in user's buffer.

                        // compute require size by adding:
                        //  size of the text strings
                        dwSize = (dwSize -  (sizeof(PDHI_COUNTER_PATH) - sizeof(DWORD))) / sizeof(WCHAR);
                        // + the size of the data structure
                        dwSize += sizeof(PDH_COUNTER_PATH_ELEMENTS_A);
                        // + the allowance for DWORD alignment padding
                        dwSize += (sizeof(DWORD) -1) * 4; // 5 string elements

                        dwSizeUsed = sizeof(PDH_COUNTER_PATH_ELEMENTS);

                        szString = (LPSTR) & pCounterPathElements[1];
                        if (pLocalCounterPath->szMachineName != NULL) {
                            dwSize = (dwLocalBufferSize >= dwSizeUsed)
                                   ? (dwLocalBufferSize - dwSizeUsed) : (0);
                            pdhStatus1 = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                         pLocalCounterPath->szMachineName,
                                         szString,
                                         & dwSize);
                            if (dwSize % sizeof(DWORD) != 0) {
                                dwSize = sizeof(DWORD)
                                       * ((dwSize / sizeof(DWORD)) + 1);
                            }
                            dwSizeUsed += dwSize;
                            if (pdhStatus1 == ERROR_SUCCESS) {
                                szString += dwSize;
                                //szString  = ALIGN_ON_DWORD(szString);
                            }
                            else if (pdhStatus == ERROR_SUCCESS) {
                                pdhStatus = pdhStatus1;
                            }
                        }
                        if (pLocalCounterPath->szMachineName != NULL) {
                            dwSize = (dwLocalBufferSize >= dwSizeUsed)
                                   ? (dwLocalBufferSize - dwSizeUsed) : (0);
                            pdhStatus1 = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                         pLocalCounterPath->szMachineName,
                                         szString,
                                         & dwSize);
                            if (dwSize % sizeof(DWORD) != 0) {
                                dwSize = sizeof(DWORD)
                                       * ((dwSize / sizeof(DWORD)) + 1);
                            }
                            dwSizeUsed += dwSize;
                            if (pdhStatus1 == ERROR_SUCCESS) {
                                pCounterPathElements->szMachineName = szString;
                                szString += dwSize;
                                //szString  = ALIGN_ON_DWORD(szString);
                            }
                            else if (pdhStatus == ERROR_SUCCESS) {
                                pdhStatus = pdhStatus1;
                            }
                        }
                        else if (pCounterPathElements != NULL) {
                            pCounterPathElements->szMachineName = NULL;
                        }

                        if (pLocalCounterPath->szObjectName != NULL) {
                            dwSize = (dwLocalBufferSize >= dwSizeUsed)
                                   ? (dwLocalBufferSize - dwSizeUsed) : (0);
                            pdhStatus1 = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                         pLocalCounterPath->szObjectName,
                                         szString,
                                         & dwSize);
                            if (dwSize % sizeof(DWORD) != 0) {
                                dwSize = sizeof(DWORD)
                                       * ((dwSize / sizeof(DWORD)) + 1);
                            }
                            dwSizeUsed += dwSize;
                            if (pdhStatus1 == ERROR_SUCCESS) {
                                pCounterPathElements->szObjectName = szString;
                                szString += dwSize;
                                //szString  = ALIGN_ON_DWORD(szString);
                            }
                            else if (pdhStatus == ERROR_SUCCESS) {
                                pdhStatus = pdhStatus1;
                            }
                        }
                        else if (pCounterPathElements != NULL) {
                            pCounterPathElements->szObjectName = NULL;
                        }

                        if (pLocalCounterPath->szInstanceName != NULL) {
                            dwSize = (dwLocalBufferSize >= dwSizeUsed)
                                   ? (dwLocalBufferSize - dwSizeUsed) : (0);
                            pdhStatus1 = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                         pLocalCounterPath->szInstanceName,
                                         szString,
                                         & dwSize);
                            if (dwSize % sizeof(DWORD) != 0) {
                                dwSize = sizeof(DWORD)
                                       * ((dwSize / sizeof(DWORD)) + 1);
                            }
                            dwSizeUsed += dwSize;
                            if (pdhStatus1 == ERROR_SUCCESS) {
                                pCounterPathElements->szInstanceName = szString;
                                szString += dwSize;
                                //szString  = ALIGN_ON_DWORD(szString);
                            }
                            else if (pdhStatus == ERROR_SUCCESS) {
                                pdhStatus = pdhStatus1;
                            }
                            if (pLocalCounterPath->szParentName != NULL) {
                                dwSize = (dwLocalBufferSize >= dwSizeUsed)
                                       ? (dwLocalBufferSize - dwSizeUsed) : (0);
                                pdhStatus1 = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                             pLocalCounterPath->szParentName,
                                             szString,
                                             & dwSize);
                                if (dwSize % sizeof(DWORD) != 0) {
                                    dwSize = sizeof(DWORD)
                                           * ((dwSize / sizeof(DWORD)) + 1);
                                }
                                dwSizeUsed += dwSize;
                                if (pdhStatus1 == ERROR_SUCCESS) {
                                    pCounterPathElements->szParentInstance = szString;
                                    szString += dwSize;
                                    //szString  = ALIGN_ON_DWORD(szString);
                                }
                                else if (pdhStatus == ERROR_SUCCESS) {
                                    pdhStatus = pdhStatus1;
                                }
                            }
                            else if (pCounterPathElements != NULL) {
                                pCounterPathElements->szParentInstance = NULL;
                            }
                            if (pCounterPathElements != NULL) {
                                pCounterPathElements->dwInstanceIndex =
                                                    pLocalCounterPath->dwIndex;
                            }
                        }
                        else if (pCounterPathElements != NULL) {
                            pCounterPathElements->szInstanceName   = NULL;
                            pCounterPathElements->szParentInstance = NULL;
                            pCounterPathElements->dwInstanceIndex  = 0;
                        }

                        if (pLocalCounterPath->szCounterName != NULL) {
                            dwSize = (dwLocalBufferSize >= dwSizeUsed)
                                   ? (dwLocalBufferSize - dwSizeUsed) : (0);
                            pdhStatus1 = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                         pLocalCounterPath->szCounterName,
                                         szString,
                                         & dwSize);
                            if (dwSize % sizeof(DWORD) != 0) {
                                dwSize = sizeof(DWORD)
                                       * ((dwSize / sizeof(DWORD)) + 1);
                            }
                            dwSizeUsed += dwSize;
                            if (pdhStatus1 == ERROR_SUCCESS) {
                                pCounterPathElements->szCounterName = szString;
                                szString += dwSize;
                                //szString  = ALIGN_ON_DWORD(szString);
                            }
                            else if (pdhStatus == ERROR_SUCCESS) {
                                pdhStatus = pdhStatus1;
                            }
                        }
                        else if (pCounterPathElements != NULL) {
                            pCounterPathElements->szCounterName = NULL;
                        }
                        dwLocalBufferSize = dwSizeUsed;

                    } else {
                        pdhStatus = PDH_INVALID_PATH;
                    }
                } else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }

                if (wszFullPath != NULL) G_FREE(wszFullPath);
            } else {
                // this is a WBEM path so have the WBEM function figure
                // it out
                // there is some WBEM component involved so send to WBEM function
                // to figure it out
                pdhStatus = PdhiDecodeWbemPathA (
                    szFullPathBuffer,
                    pCounterPathElements,
                    &dwLocalBufferSize,
                    (LANGID)((dwFlags >> 16) & 0x0000FFFF),
                    (DWORD)(dwFlags & 0x0000FFFF));
            }

        }

        *pcchBufferSize = dwLocalBufferSize;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;

}

PDH_FUNCTION
PdhParseInstanceNameW (
    IN      LPCWSTR szInstanceString,
    IN      LPWSTR  szInstanceName,
    IN      LPDWORD pcchInstanceNameLength,
    IN      LPWSTR  szParentName,
    IN      LPDWORD pcchParentNameLength,
    IN      LPDWORD lpIndex
)
/*++

Routine Description:

    parses the fields of an instance string and returns them in the
    buffers supplied by the caller

Arguments:

    szInstanceString
            is the pointer to the string containing the instance substring
            to parse into individual components. This string can contain the
        following formats and less than MAX_PATH chars in length:
        instance
        instance#index
        parent/instance
        parent/instance#index
    szInstanceName
        is the pointer to the buffer that will receive the instance
        name parsed from the instance string. This pointer can be
        NULL if the DWORD referenced by the pcchInstanceNameLength
        argument is 0.
    pcchInstanceNameLength
        is the pointer to the DWORD that contains the length of the
        szInstanceName buffer. If the value of this DWORD is 0, then
        the buffer size required to hold the instance name will be
        returned.
    szParentName
        is the pointer to the buffer that will receive the name
        of the parent index if one is specified. This argument can
        be NULL if the value of the DWORD referenced by the
        pcchParentNameLength argument is 0.
    lpIndex
        is the pointer to the DWORD that will receive the index
        value of the instance. If an index entry is not present in
        the string, then this value will be 0. This argument can
        be NULL if this information is not needed.

Return Value:

    ERROR_SUCCESS if the function completes successfully, otherwise
        a PDH error is returned.
    PDH_INVALID_ARGUMENT is returned when one or more of the
        arguments is invalid or incorrect.
    PDH_INVALID_INSTANCE is returned if the instance string is incorrectly
        formatted and cannot be parsed
    PDH_INSUFFICIENT_BUFFER is returned when one or both of the string
        buffers supplied is not large enough for the strings to be
        returned.

--*/
{
    BOOL        bReturn;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwSize;
    DWORD       dwLocalIndex;

    WCHAR   szLocalInstanceName[MAX_PATH];
    WCHAR   szLocalParentName[MAX_PATH];

    DWORD   dwLocalInstanceNameLength;
    DWORD   dwLocalParentNameLength;

    // test access to arguments

    if ((szInstanceString == NULL) || 
        (pcchInstanceNameLength == NULL) ||
        (pcchParentNameLength == NULL)) {
        return PDH_INVALID_ARGUMENT;
    } 
    __try {
        if (*szInstanceString == 0) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        dwLocalInstanceNameLength = *pcchInstanceNameLength;

        if (szInstanceName != NULL) {
            if (dwLocalInstanceNameLength > 0) {
                WCHAR wChar = *szInstanceName;
                *szInstanceName = 0;
                *szInstanceName = wChar;

                wChar =szInstanceName[dwLocalInstanceNameLength -1];
                szInstanceName[dwLocalInstanceNameLength -1] = 0;
                szInstanceName[dwLocalInstanceNameLength -1] = wChar;
            } // else size only request
        } // else size only request

        dwLocalParentNameLength = *pcchParentNameLength;

        if (szParentName != NULL) {
            if (dwLocalParentNameLength > 0) {
                WCHAR wChar = *szParentName;
                *szParentName = 0;
                *szParentName = wChar;

                wChar = szParentName[dwLocalParentNameLength -1];
                szParentName[dwLocalParentNameLength -1] = 0;
                szParentName[dwLocalParentNameLength -1] = wChar;
            } // else size only request
        } // else size only request
    
        if (pdhStatus == ERROR_SUCCESS) {

            memset (&szLocalInstanceName[0], 0, sizeof(szLocalInstanceName));
            memset (&szLocalParentName[0], 0, sizeof(szLocalParentName));

            bReturn = ParseInstanceName (
                szInstanceString,
                szLocalInstanceName,
                szLocalParentName,
                &dwLocalIndex);

            if (bReturn) {
                dwSize = lstrlenW(szLocalInstanceName);
                if (   szInstanceName != NULL
                    && dwLocalInstanceNameLength > 0) {
                    if (dwSize < dwLocalInstanceNameLength) {
                        lstrcpyW (szInstanceName, szLocalInstanceName);
                    } else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }
                else {
                    pdhStatus = PDH_MORE_DATA;
                }
                dwLocalInstanceNameLength = dwSize + 1; // include the trailing NULL

                dwSize = lstrlenW(szLocalParentName);
                if (szParentName != NULL && dwLocalParentNameLength > 0) {
                    if (dwSize < dwLocalParentNameLength) {
                        lstrcpyW (szParentName, szLocalParentName);
                    } else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }
                else {
                    pdhStatus = PDH_MORE_DATA;
                }
                dwLocalParentNameLength = dwSize + 1; // include the trailing NULL

                __try {
                    *pcchInstanceNameLength = dwLocalInstanceNameLength;
                    *pcchParentNameLength = dwLocalParentNameLength;

                    if (lpIndex != NULL) {
                        *lpIndex = dwLocalIndex;
                    }
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } else {
                // unable to parse string
                pdhStatus = PDH_INVALID_INSTANCE;
            }
        } // else pass the error through

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhParseInstanceNameA (
    IN      LPCSTR  szInstanceString,
    IN      LPSTR   szInstanceName,
    IN      LPDWORD pcchInstanceNameLength,
    IN      LPSTR   szParentName,
    IN      LPDWORD pcchParentNameLength,
    IN      LPDWORD lpIndex
)
/*++

Routine Description:

    parses the fields of an instance string and returns them in the
    buffers supplied by the caller

Arguments:

    szInstanceString
            is the pointer to the string containing the instance substring
            to parse into individual components. This string can contain the
        following formats and less than MAX_PATH chars in length:
        instance
        instance#index
        parent/instance
        parent/instance#index
    szInstanceName
        is the pointer to the buffer that will receive the instance
        name parsed from the instance string. This pointer can be
        NULL if the DWORD referenced by the pcchInstanceNameLength
        argument is 0.
    pcchInstanceNameLength
        is the pointer to the DWORD that contains the length of the
        szInstanceName buffer. If the value of this DWORD is 0, then
        the buffer size required to hold the instance name will be
        returned.
    szParentName
        is the pointer to the buffer that will receive the name
        of the parent index if one is specified. This argument can
        be NULL if the value of the DWORD referenced by the
        pcchParentNameLength argument is 0.
    lpIndex
        is the pointer to the DWORD that will receive the index
        value of the instance. If an index entry is not present in
        the string, then this value will be 0. This argument can
        be NULL if this information is not needed.

Return Value:

    ERROR_SUCCESS if the function completes successfully, otherwise
        a PDH error is returned.
    PDH_INVALID_ARGUMENT is returned when one or more of the
        arguments is invalid or incorrect.
    PDH_INVALID_INSTANCE is returned if the instance string is incorrectly
        formatted and cannot be parsed
    PDH_INSUFFICIENT_BUFFER is returned when one or both of the string
        buffers supplied is not large enough for the strings to be
        returned.

--*/
{
    BOOL    bReturn;
    LONG    pdhStatus = ERROR_SUCCESS;
    DWORD   dwSize;

    WCHAR   wszInstanceString[MAX_PATH];
    WCHAR   wszLocalInstanceName[MAX_PATH];
    WCHAR   wszLocalParentName[MAX_PATH];

    DWORD   dwLocalIndex = 0;

    DWORD   dwLocalInstanceNameLength;
    DWORD   dwLocalParentNameLength;

    // test access to arguments

    if ((szInstanceString == NULL) || 
        (pcchInstanceNameLength == NULL) ||
        (pcchParentNameLength == NULL)) {
        return PDH_INVALID_ARGUMENT;
    } 
    __try {
        if (*szInstanceString == 0) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        dwLocalInstanceNameLength = *pcchInstanceNameLength;

        if (szInstanceName != NULL) {
            if (dwLocalInstanceNameLength > 0) {
                CHAR cChar = *szInstanceName;
                *szInstanceName = 0;
                *szInstanceName = cChar;

                cChar =szInstanceName[dwLocalInstanceNameLength -1];
                szInstanceName[dwLocalInstanceNameLength -1] = 0;
                szInstanceName[dwLocalInstanceNameLength -1] = cChar;
            } // else size only request
        } // else size only request

        dwLocalParentNameLength = *pcchParentNameLength;

        if (szParentName != NULL) {
            if (dwLocalParentNameLength > 0) {
                CHAR cChar = *szParentName;
                *szParentName = 0;
                *szParentName = cChar;

                cChar = szParentName[dwLocalParentNameLength -1];
                szParentName[dwLocalParentNameLength -1] = 0;
                szParentName[dwLocalParentNameLength -1] = cChar;
            } // else size only request
        } // else size only request

        if (pdhStatus == ERROR_SUCCESS) {
            memset (&wszInstanceString[0], 0, sizeof(wszInstanceString));
            memset (&wszLocalInstanceName[0], 0, sizeof(wszLocalInstanceName));
            memset (&wszLocalParentName[0], 0, sizeof(wszLocalParentName));

            dwSize = lstrlenA(szInstanceString) +1 ;
            if (lstrlenA(szInstanceString) < MAX_PATH) {
                MultiByteToWideChar(_getmbcp(),
                                    0,
                                    szInstanceString,
                                    lstrlenA(szInstanceString),
                                    wszInstanceString,
                                    dwSize);
                bReturn = ParseInstanceName (
                    wszInstanceString,
                    wszLocalInstanceName,
                    wszLocalParentName,
                    &dwLocalIndex);
            } else {
                // instance string is too long
                bReturn = FALSE;
                pdhStatus = PDH_INVALID_INSTANCE;
            }

            if (bReturn) {
                PDH_STATUS pdhInstStatus   = ERROR_SUCCESS;
                PDH_STATUS pdhParentStatus = ERROR_SUCCESS;

                dwSize = dwLocalInstanceNameLength;
                pdhInstStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                            wszLocalInstanceName,
                            szInstanceName,
                            & dwSize);
                dwLocalInstanceNameLength = dwSize;

                dwSize = * pcchParentNameLength;
                pdhParentStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                            wszLocalParentName,
                            szParentName,
                            & dwSize);
                if (pdhParentStatus == PDH_INVALID_ARGUMENT) {
                    pdhParentStatus = ERROR_SUCCESS;
                }
                dwLocalParentNameLength = dwSize + 1;
                if (pdhInstStatus != ERROR_SUCCESS) {
                    pdhStatus = pdhInstStatus;
                }
                else {
                    pdhStatus = pdhParentStatus;
                }

                __try {
                    *pcchInstanceNameLength = dwLocalInstanceNameLength;
                    *pcchParentNameLength = dwLocalParentNameLength;

                    if (lpIndex != NULL) {
                        *lpIndex = dwLocalIndex;
                    }
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } else {
                // unable to parse string
                pdhStatus = PDH_INVALID_INSTANCE;
            }
        } // else pass status through to caller

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhValidatePathW (
    IN      LPCWSTR szFullPathBuffer
)
/*++

Routine Description:

    breaks the specified path into its component parts and evaluates
        each of the part to make sure the specified path represents
        a valid and operational performance counter. The return value
        indicates the pdhStatus of the counter defined in the path string.

Arguments:

    IN      LPCWSTR szFullPathBuffer
                the full path string of the counter to validate.

Return Value:

    ERROR_SUCCESS of the counter was successfully located otherwise
        a PDH error.
    PDH_CSTATUS_NO_INSTANCE is returned if the specified instance of
        the performance object wasn't found
    PDH_CSTATUS_NO_COUNTER is returned if the specified counter was not
        found in the object.
    PDH_CSTATUS_NO_OBJECT is returned if the specified object was not
        found on the machine
    PDH_CSTATUS_NO_MACHINE is returned if the specified machine could
        not be found or connected to
    PDH_CSTATUS_BAD_COUNTERNAME is returned when the counter path string
        could not be parsed.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when the function is unable
        to allocate a required temporary buffer
    PDH_INVALID_ARGUMENT is returned when the counter path string argument
        could not be accessed

--*/
{
    PPERF_MACHINE       pMachine;
    PPDHI_COUNTER_PATH  pLocalCounterPath;
    DWORD               dwSize;
    PERF_OBJECT_TYPE    *pPerfObjectDef = NULL;
    PERF_INSTANCE_DEFINITION    *pPerfInstanceDef;
    PERF_COUNTER_DEFINITION     *pPerfCounterDef;
    PDH_STATUS          CStatus = ERROR_SUCCESS;

    DebugPrint((4, "PdhValidatePathW BEGIN\n"));
    
    if (szFullPathBuffer != NULL) {
        // validate access to arguments
        __try {
            // make sure the name isn't empty
            if (*szFullPathBuffer == 0) {
                CStatus = PDH_INVALID_ARGUMENT;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            CStatus = PDH_INVALID_ARGUMENT;
        }
    } else {
        // cannot be null
        CStatus = PDH_INVALID_ARGUMENT;
    }

    if (CStatus == ERROR_SUCCESS) {
        CStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }

    if (CStatus == ERROR_SUCCESS) {
        __try {
            pLocalCounterPath = G_ALLOC (
                (sizeof(PDHI_COUNTER_PATH) +
                    2 * lstrlenW(szFullPathBuffer) * sizeof (WCHAR)));

            if (pLocalCounterPath != NULL) {
                dwSize = (DWORD)G_SIZE (pLocalCounterPath);

                if (ParseFullPathNameW (szFullPathBuffer,
                    &dwSize, pLocalCounterPath, FALSE)) {
                    // parsed successfully so try to connect to machine
                    // and get machine pointer

                    pMachine = GetMachine (pLocalCounterPath->szMachineName, 0);

                    if (pMachine != NULL) {
                        if (pMachine->dwStatus == ERROR_SUCCESS) {
                            // look up object name
                            pPerfObjectDef = GetObjectDefByName (
                                pMachine->pSystemPerfData,
                                pMachine->dwLastPerfString,
                                pMachine->szPerfStrings,
                                pLocalCounterPath->szObjectName);
                        } else {
                            pPerfObjectDef = NULL;
                        }

                        if (pPerfObjectDef != NULL) {
                            // look up instances if necessary
                            if (pPerfObjectDef->NumInstances != PERF_NO_INSTANCES) {
                                if (pLocalCounterPath->szInstanceName != NULL) {
                                    if (*pLocalCounterPath->szInstanceName != SPLAT_L) {
                                        pPerfInstanceDef = GetInstanceByName (
                                            pMachine->pSystemPerfData,
                                            pPerfObjectDef,
                                            pLocalCounterPath->szInstanceName,
                                            pLocalCounterPath->szParentName,
                                            (pLocalCounterPath->dwIndex != (DWORD)-1 ?
                                                pLocalCounterPath->dwIndex : 0));
                                        if (pPerfInstanceDef == NULL) {
                                            // unable to lookup instance
                                            CStatus = PDH_CSTATUS_NO_INSTANCE;
                                        } else {
                                            // instance found and matched so continue
                                        }
                                    } else {
                                        // wild card instances are OK IF multiple instances
                                        // are supported!!!
                                    }
                                } else {
                                    // no instance was specified for a counter
                                    // that should have an instance so this is
                                    // an invalid path
                                    CStatus = PDH_CSTATUS_NO_INSTANCE;
                                }
                            } else {
                                // no instances in this counter, see if one
                                // is defined
                                if ((pLocalCounterPath->szInstanceName != NULL) ||
                                    (pLocalCounterPath->szParentName != NULL)) {
                                    // unable to lookup instance
                                    CStatus = PDH_CSTATUS_NO_INSTANCE;
                                }
                            }

                            if (CStatus == ERROR_SUCCESS) {
                                // and look up counter

                                pPerfCounterDef = GetCounterDefByName (
                                    pPerfObjectDef,
                                    pMachine->dwLastPerfString,
                                    pMachine->szPerfStrings,
                                    pLocalCounterPath->szCounterName);

                                if (pPerfCounterDef != NULL) {
                                    // counter found so return TRUE & valid
                                    CStatus = ERROR_SUCCESS;
                                } else {
                                    // unable to lookup counter
                                    CStatus = PDH_CSTATUS_NO_COUNTER;
                                }
                            }
                        } else {
                            // unable to lookup object
                            CStatus = PDH_CSTATUS_NO_OBJECT;
                        }
                        pMachine->dwRefCount--;
                        RELEASE_MUTEX (pMachine->hMutex);
                    } else {
                        // unable to find machine
                        CStatus = PDH_CSTATUS_NO_MACHINE;
                    }
                } else {
                    // unable to parse counter name
                    CStatus = PDH_CSTATUS_BAD_COUNTERNAME;
                }

                G_FREE (pLocalCounterPath);
            } else {
                // unable to allocate memory
                CStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            CStatus = PDH_INVALID_ARGUMENT;
        }

        RELEASE_MUTEX (hPdhDataMutex);

    } // else pass error to caller

    DebugPrint((4, "PdhValidatePathW END status 0x%08X\n", CStatus));
    return CStatus;
}

PDH_FUNCTION
PdhValidatePathA (
    IN      LPCSTR  szFullPathBuffer
)
/*++


Routine Description:

    breaks the specified path into its component parts and evaluates
        each of the part to make sure the specified path represents
        a valid and operational performance counter. The return value
        indicates the pdhStatus of the counter defined in the path string.

Arguments:

    IN      LPCSTR szFullPathBuffer
                the full path string of the counter to validate.

Return Value:

    ERROR_SUCCESS of the counter was successfully located otherwise
        a PDH error.
    PDH_CSTATUS_NO_INSTANCE is returned if the specified instance of
        the performance object wasn't found
    PDH_CSTATUS_NO_COUNTER is returned if the specified counter was not
        found in the object.
    PDH_CSTATUS_NO_OBJECT is returned if the specified object was not
        found on the machine
    PDH_CSTATUS_NO_MACHINE is returned if the specified machine could
        not be found or connected to
    PDH_CSTATUS_BAD_COUNTERNAME is returned when the counter path string
        could not be parsed.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when the function is unable
        to allocate a required temporary buffer

--*/
{
    LPWSTR  wszFullPath = NULL;
    PDH_STATUS  Status = ERROR_SUCCESS;
    DWORD       dwSize;

    DebugPrint((4, "PdhValidatePathA BEGIN\n"));

    if (szFullPathBuffer != NULL) {
        __try {
            // cannot be blank
            if (*szFullPathBuffer == 0) {
                Status = PDH_INVALID_ARGUMENT;
            } else {
                dwSize = lstrlenA(szFullPathBuffer);
                wszFullPath = G_ALLOC ((dwSize + 1) * sizeof(WCHAR));
                if (wszFullPath != NULL) {
                    MultiByteToWideChar(_getmbcp(),
                                        0,
                                        szFullPathBuffer,
                                        dwSize,
                                        wszFullPath,
                                        dwSize + 1);
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
        }
    } else {
        // cannot be null
        Status = PDH_INVALID_ARGUMENT;
    }

    if (Status == ERROR_SUCCESS) {
        if (wszFullPath != NULL) {
            Status = PdhValidatePathW (wszFullPath);
        } else {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }

    if (wszFullPath != NULL) G_FREE (wszFullPath);

    DebugPrint((4, "PdhValidatePathA END status 0x%08X\n", Status));
    return Status;
}

PDH_FUNCTION
PdhiGetDefaultPerfObjectW (
    IN DWORD   dwDataSource,
    IN LPCWSTR szMachineName,
    IN LPWSTR  szDefaultObjectName,
    IN LPDWORD pcchBufferSize
)
/*++

Routine Description:

    Obtains the default performance object from the specified machine.

Arguments:

    IN      DWORD    dwDataSourcetype
    IN      LPCWSTR szMachineName
                NULL indicates the local machine, othewise this is the
                name of the remote machine to query. If this machine is
                not known to the PDH DLL, then it will be connected.
    IN      LPWSTR  szDefaultObjectName
                pointer to the buffer that will receive the default object
                name. This pointer can be NULL if the value of the DWORD
                referenced by bcchBufferSize is 0.
    IN      LPDWORD pcchBufferSize
                pointer to a DWORD containing the size of the buffer, in
                characters, referenced by the szDefaultObjectName argument.
                If the value of this DWORD is 0, then no data will be written
                to the szDefaultObjectNameBuffer, however the required
                buffer size will be returned in the DWORD referenced by
                this pointer.

Return Value:

    ERROR_SUCCESS if this function completes normally otherwise a PDH error.

    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a required temporary
        buffer could not be allocated.
    PDH_INSUFFICIENT_BUFFER is returned when the buffer supplied is
        not large enough for the available data.
    PDH_CSTATUS_NO_COUNTERNAME is returned when the default object
        name cannot be read or found.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.

--*/
{
    PPERF_MACHINE   pMachine;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    LONG            lDefault;
    DWORD           dwStringLen;
    DWORD           dwLocalBufferSize = 0;
    LPWSTR          szDefault;
    LPWSTR          szThisMachine = NULL;

    DebugPrint((4, "PdhiGetDefaultPerfObjectW BEGIN\n"));

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        // test the access the arguments
        __try {
            if (szMachineName != NULL) {
                // if there's a machine name then it cannot be blank
                if (*szMachineName == 0) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } // else NULL machine Name is OK

            if (pdhStatus == ERROR_SUCCESS) {
                dwLocalBufferSize = *pcchBufferSize;
                if (dwLocalBufferSize > 0) {
                    // test both ends of the caller's buffer for
                    // write access
                    szDefaultObjectName[0] = 0;
                    szDefaultObjectName[dwLocalBufferSize -1] = 0;
                } else {
                    // this is just a size request so the buffer will not be used
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS && szMachineName != NULL) {
        DWORD dwMachineName = (* szMachineName == L'\\')
                            ? (lstrlenW(szMachineName) + 1)
                            : (lstrlenW(szMachineName) + 3);
        dwMachineName *= sizeof(WCHAR);
        szThisMachine = G_ALLOC(dwMachineName);
        if (szThisMachine == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else if (* szMachineName == L'\\') {
            lstrcpyW(szThisMachine, szMachineName);
        }
        else {
            lstrcpyW(szThisMachine, cszDoubleBackSlash);
            lstrcatW(szThisMachine, szMachineName);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pMachine = GetMachine ((LPWSTR)szThisMachine, 0);
                if (pMachine == NULL) {
                    // unable to connect to machine so get pdhStatus
                    pdhStatus = GetLastError();
                }

                if (pMachine != NULL) {
                    if (pMachine->dwStatus == ERROR_SUCCESS) {
                        // only look at buffers from machines that are "on line"
                        lDefault = pMachine->pSystemPerfData->DefaultObject;
                        if ((lDefault > 0) && ((DWORD)lDefault < pMachine->dwLastPerfString)) {
                            // then there should be a string in the table
                            szDefault = (LPWSTR)PdhiLookupPerfNameByIndex (
                                pMachine, lDefault);
                            if (szDefault != NULL) {
                                // determine string buffer length including term. NULL char
                                dwStringLen = lstrlenW (szDefault) + 1;
                                if (dwLocalBufferSize > 0) {
                                    if (dwStringLen <= dwLocalBufferSize) {
                                        lstrcpyW (szDefaultObjectName, szDefault);
                                        pdhStatus = ERROR_SUCCESS;
                                    } else {
                                        pdhStatus = PDH_MORE_DATA;
                                    }
                                }
                                else {
                                    pdhStatus = PDH_MORE_DATA;
                                }
                            } else {
                                // unable to find a matching counter name
                                pdhStatus = PDH_CSTATUS_NO_COUNTERNAME;
                                dwStringLen = 0;
                            }
                        } else {
                            // string not in table
                            pdhStatus = PDH_CSTATUS_NO_COUNTERNAME;
                            dwStringLen = 0;
                        }
                        dwLocalBufferSize = dwStringLen;
                    } else {
                        // machine is off line
                        pdhStatus = pMachine->dwStatus;
                    }
                    pMachine->dwRefCount--;
                    RELEASE_MUTEX (pMachine->hMutex);
                } // else pass error pdhStatus on to the caller
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiGetDefaultWbemObject (
                    szThisMachine,
                    (LPVOID)szDefaultObjectName,
                    &dwLocalBufferSize,
                    TRUE); // unicode function
                break;

            case DATA_SOURCE_LOGFILE:
                // log files don't support this (for now)
                // but this is still successful.
                dwLocalBufferSize = 0;
                *szDefaultObjectName = 0;

                break;

            default:
                assert (FALSE);
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        RELEASE_MUTEX (hPdhDataMutex);

        __try {
            *pcchBufferSize = dwLocalBufferSize;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (szThisMachine != NULL) {
        G_FREE(szThisMachine);
    }
    DebugPrint((4, "PdhiGetDefaultPerfObjectW END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfObjectHW(
    IN HLOG    hDataSource,
    IN LPCWSTR szMachineName,
    IN LPWSTR  szDefaultObjectName,
    IN LPDWORD pcchBufferSize)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    __try {
        dwDataSourceType = DataSourceTypeH(hDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfObjectW(dwDataSourceType,
                                              szMachineName,
                                              szDefaultObjectName,
                                              pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfObjectW(
    IN LPCWSTR szDataSource,
    IN LPCWSTR szMachineName,
    IN LPWSTR  szDefaultObjectName,
    IN LPDWORD pcchBufferSize)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    __try {
        if (szDataSource != NULL) {
            if (* szDataSource == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        dwDataSourceType = DataSourceTypeW(szDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfObjectW(dwDataSourceType,
                                              szMachineName,
                                              szDefaultObjectName,
                                              pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetDefaultPerfObjectA (
    IN DWORD   dwDataSource,
    IN LPCSTR  szMachineName,
    IN LPSTR   szDefaultObjectName,
    IN LPDWORD pcchBufferSize
)
/*++

Routine Description:

    Obtains the default performance object from the specified machine.

Arguments:

    IN      DWORD   dwDataSourceType
    IN      LPCSTR szMachineName
                NULL indicates the local machine, othewise this is the
                name of the remote machine to query. If this machine is
                not known to the PDH DLL, then it will be connected.
    IN      LPSTR  szDefaultObjectName
                pointer to the buffer that will receive the default object
                name. This pointer can be NULL if the value of the DWORD
                referenced by bcchBufferSize is 0.
    IN      LPDWORD pcchBufferSize
                pointer to a DWORD containing the size of the buffer, in
                characters, referenced by the szDefaultObjectName argument.
                If the value of this DWORD is 0, then no data will be written
                to the szDefaultObjectNameBuffer, however the required
                buffer size will be returned in the DWORD referenced by
                this pointer.

Return Value:

    ERROR_SUCCESS if this function completes normally otherwise a PDH error.

    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a required temporary
        buffer could not be allocated.
    PDH_INSUFFICIENT_BUFFER is returned when the buffer supplied is
        not large enough for the available data.
    PDH_CSTATUS_NO_COUNTERNAME is returned when the default object
        name cannot be read or found.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.

--*/
{
    LPWSTR      szWideName = NULL;
    DWORD       dwNameLength;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    PPERF_MACHINE   pMachine = NULL;
    LONG            lDefault;
    DWORD       dwStringLen;
    DWORD       dwLocalBufferSize = 0;
    LPWSTR      szDefault = NULL;

    DebugPrint((4, "PdhiGetDefaultPerfObjectA BEGIN\n"));
    if (pcchBufferSize == NULL) {
        return PDH_INVALID_ARGUMENT;
    }
    // test the access the arguments
    __try {
        if (szMachineName != NULL) {
            if (*szMachineName == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL machine Name is OK

        if (pdhStatus == ERROR_SUCCESS) {
            dwLocalBufferSize = *pcchBufferSize;
            if (dwLocalBufferSize > 0) {
                // test both ends of the caller's buffer for
                // write access
                szDefaultObjectName[0] = 0;
                szDefaultObjectName[dwLocalBufferSize -1] = 0;
            } else {
                // this is just a size request so the buffer will not be used
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS && szMachineName != NULL) {
        dwNameLength = (* szMachineName == '\\')
                     ? (lstrlenA(szMachineName) + 1)
                     : (lstrlenA(szMachineName) + 3);
        szWideName = G_ALLOC (dwNameLength * sizeof(WCHAR));
        if (szWideName == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else if (* szMachineName == '\\') {
            MultiByteToWideChar(_getmbcp(),
                                0,
                                szMachineName,
                                lstrlenA(szMachineName),
                                (LPWSTR) szWideName,
                                dwNameLength);
        }
        else {
            LPWSTR szThisMachine = szWideName + 2;
            lstrcpyW(szWideName, cszDoubleBackSlash);
            MultiByteToWideChar(_getmbcp(),
                                0,
                                szMachineName,
                                lstrlenA(szMachineName),
                                (LPWSTR) szThisMachine,
                                dwNameLength - 2);
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                if (pdhStatus == ERROR_SUCCESS) {
                    pMachine = GetMachine (szWideName, 0);
                    if (pMachine == NULL) {
                        // unable to connect to machine so get pdhStatus
                        pdhStatus = GetLastError();
                    } else {
                        pdhStatus = ERROR_SUCCESS;
                    }
                }
                if (pMachine != NULL) {
                    if (pMachine->dwStatus == ERROR_SUCCESS) {
                        // only look at buffers from machines that are "on line"
                        lDefault = pMachine->pSystemPerfData->DefaultObject;
                        if ((lDefault > 0) && ((DWORD)lDefault < pMachine->dwLastPerfString)) {
                            // then there should be a string in the table
                            szDefault = (LPWSTR)PdhiLookupPerfNameByIndex (
                                pMachine, lDefault);
                            if (szDefault != NULL) {
                                // determine string buffer length including term. NULL char
                                dwStringLen = dwLocalBufferSize;
                                pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                            szDefault,
                                            szDefaultObjectName,
                                            & dwStringLen);
                            } else {
                                // unable to find a matching counter name
                                pdhStatus = PDH_CSTATUS_NO_COUNTERNAME;
                                dwStringLen = 0;
                            }
                        } else {
                            // string not in table
                            pdhStatus = PDH_CSTATUS_NO_COUNTERNAME;
                            dwStringLen = 0;
                        }
                        dwLocalBufferSize = dwStringLen;
                    } else {
                        // machine is off line
                        pdhStatus = pMachine->dwStatus;
                    }
                    pMachine->dwRefCount--;
                    RELEASE_MUTEX (pMachine->hMutex);
                } // else pass error pdhStatus on to the caller
                break;

            case DATA_SOURCE_WBEM:
            case DATA_SOURCE_LOGFILE:
                if ((pdhStatus == ERROR_SUCCESS) && (dwDataSource == DATA_SOURCE_WBEM)) {
                    pdhStatus = PdhiGetDefaultWbemObject (
                            szWideName,
                            (LPVOID)szDefaultObjectName,
                            &dwLocalBufferSize,
                            FALSE); // ANSI function
                } else {
                    //log files don't support this (for now)
                    dwLocalBufferSize = 0;
                    *szDefaultObjectName = 0;
                }
                break;

            default:
                assert (FALSE);
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        RELEASE_MUTEX (hPdhDataMutex);

        __try {
            *pcchBufferSize = dwLocalBufferSize;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (szWideName != NULL) G_FREE (szWideName);

    DebugPrint((4, "PdhiGetDefaultPerfObjectA END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfObjectHA(
    IN HLOG    hDataSource,
    IN LPCSTR  szMachineName,
    IN LPSTR   szDefaultObjectName,
    IN LPDWORD pcchBufferSize)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    __try {
        dwDataSourceType = DataSourceTypeH(hDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfObjectA(dwDataSourceType,
                                              szMachineName,
                                              szDefaultObjectName,
                                              pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfObjectA(
    IN LPCSTR  szDataSource,
    IN LPCSTR  szMachineName,
    IN LPSTR   szDefaultObjectName,
    IN LPDWORD pcchBufferSize)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    __try {
        if (szDataSource != NULL) {
            if (* szDataSource == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        dwDataSourceType = DataSourceTypeA(szDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfObjectA(dwDataSourceType,
                                              szMachineName,
                                              szDefaultObjectName,
                                              pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetDefaultPerfCounterW (
    IN DWORD   dwDataSource,
    IN LPCWSTR szMachineName,
    IN LPCWSTR szObjectName,
    IN LPWSTR  szDefaultCounterName,
    IN LPDWORD pcchBufferSize
)
/*++

Routine Description:

    Obtains the default performance counter from the specified object on
        the specified machine.

Arguments:

    IN      DWORD   dwDataSource
    IN      LPCWSTR szMachineName
                NULL indicates the local machine, othewise this is the
                name of the remote machine to query. If this machine is
                not known to the PDH DLL, then it will be connected.
    IN      LPCWSTR szObjectName
                a pointer to the buffer that contains the name of the object
                on the machine to find the default counter for.
    IN      LPWSTR  szDefaultCounterName
                pointer to the buffer that will receive the default counter
                name. This pointer can be NULL if the value of the DWORD
                referenced by bcchBufferSize is 0.
    IN      LPDWORD pcchBufferSize
                pointer to a DWORD containing the size of the buffer, in
                characters, referenced by the szDefaultObjectName argument.
                If the value of this DWORD is 0, then no data will be written
                to the szDefaultObjectNameBuffer, however the required
                buffer size will be returned in the DWORD referenced by
                this pointer.

Return Value:

    ERROR_SUCCESS if this function completes normally otherwise a PDH error.

    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a required temporary
        buffer could not be allocated.
    PDH_INSUFFICIENT_BUFFER is returned when the buffer supplied is
        not large enough for the available data.
    PDH_CSTATUS_NO_COUNTERNAME is returned when the name string for the
        default counter could not be found.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_CSTATUS_NO_OBJECT is returned when the specified object could
        not be found on the specified computer.
    PDH_CSTATUS_NO_COUNTER is returned when the default counter is not
        found in the data buffer.

--*/
{
    PPERF_MACHINE   pMachine;
    PERF_OBJECT_TYPE    *pObjectDef;
    PPERF_COUNTER_DEFINITION    pCounterDef;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    LONG            lDefault;
    DWORD           dwStringLen;
    DWORD           dwLocalBufferSize = 0;
    LPWSTR          szDefault;
    LPWSTR          szThisMachine = NULL;

    DebugPrint((4, "PdhiGetDefaultPerfCounterW BEGIN\n"));

    if ((szObjectName == NULL) ||
        (pcchBufferSize == NULL)) {
         pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        // test the access the arguments
        __try {
            if (szMachineName != NULL) {
                if (*szMachineName == 0) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } // else NULL machine Name is OK

            if (pdhStatus == ERROR_SUCCESS) {
                if (szObjectName != NULL) {
                    if (*szObjectName == 0) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    // Null Object is not allowed
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwLocalBufferSize = *pcchBufferSize;

                if (dwLocalBufferSize > 0) {
                    // test both ends of the caller's buffer for
                    // write access
                    szDefaultCounterName[0] = 0;
                    szDefaultCounterName[dwLocalBufferSize -1] = 0;
                } else {
                    // this is just a size request so the buffer will not be used
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS && szMachineName != NULL) {
        DWORD dwMachineName = (* szMachineName == L'\\')
                            ? (lstrlenW(szMachineName) + 1)
                            : (lstrlenW(szMachineName) + 3);
        dwMachineName *= sizeof(WCHAR);
        szThisMachine = G_ALLOC(dwMachineName);
        if (szThisMachine == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else if (* szMachineName == L'\\') {
            lstrcpyW(szThisMachine, szMachineName);
        }
        else {
            lstrcpyW(szThisMachine, cszDoubleBackSlash);
            lstrcatW(szThisMachine, szMachineName);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pMachine = GetMachine ((LPWSTR)szThisMachine, 0);
                if (pMachine == NULL) {
                    // unable to connect to machine so get pdhStatus
                    pdhStatus = GetLastError();
                } else {
                    pdhStatus = pMachine->dwStatus;
                }

                if (pdhStatus == ERROR_SUCCESS) {
                    // get object pointer

                    pObjectDef = GetObjectDefByName (
                        pMachine->pSystemPerfData,
                        pMachine->dwLastPerfString,
                        pMachine->szPerfStrings,
                        szObjectName);

                    if (pObjectDef != NULL) {
                        // default counter reference is an index into the list
                        // of counter definition entries so walk down list of
                        // counters defs to find the default one
                        if (pObjectDef->DefaultCounter < (LONG)pObjectDef->NumCounters) {
                            // then the default index should be this buffer
                            lDefault = 0;
                            pCounterDef = FirstCounter (pObjectDef);
                            while ((lDefault < pObjectDef->DefaultCounter) &&
                                (lDefault < (LONG)pObjectDef->NumCounters)) {
                                pCounterDef = NextCounter (pCounterDef);
                                lDefault++;
                            }

                            lDefault = pCounterDef->CounterNameTitleIndex;
                            if ((lDefault > 0) && ((DWORD)lDefault < pMachine->dwLastPerfString)) {
                                // then there should be a string in the table
                                szDefault = (LPWSTR)PdhiLookupPerfNameByIndex (
                                    pMachine, lDefault);
                                dwStringLen = lstrlenW (szDefault) + 1;
                                if (dwLocalBufferSize > 0) {
                                    if (dwStringLen <= dwLocalBufferSize) {
                                        lstrcpyW (szDefaultCounterName, szDefault);
                                        pdhStatus = ERROR_SUCCESS;
                                    } else {
                                        pdhStatus = PDH_MORE_DATA;
                                    }
                                }
                                else {
                                    pdhStatus = PDH_MORE_DATA;
                                }
                                dwLocalBufferSize = dwStringLen;
                            } else {
                                // string index is not valid
                                dwLocalBufferSize = 0;
                                pdhStatus = PDH_CSTATUS_NO_COUNTER;
                            }
                        } else {
                            // the counter entry is not in the buffer
                            dwLocalBufferSize = 0;
                            pdhStatus = PDH_CSTATUS_NO_COUNTER;
                        }
                    } else {
                        // unable to find object
                        dwLocalBufferSize = 0;
                        pdhStatus = PDH_CSTATUS_NO_OBJECT;
                    }
                    pMachine->dwRefCount--;
                    RELEASE_MUTEX (pMachine->hMutex);
                } // else pass pdhStatus value to caller
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiGetDefaultWbemProperty (
                    szThisMachine,
                    szObjectName,
                    szDefaultCounterName,
                    &dwLocalBufferSize,
                    TRUE);
                break;

            case DATA_SOURCE_LOGFILE:
                *szDefaultCounterName = 0;
                dwLocalBufferSize = 0;

                break;

            default:
                assert (FALSE);
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        RELEASE_MUTEX (hPdhDataMutex);

        __try {
            *pcchBufferSize = dwLocalBufferSize;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (szThisMachine != NULL) G_FREE(szThisMachine);
    DebugPrint((4, "PdhiGetDefaultPerfCounterW END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfCounterHW (
    IN HLOG    hDataSource,
    IN LPCWSTR szMachineName,
    IN LPCWSTR szObjectName,
    IN LPWSTR  szDefaultCounterName,
    IN LPDWORD pcchBufferSize)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    __try {
        dwDataSourceType = DataSourceTypeH(hDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfCounterW(dwDataSourceType,
                                               szMachineName,
                                               szObjectName,
                                               szDefaultCounterName,
                                               pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfCounterW(
    IN LPCWSTR szDataSource,
    IN LPCWSTR szMachineName,
    IN LPCWSTR szObjectName,
    IN LPWSTR  szDefaultCounterName,
    IN LPDWORD pcchBufferSize)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    __try {
        if (szDataSource != NULL) {
            if (* szDataSource == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        dwDataSourceType = DataSourceTypeW(szDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfCounterW(dwDataSourceType,
                                               szMachineName,
                                               szObjectName,
                                               szDefaultCounterName,
                                               pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetDefaultPerfCounterA (
    IN DWORD   dwDataSource,
    IN LPCSTR  szMachineName,
    IN LPCSTR  szObjectName,
    IN LPSTR   szDefaultCounterName,
    IN LPDWORD pcchBufferSize
)
/*++

Routine Description:

    Obtains the default performance counter from the specified object on
        the specified machine.

Arguments:

    IN      DWORD  dwDataSource
    IN      LPCSTR szMachineName
                NULL indicates the local machine, othewise this is the
                name of the remote machine to query. If this machine is
                not known to the PDH DLL, then it will be connected.
    IN      LPCSTR szObjectName
                a pointer to the buffer that contains the name of the object
                on the machine to find the default counter for.
    IN      LPSTR  szDefaultCounterName
                pointer to the buffer that will receive the default counter
                name. This pointer can be NULL if the value of the DWORD
                referenced by bcchBufferSize is 0.
    IN      LPDWORD pcchBufferSize
                pointer to a DWORD containing the size of the buffer, in
                characters, referenced by the szDefaultObjectName argument.
                If the value of this DWORD is 0, then no data will be written
                to the szDefaultObjectNameBuffer, however the required
                buffer size will be returned in the DWORD referenced by
                this pointer.

Return Value:

    ERROR_SUCCESS if this function completes normally otherwise a PDH error.

    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a required temporary
        buffer could not be allocated.
    PDH_INSUFFICIENT_BUFFER is returned when the buffer supplied is
        not large enough for the available data.
    PDH_CSTATUS_NO_COUNTERNAME is returned when the name string for the
        default counter could not be found.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_CSTATUS_NO_OBJECT is returned when the specified object could
        not be found on the specified computer.
    PDH_CSTATUS_NO_COUNTER is returned when the default counter is not
        found in the data buffer.

--*/
{
    LPWSTR              szWideObject = NULL;
    LPWSTR              szWideName = NULL;
    DWORD               dwNameLength;
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    PPERF_MACHINE       pMachine = NULL;
    PPERF_OBJECT_TYPE   pObjectDef = NULL;
    PPERF_COUNTER_DEFINITION    pCounterDef;
    LONG                lDefault;
    DWORD               dwStringLen;
    DWORD               dwLocalBufferSize = 0;
    LPWSTR              szDefault;

    DebugPrint((4, "PdhGetDefaultPerfCounterA BEGIN\n"));

    if ((szObjectName == NULL) ||
        (pcchBufferSize == NULL)) {
         pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        // test the access the arguments
        __try {
            if (szMachineName != NULL) {
                if (*szMachineName == 0) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } // else NULL machine Name is OK

            if (pdhStatus == ERROR_SUCCESS) {
                if (szObjectName != NULL) {
                    if (*szObjectName == 0) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    // null objects are not allowed
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwLocalBufferSize = *pcchBufferSize;
                if (dwLocalBufferSize > 0) {
                    // test both ends of the caller's buffer for
                    // write access
                    szDefaultCounterName[0] = 0;
                    szDefaultCounterName[dwLocalBufferSize -1] = 0;
                } else {
                    // this is just a size request so the buffer will not be used
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS && szMachineName != NULL) {
        dwNameLength = (* szMachineName == '\\')
                     ? (lstrlenA(szMachineName) + 1)
                     : (lstrlenA(szMachineName) + 3);
        szWideName = G_ALLOC (dwNameLength * sizeof(WCHAR));
        if (szWideName == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else if (* szMachineName == '\\') {
            MultiByteToWideChar(_getmbcp(),
                                0,
                                szMachineName,
                                lstrlenA(szMachineName),
                                (LPWSTR) szWideName,
                                dwNameLength);
        }
        else {
            LPWSTR szThisMachine = szWideName + 2;
            lstrcpyW(szWideName, cszDoubleBackSlash);
            MultiByteToWideChar(_getmbcp(),
                                0,
                                szMachineName,
                                lstrlenA(szMachineName),
                                (LPWSTR) szThisMachine,
                                dwNameLength - 2);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
        
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                if (pdhStatus == ERROR_SUCCESS) {
                    pMachine = GetMachine (szWideName, 0);
                    if (pMachine == NULL) {
                        // unable to connect to machine so get pdhStatus
                        pdhStatus = GetLastError();
                    } else {
                        pdhStatus = ERROR_SUCCESS;
                    }
                }
                if (szWideName != NULL) {
                    G_FREE (szWideName);
                    szWideName = NULL;
                }
                if ((pdhStatus == ERROR_SUCCESS) && (pMachine != NULL)) {
                    // get selected object

                    dwNameLength = lstrlenA (szObjectName);

                    szWideName = G_ALLOC ((dwNameLength+1) * sizeof(WCHAR));
                    if (szWideName == NULL) {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    } else {
                        MultiByteToWideChar(_getmbcp(),
                                            0,
                                            szObjectName,
                                            dwNameLength,
                                            szWideName,
                                            dwNameLength + 1);

                        pObjectDef = GetObjectDefByName (
                            pMachine->pSystemPerfData,
                            pMachine->dwLastPerfString,
                            pMachine->szPerfStrings,
                            szWideName);

                        G_FREE (szWideName);
                    }

                    if (pObjectDef != NULL) {
                        // default counter reference is an index into the list
                        // of counter definition entries so walk down list of
                        // counters defs to find the default one
                        if (pObjectDef->DefaultCounter < (LONG)pObjectDef->NumCounters) {
                            // then the default index should be this buffer
                            lDefault = 0;
                            pCounterDef = FirstCounter (pObjectDef);
                            while ((lDefault < pObjectDef->DefaultCounter) &&
                                (lDefault < (LONG)pObjectDef->NumCounters)) {
                                pCounterDef = NextCounter (pCounterDef);
                                lDefault++;
                            }

                            lDefault = pCounterDef->CounterNameTitleIndex;
                            if ((lDefault > 0) && ((DWORD)lDefault < pMachine->dwLastPerfString)) {
                                // then there should be a string in the table
                                szDefault = (LPWSTR)PdhiLookupPerfNameByIndex (
                                        pMachine, lDefault);
                                dwStringLen = dwLocalBufferSize;
                                pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                            szDefault,
                                            szDefaultCounterName,
                                            & dwStringLen);
                                dwLocalBufferSize = dwStringLen;
                            } else {
                                // string index is not valid
                                dwLocalBufferSize = 0;
                                pdhStatus = PDH_CSTATUS_NO_COUNTER;
                            }
                        } else {
                            // the counter entry is not in the buffer
                            dwLocalBufferSize = 0;
                            pdhStatus = PDH_CSTATUS_NO_COUNTER;
                        }
                    } else {
                        // unable to find object
                        dwLocalBufferSize = 0;
                        pdhStatus = PDH_CSTATUS_NO_OBJECT;
                    }
                    pMachine->dwRefCount--;
                    RELEASE_MUTEX (pMachine->hMutex);
                } else {
                    // unable to find machine
                    pdhStatus = GetLastError();
                }
                break;

            case DATA_SOURCE_WBEM:
            case DATA_SOURCE_LOGFILE:
                if ((pdhStatus == ERROR_SUCCESS) && (dwDataSource == DATA_SOURCE_WBEM)) {
                    dwNameLength = lstrlenA (szObjectName);
                    szWideObject = G_ALLOC ((dwNameLength + 1) * sizeof(WCHAR));
                    if (szWideObject == NULL) {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    } else {
                        MultiByteToWideChar(_getmbcp(),
                                            0,
                                            szObjectName,
                                            dwNameLength,
                                            szWideObject,
                                            dwNameLength + 1);
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        pdhStatus = PdhiGetDefaultWbemProperty (
                            szWideName,
                            szWideObject,
                            (LPVOID)szDefaultCounterName,
                            &dwLocalBufferSize,
                            FALSE); // ANSI function
                    }
                } else {
                    //log files don't support this (for now)
                    dwLocalBufferSize = 0;
                    *szDefaultCounterName = 0;
                }
                if (szWideName != NULL) G_FREE (szWideName);
                if (szWideObject != NULL) G_FREE (szWideObject);
                break;

            default:
                assert (FALSE);

            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX (hPdhDataMutex);

        __try {
            *pcchBufferSize = dwLocalBufferSize;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    DebugPrint((4, "PdhGetDefaultPerfCounterA END status 0x%08X\n", pdhStatus));
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfCounterHA (
    IN HLOG    hDataSource,
    IN LPCSTR  szMachineName,
    IN LPCSTR  szObjectName,
    IN LPSTR   szDefaultCounterName,
    IN LPDWORD pcchBufferSize)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    __try {
        dwDataSourceType = DataSourceTypeH(hDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfCounterA(dwDataSourceType,
                                               szMachineName,
                                               szObjectName,
                                               szDefaultCounterName,
                                               pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfCounterA(
    IN LPCSTR  szDataSource,
    IN LPCSTR  szMachineName,
    IN LPCSTR  szObjectName,
    IN LPSTR   szDefaultCounterName,
    IN LPDWORD pcchBufferSize)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    __try {
        if (szDataSource != NULL) {
            if (* szDataSource == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        dwDataSourceType = DataSourceTypeA(szDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfCounterA(dwDataSourceType,
                                               szMachineName,
                                               szObjectName,
                                               szDefaultCounterName,
                                               pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhBrowseCountersHW (
    IN PPDH_BROWSE_DLG_CONFIG_HW  pBrowseDlgData)
{
    PDHI_BROWSE_DLG_INFO  pInfo;
    LPWSTR                szResource;
    int                   nDlgReturn;
    DWORD                 dwReturn = ERROR_SUCCESS;

    pInfo.pWideStruct = (PPDH_BROWSE_DLG_CONFIG_W) pBrowseDlgData;
    pInfo.pAnsiStruct = NULL;

    if (pBrowseDlgData != NULL) {
        __try {
            // copy the data source since it wide characters already
            pInfo.hDataSource = pBrowseDlgData->hDataSource;

            szResource = MAKEINTRESOURCEW (
                pBrowseDlgData->bShowObjectBrowser ?
                    IDD_BROWSE_OBJECTS :
                    pBrowseDlgData->bSingleCounterPerDialog ?
                        IDD_BROWSE_COUNTERS_SIM :
                        IDD_BROWSE_COUNTERS_EXT);
            nDlgReturn = (int)DialogBoxParamW (ThisDLLHandle,
                    szResource,
                    pBrowseDlgData->hWndOwner,
                    BrowseCounterDlgProc,
                    (LPARAM)&pInfo);

            if (nDlgReturn == -1) {
                dwReturn = GetLastError();
            } else {
                dwReturn = (nDlgReturn == IDOK)
                         ? ERROR_SUCCESS : PDH_DIALOG_CANCELLED;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    } else {
        dwReturn = PDH_INVALID_ARGUMENT;
    }
    return dwReturn;
}

PDH_FUNCTION
PdhBrowseCountersHA (
    IN PPDH_BROWSE_DLG_CONFIG_HA  pBrowseDlgData)
{
    PDHI_BROWSE_DLG_INFO  pInfo;
    LPWSTR                szResource;
    int                   nDlgReturn;
    DWORD                 dwReturn = ERROR_SUCCESS;

    pInfo.pAnsiStruct = (PPDH_BROWSE_DLG_CONFIG_A) pBrowseDlgData;
    pInfo.pWideStruct = NULL;

    if (pBrowseDlgData != NULL) {
        __try {
            // copy the data source since it wide characters already
            pInfo.hDataSource = pBrowseDlgData->hDataSource;

            szResource = MAKEINTRESOURCEW (
                pBrowseDlgData->bShowObjectBrowser ?
                    IDD_BROWSE_OBJECTS :
                    pBrowseDlgData->bSingleCounterPerDialog ?
                        IDD_BROWSE_COUNTERS_SIM :
                        IDD_BROWSE_COUNTERS_EXT);
            nDlgReturn = (int)DialogBoxParamW (ThisDLLHandle,
                    szResource,
                    pBrowseDlgData->hWndOwner,
                    BrowseCounterDlgProc,
                    (LPARAM)&pInfo);

            if (nDlgReturn == -1) {
                dwReturn = GetLastError();
            } else {
                dwReturn = (nDlgReturn == IDOK)
                         ? ERROR_SUCCESS : PDH_DIALOG_CANCELLED;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    } else {
        dwReturn = PDH_INVALID_ARGUMENT;
    }
    return dwReturn;
}

PDH_FUNCTION
PdhBrowseCountersW (
    IN      PPDH_BROWSE_DLG_CONFIG_W    pBrowseDlgData
)
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    PDHI_BROWSE_DLG_INFO    pInfo;
    LPWSTR      szResource;
    int         nDlgReturn;
    DWORD       dwReturn = ERROR_SUCCESS;

    pInfo.pWideStruct = pBrowseDlgData;
    pInfo.pAnsiStruct = NULL;

    if (pBrowseDlgData != NULL) {
        __try {
            DWORD dwDataSource = DataSourceTypeW (pBrowseDlgData->szDataSource);

            if (dwDataSource == DATA_SOURCE_WBEM) {
                pInfo.hDataSource = H_WBEM_DATASOURCE;
            }
            else if (dwDataSource == DATA_SOURCE_LOGFILE) {
                DWORD dwLogType = 0;

                dwReturn = PdhOpenLogW(
                            pBrowseDlgData->szDataSource,
                            PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                          & dwLogType,
                            NULL,
                            0,
                            NULL,
                          & pInfo.hDataSource);
            }
            else {
                pInfo.hDataSource = H_REALTIME_DATASOURCE;
            }

            if (dwReturn == ERROR_SUCCESS) {
                szResource = MAKEINTRESOURCEW (
                        pBrowseDlgData->bShowObjectBrowser ?
                            IDD_BROWSE_OBJECTS :
                        pBrowseDlgData->bSingleCounterPerDialog ?
                            IDD_BROWSE_COUNTERS_SIM : 
                            IDD_BROWSE_COUNTERS_EXT);
                nDlgReturn = (int)DialogBoxParamW (ThisDLLHandle,
                            szResource,
                            pBrowseDlgData->hWndOwner,
                            BrowseCounterDlgProc,
                            (LPARAM)&pInfo);

                if (nDlgReturn == -1) {
                    dwReturn = GetLastError();
                } else {
                    dwReturn = nDlgReturn == IDOK ? ERROR_SUCCESS : PDH_DIALOG_CANCELLED;
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    } else {
        dwReturn = PDH_INVALID_ARGUMENT;
    }
    return dwReturn;
}

PDH_FUNCTION
PdhBrowseCountersA (
    IN      PPDH_BROWSE_DLG_CONFIG_A    pBrowseDlgData
)
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    PDHI_BROWSE_DLG_INFO    pInfo;
    LPWSTR      szResource;
    int         nDlgReturn;
    DWORD       dwReturn = ERROR_SUCCESS;

    pInfo.pAnsiStruct = pBrowseDlgData;
    pInfo.pWideStruct = NULL;

    if (pBrowseDlgData != NULL) {
        __try {
            DWORD dwDataSource = DataSourceTypeA(pBrowseDlgData->szDataSource);

            if (dwDataSource == DATA_SOURCE_WBEM) {
                pInfo.hDataSource = H_WBEM_DATASOURCE;
            }
            else if (dwDataSource == DATA_SOURCE_LOGFILE) {
                DWORD dwLogType = 0;

                dwReturn = PdhOpenLogA(
                        pBrowseDlgData->szDataSource,
                        PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                        & dwLogType,
                        NULL,
                        0,
                        NULL,
                        & pInfo.hDataSource);
            }
            else {
                pInfo.hDataSource = H_REALTIME_DATASOURCE;
            }

            if (dwReturn == ERROR_SUCCESS) {
                szResource = MAKEINTRESOURCEW (
                        pBrowseDlgData->bShowObjectBrowser ?
                            IDD_BROWSE_OBJECTS :
                        pBrowseDlgData->bSingleCounterPerDialog ?
                            IDD_BROWSE_COUNTERS_SIM : 
                            IDD_BROWSE_COUNTERS_EXT);

                nDlgReturn = (int)DialogBoxParamW (ThisDLLHandle,
                            szResource,
                            pBrowseDlgData->hWndOwner,
                            BrowseCounterDlgProc,
                            (LPARAM)&pInfo);

                if (nDlgReturn == -1) {
                    dwReturn = GetLastError();
                } else {
                    dwReturn = nDlgReturn == IDOK ? ERROR_SUCCESS : PDH_DIALOG_CANCELLED;
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    } else {
        dwReturn = PDH_INVALID_ARGUMENT;
    }

    return dwReturn;
}

LPWSTR
PdhiGetExplainText (
    IN  LPCWSTR     szMachineName,
    IN  LPCWSTR     szObjectName,
    IN  LPCWSTR     szCounterName
)
{
    PPERF_MACHINE       pMachine;
    PERF_OBJECT_TYPE    *pObjectDef;
    PERF_COUNTER_DEFINITION *pCounterDef;
    LPWSTR              szReturnString = NULL;

    pMachine = GetMachine ((LPWSTR)szMachineName, 0);

    if (pMachine != NULL) {

        // make sure the machine connection is valid
        if (pMachine->dwStatus == ERROR_SUCCESS) {

            pObjectDef = GetObjectDefByName (
                pMachine->pSystemPerfData,
                pMachine->dwLastPerfString,
                pMachine->szPerfStrings,
                szObjectName);

            if (pObjectDef != NULL) {
                if (szCounterName != NULL) {
                    pCounterDef = GetCounterDefByName (
                            pObjectDef,
                            pMachine->dwLastPerfString,
                            pMachine->szPerfStrings,
                            (LPWSTR)szCounterName);

                    if ((pCounterDef != NULL) && 
                        (pCounterDef->CounterHelpTitleIndex <= pMachine->dwLastPerfString)) {
                    // return string from array
                        szReturnString = pMachine->szPerfStrings[pCounterDef->CounterHelpTitleIndex];
                    } else {
                        // counter not found
                    }
                }
                else if (pObjectDef->ObjectHelpTitleIndex <= pMachine->dwLastPerfString) {
                    szReturnString = pMachine->szPerfStrings[pObjectDef->ObjectHelpTitleIndex];
                }
            } else {
                // object not found
            }
        } else {
            // machine not accessible
        }
        pMachine->dwRefCount--;
        RELEASE_MUTEX (pMachine->hMutex);
    } else {
        // machine not found
    }
    return szReturnString;
}

BOOL
IsWbemDataSource (
    IN  LPCWSTR  szDataSource
)
{
    BOOL    bReturn = FALSE;
    __try {
        if (DataSourceTypeW(szDataSource) == DATA_SOURCE_WBEM)
            bReturn = TRUE;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError (GetExceptionCode());
    }
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhui\expldlg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    expldlg.h

Abstract:

    <abstract>

--*/

#ifndef _EXPLDLG_H_
#define _EXPLDLG_H_

// dialog box messages

#define EDM_EXPLAIN_DLG_CLOSING (WM_USER+0x100)
#define EDM_UPDATE_EXPLAIN_TEXT (WM_USER+0x101)
#define EDM_UPDATE_TITLE_TEXT   (WM_USER+0x102)

BOOL
ExplainTextDlgProc (
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

#endif //_EXPLDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhui\pdhdlgs.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    pdhdlgs.h

Abstract:

    Dialog resource constants

--*/

#define IDC_STATIC                  -1
#define IDD_BROWSE_COUNTERS_EXT     100
#define IDD_BROWSE_COUNTERS_SIM     101
#define IDD_DATA_SOURCE             102
#define IDD_EXPLAIN_DLG             103
#define IDD_BROWSE_OBJECTS          104
#define IDC_USE_LOCAL_MACHINE       1001
#define IDC_SELECT_MACHINE          1002
#define IDC_MACHINE_CAPTION         1003
#define IDC_MACHINE_COMBO           1004
#define IDC_OBJECT_NAME_CAPTION     1010
#define IDC_OBJECT_COMBO            1011
#define IDC_COUNTERS_CAPTION        1020
#define IDC_ALL_COUNTERS            1021
#define IDC_USE_COUNTER_LIST        1022
#define IDC_COUNTER_LIST            1023
#define IDC_ALL_INSTANCES           1031
#define IDC_USE_INSTANCE_LIST       1032
#define IDC_INSTANCE_CAPTION        1033
#define IDC_INSTANCE_LIST           1034
#define IDC_EXPLAIN_BTN             1041
#define IDC_HELP_BTN                1042
#define IDC_NETWORK                 1043
#define IDC_OBJECT_DETAIL_CAPTION   1044
#define IDC_OBJECT_LIST             1045
#define IDC_COUNTER_DETAIL_CAPTION  1051
#define IDC_COUNTER_DETAIL_COMBO    1052
#define IDC_COUNTER_INFO_TEXT       2001
#define IDC_COUNTER_INFO_NAME       2002
#define IDC_CURRENT_ACTIVITY        3001
#define IDC_DATA_FROM_LOG_FILE      3002
#define IDC_PERF_REG                3003    
#define IDC_WBEM_NS                 3004
#define IDC_LOG_FILE_EDIT           3005
#define IDC_BROWSE_LOG_FILES        3006
#define IDC_EXPLAIN_TEXT            4001
#define IDS_STRINGBASE              10000
#define IDS_DETAIL_NOVICE           10001
#define IDS_DETAIL_ADVANCED         10002
#define IDS_DETAIL_EXPERT           10003
#define IDS_DETAIL_WIZARD           10004
#define IDS_DEFAULT_ACCOUNT         12001

#define IDH_USE_LOCAL_MACHINE       11001
#define IDH_SELECT_MACHINE          11002
#define IDH_MACHINE_COMBO           11003
#define IDH_COUNTER_DETAIL_COMBO    11004
#define IDH_OBJECT_COMBO            11005
#define IDH_ALL_COUNTERS            11006
#define IDH_USE_COUNTER_LIST        11007
#define IDH_COUNTER_LIST            11008
#define IDH_ALL_INSTANCES           11009
#define IDH_USE_INSTANCE_LIST       11010
#define IDH_INSTANCE_LIST           11011
#define IDH_EXPLAIN_BTN             11012

#define IDH_CURRENT_ACTIVITY        11013
#define IDH_DATA_FROM_LOG_FILE      11014
#define IDH_LOG_FILE_EDIT           11015
#define IDH_OBJECT_LIST             11016
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhui\expldlg.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    expldlg.c

Abstract:

    explain dialog box functions

Revision History

    Bob Watson (bobw)   mar-97 Created 

--*/
#include <windows.h>
#include <tchar.h>
#include <pdh.h>
#include "pdhidef.h"
#include "pdhdlgs.h"
#include "expldlg.h"
#include "pdhui.h"

//
//  Constants used in this module
//
WCHAR PdhiszTitleString[MAX_PATH+1];


STATIC_BOOL
ExplainTextDlg_WM_INITDIALOG (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    RECT    ParentRect;
    RECT    rectDeskTop;
    RECT    rectDlg;
    BOOL    bResult = FALSE;

    UNREFERENCED_PARAMETER (lParam);
    UNREFERENCED_PARAMETER (wParam);

    bResult =  GetWindowRect(GetDesktopWindow(), & rectDeskTop)
            && GetWindowRect(hDlg, & rectDlg);
    GetWindowTextW (hDlg, PdhiszTitleString, MAX_PATH);

    if (GetWindowRect (GetParent(hDlg), & ParentRect)) {
        int x = ParentRect.left;
        int y = ParentRect.bottom + 1;

        if (bResult) {
            if (  y + (rectDlg.bottom - rectDlg.top)
                > (rectDeskTop.bottom - rectDeskTop.top)) {
                // Explain dialog will be off-screen at the bottom, so
                // reposition it to top of AddCounter dialog
                //
                y = ParentRect.top - (rectDlg.bottom - rectDlg.top) - 1;
                if (y < 0) {
                    // Explain dialog will be off-screen at the top, use
                    // original calculation
                    //
                    y = ParentRect.bottom + 1;
                }
            }
        }
        SetWindowPos (hDlg, HWND_TOP, x, y, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
    } else {
        ShowWindow (hDlg, SW_SHOW);
    }

    return FALSE;
}

STATIC_BOOL
ExplainTextDlg_WM_COMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    WORD    wNotifyMsg;

    UNREFERENCED_PARAMETER (lParam);
    UNREFERENCED_PARAMETER (hDlg);

    wNotifyMsg = HIWORD(wParam);

    switch (LOWORD(wParam)) {   // select on the control ID
        default:
            return FALSE;
    }
}

STATIC_BOOL
ExplainTextDlg_WM_SYSCOMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER (lParam);

    switch (wParam) {
        case SC_CLOSE:
            PostMessageW (GetParent(hDlg), EDM_EXPLAIN_DLG_CLOSING, 0, 0);
            EndDialog (hDlg, IDOK);
            return TRUE;

        default:
            return FALSE;
    }
}

STATIC_BOOL
ExplainTextDlg_WM_CLOSE (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER (lParam);
    UNREFERENCED_PARAMETER (wParam);
    UNREFERENCED_PARAMETER (hDlg);

    return TRUE;
}

STATIC_BOOL
ExplainTextDlg_WM_DESTROY (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER (lParam);
    UNREFERENCED_PARAMETER (wParam);
    UNREFERENCED_PARAMETER (hDlg);

    return TRUE;
}

BOOL
ExplainTextDlgProc (
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    WCHAR szCaption[MAX_PATH*2];

    switch (message) {
        case WM_INITDIALOG:
            return ExplainTextDlg_WM_INITDIALOG (hDlg, wParam, lParam);

        case WM_COMMAND:
            return ExplainTextDlg_WM_COMMAND (hDlg, wParam, lParam);

        case WM_SYSCOMMAND:
            return ExplainTextDlg_WM_SYSCOMMAND (hDlg, wParam, lParam);

        case WM_CLOSE:
            return ExplainTextDlg_WM_CLOSE (hDlg, wParam, lParam);

        case WM_DESTROY:
            return ExplainTextDlg_WM_DESTROY (hDlg, wParam, lParam);

        case EDM_UPDATE_EXPLAIN_TEXT:
            if (lParam != 0) {
                SetWindowTextW (GetDlgItem(hDlg, IDC_EXPLAIN_TEXT), (LPCWSTR)lParam);
            } else {
                SetWindowTextW (GetDlgItem(hDlg, IDC_EXPLAIN_TEXT), cszEmptyString);
            }
            return TRUE;

        case EDM_UPDATE_TITLE_TEXT:
            lstrcpyW (szCaption, PdhiszTitleString);
            if (lParam != 0) {
                if (*(LPWSTR)lParam != 0) {
                    lstrcatW (szCaption, cszSpacer);
                    lstrcatW (szCaption, (LPCWSTR)lParam);
                }
            }
            SetWindowTextW (hDlg, (LPCWSTR)szCaption);
            return TRUE;

        default:
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhui\pdhui.h ===
#ifndef  _PDHUI_H_
#define  _PDHUI_H_
#include "pdhmsg.h"
#include "strings.h"
#endif  // _PDHUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhui\wildcard.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    wildcard.c

Abstract:

    counter name wild card expansion functions

--*/
#include <windows.h>
#include <winperf.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include "mbctype.h"
#include "pdhidef.h"
#include "pdhdlgs.h"
#include "pdh.h"
#include "pdhui.h"
#include "perftype.h"
#include "perfdata.h"

#pragma warning ( disable : 4213)

#define PDHI_COUNTER_PATH_BUFFER_SIZE   (DWORD)(sizeof(PDHI_COUNTER_PATH) + (5 * MAX_PATH))

DWORD DataSourceTypeA(LPCSTR  szDataSource);
DWORD DataSourceTypeW(LPCWSTR szDataSource);

STATIC_BOOL
WildStringMatchW (
    LPWSTR  szWildString,
    LPWSTR  szMatchString
)
{
    BOOL    bReturn;
    if (szWildString == NULL) {
        // every thing matches a null wild card string
        bReturn = TRUE;
    } else if (*szWildString == SPLAT_L) {
        // every thing matches this
        bReturn = TRUE;
    } else {
        // for now just do a case insensitive comparison.
        // later, this can be made more selective to support
        // partial wildcard string matches
        bReturn = (BOOL)(lstrcmpiW(szWildString, szMatchString) == 0);
    }
    return bReturn;
}

STATIC_PDH_FUNCTION
PdhiExpandWildcardPath (
    IN      HLOG    hDataSource,
    IN      LPCWSTR szWildCardPath,
    IN      LPVOID  pExpandedPathList,
    IN      LPDWORD pcchPathListLength,
    IN      DWORD   dwFlags,
    IN      BOOL    bUnicode
)
/*
    Flags:
        NoExpandCounters
        NoExpandInstances
        CheckCostlyCounters
*/
{
    PDH_COUNTER_PATH_ELEMENTS_W pPathElem;
    PPDHI_COUNTER_PATH          pWildCounterPath = NULL;
    
    PDH_STATUS                  pdhStatus = ERROR_SUCCESS;

    DWORD                       dwDetailLevel = PERF_DETAIL_WIZARD;
    DWORD                       dwBufferRemaining = 0;
    LPVOID                      szNextUserString = NULL;
    DWORD                       dwSize;
    DWORD                       dwSizeReturned = 0;
    DWORD                       dwRetry;

    LPWSTR                      mszObjectList = NULL;
    DWORD                       dwObjectListSize = 0;
    LPWSTR                      szThisObject;

    LPWSTR                      mszCounterList = NULL;
    DWORD                       dwCounterListSize = 0;
    LPWSTR                      szThisCounter;

    LPWSTR                      mszInstanceList = NULL;
    DWORD                       dwInstanceListSize = 0;
    LPWSTR                      szThisInstance;
   
    WCHAR                       szTempPathBuffer[MAX_PATH * 2];
    DWORD                       szTempPathBufferSize;

    BOOL                        bMoreData = FALSE;
    BOOL                        bNoInstances = FALSE;\

    LIST_ENTRY     InstList;
    PLIST_ENTRY    pHead;
    PLIST_ENTRY    pNext;
    PPDHI_INSTANCE pInst;

    // allocate buffers
    pWildCounterPath = G_ALLOC (PDHI_COUNTER_PATH_BUFFER_SIZE);

    if (pWildCounterPath == NULL) {
        // unable to allocate memory so bail out
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    } else {
        __try {
            dwBufferRemaining = *pcchPathListLength;
            szNextUserString = pExpandedPathList;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // Parse wild card Path
        dwSize = (DWORD)G_SIZE (pWildCounterPath);
        if (ParseFullPathNameW (szWildCardPath, &dwSize, pWildCounterPath, FALSE)) {
            if (pWildCounterPath->szObjectName == NULL) {
                pdhStatus = PDH_INVALID_PATH;
            } else if (*pWildCounterPath->szObjectName == SPLAT_L) {
                //then the object is wild so get the list
                // of objects supported by this machine
                dwObjectListSize = 2048;    // starting buffer size
                dwRetry = 10;
                do {
                    if (mszObjectList != NULL) G_FREE(mszObjectList);
                    mszObjectList = G_ALLOC (dwObjectListSize * sizeof(WCHAR));
                    if (mszObjectList != NULL) {
                        pdhStatus = PdhEnumObjectsHW (
                            hDataSource,
                            pWildCounterPath->szMachineName,
                            mszObjectList,
                            &dwObjectListSize,
                            dwDetailLevel,
                            TRUE);
                        dwRetry--;
                    } else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                } while (   (dwRetry)
                         && (   pdhStatus == PDH_MORE_DATA
                             || pdhStatus == PDH_INSUFFICIENT_BUFFER));
            } else {
                dwObjectListSize = lstrlenW(pWildCounterPath->szObjectName) + 2;
                mszObjectList = G_ALLOC(dwObjectListSize * sizeof (WCHAR));
                if (mszObjectList != NULL) {
                    lstrcpyW (mszObjectList, pWildCounterPath->szObjectName);
                    // add the MSZ terminator
                    mszObjectList[dwObjectListSize-1] = 0;
                    pdhStatus = ERROR_SUCCESS;
                } else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
        } else {
            pdhStatus = PDH_INVALID_PATH;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pPathElem.szMachineName = pWildCounterPath->szMachineName;
        // for each object
        for (szThisObject = mszObjectList;
            *szThisObject != 0;
            szThisObject += lstrlenW(szThisObject) + 1) {
            dwCounterListSize = 8192;    // starting buffer size
            dwInstanceListSize = 16384; // starting buffer size
            dwRetry = 10;
            do {
                if (mszCounterList != NULL)  G_FREE(mszCounterList);
                if (mszInstanceList != NULL) G_FREE(mszInstanceList);
                mszCounterList = G_ALLOC ((dwCounterListSize * sizeof(WCHAR)));
                if (mszCounterList != NULL) {
                    mszInstanceList = G_ALLOC (dwInstanceListSize  * sizeof(WCHAR));
                    if (mszInstanceList != NULL) {
                        pdhStatus = PdhEnumObjectItemsHW (
                            hDataSource,
                            pWildCounterPath->szMachineName,
                            szThisObject,
                            mszCounterList,
                            &dwCounterListSize,
                            mszInstanceList,
                            &dwInstanceListSize,
                            dwDetailLevel,
                            0);
                        dwRetry--;
                    } else {
                        G_FREE (mszCounterList);
                        mszCounterList = NULL;
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    } 
                } else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            } while (   (dwRetry)
                     && (   pdhStatus == PDH_MORE_DATA
                         || pdhStatus == PDH_INSUFFICIENT_BUFFER));

            pPathElem.szObjectName = szThisObject;
            
            if (pdhStatus == ERROR_SUCCESS) {
                if (pWildCounterPath->szCounterName == NULL) {
                    pdhStatus = PDH_INVALID_PATH;
                } else if ((*pWildCounterPath->szCounterName != SPLAT_L) || (dwFlags & PDH_NOEXPANDCOUNTERS)) {
                    if (mszCounterList != NULL) G_FREE(mszCounterList);
                    dwCounterListSize = lstrlenW(pWildCounterPath->szCounterName) + 2;
                    mszCounterList = G_ALLOC (dwCounterListSize * sizeof(WCHAR));
                    if (mszCounterList != NULL) {
                        lstrcpyW (mszCounterList, pWildCounterPath->szCounterName);
                        mszCounterList[dwCounterListSize-1] = 0;
                    } else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                } else { 
                    // enum wild counters
                }

                if ((pWildCounterPath->szInstanceName == NULL) && (pdhStatus == ERROR_SUCCESS)){
                    bNoInstances = TRUE;
                    dwInstanceListSize = 2;
                    mszInstanceList = G_ALLOC (dwInstanceListSize * sizeof(WCHAR));
                    if (mszInstanceList != NULL) {
                        mszInstanceList [0] =0;
                        mszInstanceList [dwInstanceListSize-1] = 0;
                    } else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                } else if ((*pWildCounterPath->szInstanceName != SPLAT_L) || (dwFlags & PDH_NOEXPANDINSTANCES)) {
                    if (mszInstanceList != NULL) G_FREE(mszInstanceList);
                    dwInstanceListSize = lstrlenW(pWildCounterPath->szInstanceName) + 2;
                    mszInstanceList = G_ALLOC (dwInstanceListSize * sizeof(WCHAR));
                    if (mszInstanceList != NULL) {
                        lstrcpyW (mszInstanceList, pWildCounterPath->szInstanceName);
                        mszInstanceList [dwInstanceListSize-1] = 0;
                    } else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                } else { 
                    // enum wild instance
                }
            }

            if (mszInstanceList != NULL) {
                InitializeListHead(& InstList);
                szThisInstance = mszInstanceList;
                do {
                    PdhiFindInstance(& InstList, szThisInstance, TRUE, &pInst);
                    szThisInstance += lstrlenW(szThisInstance) + 1;
                } while (* szThisInstance != 0);

                szThisInstance = mszInstanceList;
                do {
                    if (bNoInstances) {
                        pPathElem.szInstanceName = NULL;
                    } else {
                        pPathElem.szInstanceName = szThisInstance;
                    }
                    pPathElem.szParentInstance = NULL;  // included in the instance name
                    pInst = NULL;
                    PdhiFindInstance(
                            & InstList, szThisInstance, FALSE, & pInst);
                    if (pInst == NULL || pInst->dwTotal == 1
                                      || pInst->dwCount <= 1) {
                        pPathElem.dwInstanceIndex = (DWORD) -1;     // included in the instance name
                    }
                    else {
                        pInst->dwCount --;
                        pPathElem.dwInstanceIndex = pInst->dwCount;
                    }
                    for (szThisCounter = mszCounterList;
                        *szThisCounter != 0;
                        szThisCounter += lstrlenW(szThisCounter) +1) {
                        pPathElem.szCounterName = szThisCounter;

                        //make path string and add to list if it will fit

                        szTempPathBufferSize = sizeof (szTempPathBuffer) / sizeof (szTempPathBuffer[0]);
                        pdhStatus = PdhMakeCounterPathW (
                            &pPathElem,
                            szTempPathBuffer,
                            &szTempPathBufferSize,
                            0);

                        if (pdhStatus == ERROR_SUCCESS) {
                            // add the string if it will fit
                            if (bUnicode) {
                                dwSize = lstrlenW((LPWSTR) szTempPathBuffer) + 1;
                                if (!bMoreData && (dwSize  <= dwBufferRemaining)) {
                                    lstrcpyW ((LPWSTR)szNextUserString, szTempPathBuffer);
                                    (LPBYTE) szNextUserString += dwSize * sizeof(WCHAR);
                                    dwBufferRemaining         -= dwSize;
                                }
                                else {
                                    dwBufferRemaining = 0;
                                    bMoreData         = TRUE;
                                }
                            }
                            else {
                                dwSize = dwBufferRemaining;
                                if (PdhiConvertUnicodeToAnsi(_getmbcp(),
                                            szTempPathBuffer,
                                            szNextUserString,
                                            & dwSize) == ERROR_SUCCESS) {
                                    (LPBYTE)szNextUserString += dwSize * sizeof(CHAR);
                                    dwBufferRemaining        -= dwSize;
                                }
                                else {
                                    dwBufferRemaining = 0;
                                    bMoreData         = TRUE;
                                }
                            }
                            dwSizeReturned += dwSize;
                        } // end if path created OK
                    } // end for each counter
                    szThisInstance += lstrlenW(szThisInstance) +1;
                } while (*szThisInstance != 0);

                if (! IsListEmpty(& InstList)) {
                    pHead = & InstList;
                    pNext = pHead->Flink;
                    while (pNext != pHead) {
                        pInst = CONTAINING_RECORD(pNext, PDHI_INSTANCE, Entry);
                        pNext = pNext->Flink;
                        RemoveEntryList(& pInst->Entry);
                        G_FREE(pInst);
                    }
                }
            } // else no instances to do
        } // end for each object found
    } // end if object enumeration successful

    if ((dwSizeReturned > 0) && (dwBufferRemaining >= 1))  {
        dwSize = 1;
        if (szNextUserString) {
            if (bUnicode) {
                * (LPWSTR) szNextUserString = 0;
                (LPBYTE) szNextUserString  += dwSize * sizeof(WCHAR);
            } else {
                * (LPSTR) szNextUserString = 0;
                (LPBYTE) szNextUserString += dwSize * sizeof(CHAR);
            }
        }
        dwSizeReturned += dwSize;
        dwBufferRemaining -= dwSize;
    }

    *pcchPathListLength = dwSizeReturned;

    if (mszCounterList != NULL)   G_FREE(mszCounterList);
    if (mszInstanceList != NULL)  G_FREE(mszInstanceList);
    if (mszObjectList != NULL)    G_FREE(mszObjectList);
    if (pWildCounterPath != NULL) G_FREE(pWildCounterPath);

    if (bMoreData) pdhStatus = PDH_MORE_DATA;

    return (pdhStatus);
}

STATIC_PDH_FUNCTION
PdhiExpandCounterPath (
    IN      LPCWSTR szWildCardPath,
    IN      LPVOID  pExpandedPathList,
    IN      LPDWORD pcchPathListLength,
    IN      BOOL    bUnicode
)
{
    PPERF_MACHINE       pMachine;
    PPDHI_COUNTER_PATH  pWildCounterPath = NULL;
    WCHAR               szWorkBuffer[MAX_PATH];
    WCHAR               szCounterName[MAX_PATH];
    WCHAR               szInstanceName[MAX_PATH];
    LPWSTR              szEndOfObjectString;
    LPWSTR              szInstanceString;
    LPWSTR              szCounterString;
    LPVOID              szNextUserString = NULL;
    PERF_OBJECT_TYPE    *pObjectDef;
    PERF_OBJECT_TYPE    *pParentObjectDef;
    PERF_COUNTER_DEFINITION *pCounterDef;
    PERF_INSTANCE_DEFINITION *pInstanceDef;
    PERF_INSTANCE_DEFINITION *pParentInstanceDef;

    DWORD               dwLocalPathLength = 0;
    DWORD               dwBufferRemaining = 0;
    DWORD               dwSize;
    DWORD               dwSizeReturned = 0;
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;

    DWORD               dwCtrNdx, dwInstNdx;
    BOOL                bMoreData = FALSE;

    if ((szWildCardPath == NULL) ||
        (pExpandedPathList == NULL) ||
        (pcchPathListLength == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {

        // allocate buffers
        pWildCounterPath = G_ALLOC (PDHI_COUNTER_PATH_BUFFER_SIZE);

        if (pWildCounterPath == NULL) {
          // unable to allocate memory so bail out
          pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        } else {
          __try {

            dwLocalPathLength = *pcchPathListLength;
            dwBufferRemaining = dwLocalPathLength;
            szNextUserString = pExpandedPathList;
          } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
          }
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }

    if (pdhStatus == ERROR_SUCCESS) {
      // Parse wild card Path

      dwSize = (DWORD)G_SIZE (pWildCounterPath);
      if (ParseFullPathNameW (szWildCardPath, &dwSize, pWildCounterPath, FALSE)) {
        // get the machine referenced in the path
        pMachine = GetMachine (pWildCounterPath->szMachineName, 0);
        if (pMachine != NULL) {
          if (wcsncmp (cszDoubleBackSlash, szWildCardPath, 2) == 0) {
            // the caller wants the machine name in the path so
            // copy it to the work buffer
            lstrcpyW (szWorkBuffer, pWildCounterPath->szMachineName);
          } else {
            *szWorkBuffer = 0;
          }
          // append the object name (since wild card objects are not
          // currently supported.

          lstrcatW (szWorkBuffer, cszBackSlash);
          lstrcatW (szWorkBuffer, pWildCounterPath->szObjectName);
          szEndOfObjectString = &szWorkBuffer[lstrlenW(szWorkBuffer)];

          if (pMachine->dwStatus == ERROR_SUCCESS) {
           // get object pointer (since objects are not wild)
            pObjectDef = GetObjectDefByName (
              pMachine->pSystemPerfData,
              pMachine->dwLastPerfString,
              pMachine->szPerfStrings,
              pWildCounterPath->szObjectName);
          } else {
              pObjectDef = NULL;
          }

          if (pObjectDef != NULL) {
            // for each counters and identify matches
            pCounterDef = FirstCounter (pObjectDef);
            for (dwCtrNdx = 0; dwCtrNdx < pObjectDef->NumCounters; dwCtrNdx++) {
              // for each counter check instances (if supported)
              //  and keep matches
              if ((pCounterDef->CounterNameTitleIndex > 0) &&
                  (pCounterDef->CounterNameTitleIndex < pMachine->dwLastPerfString ) &&
                  (!((pCounterDef->CounterType & PERF_DISPLAY_NOSHOW) &&
                     // this is a hack because this type is not defined correctly
                    (pCounterDef->CounterType != PERF_AVERAGE_BULK)))) {
                // look up name of each object & store size
                lstrcpyW (szCounterName,
                    PdhiLookupPerfNameByIndex (
                        pMachine,
                        pCounterDef->CounterNameTitleIndex));
                if (WildStringMatchW(pWildCounterPath->szCounterName, szCounterName)) {
                  // if this object has instances, then walk down
                  // the instance list and save any matches
                  if (pObjectDef->NumInstances != PERF_NO_INSTANCES) {
                    // then walk instances to find matches
                    pInstanceDef = FirstInstance (pObjectDef);
                    if (pObjectDef->NumInstances > 0) {
                      for (dwInstNdx = 0;
                        dwInstNdx < (DWORD)pObjectDef->NumInstances;
                        dwInstNdx++) {
                        szInstanceString = szEndOfObjectString;
                        if (pInstanceDef->ParentObjectTitleIndex > 0) {
                          // then add in parent instance name
                          pParentObjectDef = GetObjectDefByTitleIndex (
                            pMachine->pSystemPerfData,
                            pInstanceDef->ParentObjectTitleIndex);
                          if (pParentObjectDef != NULL) {
                            pParentInstanceDef = GetInstance (
                              pParentObjectDef,
                              pInstanceDef->ParentObjectInstance);
                            if (pParentInstanceDef != NULL) {
                              GetInstanceNameStr (pParentInstanceDef,
                                szInstanceName,
                                pObjectDef->CodePage);
                              if (WildStringMatchW (pWildCounterPath->szParentName, szInstanceName)) {
                                // add this string
                                szInstanceString = szEndOfObjectString;
                                lstrcpyW (szInstanceString, cszLeftParen);
                                lstrcatW (szInstanceString, szInstanceName);
                                lstrcatW (szInstanceString, cszSlash);
                              } else {
                                // get next instance and continue
                                pInstanceDef = NextInstance(pInstanceDef);
                                continue;
                              }
                            } else {
                              // unable to locate parent instance
                              // so cancel this one, then
                              // get next instance and continue
                              pInstanceDef = NextInstance(pInstanceDef);
                              continue;
                            }
                          } else {
                            // unable to locate parent object
                            // so cancel this one, then
                            // get next instance and continue
                            pInstanceDef = NextInstance(pInstanceDef);
                            continue;
                          }
                        } else {
                          // no parent name so continue
                          szInstanceString = szEndOfObjectString;
                          lstrcpyW (szInstanceString, cszLeftParen);
                        }
                        GetInstanceNameStr (pInstanceDef,
                          szInstanceName,
                          pObjectDef->CodePage);

                        // if this instance name matches, then keep it
                        if (WildStringMatchW (pWildCounterPath->szInstanceName, szInstanceName)) {
                          lstrcatW (szInstanceString, szInstanceName);
                          lstrcatW (szInstanceString, cszRightParenBackSlash);
                          // now append this counter name
                          lstrcatW (szInstanceString, szCounterName);

                          // add it to the user's buffer if there's room
                          if (bUnicode) {
                              dwSize = lstrlenW(szWorkBuffer) + 1;
                              if (!bMoreData && (dwSize <= dwBufferRemaining)) {
                                    lstrcpyW ((LPWSTR)szNextUserString, szWorkBuffer);
                                    (LPBYTE)szNextUserString += dwSize * sizeof(WCHAR);
                              }
                              else {
                                  bMoreData = TRUE;
                              }
                          } else {
                              dwSize = dwBufferRemaining;
                              if (PdhiConvertUnicodeToAnsi(_getmbcp(),
                                      szWorkBuffer, szNextUserString, & dwSize)
                                          == ERROR_SUCCESS) {
                                  (LPBYTE)szNextUserString += dwSize * sizeof(CHAR);
                              }
                              else {
                                  bMoreData = TRUE;
                              }
                          }
                          dwSizeReturned += dwSize;
                          if (! bMoreData) {
                              dwBufferRemaining -= dwSize;
                          }
                        } else {
                          // they don't want this instance so skip it
                        }
                        pInstanceDef = NextInstance (pInstanceDef);
                      } // end for each instance in object
                    } else {
                      // this object supports instances,
                      // but doesn't currently have any
                      // so do nothing.
                    }
                  } else {
                    // this object does not use instances so copy this
                    // counter to the caller's buffer.
                    szCounterString = szEndOfObjectString;
                    lstrcpyW (szCounterString, cszBackSlash);
                    lstrcatW (szCounterString, szCounterName);
                    if (bUnicode) {
                        dwSize = lstrlenW(szWorkBuffer) + 1;
                        if (!bMoreData && (dwSize  < dwBufferRemaining)) {
                            lstrcpyW ((LPWSTR)szNextUserString, szWorkBuffer);
                            (LPBYTE)szNextUserString += dwSize * sizeof(WCHAR);
                        }
                        else {
                            bMoreData = TRUE;
                        }
                    } else {
                        dwSize = dwBufferRemaining;
                        if (PdhiConvertUnicodeToAnsi(_getmbcp(),
                                szWorkBuffer, szNextUserString, & dwSize)
                                    == ERROR_SUCCESS) {
                            (LPBYTE)szNextUserString += dwSize * sizeof(CHAR);
                        }
                        else {
                            bMoreData = TRUE;
                        }
                    }
                    dwSizeReturned += dwSize;
                    if (! bMoreData) {
                      dwBufferRemaining -= dwSize;
                    }
                  }
                } else {
                  // this counter doesn't match so skip it
                }
              } else {
                // this counter string is not available
              }
              pCounterDef = NextCounter(pCounterDef);
            } // end for each counter in this object
            if (bUnicode) {
                *(LPWSTR)szNextUserString = 0;  // MSZ terminator
            } else {
                *(LPSTR)szNextUserString = 0;  // MSZ terminator
            }
            dwLocalPathLength = dwSizeReturned;
            if (bMoreData) {
              pdhStatus = PDH_MORE_DATA;
            } else {
              pdhStatus = ERROR_SUCCESS;
            }
          } else {
            // unable to find object
            pdhStatus = PDH_INVALID_PATH;
          }
          pMachine->dwRefCount--;
          RELEASE_MUTEX (pMachine->hMutex);
        } else {
          // unable to connect to machine.
          pdhStatus = GetLastError();
        }
      } else {
        // unable to read input path string
          pdhStatus = PDH_INVALID_PATH;
      }
      RELEASE_MUTEX (hPdhDataMutex);

      __try {
          *pcchPathListLength = dwLocalPathLength;
      } __except (EXCEPTION_EXECUTE_HANDLER) {
          pdhStatus = PDH_INVALID_ARGUMENT;
      }
    }

    if (pWildCounterPath != NULL) G_FREE (pWildCounterPath);

    return pdhStatus;
}

PDH_FUNCTION
PdhExpandCounterPathW (
    IN      LPCWSTR szWildCardPath,
    IN      LPWSTR  mszExpandedPathList,
    IN      LPDWORD pcchPathListLength
)
/*++

    Expands any wild card characters in the following fields of the
    counter path string in the szWildCardPath argument and returns the
    matching counter paths in the buffer referenced by the
    mszExpandedPathList argument

    The input path is defined as one of the following formats:

        \\machine\object(parent/instance#index)\counter
        \\machine\object(parent/instance)\counter
        \\machine\object(instance#index)\counter
        \\machine\object(instance)\counter
        \\machine\object\counter
        \object(parent/instance#index)\counter
        \object(parent/instance)\counter
        \object(instance#index)\counter
        \object(instance)\counter
        \object\counter

    Input paths that include the machine will be expanded to also
    include the machine and use the specified machine to resolve the
    wild card matches. Input paths that do not contain a machine name
    will use the local machine to resolve wild card matches.

    The following fields may contain either a valid name or a wild card
    character ("*").  Partial string matches (e.g. "pro*") are not
    supported.

        parent      returns all instances of the specified object that
                        match the other specified fields
        instance    returns all instances of the specified object and
                        parent object if specified
        index       returns all duplicate matching instance names
        counter     returns all counters of the specified object

--*/
{
    return PdhiExpandCounterPath (
        szWildCardPath,
        (LPVOID)mszExpandedPathList,
        pcchPathListLength,
        TRUE);
}

PDH_FUNCTION
PdhExpandCounterPathA (
    IN      LPCSTR  szWildCardPath,
    IN      LPSTR   mszExpandedPathList,
    IN      LPDWORD pcchPathListLength
)
{
    LPWSTR              szWideWildCardPath = NULL;
    DWORD               dwSize;
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    DWORD               dwLocalListSize = 0;

    if ((szWildCardPath == NULL) || (pcchPathListLength == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (* szWildCardPath == '\0') {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        __try {
            dwLocalListSize = *pcchPathListLength;
            dwSize = lstrlenA (szWildCardPath);
            szWideWildCardPath = G_ALLOC (((dwSize+1) * sizeof (WCHAR)));
            if (szWideWildCardPath == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            } else {
                MultiByteToWideChar(_getmbcp(),
                                    0,
                                    szWildCardPath,
                                    dwSize,
                                    (LPWSTR) szWideWildCardPath,
                                    dwSize + 1);
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS && szWideWildCardPath != NULL) {
        pdhStatus = PdhiExpandCounterPath (
            szWideWildCardPath,
            (LPVOID)mszExpandedPathList,
            &dwLocalListSize,
            FALSE);

        __try {
            * pcchPathListLength = dwLocalListSize;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (szWideWildCardPath != NULL) G_FREE (szWideWildCardPath);

    return pdhStatus;
}

PDH_FUNCTION
PdhExpandWildCardPathHW (
    IN HLOG    hDataSource,
    IN LPCWSTR szWildCardPath,
    IN LPWSTR  mszExpandedPathList,
    IN LPDWORD pcchPathListLength,
    IN DWORD   dwFlags
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwLocalBufferSize;

    if ((szWildCardPath == NULL) || (pcchPathListLength == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwLocalBufferSize = * pcchPathListLength;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiExpandWildcardPath (
                    hDataSource,
                    szWildCardPath,
                    (LPVOID) mszExpandedPathList,
                    & dwLocalBufferSize,
                    dwFlags,
                    TRUE);
        __try {
            * pcchPathListLength = dwLocalBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhExpandWildCardPathW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szWildCardPath,
    IN      LPWSTR  mszExpandedPathList,
    IN      LPDWORD pcchPathListLength,
    IN      DWORD   dwFlags
)
/*++

    Expands any wild card characters in the following fields of the
    counter path string in the szWildCardPath argument and returns the
    matching counter paths in the buffer referenced by the
    mszExpandedPathList argument

    The input path is defined as one of the following formats:

        \\machine\object(parent/instance#index)\counter
        \\machine\object(parent/instance)\counter
        \\machine\object(instance#index)\counter
        \\machine\object(instance)\counter
        \\machine\object\counter
        \object(parent/instance#index)\counter
        \object(parent/instance)\counter
        \object(instance#index)\counter
        \object(instance)\counter
        \object\counter

    Input paths that include the machine will be expanded to also
    include the machine and use the specified machine to resolve the
    wild card matches. Input paths that do not contain a machine name
    will use the local machine to resolve wild card matches.

    The following fields may contain either a valid name or a wild card
    character ("*").  Partial string matches (e.g. "pro*") are not
    supported.

        parent      returns all instances of the specified object that
                        match the other specified fields
        instance    returns all instances of the specified object and
                        parent object if specified
        index       returns all duplicate matching instance names
        counter     returns all counters of the specified object

--*/
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwLocalBufferSize;
    DWORD       dwDataSource = 0;
    HLOG        hDataSource = H_REALTIME_DATASOURCE;

    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg

        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSource      = DataSourceTypeW(szDataSource);
            dwLocalBufferSize = * pcchPathListLength;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogW(
                    szDataSource,
                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                    & dwLogType,
                    NULL,
                    0,
                    NULL,
                    & hDataSource);
        }

        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhExpandWildCardPathHW (
                        hDataSource,
                        szWildCardPath,
                        mszExpandedPathList,
                        pcchPathListLength,
                        dwFlags);
            if (dwDataSource == DATA_SOURCE_LOGFILE) {
                PdhCloseLog(hDataSource, 0);
            }
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhExpandWildCardPathHA (
    IN HLOG    hDataSource,
    IN LPCSTR  szWildCardPath,
    IN LPSTR   mszExpandedPathList,
    IN LPDWORD pcchPathListLength,
    IN DWORD   dwFlags
)
{
    LPWSTR      szWideWildCardPath = NULL;
    DWORD       dwSize;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwLocalBufferSize;

    if ((szWildCardPath == NULL) || (pcchPathListLength == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (* szWildCardPath == '\0') {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwSize = lstrlenA(szWildCardPath);
            szWideWildCardPath = G_ALLOC(((dwSize + 1) * sizeof(WCHAR)));
            if (szWideWildCardPath == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else {
                MultiByteToWideChar(_getmbcp(),
                                    0,
                                    szWildCardPath,
                                    dwSize,
                                    (LPWSTR) szWideWildCardPath,
                                    dwSize + 1);
            }

            dwLocalBufferSize = * pcchPathListLength;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiExpandWildcardPath (
                    hDataSource,
                    szWideWildCardPath,
                    (LPVOID) mszExpandedPathList,
                    & dwLocalBufferSize,
                    dwFlags,
                    FALSE);
        __try {
            * pcchPathListLength = dwLocalBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (szWideWildCardPath != NULL) G_FREE(szWideWildCardPath);

    return pdhStatus;
}

PDH_FUNCTION
PdhExpandWildCardPathA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szWildCardPath,
    IN      LPSTR   mszExpandedPathList,
    IN      LPDWORD pcchPathListLength,
    IN      DWORD   dwFlags
)
{
    PDH_STATUS  pdhStatus   = ERROR_SUCCESS;
    HLOG        hDataSource = H_REALTIME_DATASOURCE;
    DWORD       dwDataSource  = 0;

    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg

        if (pdhStatus == ERROR_SUCCESS) {
                dwDataSource      = DataSourceTypeA(szDataSource);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogA(
                    szDataSource,
                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                    & dwLogType,
                    NULL,
                    0,
                    NULL,
                    & hDataSource);
        }

        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhExpandWildCardPathHA (
                        hDataSource,
                        szWildCardPath,
                        mszExpandedPathList,
                        pcchPathListLength,
                        dwFlags);
            if (dwDataSource == DATA_SOURCE_LOGFILE) {
                PdhCloseLog(hDataSource, 0);
            }
        }
    }

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhwmi\wbem.cpp ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    WMI interface functions exported by PDH.DLL

--*/

#include <windows.h>
#include <winperf.h>
#include "mbctype.h"
#include <mbctype.h>
#include <pdh.h>
#include <pdhmsg.h>
#include <assert.h>
#include "wbemdef.h"
#include "pdhitype.h"
#include "pdhidef.h"
#include "strings.h"

#define PERF_TIMER_FIELD \
    (PERF_TIMER_TICK | PERF_TIMER_100NS | PERF_OBJECT_TIMER)

__inline 
VOID
PdhiSysFreeString( 
    BSTR *x
) 
{
    if (x != NULL) {
        if (*x != NULL) {
            SysFreeString(*x);
            *x = NULL;
        }
    }
}

// at this point, calling the refresher while adding items to the refresher
// doesn't work. so for the time being, we'll use this interlock to prevent
// a collision
static BOOL bDontRefresh = FALSE;

// Prototype
HRESULT WbemSetProxyBlanket(
    IUnknown                 *pInterface,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities );

HRESULT SetWbemSecurity( IUnknown *pInterface )
{
    return WbemSetProxyBlanket( pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );
}


// This is the same timeout value the refresher uses so we can pretend
// we're doing the same thing.

#define WBEM_REFRESHER_TIMEOUT  10000

//  This class is designed to encapsulate the IWbemRefresher functionality
//  The definition and implementation are all in this source file

class CWbemRefresher : public IUnknown
{
protected:
    LONG                        m_lRefCount;

    // The primitives that will control the multithreading stuff
    HANDLE                      m_hQuitEvent;
    HANDLE                      m_hDoWorkEvent;
    HANDLE                      m_hWorkDoneEvent;
    HANDLE                      m_hRefrMutex;
    HANDLE                      m_hInitializedEvent;
    HANDLE                      m_hThread;
    DWORD                       m_dwThreadId;
    BOOL                        m_fThreadOk;

    // These are the pass-thru variables we will use as placeholders
    // as we perform our operations.  Note that a couple are missing.
    // This is because we are not really using them in our code, so
    // no sense in adding anything we don't really need.

    IStream*            m_pNSStream;
    LPCWSTR             m_wszPath;
    LPCWSTR             m_wszClassName;
    long                m_lFlags;
    IWbemClassObject**  m_ppRefreshable;
    IWbemHiPerfEnum**   m_ppEnum;
    long*               m_plId;
    long                m_lId;
    HRESULT             m_hOperResult;

    // This is what will be set to indicate to the thread which operation
    // it is supposed to perform.

    typedef enum
    {
        eRefrOpNone,
        eRefrOpRefresh,
        eRefrOpAddByPath,
        eRefrOpAddEnum,
        eRefrOpRemove,
        eRefrOpLast
    }   tRefrOps;

    tRefrOps            m_eRefrOp;

    // Thread ebtryt
    class XRefresher : public IWbemRefresher
    {
    protected:
        CWbemRefresher* m_pOuter;

    public:
        XRefresher( CWbemRefresher* pOuter ) : m_pOuter( pOuter ) {};
        ~XRefresher()   {};

        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG, AddRef)(THIS);
        STDMETHOD_(ULONG, Release)(THIS);
        STDMETHOD(Refresh)(long lFlags);

    } m_xRefresher;

    class XConfigRefresher : public IWbemConfigureRefresher
    {
    protected:
        CWbemRefresher* m_pOuter;

    public:
        XConfigRefresher( CWbemRefresher* pOuter ) : m_pOuter( pOuter ) {};
        ~XConfigRefresher() {};

        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG, AddRef)(THIS);
        STDMETHOD_(ULONG, Release)(THIS);
        STDMETHOD(AddObjectByPath)(IWbemServices* pNamespace, LPCWSTR wszPath,
            long lFlags, IWbemContext* pContext,
            IWbemClassObject** ppRefreshable, long* plId);

        STDMETHOD(AddObjectByTemplate)(IWbemServices* pNamespace,
            IWbemClassObject* pTemplate,
            long lFlags, IWbemContext* pContext,
            IWbemClassObject** ppRefreshable, long* plId);

        STDMETHOD(AddRefresher)(IWbemRefresher* pRefresher, long lFlags,
            long* plId);

        STDMETHOD(Remove)(long lId, long lFlags);

        STDMETHOD(AddEnum)( IWbemServices*  pNamespace, LPCWSTR wscClassName,
            long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
            long* plId );

    } m_xConfigRefresher;

protected:

    void Initialize( void );
    void Cleanup( void );

    // Operation helpers
    HRESULT SignalRefresher( void );
    HRESULT SetRefresherParams( IWbemServices* pNamespace, tRefrOps eOp,
            LPCWSTR pwszPath, LPCWSTR pwszClassName, long lFlags,
            IWbemClassObject** ppRefreshable, IWbemHiPerfEnum** ppEnum, long* plId,
            long lId );
    void ClearRefresherParams( void );

    DWORD WINAPI RealEntry( void );

    static DWORD WINAPI ThreadProc( void * pThis )
    {
        return ((CWbemRefresher*) pThis)->RealEntry();
    }

public:
    CWbemRefresher();
    virtual ~CWbemRefresher();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // The real implementations
    STDMETHOD(AddObjectByPath)(IWbemServices* pNamespace, LPCWSTR wszPath,
        long lFlags, IWbemContext* pContext,
        IWbemClassObject** ppRefreshable, long* plId);

    STDMETHOD(AddObjectByTemplate)(IWbemServices* pNamespace,
        IWbemClassObject* pTemplate,
        long lFlags, IWbemContext* pContext,
        IWbemClassObject** ppRefreshable, long* plId);

    STDMETHOD(AddRefresher)(IWbemRefresher* pRefresher, long lFlags,
        long* plId);

    STDMETHOD(Remove)(long lId, long lFlags);

    STDMETHOD(AddEnum)( IWbemServices*  pNamespace, LPCWSTR wscClassName,
        long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
        long* plId );

    STDMETHOD(Refresh)(long lFlags);

};

/*
**  Begin CWbemRefresher Implementation
*/

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4355)

// CTor and DTor
CWbemRefresher::CWbemRefresher( void )
: m_lRefCount(0), m_xRefresher( this ), m_xConfigRefresher( this ),
        m_hQuitEvent( NULL ),
        m_hDoWorkEvent( NULL ), m_hRefrMutex( NULL ), m_hInitializedEvent( NULL ),
        m_hThread( NULL ), m_hWorkDoneEvent( NULL ), m_dwThreadId( 0 ),
        m_pNSStream( NULL ), m_wszPath( NULL ), m_wszClassName( NULL ),
        m_lFlags( 0L ), m_ppRefreshable( NULL ), m_ppEnum( NULL ), m_plId( NULL ),
        m_eRefrOp( eRefrOpRefresh ), m_hOperResult( WBEM_S_NO_ERROR ), m_fThreadOk( FALSE ),
        m_lId( 0 )
{
    Initialize();
}

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4355)
#endif

CWbemRefresher::~CWbemRefresher( void )
{
    Cleanup();
}

void CWbemRefresher::Initialize( void )
{
    // Now create the events, mutexes and our pal, the MTA thread on which all of
    // the operations will run

    m_hQuitEvent = CreateEventW( NULL, FALSE, FALSE, NULL );
    m_hDoWorkEvent = CreateEventW( NULL, FALSE, FALSE, NULL );
    m_hInitializedEvent = CreateEventW( NULL, FALSE, FALSE, NULL );
    m_hWorkDoneEvent = CreateEventW( NULL, FALSE, FALSE, NULL );

    m_hRefrMutex = CreateMutexW( NULL, FALSE, NULL );

    // If we don't have all these, something's gone south
    if (    NULL    ==  m_hQuitEvent        ||
            NULL    ==  m_hDoWorkEvent      ||
            NULL    ==  m_hInitializedEvent ||
            NULL    ==  m_hWorkDoneEvent    ||
            NULL    ==  m_hRefrMutex        )
    {
        return;
    }

    // Kick off the thread and wait for the initialized event signal (we'll give it
    // 5 seconds...if it don't get signalled in that timeframe, something is most likely
    // wrong, but we'll bounce out so whoever allocated us isn't left wondering what
    // to do).

    m_hThread = CreateThread( NULL, 0, CWbemRefresher::ThreadProc,
                    (void*) this, 0, &m_dwThreadId );

    if ( NULL == m_hThread )
    {
        return;
    }

    WaitForSingleObject( m_hInitializedEvent, 5000 );

}

void CWbemRefresher::Cleanup( void )
{
    // If we have a thread, tell it to go away
    if ( NULL != m_hThread )
    {
        // Signal the quit event and give the thread a 5 second grace period
        // to shutdown.  If it don't, don't worry, just close the handle and go away.

        SetEvent( m_hQuitEvent );
        WaitForSingleObject( m_hThread, 5000 );

        CloseHandle( m_hThread );
        m_hThread = NULL;
    }

    // Cleanup the primitives

    if ( NULL != m_hQuitEvent )
    {
        CloseHandle( m_hQuitEvent );
        m_hQuitEvent = NULL;
    }

    if ( NULL != m_hDoWorkEvent )
    {
        CloseHandle( m_hDoWorkEvent );
        m_hDoWorkEvent = NULL;
    }

    if ( NULL != m_hInitializedEvent )
    {
        CloseHandle( m_hInitializedEvent );
        m_hInitializedEvent = NULL;
    }

    if ( NULL != m_hWorkDoneEvent )
    {
        CloseHandle( m_hWorkDoneEvent );
        m_hWorkDoneEvent = NULL;
    }

    if ( NULL != m_hRefrMutex )
    {
        CloseHandle( m_hRefrMutex );
        m_hRefrMutex = NULL;
    }

}

DWORD CWbemRefresher::RealEntry( void )
{
    // Grab hold of all the things we may care about in case some evil timing
    // problem occurs, so we don't get left trying to hit on member variables that
    // don't exist anymore.

    HANDLE  hQuitEvent          =   m_hQuitEvent,
            hDoWorkEvent        =   m_hDoWorkEvent,
            hInitializedEvent   =   m_hInitializedEvent,
            hWorkDoneEvent      =   m_hWorkDoneEvent;

    DWORD   dwWait = 0;

    HANDLE  ahEvents[2];

    ahEvents[0] = hDoWorkEvent;
    ahEvents[1] = hQuitEvent;

    // Initialize this thread
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (hr == S_FALSE) {
        // COM library is already initialized, we can continue;
        //
        hr = S_OK;
    }

    // Now get the refresher and config refresher pointers.

    IWbemRefresher*             pWbemRefresher = NULL;
    IWbemConfigureRefresher*    pWbemConfig = NULL;

    if ( SUCCEEDED( hr ) )
    {
        hr = CoCreateInstance (CLSID_WbemRefresher, 0, CLSCTX_SERVER,
                        IID_IWbemRefresher, (LPVOID *)&pWbemRefresher);

        if ( SUCCEEDED( hr ) )
        {
            pWbemRefresher->QueryInterface( IID_IWbemConfigureRefresher, (LPVOID *) &pWbemConfig );
        }

    }

    //  Obviously we can't go any further if we don't have our pointers correctly
    //  setup.
    m_fThreadOk = SUCCEEDED( hr );

    // Ready to go --- Signal the Initialized Event
    SetEvent( hInitializedEvent );

    if ( m_fThreadOk )
    {

        while ( ( dwWait = WaitForMultipleObjects( 2, ahEvents, FALSE,  INFINITE ) ) == WAIT_OBJECT_0 )
        {
            // Don't continue if quit is signalled
            if ( WaitForSingleObject( hQuitEvent, 0 ) == WAIT_OBJECT_0 )
            {
                break;
            }

            // This is where we'll do the real operation

            switch( m_eRefrOp )
            {
                case eRefrOpRefresh:
                {
                    m_hOperResult = pWbemRefresher->Refresh( m_lFlags );
                    break;
                }

                // For both of these ops, we will need to umarshal the
                // namespace
                case eRefrOpAddEnum:
                case eRefrOpAddByPath:
                {
                    IWbemServices*  pNamespace = NULL;

                    // Unmarshal the interface, then set security
                    m_hOperResult = CoGetInterfaceAndReleaseStream(
                        m_pNSStream, IID_IWbemServices,
                        (void**) &pNamespace );
                    m_pNSStream = NULL;

                    if ( SUCCEEDED( m_hOperResult ) )
                    {
                        m_hOperResult = SetWbemSecurity( pNamespace );

                        if ( SUCCEEDED( m_hOperResult ) )
                        {
                            if ( eRefrOpAddByPath == m_eRefrOp )
                            {
                                m_hOperResult = pWbemConfig->AddObjectByPath(
                                    pNamespace, m_wszPath, m_lFlags, NULL,
                                    m_ppRefreshable, m_plId );
                            }
                            else
                            {
                                m_hOperResult = pWbemConfig->AddEnum(
                                    pNamespace, m_wszClassName, m_lFlags, NULL,
                                    m_ppEnum, m_plId );
                            }
                        }

                        pNamespace->Release();
                    }

                    break;
                }

                case eRefrOpRemove:
                {
                    m_hOperResult = pWbemConfig->Remove( m_lId, m_lFlags );
                    break;
                }

                default:
                {
                    m_hOperResult = WBEM_E_FAILED;
                }
            }

            // Signal the event to let a waiting thread know we're done doing
            // what it asked us to do.
            SetEvent( hWorkDoneEvent );
        }

    }

    // This means we're not processing anymore (for whatever reason)
    m_fThreadOk = FALSE;

    // Cleanup our pointers
    if ( NULL != pWbemRefresher )
    {
        pWbemRefresher->Release();
    }

    if ( NULL != pWbemConfig )
    {
        pWbemConfig->Release();
    }

    CoUninitialize();

    return 0;
}

// CWbemRefresher class functions
SCODE CWbemRefresher::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid)
    {
        *ppvObj = (IUnknown*)this;
        AddRef();
        return NOERROR;
    }
    else if ( IID_IWbemRefresher == riid )
    {
        *ppvObj = (IWbemRefresher*) &m_xRefresher;
        AddRef();
        return NOERROR;
    }
    else if ( IID_IWbemConfigureRefresher == riid )
    {
        *ppvObj = (IWbemConfigureRefresher*) &m_xConfigRefresher;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

ULONG CWbemRefresher::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

ULONG CWbemRefresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRefCount);

    if (0 != lRef)
        return lRef;

    delete this;
    return 0;
}

HRESULT CWbemRefresher::SignalRefresher( void )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( SetEvent( m_hDoWorkEvent ) )
    {
        if ( WaitForSingleObject( m_hWorkDoneEvent, INFINITE ) == WAIT_OBJECT_0 )
        {
            hr = m_hOperResult;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    ClearRefresherParams();

    return hr;
}

HRESULT CWbemRefresher::SetRefresherParams( IWbemServices* pNamespace, tRefrOps eOp,
            LPCWSTR pwszPath, LPCWSTR pwszClassName, long lFlags,
            IWbemClassObject** ppRefreshable, IWbemHiPerfEnum** ppEnum, long* plId,
            long lId )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pNamespace )
    {
        // Marshal the namespace pointer into the stream member
        hr = CoMarshalInterThreadInterfaceInStream( IID_IWbemServices, pNamespace,
            &m_pNSStream );
    }
    else
    {
        m_pNSStream = NULL;
    }

    if ( SUCCEEDED( hr ) )
    {
        m_eRefrOp = eOp;
        m_wszPath = pwszPath;
        m_wszClassName = pwszClassName,
        m_lFlags = lFlags;
        m_ppRefreshable = ppRefreshable;
        m_ppEnum = ppEnum;
        m_plId = plId;
        m_lId = lId;
    }

    return hr;
}

void CWbemRefresher::ClearRefresherParams( void )
{
    m_pNSStream = NULL;
    m_eRefrOp = eRefrOpNone;
    m_wszPath = NULL;
    m_wszClassName = NULL,
    m_lFlags = 0L;
    m_ppRefreshable = NULL;
    m_ppEnum = NULL;
    m_plId = NULL;
    m_lId = 0L;
    m_hOperResult = WBEM_S_NO_ERROR;
}

// These are the real method implementations
STDMETHODIMP CWbemRefresher::AddObjectByPath(
    IWbemServices* pNamespace, LPCWSTR wszPath,
    long lFlags, IWbemContext* pContext,
    IWbemClassObject** ppRefreshable, long* plId)
{
    HRESULT hr = WBEM_E_FAILED;

    UNREFERENCED_PARAMETER (pContext);

    if ( WaitForSingleObject( m_hRefrMutex, WBEM_REFRESHER_TIMEOUT ) == WAIT_OBJECT_0 )
    {
        // Check that the thread is still running
        if ( m_fThreadOk )
        {
            // Setup the parameters and perform the operation
            hr = SetRefresherParams( pNamespace, eRefrOpAddByPath, wszPath, NULL,
                    lFlags, ppRefreshable, NULL, plId, 0L );

            if ( SUCCEEDED( hr ) )
            {
                // This is where we ask the thread to do the work
                hr = SignalRefresher();
            }
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

        ReleaseMutex( m_hRefrMutex );
    }
    else
    {
        hr = WBEM_E_REFRESHER_BUSY;
    }

    return hr;
}

STDMETHODIMP CWbemRefresher::AddObjectByTemplate(
    IWbemServices* pNamespace,
    IWbemClassObject* pTemplate,
    long lFlags, IWbemContext* pContext,
    IWbemClassObject** ppRefreshable, long* plId)
{
    UNREFERENCED_PARAMETER (pNamespace);
    UNREFERENCED_PARAMETER (pTemplate);
    UNREFERENCED_PARAMETER (lFlags);
    UNREFERENCED_PARAMETER (pContext);
    UNREFERENCED_PARAMETER (ppRefreshable);
    UNREFERENCED_PARAMETER (plId);

    // We don't call this internally, so don't implement
    return WBEM_E_METHOD_NOT_IMPLEMENTED;
}

STDMETHODIMP CWbemRefresher::Remove(long lId, long lFlags)
{

    HRESULT hr = WBEM_E_FAILED;

    UNREFERENCED_PARAMETER (lId);
    UNREFERENCED_PARAMETER (lFlags);

    if ( WaitForSingleObject( m_hRefrMutex, WBEM_REFRESHER_TIMEOUT ) == WAIT_OBJECT_0 )
    {
        // Check that the thread is still running
        if ( m_fThreadOk )
        {
            // Setup the parameters and perform the operation
            hr = SetRefresherParams( NULL, eRefrOpRemove, NULL, NULL,
                    lFlags, NULL, NULL, NULL, lId );

            if ( SUCCEEDED( hr ) )
            {
                // This is where we ask the thread to do the work
                hr = SignalRefresher();
            }
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

        ReleaseMutex( m_hRefrMutex );
    }
    else
    {
        hr = WBEM_E_REFRESHER_BUSY;
    }

    return hr;

}

STDMETHODIMP CWbemRefresher::AddRefresher(
                    IWbemRefresher* pRefresher, long lFlags, long* plId)
{
    UNREFERENCED_PARAMETER (lFlags);
    UNREFERENCED_PARAMETER (pRefresher);
    UNREFERENCED_PARAMETER (plId);

    // We don't call this internally, so don't implement
    return WBEM_E_METHOD_NOT_IMPLEMENTED;
}

HRESULT CWbemRefresher::AddEnum(
        IWbemServices* pNamespace, LPCWSTR wszClassName,
        long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
        long* plId)
{

    HRESULT hr = WBEM_E_FAILED;

    UNREFERENCED_PARAMETER (pContext);

    if ( WaitForSingleObject( m_hRefrMutex, WBEM_REFRESHER_TIMEOUT ) == WAIT_OBJECT_0 )
    {
        // Check that the thread is still running
        if ( m_fThreadOk )
        {
            // Setup the parameters and perform the operation
            hr = SetRefresherParams( pNamespace, eRefrOpAddEnum, NULL, wszClassName,
                    lFlags, NULL, ppEnum, plId, 0L );

            if ( SUCCEEDED( hr ) )
            {
                // This is where we ask the thread to do the work
                hr = SignalRefresher();
            }
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

        ReleaseMutex( m_hRefrMutex );
    }
    else
    {
        hr = WBEM_E_REFRESHER_BUSY;
    }

    return hr;

}

STDMETHODIMP CWbemRefresher::Refresh( long lFlags )
{
    HRESULT hr = WBEM_E_FAILED;

    if ( WaitForSingleObject( m_hRefrMutex, WBEM_REFRESHER_TIMEOUT ) == WAIT_OBJECT_0 )
    {
        // Check that the thread is still running
        if ( m_fThreadOk )
        {
            // Setup the parameters and perform the operation
            hr = SetRefresherParams( NULL, eRefrOpRefresh, NULL, NULL,
                    lFlags, NULL, NULL, NULL, 0L );

            if ( SUCCEEDED( hr ) )
            {
                // This is where we ask the thread to do the work
                hr = SignalRefresher();
            }
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

        ReleaseMutex( m_hRefrMutex );
    }
    else
    {
        hr = WBEM_E_REFRESHER_BUSY;
    }

    return hr;
}

// XRefresher
SCODE CWbemRefresher::XRefresher::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    return m_pOuter->QueryInterface( riid, ppvObj );
}

ULONG CWbemRefresher::XRefresher::AddRef()
{
    return m_pOuter->AddRef();
}

ULONG CWbemRefresher::XRefresher::Release()
{
    return m_pOuter->Release();
}

STDMETHODIMP CWbemRefresher::XRefresher::Refresh( long lFlags )
{
    // Pass through
    return m_pOuter->Refresh( lFlags );
}

// XConfigRefresher
SCODE CWbemRefresher::XConfigRefresher::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    return m_pOuter->QueryInterface( riid, ppvObj );
}

ULONG CWbemRefresher::XConfigRefresher::AddRef()
{
    return m_pOuter->AddRef();
}

ULONG CWbemRefresher::XConfigRefresher::Release()
{
    return m_pOuter->Release();
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::AddObjectByPath(
    IWbemServices* pNamespace, LPCWSTR wszPath,
    long lFlags, IWbemContext* pContext,
    IWbemClassObject** ppRefreshable, long* plId)
{
    // Pass through
    return m_pOuter->AddObjectByPath( pNamespace, wszPath, lFlags, pContext,
            ppRefreshable, plId );
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::AddObjectByTemplate(
    IWbemServices* pNamespace,
    IWbemClassObject* pTemplate,
    long lFlags, IWbemContext* pContext,
    IWbemClassObject** ppRefreshable, long* plId)
{
    // Pass through
    return m_pOuter->AddObjectByTemplate( pNamespace, pTemplate, lFlags, pContext,
            ppRefreshable, plId );
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::Remove(long lId, long lFlags)
{
    return m_pOuter->Remove( lId, lFlags );
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::AddRefresher(
                    IWbemRefresher* pRefresher, long lFlags, long* plId)
{
    return m_pOuter->AddRefresher( pRefresher, lFlags, plId );
}

HRESULT CWbemRefresher::XConfigRefresher::AddEnum(
        IWbemServices* pNamespace, LPCWSTR wszClassName,
        long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
        long* plId)
{
    return m_pOuter->AddEnum( pNamespace, wszClassName, lFlags, pContext,
            ppEnum, plId );
}

/*
**  End CWbemRefresher Implementation!
*/

// HELPER Function to establish the CWbemRefresher Interface pass-thru
HRESULT CoCreateRefresher( IWbemRefresher** ppRefresher )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Allocate the pass-thru object then, if successful, get
    // the interface pointer out of it
    CWbemRefresher* pWbemRefresher = new CWbemRefresher;

    if ( NULL != pWbemRefresher )
    {
        hr = pWbemRefresher->QueryInterface( IID_IWbemRefresher, (LPVOID*) ppRefresher );
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

PPDHI_WBEM_SERVER_DEF pFirstWbemServer = NULL;
//BOOL    bWbemInitialized = FALSE;

BOOL    bSecurityInitialized = FALSE;
IGlobalInterfaceTable * gp_GIT = NULL;

BOOL PdhiCoInitialize( void )
{
    HRESULT sc = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( !bSecurityInitialized )
    {
        // In case it hasn't been
        HRESULT hr = CoInitializeSecurity(
            NULL,   //Points to security descriptor
            -1L,     //Count of entries in asAuthSvc -1 means use default
            NULL,   //Array of names to register
            NULL,   //Reserved for future use
            RPC_C_AUTHN_LEVEL_PKT,  //The default authentication level
                                // for proxies
            RPC_C_IMP_LEVEL_IMPERSONATE,    //The default impersonation level
                                // for proxies
            NULL,   //Authentication information for
                    // each authentication service
            EOAC_NONE,   //Additional client and/or
                            // server-side capabilities
            NULL    //Reserved for future use
            );

        bSecurityInitialized = (hr == S_OK || hr == RPC_E_TOO_LATE);
    }

    if (gp_GIT == NULL) {
        HRESULT hr1 = CoCreateInstance(CLSID_StdGlobalInterfaceTable, 
                                       NULL,
                                       CLSCTX_INPROC_SERVER, 
                                       IID_IGlobalInterfaceTable,
                                       (void **) & gp_GIT); 
        if (hr1 != ERROR_SUCCESS) {
            gp_GIT = NULL;
        }
    }

    // We will only return that this succeeded if the call to CoInitializeEx
    // returned S_FALSE.  If it didn't, it either errored or returned S_OK.
    // If S_OK, we will assume that the client isn't doing any COM stuff
    // natively.  If S_FALSE, the client already CoInitialized this thread
    // so we just bumped up the ref count and should cleanup on the way
    // out

    return (S_FALSE == sc);
}

void PdhiCoUninitialize( void )
{
    CoUninitialize();
}

PDH_FUNCTION PdhiCloseWbemServer (PPDHI_WBEM_SERVER_DEF pWbemServer);

PDH_FUNCTION
PdhiDisconnectWbemServer (
    PPDHI_WBEM_SERVER_DEF pWbemServer
)
{
    PDH_STATUS  pdhReturn = ERROR_SUCCESS;
    if (pWbemServer != NULL) {
        pWbemServer->lRefCount--;
        if (pWbemServer->lRefCount < 0) {
            pWbemServer->lRefCount = 0;
        }
    }

    return pdhReturn;
}

PDH_FUNCTION
PdhiFreeWbemQuery (
    PPDHI_QUERY     pThisQuery
)
{
    HRESULT hRes;

    if (!bProcessIsDetaching) {
        if ((pThisQuery->pRefresherCfg) != NULL) {
            hRes = pThisQuery->pRefresherCfg->Release ();
            pThisQuery->pRefresherCfg = NULL;
        }

        if ((pThisQuery->pRefresher) != NULL) {
            hRes = pThisQuery->pRefresher->Release ();
            pThisQuery->pRefresher = NULL;
        }
    }
    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiCloseWbemCounter (
    PPDHI_COUNTER   pThisCounter
)
{
    HRESULT hRes;
    BOOLEAN bRemoveRefresher = TRUE;

    if (!bProcessIsDetaching) {
        if (pThisCounter->pOwner->pRefresherCfg != NULL) {
            PPDHI_QUERY   pQuery   = pThisCounter->pOwner;
            PPDHI_COUNTER pCounter = pQuery->pCounterListHead;

            do {
                if (pCounter == NULL) {
                    bRemoveRefresher = FALSE;
                }
                else if (pCounter != pThisCounter && pCounter->lWbemRefreshId
                                == pThisCounter->lWbemRefreshId) {
                    bRemoveRefresher = FALSE;
                }
                else {
                    pCounter = pCounter->next.flink;
                }
            }
            while (bRemoveRefresher && pCounter != NULL
                                    && pCounter != pQuery->pCounterListHead);

            if (bRemoveRefresher) {
                hRes = pThisCounter->pOwner->pRefresherCfg->Remove(
                                pThisCounter->lWbemRefreshId, 0L);
            }
            // assert (hRes == S_OK); the function returns a BOOL even though it's defined as an HRESULT
//            pThisCounter->pOwner->pRefresherCfg->Release();
//            pThisCounter->pOwner->pRefresherCfg = NULL;
        }

        if (pThisCounter->pWbemAccess != NULL) {
            pThisCounter->pWbemAccess->Release();
            pThisCounter->pWbemAccess = NULL;
        }

        if (pThisCounter->pWbemObject != NULL) {
            pThisCounter->pWbemObject->Release();
            pThisCounter->pWbemObject = NULL;
        }
    }

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiBreakWbemMachineName (
    LPCWSTR     szMachineAndNamespace,
    LPWSTR      szMachine,
    LPWSTR      szNamespace
)
/*
    assumes szMachine and szPath are large enough to hold the result
*/
{
    LPWSTR  szSrc = NULL;
    LPWSTR  szDest = NULL;

    assert (szMachine != NULL);
    assert (szNamespace != NULL);

    szSrc = (LPWSTR)szMachineAndNamespace;

    if (szSrc == NULL) {
        // then use local machine and default namespace
        lstrcpyW (szMachine, szStaticLocalMachineName); // local machine
        lstrcpyW (szNamespace, cszWbemDefaultPerfRoot);
        return ERROR_SUCCESS;
    } else {
        // break into components
        if (*szSrc  != NULL) {
            // there's a string, see if it's a machine or a namespace
            if ((szSrc[0] == L'\\') && (szSrc[1] == L'\\')) {
                szDest = szMachine;
                // then there's a machine name
                *szDest++ = *szSrc++;
                *szDest++ = *szSrc++;
                while ((*szSrc != 0) && (*szSrc != L'\\')){
                    *szDest++ = *szSrc++;
                }
                *szDest = 0;
            } else {
                // no machine so use default
                // it must be just a namespace
            }
        } else {
            // no machine so use default
        }

        if (szDest == NULL) {
            // nothing found yet, so insert local machine as default
            szDest = szMachine;
            lstrcpyW (szDest, szStaticLocalMachineName);
        }

        szDest = szNamespace;

        if (*szSrc != 0) {
            // if there's a namespace then copy it
            szSrc++;    // move past backslash
            while (*szSrc != 0) {
                *szDest++ = *szSrc++;
            }
            *szDest = 0;
        } else {
            // else return the default;
            lstrcpyW (szDest, cszWbemDefaultPerfRoot);
        }
        return ERROR_SUCCESS;
    }
}

PDH_FUNCTION
PdhiMakeWbemInstancePath (
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPWSTR                      szFullPathBuffer,
    IN      BOOL                        bMakeRelativePath
)
{
    WCHAR   szMachine[MAX_PATH];
    WCHAR   szNamespace[MAX_PATH];
    WCHAR   szWbemInstance[MAX_PATH];

    LPWSTR  szSrc, szDest;
    //  the function assumes that the path buffer is sufficiently large
    //  to hold the result
    //
    //
    // the wbem class instance path consists of one of the following formats:
    // for perf objects with one and only one instance (singleton classes in
    // WBEM parlance) the format is
    //
    //      <objectname>=@
    //
    // for object with instances, the format is
    //
    //      <objectname>.Name="<instancename>"
    //
    if (!bMakeRelativePath) {
        PdhiBreakWbemMachineName (
            pCounterPathElements->szMachineName,
            szMachine,
            szNamespace);
        lstrcpyW (szFullPathBuffer, szMachine);
        lstrcatW (szFullPathBuffer, cszBackSlash);
        lstrcatW (szFullPathBuffer, szNamespace);
        lstrcatW (szFullPathBuffer, cszColon);
    } else {
        *szFullPathBuffer = 0;
    }

    if (pCounterPathElements->szInstanceName == NULL) {
        // then apply the singleton logic
        lstrcatW (szFullPathBuffer, pCounterPathElements->szObjectName);
        lstrcatW (szFullPathBuffer, cszSingletonInstance);
    } else {
        // wbem will interpret the backslash character as an
        // escape char (as "C" does) so we'll have to double each
        // backslash in the string to make it come out OK
        szDest = &szWbemInstance[0];
        if (pCounterPathElements->szParentInstance != NULL) {
            szSrc = pCounterPathElements->szParentInstance;
            while (*szSrc != 0) {
                *szDest = *szSrc;
                if (*szSrc == BACKSLASH_L) {
                    *++szDest = BACKSLASH_L;
                }
                szDest++;
                szSrc++;
                assert (szDest < &szWbemInstance[MAX_PATH]);
            }
            *szDest++ = '/'; // parent/child delimiter
        }
        szSrc = pCounterPathElements->szInstanceName;
        while (*szSrc != 0) {
            *szDest = *szSrc;
            if (*szSrc == BACKSLASH_L) {
                *++szDest = BACKSLASH_L;
            }
            szDest++;
            szSrc++;
            assert (szDest < &szWbemInstance[MAX_PATH]);
        }
        *szDest = 0;
        // apply the instance name format
        lstrcatW (szFullPathBuffer, pCounterPathElements->szObjectName);
        lstrcatW (szFullPathBuffer, cszNameParam);
        lstrcatW (szFullPathBuffer, szWbemInstance);
        lstrcatW (szFullPathBuffer, cszDoubleQuote);
    }
    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiWbemGetCounterPropertyName (
    IWbemClassObject        *pThisClass,
    LPCWSTR                 szCounterDisplayName,
    LPWSTR                  szPropertyName,
    DWORD                   dwPropertyNameSize
)
{
    HRESULT         hResult;
    PDH_STATUS      pdhStatus = PDH_CSTATUS_NO_COUNTER;
    SAFEARRAY       *psaNames = NULL;
    long            lLower; 
    long            lUpper = 0;
    long            lCount;
    BSTR            bsPropName = NULL;
    BSTR            bsCountertype = NULL;
    BSTR            bsDisplayname = NULL;
    VARIANT         vName, vCountertype;
    IWbemQualifierSet       *pQualSet = NULL;

    VariantInit (&vName);
    VariantInit (&vCountertype);

    // get the properties of this class as a Safe Array
    hResult = pThisClass->GetNames (NULL,
        WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
    if (hResult == WBEM_NO_ERROR) {
        hResult = SafeArrayGetLBound (psaNames, 1, &lLower);
        if (hResult == S_OK) {
            hResult = SafeArrayGetUBound (psaNames, 1, &lUpper);
        }
        if (hResult == S_OK) {
            bsCountertype = SysAllocString (cszCountertype);
            bsDisplayname = SysAllocString (cszDisplayname);
            if (bsCountertype && bsDisplayname) {
                for (lCount = lLower; lCount <= lUpper; lCount++) {
                    hResult = SafeArrayGetElement (psaNames, &lCount, &bsPropName);
                    if (hResult == S_OK) {
                        // this is the desired counter so
                        // get the qualifier set for this property
                        hResult = pThisClass->GetPropertyQualifierSet (
                            bsPropName, &pQualSet);
                        if (hResult == WBEM_NO_ERROR) {
                            LONG    lCounterType;
                            // make sure this is a perf counter property
                            hResult = pQualSet->Get (bsCountertype, 0, &vCountertype, NULL);
                            if (hResult == WBEM_NO_ERROR) {
                                lCounterType = V_I4(&vCountertype);
                                // then see if this is a displayable counter
                                if (!(lCounterType & PERF_DISPLAY_NOSHOW) ||
                                    (lCounterType == PERF_AVERAGE_BULK)) {
                                    // by testing for the counter type
                                    // get the display name for this property
                                    hResult = pQualSet->Get (bsDisplayname, 0, &vName, NULL);
                                    if (hResult == WBEM_NO_ERROR) {
                                        // display name found compare it
                                        if (lstrcmpiW(szCounterDisplayName, V_BSTR(&vName)) == 0) {
                                            // then this is the correct property so return
                                            if ((DWORD)lstrlenW(bsPropName) < dwPropertyNameSize) {
                                                lstrcpyW (szPropertyName, (LPWSTR)bsPropName);
                                                pdhStatus = ERROR_SUCCESS;
                                                pQualSet->Release();
                                                pQualSet = NULL;
                                                break;
                                            } else {
                                                pdhStatus = PDH_MORE_DATA;
                                            }
                                        } else {
                                            //not this property so continue
                                        }
                                    }
                                } else {
                                    // this is a "don't show" counter so skip it
                                }
                            } else {
                                // unable to get the counter type so it's probably
                                // not a perf counter property, skip it and continue
                            }
                            VariantClear (&vName);
                            VariantClear (&vCountertype);
                            pQualSet->Release();
                            pQualSet = NULL;
                        } else {
                            // unable to read qualifiers so skip
                            continue;
                        }
                    } else {
                        // unable to read element in SafeArray
                        pdhStatus = PDH_WBEM_ERROR;
                        SetLastError(hResult);
                    }
                } // end for each element in SafeArray
            } else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            PdhiSysFreeString (&bsCountertype);
            PdhiSysFreeString (&bsDisplayname);
        } else {
            // unable to get array boundries
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }

    } else {
        // unable to get property strings
        pdhStatus = PDH_WBEM_ERROR;
        SetLastError (hResult);
    }

    VariantClear (&vName);
    VariantClear (&vCountertype);

    if (psaNames != NULL) {
        // Clear the SafeArray if it exists
        SafeArrayDestroy( psaNames );
    }

    // make sure it was released
    assert (pQualSet == NULL);

    return pdhStatus;
}

PDH_FUNCTION
PdhiWbemGetCounterDisplayName (
    IWbemClassObject        *pThisClass,
    LPCWSTR                 szCounterName,
    LPWSTR                  szDisplayName,
    DWORD                   dwDisplayNameSize
)
{
    HRESULT         hResult;
    PDH_STATUS      pdhStatus = PDH_CSTATUS_NO_COUNTER;
    SAFEARRAY       *psaNames = NULL;
    long            lLower; 
    long            lUpper = 0;
    long            lCount;
    BSTR            bsPropName = NULL;
    BSTR            bsCountertype = NULL;
    BSTR            bsDisplayname = NULL;
    VARIANT         vName, vCountertype;
    IWbemQualifierSet       *pQualSet = NULL;

    VariantInit (&vName);
    VariantInit (&vCountertype);

    // get the properties of this class as a Safe Array
    hResult = pThisClass->GetNames (NULL,
        WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
    if (hResult == WBEM_NO_ERROR) {
        hResult = SafeArrayGetLBound (psaNames, 1, &lLower);
        if (hResult == S_OK) {
            hResult = SafeArrayGetUBound (psaNames, 1, &lUpper);
        }
        if (hResult == S_OK) {
            bsCountertype = SysAllocString (cszCountertype);
            bsDisplayname = SysAllocString (cszDisplayname);
            if (bsCountertype && bsDisplayname) {
                for (lCount = lLower; lCount <= lUpper; lCount++) {
                    hResult = SafeArrayGetElement (psaNames, &lCount, &bsPropName);
                    if (hResult == S_OK) {
                        if (lstrcmpiW ((LPWSTR)bsPropName, szCounterName) == 0) {
                            // this is the desired counter so
                            // get the qualifier set for this property
                            hResult = pThisClass->GetPropertyQualifierSet (
                                bsPropName, &pQualSet);
                            if (hResult == WBEM_NO_ERROR) {
                                LONG    lCounterType;
                                // make sure this is a perf counter property
                                hResult = pQualSet->Get (bsCountertype, 0, &vCountertype, NULL);
                                if (hResult == WBEM_NO_ERROR) {
                                    lCounterType = V_I4(&vCountertype);
                                    // then see if this is a displayable counter
                                    if (!(lCounterType & PERF_DISPLAY_NOSHOW) ||
                                        (lCounterType == PERF_AVERAGE_BULK)) {
                                        // by testing for the counter type
                                        // get the display name for this property
                                        hResult = pQualSet->Get (bsDisplayname, 0, &vName, NULL);
                                        if (hResult == WBEM_NO_ERROR) {
                                            // display name found so copy and break
                                            if ((DWORD)lstrlenW(V_BSTR(&vName)) < dwDisplayNameSize) {
                                                lstrcpyW (szDisplayName, V_BSTR(&vName));
                                                pdhStatus = ERROR_SUCCESS;
                                                pQualSet->Release();
                                                pQualSet = NULL;
                                                break;
                                            } else {
                                                pdhStatus = PDH_MORE_DATA;
                                            }
                                        }
                                    } else {
                                        // this is a "don't show" counter so skip it
                                    }
                                } else {
                                    // unable to get the counter type so it's probably
                                    // not a perf counter property, skip it and continue
                                }
                                VariantClear (&vName);
                                VariantClear (&vCountertype);
                                pQualSet->Release();
                                pQualSet = NULL;
                            } else {
                                // unable to read qualifiers so skip
                                continue;
                            }
                        } else {
                            // aren't interested in this property, so
                            continue;
                        }
                    } else {
                        // unable to read element in SafeArray
                        pdhStatus = PDH_WBEM_ERROR;
                        SetLastError(hResult);
                    }
                } // end for each element in SafeArray
            } else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            PdhiSysFreeString (&bsCountertype);
            PdhiSysFreeString (&bsDisplayname);
        } else {
            // unable to get array boundries
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }

    } else {
        // unable to get property strings
        pdhStatus = PDH_WBEM_ERROR;
        SetLastError (hResult);
    }

    VariantClear (&vName);
    VariantClear (&vCountertype);

    // Clear the SafeArray if it exists
    if ( NULL != psaNames )
    {
        SafeArrayDestroy( psaNames );
    }
    // make sure it was released
    assert (pQualSet == NULL);

    return pdhStatus;
}

PDH_FUNCTION
PdhiWbemGetClassObjectByName (
    PPDHI_WBEM_SERVER_DEF   pThisServer,
    LPCWSTR                 szClassName,
    IWbemClassObject        **pReturnClass
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    HRESULT hResult;
    BSTR    bsClassName;

    IWbemClassObject        *pThisClass = NULL;

    bsClassName = SysAllocString (szClassName);

    if (bsClassName) {
        hResult = pThisServer->pSvc->GetObject (
            bsClassName, // class name
            WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL,
            &pThisClass,
            NULL);
        PdhiSysFreeString (&bsClassName);

        if (hResult != WBEM_NO_ERROR) {
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        } else {
            *pReturnClass = pThisClass;
        }
    } else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    return (pdhStatus);
}

PDH_FUNCTION
PdhiWbemGetClassDisplayName (
    PPDHI_WBEM_SERVER_DEF   pThisServer,
    LPCWSTR                 szClassName,
    LPWSTR                  szClassDisplayName,
    DWORD                   dwClassDisplayNameSize,
    IWbemClassObject        **pReturnClass
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    HRESULT hResult;
    BSTR    bsClassName;
    BSTR    bsClass;
    BSTR    bsDisplayName;
    VARIANT vName;
    LPWSTR  szDisplayName;

    IWbemClassObject        *pThisClass = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    VariantInit (&vName);

    bsClassName = SysAllocString (szClassName);

    if (bsClassName) {
        hResult = pThisServer->pSvc->GetObject (
            bsClassName, // class name
            WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL,
            &pThisClass,
            NULL);
        if (hResult != WBEM_NO_ERROR) {
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }
        PdhiSysFreeString (&bsClassName);
    } else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // get the display name property of this class
        pThisClass->GetQualifierSet (&pQualSet);
        if (pQualSet != NULL) {
            bsDisplayName = SysAllocString (cszDisplayname);
            if (bsDisplayName) {
                hResult = pQualSet->Get (bsDisplayName, 0, &vName, 0);

                if (hResult == WBEM_E_NOT_FOUND) {
                    // then this has not display name so
                    // pull the class name
                    bsClass = SysAllocString (cszClass);
                    if (bsClass) {
                        hResult = pThisClass->Get (bsClass, 0, &vName, 0, 0);
                        PdhiSysFreeString (&bsClass);
                    } else {
                        hResult = WBEM_E_OUT_OF_MEMORY;
                    }
                } else {
                    hResult = WBEM_E_OUT_OF_MEMORY;
                }
                pQualSet->Release();
            } else {
                hResult = WBEM_E_OUT_OF_MEMORY;
            }
        } else {
            hResult = WBEM_E_NOT_FOUND;
        }

        if (hResult == WBEM_E_NOT_FOUND) {
            //unable to look up a display name so nothing to return
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        } else if (hResult == WBEM_E_OUT_OF_MEMORY) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            SetLastError(hResult);
        } else if (hResult == S_OK) {
            // copy string to caller's buffers
            szDisplayName = V_BSTR(&vName);
            if ((DWORD)lstrlenW(szDisplayName) < dwClassDisplayNameSize) {
                lstrcpyW (szClassDisplayName, szDisplayName);
                pdhStatus = ERROR_SUCCESS;
            }
            if (pReturnClass != NULL) {
                // return the class pointer, the caller will close it
                *pReturnClass = pThisClass;
            } else {
                // close it
                pThisClass->Release();
            }
        }
    }

    VariantClear (&vName);

    return pdhStatus;
}
BOOL
PdhiIsSingletonClass (
    IWbemClassObject        *pThisClass
)
{
    HRESULT                 hResult;
    BOOL                    bReturnValue = FALSE;   //
    BSTR                    bsSingleton = NULL;
    VARIANT                 vValue;
    IWbemQualifierSet       *pQualSet = NULL;

    bsSingleton = SysAllocString (cszSingleton);

    if (bsSingleton) {
        VariantInit (&vValue);
        // get the display name of this class
        pThisClass->GetQualifierSet (&pQualSet);
        if (pQualSet != NULL) {
            hResult = pQualSet->Get (bsSingleton, 0, &vValue, 0);
            pQualSet->Release();
        } else {
            hResult = WBEM_E_NOT_FOUND;
        }

        if (hResult == ERROR_SUCCESS) {
            bReturnValue = TRUE;
        }

        VariantClear (&vValue);
        PdhiSysFreeString (&bsSingleton);
    } else {
        bReturnValue = FALSE;
    }

    return bReturnValue;
}

#pragma warning ( disable : 4127 )
PDH_FUNCTION
PdhiEnumWbemServerObjects(
    IN  PPDHI_WBEM_SERVER_DEF   pThisServer,
    IN  LPVOID                  mszObjectList,
    IN  LPDWORD                 pcchBufferSize,
    IN  DWORD                   dwDetailLevel,
    IN  BOOL                    bRefresh,
    IN  BOOL                    bUnicode
);

PDH_FUNCTION
PdhiWbemGetObjectClassName (
    PPDHI_WBEM_SERVER_DEF   pThisServer,
    LPCWSTR                 szObjectName,
    LPWSTR                  szObjectClassName,
    DWORD                   dwObjectClassNameSize,
    IWbemClassObject        **pReturnClass
)
{
    PDH_STATUS    pdhStatus = ERROR_SUCCESS;
    HRESULT       hResult;
    LONG          lResult;

    assert(pThisServer != NULL);
    assert(szObjectName != NULL);
    assert(szObjectClassName != NULL);
    assert(dwObjectClassNameSize > 0);

    if (pThisServer->pObjList == NULL) {
        DWORD dwSize = 0;
        pdhStatus = PdhiEnumWbemServerObjects(
                        pThisServer,
                        NULL,
                        & dwSize,
                        PERF_DETAIL_WIZARD | PERF_DETAIL_COSTLY,
                        TRUE,
                        TRUE);
        if (pThisServer->pObjList != NULL) {
            pdhStatus = ERROR_SUCCESS;
        }
    }

    if (pThisServer->pObjList != NULL) {
        PPDHI_WBEM_OBJECT_DEF pObject = pThisServer->pObjList;

        pdhStatus = PDH_CSTATUS_NO_OBJECT;
        while (pObject != NULL) {
            lResult = lstrcmpiW(pObject->szDisplay, szObjectName);
            if (lResult == 0) {
                if (  ((DWORD) lstrlenW(pObject->szObject))
                    < dwObjectClassNameSize) {
                    pdhStatus = ERROR_SUCCESS;
                    lstrcpyW(szObjectClassName, pObject->szObject);
                }
                else {
                    pdhStatus = PDH_MORE_DATA;
                }

                if (pObject->pClass == NULL) {
                    BSTR bsClassName = SysAllocString(pObject->szObject);
                    if (bsClassName) {
                        hResult = pThisServer->pSvc->GetObject(
                                bsClassName, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, & pObject->pClass, NULL);
                        if (hResult != WBEM_NO_ERROR) {
                            SetLastError(hResult);
                            pdhStatus = PDH_WBEM_ERROR;
                        }
                        else if (pReturnClass != NULL) {
                            * pReturnClass = pObject->pClass;
                        }
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
                else if (pReturnClass != NULL) {
                    * pReturnClass = pObject->pClass;
                }
                break;
            }
            pObject = pObject->pNext;
        }
    }

    return pdhStatus;
}
#pragma warning ( default : 4127 )

PDH_FUNCTION
PdhiAddWbemServer (
    LPCWSTR  szMachineName,
    PPDHI_WBEM_SERVER_DEF *pWbemServer
)
{
    IWbemLocator    *pWbemLocator = 0;
    IWbemServices   *pWbemServices = 0;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    HRESULT         hResult;
    DWORD           dwResult;
    DWORD           dwStrLen = 0;
    PPDHI_WBEM_SERVER_DEF pNewServer = NULL;
    WCHAR           szLocalMachineName[MAX_PATH];
    WCHAR           szLocalServerPath[MAX_PATH];
    WCHAR           szLocalNameSpaceString[MAX_PATH];
    WCHAR           szLocale[32];

    // szMachineName can be null,
    // that means use the local machine and default namespace
    assert (pWbemServer != NULL);

    // connect to locator
    dwResult = CoCreateInstance (CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
        IID_IWbemLocator, (LPVOID *)&pWbemLocator);
    if (dwResult != S_OK) {
        SetLastError (dwResult);
        pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        PdhiBreakWbemMachineName (
            szMachineName,
            szLocalMachineName,
            szLocalNameSpaceString);
        lstrcpyW (szLocalServerPath, szLocalMachineName);
        lstrcatW (szLocalServerPath, szLocalNameSpaceString);

        // Create the locale
        swprintf( szLocale, L"MS_%hX", GetUserDefaultUILanguage());

        // try to connect to the service
        hResult = pWbemLocator->ConnectServer (
            szLocalServerPath,
            NULL, NULL, szLocale,
            0L,
            0,0,
            &pWbemServices);
        if (hResult) {
            SetLastError (hResult);
            pdhStatus =  PDH_CANNOT_CONNECT_WMI_SERVER;
        } else {
            dwStrLen = lstrlenW (szLocalMachineName ) + 1;

        }
        // free the locator
        pWbemLocator->Release();
    }

    // If we succeeded, we need to set Interface Security on the proxy and its
    // IUnknown in order for Impersonation to correctly work.

    if ( pdhStatus == ERROR_SUCCESS )
    {
        pdhStatus = SetWbemSecurity( pWbemServices );
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // everything went ok so save this connection
        if (*pWbemServer == NULL) {
            // then this is a new connection
            pNewServer = (PPDHI_WBEM_SERVER_DEF)G_ALLOC (sizeof (PDHI_WBEM_SERVER_DEF) + (dwStrLen * sizeof (WCHAR)));
            if (pNewServer == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            } else {
                // insert this at the head of the list
                pNewServer->pNext = pFirstWbemServer;
                pFirstWbemServer = pNewServer;
                pNewServer->szMachine = (LPWSTR)&pNewServer[1];
                lstrcpyW (pNewServer->szMachine, szLocalMachineName);
                pNewServer->lRefCount = 0; // it'll be incremented in the connect function
                *pWbemServer = pNewServer;
            }
        } else {
            // we are reconnecting and reusing an old memory block
            // so just update the pointer
            pNewServer = *pWbemServer;
        }
        // if reconnecting or connecting for the first time, this should be NULL
        assert (pNewServer->pSvc == NULL);

        if (pdhStatus == ERROR_SUCCESS) {
            // update fields
            // load the name fields
            pNewServer->pSvc     = pWbemServices;
            pNewServer->pObjList = NULL;
            pNewServer->dwCache  = 0;
            if (gp_GIT != NULL) {
                HRESULT hrTmp = gp_GIT->RegisterInterfaceInGlobal(
                                                pWbemServices,
                                                IID_IWbemServices,
                                                & (pNewServer->dwCache));
                DebugPrint((3,"RegisterInterfaceInGlobal(0x%08X,0x%08X,%d)\n",
                            hrTmp, pNewServer->pSvc, pNewServer->dwCache));
                if (! SUCCEEDED(hrTmp)) {
                    pWbemServices->Release();
                    pNewServer->pSvc    = NULL;
                    pNewServer->dwCache = 0;
                    pdhStatus           = PDH_WBEM_ERROR;
                }
            }
            else {
                pWbemServices->Release();
                pNewServer->pSvc    = NULL;
                pNewServer->dwCache = 0;
                pdhStatus           = PDH_WBEM_ERROR;
            }
        } else {
            // something failed so return a NULL for the server pointer
            *pWbemServer = NULL;
        }
    } else {
        // unable to connect so return NULL
        *pWbemServer = NULL;
    }

    // if there was an eror, then free the new sever memory
    if ((* pWbemServer) == NULL) G_FREE(pNewServer);

    return pdhStatus;
}

PDH_FUNCTION
PdhiCloseWbemServer (
    PPDHI_WBEM_SERVER_DEF pWbemServer
)
{
    assert (pWbemServer != NULL);

    if (!bProcessIsDetaching) {
        if (pWbemServer != NULL) {
            if (pWbemServer->pObjList != NULL) {
                PPDHI_WBEM_OBJECT_DEF pObject = pWbemServer->pObjList;
                PPDHI_WBEM_OBJECT_DEF pNext;

                pWbemServer->pObjList = NULL;
                while (pObject != NULL) {
                    pNext = pObject->pNext;
                    if (pObject->pClass != NULL) pObject->pClass->Release();
                    G_FREE(pObject);
                    pObject = pNext;
                }
            }
            if (pWbemServer->pSvc != NULL) {
                // this is about all that's currently required
                pWbemServer->pSvc->Release();
                pWbemServer->pSvc = NULL;
            } else {
                // no server is connected
            }
        } else {
            // no structure exists
        }
    }

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiConnectWbemServer (
    LPCWSTR  szMachineName,
    PPDHI_WBEM_SERVER_DEF *pWbemServer
)
{
    PDH_STATUS  pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
    PPDHI_WBEM_SERVER_DEF pThisServer = NULL;

    LPWSTR  szWideMachineName = NULL;
    LPWSTR  szWideNamespace = NULL;
    LPWSTR  szMachineNameArg = NULL;

    // get the local machine name & default name space if the caller
    // has passed in a NULL machine name

    if (szMachineName == NULL) {
        szWideMachineName = (LPWSTR) G_ALLOC (2048 + 1024); // this should be long enough
        if (szWideMachineName == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        } else {
            szWideNamespace = (LPWSTR)((LPBYTE)szWideMachineName + 2048);
        }

        if (pdhStatus != PDH_MEMORY_ALLOCATION_FAILURE) {
            pdhStatus = PdhiBreakWbemMachineName (
                NULL,
                szWideMachineName,
                szWideNamespace);
//            lstrcatW (szWideMachineName, cszBackSlash);
//            lstrcatW (szWideMachineName, szWideNamespace);
            szMachineNameArg = szWideMachineName;
        }
    } else {
        szMachineNameArg = (LPWSTR)szMachineName;
        pdhStatus = ERROR_SUCCESS;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // walk down list of connected servers and find the requested one
        assert (pWbemServer != NULL);

        for (pThisServer = pFirstWbemServer;
             pThisServer != NULL;
             pThisServer = pThisServer->pNext) {
            // machine name includes the namespace
            if (lstrcmpiW(pThisServer->szMachine, szMachineNameArg) == 0) {
                pdhStatus = ERROR_SUCCESS;
                break;
            }
        }

        if (pThisServer == NULL) {
             // then add it to the list and return it
             pdhStatus = PdhiAddWbemServer (
                szMachineNameArg,
                &pThisServer);
        } else {
            // make sure the server is really there
            // this is just a dummy call to see if the server will respond
            // with an error or RPC will respond with an error that there's
            // no server anymore.
            HRESULT hrTest;

            if (gp_GIT != NULL) {
                IWbemServices * pSvc = NULL;

                hrTest = gp_GIT->GetInterfaceFromGlobal(
                                pThisServer->dwCache,
                                IID_IWbemServices,
                                (void **) & pSvc);
                if (SUCCEEDED(hrTest)) {
                    if (pSvc != pThisServer->pSvc) {
                        DebugPrint((3,"GetInterfaceFromGlobal(0x%08X,%d,0x%08X,0x%08X)\n",
                                hrTest, pThisServer->dwCache, pThisServer->pSvc, pSvc));
                        pThisServer->pSvc = NULL;
                        if (pThisServer->pObjList != NULL) {
                            PPDHI_WBEM_OBJECT_DEF pObject;
                            PPDHI_WBEM_OBJECT_DEF pNext;
                            pObject = pThisServer->pObjList;
                            pThisServer->pObjList = NULL;
                            while (pObject != NULL) {
                                pNext = pObject->pNext;
                                G_FREE(pObject);
                                pObject = pNext;
                            }
                        }
                    }
                }
                else {
                    DebugPrint((3,"GetInterfaceFromGlobal(0x%08X,%d,0x%08X,0x%08X)\n",
                            hrTest, pThisServer->dwCache, pThisServer->pSvc, pSvc));
                    pThisServer->pSvc   = NULL;
                    if (pThisServer->pObjList != NULL) {
                        PPDHI_WBEM_OBJECT_DEF pObject;
                        PPDHI_WBEM_OBJECT_DEF pNext;
                        pObject = pThisServer->pObjList;
                        pThisServer->pObjList = NULL;
                        while (pObject != NULL) {
                            pNext = pObject->pNext;
                            G_FREE(pObject);
                            pObject = pNext;
                        }
                    }
                }
            }
            else {
                pThisServer->pSvc  = NULL;
                if (pThisServer->pObjList != NULL) {
                    PPDHI_WBEM_OBJECT_DEF pObject;
                    PPDHI_WBEM_OBJECT_DEF pNext;
                    pObject = pThisServer->pObjList;
                    pThisServer->pObjList = NULL;
                    while (pObject != NULL) {
                        pNext = pObject->pNext;
                        G_FREE(pObject);
                        pObject = pNext;
                    }
                }
            }
            if (pThisServer->pSvc != NULL) {
                hrTest = pThisServer->pSvc->CancelAsyncCall(NULL);
            } else {
                // there is no service connected so set the HRESULT to
                // get the next block to try and reconnect
                hrTest = 0x800706BF; // some bad status value thats NOT WBEM_E_INVALID_PARAMETER
            }

            // if the error is WBEM_E_INVALID_PARAMETER then the server is there
            // so we can continue
            // else if the error is something else then try to reconnect by closing and
            // reopening this connection

            if (hrTest != WBEM_E_INVALID_PARAMETER) {
                PdhiCloseWbemServer(pThisServer);
                pdhStatus = PdhiAddWbemServer (
                    szMachineNameArg,
                    &pThisServer);
            }
        }

        *pWbemServer = pThisServer;

        if (pdhStatus == ERROR_SUCCESS) pThisServer->lRefCount++;
    }

    if (szWideMachineName != NULL)  G_FREE (szWideMachineName);

    return pdhStatus;
}

PDH_FUNCTION
PdhiFreeAllWbemServers (
)
{
    PPDHI_WBEM_SERVER_DEF pThisServer;
    PPDHI_WBEM_SERVER_DEF pNextServer;

    pThisServer = pFirstWbemServer;
    while (pThisServer != NULL) {
        pNextServer = pThisServer->pNext;
        PdhiCloseWbemServer (pThisServer);
        G_FREE(pThisServer);
        pThisServer = pNextServer;
    }
    pFirstWbemServer = NULL;

    if (gp_GIT != NULL) {
        gp_GIT->Release();
        gp_GIT = NULL;
    }

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiGetWbemExplainText (
    IN  LPCWSTR     szMachineName,
    IN  LPCWSTR     szObjectName,
    IN  LPCWSTR     szCounterName,
    IN  LPWSTR      szExplain,
    IN  LPDWORD     pdwExplain
)
{
    PDH_STATUS Status      = ERROR_SUCCESS;
    HRESULT    hResult;
    BOOL       bDisconnect = FALSE;
    VARIANT    vsExplain;
    WCHAR      szObjectClassName[MAX_PATH];

    PPDHI_WBEM_SERVER_DEF   pThisServer = NULL;
    IEnumWbemClassObject  * pEnum       = NULL;
    IWbemClassObject      * pThisObject = NULL;
    IWbemQualifierSet     * pQualSet    = NULL;
    BOOL                    fCoInitialized = PdhiCoInitialize();

    if (szMachineName == NULL || szObjectName == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    if (szExplain != NULL && * pdwExplain != 0) {
        ZeroMemory(szExplain, * pdwExplain);
    }

    if (Status == ERROR_SUCCESS) {
        Status = PdhiConnectWbemServer(szMachineName, &pThisServer);
    }
    if (Status == ERROR_SUCCESS) {
        bDisconnect = TRUE;
        Status = PdhiWbemGetObjectClassName(
                pThisServer,
                szObjectName,
                szObjectClassName,
                MAX_PATH,
                & pThisObject);
    }

    if (Status == ERROR_SUCCESS) {
        VariantInit(& vsExplain);

        if (szCounterName != NULL) {
            SAFEARRAY * psaNames      = NULL;
            LONG        lLower        = 0; 
            LONG        lUpper        = 0;
            LONG        lCount        = 0;
            BSTR        bsPropName    = NULL;
            VARIANT     vName;
            VARIANT     vCountertype;
            LONG        lCounterType;

            VariantInit (& vName);
            VariantInit (& vCountertype);

            hResult = pThisObject->GetNames(
                        NULL,
                        WBEM_FLAG_NONSYSTEM_ONLY,
                        NULL,
                        & psaNames);
            if (hResult == WBEM_NO_ERROR) {
                hResult = SafeArrayGetLBound(psaNames, 1, & lLower);
                if (hResult == S_OK) {
                    hResult = SafeArrayGetUBound(psaNames, 1, & lUpper);
                }
                if (hResult == S_OK) {
                    for (lCount = lLower; lCount <= lUpper; lCount++) {
                        hResult = SafeArrayGetElement(
                                    psaNames,
                                    & lCount,
                                    & bsPropName);
                        if (hResult == S_OK) {
                            hResult = pThisObject->GetPropertyQualifierSet(
                                        bsPropName,
                                        & pQualSet);
                            if (hResult == S_OK) {
                                hResult = pQualSet->Get(
                                        cszCountertype,
                                        0,
                                        & vCountertype,
                                        NULL);
                                if (hResult == S_OK) {
                                    lCounterType = V_I4(& vCountertype);
                                    if (   ! (lCounterType & PERF_DISPLAY_NOSHOW)
                                        || (lCounterType == PERF_AVERAGE_BULK)) {
                                        hResult = pQualSet->Get(
                                                cszDisplayname,
                                                0,
                                                & vName,
                                                NULL);
                                        if (   hResult == S_OK
                                            && vName.vt == VT_BSTR) {
                                            if (lstrcmpiW(szCounterName,
                                                          V_BSTR(& vName)) == 0) {
                                                hResult = pQualSet->Get(
                                                        cszExplainText,
                                                        0,
                                                        & vsExplain,
                                                        NULL);
                                                if (   hResult == S_OK
                                                    && vsExplain.vt == VT_BSTR) {
                                                    LPWSTR szResult = V_BSTR(& vsExplain);
                                                    if (((DWORD) lstrlenW(szResult)) < (* pdwExplain)) {
                                                        lstrcpyW(szExplain, szResult);
                                                        Status = ERROR_SUCCESS;
                                                    }
                                                    else {
                                                        * pdwExplain = (DWORD) lstrlenW(szResult);
                                                        Status       = PDH_MORE_DATA;
                                                    }
                                                }
                                                pQualSet->Release();
                                                break;
                                            }
                                        }
                                    }
                                }
                                pQualSet->Release();
                            }
                        }
                        else {
                            SetLastError(hResult);
                            Status = PDH_WBEM_ERROR;
                        }
                    }
                }
                else {
                    SetLastError(hResult);
                    Status = PDH_WBEM_ERROR;
                }
            }
            else {
                SetLastError(hResult);
                Status = PDH_WBEM_ERROR;
            }
            VariantClear(& vName);
            VariantClear(& vCountertype);
        }
        else {
            // get counter object explain text
            //
            pThisObject->GetQualifierSet(& pQualSet);
            if (pQualSet != NULL) {
                hResult = pQualSet->Get(cszExplainText, 0, & vsExplain, 0);
                if (hResult == S_OK) {
                    LPWSTR szResult = V_BSTR(& vsExplain);
                    if (((DWORD) lstrlenW(szResult)) < (* pdwExplain)) {
                        lstrcpyW(szExplain, szResult);
                        Status = ERROR_SUCCESS;
                    }
                    else {
                        * pdwExplain = (DWORD) lstrlenW(szResult);
                        Status       = PDH_MORE_DATA;
                    }
                }
                else {
                    SetLastError(hResult);
                    Status = PDH_WBEM_ERROR;
                }
                pQualSet->Release();
            }
            else {
                SetLastError(WBEM_E_NOT_FOUND);
                Status = PDH_WBEM_ERROR;
            }
        }
        //pThisObject->Release();
        VariantClear(& vsExplain);
    }

    if (bDisconnect) {
        if (Status == ERROR_SUCCESS) {
            Status = PdhiDisconnectWbemServer(pThisServer);
        }
        else {
            PdhiDisconnectWbemServer(pThisServer);
        }
    }

    if ( fCoInitialized )
    {
        PdhiCoUninitialize();
    }
    return Status;
}

PDH_FUNCTION
PdhiEnumWbemMachines (
    IN      LPVOID      pMachineList,
    IN      LPDWORD     pcchBufferSize,
    IN      BOOL        bUnicode
)
{
    PDH_STATUS  pdhStatus;
    PPDHI_WBEM_SERVER_DEF pThisServer = NULL;
    DWORD   dwCharsLeftInBuffer = *pcchBufferSize;
    DWORD   dwBufferSize = 0;
    DWORD   dwStrLen;
    DWORD   dwResult;

    assert (pcchBufferSize != NULL);

    // CoInitialize() if we need to
    BOOL    fCoInitialized = PdhiCoInitialize();

    // test to see if we've connected to the local machine yet, if not then do it
    if (pFirstWbemServer == NULL) {
        // add local machine
        pdhStatus = PdhiAddWbemServer (
            NULL,
            &pThisServer);
    }

    // walk down list of known machines and find the machines that are using
    // the specified name space.

    pThisServer = pFirstWbemServer;
    while (pThisServer != NULL) {
        dwStrLen = lstrlenW (pThisServer->szMachine) + 1;
        if ((pMachineList != NULL) && (dwCharsLeftInBuffer > dwStrLen)) {
            // then it will fit so add it
            dwResult = AddUniqueWideStringToMultiSz (
                pMachineList, pThisServer->szMachine, bUnicode);
            if (dwResult > 0) {
                dwBufferSize = dwResult;
                dwCharsLeftInBuffer = *pcchBufferSize - dwBufferSize;
            } // else
            // this string is already in the list so
            // nothing was added
        } else {
            // just add the string length to estimate the buffer size
            // required
            dwCharsLeftInBuffer = 0; // to prevent any other strings from being added
            dwBufferSize += dwStrLen;
        }
        pThisServer = pThisServer->pNext;
    }// end of while loop

    if (dwBufferSize <= *pcchBufferSize) {
        // the buffer size includes both term nulls
        pdhStatus = ERROR_SUCCESS;
    } else {
        // add terminating MSZ Null char size
        dwBufferSize++;
        // there wasn't enough room. See if a buffer was passed in
        pdhStatus = PDH_MORE_DATA;
    }
    // return the size used or required
    *pcchBufferSize = dwBufferSize;

    // CoUninitialize if necessary
    if ( fCoInitialized )
    {
        PdhiCoUninitialize();
    }

    return pdhStatus;
}

#pragma warning ( disable : 4127 )
PDH_FUNCTION
PdhiEnumWbemServerObjects(
    IN  PPDHI_WBEM_SERVER_DEF   pThisServer,
    IN  LPVOID                  mszObjectList,
    IN  LPDWORD                 pcchBufferSize,
    IN  DWORD                   dwDetailLevel,
    IN  BOOL                    bRefresh,       // ignored
    IN  BOOL                    bUnicode)
{
    // this function enumerates the classes that are subclassed
    // from the Win32_PerfRawData Superclass
    PDH_STATUS              pdhStatus = ERROR_SUCCESS;
    HRESULT                 hResult;
    DWORD                   dwCharsLeftInBuffer = *pcchBufferSize;
    DWORD                   dwBufferSize = 0;
    DWORD                   dwStrLen;
    DWORD                   dwRtnCount;
    DWORD                   dwResult;
    DWORD                   dwDetailLevelDesired;
    DWORD                   dwItemDetailLevel = 0;
    LPWSTR                  szClassName;
    VARIANT                 vName;
    VARIANT                 vClass;
    VARIANT                 vDetailLevel;
    BOOL                    bPerfDefault = FALSE;
    BSTR                    bsTemp = NULL;
    BSTR                    bsDisplayName = NULL;
    BSTR                    bsClass = NULL;
    BSTR                    bsCostly = NULL;
    BSTR                    bsDetailLevel = NULL;
    BSTR                    bsPerfDefault = NULL;

    BOOL                    bGetCostlyItems = FALSE;
    BOOL                    bIsCostlyItem = FALSE;
    BOOL                    bDisconnectServer = FALSE;

    IEnumWbemClassObject  * pEnum = NULL;
    IWbemClassObject      * pThisClass = NULL;
    IWbemQualifierSet     * pQualSet = NULL;

    PPDHI_WBEM_OBJECT_DEF   pHead   = NULL;
    PPDHI_WBEM_OBJECT_DEF   pObject = NULL;

    DBG_UNREFERENCED_PARAMETER(bRefresh);

    VariantInit(& vName);
    VariantInit(& vClass);
    VariantInit(& vDetailLevel);

    if (pThisServer->pObjList != NULL) {
        PPDHI_WBEM_OBJECT_DEF pObject = pThisServer->pObjList;
        PPDHI_WBEM_OBJECT_DEF pNext;

        pThisServer->pObjList = NULL;
        while (pObject != NULL) {
            pNext = pObject->pNext;
            if (pObject->pClass != NULL) pObject->pClass->Release();
            G_FREE(pObject);
            pObject = pNext;
        }
    }

    // create an enumerator of the PerfRawData class
    bsTemp = SysAllocString (cszPerfRawData);
    if (bsTemp) {
        hResult = pThisServer->pSvc->CreateClassEnum (
                bsTemp,
                WBEM_FLAG_DEEP | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                NULL,
                & pEnum);
        PdhiSysFreeString(&bsTemp);

        bDisconnectServer = TRUE;
        // Set security on the proxy
        if (SUCCEEDED(hResult))
        {
            hResult = SetWbemSecurity(pEnum);
        }

        if (hResult != WBEM_NO_ERROR) {
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }
    } else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // set costly flag
        bGetCostlyItems = ((dwDetailLevel & PERF_DETAIL_COSTLY) == PERF_DETAIL_COSTLY);
        dwDetailLevelDesired = (DWORD)(dwDetailLevel & PERF_DETAIL_STANDARD);
        bsCostly = SysAllocString (cszCostly);
        bsDisplayName = SysAllocString (cszDisplayname);
        bsClass = SysAllocString (cszClass);
        bsDetailLevel = SysAllocString (cszPerfdetail);
        bsPerfDefault = SysAllocString(cszPerfdefault);

        if (bsCostly && bsDisplayName && bsClass && bsDetailLevel) {
            while (TRUE) {
                hResult = pEnum->Next (
                    WBEM_INFINITE,      // timeout
                    1,      // return only 1 object
                    &pThisClass,
                    &dwRtnCount);

                // no more classes
                if ((pThisClass == NULL) || (dwRtnCount == 0)) break;

                // get the display name of this class
                bIsCostlyItem = FALSE; // assume it's not unless proven otherwise
                bPerfDefault  = FALSE;
                hResult = pThisClass->Get(bsClass, 0, & vClass, 0, 0);

                pThisClass->GetQualifierSet (&pQualSet);
                if (pQualSet != NULL) {
                    VariantClear (&vName);
                    hResult = pQualSet->Get (bsCostly, 0, &vName, 0);
                    if (hResult == S_OK) {
                        bIsCostlyItem = TRUE;
                    }
                    hResult = pQualSet->Get (bsDetailLevel, 0, &vDetailLevel, 0);
                    if (hResult == S_OK) {
                        dwItemDetailLevel = (DWORD)V_I4(&vDetailLevel);
                    } else {
                        dwItemDetailLevel = 0;
                    }

                    VariantClear(&vName);
                    hResult = pQualSet->Get(bsPerfDefault, 0, & vName, 0);
                    if (hResult != WBEM_E_NOT_FOUND) {
                        bPerfDefault = (BOOL) V_BOOL(& vName);
                    }

                    VariantClear(&vName);
                    hResult = pQualSet->Get(bsDisplayName, 0, & vName, 0);
                    pQualSet->Release();
                } else {
                    hResult = WBEM_E_NOT_FOUND;
                }

                if (hResult == WBEM_E_NOT_FOUND) {
                    // then this has not display name so
                    // pull the class name
                    hResult = pThisClass->Get(bsClass, 0, & vName, 0, 0);
                }

                if (hResult == WBEM_E_NOT_FOUND) {
                    szClassName = (LPWSTR) cszNotFound;
                } else {
                    szClassName = (LPWSTR) V_BSTR(&vName);
                }

                if (((bIsCostlyItem && bGetCostlyItems) || // if costly and we want them
                    (!bIsCostlyItem)) && (dwItemDetailLevel <= dwDetailLevelDesired)) {
                    dwStrLen = lstrlenW (szClassName) + 1;
                    if ((mszObjectList != NULL) && (dwCharsLeftInBuffer > dwStrLen)) {
                        // then it will fit so add it
                        dwResult = AddUniqueWideStringToMultiSz (
                            mszObjectList, szClassName, bUnicode);
                        if (dwResult > 0) {
                            dwBufferSize = dwResult;
                            dwCharsLeftInBuffer = *pcchBufferSize - dwBufferSize;
                        } // else
                    } else {
                        // just add the string length to estimate the buffer size
                        // required
                        dwCharsLeftInBuffer = 0; // to prevent any other strings from being added
                        dwBufferSize += dwStrLen;
                    }
                }

                if (lstrcmpiW(szClassName, cszNotFound) != 0) {
                    LPWSTR szClass = (LPWSTR) V_BSTR(& vClass);
                    DWORD dwSize   = sizeof(PDHI_WBEM_OBJECT_DEF)
                                   + sizeof(WCHAR) * (  lstrlenW(szClassName)
                                                      + lstrlenW(szClass) + 2);
                    pObject = (PPDHI_WBEM_OBJECT_DEF) G_ALLOC(dwSize);
                    if (pObject != NULL) {
                        pObject->bDefault  = bPerfDefault;
                        pObject->szObject  = (LPWSTR) (((LPBYTE) pObject)
                                           + sizeof(PDHI_WBEM_OBJECT_DEF));
                        lstrcpyW(pObject->szObject, szClass);
                        pObject->szDisplay = (LPWSTR) (((LPBYTE) pObject)
                                           + sizeof(PDHI_WBEM_OBJECT_DEF)
                                           + sizeof(WCHAR) * (lstrlenW(szClass) + 1));
                        lstrcpyW(pObject->szDisplay, szClassName);
                        pObject->pNext = pHead;
                        pHead          = pObject;
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        pThisClass->Release();
                        break;
                    }
                }

                // clear the variant
                VariantClear(& vName);
                VariantClear(& vClass);
                VariantClear(& vDetailLevel);

                // free this class
                pThisClass->Release();
            }
            dwBufferSize ++; // the final NULL

            if (dwBufferSize <= *pcchBufferSize) {
                pdhStatus = ERROR_SUCCESS;
            } else {
                // there wasn't enough room. See if a buffer was passed in
                pdhStatus = PDH_MORE_DATA;
            }
            // return the size used or required
            *pcchBufferSize = dwBufferSize;
        }
    } else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    PdhiSysFreeString(& bsDisplayName);
    PdhiSysFreeString(& bsClass);
    PdhiSysFreeString(& bsCostly);
    PdhiSysFreeString(& bsDetailLevel);
    PdhiSysFreeString(& bsPerfDefault);

    VariantClear(& vName);
    VariantClear(& vClass);
    VariantClear(& vDetailLevel);

    if (pEnum != NULL) pEnum->Release();

    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        pThisServer->pObjList = pHead;
    }
    else {
        pObject = pHead;
        while (pObject != NULL) {
            pHead   = pObject->pNext;
            G_FREE(pObject);
            pObject = pHead;
        }
    }

    if (bDisconnectServer) {
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiDisconnectWbemServer (pThisServer);
        } else {
            // keep error code from function body
            PdhiDisconnectWbemServer (pThisServer);
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumWbemObjects(
    IN  LPCWSTR     szWideMachineName,
    IN  LPVOID      mszObjectList,
    IN  LPDWORD     pcchBufferSize,
    IN  DWORD       dwDetailLevel,
    IN  BOOL        bRefresh,       // ignored
    IN  BOOL        bUnicode)
{
    PDH_STATUS             pdhStatus;
    PPDHI_WBEM_SERVER_DEF  pThisServer;
    BOOL                   fCoInitialized = PdhiCoInitialize();

    pdhStatus = PdhiConnectWbemServer(szWideMachineName, & pThisServer);
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiEnumWbemServerObjects(pThisServer,
                                              mszObjectList,
                                              pcchBufferSize,
                                              dwDetailLevel,
                                              bRefresh,
                                              bUnicode);
    }

    if (fCoInitialized) {
        PdhiCoUninitialize();
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiGetDefaultWbemObject (
    IN  LPCWSTR     szMachineName,
    IN  LPVOID      szDefaultObjectName,
    IN  LPDWORD     pcchBufferSize,
    IN  BOOL        bUnicode)
{
    // walk down the list of WBEM perf classes and find the one with the
    // default qualifier

    PDH_STATUS              pdhStatus;
    PPDHI_WBEM_SERVER_DEF   pThisServer;
    HRESULT                 hResult;
    DWORD                   dwBufferSize = 0;
    DWORD                   dwStrLen;
    BOOL                    bDisconnectServer = FALSE;

    // CoInitialize() if we need to
    BOOL fCoInitialized = PdhiCoInitialize();

    pdhStatus = PdhiConnectWbemServer (
        szMachineName,
        &pThisServer);

    if (pdhStatus == ERROR_SUCCESS) {
        bDisconnectServer = TRUE;
        if (pThisServer->pObjList == NULL) {
            DWORD dwSize = 0;
            pdhStatus = PdhiEnumWbemServerObjects(
                            pThisServer,
                            NULL,
                            & dwSize,
                            PERF_DETAIL_WIZARD | PERF_DETAIL_COSTLY,
                            TRUE,
                            TRUE);
            if (pThisServer->pObjList != NULL) {
                pdhStatus = ERROR_SUCCESS;
            }
        }

        if (pThisServer->pObjList != NULL) {
            PPDHI_WBEM_OBJECT_DEF pObject = pThisServer->pObjList;

            pdhStatus = PDH_CSTATUS_NO_OBJECT;
            while (pObject != NULL) {
                if (pObject->bDefault) {
                    pdhStatus = ERROR_SUCCESS;
                    if (bUnicode) {
                        dwStrLen = lstrlenW(pObject->szDisplay);
                        if (   szDefaultObjectName != NULL
                            && dwStrLen < * pcchBufferSize) {
                            lstrcpyW((LPWSTR) szDefaultObjectName,
                                     pObject->szDisplay);
                        }
                        else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                        dwBufferSize = dwStrLen + 1;
                    }
                    else {
                        dwStrLen = * pcchBufferSize;
                        pdhStatus = PdhiConvertUnicodeToAnsi( _getmbcp(),
                                        pObject->szDisplay,
                                        (LPSTR) szDefaultObjectName,
                                        & dwStrLen);
                        dwBufferSize = dwStrLen;
                    }
                }
                pObject = pObject->pNext;
            }
        }
    }

    // return the size used or required
    * pcchBufferSize = dwBufferSize;

    if (bDisconnectServer) {
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiDisconnectWbemServer (pThisServer);
        } else {
            // keep error code from function body
            PdhiDisconnectWbemServer (pThisServer);
        }
    }

    // CoUninitialize if necessary
    if ( fCoInitialized )
    {
        PdhiCoUninitialize();
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumWbemObjectItems (
    IN LPCWSTR      szWideMachineName,
    IN LPCWSTR      szWideObjectName,
    IN LPVOID       mszCounterList,
    IN LPDWORD      pcchCounterListLength,
    IN LPVOID       mszInstanceList,
    IN LPDWORD      pcchInstanceListLength,
    IN DWORD        dwDetailLevel,
    IN DWORD        dwFlags,
    IN BOOL         bUnicode
)
{
    PDH_STATUS          pdhStatus      = ERROR_SUCCESS;
    PDH_STATUS          CounterStatus  = ERROR_SUCCESS;
    PDH_STATUS          InstanceStatus = ERROR_SUCCESS;
    DWORD               dwStrLen;
    PPDHI_WBEM_SERVER_DEF   pThisServer;
    HRESULT                 hResult;
    DWORD               dwReturnCount;
    DWORD               dwCounterStringLen = 0;
    DWORD               dwInstanceStringLen = 0;
    LPWSTR              szNextWideString = NULL;
    LPSTR               szNextAnsiString = NULL;
    WCHAR               szObjectClassName[MAX_PATH];
    BSTR                bsName = NULL;
    BSTR                bsClassName = NULL;
    BOOL                bSingletonClass = FALSE;
    VARIANT             vName;
    DWORD               bDisconnectServer = FALSE;

    IWbemClassObject        *pThisClass = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    DBG_UNREFERENCED_PARAMETER (dwFlags);

    assert (szWideObjectName != NULL);
    assert (pcchCounterListLength != NULL);
    assert (pcchInstanceListLength != NULL);

    // CoInitialize() if we need to
    BOOL    fCoInitialized = PdhiCoInitialize();

    pdhStatus = PdhiConnectWbemServer (
        szWideMachineName,
        &pThisServer);

    // enumerate the instances
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiWbemGetObjectClassName (
            pThisServer,
            szWideObjectName,
            &szObjectClassName[0],
            sizeof(szObjectClassName) / sizeof(szObjectClassName[0]),
            &pThisClass);

        assert (pThisClass != NULL);

        bDisconnectServer = TRUE;

        if (pdhStatus == ERROR_SUCCESS) {
            bSingletonClass = PdhiIsSingletonClass (pThisClass);
        } else if (pThisClass == NULL) {
            pdhStatus = PDH_CSTATUS_NO_OBJECT;
        } else {
            // unable to find matching perf class
            // return status returned by method
        }
    }

    //enumerate the counter properties

    if (pdhStatus == ERROR_SUCCESS) {
        SAFEARRAY   *psaNames = NULL;
        long        lLower; 
        long        lUpper = 0;
        long        lCount;
        BSTR        bsPropName = NULL;
        BSTR        bsCountertype = NULL;
        BSTR        bsDisplayname = NULL;
        BSTR        bsDetailLevel = NULL;
        VARIANT     vCountertype;
        VARIANT     vDetailLevel;
        DWORD       dwItemDetailLevel;

        VariantInit (&vName);
        VariantInit (&vCountertype);
        VariantInit (&vDetailLevel);

        assert (pThisClass != NULL);

        dwDetailLevel &= PERF_DETAIL_STANDARD; // mask off any inappropriate bits

        // get the properties of this class as a Safe Array
        hResult = pThisClass->GetNames (NULL,
            WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
        if (hResult == WBEM_NO_ERROR) {
            hResult = SafeArrayGetLBound (psaNames, 1, &lLower);
            if (hResult == S_OK) {
                hResult = SafeArrayGetUBound (psaNames, 1, &lUpper);
            }
            if (hResult == S_OK) {
                szNextAnsiString = (LPSTR)mszCounterList;
                szNextWideString = (LPWSTR)mszCounterList;
                bsCountertype = SysAllocString (cszCountertype);
                bsDisplayname = SysAllocString (cszDisplayname);
                bsDetailLevel = SysAllocString (cszPerfdetail);
                if (bsCountertype && bsDisplayname && bsDetailLevel) {
                    for (lCount = lLower; lCount <= lUpper; lCount++) {
                        hResult = SafeArrayGetElement (psaNames, &lCount, &bsPropName);
                        if (hResult == S_OK) {
                            // get the qualifier set for this property
                            hResult = pThisClass->GetPropertyQualifierSet (
                                bsPropName, &pQualSet);
                            if (hResult == WBEM_NO_ERROR) {
                                LONG    lCounterType;
                                hResult = pQualSet->Get (bsDetailLevel, 0, &vDetailLevel, 0);
                                if (hResult == S_OK) {
                                    dwItemDetailLevel = (DWORD)V_I4(&vDetailLevel);
                                } else {
                                    dwItemDetailLevel = 0;
                                }

                                // make sure this is a perf counter property
                                hResult = pQualSet->Get (bsCountertype, 0, &vCountertype, NULL);
                                if (hResult == WBEM_NO_ERROR) {
                                    lCounterType = V_I4(&vCountertype);
                                    // then see if this is a displayable counter
                                    if ((!(lCounterType & PERF_DISPLAY_NOSHOW) ||
                                         (lCounterType == PERF_AVERAGE_BULK)) &&
                                        (dwItemDetailLevel <= dwDetailLevel)) {
                                        // by testing for the counter type
                                        // get the display name for this property
                                        hResult = pQualSet->Get (bsDisplayname, 0, &vName, NULL);
                                        if (hResult == WBEM_NO_ERROR && vName.vt == VT_BSTR) {
                                            // display name found
                                            if (bUnicode) {
                                                dwStrLen = lstrlenW (V_BSTR(&vName)) + 1;
                                                if (   (mszCounterList != NULL)
                                                    && (   (dwCounterStringLen + dwStrLen)
                                                        <= (* pcchCounterListLength))) {
                                                    lstrcpyW (szNextWideString, V_BSTR(&vName));
                                                    szNextWideString += dwStrLen;
                                                }
                                                else {
                                                    pdhStatus = PDH_MORE_DATA;
                                                }
                                            } else {
                                                dwStrLen = (dwCounterStringLen < * pcchCounterListLength)
                                                         ? (* pcchCounterListLength - dwCounterStringLen)
                                                         : (0);
                                                 pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                         V_BSTR(& vName), szNextAnsiString, & dwStrLen);
                                                 if (pdhStatus == ERROR_SUCCESS) {
                                                    szNextAnsiString += dwStrLen;
                                                 }
                                            }
                                            dwCounterStringLen += dwStrLen;
                                        }
                                    } else {
                                        // this is a "don't show" counter so skip it
                                    }
                                } else {
                                    // unable to get the counter type so it's probably
                                    // not a perf counter property, skip it and continue
                                }
                                VariantClear (&vName);
                                VariantClear (&vCountertype);
                                VariantClear (&vDetailLevel);

                                pQualSet->Release();
                            } else {
                                // no properties so continue with the next one
                            }
                        } else {
                            // unable to read element in SafeArray
                            pdhStatus = PDH_WBEM_ERROR;
                            SetLastError(hResult);
                        }
                    } // end for each element in SafeArray
                } else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                PdhiSysFreeString (&bsCountertype);
                PdhiSysFreeString (&bsDisplayname);
                PdhiSysFreeString (&bsDetailLevel);
            } else {
                // unable to get array boundries
                pdhStatus = PDH_WBEM_ERROR;
                SetLastError (hResult);
            }
        } else {
            // unable to get property strings
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }

        dwCounterStringLen ++; // final NULL for MSZ
        if (dwCounterStringLen > * pcchCounterListLength) {
            pdhStatus = PDH_MORE_DATA;
        }

        if (pdhStatus == ERROR_SUCCESS) {
            if (bUnicode) {
                if (szNextWideString != NULL) {
                    if (szNextWideString != (LPWSTR)mszCounterList) {
                        *szNextWideString++ = 0;
                    } else {
                        // nothing returned
                        dwCounterStringLen = 0;
                    }
                } else {
                    // then this is just a length query so return
                    // include the the MSZ term null char
                    CounterStatus = PDH_MORE_DATA;
                }
            } else {
                if (szNextAnsiString != NULL) {
                    if (szNextAnsiString != (LPSTR)mszCounterList) {
                        *szNextAnsiString ++ = 0;
                    } else {
                        dwCounterStringLen = 0;
                    }
                } else {
                    // then this is just a length query so return
                    // include the the MSZ term null char
                    CounterStatus = PDH_MORE_DATA;
                }
            }
        }
        else {
            CounterStatus = pdhStatus;
        }

        VariantClear (&vName);
        VariantClear (&vCountertype);
        VariantClear (&vDetailLevel);

                // Clear the SafeArray if it exists
        if ( NULL != psaNames )
        {
            SafeArrayDestroy( psaNames );
            psaNames = NULL;
        }

        *pcchCounterListLength = dwCounterStringLen;

        //pThisClass->Release();
    }

    // Get instance strings if necessary

    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        szNextAnsiString = (LPSTR)  mszInstanceList;
        szNextWideString = (LPWSTR) mszInstanceList;

        if (!bSingletonClass) {
            IWbemRefresher           * pRefresher    = NULL;
            IWbemConfigureRefresher  * pConfig       = NULL;
            IWbemHiPerfEnum          * pEnum         = NULL;
            LONG                       lID;
            DWORD                      dwNumReturned = 1;
            DWORD                      dwNumObjects  = 0;
            DWORD                      i;
            IWbemObjectAccess       ** apEnumAccess  = NULL;
            CIMTYPE                    cimType;
            WCHAR                      szName[SMALL_BUFFER_SIZE];
            LONG                       lNameHandle   = -1;
            LONG                       lSize1        = SMALL_BUFFER_SIZE;
            LONG                       lSize2        = 0;

            hResult = CoCreateInstance(CLSID_WbemRefresher,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IWbemRefresher,
                                       (void **) & pRefresher);
            if (SUCCEEDED(hResult)) {
                hResult = pRefresher->QueryInterface(
                                IID_IWbemConfigureRefresher,
                                (void **) & pConfig);
                if (SUCCEEDED(hResult)) {
                    hResult = pConfig->AddEnum(pThisServer->pSvc,
                                               szObjectClassName,
                                               0,
                                               NULL,
                                               & pEnum,
                                               & lID);
                    if (SUCCEEDED(hResult)) {
                        hResult = pRefresher->Refresh(0L);
                        if (SUCCEEDED(hResult)) {
                            hResult = pEnum->GetObjects(0L,
                                                        dwNumObjects,
                                                        apEnumAccess,
                                                        & dwNumReturned);
                            if (hResult == WBEM_E_BUFFER_TOO_SMALL) {
                                apEnumAccess = (IWbemObjectAccess **)
                                        G_ALLOC(dwNumReturned
                                                * sizeof(IWbemObjectAccess *));
                                if (apEnumAccess != NULL) {
                                    ZeroMemory(apEnumAccess, dwNumReturned
                                             * sizeof(IWbemObjectAccess *));
                                    dwNumObjects = dwNumReturned;
                                    hResult = pEnum->GetObjects(0L,
                                                            dwNumObjects,
                                                            apEnumAccess,
                                                            & dwNumReturned);
                                }
                                else {
                                    hResult = WBEM_E_OUT_OF_MEMORY;
                                }
                            }
                            if (SUCCEEDED(hResult)) {
                                for (i = 0; i < dwNumReturned; i ++) {
                                    hResult = apEnumAccess[i]->GetPropertyHandle(
                                                    cszName,
                                                    & cimType,
                                                    & lNameHandle);
                                    if (SUCCEEDED(hResult) && lNameHandle != -1) {
                                        ZeroMemory(szName,
                                                   SMALL_BUFFER_SIZE * sizeof(WCHAR));
                                        hResult = apEnumAccess[i]->ReadPropertyValue(
                                                lNameHandle,
                                                lSize1,
                                                & lSize2,
                                                (LPBYTE) szName);
                                        if (SUCCEEDED(hResult) && lstrlenW(szName) > 0) {
                                            if (bUnicode) {
                                                dwStrLen = lstrlenW(szName) + 1;
                                                if (   (mszInstanceList != NULL)
                                                    && (   (dwInstanceStringLen + dwStrLen)
                                                         < (* pcchInstanceListLength))) {
                                                    lstrcpyW (szNextWideString, szName);
                                                    szNextWideString += dwStrLen;
                                                }
                                                else {
                                                    pdhStatus = PDH_MORE_DATA;
                                                }
                                            }
                                            else {
                                                dwStrLen = (dwInstanceStringLen <= * pcchInstanceListLength)
                                                         ? (* pcchInstanceListLength - dwInstanceStringLen)
                                                         : (0);
                                                pdhStatus = PdhiConvertUnicodeToAnsi(
                                                        _getmbcp(),
                                                        szName,
                                                        szNextAnsiString,
                                                        & dwStrLen);
                                                if (pdhStatus == ERROR_SUCCESS) {
                                                    szNextAnsiString += dwStrLen;
                                                }
                                            }
                                            dwInstanceStringLen += dwStrLen;
                                        }
                                    }
                                    apEnumAccess[i]->Release();
                                }
                            }
                        }
                    }
                }
            }

            if (! SUCCEEDED(hResult)) {
                SetLastError(hResult);
                pdhStatus = PDH_WBEM_ERROR;
            }
            else if (dwInstanceStringLen == 0) {
                dwInstanceStringLen = 2;
                if (   szNextWideString != NULL
                    && dwInstanceStringLen <= * pcchInstanceListLength) {
                    * szNextWideString = L'\0';
                    szNextWideString ++;
                }
                if (   szNextAnsiString != NULL
                    && dwInstanceStringLen <= * pcchInstanceListLength) {
                    * szNextAnsiString = '\0';
                    szNextAnsiString ++;
                }
            }
            else {
                dwInstanceStringLen ++;
            }

            if (apEnumAccess != NULL) G_FREE(apEnumAccess);
            if (pEnum        != NULL) pEnum->Release();
            if (pConfig      != NULL) pConfig->Release();
            if (pRefresher   != NULL) pRefresher->Release();
        }

        if (dwInstanceStringLen > * pcchInstanceListLength) {
            pdhStatus = PDH_MORE_DATA;
        }
        if (pdhStatus == ERROR_SUCCESS) {
            if (bUnicode) {
                if (szNextWideString != NULL) {
                    if (szNextWideString != (LPWSTR)mszInstanceList) {
                        *szNextWideString++ = 0;
                    } else {
                        dwInstanceStringLen = 0;
                    }
                } else if (dwInstanceStringLen > 0) {
                    // then this is just a length query so return
                    // include the the MSZ term null char
                    InstanceStatus = PDH_MORE_DATA;
                }
            } else {
                if (szNextAnsiString != NULL) {
                    if (szNextAnsiString != (LPSTR)mszInstanceList) {
                        *szNextAnsiString++ = 0;
                    } else {
                        dwInstanceStringLen = 0;
                    }
                } else if (dwInstanceStringLen > 0) {
                    // then this is just a length query so return
                    // include the the MSZ term null char
                    InstanceStatus = PDH_MORE_DATA;
                }
            }
        }
        else {
            InstanceStatus = pdhStatus;
        }
        *pcchInstanceListLength = dwInstanceStringLen;
    }

    VariantClear (&vName);

    if (bDisconnectServer) {
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiDisconnectWbemServer (pThisServer);
        } else {
            // keep error code from function body
            PdhiDisconnectWbemServer (pThisServer);
        }
    }

    // CoUninitialize if necessary
    if ( fCoInitialized )
    {
        PdhiCoUninitialize();
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = (CounterStatus == ERROR_SUCCESS)
                  ? (InstanceStatus) : (CounterStatus);
    }

    return pdhStatus;
}
#pragma warning ( default : 4127 )

PDH_FUNCTION
PdhiGetDefaultWbemProperty (
    IN LPCWSTR      szMachineName,
    IN LPCWSTR      szObjectName,
    IN LPVOID       szDefaultCounterName,
    IN LPDWORD      pcchBufferSize,
    IN BOOL         bUnicode
)
{
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    DWORD               dwStrLen;
    PPDHI_WBEM_SERVER_DEF   pThisServer;
    HRESULT                 hResult;
    DWORD               dwCounterStringLen = 0;
    WCHAR               szObjectClassName[MAX_PATH];
    DWORD               bDisconnectServer = FALSE;
    BOOL                bFound = FALSE;

    IWbemClassObject        *pThisClass = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    assert (szMachineName != NULL);
    assert (szObjectName != NULL);
    assert (pcchBufferSize != NULL);

    // CoInitialize() if we need to
    BOOL    fCoInitialized = PdhiCoInitialize();

    pdhStatus = PdhiConnectWbemServer (
        szMachineName,
        &pThisServer);

    // enumerate the instances
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiWbemGetObjectClassName (
            pThisServer,
            szObjectName,
            &szObjectClassName[0],
            sizeof(szObjectClassName) / sizeof(szObjectClassName[0]),
            &pThisClass);
        bDisconnectServer = TRUE;
    }

    //enumerate the counter properties

    if (pdhStatus == ERROR_SUCCESS) {
        SAFEARRAY   *psaNames = NULL;
        long        lLower; 
        long        lUpper = 0;
        long        lCount;
        BSTR        bsPropName = NULL;
        BSTR        bsDisplayname = NULL;
        BSTR        bsPerfDefault = NULL;
        VARIANT     vName, vCountertype;

        VariantInit (&vName);
        VariantInit (&vCountertype);

        // get the properties of this class as a Safe Array
        hResult = pThisClass->GetNames (NULL,
            WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
        if (hResult == WBEM_NO_ERROR) {
            hResult = SafeArrayGetLBound (psaNames, 1, &lLower);
            if (hResult == S_OK) {
                hResult = SafeArrayGetUBound (psaNames, 1, &lUpper);
            }
            if (hResult == S_OK) {
                bsDisplayname = SysAllocString (cszDisplayname);
                bsPerfDefault = SysAllocString (cszPerfdefault);
                if (bsDisplayname && bsPerfDefault) {
                    for (lCount = lLower; lCount <= lUpper; lCount++) {
                        hResult = SafeArrayGetElement (psaNames, &lCount, &bsPropName);
                        if (hResult == S_OK) {
                            // get the qualifier set for this property
                            hResult = pThisClass->GetPropertyQualifierSet (
                                bsPropName, &pQualSet);
                            if (hResult == WBEM_NO_ERROR) {
                                // make sure this is a perf counter property
                                hResult = pQualSet->Get (bsPerfDefault, 0, &vCountertype, NULL);
                                if (hResult == WBEM_NO_ERROR) {
                                    if ((BOOL)V_BOOL(&vCountertype)) {
                                        // found the default property so load it and return
                                        hResult = pQualSet->Get (bsDisplayname, 0, &vName, NULL);
                                        if (hResult == WBEM_NO_ERROR) {
                                            // display name found
                                            bFound = TRUE;
                                            if (bUnicode) {
                                                dwStrLen = lstrlenW (V_BSTR(&vName)) + 1;
                                                if (   (szDefaultCounterName != NULL)
                                                    && (dwStrLen <= * pcchBufferSize)) {
                                                    lstrcpyW ((LPWSTR)szDefaultCounterName,
                                                              (LPWSTR)V_BSTR(&vName));
                                                }
                                                else {
                                                    pdhStatus = PDH_MORE_DATA;
                                                }
                                            }
                                            else {
                                                dwStrLen = * pcchBufferSize;
                                                pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                        (LPWSTR) V_BSTR(& vName),
                                                        (LPSTR)  szDefaultCounterName,
                                                        & dwStrLen);
                                            }
                                            // this is either the amount used or the amount needed
                                            dwCounterStringLen = dwStrLen;
                                            // free qualifier set
                                            pQualSet->Release();
                                            // now leave
                                            break;
                                        } else {
                                            // no qualifier so assume FALSE
                                        }
                                    } else {
                                        // value found but is FALSE
                                    }
                                }
                                // free the qualifier set
                                pQualSet->Release();
                                // clear variants
                                VariantClear (&vName);
                                VariantClear (&vCountertype);
                            } else {
                                // no Qualifiers so continue with the next one
                            }
                        } else {
                            // unable to read element in SafeArray
                            pdhStatus = PDH_WBEM_ERROR;
                            SetLastError(hResult);
                        }
                    } // end for each element in SafeArray
                } else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                // no default defined for this object
                if ((pdhStatus == ERROR_SUCCESS) && !bFound) pdhStatus = PDH_CSTATUS_NO_COUNTER;

                PdhiSysFreeString (&bsPerfDefault);
                PdhiSysFreeString (&bsDisplayname);
            } else {
                // unable to get array boundries
                pdhStatus = PDH_WBEM_ERROR;
                SetLastError (hResult);
            }
        } else {
            // unable to get property strings
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }

        if ( NULL != psaNames )
        {
            SafeArrayDestroy( psaNames );
        }

        VariantClear (&vName);
        VariantClear (&vCountertype);

        //pThisClass->Release();
    }
    *pcchBufferSize = dwCounterStringLen;

    if (bDisconnectServer) {
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiDisconnectWbemServer (pThisServer);
        } else {
            // keep error code from function body
            PdhiDisconnectWbemServer (pThisServer);
        }
    }

    // CoUninitialize if necessary
    if ( fCoInitialized )
    {
        PdhiCoUninitialize();
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiEncodeWbemPathW (
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPWSTR                      szFullPathBuffer,
    IN      LPDWORD                     pcchBufferSize,
    IN      LANGID                      LangId,
    IN      DWORD                       dwFlags
)
/*++

  converts a set of path elements in either Registry or WBEM format
  to a path in either Registry or WBEM format as defined by the flags.

--*/
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwBuffSize;
    LPWSTR      szTempPath = NULL;
    DWORD       dwCurSize = 0;

    LPWSTR      szThisChar;
    IWbemClassObject        *pWbemClass = NULL;
    PPDHI_WBEM_SERVER_DEF   pWbemServer = NULL;
    DWORD                   bDisconnectServer = FALSE;

    DBG_UNREFERENCED_PARAMETER (LangId);

    assert (pCounterPathElements != NULL); // this is not allowed
    assert (dwFlags != 0); // this should be caught by the calling fn.
    assert (pcchBufferSize != NULL); // this is required

    // CoInitialize() if we need to
    BOOL    fCoInitialized = PdhiCoInitialize();

    // create a working buffer the same size as the one passed in

    if (*pcchBufferSize == 0L) {
        dwBuffSize = *pcchBufferSize * sizeof(WCHAR);
    } else {
        dwBuffSize = 1024 * sizeof(WCHAR); // just something to work with
    }

    szTempPath = (LPWSTR) G_ALLOC(dwBuffSize);

    if (szTempPath == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    } else if (pdhStatus == ERROR_SUCCESS) {
        szTempPath[0] = L'\0';
        // start by adding the machine name to the path
        if (pCounterPathElements->szMachineName != NULL) {
            lstrcpyW (szTempPath, pCounterPathElements->szMachineName);
            if (dwFlags == (PDH_PATH_WBEM_INPUT)) {
                // if this is a wbem element in to a registry path out,
                // then remove the namespace which occurs starting at the
                // second backslash
                for (szThisChar = &szTempPath[2];
                    (*szThisChar != 0) && (*szThisChar != L'\\');
                    szThisChar++);
                if (*szThisChar != 0) *szThisChar = 0;
            } else if (dwFlags == (PDH_PATH_WBEM_RESULT)) {
                // if this is a registry element in to a WBEM out, then
                // append the default namespace to the machine name
//NAMEFIX                lstrcatW (szTempPath, cszWbemDefaultPerfRoot);
            }
        } else {
            // no machine name specified so add the default machine
            // and default namespace for a wbem output path
            if (dwFlags == (PDH_PATH_WBEM_RESULT)) {
                lstrcpyW (szTempPath, cszDoubleBackSlashDot); // default machine
//NAMEFIX                lstrcatW (szTempPath, cszWbemDefaultPerfRoot);
            } else {
                // no entry required for the registry path
            }
        }
        dwCurSize = lstrlenW(szTempPath);

        // now add the object or class name
        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements->szObjectName != NULL) {
                DWORD   dwSize;
                WCHAR   szTempObjectString[1024];
    
                dwSize = 1024;
                ZeroMemory(szTempObjectString, sizeof(WCHAR) * 1024);
                // then the input is different from the output
                // so convert from one to the other
                // and default name space since perf counters won't be
                // found elsewhere
                pdhStatus = PdhiConnectWbemServer (
                    NULL, // use local machine
                    &pWbemServer);
                if (pdhStatus == ERROR_SUCCESS) {
                    bDisconnectServer = TRUE;
                    if (dwFlags & PDH_PATH_WBEM_INPUT) {
                        // convert the WBEM Class to the display name
                        pdhStatus = PdhiWbemGetClassDisplayName (
                            pWbemServer,
                            pCounterPathElements->szObjectName,
                            &szTempObjectString[0],
                            dwSize,
                            &pWbemClass);
                        // add a backslash path separator for registry output
                        if (pdhStatus == ERROR_SUCCESS) {
                            if (dwFlags & PDH_PATH_WBEM_RESULT) {
                                lstrcatW(szTempPath, cszColon);
                                // just copy the string, but save
                                lstrcpyW (szTempObjectString, pCounterPathElements->szObjectName);
                            } else {
                                lstrcatW(szTempPath, cszBackSlash);
                                // copy the retrieved string
                            }
                        }
                    } else {
                        // convert the display name to a Wbem class name
                        pdhStatus = PdhiWbemGetObjectClassName (
                            pWbemServer,
                            pCounterPathElements->szObjectName,
                            &szTempObjectString[0],
                            dwSize,
                            &pWbemClass);
                        // add a colon path separator
                        lstrcatW(szTempPath, cszColon);
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        //then add the string
                        lstrcatW(szTempPath, szTempObjectString);
                        dwCurSize += lstrlenW(szTempObjectString) + 1; // includes delimiter
                    }

                    if (bDisconnectServer) {
                        if (pdhStatus == ERROR_SUCCESS) {
                            pdhStatus = PdhiDisconnectWbemServer (pWbemServer);
                        } else {
                            // keep error code from function body
                            PdhiDisconnectWbemServer (pWbemServer);
                        }
                    }
                }
            } else {
                // no object name, so bad structure
                pdhStatus = PDH_CSTATUS_NO_OBJECT;
            }

        }

        // check for instance entries to add before adding the counter.
        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements->szInstanceName != NULL) {
                lstrcatW (szTempPath, cszLeftParen);
                dwCurSize += 1;
                if (pCounterPathElements->szParentInstance != NULL) {
                    lstrcatW (szTempPath, pCounterPathElements->szParentInstance);
                    lstrcatW (szTempPath, cszSlash);
                    dwCurSize += lstrlenW( pCounterPathElements->szParentInstance ) + 1;
                }
                lstrcatW (szTempPath, pCounterPathElements->szInstanceName);
                lstrcatW (szTempPath, cszRightParen);
                dwCurSize += lstrlenW( pCounterPathElements->szInstanceName ) + 1;
            } else {
                // this is OK
                assert (pCounterPathElements->szParentInstance == NULL);
                assert (pCounterPathElements->dwInstanceIndex == 0);
            }
        }

        // add counter name
        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements->szCounterName != NULL) {
                DWORD   dwSize;
                WCHAR   szTempCounterString[1024];

                dwSize = 1024;
                // then the input is different from the output
                // so convert from one to the other
                // and default name space since perf counters won't be
                // found elsewhere
                assert (pWbemServer != NULL);
                if (pdhStatus == ERROR_SUCCESS) {
                    // add a backslash path separator
                    lstrcatW(szTempPath, cszBackSlash);
                    if (dwFlags & PDH_PATH_WBEM_INPUT) {
                        // convert the WBEM Class to the display name
                        pdhStatus = PdhiWbemGetCounterDisplayName (
                            pWbemClass,
                            pCounterPathElements->szCounterName,
                            &szTempCounterString[0],
                            dwSize);
                        if (dwFlags & PDH_PATH_WBEM_RESULT) {
                            // just copy the string, but save
                            // the class pointer
                            lstrcpyW (szTempCounterString, pCounterPathElements->szCounterName);
                        } else {
                            // copy the retrieved string
                        }
                    } else {
                        // convert the display name to a Wbem class name
                        pdhStatus = PdhiWbemGetCounterPropertyName (
                            pWbemClass,
                            pCounterPathElements->szCounterName,
                            &szTempCounterString[0],
                            dwSize);
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        //then add the string
                        lstrcatW(szTempPath, szTempCounterString);
                        dwCurSize += lstrlenW(szTempCounterString) + 1; // includes delimiter
                    }
                }
            } else {
                // no object name, so bad structure
                pdhStatus = PDH_CSTATUS_NO_COUNTER;
            }
        }

        assert (dwCurSize == (DWORD)lstrlenW(szTempPath));
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // copy path to the caller's buffer if it will fit
        assert (dwCurSize == (DWORD)lstrlenW(szTempPath));
        if (dwCurSize < *pcchBufferSize) {
            if (szFullPathBuffer != NULL) {
                lstrcpyW (szFullPathBuffer, szTempPath);
            }
        } else {
            if (szFullPathBuffer != NULL) {
                // the buffer passed in is too small
                pdhStatus = PDH_MORE_DATA;
            }
        }
        *pcchBufferSize = dwCurSize;
    }

    //if (pWbemClass != NULL) pWbemClass->Release();

    // CoUninitialize if necessary
    if ( fCoInitialized )
    {
        PdhiCoUninitialize();
    }
    if (szTempPath != NULL) G_FREE(szTempPath);

    return pdhStatus;
}

PDH_FUNCTION
PdhiEncodeWbemPathA (
    PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    LPSTR                       szFullPathBuffer,
    LPDWORD                     pcchBufferSize,
    LANGID                      LangId,
    DWORD                       dwFlags
)
{
    PDH_STATUS                  pdhStatus = ERROR_SUCCESS;
    LPWSTR                      wszNextString;
    LPWSTR                      wszReturnBuffer;
    PDH_COUNTER_PATH_ELEMENTS_W *pWideCounterPathElements;
    DWORD                       dwcchBufferSize;
    DWORD                       dwBuffSize;
    DWORD                       dwDest;

    // get required buffer size...
    dwBuffSize = sizeof (PDH_COUNTER_PATH_ELEMENTS_W);

    if (pCounterPathElements->szMachineName != NULL) {
        dwBuffSize += (lstrlenA(pCounterPathElements->szMachineName) + 1) * sizeof(WCHAR);
    }

    if (pCounterPathElements->szObjectName != NULL) {
        dwBuffSize += (lstrlenA(pCounterPathElements->szObjectName) + 1) * sizeof(WCHAR);
    }

    if (pCounterPathElements->szInstanceName != NULL) {
        dwBuffSize += (lstrlenA(pCounterPathElements->szInstanceName) + 1) * sizeof(WCHAR);
    }

    if (pCounterPathElements->szParentInstance != NULL) {
        dwBuffSize += (lstrlenA(pCounterPathElements->szParentInstance) + 1) * sizeof(WCHAR);
    }

    if (pCounterPathElements->szCounterName != NULL) {
        dwBuffSize += (lstrlenA(pCounterPathElements->szCounterName) + 1) * sizeof(WCHAR);
    }

    // add in room for the return buffer
    dwcchBufferSize  = * pcchBufferSize;
    dwBuffSize      += dwcchBufferSize * sizeof(WCHAR);

    pWideCounterPathElements = (PDH_COUNTER_PATH_ELEMENTS_W *)G_ALLOC(dwBuffSize);

    if (pWideCounterPathElements != NULL) {
        // populate the fields
        wszNextString = (LPWSTR)&pWideCounterPathElements[1];

        if (pCounterPathElements->szMachineName != NULL) {
            dwDest = MultiByteToWideChar(_getmbcp(),
                        0,
                        pCounterPathElements->szMachineName,
                        lstrlenA(pCounterPathElements->szMachineName),
                        wszNextString,
                        (lstrlenA(pCounterPathElements->szMachineName) + 1));
            if (dwDest > 0) {
                pWideCounterPathElements->szMachineName = wszNextString;
                wszNextString += dwDest + 1;
            }
            else {
                pWideCounterPathElements->szMachineName = NULL;
            }
        } else {
            pWideCounterPathElements->szMachineName = NULL;
        }

        if (pCounterPathElements->szObjectName != NULL) {
            pWideCounterPathElements->szObjectName = wszNextString;
            dwDest = MultiByteToWideChar(_getmbcp(),
                        0,
                        pCounterPathElements->szObjectName,
                        lstrlenA(pCounterPathElements->szObjectName),
                        wszNextString,
                        (lstrlenA(pCounterPathElements->szObjectName) + 1));
            if (dwDest > 0) {
                pWideCounterPathElements->szObjectName = wszNextString;
                wszNextString += dwDest + 1;
            }
            else {
                pWideCounterPathElements->szObjectName = NULL;
            }
        } else {
            pWideCounterPathElements->szObjectName = NULL;
        }

        if (pCounterPathElements->szInstanceName != NULL) {
            dwDest = MultiByteToWideChar(_getmbcp(),
                        0,
                        pCounterPathElements->szInstanceName,
                        lstrlenA(pCounterPathElements->szInstanceName),
                        wszNextString,
                        (lstrlenA(pCounterPathElements->szInstanceName) + 1));
            if (dwDest > 0) {
                pWideCounterPathElements->szInstanceName = wszNextString;
                wszNextString += dwDest + 1;
            }
            else {
                pWideCounterPathElements->szInstanceName = NULL;
            }
        } else {
            pWideCounterPathElements->szInstanceName = NULL;
        }

        if (pCounterPathElements->szParentInstance != NULL) {
            dwDest = MultiByteToWideChar(_getmbcp(),
                        0,
                        pCounterPathElements->szParentInstance,
                        lstrlenA(pCounterPathElements->szParentInstance),
                        wszNextString,
                        (lstrlenA(pCounterPathElements->szParentInstance) + 1));
            if (dwDest > 0) {
                pWideCounterPathElements->szParentInstance = wszNextString;
                wszNextString += dwDest + 1;
            }
            else {
                pWideCounterPathElements->szParentInstance = NULL;
            }
        } else {
            pWideCounterPathElements->szParentInstance = NULL;
        }

        if (pCounterPathElements->szCounterName != NULL) {
            dwDest = MultiByteToWideChar(_getmbcp(),
                        0,
                        pCounterPathElements->szCounterName,
                        lstrlenA(pCounterPathElements->szCounterName),
                        wszNextString,
                        (lstrlenA(pCounterPathElements->szCounterName) + 1));
            if (dwDest > 0) {
                pWideCounterPathElements->szCounterName = wszNextString;
                wszNextString += dwDest + 1;
            }
            else {
                pWideCounterPathElements->szCounterName = NULL;
            }
        } else {
            pWideCounterPathElements->szCounterName = NULL;
        }

        pWideCounterPathElements->dwInstanceIndex =
            pCounterPathElements->dwInstanceIndex;

        if (szFullPathBuffer != NULL) {
            wszReturnBuffer = wszNextString;
        } else {
            wszReturnBuffer = NULL;
        }

        // call wide function
        pdhStatus = PdhiEncodeWbemPathW (
            pWideCounterPathElements,
            wszReturnBuffer,
            & dwcchBufferSize,
            LangId,
            dwFlags);

        if ((pdhStatus == ERROR_SUCCESS) && (szFullPathBuffer != NULL)) {
            // convert the wide path back to ANSI
            pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                        wszReturnBuffer,
                        szFullPathBuffer,
                        pcchBufferSize);
        }

        G_FREE (pWideCounterPathElements);
    } else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    return pdhStatus;

}

PDH_FUNCTION
PdhiDecodeWbemPathW (
    IN      LPCWSTR                     szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPDWORD                     pdwBufferSize,
    IN      LANGID                      LangId,
    IN      DWORD                       dwFlags
)
{
    PPDHI_COUNTER_PATH  pLocalCounterPath;
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    DWORD               dwSize;
    LPWSTR              szString = NULL;
    WCHAR               wszTempBuffer[MAX_PATH];
    LPWSTR              szSrc = NULL;

    PPDHI_WBEM_SERVER_DEF   pThisServer = NULL;
    IWbemClassObject    *pThisClass = NULL;

    DBG_UNREFERENCED_PARAMETER (LangId);

    // CoInitialize() if we need to
    BOOL    fCoInitialized = PdhiCoInitialize();

     // allocate a temporary work buffer
    pLocalCounterPath = (PPDHI_COUNTER_PATH) G_ALLOC(
            sizeof(PDHI_COUNTER_PATH) + sizeof(WCHAR) * 2 *
                (  lstrlenW(szStaticLocalMachineName)
                 + lstrlenW(szFullPathBuffer) + 3));

    if (pLocalCounterPath != NULL) {
        dwSize = (DWORD)G_SIZE (pLocalCounterPath);
        assert (dwSize != NULL);

        if (pdhStatus == ERROR_SUCCESS) {
            // get WBEM server since we'll probably need it later
            if (ParseFullPathNameW (szFullPathBuffer,
                &dwSize, pLocalCounterPath,
                (dwFlags & PDH_PATH_WBEM_INPUT ? TRUE : FALSE))) {
                // parsed successfully so load into user's buffer
                if (*pdwBufferSize != 0) {
                    if (pCounterPathElements != NULL) {
                        // see if there's enough room
                        if (*pdwBufferSize >= dwSize) {
                            // there's room so copy / translate the data
                            szString = (LPWSTR)&pCounterPathElements[1];
                            if (pLocalCounterPath->szMachineName != NULL) {
                                pCounterPathElements->szMachineName = szString;
                                lstrcpyW (szString, pLocalCounterPath->szMachineName);
                                szString += lstrlenW (szString) + 1;
                                szString = (LPWSTR)ALIGN_ON_DWORD (szString);
                            } else {
                                pCounterPathElements->szMachineName = NULL;
                            }
                            dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);
                        }

                        // Now that we have the proper machine name,
                        // connect to the server if we need to
                        if (dwFlags != (PDH_PATH_WBEM_INPUT | PDH_PATH_WBEM_RESULT)) {
                            pdhStatus = PdhiConnectWbemServer (
                                pCounterPathElements->szMachineName, &pThisServer);
                        } else {
                            // this will just be a copy operation
                            pdhStatus = ERROR_SUCCESS;
                        }

                        if ( pdhStatus == ERROR_SUCCESS ) {

                            if (pLocalCounterPath->szObjectName != NULL) {
                                pCounterPathElements->szObjectName = szString;
                                if (dwFlags & PDH_PATH_WBEM_RESULT) {
                                    if (dwFlags & PDH_PATH_WBEM_INPUT) {
                                        // just copy
                                        szSrc = pLocalCounterPath->szObjectName;
                                    } else {
                                        // interpret the display name to a class name
                                        pdhStatus = PdhiWbemGetObjectClassName (
                                            pThisServer,
                                            pLocalCounterPath->szObjectName,
                                            wszTempBuffer,
                                            sizeof(wszTempBuffer) / sizeof(wszTempBuffer[0]),
                                            &pThisClass);
                                        if (pdhStatus == ERROR_SUCCESS) {
                                            szSrc = wszTempBuffer;
                                        } 
                                    }
                                } else {
                                    if (dwFlags & PDH_PATH_WBEM_INPUT) {
                                        // translate class name to a display name
                                        pdhStatus = PdhiWbemGetClassDisplayName (
                                            pThisServer, pLocalCounterPath->szObjectName,
                                            wszTempBuffer,
                                            sizeof(wszTempBuffer) / sizeof(wszTempBuffer[0]),
                                            &pThisClass);
                                        if (pdhStatus == ERROR_SUCCESS) {
                                            szSrc = wszTempBuffer;
                                        }
                                    } else {
                                        assert (dwFlags != 0); // this should be caught earlier
                                    }
                                }

                                if (pdhStatus == ERROR_SUCCESS) {
                                    dwSize += (lstrlenW(szSrc) +1) * sizeof(WCHAR);
                                    if (*pdwBufferSize >= dwSize) {
                                        lstrcpyW (szString, szSrc);
                                        szString += lstrlenW (szString) + 1;
                                        szString = (LPWSTR)ALIGN_ON_DWORD (szString);
                                        dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);
                                    } else {
                                        // not enough room
                                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                                    }
                                }
                            } else {
                                pCounterPathElements->szObjectName = NULL;
                            }

                            if (pdhStatus == ERROR_SUCCESS) {
                                if (pLocalCounterPath->szInstanceName != NULL) {
                                    pCounterPathElements->szInstanceName = szString;
                                    szSrc = pLocalCounterPath->szInstanceName;
                                    dwSize += (lstrlenW(szSrc) +1) * sizeof(WCHAR);
                                    if (*pdwBufferSize >= dwSize) {
                                        lstrcpyW (szString, szSrc);
                                        szString += lstrlenW (szString) + 1;
                                        szString = (LPWSTR)ALIGN_ON_DWORD (szString);
                                        dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);
                                    } else {
                                        // not enough room
                                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                                    }

                                    if (pLocalCounterPath->szParentName != NULL) {
                                        pCounterPathElements->szParentInstance = szString;
                                        szSrc = pLocalCounterPath->szParentName;
                                        dwSize += (lstrlenW(szSrc) +1) * sizeof(WCHAR);
                                        if (*pdwBufferSize >= dwSize) {
                                            lstrcpyW (szString, szSrc);
                                            szString += lstrlenW (szString) + 1;
                                            szString = (LPWSTR)ALIGN_ON_DWORD (szString);
                                            dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);
                                        } else {
                                            // not enough room
                                            pdhStatus = PDH_INSUFFICIENT_BUFFER;
                                        }
                                    } else {
                                        pCounterPathElements->szParentInstance = NULL;
                                    }

                                    pCounterPathElements->dwInstanceIndex =
                                        pLocalCounterPath->dwIndex;

                                } else {
                                    pCounterPathElements->szInstanceName = NULL;
                                    pCounterPathElements->szParentInstance = NULL;
                                    pCounterPathElements->dwInstanceIndex = (DWORD)-1;
                                }
                            }

                            if (pdhStatus == ERROR_SUCCESS) {
                                if (pLocalCounterPath->szCounterName != NULL) {
                                    pCounterPathElements->szCounterName = szString;
                                    if (dwFlags & PDH_PATH_WBEM_RESULT) {
                                        if (dwFlags & PDH_PATH_WBEM_INPUT) {
                                            // just copy
                                            szSrc = pLocalCounterPath->szCounterName;
                                        } else {
                                            // interpret the display name to a property name
                                            pdhStatus = PdhiWbemGetCounterPropertyName (
                                                pThisClass,
                                                pLocalCounterPath->szCounterName,
                                                wszTempBuffer,
                                                sizeof(wszTempBuffer) / sizeof(wszTempBuffer[0]));
                                            if (pdhStatus == ERROR_SUCCESS) {
                                                szSrc = wszTempBuffer;
                                            }
                                        }
                                    } else {
                                        if (dwFlags & PDH_PATH_WBEM_INPUT) {
                                            // translate class name to a display name
                                            pdhStatus = PdhiWbemGetCounterDisplayName (
                                                pThisClass, pLocalCounterPath->szCounterName,
                                                wszTempBuffer,
                                                sizeof(wszTempBuffer) / sizeof(wszTempBuffer[0]));
                                            if (pdhStatus == ERROR_SUCCESS) {
                                                szSrc = wszTempBuffer;
                                            }
                                        } else {
                                            assert (dwFlags != 0); // this should be caught earlier
                                        }
                                    }
                                    dwSize += (lstrlenW(szSrc) +1) * sizeof(WCHAR);
                                    if (*pdwBufferSize >= dwSize) {
                                        lstrcpyW (szString, szSrc);
                                        szString += lstrlenW (szString) + 1;
                                        szString = (LPWSTR)ALIGN_ON_DWORD (szString);
                                        dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);
                                    } else {
                                        // not enough room
                                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                                    }
                                } else {
                                    pCounterPathElements->szCounterName = NULL;
                                }
                            }
                        }   // If pdhStatus == ERROR_SUCCESS

                        if (pdhStatus == ERROR_SUCCESS) {
                            dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);

                            *pdwBufferSize = dwSize;
                        }
                    } else {
                        // a null buffer pointer was passed int
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    // this is just a size check so return size required
                    *pdwBufferSize = dwSize * 2; // doubled to insure room for path expansions
                    pdhStatus = ERROR_SUCCESS;
                }
            } else {
                // unable to read path
                pdhStatus = PDH_INVALID_PATH;
            }
            // release class object if used
            //if (pThisClass != NULL) pThisClass->Release();

            // Cleanup pThisServer if used
            if ( NULL != pThisServer )
            {
                if (pdhStatus == ERROR_SUCCESS) {
                    pdhStatus = PdhiDisconnectWbemServer (pThisServer);
                } else {
                    // don't trash the return status
                    PdhiDisconnectWbemServer (pThisServer);
                }
            }

        }
        G_FREE (pLocalCounterPath);
    } else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    // CoUninitialize if necessary
    if ( fCoInitialized )
    {
        PdhiCoUninitialize();
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiDecodeWbemPathA (
    IN      LPCSTR                      szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    IN      LPDWORD                     pdwBufferSize,
    IN      LANGID                      LangId,
    IN      DWORD                       dwFlags
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    LPWSTR      wszWidePath = NULL;
    PDH_COUNTER_PATH_ELEMENTS_W     *pWideElements = NULL;
    DWORD       dwSize;
    DWORD       dwDest = 0;
    LONG        lSizeRemaining;
    LPSTR       szNextString;

    wszWidePath = (LPWSTR)G_ALLOC((lstrlenA(szFullPathBuffer) + 1) * sizeof(WCHAR));

    if (wszWidePath == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // compute size of temp element buffer
        lSizeRemaining = * pdwBufferSize - sizeof(PDH_COUNTER_PATH_ELEMENTS_A);
        dwSize = * pdwBufferSize - sizeof(PDH_COUNTER_PATH_ELEMENTS_A);
        // dwSize now has the size of the buffer AFTER the structure so
        // adjust this for the longer char length to make it a fair comparison
        dwSize *= sizeof(WCHAR)/sizeof(CHAR);
        // and add back in the structure
        dwSize += sizeof(PDH_COUNTER_PATH_ELEMENTS_W);

        if (pCounterPathElements != NULL) {
            pWideElements = (PDH_COUNTER_PATH_ELEMENTS_W *) G_ALLOC(dwSize);
            if (pWideElements == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        } else {
            pWideElements = NULL;
            pdhStatus = ERROR_SUCCESS;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // convert path to Wide
        MultiByteToWideChar(_getmbcp(),
                    0,
                    szFullPathBuffer,
                    lstrlenA(szFullPathBuffer),
                    wszWidePath,
                    lstrlenA(szFullPathBuffer) + 1);
        pdhStatus = PdhiDecodeWbemPathW (
                    wszWidePath,
                    pWideElements,
                    & dwSize,
                    LangId,
                    dwFlags);

        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements != NULL) {
                // populate the fields of the caller's buffer
                szNextString = (LPSTR)&pCounterPathElements[1];

                if (   pWideElements->szMachineName != NULL
                    && lSizeRemaining > 0) {
                    dwDest    = lSizeRemaining;
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                pWideElements->szMachineName,
                                szNextString,
                                & dwDest);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pCounterPathElements->szMachineName = szNextString;
                        szNextString += dwDest + 1;
                    }
                    else {
                        pCounterPathElements->szMachineName = NULL;
                    }
                    lSizeRemaining -= dwDest + 1;
                } else {
                    pCounterPathElements->szMachineName = NULL;
                }

                if (   pWideElements->szObjectName != NULL
                    && lSizeRemaining > 0) {
                    dwDest    = lSizeRemaining;
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                pWideElements->szObjectName,
                                szNextString,
                                & dwDest);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pCounterPathElements->szObjectName = szNextString;
                        szNextString += dwDest + 1;
                    }
                    else {
                        pCounterPathElements->szObjectName = NULL;
                    }
                    lSizeRemaining -= dwDest + 1;
                } else {
                    pCounterPathElements->szObjectName = NULL;
                }

                if (   pWideElements->szInstanceName != NULL
                    && lSizeRemaining > 0) {
                    dwDest    = lSizeRemaining;
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                pWideElements->szInstanceName,
                                szNextString,
                                & dwDest);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pCounterPathElements->szInstanceName = szNextString;
                        szNextString += dwDest + 1;
                    }
                    else {
                        pCounterPathElements->szInstanceName = NULL;
                    }
                    lSizeRemaining -= dwDest + 1;
                } else {
                    pCounterPathElements->szInstanceName = NULL;
                }

                if (   pWideElements->szParentInstance != NULL
                    && lSizeRemaining > 0) {
                    dwDest    = lSizeRemaining;
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                pWideElements->szParentInstance,
                                szNextString,
                                & dwDest);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pCounterPathElements->szParentInstance = szNextString;
                        szNextString += dwDest + 1;
                    }
                    else {
                        pCounterPathElements->szParentInstance = NULL;
                    }
                    lSizeRemaining -= dwDest + 1;
                } else {
                    pCounterPathElements->szParentInstance = NULL;
                }

                if (   pWideElements->szCounterName != NULL
                    && lSizeRemaining > 0) {
                    dwDest    = lSizeRemaining;
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                pWideElements->szObjectName,
                                szNextString,
                                & dwDest);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pCounterPathElements->szCounterName = szNextString;
                        szNextString   += dwDest + 1;
                    }
                    else {
                        pCounterPathElements->szCounterName = NULL;
                    }
                    lSizeRemaining -= dwDest + 1;
                } else {
                    pCounterPathElements->szCounterName = NULL;
                }

                pCounterPathElements->dwInstanceIndex =
                    pWideElements->dwInstanceIndex;

                *pdwBufferSize = (DWORD)((LPBYTE)szNextString - (LPBYTE)pCounterPathElements);
            } else {
                // just return the size required adjusted for wide/ansi characters
                *pdwBufferSize = sizeof(PDH_COUNTER_PATH_ELEMENTS_A);
                dwSize -= sizeof(PDH_COUNTER_PATH_ELEMENTS_W);
                dwSize /= sizeof(WCHAR)/sizeof(CHAR);
                *pdwBufferSize += dwSize;
            }
        } else {
            // call to wide function failed so just return error
        }
    } else {
        // memory allocation failed so return error
    }

    if (pWideElements != NULL) G_FREE(pWideElements);
    if (wszWidePath != NULL) G_FREE(wszWidePath);

    return pdhStatus;
}

BOOL
WbemInitCounter (
    IN      PPDHI_COUNTER pCounter
)
/*++

Routine Description:

    Initialized the counter data structure by:
        Allocating the memory block to contain the counter structure
            and all the associated data fields. If this allocation
            is successful, then the fields are initialized by
            verifying the counter is valid.

Arguments:

    IN      PPDHI_COUNTER pCounter
        pointer of the counter to initialize using the system data

Return Value:

    TRUE if the counter was successfully initialized
    FALSE if a problem was encountered

    In either case, the CStatus field of the structure is updated to
    indicate the status of the operation.

--*/
{
    DWORD               dwResult;
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    PPDHI_WBEM_SERVER_DEF   pWbemServer = NULL;
    DWORD               dwLastError = ERROR_SUCCESS;
    HRESULT             hRes = S_OK;
    VARIANT             vCountertype;
    WCHAR               szBasePropertyName[MAX_PATH];
    WCHAR               szFreqPropertyName[MAX_PATH];
    WCHAR               szWbemItemPath[MAX_PATH];
    ULONGLONG           llValue;
    LONG                lOffset;

    PPDH_COUNTER_PATH_ELEMENTS_W    pPathElem = NULL;
    BOOL                            bReturn = TRUE;
    DWORD                           dwBufferSize = 0;
    BSTR                            bsPropName = NULL;
    BSTR                            bsCountertype = NULL;
    IWbemQualifierSet               *pQualSet = NULL;
    PPDHI_COUNTER                   pCounterInList = NULL;
    PPDHI_COUNTER_PATH              pPdhiCtrPath = NULL;
    BOOL                bMatchFound;
    DWORD               bDisconnectServer = FALSE;

    // CoInitialize() if we need to
    BOOL    fCoInitialized = PdhiCoInitialize();

    VariantInit (&vCountertype);

    pCounter->dwFlags |= PDHIC_WBEM_COUNTER; // make sure WBEM flag is set

    // make sure the query has a refresher started already
    if (pCounter->pOwner->pRefresher == NULL) {
        // it hasn't been started so start now
        dwResult = CoCreateRefresher( &pCounter->pOwner->pRefresher );
        if ((dwResult != S_OK) || (pCounter->pOwner->pRefresher ==  NULL)) {
            pCounter->pOwner->pRefresher = NULL;
            dwLastError = PDH_WBEM_ERROR;
            bReturn = FALSE;
        } else {
            // open config interface
            dwResult = pCounter->pOwner->pRefresher->QueryInterface (
                IID_IWbemConfigureRefresher,
                (LPVOID *)&pCounter->pOwner->pRefresherCfg);
            if (dwResult != S_OK) {
                pCounter->pOwner->pRefresherCfg = NULL;
                pCounter->pOwner->pRefresher->Release();
                pCounter->pOwner->pRefresher = NULL;
                dwLastError = PDH_WBEM_ERROR;
                bReturn = FALSE;
            }
        }
    }

    if (bReturn) {
        // so far so good, now figure out the WBEM path to add it to the
        // refresher
        dwBufferSize = lstrlenW(pCounter->szFullName) * sizeof(WCHAR) * 10;
        dwBufferSize += sizeof (PDH_COUNTER_PATH_ELEMENTS_W);

        pPathElem = (PPDH_COUNTER_PATH_ELEMENTS_W) G_ALLOC (dwBufferSize);
        // the path is display names, so convert to WBEM class names first

        if (pPathElem == NULL) {
            dwLastError = PDH_MEMORY_ALLOCATION_FAILURE;
            bReturn = FALSE;
        } else {
            pdhStatus = PdhiDecodeWbemPathW (
                pCounter->szFullName,
                pPathElem,
                &dwBufferSize,
                pCounter->pOwner->LangID,
                PDH_PATH_WBEM_RESULT);
            if (pdhStatus == ERROR_SUCCESS) {
                // continue
            } else {
                dwLastError = PDH_INVALID_PATH;
                bReturn = FALSE;
            }
        }
    }

    if (bReturn) {
        dwBufferSize *= 8; // just to be safe
        pPdhiCtrPath = (PPDHI_COUNTER_PATH) G_ALLOC (dwBufferSize);
        if (pPdhiCtrPath == NULL) {
            dwLastError = PDH_MEMORY_ALLOCATION_FAILURE;
            bReturn = FALSE;
        } else {
            // break path into display elements
            bReturn = ParseFullPathNameW (
                pCounter->szFullName,
                &dwBufferSize,
                pPdhiCtrPath,
                FALSE);
            if (bReturn) {
                // realloc to use only the memory needed
                pCounter->pCounterPath = (PPDHI_COUNTER_PATH)
                    G_REALLOC (pPdhiCtrPath, dwBufferSize);
                if ((pPdhiCtrPath != pCounter->pCounterPath) &&
                    (pCounter->pCounterPath != NULL)){
                    // the memory block moved so
                    // correct addresses inside structure
                    lOffset = (LONG)((ULONG_PTR)pCounter->pCounterPath -
                                     (ULONG_PTR)pPdhiCtrPath);
                    if (pCounter->pCounterPath->szMachineName) {
                        pCounter->pCounterPath->szMachineName = (LPWSTR)(
                            (LPBYTE)pCounter->pCounterPath->szMachineName + lOffset);
                    }
                    if (pCounter->pCounterPath->szObjectName) {
                        pCounter->pCounterPath->szObjectName = (LPWSTR)(
                            (LPBYTE)pCounter->pCounterPath->szObjectName + lOffset);
                    }
                    if (pCounter->pCounterPath->szInstanceName) {
                        pCounter->pCounterPath->szInstanceName = (LPWSTR)(
                            (LPBYTE)pCounter->pCounterPath->szInstanceName + lOffset);
                    }
                    if (pCounter->pCounterPath->szParentName) {
                        pCounter->pCounterPath->szParentName = (LPWSTR)(
                            (LPBYTE)pCounter->pCounterPath->szParentName + lOffset);
                    }
                    if (pCounter->pCounterPath->szCounterName) {
                        pCounter->pCounterPath->szCounterName = (LPWSTR)(
                            (LPBYTE)pCounter->pCounterPath->szCounterName + lOffset);
                    }
                }
            } else {
                // free the buffer
                G_FREE (pPdhiCtrPath);
                dwLastError = PDH_WBEM_ERROR;
            }
        }
    }

    // connect to the WBEM Server on that machine
    if (bReturn) {
        pdhStatus = PdhiConnectWbemServer (
            pCounter->pCounterPath->szMachineName,
            &pWbemServer);
        if (pdhStatus != ERROR_SUCCESS) {
            dwLastError = pdhStatus;
            bReturn = FALSE;
        } else {
            bDisconnectServer = TRUE;
        }
    }

    if (bReturn) {
        // make WBEM Instance path out of path elements
        pdhStatus = PdhiMakeWbemInstancePath (
            pPathElem,
            szWbemItemPath,
            TRUE);

        // check for an object/class of this type that has already been added
        // walk down counter list to find a matching:
        //  machine\namespace
        //  object
        //  instance name
        if (pdhStatus != ERROR_SUCCESS) {
            dwLastError = pdhStatus;
            bReturn = FALSE;
        }
    }

    if (bReturn) {
        assert (pCounter->pWbemObject == NULL);
        assert (pCounter->lWbemRefreshId == 0);

        pCounterInList = pCounter->pOwner->pCounterListHead;
        if (pCounterInList == NULL) {
            // then there are no entries to search so continue
        } else {
            do {
                // check for matching machine name
                bMatchFound = FALSE;
                if (lstrcmpiW(pCounterInList->pCounterPath->szMachineName,
                    pCounter->pCounterPath->szMachineName) == 0) {
                    // then the machine name matches
                    if (lstrcmpiW (pCounterInList->pCounterPath->szObjectName,
                        pCounter->pCounterPath->szObjectName) == 0) {
                        // then the object name matches
                        // see if the instance matches
                        if (lstrcmpiW (pCounterInList->pCounterPath->szInstanceName,
                            pCounter->pCounterPath->szInstanceName) == 0) {
                            if (pCounter->pCounterPath->szParentName != 0) {
                                if (lstrcmpiW (pCounterInList->pCounterPath->szParentName,
                                    pCounter->pCounterPath->szParentName) == 0) {
                                    // then this is a match
                                    bMatchFound = TRUE;
                                } else {
                                    // not a match
                                }
                            } else {
                                // this is a match
                                bMatchFound = TRUE;
                            }

                            if (bMatchFound) {
                                if ((pCounter->pCounterPath->szInstanceName != NULL) &&
                                    (*pCounter->pCounterPath->szInstanceName == SPLAT_L)) {
                                    // then this is a Wild Card or multiple instance path
                                    // see if an enumerator for this object has already been created
                                    // if so, then AddRef it
                                    if (pCounterInList->pWbemEnum != NULL) {
                                        pCounter->pWbemObject = pCounterInList->pWbemObject;
                                        pCounter->pWbemEnum = pCounterInList->pWbemEnum;
                                        // bump the ref counts on this object so it
                                        //  doesn't disapper from us
                                        pCounter->pWbemObject->AddRef();
                                        pCounter->pWbemEnum->AddRef();
                                        pCounter->lWbemEnumId = pCounterInList->lWbemEnumId;
                                        pCounter->dwFlags |= PDHIC_MULTI_INSTANCE;
                                    }
                                    // and exit loop
                                    hRes = S_OK;
                                    break;
                                } else {
                                    // then it's a regular instance the instance name matches
                                    // so get the Object pointer
                                    pCounter->pWbemObject = pCounterInList->pWbemObject;
                                    pCounter->pWbemAccess = pCounterInList->pWbemAccess;
                                    // bump the ref counts on this object so it
                                    //  doesn't disapper from us
                                    pCounter->pWbemObject->AddRef();
                                    pCounter->pWbemAccess->AddRef();
                                    pCounter->lWbemRefreshId = pCounterInList->lWbemRefreshId;
                                    // and exit loop
                                    hRes = S_OK;
                                    break;
                                }
                            } else {
                                // no match so go to next one
                            }
                        } else {
                            // no match so go to next one
                        }
                    } else {
                        // no match so go to next one
                    }
                } else {
                    // no match so go to next counter
                }
                pCounterInList = pCounterInList->next.flink;
            } while (pCounterInList != pCounter->pOwner->pCounterListHead);
        }

        bDontRefresh = TRUE;

        // determine if we should and an object or an enumerator
        if ((pCounter->pCounterPath->szInstanceName != NULL) &&
            (*pCounter->pCounterPath->szInstanceName == SPLAT_L)) {
            // then this is an enum type so see if there's already one assigned
            // if not, then create one
            if (pCounter->pWbemEnum == NULL) {
                if (pCounter->pOwner->pRefresherCfg != NULL) {
                    hRes = pCounter->pOwner->pRefresherCfg->AddEnum(
                        pWbemServer->pSvc,
                        pPathElem->szObjectName,
                        WBEM_FLAG_USE_AMENDED_QUALIFIERS, 0,
                        &pCounter->pWbemEnum,
                        &pCounter->lWbemEnumId);
                } else {
                    hRes = WBEM_E_INITIALIZATION_FAILURE;
                }

                if (hRes != S_OK) {
                    bReturn = FALSE;
                    dwLastError = PDH_WBEM_ERROR;
                } else {
                    pdhStatus = PdhiWbemGetClassObjectByName (
                        pWbemServer,
                        pPathElem->szObjectName,
                        &pCounter->pWbemObject);
                }
                // set multi instance flag
                pCounter->dwFlags |= PDHIC_MULTI_INSTANCE;
            } else {
                // we must have copied another one so continue
            }

        } else {
            // this is a single counter
            if (pCounter->pWbemObject == NULL) {
                // and it hasn't been added yet, so just add one object
                if (pCounter->pOwner->pRefresherCfg != NULL) {
                    hRes = pCounter->pOwner->pRefresherCfg->AddObjectByPath (
                        pWbemServer->pSvc,
                        szWbemItemPath,
                        WBEM_FLAG_USE_AMENDED_QUALIFIERS, 0,
                        &pCounter->pWbemObject,
                        &pCounter->lWbemRefreshId);
                } else {
                    hRes = WBEM_E_INITIALIZATION_FAILURE;
                }

                if (hRes != S_OK) {
                    bReturn = FALSE;
                    dwLastError = PDH_WBEM_ERROR;
                }
            } else {
                // it must have been copied from another
            }
        }

        if (hRes == S_OK) {
            // get handles for subsequent data collection from this object
            hRes = pCounter->pWbemObject->QueryInterface (IID_IWbemObjectAccess,
                (LPVOID *)&pCounter->pWbemAccess);
            if (hRes == S_OK) {
                if (!PdhiIsSingletonClass (pCounter->pWbemObject)) {
                    CIMTYPE cimType = 0;
                    bsPropName = SysAllocString(cszName);
                    if (bsPropName) {
                        // get handle to the name property for this counter
                        hRes = pCounter->pWbemAccess->GetPropertyHandle (
                            bsPropName, &cimType,
                            &pCounter->lNameHandle);
                        if (hRes != S_OK) {
                            dwLastError = PDH_WBEM_ERROR;
                        }
                        assert (cimType == CIM_STRING);
                    } else {
                        dwLastError = PDH_MEMORY_ALLOCATION_FAILURE;
                        hRes = WBEM_E_OUT_OF_MEMORY;
                    }
                } else {
                    pCounter->lNameHandle = -1;
                }
                if (hRes == S_OK) {
                    // get handle to the data property for this counter
                    hRes = pCounter->pWbemAccess->GetPropertyHandle (
                        pPathElem->szCounterName, &pCounter->lNumItemType,
                        &pCounter->lNumItemHandle);
                    assert (hRes == S_OK);

                    // get counter type field
                    // first get the property qualifiers
                    PdhiSysFreeString (&bsPropName);
                    bsPropName = SysAllocString (pPathElem->szCounterName);
                    if (bsPropName) {
                        hRes = pCounter->pWbemObject->GetPropertyQualifierSet (
                            bsPropName, &pQualSet);
                    } else {
                        hRes = WBEM_E_OUT_OF_MEMORY;
                    }

                    if (hRes == WBEM_NO_ERROR) {
                        // now get the specific value
                        VariantClear (&vCountertype);
                        bsCountertype = SysAllocString (cszCountertype);
                        if (bsCountertype) {
                            hRes = pQualSet->Get (bsCountertype, 0, &vCountertype, NULL);
                            if (hRes == WBEM_NO_ERROR) {
                                pCounter->plCounterInfo.dwCounterType = (DWORD)V_I4(&vCountertype);
                            } else {
                                pCounter->plCounterInfo.dwCounterType = 0;
                            }
                            PdhiSysFreeString (&bsCountertype);
                        } else {
                            hRes = WBEM_E_OUT_OF_MEMORY;
                        }


                        if (hRes == WBEM_NO_ERROR) {
 
                            // if this is a fraction counter that has a "base" value
                            // then look it up by appending the "base" string to the
                            // property name

                            if ((pCounter->plCounterInfo.dwCounterType == PERF_SAMPLE_FRACTION) ||
                                (pCounter->plCounterInfo.dwCounterType == PERF_AVERAGE_TIMER)   ||
                                (pCounter->plCounterInfo.dwCounterType == PERF_AVERAGE_BULK)    ||
                                (pCounter->plCounterInfo.dwCounterType == PERF_LARGE_RAW_FRACTION) ||
                                (pCounter->plCounterInfo.dwCounterType == PERF_RAW_FRACTION)) {

                                // make sure we have room for the "_Base" string
                                assert (lstrlenW(pPathElem->szCounterName) < (MAX_PATH - 6));
                                lstrcpyW (szBasePropertyName, pPathElem->szCounterName);
                                lstrcatW (szBasePropertyName, cszBaseSuffix);

                                // get the handle to the denominator
                                hRes = pCounter->pWbemAccess->GetPropertyHandle (
                                    szBasePropertyName, &pCounter->lDenItemType,
                                    &pCounter->lDenItemHandle);
                                assert (hRes == S_OK);

                            } else {
                                // the denominator is a time field
                                if ((pCounter->plCounterInfo.dwCounterType & PERF_TIMER_FIELD) == PERF_TIMER_TICK) {
                                    // use the system perf time timestamp as the denominator
                                    lstrcpyW (szBasePropertyName, cszTimestampPerfTime);
                                    lstrcpyW (szFreqPropertyName, cszFrequencyPerfTime);
                                } else if ((pCounter->plCounterInfo.dwCounterType & PERF_TIMER_FIELD) == PERF_TIMER_100NS) {
                                    lstrcpyW (szBasePropertyName, cszTimestampSys100Ns);
                                    lstrcpyW (szFreqPropertyName, cszFrequencySys100Ns);
                                } else if ((pCounter->plCounterInfo.dwCounterType & PERF_TIMER_FIELD) == PERF_OBJECT_TIMER) {
                                    lstrcpyW (szBasePropertyName, cszTimestampObject);
                                    lstrcpyW (szFreqPropertyName, cszFrequencyObject);
                                } else {
                                    assert (FALSE); // this should never happen
                                }

                                // get the handle to the denominator
                                hRes = pCounter->pWbemAccess->GetPropertyHandle (
                                    szBasePropertyName, &pCounter->lDenItemType,
                                    &pCounter->lDenItemHandle);
                                assert (hRes == S_OK);

                                // get the handle to the frequency
                                hRes = pCounter->pWbemAccess->GetPropertyHandle (
                                    szFreqPropertyName, &pCounter->lFreqItemType,
                                    &pCounter->lFreqItemHandle);
                                assert (hRes == S_OK);
                            }

                            // get the default scale value of this counter
                            VariantClear (&vCountertype);
                            PdhiSysFreeString (&bsCountertype);
                            bsCountertype = SysAllocString (cszDefaultscale);
                            if (bsCountertype) {
                                hRes = pQualSet->Get (bsCountertype, 0, &vCountertype, NULL);
                                if (hRes == WBEM_NO_ERROR) {
                                    pCounter->lScale = 0;
                                    pCounter->plCounterInfo.lDefaultScale = (DWORD)V_I4(&vCountertype);
                                } else {
                                    pCounter->plCounterInfo.lDefaultScale = 0;
                                    pCounter->lScale = 0;
                                }

                                // this may not be initialized but we try anyway
                                if ((pCounter->lFreqItemType == VT_I8) ||
                                    (pCounter->lFreqItemType == VT_UI8)) {
                                    pCounter->pWbemAccess->ReadQWORD (
                                        pCounter->lFreqItemHandle, &llValue);
                                } else {
                                    llValue = 0;
                                }
                                // the timebase is a 64 bit integer
                                pCounter->TimeBase = llValue;
                            } else {
                                hRes = WBEM_E_OUT_OF_MEMORY;
                            }
                        }
                        PdhiSysFreeString (&bsCountertype);
                        pQualSet->Release();
                    } else {
                        if (hRes == WBEM_E_OUT_OF_MEMORY) {
                            dwLastError = PDH_MEMORY_ALLOCATION_FAILURE;
                        } else {
                            dwLastError = PDH_WBEM_ERROR;
                        }
                        bReturn = FALSE;
                    }
                } // else an error has ocurred
                PdhiSysFreeString (&bsPropName);
            } else {
                dwLastError = PDH_WBEM_ERROR;
                bReturn = FALSE;
            }
        } else {
            dwLastError = PDH_WBEM_ERROR;
            bReturn = FALSE;
        }

        if (bReturn) {
            // clear the not init'd flag to say it's ok to use now
            pCounter->dwFlags &= ~PDHIC_COUNTER_NOT_INIT;
        }

        bDontRefresh = FALSE;
    }

    if (bReturn) {
        if (!AssignCalcFunction (
            pCounter->plCounterInfo.dwCounterType,
            &pCounter->CalcFunc,
            &pCounter->StatFunc)) {
            dwLastError = PDH_FUNCTION_NOT_FOUND;
            bReturn = FALSE;
        }
    }

    if (pPathElem != NULL) G_FREE(pPathElem);
    VariantClear (&vCountertype);

    if (bDisconnectServer) {
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiDisconnectWbemServer (pWbemServer);
        } else {
            // keep error code from function body
            PdhiDisconnectWbemServer (pWbemServer);
        }
    }

    if (!bReturn) SetLastError (dwLastError);

    // CoUninitialize if necessary
    if ( fCoInitialized )
    {
        PdhiCoUninitialize();
    }

    return bReturn;
}

BOOL
UpdateWbemCounterValue (
    IN      PPDHI_COUNTER   pCounter,
    IN      FILETIME        *pTimeStamp
)
{
    DWORD   LocalCStatus = 0;
    DWORD   LocalCType  = 0;
    ULONGLONG   llValue;
    DWORD       dwValue;

    BOOL    bReturn  = FALSE;

    // move current value to last value buffer
    pCounter->LastValue = pCounter->ThisValue;

    // and clear the old value
    pCounter->ThisValue.MultiCount = 1;
    pCounter->ThisValue.FirstValue =
        pCounter->ThisValue.SecondValue = 0;
    pCounter->ThisValue.TimeStamp = *pTimeStamp;

    // get the counter's machine status first. There's no point in
    // contuning if the machine is offline

    // UpdateWbemCounterValue() will be called only if WBEM refresher succeeds
    // in GetQueryWbemData(); that is, all remote machines should be on-line

    LocalCStatus = ERROR_SUCCESS;

    if (IsSuccessSeverity(LocalCStatus)) {
        // get the pointer to the counter data
        LocalCType = pCounter->plCounterInfo.dwCounterType;
        switch (LocalCType) {
            //
            // these counter types are loaded as:
            //      Numerator = Counter data from perf data block
            //      Denominator = Perf Time from perf data block
            //      (the time base is the PerfFreq)
            //
            case PERF_COUNTER_COUNTER:
            case PERF_COUNTER_QUEUELEN_TYPE:
            case PERF_SAMPLE_COUNTER:
                // this should be a DWORD counter
                assert ((pCounter->lNumItemType == VT_I4) ||
                        (pCounter->lNumItemType == VT_UI4));
                pCounter->pWbemAccess->ReadDWORD (
                    pCounter->lNumItemHandle, &dwValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)(dwValue);

                assert ((pCounter->lDenItemType == VT_I8) ||
                        (pCounter->lDenItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lDenItemHandle, &llValue);
                // the denominator should be a 64-bit timestamp
                pCounter->ThisValue.SecondValue = llValue;

                // look up the timebase freq if necessary
                if (pCounter->TimeBase == 0) {
                    assert ((pCounter->lFreqItemType == VT_I8) ||
                            (pCounter->lFreqItemType == VT_UI8));
                    pCounter->pWbemAccess->ReadQWORD (
                        pCounter->lFreqItemHandle, &llValue);
                    // the timebase is a 64 bit integer
                    pCounter->TimeBase = llValue;
                }

                break;

            case PERF_ELAPSED_TIME:
            case PERF_100NSEC_TIMER:
            case PERF_100NSEC_TIMER_INV:
            case PERF_COUNTER_TIMER:
            case PERF_COUNTER_TIMER_INV:
            case PERF_COUNTER_BULK_COUNT:
            case PERF_COUNTER_MULTI_TIMER:
            case PERF_COUNTER_MULTI_TIMER_INV:
            case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
            case PERF_OBJ_TIME_TIMER:
            case PERF_COUNTER_100NS_QUEUELEN_TYPE:
            case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
            case PERF_PRECISION_SYSTEM_TIMER:
            case PERF_PRECISION_100NS_TIMER:
            case PERF_PRECISION_OBJECT_TIMER:
                // this should be a QWORD counter
                assert ((pCounter->lNumItemType == VT_I8) ||
                        (pCounter->lNumItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lNumItemHandle, &llValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)(llValue);

                assert ((pCounter->lDenItemType == VT_I8) ||
                        (pCounter->lDenItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lDenItemHandle, &llValue);
                // the denominator should be a 64-bit timestamp
                pCounter->ThisValue.SecondValue = llValue;

                // look up the timebase freq if necessary
                if (pCounter->TimeBase == 0) {
                    assert ((pCounter->lFreqItemType == VT_I8) ||
                            (pCounter->lFreqItemType == VT_UI8));
                    pCounter->pWbemAccess->ReadQWORD (
                        pCounter->lFreqItemHandle, &llValue);
                    // the timebase is a 64 bit integer
                    pCounter->TimeBase = llValue;
                }

                break;
            //
            //  These counters do not use any time reference
            //
            case PERF_COUNTER_RAWCOUNT:
            case PERF_COUNTER_RAWCOUNT_HEX:
            case PERF_COUNTER_DELTA:
                // this should be a DWORD counter
                assert ((pCounter->lNumItemType == VT_I4) ||
                        (pCounter->lNumItemType == VT_UI4));
                pCounter->pWbemAccess->ReadDWORD (
                    pCounter->lNumItemHandle, &dwValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)(dwValue);
                pCounter->ThisValue.SecondValue = 0;
                break;

            case PERF_COUNTER_LARGE_RAWCOUNT:
            case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
            case PERF_COUNTER_LARGE_DELTA:
                // this should be a DWORD counter
                assert ((pCounter->lNumItemType == VT_I8) ||
                        (pCounter->lNumItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lNumItemHandle, &llValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)(llValue);
                pCounter->ThisValue.SecondValue = 0;
                break;

            //
            //  These counters use two data points, the one pointed to by
            //  pData and the one immediately after
            //
            case PERF_SAMPLE_FRACTION:
            case PERF_RAW_FRACTION:
                // this should be a DWORD counter
                assert ((pCounter->lNumItemType == VT_I4) ||
                        (pCounter->lNumItemType == VT_UI4));
                pCounter->pWbemAccess->ReadDWORD (
                    pCounter->lNumItemHandle, &dwValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)dwValue;

                assert ((pCounter->lDenItemType == VT_I4) ||
                        (pCounter->lDenItemType == VT_UI4));
                pCounter->pWbemAccess->ReadDWORD (
                    pCounter->lDenItemHandle, &dwValue);
                // the denominator should be a 32-bit value
                pCounter->ThisValue.SecondValue = (LONGLONG)dwValue;
                break;

            case PERF_LARGE_RAW_FRACTION:
                // this should be a DWORD counter
                assert ((pCounter->lNumItemType == VT_I8) ||
                        (pCounter->lNumItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lNumItemHandle, & llValue);
                pCounter->ThisValue.FirstValue = (LONGLONG) llValue;

                assert ((pCounter->lDenItemType == VT_I8) ||
                        (pCounter->lDenItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lDenItemHandle, & llValue);
                // the denominator should be a 32-bit value
                pCounter->ThisValue.SecondValue = (LONGLONG) llValue;
            break;

            case PERF_AVERAGE_TIMER:
            case PERF_AVERAGE_BULK:
                // counter (numerator) is a LONGLONG, while the
                // denominator is just a DWORD
                // this should be a DWORD counter
                assert ((pCounter->lNumItemType == VT_I8) ||
                        (pCounter->lNumItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lNumItemHandle, &llValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)llValue;

                assert ((pCounter->lDenItemType == VT_I4) ||
                        (pCounter->lDenItemType == VT_UI4));
                pCounter->pWbemAccess->ReadDWORD (
                    pCounter->lDenItemHandle, &dwValue);
                // the denominator should be a 32-bit value
                pCounter->ThisValue.SecondValue = (LONGLONG)dwValue;

                // look up the timebase freq if necessary
                if (pCounter->TimeBase == 0) {
                    assert ((pCounter->lFreqItemType == VT_I8) ||
                            (pCounter->lFreqItemType == VT_UI8));
                    pCounter->pWbemAccess->ReadQWORD (
                        pCounter->lFreqItemHandle, &llValue);
                    // the timebase is a 64 bit integer
                    pCounter->TimeBase = llValue;
                }
                break;
            //
            //  These counters are used as the part of another counter
            //  and as such should not be used, but in case they are
            //  they'll be handled here.
            //
            case PERF_SAMPLE_BASE:
            case PERF_AVERAGE_BASE:
            case PERF_COUNTER_MULTI_BASE:
            case PERF_RAW_BASE:
            case PERF_LARGE_RAW_BASE:
                pCounter->ThisValue.FirstValue = 0;
                pCounter->ThisValue.SecondValue = 0;
                break;

            //
            //  These counters are not supported by this function (yet)
            //
            case PERF_COUNTER_TEXT:
            case PERF_COUNTER_NODATA:
            case PERF_COUNTER_HISTOGRAM_TYPE:
                pCounter->ThisValue.FirstValue = 0;
                pCounter->ThisValue.SecondValue = 0;
                break;

            case PERF_100NSEC_MULTI_TIMER:
            case PERF_100NSEC_MULTI_TIMER_INV:
            default:
                // an unidentified  or unsupported
                // counter was returned so
                pCounter->ThisValue.FirstValue = 0;
                pCounter->ThisValue.SecondValue = 0;
                bReturn = FALSE;
                break;
        }
    } else {
        // else this counter is not valid so this value == 0
        pCounter->ThisValue.CStatus     = LocalCStatus;
        pCounter->ThisValue.FirstValue  = 0;
        pCounter->ThisValue.SecondValue = 0;
        bReturn = FALSE;
    }

    return bReturn;
}

BOOL
UpdateWbemMultiInstanceCounterValue (
    IN      PPDHI_COUNTER   pCounter,
    IN      FILETIME        *pTimestamp
)
{
    IWbemObjectAccess   *pWbemAccess;
    HRESULT     hRes;

    DWORD       LocalCStatus = 0;
    DWORD       LocalCType  = 0;
    DWORD       dwValue;
    ULONGLONG   llValue;
    DWORD       dwSize;
    DWORD       dwFinalSize;
    LONG        lAvailableSize;
    LONG        lReturnSize;
    LONG        lThisInstanceIndex;
    LONG        lNumInstances;

    LPWSTR  szNextNameString;
    PPDHI_RAW_COUNTER_ITEM   pThisItem;

    BOOL    bReturn  = FALSE;

    if (pCounter->pThisRawItemList != NULL) {
        // free old counter buffer list
        G_FREE(pCounter->pLastRawItemList);
        pCounter->pLastRawItemList =
            pCounter->pThisRawItemList;
        pCounter->pThisRawItemList = NULL;
    }

    // get the counter's machine status first. There's no point in
    // contuning if the machine is offline

    // UpdateWbemCounterValue() will be called only if WBEM refresher succeeds
    // in GetQueryWbemData(); that is, all remote machines should be on-line

    LocalCStatus = ERROR_SUCCESS;

    if (IsSuccessSeverity(LocalCStatus)) {
        IWbemObjectAccess   **pWbemInstances = NULL;
        // get count of instances in enumerator
        assert (pCounter->pWbemEnum != NULL);
        hRes = pCounter->pWbemEnum->GetObjects(0, 0, NULL, (LPDWORD)&lNumInstances);
        if (hRes == WBEM_E_BUFFER_TOO_SMALL) {
            // then we should know how many have been returned so allocate an
            // array of pointers
            pWbemInstances = new IWbemObjectAccess * [lNumInstances];
            assert (pWbemInstances != NULL);
            if (pWbemInstances == NULL) {
                SetLastError(ERROR_OUTOFMEMORY);
                hRes    = ERROR_OUTOFMEMORY;
                bReturn = FALSE;
            }
            else {
                hRes = pCounter->pWbemEnum->GetObjects(0,
                    lNumInstances, pWbemInstances, (LPDWORD)&lNumInstances);
            }

            if (hRes == S_OK && lNumInstances > 0) {
                // then we have a table of instances
                // estimate the size required for the new data block
                dwSize = sizeof (PDHI_RAW_COUNTER_ITEM_BLOCK) - sizeof (PDHI_RAW_COUNTER_ITEM);
                dwSize += lNumInstances * (sizeof(PDH_RAW_COUNTER_ITEM_W) + (MAX_PATH * 2 * sizeof(WCHAR)));

                pCounter->pThisRawItemList = (PPDHI_RAW_COUNTER_ITEM_BLOCK)G_ALLOC (dwSize);

                if (pCounter->pThisRawItemList != NULL) {
                    dwFinalSize = lNumInstances * sizeof(PDH_RAW_COUNTER_ITEM_W);
                    szNextNameString = (LPWSTR)((PBYTE)pCounter->pThisRawItemList + dwFinalSize);

                    for (lThisInstanceIndex = 0;
                        lThisInstanceIndex < lNumInstances;
                        lThisInstanceIndex++) {
                        // get pointer to this raw data block in the array
                        pThisItem = &pCounter->pThisRawItemList->pItemArray[lThisInstanceIndex];
                        // get pointer to this IWbemObjectAccess pointer
                        pWbemAccess = pWbemInstances[lThisInstanceIndex];
                        // compute the remaining size of the buffer
                        lAvailableSize = (long)(dwSize - dwFinalSize);

                        assert (lAvailableSize > 0);

                        if (pCounter->lNameHandle != -1) {
                            hRes = pWbemAccess->ReadPropertyValue(
                                    pCounter->lNameHandle,
                                    lAvailableSize,
                                    &lReturnSize,
                                    (LPBYTE)szNextNameString);
                            assert(hRes == S_OK);
                        } else {
                            szNextNameString[0] = ATSIGN_L;
                            szNextNameString[1] = 0;
                            lReturnSize = 2;
                        }
                        pThisItem->szName = (DWORD)
                                (  ((LPBYTE) szNextNameString)
                                 - ((LPBYTE) pCounter->pThisRawItemList));
                        szNextNameString = (LPWSTR)((LPBYTE)szNextNameString + lReturnSize);
                        dwFinalSize += lReturnSize;
                        dwFinalSize = DWORD_MULTIPLE(dwFinalSize);

                        LocalCType = pCounter->plCounterInfo.dwCounterType;
                        switch (LocalCType) {
                            //
                            // these counter types are loaded as:
                            //      Numerator = Counter data from perf data block
                            //      Denominator = Perf Time from perf data block
                            //      (the time base is the PerfFreq)
                            //
                            case PERF_COUNTER_COUNTER:
                            case PERF_COUNTER_QUEUELEN_TYPE:
                            case PERF_SAMPLE_COUNTER:
                                // this should be a DWORD counter
                                assert ((pCounter->lNumItemType == VT_I4) ||
                                        (pCounter->lNumItemType == VT_UI4));
                                pWbemAccess->ReadDWORD (
                                        pCounter->lNumItemHandle, &dwValue);
                                pThisItem->FirstValue = (LONGLONG)(dwValue);

                                assert ((pCounter->lDenItemType == VT_I8) ||
                                        (pCounter->lDenItemType == VT_UI8));
                                pWbemAccess->ReadQWORD (
                                        pCounter->lDenItemHandle, &llValue);
                                // the denominator should be a 64-bit timestamp
                                pThisItem->SecondValue = llValue;

                                // look up the timebase freq if necessary
                                if (pCounter->TimeBase == 0) {
                                    assert ((pCounter->lFreqItemType == VT_I8) ||
                                            (pCounter->lFreqItemType == VT_UI8));
                                    pWbemAccess->ReadQWORD (
                                            pCounter->lFreqItemHandle, &llValue);
                                    // the timebase is a 64 bit integer
                                    pCounter->TimeBase = llValue;
                                }
                                break;

                            case PERF_ELAPSED_TIME:
                            case PERF_100NSEC_TIMER:
                            case PERF_100NSEC_TIMER_INV:
                            case PERF_COUNTER_TIMER:
                            case PERF_COUNTER_TIMER_INV:
                            case PERF_COUNTER_BULK_COUNT:
                            case PERF_COUNTER_MULTI_TIMER:
                            case PERF_COUNTER_MULTI_TIMER_INV:
                            case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
                            case PERF_OBJ_TIME_TIMER:
                            case PERF_COUNTER_100NS_QUEUELEN_TYPE:
                            case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
                            case PERF_PRECISION_SYSTEM_TIMER:
                            case PERF_PRECISION_100NS_TIMER:
                            case PERF_PRECISION_OBJECT_TIMER:
                                // this should be a QWORD counter
                                assert ((pCounter->lNumItemType == VT_I8) ||
                                        (pCounter->lNumItemType == VT_UI8));
                                pWbemAccess->ReadQWORD (
                                        pCounter->lNumItemHandle, &llValue);
                                pThisItem->FirstValue = (LONGLONG)(llValue);

                                assert ((pCounter->lDenItemType == VT_I8) ||
                                        (pCounter->lDenItemType == VT_UI8));
                                pWbemAccess->ReadQWORD (
                                        pCounter->lDenItemHandle, &llValue);
                                // the denominator should be a 64-bit timestamp
                                pThisItem->SecondValue = llValue;

                                // look up the timebase freq if necessary
                                if (pCounter->TimeBase == 0) {
                                    assert ((pCounter->lFreqItemType == VT_I8) ||
                                            (pCounter->lFreqItemType == VT_UI8));
                                    pWbemAccess->ReadQWORD (
                                            pCounter->lFreqItemHandle, &llValue);
                                    // the timebase is a 64 bit integer
                                    pCounter->TimeBase = llValue;
                                }
                                break;
                            //
                            //  These counters do not use any time reference
                            //
                            case PERF_COUNTER_RAWCOUNT:
                            case PERF_COUNTER_RAWCOUNT_HEX:
                            case PERF_COUNTER_DELTA:
                                // this should be a DWORD counter
                                assert ((pCounter->lNumItemType == VT_I4) ||
                                        (pCounter->lNumItemType == VT_UI4));
                                pWbemAccess->ReadDWORD (
                                        pCounter->lNumItemHandle, &dwValue);
                                pThisItem->FirstValue = (LONGLONG)(dwValue);
                                pThisItem->SecondValue = 0;
                                break;

                            case PERF_COUNTER_LARGE_RAWCOUNT:
                            case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
                            case PERF_COUNTER_LARGE_DELTA:
                                // this should be a DWORD counter
                                assert ((pCounter->lNumItemType == VT_I8) ||
                                        (pCounter->lNumItemType == VT_UI8));
                                pWbemAccess->ReadQWORD (
                                        pCounter->lNumItemHandle, &llValue);
                                pThisItem->FirstValue = (LONGLONG)(llValue);
                                pThisItem->SecondValue = 0;
                                break;

                            //
                            //  These counters use two data points, the one pointed to by
                            //  pData and the one immediately after
                            //
                            case PERF_SAMPLE_FRACTION:
                            case PERF_RAW_FRACTION:
                                // this should be a DWORD counter
                                assert ((pCounter->lNumItemType == VT_I4) ||
                                        (pCounter->lNumItemType == VT_UI4));
                                pWbemAccess->ReadDWORD (
                                        pCounter->lNumItemHandle, &dwValue);
                                pThisItem->FirstValue = (LONGLONG)dwValue;

                                assert ((pCounter->lDenItemType == VT_I4) ||
                                        (pCounter->lDenItemType == VT_UI4));
                                pWbemAccess->ReadDWORD (
                                        pCounter->lDenItemHandle, &dwValue);
                                // the denominator should be a 32-bit value
                                pThisItem->SecondValue = (LONGLONG)dwValue;
                                break;

                            case PERF_LARGE_RAW_FRACTION:
                                // this should be a DWORD counter
                                assert ((pCounter->lNumItemType == VT_I8) ||
                                        (pCounter->lNumItemType == VT_UI8));
                                pCounter->pWbemAccess->ReadQWORD (
                                    pCounter->lNumItemHandle, & llValue);
                                pCounter->ThisValue.FirstValue = (LONGLONG) llValue;

                                assert ((pCounter->lDenItemType == VT_I8) ||
                                        (pCounter->lDenItemType == VT_UI8));
                                pCounter->pWbemAccess->ReadQWORD (
                                    pCounter->lDenItemHandle, & llValue);
                                // the denominator should be a 32-bit value
                                pCounter->ThisValue.SecondValue = (LONGLONG) llValue;
                            break;

                            case PERF_AVERAGE_TIMER:
                            case PERF_AVERAGE_BULK:
                                // counter (numerator) is a LONGLONG, while the
                                // denominator is just a DWORD
                                // this should be a DWORD counter
                                assert ((pCounter->lNumItemType == VT_I8) ||
                                        (pCounter->lNumItemType == VT_UI8));
                                pWbemAccess->ReadQWORD (
                                        pCounter->lNumItemHandle, &llValue);
                                pThisItem->FirstValue = (LONGLONG)llValue;

                                assert ((pCounter->lDenItemType == VT_I4) ||
                                        (pCounter->lDenItemType == VT_UI4));
                                pWbemAccess->ReadDWORD (
                                        pCounter->lDenItemHandle, &dwValue);
                                // the denominator should be a 32-bit value
                                pThisItem->SecondValue = (LONGLONG)dwValue;

                                // look up the timebase freq if necessary
                                if (pCounter->TimeBase == 0) {
                                    assert ((pCounter->lFreqItemType == VT_I8) ||
                                            (pCounter->lFreqItemType == VT_UI8));
                                    pWbemAccess->ReadQWORD (
                                            pCounter->lFreqItemHandle, &llValue);
                                    // the timebase is a 64 bit integer
                                    pCounter->TimeBase = llValue;
                                }
                                break;
                            //
                            //  These counters are used as the part of another counter
                            //  and as such should not be used, but in case they are
                            //  they'll be handled here.
                            //
                            case PERF_SAMPLE_BASE:
                            case PERF_AVERAGE_BASE:
                            case PERF_COUNTER_MULTI_BASE:
                            case PERF_RAW_BASE:
                            case PERF_LARGE_RAW_BASE:
                                pThisItem->FirstValue = 0;
                                pThisItem->SecondValue = 0;
                                break;

                            //
                            //  These counters are not supported by this function (yet)
                            //
                            case PERF_COUNTER_TEXT:
                            case PERF_COUNTER_NODATA:
                            case PERF_COUNTER_HISTOGRAM_TYPE:
                                pThisItem->FirstValue = 0;
                                pThisItem->SecondValue = 0;
                                break;

                            case PERF_100NSEC_MULTI_TIMER:
                            case PERF_100NSEC_MULTI_TIMER_INV:
                            default:
                                // an unidentified  or unsupported
                                // counter was returned so
                                pThisItem->FirstValue = 0;
                                pThisItem->SecondValue = 0;
                                bReturn = FALSE;
                                break;
                        }
                        // we're done with this one so release it
                        pWbemAccess->Release();
                    }
                    // measure the memory block used
                    assert (dwFinalSize == (DWORD)((LPBYTE)szNextNameString -
                            (LPBYTE)(pCounter->pThisRawItemList)));

                    pCounter->pThisRawItemList->dwLength = dwFinalSize;
                    pCounter->pThisRawItemList->dwItemCount = lNumInstances;
                    pCounter->pThisRawItemList->dwReserved = 0;
                    pCounter->pThisRawItemList->CStatus = ERROR_SUCCESS;

                    pCounter->pThisRawItemList->TimeStamp = *pTimestamp;

                } else {
                    // unable to allocate a new buffer so return error
                    SetLastError (ERROR_OUTOFMEMORY);
                    bReturn = FALSE;
                }
            }
        }
    }
    return bReturn;
}

LONG
GetQueryWbemData (
    IN  PPDHI_QUERY         pQuery,
    IN  LONGLONG            *pllTimeStamp
)
{
    FILETIME            GmtFileTime;
    FILETIME            LocFileTime;
    LONGLONG            llTimeStamp = 0;
    HRESULT             hRes;
    LONG                lRetStatus = ERROR_SUCCESS;\

    PPDHI_COUNTER       pCounter;
    PDH_STATUS          pdhStatus;

    // refresh Wbem Refresher

    if (bDontRefresh) return ERROR_BUSY;

    if (pQuery->pRefresher != NULL) {
        hRes = pQuery->pRefresher->Refresh(0);
    } else {
        hRes = WBEM_E_INITIALIZATION_FAILURE;
    }

    // If multiple objects are being refreshed, some objects may succeed and
    // others may fail, in which case WBEM_S_PARTIAL_RESULTS is returned.

    if ( FAILED( hRes ) ) {
        SetLastError (hRes);
        lRetStatus = PDH_WBEM_ERROR;
    }

    if (lRetStatus == ERROR_SUCCESS) {
        // get timestamp for this counter
        GetSystemTimeAsFileTime(& GmtFileTime);
        FileTimeToLocalFileTime(& GmtFileTime, & LocFileTime);
        llTimeStamp = MAKELONGLONG(LocFileTime.dwLowDateTime,
                                   LocFileTime.dwHighDateTime);

        // now update the counters using this new data
        if ((pCounter = pQuery->pCounterListHead) != NULL) {
            do {
                if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
                    pdhStatus = UpdateWbemMultiInstanceCounterValue (
                        pCounter, (FILETIME *)&llTimeStamp);
                } else {
                    // update single instance counter values
                    pdhStatus = UpdateWbemCounterValue (pCounter,
                        (FILETIME *)&llTimeStamp);
                }
                pCounter = pCounter->next.flink;
            } while (pCounter != pQuery->pCounterListHead);
            pdhStatus = ERROR_SUCCESS;
        } else {
            // no counters in the query  (?!)
            pdhStatus = PDH_NO_DATA;
        }
        lRetStatus = pdhStatus;
    }
    
    *pllTimeStamp = llTimeStamp;

    return lRetStatus;
}

HRESULT WbemSetProxyBlanket(
    IUnknown                 *pInterface,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities )
{
    // Security MUST be set on both the Proxy and it's IUnknown!

    IUnknown * pUnk = NULL;
    IClientSecurity * pCliSec = NULL;
    HRESULT sc = pInterface->QueryInterface(IID_IUnknown, (void **) &pUnk);
    if(sc != S_OK)
        return sc;
    sc = pInterface->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc != S_OK)
    {
        pUnk->Release();
        return sc;
    }
    sc = pCliSec->SetBlanket(pInterface, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
    pCliSec->Release();
    pCliSec = NULL;
    sc = pUnk->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc == S_OK)
    {
        sc = pCliSec->SetBlanket(pUnk, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
            dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
        pCliSec->Release();
    }
    else if (sc == 0x80004002)
        sc = S_OK;
    pUnk->Release();
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\bvt\strings.cpp ===
// strings.cpp
//
// central definition file of common static strings
// these strings SHOULD NOT be localized as they are internal
// to the program and not intended for any display to the user
//
#include "strings.h"

// OLE and  Registry strings
LPCWSTR cszOleRegistryComment   = L"WBEM NT5 Base Perf Provider";
LPCWSTR cszClsidFormatString    = L"Software\\Classes\\CLSID\\\\%s";
LPCWSTR cszThreadingModel       = L"ThreadingModel";
LPCWSTR cszInprocServer         = L"InprocServer32";
LPCWSTR cszClsidKey             = L"Software\\Classes\\CLSID";
LPCWSTR cszPerflibKey           = L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR cszDLLValue             = L"Library";
LPCWSTR cszObjListValue         = L"Object List";
LPCWSTR cszLinkageKey           = L"\\Linkage";
LPCWSTR cszExportValue          = L"Export";
LPCWSTR cszOpenTimeout          = L"Open Timeout";
LPCWSTR cszCollectTimeout       = L"Collect Timeout";
LPCWSTR cszExtCounterTestLevel  = L"ExtCounterTestLevel";
LPCWSTR cszOpenProcedureWaitTime = L"OpenProcedureWaitTime";
LPCWSTR cszLibraryUnloadTime    = L"Library Unload Time";
LPCWSTR cszKeepResident         = L"Keep Library Resident";
LPCWSTR cszDisablePerformanceCounters = L"Disable Performance Counters";
LPCWSTR cszProviderName         = L"NT5_GenericPerfProvider_V1";
LPCWSTR cszHklmServicesKey      = L"SYSTEM\\CurrentControlSet\\Services";
LPCWSTR cszPerformance          = L"\\Performance";
LPCWSTR cszGlobal               = L"Global";
LPCWSTR cszForeign              = L"FOREIGN";
LPCWSTR cszCostly               = L"COSTLY";
LPCWSTR cszCounter              = L"COUNTER";
LPCWSTR cszExplain              = L"EXPLAIN";
LPCWSTR cszHelp                 = L"HELP";
LPCWSTR cszAddCounter           = L"ADDCOUNTER";
LPCWSTR cszAddHelp              = L"ADDEXPLAIN";
LPCWSTR cszOnly                 = L"ONLY";
LPCWSTR cszBoth                 = L"Both";
LPCWSTR cszServiceKeyName       = L"SYSTEM\\CurrentControlSet\\Services";

LPCSTR  caszOpenValue           = "Open";
LPCSTR  caszCloseValue          = "Close";
LPCSTR  caszCollectValue        = "Collect";
LPCSTR  caszQueryValue          = "Query";

// "well known" property names
LPCWSTR cszPropertyCount        = L"__PROPERTY_COUNT";
LPCWSTR cszClassName            = L"__CLASS";
LPCWSTR cszName                 = L"Name";
LPCWSTR cszTimestampPerfTime    = L"Timestamp_PerfTime";
LPCWSTR cszFrequencyPerfTime    = L"Frequency_PerfTime";
LPCWSTR cszTimestampSys100Ns    = L"Timestamp_Sys100NS";
LPCWSTR cszFrequencySys100Ns    = L"Frequency_Sys100NS";
LPCWSTR cszTimestampObject      = L"Timestamp_Object";
LPCWSTR cszFrequencyObject      = L"Frequency_Object";

// "well known" qualifier names
LPCWSTR cszPerfIndex            = L"PerfIndex";
LPCWSTR cszSingleton            = L"Singleton";
LPCWSTR cszCountertype          = L"countertype";
LPCWSTR cszProvider             = L"Provider";
LPCWSTR cszRegistryKey          = L"registrykey";

// other random strings
LPCWSTR cszSpace                = L" ";
LPCWSTR cszSlash                = L"/";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\bvt\strings.h ===
// strings.h
//
// central definition file of common static strings
// these strings SHOULD NOT be localized as they are internal
// to the program and not intended for any display to the user
//
#include "windows.h"

#ifdef __cplusplus
extern "C" {
#endif

// single character constants
#define wcSpace     L' '
#define wcSlash     L'/'
#define wcPoundSign L'#'
#define wc_0        L'0'
#define wc_a        L'a'
#define wc_A        L'A'
#define wc_E        L'E'
#define wc_F        L'F'
#define wc_P        L'P'
#define wc_R        L'R'
#define wc_z        L'z'
   
// OLE and  Registry strings
extern LPCWSTR cszOleRegistryComment;
extern LPCWSTR cszClsidFormatString;
extern LPCWSTR cszThreadingModel;
extern LPCWSTR cszInprocServer;
extern LPCWSTR cszClsidKey;
extern LPCWSTR cszPerflibKey;
extern LPCWSTR cszDLLValue;
extern LPCWSTR cszObjListValue;
extern LPCWSTR cszLinkageKey;
extern LPCWSTR cszExportValue;
extern LPCWSTR cszOpenTimeout;
extern LPCWSTR cszCollectTimeout;
extern LPCWSTR cszExtCounterTestLevel;
extern LPCWSTR cszOpenProcedureWaitTime;
extern LPCWSTR cszLibraryUnloadTime;
extern LPCWSTR cszKeepResident;
extern LPCWSTR cszDisablePerformanceCounters;
extern LPCWSTR cszProviderName;
extern LPCWSTR cszHklmServicesKey;
extern LPCWSTR cszPerformance;
extern LPCWSTR cszGlobal;
extern LPCWSTR cszForeign;
extern LPCWSTR cszCostly;
extern LPCWSTR cszCounter;
extern LPCWSTR cszExplain;
extern LPCWSTR cszHelp;
extern LPCWSTR cszAddCounter;
extern LPCWSTR cszAddHelp;
extern LPCWSTR cszOnly;
extern LPCWSTR cszBoth;
extern LPCWSTR cszServiceKeyName;

extern LPCSTR  caszOpenValue;
extern LPCSTR  caszCloseValue;
extern LPCSTR  caszCollectValue;
extern LPCSTR  caszQueryValue;

// "well known" property names
extern LPCWSTR cszPropertyCount;
extern LPCWSTR cszClassName;
extern LPCWSTR cszName;
extern LPCWSTR cszTimestampPerfTime;
extern LPCWSTR cszFrequencyPerfTime;
extern LPCWSTR cszTimestampSys100Ns;
extern LPCWSTR cszFrequencySys100Ns;
extern LPCWSTR cszTimestampObject;
extern LPCWSTR cszFrequencyObject;

// "well known" qualifier names
extern LPCWSTR cszPerfIndex;
extern LPCWSTR cszSingleton;
extern LPCWSTR cszCountertype;
extern LPCWSTR cszProvider;
extern LPCWSTR cszRegistryKey;

// other random strings
extern LPCWSTR cszSpace;
extern LPCWSTR cszSlash;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\bvt\perfval.h ===
#ifndef _PERFVAL_H_
#define _PERFVAL_H_

#include <winperf.h>

#define WBEMPERF_OPEN_PROC_NOT_FOUND    0xC0100002
#define WBEMPERF_COLLECT_PROC_NOT_FOUND 0xC0100003
#define WBEMPERF_CLOSE_PROC_NOT_FOUND   0xC0100004
#define WBEMPERF_OPEN_PROC_FAILURE      0xC0100005
#define WBEMPERF_OPEN_PROC_EXCEPTION    0xC0100006

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes)
#define ALIGN_ON_DWORD(x) ((VOID *)(((DWORD_PTR)x & 3) ? (((DWORD_PTR)x & ~3) + 4) : ((DWORD_PTR)x)))

#define QWORD_MULTIPLE(x) (((x+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))

//    (assumes quadword is 8 bytes)
#define ALIGN_ON_QWORD(x) ((VOID *)(((DWORD_PTR)x & 7) ? (((DWORD_PTR)x & ~7) + 8) : ((DWORD_PTR)x)))

//
//      constants used by guard page testing
//
#define GUARD_PAGE_SIZE 1024
#define GUARD_PAGE_CHAR 0xA5
#define GUARD_PAGE_DWORD 0xA5A5A5A5

#define  LOG_UNDEFINED  ((LONG)-1)
#define  LOG_NONE       0
#define  LOG_USER       1
#define  LOG_DEBUG      2
#define  LOG_VERBOSE    3

#define     EXT_TEST_UNDEFINED  0
#define     EXT_TEST_ALL        1
#define     EXT_TEST_BASIC      2
#define     EXT_TEST_NONE       3
#define     EXT_TEST_NOMEMALLOC 4

#define WAIT_FOR_AND_LOCK_MUTEX(h) (h != NULL ? WaitForSingleObject(h, 10000) : WAIT_TIMEOUT)
#define RELEASE_MUTEX(h)  (h != NULL ? ReleaseMutex(h) : FALSE)

// convert mS to relative time
#define MakeTimeOutValue(ms) ((LONGLONG)((LONG)(ms) * -10000L))

//
//  Definition of handle table for extensible objects
//
typedef PM_OPEN_PROC    *OPENPROC;
typedef PM_COLLECT_PROC *COLLECTPROC;
typedef PM_QUERY_PROC   *QUERYPROC;
typedef PM_CLOSE_PROC   *CLOSEPROC;

#define EXT_OBJ_INFO_NAME_LENGTH    32

typedef struct _EXT_OBJECT {
        LPVOID      pNext;   // not used
        HANDLE      hMutex;         // sync mutex for this function
        OPENPROC    OpenProc;       // address of the open routine
        LPSTR       szOpenProcName; // open procedure name
        LPWSTR      szLinkageString; // param for open proc
        DWORD       dwOpenTimeout;  // wait time in MS for open proc
        COLLECTPROC CollectProc;    // address of the collect routine
        QUERYPROC   QueryProc;      // address of query proc
        LPSTR       szCollectProcName;  // collect procedure name
        DWORD       dwCollectTimeout;   // wait time in MS for collect proc
        CLOSEPROC   CloseProc;     // address of the close routine
        LPSTR       szCloseProcName;    // close procedure name
        HMODULE     hLibrary ;     // handle returned by LoadLibraryW
        LPWSTR      szLibraryName;  // full path of library
        HKEY        hPerfKey;       // handle to performance sub key fo this service
        DWORD       dwNumObjects;  // number of supported objects
        DWORD       dwObjList[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];    // address of array of supported objects
        DWORD       dwFlags;        // flags
        LPWSTR      szServiceName;  // service name
        LONGLONG    llLastUsedTime; // FILETIME of last access
// Performance statistics
        LONGLONG    llOpenTime;     // total time spent in open procedure
        LONGLONG    llCollectTime;  // time spent in call in 100Ns Units
        DWORD       dwCollectCount; // number of times Collect successfully called
        DWORD       dwOpenCount;    // number of Loads & opens
        DWORD       dwCloseCount;   // number of Unloads & closes
        DWORD       dwLockoutCount; // count of lock timeouts
        DWORD       dwErrorCount;   // count of errors (other than timeouts)
        DWORD       dwExceptionCount; // exceptions
        DWORD       dwLowerGPViolations;
        DWORD       dwUpperGPViolations;
        DWORD       dwBadPointers;
        DWORD       dwBufferSizeErrors;
        DWORD       dwAlignmentErrors;
        DWORD       dwObjectSizeErrors;
        DWORD       dwInstanceSizeErrors;
        DWORD       dwInstanceNameErrors;
        // last function call values
        LONGLONG    llTimeBase;     // time base frequency
        LONGLONG    llFunctionTime; // time spent in last successful call in 100Ns Units
        DWORD       dwNumObjectsRet; // number of objects returned by collect function
        DWORD       dwRetBufSize;   // buffer size returned by function
} EXT_OBJECT , *PEXT_OBJECT ;


// ext object flags
#define PERF_EO_QUERY_FUNC  ((DWORD)0x00000001)     // use query proc
#define PERF_EO_BAD_DLL     ((DWORD)0x00000002)     // true when DLL ret. error
#define PERF_EO_KEEP_RESIDENT ((DWORD)0x00000004)    // true if lib should not be trimmed
#define PERF_EO_OBJ_IN_QUERY ((DWORD)0x80000000)    // true when in query list


typedef struct _EXT_CTR_PERF_DATA {
        // accumulating functions
        LONGLONG    llElapsedTime;  // cumulative time spent in call in 100Ns Units
        DWORD       dwCollectCount; // number of times Collect successfully called
        DWORD       dwOpenCount;    // number of Loads & opens
        DWORD       dwCloseCount;   // number of Unloads & closes
        DWORD       dwLockoutCount; // count of lock timeouts
        DWORD       dwErrorCount;   // count of errors (other than timeouts)
        DWORD       dwExceptionCount; // exceptions
        DWORD       dwLowerGPViolations;
        DWORD       dwUpperGPViolations;
        DWORD       dwBadPointers;
        DWORD       dwBufferSizeErrors;
        DWORD       dwAlignmentErrors;
        DWORD       dwObjectSizeErrors;
        DWORD       dwInstanceSizeErrors;
        DWORD       dwReserved1;
        // last function call values
        LONGLONG    llTimeBase;     // time base frequency
        LONGLONG    llFunctionTime; // time spent in call in 100Ns Units
        DWORD       dwNumObjects;   // number of objects returned by collect function
        DWORD       dwRetBufSize;   // buffer size returned by function
} EXT_CTR_PERF_DATA, *PEXT_CTR_PERF_DATA;

typedef struct _OPEN_PROC_WAIT_INFO {
    struct _OPEN_PROC_WAIT_INFO *pNext;
    LPWSTR  szLibraryName;
    LPWSTR  szServiceName;
    DWORD   dwWaitTime;
    DWORD   dwEventMsg;
    LPVOID  pData;
} OPEN_PROC_WAIT_INFO, FAR * LPOPEN_PROC_WAIT_INFO;

#define NextObject(pObject)            \
   ((PERF_OBJECT_TYPE *) ((PBYTE) pObject + pObject->TotalByteLength))

#define FirstCounter(pObjectDef)       \
   ((PERF_COUNTER_DEFINITION *) ((PCHAR)pObjectDef + pObjectDef->HeaderLength))

#define NextCounter(pCounterDef)       \
   ((PERF_COUNTER_DEFINITION *) ((PCHAR)pCounterDef + pCounterDef->ByteLength))

#endif //_PERFVAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\perfmon5\perfmon5.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    perfmon5.c

Abstract:

    Program to adapt the command line Perfmon from NT4 and prior
        to the MMC & NT5 compatible format

Author:

    Bob Watson (bobw) 11 may 99

Revision History:

--*/
#define _OUTPUT_HTML    1
//#define _DBG_MSG_PRINT  1 
#define _USE_MMC 1

#define MAXSTR      512

#include "perfmon5.h"

// static & global variables
#ifdef _USE_MMC
static LPCWSTR szMmcExeCmd= (LPCWSTR)L"%windir%\\system32\\mmc.exe";
static LPCWSTR szMmcExeArg= (LPCWSTR)L" %windir%\\system32\\perfmon.msc /s";
#else
static LPCWSTR szMmcExeCmd= (LPCWSTR)L"%windir%\\explorer.exe";
static LPCWSTR szMmcExeArg= (LPCWSTR)L" ";
#endif
static LPCWSTR szMmcExeSetsArg= (LPCWSTR)L"/SYSMON%ws_SETTINGS \"%ws\"";
static LPCWSTR szMmcExeSetsLogOpt= (LPCWSTR)L"LOG";
static LPCWSTR szEmpty= (LPCWSTR)L"";

//HTML Formatting definitions
// these are not localized
LPCWSTR szHtmlHeader = (LPCWSTR)L"\
<HTML>\r\n\
<HEAD>\r\n\
<META NAME=\"GENERATOR\"  Content=\"Microsoft System Monitor\">\r\n\
<META HTTP-EQUIV=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\r\n\
</HEAD><BODY  bgcolor=\"#%6.6x\">\r\n";

LPCWSTR szObjectHeader = (LPCWSTR)L"\
<OBJECT ID=\"%s\" WIDTH=\"100%%\" HEIGHT=\"100%%\"\r\n\
    CLASSID=\"CLSID:C4D2D8E0-D1DD-11CE-940F-008029004347\">\r\n\
    <PARAM NAME=\"Version\" VALUE=\"196611\"\r\n";

LPCWSTR szObjectFooter = (LPCWSTR)L"\
</OBJECT>\r\n";

LPCWSTR szHtmlFooter = (LPCWSTR)L"\
</BODY>\r\n\
</HTML>\r\n";

LPCWSTR szHtmlDecimalParamFmt    = (LPCWSTR)L"    <PARAM NAME=\"%s\" VALUE=\"%d\">\r\n";
LPCWSTR szHtmlStringParamFmt     = (LPCWSTR)L"    <PARAM NAME=\"%s\" VALUE=\"%s\">\r\n";
LPCWSTR szHtmlWideStringParamFmt = (LPCWSTR)L"    <PARAM NAME=\"%s\" VALUE=\"%ws\">\r\n";
LPCWSTR szHtmlLineDecimalParamFmt = (LPCWSTR)L"    <PARAM NAME=\"Counter%5.5d.%s\" VALUE=\"%d\">\r\n";
LPCWSTR szHtmlLineRealParamFmt    = (LPCWSTR)L"    <PARAM NAME=\"Counter%5.5d.%s\" VALUE=\"%f\">\r\n";
LPCWSTR szHtmlLineStringParamFmt  = (LPCWSTR)L"    <PARAM NAME=\"Counter%5.5d.%s\" VALUE=\"%s\">\r\n";

LPCWSTR szSingleObjectName      = (LPCWSTR)L"SystemMonitor1";
LPCWSTR szSysmonControlIdFmt    = (LPCWSTR)L"SysmonControl%d";
// CODE STARTS HERE

LPWSTR
DiskStringRead (
               PDISKSTRING pDS
               )
{
    LPWSTR  szReturnString = NULL;

    if (pDS->dwLength == 0) {
        szReturnString = NULL;
    } else {
        szReturnString = HeapAlloc (GetProcessHeap(), 0, ((pDS->dwLength + 1) * sizeof (WCHAR)));
        if (szReturnString) {
            wcsncpy (szReturnString, (WCHAR *)((PBYTE) pDS + pDS->dwOffset),
                  pDS->dwLength) ;
            szReturnString[pDS->dwLength] = 0;
        }
    }

    return (szReturnString) ;
}

static
BOOL 
FileRead (HANDLE   hFile,
               LPVOID   lpMemory,
               DWORD    nAmtToRead)
{  // FileRead
   BOOL           bSuccess ;
   DWORD          nAmtRead ;

   bSuccess = ReadFile (hFile, lpMemory, nAmtToRead, &nAmtRead, NULL) ;
   return (bSuccess && (nAmtRead == nAmtToRead)) ;
}  // FileRead

BOOL
ReadLogLine (
         HANDLE hFile,
         FILE   *fOutFile,
         LPDWORD pdwLineNo,
         DWORD  dwInFileType,
         PDISKLINE  *ppDiskLine,
         DWORD *pSizeofDiskLine
)
/*
   Effect:        Read in a line from the file hFile, at the current file
                  position.

   Internals:     The very first characters are a line signature, then a
                  length integer. If the signature is correct, then allocate
                  the length amount, and work with that.
*/
{
#ifdef _OUTPUT_HTML
    PDH_COUNTER_PATH_ELEMENTS_W pdhPathElem;
    WCHAR           wszCounterPath[1024];
    PDH_STATUS      pdhStatus;
    DWORD           dwCounterPathSize = (sizeof(wszCounterPath)/sizeof(wszCounterPath[0])); 
#endif
    LOGENTRY        LogEntry;

    UNREFERENCED_PARAMETER (dwInFileType);    
    UNREFERENCED_PARAMETER (ppDiskLine);    
    UNREFERENCED_PARAMETER (pSizeofDiskLine);    

    //=============================//
    // read and compare signature  //
    //=============================//

    if (!FileRead (hFile, &LogEntry, sizeof(LOGENTRY)-sizeof(LogEntry.pNextLogEntry)))
        return (FALSE) ;


#ifdef _OUTPUT_HTML
    // expand log entry into counters: not this may not always work!
    if (lstrcmpW(LogEntry.szComputer, (LPCWSTR)L"....") != 0) {
        // then add the machine name
        pdhPathElem.szMachineName = LogEntry.szComputer;
    } else {
        pdhPathElem.szMachineName = NULL;
    }
    pdhPathElem.szObjectName = LogEntry.szObject;
    pdhPathElem.szInstanceName = (LPWSTR)L"*";
    pdhPathElem.szParentInstance = NULL;
    pdhPathElem.dwInstanceIndex = (DWORD)-1;
    pdhPathElem.szCounterName = (LPWSTR)L"*";

    pdhStatus = PdhMakeCounterPathW (
        &pdhPathElem,
        wszCounterPath,
        &dwCounterPathSize,
        0);

    fwprintf (fOutFile, szHtmlLineStringParamFmt, *pdwLineNo, (LPCWSTR)L"Path", wszCounterPath);
    
    *pdwLineNo = *pdwLineNo + 1;   // increment the line no

#else
    fprintf (fOutFile, "\n    Line[%3.3d].ObjectTitleIndex = %d",       *pdwLineNo, LogEntry.ObjectTitleIndex);
    fprintf (fOutFile, "\n    Line[%3.3d].szComputer = %ws",            *pdwLineNo, LogEntry.szComputer);
    fprintf (fOutFile, "\n    Line[%3.3d].szObject = %ws",              *pdwLineNo, LogEntry.szObject);
    fprintf (fOutFile, "\n    Line[%3.3d].bSaveCurrentName = %d",       *pdwLineNo, LogEntry.bSaveCurrentName);
    *pdwLineNo = *pdwLineNo + 1;   // increment the line no
#endif


    return TRUE;
}

BOOL
ReadLine (
         HANDLE hFile,
         FILE   *fOutFile,
         LPDWORD pdwLineNo,
         DWORD  dwInFileType,
         PDISKLINE  *ppDiskLine,
         DWORD *pSizeofDiskLine
)
/*
   Effect:        Read in a line from the file hFile, at the current file
                  position.

   Internals:     The very first characters are a line signature, then a
                  length integer. If the signature is correct, then allocate
                  the length amount, and work with that.
*/
{
    PDISKLINE       pDiskLine = NULL ;
    DWORD           dwLineNo = *pdwLineNo;

#ifdef _OUTPUT_HTML
    double          dScaleFactor;
    PDH_STATUS      pdhStatus;
    PDH_COUNTER_PATH_ELEMENTS_W pdhPathElem;
    WCHAR           wszCounterPath[1024];
    DWORD           dwCounterPathSize = (sizeof(wszCounterPath)/sizeof(wszCounterPath[0])); 
#else
    LPWSTR          szTempString;
#endif

    struct {
        DWORD             dwSignature ;
        DWORD             dwLength ;
    } LineHeader ;

    //=============================//
    // read and compare signature  //
    //=============================//

    if (!FileRead (hFile, &LineHeader, sizeof (LineHeader)))
        return (FALSE) ;


    if (LineHeader.dwSignature != dwLineSignature ||
        LineHeader.dwLength == 0) {
        SetLastError (ERROR_BAD_FORMAT) ;
        return (FALSE) ;
    }

    //=============================//
    // read and allocate length    //
    //=============================//

    //   if (!FileRead (hFile, &dwLength, sizeof (dwLength)) || dwLength == 0)
    //      return (NULL) ;

    // check if we need a bigger buffer,
    // normally, it should be the same except the first time...
    if (LineHeader.dwLength > *pSizeofDiskLine) {
        if (*ppDiskLine) {
            // free the previous buffer
            HeapFree (GetProcessHeap(), 0, *ppDiskLine);
            *pSizeofDiskLine = 0 ;
        }

        // re-allocate a new buffer
        *ppDiskLine = (PDISKLINE) HeapAlloc(GetProcessHeap(), 0, LineHeader.dwLength) ;
        if (!(*ppDiskLine)) {
            // no memory, should flag an error...
            return (FALSE) ;
        }
        *pSizeofDiskLine = LineHeader.dwLength ;
    }

    pDiskLine = *ppDiskLine ;


    //=============================//
    // copy diskline, alloc line   //
    //=============================//

    if (!FileRead (hFile, pDiskLine, LineHeader.dwLength))
        return (FALSE) ;

#ifdef _OUTPUT_HTML

    // HTML output requires 1 based indexes, not 0 based
    dwLineNo += 1;

    // make counter path string out of components
    pdhPathElem.szMachineName = DiskStringRead (&(pDiskLine->dsSystemName));
    if (   pdhPathElem.szMachineName != NULL
        && lstrcmpW (pdhPathElem.szMachineName, (LPCWSTR)L"....") == 0) {
        // then use local machine
        HeapFree (GetProcessHeap(), 0, pdhPathElem.szMachineName);
        pdhPathElem.szMachineName  = NULL;
    }
    pdhPathElem.szObjectName = DiskStringRead (&(pDiskLine->dsObjectName));
    if (pDiskLine->dwUniqueID != PERF_NO_UNIQUE_ID) {
        pdhPathElem.szInstanceName = HeapAlloc (GetProcessHeap(), 0, 64);
        if (pdhPathElem.szInstanceName != NULL) {
            _ltow (pDiskLine->dwUniqueID, pdhPathElem.szInstanceName, 10);
        }
    } else {
        pdhPathElem.szInstanceName = DiskStringRead (&(pDiskLine->dsInstanceName));
    }
    pdhPathElem.szParentInstance = DiskStringRead (&(pDiskLine->dsPINName));
    pdhPathElem.dwInstanceIndex = (DWORD)-1;
    pdhPathElem.szCounterName = DiskStringRead (&(pDiskLine->dsCounterName));
    pdhStatus = PdhMakeCounterPathW (&pdhPathElem,
        wszCounterPath, &dwCounterPathSize, 0);

    if (pdhStatus == ERROR_SUCCESS) {
        fwprintf (fOutFile, szHtmlLineStringParamFmt, dwLineNo, (LPCWSTR)L"Path", wszCounterPath);
        if (dwInFileType == PMC_FILE) {
            //fwprintf (fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR)L"ScaleFactor", pDiskLine->iScaleIndex);
            dScaleFactor = log10 (pDiskLine->eScale);
            dScaleFactor += 0.5;
            dScaleFactor = floor (dScaleFactor);
            fwprintf (fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR)L"ScaleFactor", (LONG)dScaleFactor);
            fwprintf (fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR)L"Color", *(DWORD *)&pDiskLine->Visual.crColor);
            fwprintf (fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR)L"LineStyle", pDiskLine->Visual.iStyle );
            fwprintf (fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR)L"Width", pDiskLine->Visual.iWidth);
        }

        if (dwInFileType == PMA_FILE) {
            fwprintf (fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR)L"AlertOverUnder", pDiskLine->bAlertOver);
            fwprintf (fOutFile, szHtmlLineRealParamFmt, dwLineNo, (LPCWSTR)L"AlertThreshold", pDiskLine->eAlertValue);
            fwprintf (fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR)L"Color", *(DWORD *)&pDiskLine->Visual.crColor);
        }
    }

    if (pdhPathElem.szMachineName) HeapFree (GetProcessHeap(), 0, pdhPathElem.szMachineName);
    if (pdhPathElem.szObjectName) HeapFree (GetProcessHeap(), 0, pdhPathElem.szObjectName); 
    if (pdhPathElem.szInstanceName) HeapFree (GetProcessHeap(), 0, pdhPathElem.szInstanceName);
    if (pdhPathElem.szParentInstance) HeapFree (GetProcessHeap(), 0, pdhPathElem.szParentInstance);
    if (pdhPathElem.szCounterName) HeapFree (GetProcessHeap(), 0, pdhPathElem.szCounterName);
#else
    UNREFERENCED_PARAMETER (dwInFileType);
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].iLineType = %d",         dwLineNo, pDiskLine->iLineType);
    szTempString = DiskStringRead (&(pDiskLine->dsSystemName));
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].dsSystmeName = %ws",     dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    if (szTempString != NULL) HeapFree (GetProcessHeap(), 0, szTempString);
    szTempString = DiskStringRead (&(pDiskLine->dsObjectName));
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].dsObjectName = %ws",     dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    if (szTempString != NULL) HeapFree (GetProcessHeap(), 0, szTempString);
    szTempString = DiskStringRead (&(pDiskLine->dsCounterName));
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].dsCounterName = %ws",    dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    if (szTempString != NULL) HeapFree (GetProcessHeap(), 0, szTempString);
    szTempString = DiskStringRead (&(pDiskLine->dsInstanceName));
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].dsInstanceName = %ws",   dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    if (szTempString != NULL) HeapFree (GetProcessHeap(), 0, szTempString);
    szTempString = DiskStringRead (&(pDiskLine->dsPINName));
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].dsPINName = %ws",        dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    if (szTempString != NULL) HeapFree (GetProcessHeap(), 0, szTempString);
    szTempString = DiskStringRead (&(pDiskLine->dsParentObjName));
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].dsParentObjName = %ws",  dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    if (szTempString != NULL) HeapFree (GetProcessHeap(), 0, szTempString);
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].dwUniqueID = 0x%8.8x",   dwLineNo, pDiskLine->dwUniqueID);
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].iScaleIndex = %d",       dwLineNo, pDiskLine->iScaleIndex);
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].eScale = %e",            dwLineNo, pDiskLine->eScale);
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].bAlertOver = %d",        dwLineNo, pDiskLine->bAlertOver);
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].eAlertValue = %e",       dwLineNo, pDiskLine->eAlertValue);
    szTempString = DiskStringRead (&(pDiskLine->dsAlertProgram));
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].dsAlertProgram = %ws",   dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    if (szTempString != NULL) HeapFree (GetProcessHeap(), 0, szTempString);
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].bEveryTime = %d",        dwLineNo, pDiskLine->bEveryTime);
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].LV.crColor = 0x%8.8x",   dwLineNo, *(DWORD *)&pDiskLine->Visual.crColor) ;
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].LV.iColorIndex = %d",    dwLineNo, pDiskLine->Visual.iColorIndex );
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].LV.iStyle = %d",         dwLineNo, pDiskLine->Visual.iStyle );
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].LV.iStyleIndex = %d",    dwLineNo, pDiskLine->Visual.iStyleIndex );
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].LV.iWidth = %d",         dwLineNo, pDiskLine->Visual.iWidth );
    fwprintf (fOutFile, (LPCWSTR)L"\n    Line[%3.3d].LV.iWidthIndex = %d",    dwLineNo, pDiskLine->Visual.iWidthIndex );
#endif

    return TRUE;
}
void
ReadLines (
          HANDLE hFile,
          FILE      *fOutFile,
          DWORD dwFileType,
          DWORD dwNumLines
)
{
    DWORD          i ;
    PDISKLINE      pDiskLine = NULL ;
    DWORD          SizeofDiskLine = 0 ;  // bytes in pDiskLine
    DWORD          dwLogLineNo;


    pDiskLine = HeapAlloc (GetProcessHeap(),0, MAX_PATH) ;
    if (!pDiskLine) {
        return ;
    }

    SizeofDiskLine = MAX_PATH;

    for (i = 0, dwLogLineNo = 1;
        i < dwNumLines ;
        i++) {
        if (dwFileType == PML_FILE) {
            ReadLogLine (hFile, fOutFile, &dwLogLineNo, dwFileType, &pDiskLine, &SizeofDiskLine) ;
        } else {
            ReadLine (hFile, fOutFile, &i, dwFileType, &pDiskLine, &SizeofDiskLine) ;
        }
    }

    if (pDiskLine) {
        HeapFree (GetProcessHeap(), 0, pDiskLine);
    }
}

BOOL 
OpenAlert (
    LPCWSTR szInFileName,
    HANDLE  hFile,
    FILE    * fOutFile,
    LPCWSTR szObjectName
)
{  // OpenAlert
    DISKALERT       DiskAlert ;
    BOOL            bSuccess = TRUE ;
    DWORD           dwLocalActionFlags = 0;

#ifdef _OUTPUT_HTML
    WCHAR           szComment[MAX_PATH];

    WCHAR   path[_MAX_PATH];
    WCHAR   drive[_MAX_DRIVE];
    WCHAR   dir[_MAX_DIR];
    WCHAR   fname[_MAX_FNAME];
    WCHAR   ext[_MAX_EXT];
#endif

    // read the next section if valid
    bSuccess = FileRead (hFile, &DiskAlert, sizeof (DISKALERT));

    if (bSuccess) {
#ifdef _OUTPUT_HTML
        if (DiskAlert.dwNumLines > 0) {
            fwprintf (fOutFile, szObjectHeader, szObjectName);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ManualUpdate", DiskAlert.bManualRefresh);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ShowToolbar", DiskAlert.perfmonOptions.bMenubar);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"UpdateInterval", (int)DiskAlert.dwIntervalSecs / 1000);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"SampleIntervalUnitType", 1); // Seconds
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"SampleIntervalValue", (int)DiskAlert.dwIntervalSecs / 1000);
            fwprintf (fOutFile, szHtmlStringParamFmt,  (LPCWSTR)L"CommandFile", "");
            fwprintf (fOutFile, szHtmlStringParamFmt,  (LPCWSTR)L"UserText", "");
            fwprintf (fOutFile, szHtmlStringParamFmt,  (LPCWSTR)L"PerfLogName", "");
        
            dwLocalActionFlags |= 1;            // perfmon normally logs to the UI, but we don't have one
                                                // so log to the event log by default
            if (DiskAlert.bNetworkAlert) {
                dwLocalActionFlags |= 2;
            }
            // perfmon does 1 net name per alert. we do 1 per file so leave it blank
            fwprintf (fOutFile, szHtmlStringParamFmt,  (LPCWSTR)L"NetworkName", "");

            dwLocalActionFlags |= 0x00003F00;   // command line flags
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ActionFlags",dwLocalActionFlags);

            // set the defaults to duplicate a perfmon log
            _wfullpath (path, szInFileName, _MAX_PATH);
            _wsplitpath (path, drive, dir, fname, ext);
            fwprintf (fOutFile, szHtmlWideStringParamFmt, (LPCWSTR)L"AlertName", fname);
            swprintf (szComment, (LPCWSTR)L"Created from Perfmon Settings File \"%ws%ws\"", fname, ext);
            fwprintf (fOutFile, szHtmlStringParamFmt, (LPCWSTR)L"Comment", szComment);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"LogType", 2); // Sysmon alert
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"LogFileMaxSize", -1); // no size limit
            fwprintf (fOutFile, szHtmlWideStringParamFmt, (LPCWSTR)L"LogFileBaseName", fname);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"LogFileSerialNumber", 1);
            swprintf (szComment, (LPCWSTR)L"%ws%ws", drive, dir);
            fwprintf (fOutFile, szHtmlWideStringParamFmt, (LPCWSTR)L"LogFileFolder", szComment);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"LogFileAutoFormat",  0); //no auto name
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"LogFileType", 2); // PDH binary counter log 
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"StartMode", 0); // manual start
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"StopMode", 0); // manual stop
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"RestartMode", 0); // no restart
            fwprintf (fOutFile, szHtmlStringParamFmt, (LPCWSTR)L"EOFCommandFile", "");

            // Get ready to list the counters
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"CounterCount", DiskAlert.dwNumLines);
        }
#else // output text
        UNREFERENCED_PARAMETER (szInFileName);
        UNREFERENCED_PARAMETER (szOutFileName);

        // dump settings file header
        fOutFile = stdout;
        fprintf (fOutFile, "\nDA.dwNumLines = %d",         DiskAlert.dwNumLines);
        fprintf (fOutFile, "\nDA.dwIntervalSecs = %d",     DiskAlert.dwIntervalSecs);
        fprintf (fOutFile, "\nDA.bManualRefresh  = %d",    DiskAlert.bManualRefresh);
        fprintf (fOutFile, "\nDA.bSwitchToAlert = %d",     DiskAlert.bSwitchToAlert);
        fprintf (fOutFile, "\nDA.bNetworkAlert = %d",      DiskAlert.bNetworkAlert);
        fprintf (fOutFile, "\nDA.MessageName = %16.16ws",  DiskAlert.MessageName);
        fprintf (fOutFile, "\nDA.MiscOptions = 0x%8.8x",   DiskAlert.MiscOptions);
        fprintf (fOutFile, "\nDA.LV.crColor = 0x%8.8x",    *(DWORD *)&DiskAlert.Visual.crColor) ;
        fprintf (fOutFile, "\nDA.LV.iColorIndex = %d",     DiskAlert.Visual.iColorIndex );
        fprintf (fOutFile, "\nDA.LV.iStyle = %d",          DiskAlert.Visual.iStyle );
        fprintf (fOutFile, "\nDA.LV.iStyleIndex = %d",     DiskAlert.Visual.iStyleIndex );
        fprintf (fOutFile, "\nDA.LV.iWidth = %d",          DiskAlert.Visual.iWidth );
        fprintf (fOutFile, "\nDA.LV.iWidthIndex = %d",     DiskAlert.Visual.iWidthIndex );
        fprintf (fOutFile, "\nDA.PO.bMenubar  = %d",        DiskAlert.perfmonOptions.bMenubar );
        fprintf (fOutFile, "\nDA.PO.bToolbar   = %d",        DiskAlert.perfmonOptions.bToolbar  );
        fprintf (fOutFile, "\nDA.PO.bStatusbar   = %d",        DiskAlert.perfmonOptions.bStatusbar  );
        fprintf (fOutFile, "\nDA.PO.bAlwaysOnTop   = %d",        DiskAlert.perfmonOptions.bAlwaysOnTop  );
#endif
    }
    if ((bSuccess) && (DiskAlert.dwNumLines > 0)) {
        ReadLines (hFile, fOutFile, PMA_FILE, DiskAlert.dwNumLines);
#ifdef _OUTPUT_HTML
        fwprintf (fOutFile, szObjectFooter);
#endif
    }

    return (bSuccess) ;

}  // OpenAlert

BOOL 
OpenLog (
    LPCWSTR szInFileName,
    HANDLE  hFile,
    FILE    * fOutFile,
    LPCWSTR szObjectName
)
{  // OpenLog
    DISKLOG         DiskLog ;
    BOOL            bSuccess = TRUE ;

#ifdef _OUTPUT_HTML
    WCHAR           szComment[MAX_PATH];
    
    WCHAR           path[_MAX_PATH];
    WCHAR           drive[_MAX_DRIVE];
    WCHAR           dir[_MAX_DIR];
    WCHAR           fname[_MAX_FNAME];
    WCHAR           ext[_MAX_EXT];
#endif

    // read the next section if valid
    bSuccess = FileRead (hFile, &DiskLog, sizeof (DISKLOG));

    if (bSuccess) {
#ifdef _OUTPUT_HTML
        if (DiskLog.dwNumLines > 0) {
            fwprintf (fOutFile, szObjectHeader, szObjectName);

            // dump settings file header
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ManualUpdate", DiskLog.bManualRefresh);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"UpdateInterval", (int)DiskLog.dwIntervalSecs / 1000);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"SampleIntervalUnitType", 1); // Seconds
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"SampleIntervalValue", (int)DiskLog.dwIntervalSecs / 1000);
            fwprintf (fOutFile, szHtmlWideStringParamFmt, (LPCWSTR)L"LogFileName", DiskLog.LogFileName);

            // set the defaults to duplicate a perfmon log
            _wfullpath (path, szInFileName, _MAX_PATH);
            _wsplitpath (path, drive, dir, fname, ext);
            fwprintf (fOutFile, szHtmlWideStringParamFmt, (LPCWSTR)L"LogName", fname);
            swprintf (szComment, (LPCWSTR)L"Created from Perfmon Settings File \"%ws%ws\"", fname, ext);
            fwprintf (fOutFile, szHtmlStringParamFmt, (LPCWSTR)L"Comment", szComment);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"LogType", 0); // PDH counter log 
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"LogFileMaxSize", -1); // no size limit
            fwprintf (fOutFile, szHtmlWideStringParamFmt, (LPCWSTR)L"LogFileBaseName", fname);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"LogFileSerialNumber", 1);
            swprintf (szComment, (LPCWSTR)L"%ws%ws", drive, dir);
            fwprintf (fOutFile, szHtmlWideStringParamFmt, (LPCWSTR)L"LogFileFolder", szComment);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"LogFileAutoFormat",  0); //no auto name
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"LogFileType", 2); // PDH binary counter log 
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"StartMode", 0); // manual start
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"StopMode", 0); // manual stop
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"RestartMode", 0); // no restart
            fwprintf (fOutFile, szHtmlStringParamFmt, (LPCWSTR)L"EOFCommandFile", "");

            // Get ready to list the counters
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"CounterCount", DiskLog.dwNumLines);
        }
#else // output text
        UNREFERENCED_PARAMETER (szInFileName);

        // dump settings file header
        fOutFile = stdout;
        fprintf (fOutFile, "\nDL.dwNumLines = %d",         DiskLog.dwNumLines);
        fprintf (fOutFile, "\nDL.bManualRefresh  = %d",    DiskLog.bManualRefresh);
        fprintf (fOutFile, "\nDL.dwIntervalSecs  = %d",    DiskLog.dwIntervalSecs);
        fprintf (fOutFile, "\nDL.LogFileName = %ws",       DiskLog.LogFileName);
        fprintf (fOutFile, "\nDC.PO.bMenubar  = %d",        DiskLog.perfmonOptions.bMenubar );
        fprintf (fOutFile, "\nDC.PO.bToolbar   = %d",        DiskLog.perfmonOptions.bToolbar  );
        fprintf (fOutFile, "\nDC.PO.bStatusbar   = %d",        DiskLog.perfmonOptions.bStatusbar  );
        fprintf (fOutFile, "\nDC.PO.bAlwaysOnTop   = %d",        DiskLog.perfmonOptions.bAlwaysOnTop  );
#endif
    }
    if ((bSuccess) && (DiskLog.dwNumLines > 0)) {
        //the log settings file requires a special function to read the lines from
        ReadLines (hFile, fOutFile, PML_FILE, DiskLog.dwNumLines);
#ifdef _OUTPUT_HTML
        fwprintf (fOutFile, szObjectFooter);
#endif
    }

    return (bSuccess) ;

}  // OpenLog


BOOL 
OpenReport (
    HANDLE  hFile,
    FILE    * fOutFile,
    LPCWSTR szObjectName
)
{  // OpenReport 
    DISKREPORT      DiskReport ;
    BOOL            bSuccess = TRUE ;
    DWORD           dwColor;

    // read the next section if valid
    bSuccess = FileRead (hFile, &DiskReport, sizeof (DISKREPORT));

    if (bSuccess) {
#ifdef _OUTPUT_HTML
        if (DiskReport.dwNumLines > 0) {
            // dump settings file header
            fwprintf (fOutFile, szObjectHeader, szObjectName);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ManualUpdate", DiskReport.bManualRefresh);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ShowToolbar", DiskReport.perfmonOptions.bToolbar);
            // report intervals are reported in mS
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"UpdateInterval", (int)DiskReport.dwIntervalSecs/1000);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"DisplayType", 3); // report type
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ReportValueType", 0); // default display value

            // derive the following from the current windows environment
            dwColor = GetSysColor (COLOR_WINDOW);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"BackColor", dwColor);
            dwColor = GetSysColor (COLOR_3DFACE);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"BackColorCtl", dwColor);

            dwColor = GetSysColor(COLOR_BTNTEXT);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ForeColor", dwColor);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"GridColor", dwColor);

            dwColor = 0x00FF0000; // red
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"TimeBarColor", dwColor);
    
            // other perfmon settings that are assumed by perfmon but 
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"Appearance", 1);    // 3d appearance
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"BorderStyle", 0);   // no border        

            // Get ready to list the counters
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"CounterCount", DiskReport.dwNumLines);
        } // else no counters to dump
#else // output text
        // dump settings file header
        fprintf (fOutFile, "\nDR.dwNumLines = %d",         DiskReport.dwNumLines);
        fprintf (fOutFile, "\nDR.bManualRefresh  = %d",    DiskReport.bManualRefresh);
        fprintf (fOutFile, "\nDC.dwIntervalSecs  = %d",    DiskReport.dwIntervalSecs);
        fprintf (fOutFile, "\nDR.LV.crColor = 0x%8.8x",    *(DWORD *)&DiskReport.Visual.crColor) ;
        fprintf (fOutFile, "\nDR.LV.iColorIndex = %d",     DiskReport.Visual.iColorIndex );
        fprintf (fOutFile, "\nDR.LV.iStyle = %d",          DiskReport.Visual.iStyle );
        fprintf (fOutFile, "\nDR.LV.iStyleIndex = %d",     DiskReport.Visual.iStyleIndex );
        fprintf (fOutFile, "\nDR.LV.iWidth = %d",          DiskReport.Visual.iWidth );
        fprintf (fOutFile, "\nDR.LV.iWidthIndex = %d",     DiskReport.Visual.iWidthIndex );
        fprintf (fOutFile, "\nDC.PO.bMenubar  = %d",        DiskReport.perfmonOptions.bMenubar );
        fprintf (fOutFile, "\nDC.PO.bToolbar   = %d",        DiskReport.perfmonOptions.bToolbar  );
        fprintf (fOutFile, "\nDC.PO.bStatusbar   = %d",        DiskReport.perfmonOptions.bStatusbar  );
        fprintf (fOutFile, "\nDC.PO.bAlwaysOnTop   = %d",        DiskReport.perfmonOptions.bAlwaysOnTop  );
#endif
    }
    if ((bSuccess) && (DiskReport.dwNumLines > 0)) {
       ReadLines (hFile, fOutFile, PMR_FILE, DiskReport.dwNumLines);
#ifdef _OUTPUT_HTML
       fwprintf (fOutFile, szObjectFooter);
#endif
    }

    return (bSuccess) ;

}  // OpenReport 


BOOL 
OpenChart (
    HANDLE  hFile,
    FILE    * fOutFile,
    LPCWSTR szObjectName
)
{  // OpenChart
    DISKCHART       DiskChart ;
    BOOL            bSuccess = TRUE ;
    DWORD           dwColor;

    // read the next section if valid
    bSuccess = FileRead (hFile, &DiskChart, sizeof (DISKCHART));

    if (bSuccess) {
#ifdef _OUTPUT_HTML
        if (DiskChart.dwNumLines > 0) {
            // dump settings file header
            fwprintf (fOutFile, szObjectHeader, szObjectName);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ManualUpdate", DiskChart.bManualRefresh);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ShowLegend", DiskChart.gOptions.bLegendChecked);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ShowScaleLabels", DiskChart.gOptions.bLabelsChecked);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ShowVerticalGrid", DiskChart.gOptions.bVertGridChecked);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ShowHorizontalGrid", DiskChart.gOptions.bHorzGridChecked);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ShowToolbar", DiskChart.gOptions.bMenuChecked);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"MaximumScale", DiskChart.gOptions.iVertMax);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"UpdateInterval", (int)DiskChart.gOptions.eTimeInterval);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"DisplayType", (DiskChart.gOptions.iGraphOrHistogram == BAR_GRAPH ? 2 : 1));

            // derive the following from the current windows environment
            dwColor = GetSysColor (COLOR_3DFACE);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"BackColor", dwColor);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"BackColorCtl", dwColor);

            dwColor = GetSysColor(COLOR_BTNTEXT);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"ForeColor", dwColor);
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"GridColor", dwColor);

            dwColor = 0x00FF0000; // red
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"TimeBarColor", dwColor);
    
            // other perfmon settings that are assumed by perfmon but 
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"Appearance", 1);    // 3d appearance
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"BorderStyle", 0);   // no border        

            // Get ready to list the counters
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR)L"CounterCount", DiskChart.dwNumLines);
        } // else no counters to display
#else // output text
        // dump settings file header
        fprintf (fOutFile, "\nDC.dwNumLines = %d",         DiskChart.dwNumLines);
        fprintf (fOutFile, "\nDC.gMaxValues = %d",         DiskChart.gMaxValues);
        fprintf (fOutFile, "\nDC.bManualRefresh  = %d",    DiskChart.bManualRefresh);
        fprintf (fOutFile, "\nDC.LV.crColor = 0x%8.8x",    *(DWORD *)&DiskChart.Visual.crColor) ;
        fprintf (fOutFile, "\nDC.LV.iColorIndex = %d",     DiskChart.Visual.iColorIndex );
        fprintf (fOutFile, "\nDC.LV.iStyle = %d",          DiskChart.Visual.iStyle );
        fprintf (fOutFile, "\nDC.LV.iStyleIndex = %d",     DiskChart.Visual.iStyleIndex );
        fprintf (fOutFile, "\nDC.LV.iWidth = %d",          DiskChart.Visual.iWidth );
        fprintf (fOutFile, "\nDC.LV.iWidthIndex = %d",     DiskChart.Visual.iWidthIndex );
        fprintf (fOutFile, "\nDC.GO.bLegendChecked  = %d",        DiskChart.gOptions.bLegendChecked  );
        fprintf (fOutFile, "\nDC.GO.bMenuChecked  = %d",        DiskChart.gOptions.bMenuChecked  );
        fprintf (fOutFile, "\nDC.GO.bLabelsChecked = %d",        DiskChart.gOptions.bLabelsChecked );
        fprintf (fOutFile, "\nDC.GO.bVertGridChecked  = %d",        DiskChart.gOptions.bVertGridChecked  );
        fprintf (fOutFile, "\nDC.GO.bHorzGridChecked  = %d",        DiskChart.gOptions.bHorzGridChecked  );
        fprintf (fOutFile, "\nDC.GO.bStatusBarChecked  = %d",        DiskChart.gOptions.bStatusBarChecked  );
        fprintf (fOutFile, "\nDC.GO.iVertMax  = %d",        DiskChart.gOptions.iVertMax  );
        fprintf (fOutFile, "\nDC.GO.eTimeInterval  = %e",        DiskChart.gOptions.eTimeInterval  );
        fprintf (fOutFile, "\nDC.GO.iGraphOrHistogram  = %d",        DiskChart.gOptions.iGraphOrHistogram  );
        fprintf (fOutFile, "\nDC.GO.GraphVGrid = %d",        DiskChart.gOptions.GraphVGrid );
        fprintf (fOutFile, "\nDC.GO.GraphHGrid = %d",        DiskChart.gOptions.GraphHGrid );
        fprintf (fOutFile, "\nDC.GO.HistVGrid = %d",        DiskChart.gOptions.HistVGrid );
        fprintf (fOutFile, "\nDC.GO.HistHGrid  = %d",        DiskChart.gOptions.HistHGrid  );
        fprintf (fOutFile, "\nDC.PO.bMenubar  = %d",        DiskChart.perfmonOptions.bMenubar );
        fprintf (fOutFile, "\nDC.PO.bToolbar   = %d",        DiskChart.perfmonOptions.bToolbar  );
        fprintf (fOutFile, "\nDC.PO.bStatusbar   = %d",        DiskChart.perfmonOptions.bStatusbar  );
        fprintf (fOutFile, "\nDC.PO.bAlwaysOnTop   = %d",        DiskChart.perfmonOptions.bAlwaysOnTop  );
#endif
    }
    if ((bSuccess) && (DiskChart.dwNumLines > 0)) {
       ReadLines (hFile, fOutFile, PMC_FILE, DiskChart.dwNumLines);
#ifdef _OUTPUT_HTML
       fwprintf (fOutFile, szObjectFooter);
#endif
    }

    return (bSuccess) ;

}  // OpenChart

static    
BOOL 
OpenWorkspace (
    LPCWSTR szPerfmonFileName,
    HANDLE  hInFile,
    FILE    * fOutFile)
{
    DISKWORKSPACE  DiskWorkspace ;

    WCHAR   szObjectName[MAX_PATH];
    DWORD   dwObjectId = 1;

    if (!FileRead (hInFile, &DiskWorkspace, sizeof(DiskWorkspace))) {
      goto Exit0 ;
    }

    if (DiskWorkspace.ChartOffset == 0 &&
        DiskWorkspace.AlertOffset == 0 &&
        DiskWorkspace.LogOffset == 0 &&
        DiskWorkspace.ReportOffset == 0) {
        // no entries to process
        goto Exit0 ;
    }

    if (DiskWorkspace.ChartOffset) {
        if (FileSeekBegin(hInFile, DiskWorkspace.ChartOffset) == 0xFFFFFFFF) {
           goto Exit0 ;
        }
        swprintf (szObjectName, szSysmonControlIdFmt, dwObjectId++);
        // process chart entry
        if (!OpenChart (hInFile, fOutFile, szObjectName)) {
           goto Exit0 ;
        }
    }

    if (DiskWorkspace.AlertOffset) {
        if (FileSeekBegin(hInFile, DiskWorkspace.AlertOffset) == 0xffffffff) {
           goto Exit0 ;
        }
        swprintf (szObjectName, szSysmonControlIdFmt, dwObjectId++);
        if (!OpenAlert (szPerfmonFileName, hInFile, fOutFile, szObjectName)) {
           goto Exit0 ;
        }
    }
    
    if (DiskWorkspace.LogOffset) {
        if (FileSeekBegin(hInFile, DiskWorkspace.LogOffset) == 0xffffffff) {
           goto Exit0 ;
        }
        swprintf (szObjectName, szSysmonControlIdFmt, dwObjectId++);
        if (!OpenLog (szPerfmonFileName, hInFile, fOutFile, szObjectName)) {
           goto Exit0 ;
        }
    }
    
    if (DiskWorkspace.ReportOffset) {
        if (FileSeekBegin(hInFile, DiskWorkspace.ReportOffset) == 0xffffffff) {
           goto Exit0 ;
        }
        swprintf (szObjectName, szSysmonControlIdFmt, dwObjectId++);       
        if (!OpenReport (hInFile, fOutFile, szObjectName)) {
           goto Exit0 ;
        }
    }
    
   return (TRUE) ;

Exit0:
   return (FALSE) ;

}  // OpenWorkspace

static
BOOL
ConvertPerfmonFile (
    IN  LPCWSTR szPerfmonFileName,
    IN  LPCWSTR szSysmonFileName,
    IN  LPDWORD pdwFileType
)
{
    HANDLE  hInFile = INVALID_HANDLE_VALUE;
    PERFFILEHEADER  pfHeader;
    BOOL    bSuccess = FALSE;
    FILE    * fOutFile = NULL;
#ifdef _OUTPUT_HTML
    DWORD           dwColor;
#endif

    // open input file as read only

    hInFile = CreateFileW (
        szPerfmonFileName,  // filename
        GENERIC_READ,       // read access
        0,                  // no sharing
        NULL,               // default security
        OPEN_EXISTING,      // only open existing files
        FILE_ATTRIBUTE_NORMAL, // normal attributes
        NULL);              // no template file


    if (hInFile != INVALID_HANDLE_VALUE) {
        bSuccess = FileRead (hInFile, &pfHeader, sizeof (PERFFILEHEADER));
        if (bSuccess) {
#ifdef _OUTPUT_HTML
            fOutFile = _wfopen (szSysmonFileName, (LPCWSTR)L"w+t");           
#else
            fOutFile = stdout;
#endif
            if (fOutFile != NULL) {
                dwColor = GetSysColor (COLOR_3DFACE);
                fwprintf (fOutFile, szHtmlHeader, (dwColor & 0x00FFFFFF));
                if (lstrcmpW(pfHeader.szSignature, szPerfChartSignature) == 0) {
#ifdef _DBG_MSG_PRINT
                    fprintf (stderr, "\nConverting Chart Settings file \"%ws\" to \n \"%ws\"",
                        szPerfmonFileName,
                        szSysmonFileName);
#endif
                    bSuccess = OpenChart (hInFile, fOutFile, szSingleObjectName);
                    *pdwFileType = PMC_FILE;
                } else if (lstrcmpW(pfHeader.szSignature, szPerfAlertSignature) == 0) {
#ifdef _DBG_MSG_PRINT
                    fprintf (stderr, "\nConverting Alert Settings file \"%ws\" to \n \"%ws\"",
                        szPerfmonFileName,
                        szSysmonFileName);
#endif
                    bSuccess = OpenAlert (szPerfmonFileName, hInFile, fOutFile, szSingleObjectName);
                    *pdwFileType = PMA_FILE;
                } else if (lstrcmpW(pfHeader.szSignature, szPerfLogSignature) == 0) {
#ifdef _DBG_MSG_PRINT
                    fprintf (stderr, "\nConverting Log Settings file \"%ws\" to \n \"%ws\"",
                        szPerfmonFileName,
                        szSysmonFileName);
#endif
                    bSuccess = OpenLog (szPerfmonFileName, hInFile, fOutFile, szSingleObjectName);
                    *pdwFileType = PML_FILE;
                } else if (lstrcmpW(pfHeader.szSignature, szPerfReportSignature) == 0) {
#ifdef _DBG_MSG_PRINT
                    fprintf (stderr, "\nConverting Report Settings file \"%ws\" to \n \"%ws\"",
                        szPerfmonFileName,
                        szSysmonFileName);
#endif
                    bSuccess = OpenReport (hInFile, fOutFile, szSingleObjectName);
                    *pdwFileType = PMR_FILE;
                } else if (lstrcmpW(pfHeader.szSignature, szPerfWorkspaceSignature) == 0) {
#ifdef _DBG_MSG_PRINT
                    fprintf (stderr, "\nConverting Workspace Settings file \"%ws\" to \n \"%ws\"",
                        szPerfmonFileName,
                        szSysmonFileName);
#endif
                    bSuccess = OpenWorkspace (szPerfmonFileName, hInFile, fOutFile);
                    *pdwFileType = PMW_FILE;
                } else {
                    // not a valid signature
                    bSuccess = FALSE;
                }

                fwprintf (fOutFile, szHtmlFooter);
                fclose (fOutFile);
            } else {
                // not a valid file open
                bSuccess = FALSE;
            }
        }
    }

    if (hInFile != INVALID_HANDLE_VALUE) CloseHandle (hInFile);

    return bSuccess;
}

static
BOOL
MakeTempFileName (
    IN  LPCWSTR wszRoot,
    IN  LPWSTR  wszTempFilename
)
{
	FILETIME	ft;
	DWORD		dwReturn;
	WCHAR		wszLocalFilename[MAX_PATH];

	GetSystemTimeAsFileTime (&ft);
	dwReturn = (DWORD) swprintf(wszLocalFilename, 
		(LPCWSTR)L"%%temp%%\\%s_%8.8x%8.8x.htm",
		(wszRoot != NULL ? wszRoot : (LPCWSTR)L"LodCtr"),
		ft.dwHighDateTime, ft.dwLowDateTime);
	if (dwReturn > 0) {
		// expand env. vars
		dwReturn = ExpandEnvironmentStringsW (
			wszLocalFilename,
			wszTempFilename,
			MAX_PATH-1);
	}
	return (BOOL)(dwReturn > 0);
}

static
BOOL
IsPerfmonFile(
    IN  LPWSTR szFileName
) 
{
    LPWSTR  szResult = NULL;
    _wcslwr (szFileName);

    if (szResult == NULL) szResult = wcsstr (szFileName, (LPCWSTR)L".pmc");   // test for chart settings file
    if (szResult == NULL) szResult = wcsstr (szFileName, (LPCWSTR)L".pmr");   // test for report settings file
    if (szResult == NULL) szResult = wcsstr (szFileName, (LPCWSTR)L".pma");   // test for alert settings file
    if (szResult == NULL) szResult = wcsstr (szFileName, (LPCWSTR)L".pml");   // test for log settings file
    if (szResult == NULL) szResult = wcsstr (szFileName, (LPCWSTR)L".pmw");   // test for workspace file 

    if (szResult == NULL) 
        return FALSE;
    else 
        return TRUE;
}

int
__cdecl wmain(
    int argc,
    wchar_t *argv[])
{
    WCHAR    szCommandLine[MAXSTR];
    WCHAR    szArgList[2048];
    WCHAR    szTempFileName[MAXSTR];
    WCHAR    szTempArg[MAXSTR];
    LPWSTR   szArgFileName;
    int     iThisArg;
    DWORD   dwArgListLen;
    DWORD   dwArgLen;
    STARTUPINFOW startInfo;
    PROCESS_INFORMATION processInfo;
    DWORD   dwReturnValue = ERROR_SUCCESS;
    BOOL    bSuccess = TRUE;
    DWORD   dwPmFileType = 0;
    BOOL    bPerfmonFileMade = FALSE;
    BOOL    bDeleteFileOnExit = TRUE;

    memset (&startInfo, 0, sizeof(startInfo));
    memset (&processInfo, 0, sizeof(processInfo));
    memset (szTempFileName, 0, sizeof (szTempFileName));

    startInfo.cb = sizeof(startInfo); 
    startInfo.dwFlags = STARTF_USESTDHANDLES; 
    startInfo.wShowWindow = SW_SHOWDEFAULT; 

    szTempArg[0] = UNICODE_NULL;
    szArgList[0] = UNICODE_NULL;

    ExpandEnvironmentStringsW (szMmcExeCmd, szCommandLine, sizeof(szCommandLine)/sizeof(szCommandLine[0]));
    dwArgListLen = ExpandEnvironmentStringsW (szMmcExeArg, szArgList, sizeof(szArgList)/sizeof(szArgList[0]));
    szArgList[(sizeof(szArgList)/sizeof(szArgList[0]))-1] = UNICODE_NULL;

    if (argc >= 2) {
        for (iThisArg = 1; iThisArg < argc; iThisArg++) {
            if (IsPerfmonFile(argv[iThisArg])) {
                if (!bPerfmonFileMade) {
                    if (szTempFileName[0] == 0) {
                        // if there's no filename, then make one
                        MakeTempFileName ((LPCWSTR)L"PMSettings", szTempFileName);
                    }
                    bSuccess = ConvertPerfmonFile (argv[iThisArg], szTempFileName, &dwPmFileType);
                    if (bSuccess) {

                    	swprintf(
                            (LPWSTR)szTempArg, 
                            szMmcExeSetsArg, 
		                    ( PML_FILE == dwPmFileType || PMA_FILE == dwPmFileType ) 
                                ? szMmcExeSetsLogOpt : szEmpty,
		                    szTempFileName );
                        
                        bPerfmonFileMade = TRUE;
                    } else {
                        // ignore this parameter
                        szTempArg[0] = 0;
                        szTempArg[1] = 0;
                    }
                } else {
                    // only process the first perfmon file in the path
                }
            } else if (lstrcmpiW(argv[iThisArg], (LPCWSTR)L"/WMI") == 0) {
                // this is a special switch
                lstrcpyW (szTempArg, (LPCWSTR)L"/SYSMON_WMI");
            } else if ((argv[iThisArg][0] == L'/') 
                        && ((argv[iThisArg][1] == L'H') || (argv[iThisArg][1] == L'h'))
                        && ((argv[iThisArg][2] == L'T') || (argv[iThisArg][2] == L't'))
                        && ((argv[iThisArg][3] == L'M') || (argv[iThisArg][3] == L'm'))
                        && ((argv[iThisArg][4] == L'L') || (argv[iThisArg][4] == L'l'))
                        && ((argv[iThisArg][5] == L'F') || (argv[iThisArg][5] == L'f'))
                        && ((argv[iThisArg][6] == L'I') || (argv[iThisArg][6] == L'i'))
                        && ((argv[iThisArg][7] == L'L') || (argv[iThisArg][7] == L'l'))
                        && ((argv[iThisArg][8] == L'E') || (argv[iThisArg][8] == L'e'))
                        && (argv[iThisArg][9] == L':')) {
                szArgFileName = &argv[iThisArg][10];
                if (bPerfmonFileMade) {
                    // then copy the file from the temp to the save file
                    CopyFileW (szTempFileName, szArgFileName, FALSE);
                } else {
                    // else set the perfmon file name to the one specified in the command line
                    lstrcpyW (szTempFileName, szArgFileName);
                    bDeleteFileOnExit = FALSE;
                }
            } else {
                // just copy the arg
                lstrcpynW (szTempArg, argv[iThisArg], MAXSTR-1);
                szTempArg[MAXSTR-1] = UNICODE_NULL;
            } 

            dwArgLen = lstrlenW (szTempArg) + 1;
            if ((dwArgLen + dwArgListLen) < sizeof(szArgList)/sizeof(szArgList[0])) {
                szArgList[dwArgListLen - 1] = L' ';  // add in delimiter
                lstrcpynW(&szArgList[dwArgListLen], szTempArg,
                          (sizeof(szArgList)/sizeof(szArgList[0]))
                                - dwArgListLen - 2);
                dwArgListLen += dwArgLen;
            } else {
                // no more room in the arg list buffer so bail
                break;
            }
        }
    } else {
        // no settings file in the command line so leave it as is
    }

    if (bSuccess) {
#ifdef _DBG_MSG_PRINT
        fwprintf (stderr, (LPCWSTR)L"\nStarting \"%ws\" \"%ws\"",
            szCommandLine,
            szArgList);
#endif
        bSuccess = CreateProcessW (
            szCommandLine,
            szArgList,
            NULL, NULL,
            FALSE,
            DETACHED_PROCESS,
            NULL,
            NULL,
            &startInfo,
            &processInfo);
        if (!bSuccess) {
            dwReturnValue = GetLastError();
        } else {
            Sleep (5000); // wait for things to get going            
            CloseHandle (processInfo.hProcess);
            CloseHandle (processInfo.hThread);
        }
        
#ifndef _DBG_MSG_PRINT
        if (bPerfmonFileMade && bDeleteFileOnExit) {
            DeleteFileW (szTempFileName);
        }
#endif
    }

    return (int)dwReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\perfmon5\perfmon5.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    perfmon5.h

Abstract:

    <abstract>

--*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <windows.h>
#include <winperf.h>
#include <pdh.h>

#define FileSeekBegin(hFile, lAmtToMove) \
   SetFilePointer (hFile, lAmtToMove, NULL, FILE_BEGIN)

// these defintions are copied from the NT4 perfmon.exe source files

typedef struct OPTIONSSTRUCT
   {  
   BOOL           bMenubar ;
   BOOL           bToolbar ;
   BOOL           bStatusbar ;
   BOOL           bAlwaysOnTop ;
   } OPTIONS ;

//======================================//
// DISKLINE data type                   //
//======================================//

#define dwLineSignature    (MAKELONG ('L', 'i'))

typedef struct DISKSTRINGSTRUCT
   {  
   DWORD          dwLength ;
   DWORD          dwOffset ;
   } DISKSTRING ;
typedef DISKSTRING *PDISKSTRING ;


typedef struct _TIMELINESTRUCT
{
    INT ppd ;                           // Pixels Per DataPoint
    INT rppd ;                          // Remaining Pixels Per DataPoint
    INT xLastTime ;                     // X coordinate of last time line.
    INT iValidValues ;                  // High water mark for valid data.
}TIMELINESTRUCT;


#define LineTypeChart            1
#define LineTypeAlert            2
#define LineTypeReport           3

typedef struct LINEVISUALSTRUCT
   {
   COLORREF       crColor ;
   int            iColorIndex ;    
   
   int            iStyle ;
   int            iStyleIndex ;

   int            iWidth ;
   int            iWidthIndex ;
   } LINEVISUAL ;

typedef LINEVISUAL *PLINEVISUAL ;

typedef struct DISKLINESTRUCT
   {
   int            iLineType ;
   DISKSTRING     dsSystemName ;
   DISKSTRING     dsObjectName ;
   DISKSTRING     dsCounterName ;
   DISKSTRING     dsInstanceName ;
   DISKSTRING     dsPINName ;
   DISKSTRING     dsParentObjName ;
   DWORD          dwUniqueID ;
   LINEVISUAL     Visual ;
   int            iScaleIndex ;
   FLOAT          eScale ;
   BOOL           bAlertOver ;
   FLOAT          eAlertValue ;
   DISKSTRING     dsAlertProgram ;
   BOOL           bEveryTime ;
   } DISKLINE ;

typedef DISKLINE *PDISKLINE ;

#define PerfSignatureLen  20

#define szPerfChartSignature     ((LPCWSTR)L"PERF CHART")
#define szPerfAlertSignature     ((LPCWSTR)L"PERF ALERT")
#define szPerfLogSignature       ((LPCWSTR)L"PERF LOG")
#define szPerfReportSignature    ((LPCWSTR)L"PERF REPORT")
#define szPerfWorkspaceSignature ((LPCWSTR)L"PERF WORKSPACE")

#define LINE_GRAPH          1
#define BAR_GRAPH           2

#define PMC_FILE    1
#define PMA_FILE    2
#define PML_FILE    3
#define PMR_FILE    4
#define PMW_FILE    5

#define AlertMajorVersion    1

// minor version 2 to support Alert msg name
// minor version 3 to support alert, report, log intervals in msec
// minor version 4 to support alert event logging
// minor version 6 to support alert misc options
#define AlertMinorVersion    6


typedef struct DISKALERTSTRUCT
   {
   LINEVISUAL     Visual ;
   DWORD          dwNumLines ;
   DWORD          dwIntervalSecs ;
   BOOL           bManualRefresh ;
   BOOL           bSwitchToAlert ;
   BOOL           bNetworkAlert ;
   WCHAR          MessageName [16] ;
   OPTIONS        perfmonOptions ;
   DWORD          MiscOptions ;
   } DISKALERT ;


typedef struct PERFFILEHEADERSTRUCT
   {  // PERFFILEHEADER
   WCHAR          szSignature [PerfSignatureLen] ;
   DWORD          dwMajorVersion ;
   DWORD          dwMinorVersion ;
   BYTE           abyUnused [100] ;
   } PERFFILEHEADER ;

// minor version 3 to support alert, report, log intervals in msec
#define ChartMajorVersion    1
#define ChartMinorVersion    3

typedef struct _graph_options {
    BOOL    bLegendChecked ;
    BOOL    bMenuChecked ;
    BOOL    bLabelsChecked;
    BOOL    bVertGridChecked ;
    BOOL    bHorzGridChecked ;
    BOOL    bStatusBarChecked ;
    INT     iVertMax ;
    FLOAT   eTimeInterval ;
    INT     iGraphOrHistogram ;
    INT     GraphVGrid,
            GraphHGrid,
            HistVGrid,
            HistHGrid ;

} GRAPH_OPTIONS ;

#define MAX_SYSTEM_NAME_LENGTH  128
#define PerfObjectLen               80

typedef struct DISKCHARTSTRUCT
   {
   DWORD          dwNumLines ;
   INT            gMaxValues;
   LINEVISUAL     Visual ;
   GRAPH_OPTIONS  gOptions ;
   BOOL           bManualRefresh ;
   OPTIONS        perfmonOptions ;
   } DISKCHART ;

// minor version 3 to support alert, report, log intervals in msec
#define ReportMajorVersion    1
#define ReportMinorVersion    3

typedef struct DISKREPORTSTRUCT
   {
   LINEVISUAL     Visual ;
   DWORD          dwNumLines ;
   DWORD          dwIntervalSecs ;
   BOOL           bManualRefresh ;
   OPTIONS        perfmonOptions ;
   } DISKREPORT ;

//=====================================//
// Log File Counter Name data type     //
//=====================================//


// minor version 3 to support alert, report, log intervals in msec
// minor version 5 to support storing Log file name in setting
//  and start logging after reading the file.
#define LogMajorVersion    1
#define LogMinorVersion    5


typedef struct DISKLOGSTRUCT
   {
   DWORD          dwNumLines ;
   DWORD          dwIntervalSecs ;
   BOOL           bManualRefresh ;
   OPTIONS        perfmonOptions ;
   WCHAR          LogFileName[260] ;
   } DISKLOG ;


typedef struct _LOGENTRYSTRUCT
   {
   DWORD          ObjectTitleIndex ;
   WCHAR          szComputer [MAX_SYSTEM_NAME_LENGTH + 1] ;
   WCHAR          szObject [PerfObjectLen + 1] ;
   BOOL           bSaveCurrentName ;
   struct  _LOGENTRYSTRUCT *pNextLogEntry ;
} LOGENTRY ;

typedef LOGENTRY *PLOGENTRY ;

#define WorkspaceMajorVersion    1

// minor version 1 to support window placement data
// minor version 2 to support alert msg name
// minor version 3 to support alert, report, log intervals in msec
// minor version 4 to support alert eventlog
// minor version 5 to support log file name in log setting
// minor version 6 to support alert misc options
#define WorkspaceMinorVersion    6

typedef struct DISKWORKSPACESTRUCT
   {
   INT               iPerfmonView ;
   DWORD             ChartOffset ;
   DWORD             AlertOffset ;
   DWORD             LogOffset ;
   DWORD             ReportOffset ;
   WINDOWPLACEMENT   WindowPlacement ;   
   } DISKWORKSPACE ;

WCHAR LOCAL_SYS_CODE_NAME[] = {L"...."};
#define  sizeofCodeName sizeof(LOCAL_SYS_CODE_NAME) / sizeof(WCHAR) - 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\bvt\perfval.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    perfval.c

Abstract:

    Program to test the extensible counter dll's

Author:

    Bob Watson (bobw) 8 Feb 99

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <stdio.h>
#include <stdlib.h>
#include <pdhmsg.h>
#include "strings.h"
#include "perfval.h"

#define MAX_BUF_SIZE ((DWORD)(1024 * 1024))

typedef struct _LOCAL_THREAD_DATA {
    LPWSTR  szServiceName;
    LPWSTR  szQueryString;
    DWORD   dwThreadID;
    DWORD   dwCycleCount;
    DWORD   dwLoopCount;
    BOOL    bTestContents;
    BOOL    bDisplay;
    FILE    *pOutput;
    LPWSTR  *pNameTable;
    DWORD   dwLastIndex;
} LOCAL_THREAD_DATA, *PLOCAL_THREAD_DATA;

HANDLE  hEventLog = NULL;
HANDLE  hProcessHeap = NULL;
HANDLE	hTestHeap = NULL;

LONG    lEventLogLevel = LOG_DEBUG;
LONG    lExtCounterTestLevel = EXT_TEST_ALL;

#define PERFVAL_NOCONFIG    0
#define PERFVAL_PASS        1
#define PERFVAL_FAIL        2
#define PERFVAL_TIMEOUT     3

LPCWSTR szContact = (LPCWSTR)L"jenlc";
LPCWSTR szMgrContact = (LPCWSTR)L"jeepang";
LPCWSTR szDevPrime = (LPCWSTR)L"http://ntperformance/perftools/perfctrs.htm";
LPCWSTR szDevAlt= (LPCWSTR)L"jeepang";
LPCWSTR szTestPrime = (LPCWSTR)L"ashokkum";
LPCWSTR szTestAlt = (LPCWSTR)L"a-chrila";

static const WCHAR  cszDefaultLangId[] = {L"009"};
static const WCHAR  cszNamesKey[] = {L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"};
static const WCHAR  cszLastHelp[] = {L"Last Help"};
static const WCHAR  cszLastCounter[] = {L"Last Counter"};
static const WCHAR  cszVersionName[] = {L"Version"};
static const WCHAR  cszCounterName[] = {L"Counter "};
static const WCHAR  cszHelpName[] = {L"Explain "};
static const WCHAR  cszCounters[] = {L"Counters"};
static const WCHAR  cszNotFound[] = {L"*** NOT FOUND ***"};

LPWSTR  szTestErrorMessage = NULL;

#define MAX_BUF_SIZE ((DWORD)(1024 * 1024))

#define PERFLIB_TIMER_INTERVAL  200     // 200 ms Timer


static
BOOL
IsMsService (LPCWSTR pServiceName)
{
    WCHAR  szLocalServiceName[MAX_PATH * 2];

    lstrcpyW (szLocalServiceName, pServiceName);
    _wcslwr (szLocalServiceName);

    // for now this just compares known DLL names. valid as of
    // NT v4.0
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"tcpip") == 0) return TRUE;
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"nwlnkspx") == 0) return TRUE;
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"nwlnknb") == 0) return TRUE;
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"nwlnkipx") == 0) return TRUE;
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"nbf") == 0) return TRUE;
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"remoteaccess") == 0) return TRUE;
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"nm") == 0) return TRUE;
//    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"winsctrs.dll") == 0) return TRUE;
//    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"sfmctrs.dll") == 0) return TRUE;
//    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"atkctrs.dll") == 0) return TRUE;
    // NT v5.0
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"perfdisk") == 0) return TRUE;
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"perfos") == 0) return TRUE;
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"perfproc") == 0) return TRUE;
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"perfnet") == 0) return TRUE;
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"spooler") == 0) return TRUE;
    if (lstrcmpW(szLocalServiceName, (LPCWSTR)L"tapisrv") == 0) return TRUE;

    return FALSE;
}

DWORD
OpenLibrary (
    LPCWSTR szRegistryKey,      // service key in registry
    EXT_OBJECT  **pCreatedObj   // structure allocated, init'd and returned by this structure
)
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwOpenEvent;
    DWORD   dwType;
    DWORD   dwSize;

    UINT    nErrorMode;

    // check to see if the library has already been opened

    HKEY    hServicesKey = NULL;
    HKEY    hPerfKey = NULL;
    LPWSTR  szServiceName;

    HKEY    hKeyLinkage;

    BOOL    bUseQueryFn = FALSE;

    EXT_OBJECT  *pReturnObject = NULL;
    EXT_OBJECT  *pObj = NULL;

    DWORD   dwFlags = 0;
    DWORD   dwKeep;
    DWORD   dwObjectArray[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];
    DWORD   dwObjIndex = 0;
    DWORD   dwMemBlockSize = sizeof(EXT_OBJECT);
    DWORD   dwLinkageStringLen = 0;

    CHAR    szOpenProcName[MAX_PATH];
    CHAR    szCollectProcName[MAX_PATH];
    CHAR    szCloseProcName[MAX_PATH];
    WCHAR   szLibraryString[MAX_PATH];
    WCHAR   szLibraryExpPath[MAX_PATH];
    WCHAR   mszObjectList[MAX_PATH];
    WCHAR   szLinkageKeyPath[MAX_PATH];
    WCHAR   szLinkageString[MAX_PATH];

    DWORD   dwOpenTimeout = 0;
    DWORD   dwCollectTimeout = 0;

    LPWSTR  szThisObject;
    LPWSTR  szThisChar;

    LPSTR   pNextStringA;
    LPWSTR  pNextStringW;

    WCHAR   szServicePath[MAX_PATH];
	WCHAR	szMutexName[MAX_PATH];
	WCHAR	szPID[32];

    LARGE_INTEGER   liStartTime, liEndTime, liFreq;

    OPEN_PROC_WAIT_INFO opwInfo;
    
    if (szRegistryKey != NULL) {

        lstrcpyW (szServicePath, cszHklmServicesKey);

        Status = RegOpenKeyExW (HKEY_LOCAL_MACHINE, szServicePath, 
            0, KEY_READ, &hServicesKey);

        lstrcpyW (szServicePath, szRegistryKey);
        lstrcatW (szServicePath, cszPerformance);
        Status = RegOpenKeyExW (hServicesKey, szServicePath, 
            0, KEY_READ, &hPerfKey);
        szServiceName = (LPWSTR)szRegistryKey;

        // read the performance DLL name

        dwType = 0;
        dwSize = sizeof(szLibraryString);
        memset (szLibraryString, 0, sizeof(szLibraryString));
        memset (szLibraryString, 0, sizeof(szLibraryExpPath));

        Status = RegQueryValueExW (hPerfKey,
                                cszDLLValue,
                                NULL,
                                &dwType,
                                (LPBYTE)szLibraryString,
                                &dwSize);

        if (Status == ERROR_SUCCESS) {
            if (dwType == REG_EXPAND_SZ) {
                // expand any environment vars
                dwSize = ExpandEnvironmentStringsW(
                    szLibraryString,
                    szLibraryExpPath,
                    MAX_PATH);

                if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                    Status = ERROR_INVALID_DLL;
                } else {
                    dwSize += 1;
                    dwSize *= sizeof(WCHAR);
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }
            } else if (dwType == REG_SZ) {
                // look for dll and save full file Path
                dwSize = SearchPathW (
                    NULL,   // use standard system search path
                    szLibraryString,
                    NULL,
                    MAX_PATH,
                    szLibraryExpPath,
                    NULL);

                if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                    Status = ERROR_INVALID_DLL;
                } else {
                    dwSize += 1;
                    dwSize *= sizeof(WCHAR);
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }
            } else {
                Status = ERROR_INVALID_DLL;
            }

            if (Status == ERROR_SUCCESS) {
                // we have the DLL name so get the procedure names
                dwType = 0;
                dwSize = sizeof(szOpenProcName);
                memset (szOpenProcName, 0, sizeof(szOpenProcName));
                Status = RegQueryValueExA (hPerfKey,
                                        caszOpenValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szOpenProcName,
                                        &dwSize);
            }

            if (Status == ERROR_SUCCESS) {
                // add in size of previous string
                // the size value includes the Term. NULL
                dwMemBlockSize += DWORD_MULTIPLE(dwSize);

                // we have the procedure name so get the timeout value
                dwType = 0;
                dwSize = sizeof(dwOpenTimeout);
                Status = RegQueryValueExW (hPerfKey,
                                        cszOpenTimeout,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)&dwOpenTimeout,
                                        &dwSize);

                // if error, then apply default
                if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                    dwOpenTimeout = 10000;
                    Status = ERROR_SUCCESS;
                }

            }

            if (Status == ERROR_SUCCESS) {
                // get next string

                dwType = 0;
                dwSize = sizeof(szCloseProcName);
                memset (szCloseProcName, 0, sizeof(szCloseProcName));
                Status = RegQueryValueExA (hPerfKey,
                                        caszCloseValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szCloseProcName,
                                        &dwSize);
            }

            if (Status == ERROR_SUCCESS) {
                // add in size of previous string
                // the size value includes the Term. NULL
                dwMemBlockSize += DWORD_MULTIPLE(dwSize);

                // try to look up the query function which is the
                // preferred interface if it's not found, then
                // try the collect function name. If that's not found,
                // then bail
                dwType = 0;
                dwSize = sizeof(szCollectProcName);
                memset (szCollectProcName, 0, sizeof(szCollectProcName));
                Status = RegQueryValueExA (hPerfKey,
                                        caszQueryValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szCollectProcName,
                                        &dwSize);

                if (Status == ERROR_SUCCESS) {
                    // add in size of the Query Function Name
                    // the size value includes the Term. NULL
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                    // get next string

                    bUseQueryFn = TRUE;
                    // the query function can support a static object list
                    // so look it up

                } else {
                    // the QueryFunction wasn't found so look up the
                    // Collect Function name instead
                    dwType = 0;
                    dwSize = sizeof(szCollectProcName);
                    memset (szCollectProcName, 0, sizeof(szCollectProcName));
                    Status = RegQueryValueExA (hPerfKey,
                                            caszCollectValue,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)szCollectProcName,
                                            &dwSize);

                    if (Status == ERROR_SUCCESS) {
                        // add in size of Collect Function Name
                        // the size value includes the Term. NULL
                        dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    // we have the procedure name so get the timeout value
                    dwType = 0;
                    dwSize = sizeof(dwCollectTimeout);
                    Status = RegQueryValueExW (hPerfKey,
                                            cszCollectTimeout,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)&dwCollectTimeout,
                                            &dwSize);

                    // if error, then apply default
                    if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                        dwCollectTimeout = 10000;
                        Status = ERROR_SUCCESS;
                    }

                }
                // get the list of supported objects if provided by the registry

                dwType = 0;
                dwSize = sizeof(mszObjectList);
                memset (mszObjectList, 0, sizeof(mszObjectList));
                Status = RegQueryValueExW (hPerfKey,
                                        cszObjListValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)mszObjectList,
                                        &dwSize);

                if (Status == ERROR_SUCCESS) {
                    if (dwType != REG_MULTI_SZ) {
                        // convert space delimited list to msz
                        for (szThisChar = mszObjectList; *szThisChar != 0; szThisChar++) {
                            if (*szThisChar == L' ') *szThisChar = L'\0';
                        }
                        ++szThisChar;
                        *szThisChar = 0; // add MSZ term Null
                    }
                    for (szThisObject = mszObjectList, dwObjIndex = 0;
                        (*szThisObject != 0) && (dwObjIndex < MAX_PERF_OBJECTS_IN_QUERY_FUNCTION);
                        szThisObject += lstrlenW(szThisObject) + 1) {
                        dwObjectArray[dwObjIndex] = wcstoul(szThisObject, NULL, 10);
                        dwObjIndex++;
                    }
                    if (*szThisObject != 0) {
                        // BUGBUG: log error idicating too many object ID's are
                        // in the list.
                    }
                } else {
                    // reset status since not having this is
                    //  not a showstopper
                    Status = ERROR_SUCCESS;
                }

                if (Status == ERROR_SUCCESS) {
                    dwType = 0;
                    dwKeep = 0;
                    dwSize = sizeof(dwKeep);
                    Status = RegQueryValueExW (hPerfKey,
                                            cszKeepResident,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)&dwKeep,
                                            &dwSize);

                    if ((Status == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                        if (dwKeep == 1) {
                            dwFlags |= PERF_EO_KEEP_RESIDENT;
                        } else {
                            // no change.
                        }
                    } else {
                        // not fatal, just use the defaults.
                        Status = ERROR_SUCCESS;
                    }

                }
            }
        }

        if (Status == ERROR_SUCCESS) {
            memset (szLinkageString, 0, sizeof(szLinkageString));

            lstrcpyW (szLinkageKeyPath, szServiceName);
            lstrcatW (szLinkageKeyPath, cszLinkageKey);

            Status = RegOpenKeyExW (
                hServicesKey,
                szLinkageKeyPath,
                0L,
                KEY_READ,
                &hKeyLinkage);

            if (Status == ERROR_SUCCESS) {
                // look up export value string
                dwSize = sizeof(szLinkageString);
                dwType = 0;
                Status = RegQueryValueExW (
                    hKeyLinkage,
                    cszExportValue,
                    NULL,
                    &dwType,
                    (LPBYTE)&szLinkageString,
                    &dwSize);

                if ((Status != ERROR_SUCCESS) ||
                    ((dwType != REG_SZ) && (dwType != REG_MULTI_SZ))) {
                    // clear buffer
                    memset (szLinkageString, 0, sizeof(szLinkageString));
                    dwLinkageStringLen = 0;

                    // not finding a linkage key is not fatal so correct
                    // status
                    Status = ERROR_SUCCESS;
                } else {
                    // add size of linkage string to buffer
                    // the size value includes the Term. NULL
                    dwLinkageStringLen = dwSize;
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }

                RegCloseKey (hKeyLinkage);
            } else {
                // not finding a linkage key is not fatal so correct
                // status
                Status = ERROR_SUCCESS;
            }
        }

        if (Status == ERROR_SUCCESS) {
            // add in size of service name
            dwSize = lstrlenW (szServiceName);
            dwSize += 1;
            dwSize *= sizeof(WCHAR);
            dwMemBlockSize += DWORD_MULTIPLE(dwSize);

            // allocate and initialize a new ext. object block
            pReturnObject = (EXT_OBJECT *)HeapAlloc(hTestHeap,
                HEAP_ZERO_MEMORY, dwMemBlockSize);

            if (pReturnObject != NULL) {
                // copy values to new buffer (all others are NULL)
                pNextStringA = (LPSTR)&pReturnObject[1];

                // copy Open Procedure Name
                pReturnObject->szOpenProcName = pNextStringA;
                lstrcpyA (pNextStringA, szOpenProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                pReturnObject->dwOpenTimeout = dwOpenTimeout;

                // copy collect function or query function, depending
                pReturnObject->szCollectProcName = pNextStringA;
                lstrcpyA (pNextStringA, szCollectProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                pReturnObject->dwCollectTimeout = dwCollectTimeout;

                // copy Close Procedure Name
                pReturnObject->szCloseProcName = pNextStringA;
                lstrcpyA (pNextStringA, szCloseProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                // copy Library path
                pNextStringW = (LPWSTR)pNextStringA;
                pReturnObject->szLibraryName = pNextStringW;
                lstrcpyW (pNextStringW, szLibraryExpPath);

                pNextStringW += lstrlenW (pNextStringW) + 1;
                pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);

                // copy Linkage String if there is one
                if (*szLinkageString != 0) {
                    pReturnObject->szLinkageString = pNextStringW;
                    memcpy (pNextStringW, szLinkageString, dwLinkageStringLen);

                    // length includes extra NULL char and is in BYTES
                    pNextStringW += (dwLinkageStringLen / sizeof (WCHAR));
                    pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);
                }

                // copy Service name
                pReturnObject->szServiceName = pNextStringW;
                lstrcpyW (pNextStringW, szServiceName);

                pNextStringW += lstrlenW (pNextStringW) + 1;
                pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);

                // load flags
                if (bUseQueryFn) {
                    dwFlags |= PERF_EO_QUERY_FUNC;
                }
                pReturnObject->dwFlags =  dwFlags;

                pReturnObject->hPerfKey = hPerfKey;

                // load Object array
                if (dwObjIndex > 0) {
                    pReturnObject->dwNumObjects = dwObjIndex;
                    memcpy (pReturnObject->dwObjList,
                        dwObjectArray, (dwObjIndex * sizeof(dwObjectArray[0])));
                }

                pReturnObject->llLastUsedTime = 0;

				// create Mutex name
				lstrcpyW (szMutexName, szRegistryKey);
				lstrcatW (szMutexName, (LPCWSTR)L"_Perf_Library_Lock_PID_");
				_ultow ((ULONG)GetCurrentProcessId(), szPID, 16);
				lstrcatW (szMutexName, szPID);

                pReturnObject->hMutex = CreateMutexW (NULL, FALSE, szMutexName);
            } else {
                Status = ERROR_OUTOFMEMORY;
            }
        }

        if (Status != ERROR_SUCCESS) {
            SetLastError (Status);
            if (pReturnObject != NULL) {
                // release the new block
                HeapFree (hTestHeap, 0, pReturnObject);
            }
        } else {
            if (pReturnObject != NULL) {
                pObj = pReturnObject;
                // then load library & look up functions
                nErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);
                pObj->hLibrary = LoadLibraryExW (pObj->szLibraryName,
                    NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

                if (pObj->hLibrary != NULL) {
                    // lookup function names
                    pObj->OpenProc = (OPENPROC)GetProcAddress(
                        pObj->hLibrary, pObj->szOpenProcName);
                    if (pObj->OpenProc == NULL) {
                        wprintf ((LPCWSTR)L"\nOpen Procedure \"%s\" not found in \"%s\"",
                            pObj->szOpenProcName, pObj->szLibraryName);
                    }
                } else {
                    // unable to load library
                    Status = GetLastError();
                }

                if (Status == ERROR_SUCCESS) {
                    if (pObj->dwFlags & PERF_EO_QUERY_FUNC) {
                        pObj->QueryProc = (QUERYPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->CollectProc = (COLLECTPROC)pObj->QueryProc;
                    } else {
                        pObj->CollectProc = (COLLECTPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->QueryProc = (QUERYPROC)pObj->CollectProc;
                    }

                    if (pObj->CollectProc == NULL) {
                        wprintf ((LPCWSTR)L"\nCollect Procedure \"%s\" not found in \"%s\"",
                            pObj->szCollectProcName, pObj->szLibraryName);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    pObj->CloseProc = (CLOSEPROC)GetProcAddress (
                        pObj->hLibrary, pObj->szCloseProcName);

                    if (pObj->CloseProc == NULL) {
                        wprintf ((LPCWSTR)L"\nClose Procedure \"%s\" not found in \"%s\"",
                            pObj->szCloseProcName, pObj->szLibraryName);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    __try {
                        // start timer
                        opwInfo.pNext = NULL;
                        opwInfo.szLibraryName = pObj->szLibraryName;
                        opwInfo.szServiceName = pObj->szServiceName;
                        opwInfo.dwWaitTime = pObj->dwOpenTimeout;
                        opwInfo.dwEventMsg = ERROR_TIMEOUT;
                        opwInfo.pData = (LPVOID)pObj;
                        
                        WAIT_FOR_AND_LOCK_MUTEX (pObj->hMutex);

                        QueryPerformanceCounter (&liStartTime);
                        // call open procedure to initialize DLL
                        Status = (*pObj->OpenProc)(pObj->szLinkageString);

                        // release the lock
                        RELEASE_MUTEX (pObj->hMutex);

                        // check the result.
                        if (Status != ERROR_SUCCESS) {
                            dwOpenEvent = WBEMPERF_OPEN_PROC_FAILURE;
                        } else {
                            InterlockedIncrement((LONG *)&pObj->dwOpenCount);
                            QueryPerformanceCounter (&liEndTime);
                            pObj->llFunctionTime = liEndTime.QuadPart - liStartTime.QuadPart;
                            pObj->llOpenTime += pObj->llFunctionTime;
                        }
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = GetExceptionCode();
                        dwOpenEvent = WBEMPERF_OPEN_PROC_EXCEPTION;
                    }
                }

                QueryPerformanceFrequency (&liFreq);
                pObj->llTimeBase = liFreq.QuadPart;

                if (Status != ERROR_SUCCESS) {
                    // clear fields
                    pObj->OpenProc = NULL;
                    pObj->CollectProc = NULL;
                    pObj->QueryProc = NULL;
                    pObj->CloseProc = NULL;
                    if (pObj->hLibrary != NULL) {
                        FreeLibrary (pObj->hLibrary);
                        pObj->hLibrary = NULL;
                    }
                } else {
                    GetSystemTimeAsFileTime ((FILETIME *)&pObj->llLastUsedTime);
                }
            } // else no buffer returned
            *pCreatedObj = pObj;
        }

        if (hServicesKey != NULL) RegCloseKey (hServicesKey);
    } else {
        Status = ERROR_INVALID_PARAMETER;
    }

    return Status;
}

//***************************************************************************
//
//  CollectData (LPBYTE pBuffer, 
//              LPDWORD pdwBufferSize, 
//              LPWSTR pszItemList)
//
//  Collects data from the perf objects and libraries added to the access 
//  object
//
//      Inputs:
//
//          pBuffer              -   pointer to start of data block
//                                  where data is being collected
//
//          pdwBufferSize        -   pointer to size of data buffer
//
//          pszItemList        -    string to pass to ext DLL
//
//      Outputs:
//
//          *lppDataDefinition  -   set to location for next Type
//                                  Definition if successful
//
//      Returns:
//
//          0 if successful, else Win 32 error code of failure
//
//
//***************************************************************************
//
DWORD   
CollectData (EXT_OBJECT *pThisExtObj,
             LPBYTE pBuffer, 
             LPDWORD pdwBufferSize, 
             LPCWSTR pszItemList
)
{
    LPWSTR  lpValueName = NULL;
    LPBYTE  lpData = pBuffer;
    LPDWORD lpcbData = pdwBufferSize;
    LPVOID  lpDataDefinition = pBuffer;

    DWORD Win32Error=ERROR_SUCCESS;          //  Failure code
    DWORD BytesLeft;
    DWORD InitialBytesLeft = 0;
    DWORD NumObjectTypes;

    LPVOID  lpExtDataBuffer = NULL;
    LPVOID  lpCallBuffer = NULL;
    LPVOID  lpLowGuardPage = NULL;
    LPVOID  lpHiGuardPage = NULL;
    LPVOID  lpEndPointer = NULL;
    LPVOID  lpBufferBefore = NULL;
    LPVOID  lpBufferAfter = NULL;
    LPDWORD lpCheckPointer;
    LARGE_INTEGER   liStartTime = {0,0};
    LARGE_INTEGER   liEndTime = {0,0};

    HANDLE  hPerflibFuncTimer;
    OPEN_PROC_WAIT_INFO opwInfo;

    BOOL    bGuardPageOK;
    BOOL    bBufferOK;
    BOOL    bException;
    BOOL    bUseSafeBuffer = TRUE;
    BOOL    bUnlockObjData = FALSE;

    LONG    lReturnValue = ERROR_SUCCESS;

    LONG                lInstIndex;
    PERF_OBJECT_TYPE    *pObject, *pNextObject;
    PERF_INSTANCE_DEFINITION    *pInstance;
    PERF_DATA_BLOCK     *pPerfData;
    BOOL                bForeignDataBuffer;

    DWORD           dwObjectBufSize;

    DWORD           dwIndex;
    DOUBLE          dMs;

    // use the one passed by the caller
    lpValueName = (LPWSTR)pszItemList;

    // initialize values to pass to the extensible counter function
    NumObjectTypes = 0;
    BytesLeft = (DWORD) (*lpcbData - ((LPBYTE)lpDataDefinition - lpData));
    bException = FALSE;

    // allocate a local block of memory to pass to the
    // extensible counter function.

    if (bUseSafeBuffer) {
        lpExtDataBuffer = HeapAlloc (hTestHeap,
            HEAP_ZERO_MEMORY, BytesLeft + (2*GUARD_PAGE_SIZE));
    } else {
        lpExtDataBuffer =
            lpCallBuffer = lpDataDefinition;
    }

    if (lpExtDataBuffer != NULL) {
        if (bUseSafeBuffer) {
            // set buffer pointers
            lpLowGuardPage = lpExtDataBuffer;
            lpCallBuffer = (LPBYTE)lpExtDataBuffer + GUARD_PAGE_SIZE;
            lpHiGuardPage = (LPBYTE)lpCallBuffer + BytesLeft;
            lpEndPointer = (LPBYTE)lpHiGuardPage + GUARD_PAGE_SIZE;
            lpBufferBefore = lpCallBuffer;
            lpBufferAfter = NULL;

            // initialize GuardPage Data

            memset (lpLowGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
            memset (lpHiGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
        }

        __try {
            //
            //  Collect data from extesible objects
            //

            hPerflibFuncTimer = NULL;
            bUnlockObjData = FALSE;

            if (pThisExtObj->hMutex != NULL) {
                Win32Error =  WaitForSingleObject (
                    pThisExtObj->hMutex,
                    pThisExtObj->dwCollectTimeout);
                if ((Win32Error != WAIT_TIMEOUT)  &&
                    (pThisExtObj->CollectProc != NULL)) {

                    bUnlockObjData = TRUE;

                    opwInfo.pNext = NULL;
                    opwInfo.szLibraryName = pThisExtObj->szLibraryName;
                    opwInfo.szServiceName = pThisExtObj->szServiceName;
                    opwInfo.dwWaitTime = pThisExtObj->dwCollectTimeout;
                    opwInfo.dwEventMsg = ERROR_TIMEOUT;
                    opwInfo.pData = (LPVOID)pThisExtObj;

                    InitialBytesLeft = BytesLeft;

                    QueryPerformanceCounter (&liStartTime);

                        Win32Error =  (*pThisExtObj->CollectProc) (
                            lpValueName,
                            &lpCallBuffer,
                            &BytesLeft,
                            &NumObjectTypes);

                    QueryPerformanceCounter (&liEndTime);

                    GetSystemTimeAsFileTime(
                        (FILETIME*)&pThisExtObj->llLastUsedTime);

                    ReleaseMutex (pThisExtObj->hMutex);
                    bUnlockObjData = FALSE;
                } else {
                    pThisExtObj->dwLockoutCount++;
                }
            } else {
                Win32Error = ERROR_LOCK_FAILED;
            }

            if ((Win32Error == ERROR_SUCCESS) && (BytesLeft > 0)) {
                if (BytesLeft > InitialBytesLeft) {
                    pThisExtObj->dwBufferSizeErrors++;
                    // memory error
                    Win32Error = ERROR_INVALID_PARAMETER;
                }

                // increment perf counters
                InterlockedIncrement ((LONG *)&pThisExtObj->dwCollectCount);

                pThisExtObj->llFunctionTime = liEndTime.QuadPart - liStartTime.QuadPart;
                pThisExtObj->llCollectTime += pThisExtObj->llFunctionTime;

                // check the time spent in this function
                dMs = (DOUBLE)pThisExtObj->llFunctionTime;
                dMs /= (DOUBLE)pThisExtObj->llTimeBase;
                dMs *= 1000.0;

                if (dMs > (DOUBLE)pThisExtObj->dwCollectTimeout) {
                    Win32Error = ERROR_TIMEOUT;
                } else if (BytesLeft & 0x00000007) {
                    pThisExtObj->dwAlignmentErrors++;
                    Win32Error = ERROR_INVALID_DATA;
                }

                pThisExtObj->dwNumObjectsRet = NumObjectTypes;
                pThisExtObj->dwRetBufSize = BytesLeft;

                if ((bUseSafeBuffer) && (Win32Error == ERROR_SUCCESS)) {
                    // a data buffer was returned and
                    // the function returned OK so see how things
                    // turned out...
                    //
                    lpBufferAfter = lpCallBuffer;
                    //
                    // check for buffer corruption here
                    //
                    bBufferOK = TRUE; // assume it's ok until a check fails
                    //
                    if (lExtCounterTestLevel <= EXT_TEST_BASIC) {
                        //
                        //  check 1: bytes left should be the same as
                        //      new data buffer ptr - orig data buffer ptr
                        //
                        if (BytesLeft != (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore)) {
                            pThisExtObj->dwBadPointers++;
                            // we'll keep the buffer, since the returned bytes left
                            // value is ignored anyway, in order to make the
                            // rest of this function work, we'll fix it here
                            BytesLeft = (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                            Win32Error = ERROR_INVALID_DATA;
                        }
                        //
                        //  check 2: buffer after ptr should be < hi Guard page ptr
                        //
                        if (((LPBYTE)lpBufferAfter >= (LPBYTE)lpHiGuardPage) && bBufferOK) {
                            // see if they exceeded the allocated memory
                            if ((LPBYTE)lpBufferAfter >= (LPBYTE)lpEndPointer) {
                                pThisExtObj->dwBufferSizeErrors++;
                                bBufferOK = FALSE;
                                // since the DLL overran the buffer, the buffer
                                // must be too small (no comments about the DLL
                                // will be made here) so the status will be
                                // changed to ERROR_MORE_DATA and the function
                                // will return.
                                Win32Error = ERROR_INVALID_DATA;
                            }
                        }
                        //
                        //  check 3: check lo guard page for corruption
                        //
                        if (bBufferOK) {
                            bGuardPageOK = TRUE;
                            for (lpCheckPointer = (LPDWORD)lpLowGuardPage;
                                    lpCheckPointer < (LPDWORD)lpBufferBefore;
                                lpCheckPointer++) {
                                if (*lpCheckPointer != GUARD_PAGE_DWORD) {
                                    bGuardPageOK = FALSE;
                                        break;
                                }
                            }
                            if (!bGuardPageOK) {
                                pThisExtObj->dwLowerGPViolations++;
                                Win32Error = ERROR_INVALID_DATA;
                                bBufferOK = FALSE;
                            }
                        }
                        //
                        //  check 4: check hi guard page for corruption
                        //
                        if (bBufferOK) {
                            bGuardPageOK = TRUE;
                            for (lpCheckPointer = (LPDWORD)lpHiGuardPage;
                                lpCheckPointer < (LPDWORD)lpEndPointer;
                                lpCheckPointer++) {
                                    if (*lpCheckPointer != GUARD_PAGE_DWORD) {
                                        bGuardPageOK = FALSE;
                                    break;
                                }
                            }
                            if (!bGuardPageOK) {
                                pThisExtObj->dwUpperGPViolations++;
                                bBufferOK = FALSE;
                                Win32Error = ERROR_INVALID_DATA;
                            }
                        }
                       
                        //
                        if ((lExtCounterTestLevel <= EXT_TEST_ALL) && bBufferOK) {
                            //
                            //  Internal consistency checks
                            //
                            //
                            //  Check 5: Check object length field values
                            //
                            // first test to see if this is a foreign
                            // computer data block or not
                            //
                            pPerfData = (PERF_DATA_BLOCK *)lpBufferBefore;
                            if ((pPerfData->Signature[0] == (WCHAR)'P') &&
                                (pPerfData->Signature[1] == (WCHAR)'E') &&
                                (pPerfData->Signature[2] == (WCHAR)'R') &&
                                (pPerfData->Signature[3] == (WCHAR)'F')) {
                                // if this is a foreign computer data block, then the
                                // first object is after the header
                                pObject = (PERF_OBJECT_TYPE *) (
                                    (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                bForeignDataBuffer = TRUE;
                            } else {
                                // otherwise, if this is just a buffer from
                                // an extensible counter, the object starts
                                // at the beginning of the buffer
                                pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                bForeignDataBuffer = FALSE;
                            }
                            // go to where the pointers say the end of the
                            // buffer is and then see if it's where it
                            // should be
                            dwObjectBufSize = 0;
                            for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                dwObjectBufSize += pObject->TotalByteLength;
                                pObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                    pObject->TotalByteLength);
                            }
                            if (((LPBYTE)pObject != (LPBYTE)lpCallBuffer) || 
                                (dwObjectBufSize > BytesLeft)) {
                                // then a length field is incorrect. This is FATAL
                                // since it can corrupt the rest of the buffer
                                // and render the buffer unusable.
                                pThisExtObj->dwObjectSizeErrors++;
                                bBufferOK = FALSE;
                                Win32Error = ERROR_INVALID_DATA;
                            }
                            //
                            //  Test 6: Test instance field size values
                            //
                            if (bBufferOK) {
                                // set object pointer
                                if (bForeignDataBuffer) {
                                    pObject = (PERF_OBJECT_TYPE *) (
                                        (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                } else {
                                    // otherwise, if this is just a buffer from
                                    // an extensible counter, the object starts
                                    // at the beginning of the buffer
                                    pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                }

                                for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                    pNextObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                        pObject->TotalByteLength);

                                    if (pObject->NumInstances != PERF_NO_INSTANCES) {
                                        pInstance = (PERF_INSTANCE_DEFINITION *)
                                            ((LPBYTE)pObject + pObject->DefinitionLength);
                                        lInstIndex = 0;
                                        while (lInstIndex < pObject->NumInstances) {
                                            PERF_COUNTER_BLOCK *pCounterBlock;

                                            pCounterBlock = (PERF_COUNTER_BLOCK *)
                                                ((PCHAR) pInstance + pInstance->ByteLength);

                                            pInstance = (PERF_INSTANCE_DEFINITION *)
                                                ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);

                                            lInstIndex++;
                                        }
                                        if ((LPBYTE)pInstance > (LPBYTE)pNextObject) {
                                            bBufferOK = FALSE;
                                            Win32Error = ERROR_INVALID_DATA;
                                        }
                                    }

                                    if (!bBufferOK) {
                                        Win32Error = ERROR_INVALID_DATA;
                                        break;
                                    } else {
                                        pObject = pNextObject;
                                    }
                                }

                                if (!bBufferOK) {
                                    pThisExtObj->dwInstanceSizeErrors++;
                                    Win32Error = ERROR_INVALID_DATA;
                                }
                            }

                            //
                            //  Test 7: Test instance field size values
                            //
                            if (bBufferOK) {
                                // set object pointer
                                if (bForeignDataBuffer) {
                                    pObject = (PERF_OBJECT_TYPE *) (
                                        (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                } else {
                                    // otherwise, if this is just a buffer from
                                    // an extensible counter, the object starts
                                    // at the beginning of the buffer
                                    pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                }

                                for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                    pNextObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                        pObject->TotalByteLength);

                                    if (pObject->NumInstances != PERF_NO_INSTANCES) {
                                        pInstance = (PERF_INSTANCE_DEFINITION *)
                                            ((LPBYTE)pObject + pObject->DefinitionLength);
                                        lInstIndex = 0;
                                        while (lInstIndex < pObject->NumInstances) {
                                            PERF_COUNTER_BLOCK *pCounterBlock;

                                            pCounterBlock = (PERF_COUNTER_BLOCK *)
                                                ((PCHAR) pInstance + pInstance->ByteLength);

                                            pInstance = (PERF_INSTANCE_DEFINITION *)
                                                ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);

                                            lInstIndex++;
                                        }
                                        if ((LPBYTE)pInstance > (LPBYTE)pNextObject) {
                                            bBufferOK = FALSE;
                                            Win32Error = ERROR_INVALID_DATA;
                                        }
                                    }

                                    if (!bBufferOK) {
                                        Win32Error = ERROR_INVALID_DATA;
                                        break;
                                    } else {
                                        pObject = pNextObject;
                                    }
                                }

                                if (!bBufferOK) {
                                    Win32Error = ERROR_INVALID_DATA;
                                    pThisExtObj->dwInstanceNameErrors++;
                                }
                            }
                        }
                    }
                    //
                    // if all the tests pass,then copy the data to the
                    // original buffer and update the pointers
                    if (bBufferOK) {
                        RtlMoveMemory (lpDataDefinition,
                            lpBufferBefore,
                            BytesLeft); // returned buffer size
                    } else {
                        NumObjectTypes = 0; // since this buffer was tossed
                    }
                } else {
                    // function already copied data to caller's buffer
                    // so no further action is necessary
                }
                lpDataDefinition = (LPVOID)((LPBYTE)(lpDataDefinition) + BytesLeft);    // update data pointer
            } else {
                if (Win32Error != ERROR_SUCCESS) {
                    if (Win32Error != WAIT_TIMEOUT) {
                        // don't count timeouts as function errors
                        InterlockedIncrement ((LONG *)&pThisExtObj->dwErrorCount);
                    }
                }
                if (bUnlockObjData) {
                    ReleaseMutex (pThisExtObj->hMutex);
                }

                NumObjectTypes = 0; // clear counter
            }// end if function returned successfully

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Win32Error = GetExceptionCode();
            InterlockedIncrement ((LONG *)&pThisExtObj->dwExceptionCount);
            bException = TRUE;
            if (bUnlockObjData) {
                ReleaseMutex (pThisExtObj->hMutex);
                bUnlockObjData = FALSE;
            }
        }
        if (bUseSafeBuffer) {
            HeapFree (hTestHeap, 0, lpExtDataBuffer);
        }
    } else {
        // unable to allocate memory so set error value
        Win32Error = ERROR_OUTOFMEMORY;
    } // end if temp buffer allocated successfully
    RELEASE_MUTEX (pThisExtObj->hMutex);

    lReturnValue = Win32Error;

    return lReturnValue;
}

DWORD
CloseLibrary (
    EXT_OBJECT  *pInfo
)
{
    DWORD   lStatus;

    if (pInfo != NULL) {
	    // if there's a close proc to call, then 
	    // call close procedure to close anything that may have
	    // been allocated by the library
        WAIT_FOR_AND_LOCK_MUTEX (pInfo->hMutex);
	    if (pInfo->CloseProc != NULL) {
		    lStatus = (*pInfo->CloseProc) ();
	    }
        RELEASE_MUTEX (pInfo->hMutex);

        // then close everything
        if (pInfo->hMutex != NULL) {
            CloseHandle (pInfo->hMutex);
            pInfo->hMutex = NULL;
        }
    
        if (pInfo->hLibrary != NULL) {
            FreeLibrary (pInfo->hLibrary);
            pInfo->hLibrary = NULL;
        }

        if (pInfo->hPerfKey != NULL) {
            RegCloseKey (pInfo->hPerfKey);
            pInfo->hPerfKey = NULL;
        }

        HeapFree (hTestHeap, 0, pInfo);
    }

    return ERROR_SUCCESS;
}

static
LPWSTR
*BuildNameTable(
    LPCWSTR szMachineName,
    LPCWSTR lpszLangIdArg,     // unicode value of Language subkey
    PDWORD  pdwLastItem,     // size of array in elements
    PDWORD  pdwIdArray      // array for index ID's
)
/*++
   
BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:
     
    pointer to an allocated table. (the caller must MemoryFree it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{
    HKEY    hKeyRegistry;   // handle to registry db with counter names

    LPWSTR  *lpReturnValue;
    LPCWSTR lpszLangId;

    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;

    LPWSTR  lpThisName;

    LONG    lWin32Status;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    DWORD   dwThisCounter;
    
    DWORD   dwLastId;
    DWORD   dwLastHelpId;

    DWORD   dwLastCounterIdUsed;
    DWORD   dwLastHelpIdUsed;
    
    HKEY    hKeyValue;
    HKEY    hKeyNames;

    LPWSTR  lpValueNameString;
    WCHAR   CounterNameBuffer [50];
    WCHAR   HelpNameBuffer [50];

    SetLastError (ERROR_SUCCESS);
    szTestErrorMessage = NULL;

    if (szMachineName != NULL) {
        lWin32Status = RegConnectRegistryW (szMachineName,
            HKEY_LOCAL_MACHINE,
            &hKeyRegistry);
    } else {
        lWin32Status = ERROR_SUCCESS;
        hKeyRegistry = HKEY_LOCAL_MACHINE;
    }

    lpValueNameString = NULL;   //initialize to NULL
    lpReturnValue = NULL;
    hKeyValue = NULL;
    hKeyNames = NULL;
   
    // check for null arguments and insert defaults if necessary

    if (!lpszLangIdArg) {
        lpszLangId = cszDefaultLangId;
    } else {
        lpszLangId = lpszLangIdArg;
    }

    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyExW (
        hKeyRegistry,
        cszNamesKey,
        0L,
        KEY_READ,
        &hKeyValue);
    
    if (lWin32Status != ERROR_SUCCESS) {
        szTestErrorMessage = (LPWSTR)L"Unable to Open Perflib key";
        goto BNT_BAILOUT;
    }

    // get config info
    dwValueType = 0;
    dwBufferSize = sizeof (pdwIdArray[4]);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        (LPCWSTR)L"Disable Performance Counters",
        0L,
        &dwValueType,
        (LPBYTE)&pdwIdArray[4],
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        if (lWin32Status == ERROR_FILE_NOT_FOUND) {
            // this is OK since the value need not be present
            pdwIdArray[4] = (DWORD)-1;
            lWin32Status = ERROR_SUCCESS;
        } else {
            szTestErrorMessage = (LPWSTR)L"Unable to read Disable Performance Counters value";
            goto BNT_BAILOUT;
        }
    }
    
    dwValueType = 0;
    dwBufferSize = sizeof (pdwIdArray[5]);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        (LPCWSTR)L"ExtCounterTestLevel",
        0L,
        &dwValueType,
        (LPBYTE)&pdwIdArray[5],
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        if (lWin32Status == ERROR_FILE_NOT_FOUND) {
            // this is OK since the value need not be present
            pdwIdArray[5] = (DWORD)-1;
            lWin32Status = ERROR_SUCCESS;
        } else {
            szTestErrorMessage  = (LPWSTR)L"Unable to read ExCounterTestLevel value";
            goto BNT_BAILOUT;
        }
    }
    
    dwValueType = 0;
    dwBufferSize = sizeof (pdwIdArray[6]);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        (LPCWSTR)L"Base Index",
        0L,
        &dwValueType,
        (LPBYTE)&pdwIdArray[6],
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        szTestErrorMessage  = (LPWSTR)L"Unable to read Base Index value";
        goto BNT_BAILOUT;
    }
    
    // get number of items
    
    dwBufferSize = sizeof (dwLastHelpId);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        cszLastHelp,
        0L,
        &dwValueType,
        (LPBYTE)&dwLastHelpId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        szTestErrorMessage  = (LPWSTR)L"Unable to read Last Help value";
        goto BNT_BAILOUT;
    }

    pdwIdArray[2] = dwLastHelpId;

    // get number of items
    
    dwBufferSize = sizeof (dwLastId);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        cszLastCounter,
        0L,
        &dwValueType,
        (LPBYTE)&dwLastId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        szTestErrorMessage  = (LPWSTR)L"Unable to read Last Counter value";
        goto BNT_BAILOUT;
    }
    
    pdwIdArray[0] = dwLastId;
    
    if (dwLastId < dwLastHelpId)
        dwLastId = dwLastHelpId;

    dwArraySize = dwLastId * sizeof(LPWSTR);

    // get Perflib system version
    if (szMachineName[0] == 0) {
        hKeyNames = HKEY_PERFORMANCE_DATA;
    } else {
        lWin32Status = RegConnectRegistryW (szMachineName,
            HKEY_PERFORMANCE_DATA,
            &hKeyNames);
    }
    lstrcpyW (CounterNameBuffer, cszCounterName);
    lstrcatW (CounterNameBuffer, lpszLangId);

    lstrcpyW (HelpNameBuffer, cszHelpName);
    lstrcatW (HelpNameBuffer, lpszLangId);

    // get size of counter names and add that to the arrays
    
    dwBufferSize = 0;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        CounterNameBuffer,
        0L,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        szTestErrorMessage  = (LPWSTR)L"Unable to query counter string size";
        goto BNT_BAILOUT;
    }

    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays
    
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        HelpNameBuffer,
        0L,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        szTestErrorMessage  = (LPWSTR)L"Unable to query help string size";
        goto BNT_BAILOUT;
    }

    dwHelpSize = dwBufferSize;

    lpReturnValue = (LPWSTR *)HeapAlloc (hTestHeap, 0,dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) {
        lWin32Status = ERROR_OUTOFMEMORY;
        szTestErrorMessage  = (LPWSTR)L"Unable to allocate name string buffer";
        goto BNT_BAILOUT;
    }
    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        CounterNameBuffer,
        0L,
        &dwValueType,
        (LPBYTE)lpCounterNames,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        szTestErrorMessage  = (LPWSTR)L"Unable to query counter string contents";
        goto BNT_BAILOUT;
    }
 
    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        HelpNameBuffer,
        0L,
        &dwValueType,
        (LPBYTE)lpHelpText,
        &dwBufferSize);
                            
    if (lWin32Status != ERROR_SUCCESS) {
        szTestErrorMessage  = (LPWSTR)L"Unable to query help string contents";
        goto BNT_BAILOUT;
    }

    dwLastCounterIdUsed = 0;
    dwLastHelpIdUsed = 0;

    // load counter array items

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlenW(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) {
            lWin32Status = ERROR_BADKEY;
            szTestErrorMessage  = (LPWSTR)L"Bad counter string entry, CONFIG_String_LastCounter is last valid counter string index";
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name

        lpThisName += (lstrlenW(lpThisName)+1);  

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastCounterIdUsed) dwLastCounterIdUsed = dwThisCounter;

    }

    pdwIdArray[1] = dwLastCounterIdUsed;

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlenW(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) {
            lWin32Status = ERROR_BADKEY;
            szTestErrorMessage  = (LPWSTR)L"Bad help string entry, CONFIG_String_LastHelp is last valid counter string index";
            goto BNT_BAILOUT;  // bad entry
        }
        // point to corresponding counter name

        lpThisName += (lstrlenW(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastHelpIdUsed) dwLastHelpIdUsed= dwThisCounter;
    }

    pdwIdArray[3] = dwLastHelpIdUsed;

    dwLastId = dwLastHelpIdUsed;
    if (dwLastId < dwLastCounterIdUsed) dwLastId = dwLastCounterIdUsed;

    if (pdwLastItem) *pdwLastItem = dwLastId;

    HeapFree (hTestHeap, 0, (LPVOID)lpValueNameString);
    RegCloseKey (hKeyValue);
    RegCloseKey (hKeyNames);

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        SetLastError (lWin32Status);
    }

    if (lpValueNameString) {
        HeapFree (hTestHeap, 0, (LPVOID)lpValueNameString);
    }
    
    if (lpReturnValue) {
        HeapFree (hTestHeap, 0, (LPVOID)lpValueNameString);
    }
    
    if (hKeyValue) RegCloseKey (hKeyValue);

    RegCloseKey (hKeyNames);

    return NULL;
}

DWORD
CycleTest (
    DWORD   dwThreadId,
    PLOCAL_THREAD_DATA  pData
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwRetStatus = ERROR_SUCCESS;
    EXT_OBJECT *pObj = NULL;
    LPWSTR  szValueString = pData->szQueryString;
    LPCWSTR szServiceName = pData->szServiceName;
    DWORD   dwLoopCount = pData->dwLoopCount;
    LPBYTE  pBuffer = NULL;
    LPBYTE  pThisBuffer;
    DWORD   dwBufSize = 0;
    DWORD   dwThisBufSize;
    DWORD   dwMemorySizeIncrement = 0x100;
    FILE    *pOutput = pData->pOutput;
    DOUBLE  dMs;
    LPWSTR  *pNameTable = pData->pNameTable;
    DWORD   dwLastId = pData->dwLastIndex;

    PERF_OBJECT_TYPE *  pObjDef;
    PERF_COUNTER_DEFINITION *   pCtrDef;
    DWORD   nObjIdx, nCtrIdx;

    UNREFERENCED_PARAMETER (dwThreadId);

    dwStatus = OpenLibrary (szServiceName, &pObj);

    if (pObj != NULL) {
         // an object info block was returned
        dMs = (DOUBLE)pObj->llOpenTime;     // ticks used
        dMs /= (DOUBLE)pObj->llTimeBase;    // ticks/sec
        dMs *= 1000.0;                      // ms/Sec
        fwprintf (pOutput, (LPCWSTR)L"\n\t\tINFO_OpenProcTime:       \t%12.5f mSec", dMs);
        fwprintf (pOutput, (LPCWSTR)L"\n\t\tINFO_OpenProcTimeout:    \t%6d.00000 mSec", pObj->dwOpenTimeout);

        // check for timeout
        if (dMs > (DOUBLE)pObj->dwOpenTimeout) {
            dwRetStatus = ERROR_TIMEOUT;
            fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:    \tOpen procedure exceeded timeout");
        }
    } else {
        // no object block returned
        fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:    \tUnable to open Library");
        fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORCODE:\t0x%8.8x (%dL)", dwStatus, dwStatus);
        dwRetStatus = dwStatus;
    } 

    if (dwRetStatus == ERROR_SUCCESS) {

        HeapValidate (hTestHeap, 0, NULL);

        // get the buffer size
        dwStatus = ERROR_MORE_DATA;
        do {
            if (pBuffer != NULL) HeapFree (hTestHeap, 0, pBuffer);

            dwBufSize += dwMemorySizeIncrement;
            dwMemorySizeIncrement *= 2;
            pBuffer = (LPBYTE) HeapAlloc (hTestHeap, HEAP_ZERO_MEMORY, dwBufSize);

            if (pBuffer != NULL) {
                // init the args
                pThisBuffer = pBuffer;
                dwThisBufSize = dwBufSize;
    
                HeapValidate (hTestHeap, 0, NULL);

                dwStatus = CollectData (pObj, 
                    pThisBuffer,
                    &dwThisBufSize,
                    szValueString);
            }
        } while ((dwStatus == ERROR_MORE_DATA) && (dwBufSize < MAX_BUF_SIZE));

        if (dwBufSize >= MAX_BUF_SIZE) {
            fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:    \tCollectFunction requires a buffer > %d bytes", MAX_BUF_SIZE);
            if (pBuffer != NULL) HeapFree (hTestHeap, 0, pBuffer);
            dwStatus = ERROR_INVALID_PARAMETER;
        } else if (pBuffer == NULL) {
            dwStatus = ERROR_OUTOFMEMORY;
        } else {

            // call collect function
            do {
                // init the args
                pThisBuffer = pBuffer;
                dwThisBufSize = dwBufSize;

                // get the data
                dwStatus = CollectData (pObj, 
                            pThisBuffer,
                            &dwThisBufSize,
                            szValueString);

                while ((dwStatus == ERROR_MORE_DATA) && (dwBufSize < MAX_BUF_SIZE)) {
                    if (pBuffer != NULL) HeapFree (hTestHeap, 0, pBuffer);

                    dwBufSize += dwMemorySizeIncrement;
                    dwMemorySizeIncrement *= 2;
                    pBuffer = (LPBYTE) HeapAlloc (hTestHeap, HEAP_ZERO_MEMORY, dwBufSize);

                    if (pBuffer != NULL) {
                        // init the args
                        pThisBuffer = pBuffer;
                        dwThisBufSize = dwBufSize;
   
                        // get the data again
                        dwStatus = CollectData (pObj, 
                                    pThisBuffer,
                                    &dwThisBufSize,
                                    szValueString);

                        if ((dwStatus == ERROR_SUCCESS) && (pData->bTestContents)) {
                            pObjDef = (PERF_OBJECT_TYPE *)pThisBuffer;
                            for (nObjIdx = 0; nObjIdx < pObj->dwNumObjectsRet; nObjIdx++) {
                                // test object name & help
                                if ((pObjDef->ObjectNameTitleIndex <= dwLastId) && 
                                    (pObjDef->ObjectNameTitleIndex > 0)) {
                                    if (pNameTable[pObjDef->ObjectNameTitleIndex ] == NULL) {
                                        // no string
                                        fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:\tNo Display String for index %d", pObjDef->ObjectNameTitleIndex );
                                        dwStatus = ERROR_BADKEY;
                                    } else {
                                        // probably ok
                                    }
                                } else {
                                    // id out of range
                                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:\tObject Name Index values are bad or missing");
                                    dwStatus = ERROR_BADKEY;
                                }
                                // test counter defs
                                if ((pObjDef->ObjectHelpTitleIndex <= dwLastId) && 
                                    (pObjDef->ObjectHelpTitleIndex> 0)) {
                                    if (pNameTable[pObjDef->ObjectHelpTitleIndex] == NULL) {
                                        // no string
                                        fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:\tNo Display String for index %d", pObjDef->ObjectHelpTitleIndex );
                                        dwStatus = ERROR_BADKEY;
                                    } else {
                                        // probably ok
                                    }
                                } else {
                                    // id out of range
                                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:\tObject Help Index values are bad or missing");
                                    dwStatus = ERROR_BADKEY;
                                }
                                pCtrDef = FirstCounter (pObjDef);
                                for (nCtrIdx = 0; nCtrIdx < pObjDef->NumCounters; nCtrIdx++) {
                                    pCtrDef = NextCounter (pCtrDef);
                                    if ((pCtrDef->CounterNameTitleIndex <= dwLastId) && 
                                        (pCtrDef->CounterNameTitleIndex > 0)) {
                                        if (pNameTable[pCtrDef->CounterNameTitleIndex ] == NULL) {
                                            // no string
                                            fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:\tNo Display String for index %d", pCtrDef->CounterNameTitleIndex );
                                            dwStatus = ERROR_BADKEY;
                                        } else {
                                            // probably ok
                                        }
                                    } else {
                                        // id out of range
                                        fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:\tCounter Name Index values are bad or missing");
                                        dwStatus = ERROR_BADKEY;
                                    }
                                    // test counter defs
                                    if ((pCtrDef->CounterHelpTitleIndex <= dwLastId) && 
                                        (pCtrDef->CounterHelpTitleIndex> 0)) {
                                        if (pNameTable[pCtrDef->CounterHelpTitleIndex] == NULL) {
                                            // no string
                                            fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:\tNo Display String for index %d", pCtrDef->CounterHelpTitleIndex );
                                            dwStatus = ERROR_BADKEY;
                                        } else {
                                            // probably ok
                                        }
                                    } else {
                                        // id out of range
                                        fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:\tCounter Help Index values are bad or missing");
                                        dwStatus = ERROR_BADKEY;
                                    }
                                }
                                pObjDef = NextObject (pObjDef);
                            }                                
                        }

                        HeapValidate (hTestHeap, 0, NULL);
                    }
                } 

                if (dwStatus != ERROR_SUCCESS) {
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:    \tCollect procedure returned an error");
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORCODE:\t0x%8.8x (%dL)", dwStatus, dwStatus);

                    // output the contents of the info buffer
                    if (dwStatus == ERROR_TIMEOUT) {
                        // dump collect fn stats.
                        dMs = (DOUBLE)pObj->llFunctionTime;
                        dMs /= (DOUBLE)pObj->llTimeBase;
                        dMs *= 1000.0;
                        fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_CollectProcTime:\t%12.5f mSec", dMs);
                        fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_CollectTimeout: \t%6d.00000 mSec", pObj->dwCollectTimeout);
                    }

                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_CollectTime: \t%I64u", pObj->llCollectTime);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_CollectCount:\t%d", pObj->dwCollectCount);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_OpenCount:   \t%d", pObj->dwOpenCount);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_CloseCount:  \t%d", pObj->dwCloseCount);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_LockoutCount:\t%d", pObj->dwLockoutCount);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_ErrorCount:  \t%d", pObj->dwErrorCount);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_Exceptions:  \t%d", pObj->dwExceptionCount);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_LowerGPErrs: \t%d", pObj->dwLowerGPViolations);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_UpperGPErrs: \t%d", pObj->dwUpperGPViolations);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_BadPointers: \t%d", pObj->dwBadPointers);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_BufSizeErrs: \t%d", pObj->dwBufferSizeErrors);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_AlignErrors: \t%d", pObj->dwAlignmentErrors);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_ObjSizeErrs: \t%d", pObj->dwObjectSizeErrors);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_InstSizeErrs:\t%d", pObj->dwInstanceSizeErrors);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_TimeBase:    \t%I64u", pObj->llTimeBase);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_FunctionTime:\t%I64u", pObj->llFunctionTime);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_ObjectsRet:  \t%d", pObj->dwNumObjectsRet);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tERRORINFO_RetBuffSize: \t%d", pObj->dwRetBufSize);
                    break;
                }
            } while (--dwLoopCount > 0);

            if (dwStatus == ERROR_SUCCESS) {
                // dump collect fn stats.
                if ((pObj->dwCollectCount > 0)  && (pObj->dwNumObjectsRet > 0)){
                    // don't compute time if no objects were returned
                    dMs = (DOUBLE)pObj->llCollectTime;
                    dMs /= (DOUBLE)pObj->llTimeBase;
                    dMs *= 1000.0;
                    dMs /= (DOUBLE)pObj->dwCollectCount;
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tINFO_AvgCollectProcTime: \t%12.5f mSec", dMs);
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tINFO_CollectProcTimeout: \t%6d.00000 mSec", pObj->dwCollectTimeout);
                }
                fwprintf (pOutput, (LPCWSTR)L"\n\t\tINFO_ObjectsRet:         \t%d", pObj->dwNumObjectsRet);
                fwprintf (pOutput, (LPCWSTR)L"\n\t\tINFO_RetBuffSize:        \t%d", pObj->dwRetBufSize);
            }

            HeapFree (hTestHeap, 0, pBuffer);
        }
        dwRetStatus = dwStatus;

        // close
        CloseLibrary (pObj);

    } // unable to open library

    HeapValidate (hTestHeap, 0, NULL);

    return dwStatus;
}

DWORD
CycleThreadProc (
    LPVOID  lpThreadArg
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    PLOCAL_THREAD_DATA  pData= (PLOCAL_THREAD_DATA)lpThreadArg;
    DWORD dwCycleCount = pData->dwCycleCount;
    
    DWORD   dwThisThread = GetCurrentThreadId();

    HeapValidate (hTestHeap, 0, NULL);

    do {
        // argv[1] is the name of the 
        dwStatus = CycleTest(dwThisThread, pData);
    } while (--dwCycleCount > 0);

    HeapValidate (hTestHeap, 0, NULL);

    return dwStatus;
}
int
WriteTestResultHeader(
    FILE *pOutput
)
{
    OSVERSIONINFOW       osInfo;
    WCHAR               szMachineName[MAX_PATH];
    DWORD               dwSize;
    SYSTEMTIME          stStart;

    memset (&osInfo, 0, sizeof(osInfo));
    osInfo.dwOSVersionInfoSize = sizeof(osInfo);

    memset (szMachineName, 0, sizeof(szMachineName));
    memset (&stStart, 0, sizeof(stStart));

    GetVersionExW (&osInfo);

    dwSize = sizeof(szMachineName) / sizeof (szMachineName[0]);
    GetComputerNameW (&szMachineName[0], &dwSize);

    GetLocalTime (&stStart);

    fwprintf (pOutput, (LPCWSTR)L"\n[TESTRESULT]");
    fwprintf (pOutput, (LPCWSTR)L"\n\tTEST:    \tPerf Counter DLL Validation");
    fwprintf (pOutput, (LPCWSTR)L"\n\tBUILD:   \t%d", osInfo.dwBuildNumber);
    fwprintf (pOutput, (LPCWSTR)L"\n\tMACHINE:\t%s", szMachineName);
    fwprintf (pOutput, (LPCWSTR)L"\n\tCONTACT:\t%s", szContact);
    fwprintf (pOutput, (LPCWSTR)L"\n\tMGR CONTACT:\t%s", szMgrContact);
    fwprintf (pOutput, (LPCWSTR)L"\n\tDEV PRIME:\t%s", szDevPrime);
    fwprintf (pOutput, (LPCWSTR)L"\n\tDEV ALT:\t%s", szDevAlt);
    fwprintf (pOutput, (LPCWSTR)L"\n\tTEST PRIME:\t%s", szTestPrime);
    fwprintf (pOutput, (LPCWSTR)L"\n\tTEST ALT:\t%s", szTestAlt);

    fwprintf (pOutput, (LPCWSTR)L"\n\tSTART TIME:\t%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d",
                    stStart.wMonth, stStart.wDay, stStart.wYear % 100,
                    stStart.wHour, stStart.wMinute, stStart.wSecond );

    return 0;
}

int
WriteTestConfigData(
    FILE *pOutput,
    LPDWORD pdwIdInfo
)
{
    fwprintf (pOutput, (LPCWSTR)L"\n\t");
    fwprintf (pOutput, (LPCWSTR)L"\n\tCONFIG_Perflib_LastCounter:\t%d", pdwIdInfo[0]);
    fwprintf (pOutput, (LPCWSTR)L"\n\tCONFIG_String_LastCounter: \t%d", pdwIdInfo[1]);
    fwprintf (pOutput, (LPCWSTR)L"\n\tCONFIG_Perflib_LastHelp:   \t%d", pdwIdInfo[2]);
    fwprintf (pOutput, (LPCWSTR)L"\n\tCONFIG_String_LastHelp:    \t%d", pdwIdInfo[3]);
    fwprintf (pOutput, (LPCWSTR)L"\n\tCONFIG_Disabled:           \t%d", pdwIdInfo[4]);
    fwprintf (pOutput, (LPCWSTR)L"\n\tCONFIG_ExtCounterTestLevel:\t%d", pdwIdInfo[5]);
    fwprintf (pOutput, (LPCWSTR)L"\n\tCONFIG_BaseIndex:          \t%d", pdwIdInfo[6]);
//    fwprintf (pOutput, (LPCWSTR)L"\n\tCONFIG_BaseOsObject   :    \t%d", pdwIdInfo[7]);
    
    return 0;
}

DWORD
WriteGroupConfig(
    FILE    *pOutput,
    HKEY    hKeyPerfSubKey,
    DWORD   *pIds
)
{
    DWORD   nRetStatus = (int)ERROR_SUCCESS;
    DWORD   lStatus;
    DWORD   dwData;
    DWORD   dwBufferSize;
    DWORD   dwValueType;
    WCHAR   szStringBuffer[MAX_PATH*2];

    dwBufferSize = sizeof(szStringBuffer);
    dwValueType = 0;
    memset (szStringBuffer, 0, sizeof(szStringBuffer));
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Library",
        0L,
        &dwValueType,
        (LPBYTE)&szStringBuffer[0],
        &dwBufferSize);
 
    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_Library:\t%s", 
        (lStatus == ERROR_SUCCESS ? szStringBuffer : cszNotFound));
    if (lStatus != ERROR_SUCCESS) nRetStatus = lStatus;

    dwBufferSize = sizeof(szStringBuffer);
    dwValueType = 0;
    memset (szStringBuffer, 0, sizeof(szStringBuffer));
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Open",
        0L,
        &dwValueType,
        (LPBYTE)&szStringBuffer[0],
        &dwBufferSize);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_Open:\t%s", 
        (lStatus == ERROR_SUCCESS ? szStringBuffer : cszNotFound));
    if (lStatus != ERROR_SUCCESS) nRetStatus = lStatus;
        

    dwBufferSize = sizeof(szStringBuffer);
    dwValueType = 0;
    memset (szStringBuffer, 0, sizeof(szStringBuffer));
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Collect",
        0L,
        &dwValueType,
        (LPBYTE)&szStringBuffer[0],
        &dwBufferSize);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_Collect:\t%s", 
        (lStatus == ERROR_SUCCESS ? szStringBuffer : cszNotFound));
    if (lStatus != ERROR_SUCCESS) nRetStatus = lStatus;

    dwBufferSize = sizeof(szStringBuffer);
    dwValueType = 0;
    memset (szStringBuffer, 0, sizeof(szStringBuffer));
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Object List",
        0L,
        &dwValueType,
        (LPBYTE)&szStringBuffer[0],
        &dwBufferSize);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_Object List:\t%s", 
        (lStatus == ERROR_SUCCESS ? szStringBuffer : cszNotFound));

    dwBufferSize = sizeof(szStringBuffer);
    dwValueType = 0;
    memset (szStringBuffer, 0, sizeof(szStringBuffer));
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Close",
        0L,
        &dwValueType,
        (LPBYTE)&szStringBuffer[0],
        &dwBufferSize);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_Close:\t%s", 
        (lStatus == ERROR_SUCCESS ? szStringBuffer : cszNotFound));
    if (lStatus != ERROR_SUCCESS) nRetStatus = lStatus;

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"First Counter",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_First Counter:\t%d", 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)-1));
    if (lStatus != ERROR_SUCCESS) {
        if (lStatus == ERROR_FILE_NOT_FOUND) {
            if (!pIds[4]) {
                // then this hasn't been installed yet
                nRetStatus = ERROR_SERVICE_DISABLED;
            } else {
                // then this is a base OS service
                nRetStatus = ERROR_SUCCESS;
            }
        } else {
            // some other error so return
            nRetStatus = lStatus;
        }
        pIds[0] = (DWORD)-1;
    } else {
        pIds[0] = dwData;
    }

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Last Counter",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_Last Counter:\t%d", 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)-1));
    if (lStatus != ERROR_SUCCESS) {
        if (lStatus == ERROR_FILE_NOT_FOUND) {
            if (!pIds[4]) {
                // then this hasn't been installed yet
                nRetStatus = ERROR_SERVICE_DISABLED;
            } else {
                // then this is a base OS service
                nRetStatus = ERROR_SUCCESS;
            }
        } else {
            // some other error so return
            nRetStatus = lStatus;
        }
        pIds[1] = (DWORD)-1;
    } else {
        pIds[1] = dwData;
    }

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"First Help",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_First Help:\t%d", 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)-1));
    if (lStatus != ERROR_SUCCESS) {
        if (lStatus == ERROR_FILE_NOT_FOUND) {
            if (!pIds[4]) {
                // then this hasn't been installed yet
                nRetStatus = ERROR_SERVICE_DISABLED;
            } else {
                // then this is a base OS service
                nRetStatus = ERROR_SUCCESS;
            }
        } else {
            // some other error so return
            nRetStatus = lStatus;
        }
        pIds[2] = (DWORD)-1;
    } else {
        pIds[2] = dwData;
    }

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Last Help",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_Last Help:\t%d", 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)-1));
    if (lStatus != ERROR_SUCCESS) {
        if (lStatus == ERROR_FILE_NOT_FOUND) {
            if (!pIds[4]) {
                // then this hasn't been installed yet
                nRetStatus = ERROR_SERVICE_DISABLED;
            } else {
                // then this is a base OS service
                nRetStatus = ERROR_SUCCESS;
            }
        } else {
            // some other error so return
            nRetStatus = lStatus;
        }
        pIds[3] = (DWORD)-1;
    } else {
        pIds[3] = dwData;
    }

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Open Timeout",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_Open Timeout:\t%d", 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)10000));

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Collect Timeout",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_Collect Timeout:\t%d", 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)10000));

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Disable Performance Counters",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tCONFIG_Disable Performance Counters:\t%d", 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)0));
    if ((lStatus == ERROR_SUCCESS) && (dwData != 0)){
        nRetStatus = ERROR_SERVICE_DISABLED;
    }

    return nRetStatus;
}

int
WriteTestResultTrailer(
    FILE *pOutput, 
    DWORD dwTestResult
)
{
    SYSTEMTIME          stEnd;
    LPWSTR              szResult;

    memset (&stEnd, 0, sizeof(stEnd));

    GetLocalTime (&stEnd);

    switch (dwTestResult) {
        case PERFVAL_PASS:
            szResult = (LPWSTR)L"PASS"; break;

        case PERFVAL_FAIL:
            szResult = (LPWSTR)L"FAIL"; break;

        case PERFVAL_TIMEOUT:
            szResult = (LPWSTR)L"TIMEOUT"; break;

        case PERFVAL_NOCONFIG:
        default:
            szResult = (LPWSTR)L"NOCONFIG"; break;
    }

    fwprintf (pOutput, (LPCWSTR)L"\n\n\tRESULT:   \t%s", szResult);
        
    fwprintf (pOutput, (LPCWSTR)L"\n\tEND TIME:\t%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d",
                    stEnd.wMonth, stEnd.wDay, stEnd.wYear % 100,
                    stEnd.wHour, stEnd.wMinute, stEnd.wSecond);

    fwprintf (pOutput, (LPCWSTR)L"\n[/TESTRESULT]");

    fwprintf (pOutput, (LPCWSTR)L"\n");
    return 0;
}

int
WriteGroupHeader(FILE *pOutput, LPCWSTR szGroupName)
{
    SYSTEMTIME          stStart;

    memset (&stStart, 0, sizeof(stStart));

    GetLocalTime (&stStart);

    fwprintf (pOutput, (LPCWSTR)L"\n\n\t[GROUP: %s]", szGroupName);

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tSTART TIME:\t%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%3.3d",
                    stStart.wMonth, stStart.wDay, stStart.wYear % 100,
                    stStart.wHour, stStart.wMinute, stStart.wSecond, stStart.wMilliseconds );

    return 0;
}

int
WriteGroupTrailer(FILE *pOutput, DWORD dwTestResult)
{
    LPWSTR              szResult;
    SYSTEMTIME          stEnd;

    memset (&stEnd, 0, sizeof(stEnd));

    GetLocalTime (&stEnd);

    switch (dwTestResult) {
        case PERFVAL_PASS:
            szResult = (LPWSTR)L"PASS"; break;

        case PERFVAL_FAIL:
            szResult = (LPWSTR)L"FAIL"; break;

        case PERFVAL_TIMEOUT:
            szResult = (LPWSTR)L"TIMEOUT"; break;

        case PERFVAL_NOCONFIG:
        default:
            szResult = (LPWSTR)L"NOCONFIG"; break;
    }

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tEND TIME:\t%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%3.3d",
                    stEnd.wMonth, stEnd.wDay, stEnd.wYear % 100,
                    stEnd.wHour, stEnd.wMinute, stEnd.wSecond, stEnd.wMilliseconds );

    fwprintf (pOutput, (LPCWSTR)L"\n\t\tRESULT:   %s", szResult);
    fwprintf (pOutput, (LPCWSTR)L"\n\t[/GROUP]");

    return 0;
}

int
PerfVal_ConfigTestFunction (
    FILE    *pOutput,
    LPDWORD pdwIdInfo
)
{
    DWORD   dwReturn = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER (pOutput);

    // configuration tests:
    //  LAST COUNTER in registry >= Last counter string index
    //  LAST HELP in registry >= Last help string index
    //  BASE INDEX == 1847

    SetLastError (ERROR_SUCCESS);
    szTestErrorMessage = NULL;
    
    if (pdwIdInfo[0] < pdwIdInfo[1]) {
        dwReturn = ERROR_INVALID_INDEX;
        szTestErrorMessage = (LPWSTR)L"Counter String has too many entries";
    }

    if (pdwIdInfo[2] < pdwIdInfo[3]) {
        dwReturn = ERROR_INVALID_INDEX;
        szTestErrorMessage = (LPWSTR)L"Help String has too many entries";
    }

    if (pdwIdInfo[6] != 1847) {
        dwReturn = ERROR_INVALID_PARAMETER;
        szTestErrorMessage = (LPWSTR)L"Base Index is incorrect";
    }
    
    return dwReturn;
}

int
PerfVal_ServiceTestConfig (
    FILE    *pOutput,
    LPDWORD dwNameIds,
    LPCWSTR *pNameTable,
    DWORD   dwLastId

)
{
    DWORD   dwServiceTestResult = ERROR_SUCCESS;
    DWORD   dwIdIdx = 0;

    // check counter strings
    if ((dwNameIds[0] != (DWORD)-1) && (dwNameIds[1] != (DWORD)-1)) {
        if (((dwNameIds[0] <= dwLastId) && (dwNameIds[1] <= dwLastId)) &&
            (dwNameIds[0] < dwNameIds[1])){
            for (dwIdIdx = dwNameIds[0]; dwIdIdx <= dwNameIds[1]; dwIdIdx += 2) {
                if (pNameTable[dwIdIdx] == NULL) {
                    // no string
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tWARNING:\tNo Display String for index %d", dwIdIdx);
                    dwServiceTestResult = ERROR_BADKEY;
                } else {
                    // probably ok
                }
            }
        } else {
            // id out of range
            fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:\tCounter Index values are bad or missing");
            dwServiceTestResult = ERROR_BADKEY;
        }
    } else {
        // not installed or a base counter
    }

    // check help strings
    if ((dwNameIds[2] != (DWORD)-1) && (dwNameIds[3] != (DWORD)-1)) {
        if (((dwNameIds[2] <= dwLastId) && (dwNameIds[3] <= dwLastId)) &&
            (dwNameIds[2] < dwNameIds[3])){
            for (dwIdIdx = dwNameIds[2]; dwIdIdx <= dwNameIds[3]; dwIdIdx += 2) {
                if (pNameTable[dwIdIdx] == NULL) {
                    // no string
                    fwprintf (pOutput, (LPCWSTR)L"\n\t\tWARNING:\tNo Display String for index %d", dwIdIdx);
                    dwServiceTestResult = ERROR_BADKEY;
                } else {
                    // probably ok
                }
            }
        } else {
            // id out of range
            fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:\tCounter Index values are bad or missing");
            dwServiceTestResult = ERROR_BADKEY;
        }
    } else {
        // not installed or a base counter
    }

    return dwServiceTestResult ;
}

DWORD
PerfVal_ServiceTestFunction (
    FILE    *pOutput,
    LPCWSTR szServiceName,
    HKEY    hKeyPerfSubKey,
    BOOL    bTestContents,
    LPWSTR  *pNameTable,
    DWORD   dwLastEntry
)
{
    DWORD   dwLoopCount = 1;
    DWORD   dwCycleCount = 1;
    DWORD   dwThreadCount = 0;
    LOCAL_THREAD_DATA   LTData;
    HANDLE  hThreads[MAXIMUM_WAIT_OBJECTS];
    DWORD   dwThisThread;
    DWORD   dwTimeout;
    DWORD   dwId;
    DWORD   dwStatus;

    UNREFERENCED_PARAMETER (hKeyPerfSubKey);

    LTData.szServiceName = (LPWSTR)szServiceName;
    LTData.szQueryString = (LPWSTR)L"Global";
    LTData.dwCycleCount = dwCycleCount;
    LTData.dwLoopCount = dwLoopCount;
    LTData.bDisplay = FALSE;//(dwThreadCount <= 1 ? TRUE : FALSE);
    LTData.pOutput = pOutput;
    LTData.bTestContents = bTestContents;
    LTData.pNameTable = pNameTable;
    LTData.dwLastIndex = dwLastEntry;

    if (dwThreadCount == 0) {
        dwStatus = CycleThreadProc ((LPVOID)&LTData);
    } else {
        // create threads
        for (dwThisThread = 0; dwThisThread < dwThreadCount; dwThisThread++) {
            hThreads[dwThisThread] = CreateThread(
                NULL, 0L, CycleThreadProc, (LPVOID)&LTData, 0L, &dwId);
        }
        dwTimeout = 60000 * dwCycleCount;   // allow 1 minute per cycle
        dwStatus = WaitForMultipleObjects (dwThreadCount, hThreads, TRUE, dwTimeout);
        if (dwStatus != WAIT_TIMEOUT) {
            dwStatus = ERROR_SUCCESS;
        } else {
            fwprintf (pOutput, (LPCWSTR)L"\n\t\tERROR:\tWait for test cycles to complete exceeded 60 seconds");
        }
        
        for (dwThisThread = 0; dwThisThread < dwThreadCount; dwThisThread++) {
            CloseHandle (hThreads[dwThisThread]);
        }
    }

    return dwStatus;
}

int
WriteTestError (
    FILE *pOutput,
    DWORD   dwTabLevel,
    DWORD   dwStatus
)
{
    DWORD   dwIndent;
    fwprintf (pOutput, (LPCWSTR)L"\n");
    for (dwIndent = 0; dwIndent < dwTabLevel; dwIndent++) {
        fwprintf (pOutput, (LPCWSTR)L"\t");
    }
    fwprintf (pOutput, (LPCWSTR)L"ERROR:    \t%s", (szTestErrorMessage != NULL ? szTestErrorMessage : (LPCWSTR)L"No Error"));

    fwprintf (pOutput, (LPCWSTR)L"\n");
    for (dwIndent = 0; dwIndent < dwTabLevel; dwIndent++) {
        fwprintf (pOutput, (LPCWSTR)L"\t");
    }
    fwprintf (pOutput, (LPCWSTR)L"ERRORCODE:\t0x%8.8x (%d)", dwStatus, dwStatus);
    return 0;
}  

int
__cdecl 
wmain(
    int argc,
    WCHAR *argv[]
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LONG    lStatus = ERROR_SUCCESS;
    LONG    lEnumStatus = ERROR_SUCCESS;
    DWORD   dwServiceIndex;
    WCHAR   szServiceSubKeyName[MAX_PATH];
    WCHAR   szPerfSubKeyName[MAX_PATH+20];
    DWORD   dwNameSize;
    HKEY    hKeyPerformance;
    DWORD   dwLastElement = 0;
    DWORD   dwIdArray[8];
    DWORD   dwServiceIds[8];

    HKEY    hKeyServices;
    HKEY    hKeyMachine = HKEY_LOCAL_MACHINE;
    DWORD   dwRegAccessMask = KEY_READ;
    DWORD   dwTestResult = PERFVAL_NOCONFIG;
    DWORD   dwGroupTestResult = PERFVAL_NOCONFIG;
    BOOL    bTestContents;

    FILE    *pOutput = stdout;

    LPWSTR  *pNameTable = NULL;

    UNREFERENCED_PARAMETER (argc);
    UNREFERENCED_PARAMETER (argv);

    // enumerate the services to find those with performance counters

    hProcessHeap = GetProcessHeap();

    hTestHeap = HeapCreate (HEAP_GENERATE_EXCEPTIONS, 0x10000, 0);

    if (hTestHeap == NULL) return (ERROR_OUTOFMEMORY);

    WriteTestResultHeader(pOutput);

    memset (&dwIdArray[0], 0, sizeof(dwIdArray));

    pNameTable = BuildNameTable (
        (LPCWSTR)L"",
        (LPCWSTR)L"009",
        &dwLastElement,     // size of array in elements
        &dwIdArray[0]);

    WriteTestConfigData(pOutput, &dwIdArray[0]);

    if (pNameTable == NULL) {
        // check for name table errors
        lStatus = GetLastError();       // so we don't continue
        dwTestResult = PERFVAL_FAIL;
        WriteTestError (pOutput, 1, lStatus);
    } else {
        // test config data
        lStatus = PerfVal_ConfigTestFunction (pOutput, &dwIdArray[0]); 
        if (lStatus != ERROR_SUCCESS) {
            dwTestResult = PERFVAL_FAIL;
            WriteTestError (pOutput, 1, lStatus);
        } else {
            // assume pass until something fails
            dwTestResult = PERFVAL_PASS;

            // continue with the test
            lStatus = RegOpenKeyExW (hKeyMachine,
                cszServiceKeyName,
                0L,
                dwRegAccessMask,
                &hKeyServices);

            if (lStatus != ERROR_SUCCESS) {
                dwTestResult = PERFVAL_FAIL;
                szTestErrorMessage = (LPWSTR)L"Unable to open the HKLM\\SYSTEM\\CurrentControlSet\\Services key";                
                WriteTestError (pOutput, 1, lStatus);
            } else {
                // continue processing
                dwServiceIndex = 0;
                dwNameSize = MAX_PATH;
                while ((lEnumStatus = RegEnumKeyExW (
                    hKeyServices,
                    dwServiceIndex,
                    szServiceSubKeyName,
                    &dwNameSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL)) == ERROR_SUCCESS) {

                    // assume pass until something fails
                    dwGroupTestResult = PERFVAL_PASS;

                    //try to open the perfkey under this key.
                    lstrcpyW (szPerfSubKeyName, szServiceSubKeyName);
                    lstrcatW (szPerfSubKeyName, cszPerformance);

                    lStatus = RegOpenKeyExW (
                        hKeyServices,
                        szPerfSubKeyName,
                        0L,
                        dwRegAccessMask,
                        &hKeyPerformance);

                    if (lStatus == ERROR_SUCCESS) {
                        WriteGroupHeader (pOutput, szServiceSubKeyName);
                        if (IsMsService (szServiceSubKeyName)) {
                            dwServiceIds[4] = 1;
                        } else {
                            dwServiceIds[4] = 0;
                        }
                        lStatus = WriteGroupConfig (pOutput, hKeyPerformance, &dwServiceIds[0]);

                        if (lStatus == ERROR_SUCCESS) {
                            // test this service
                            lStatus = PerfVal_ServiceTestConfig (pOutput, 
                                &dwServiceIds[0], pNameTable, dwLastElement);
                        }

                        if ((lStatus == ERROR_SUCCESS) || (lStatus == ERROR_BADKEY)){
                            bTestContents = (lStatus == ERROR_BADKEY ? TRUE : FALSE);
                            lStatus = PerfVal_ServiceTestFunction (pOutput, 
                                szServiceSubKeyName, hKeyPerformance, bTestContents, pNameTable, dwLastElement);
                        }
                        
                        if (lStatus != ERROR_SUCCESS) {
                            if (lStatus != ERROR_SERVICE_DISABLED) {
                                // if the service is disabled, then it's a pass,
                                // otherwise it's failed in the configuration.
                                dwGroupTestResult = PERFVAL_FAIL;
                                dwTestResult = PERFVAL_FAIL;
                            } else {
                                dwGroupTestResult = PERFVAL_NOCONFIG;
                            }
                        }

                        WriteGroupTrailer(pOutput, dwGroupTestResult);

                        RegCloseKey (hKeyPerformance);
                    }

                    // reset for next loop
                    dwServiceIndex++;
                    dwNameSize = MAX_PATH;
                }
                RegCloseKey (hKeyServices);
            }
        }
    }

    WriteTestResultTrailer(pOutput, dwTestResult);

    HeapDestroy (hTestHeap);	

    return (int)dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\ctrtest\ctrtest.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ctrtest.c

Abstract:

    Program to test the extensible counter dll's

Author:

    Bob Watson (bobw) 8 Feb 99

Revision History:

--*/
#include <windows.h>
#include <process.h>
#include <winperf.h>
#include <stdio.h>
#include <stdlib.h>
#include <pdhmsg.h>
#include "strings.h"
#include "ctrtest.h"

///////////////////////////////////////////////////////////////////////////////////////
//
//	Data Structures
//
///////////////////////////////////////////////////////////////////////////////////////

typedef struct _LOCAL_THREAD_DATA {
	DWORD	dwNumObjects;
	DWORD	dwCycleCount;
	DWORD	dwLoopCount;
    BOOL    bTestContents;
	BOOL	bDisplay;
	BOOL	bStopOnError;
} LOCAL_THREAD_DATA, *PLOCAL_THREAD_DATA;


///////////////////////////////////////////////////////////////////////////////////////
//
//	Globals & Constants
//
///////////////////////////////////////////////////////////////////////////////////////

HANDLE				g_hEvent;

EXT_OBJECT*			g_pExtObjects = NULL;
LOCAL_THREAD_DATA	g_LTData;
BOOL				g_fRand = FALSE;
FILE*				g_pOutput = NULL;

LPWSTR*				g_pNameTable;
DWORD				g_dwLastIndex;

HANDLE				g_hTestHeap = NULL;

LONG    lEventLogLevel = LOG_DEBUG;
LONG    lExtCounterTestLevel = EXT_TEST_ALL;

#define PERFVAL_NOCONFIG    0
#define PERFVAL_PASS        1
#define PERFVAL_FAIL        2
#define PERFVAL_TIMEOUT     3

static const WCHAR  cszDefaultLangId[] = {L"009"};
static const WCHAR  cszNamesKey[] = {L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"};
static const WCHAR  cszLastHelp[] = {L"Last Help"};
static const WCHAR  cszLastCounter[] = {L"Last Counter"};
static const WCHAR  cszVersionName[] = {L"Version"};
static const WCHAR  cszCounterName[] = {L"Counter "};
static const WCHAR  cszHelpName[] = {L"Explain "};
static const WCHAR  cszCounters[] = {L"Counters"};
static const WCHAR  cszNotFound[] = {L"*** NOT FOUND ***"};

LPWSTR  szTestErrorMessage = NULL;

#define MAX_BUF_SIZE ((DWORD)(1024 * 1024 * 8))

#define PERFLIB_TIMER_INTERVAL  200     // 200 ms Timer



///////////////////////////////////////////////////////////////////////////////////////
//
//	Code
//
///////////////////////////////////////////////////////////////////////////////////////

DWORD 
InitializeExtObj(EXT_OBJECT* pExtObj)
{
	DWORD	dwStatus = ERROR_SUCCESS;

    BOOL    bUseQueryFn = FALSE;

    DWORD   dwType;
    DWORD   dwSize;
    DWORD   dwMemBlockSize = 0; //sizeof(EXT_OBJECT);
    DWORD   dwOpenTimeout;
    DWORD   dwCollectTimeout;
    DWORD   dwObjectArray[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];
    DWORD   dwObjIndex = 0;
    DWORD   dwLinkageStringLen = 0;
    DWORD   dwFlags = 0;
    DWORD   dwKeep;

    CHAR    szOpenProcName[MAX_PATH];
    CHAR    szCollectProcName[MAX_PATH];
    CHAR    szCloseProcName[MAX_PATH];
    WCHAR   szLibraryString[MAX_PATH];
    WCHAR   szLibraryExpPath[MAX_PATH];
    WCHAR   mszObjectList[MAX_PATH];
    WCHAR   szLinkageKeyPath[MAX_PATH];
    WCHAR   szLinkageString[MAX_PATH];
    WCHAR   szServicePath[MAX_PATH];
	WCHAR	szMutexName[MAX_PATH];
	WCHAR	szPID[32];

	LPBYTE	szStringBlock;
	LPSTR   pNextStringA;
	LPWSTR  pNextStringW;

    LPWSTR  szThisChar;
    LPWSTR  szThisObject;

    HKEY    hServicesKey = NULL;
    HKEY    hPerfKey = NULL;
    LPWSTR  szServiceName;

    HKEY    hKeyLinkage;

    HeapValidate (g_hTestHeap, 0, NULL);
	
	if (pExtObj == NULL)
	{
		dwStatus = ERROR_INVALID_DATA;
	}
	else
	{
		// Open the performance subkey

        lstrcpyW (szServicePath, cszHklmServicesKey);

        dwStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE, szServicePath, 
            0, KEY_READ, &hServicesKey);

        lstrcpyW (szServicePath, pExtObj->szServiceName);
        lstrcatW (szServicePath, cszPerformance);
        dwStatus = RegOpenKeyExW (hServicesKey, szServicePath, 
            0, KEY_READ, &hPerfKey);

        szServiceName = (LPWSTR)pExtObj->szServiceName;

		if ( ERROR_SUCCESS != dwStatus )
		{
			dwStatus = ERROR_INVALID_DATA;
		}

		// Read the performance DLL name
		if (dwStatus == ERROR_SUCCESS) 
		{
			dwType = 0;
			dwSize = sizeof(szLibraryString);
			memset (szLibraryString, 0, sizeof(szLibraryString));
			memset (szLibraryExpPath, 0, sizeof(szLibraryExpPath));

			dwStatus = RegQueryValueExW (hPerfKey,
									cszDLLValue,
									NULL,
									&dwType,
									(LPBYTE)szLibraryString,
									&dwSize);
		
			if (dwStatus == ERROR_SUCCESS) 
			{
				if (dwType == REG_EXPAND_SZ) 
				{
					// expand any environment vars
					dwSize = ExpandEnvironmentStringsW(
						szLibraryString,
						szLibraryExpPath,
						MAX_PATH);

					if ((dwSize > MAX_PATH) || (dwSize == 0)) 
					{
						dwStatus = ERROR_INVALID_DLL;
					} 
					else 
					{
						dwSize += 1;
						dwSize *= sizeof(WCHAR);
						dwMemBlockSize += DWORD_MULTIPLE(dwSize);
					}
				} 
				else if (dwType == REG_SZ) 
				{
					// look for dll and save full file Path
					dwSize = SearchPathW (
						NULL,   // use standard system search path
						szLibraryString,
						NULL,
						MAX_PATH,
						szLibraryExpPath,
						NULL);

					if ((dwSize > MAX_PATH) || (dwSize == 0)) 
					{
						dwStatus = ERROR_INVALID_DLL;
					} 
					else 
					{
						dwSize += 1;
						dwSize *= sizeof(WCHAR);
						dwMemBlockSize += DWORD_MULTIPLE(dwSize);
					}
				} 
				else 
				{
					dwStatus = ERROR_INVALID_DLL;
				}
			}
		}        
		
		// Open Function
		if (dwStatus == ERROR_SUCCESS) 
		{       
            dwType = 0;
            dwSize = sizeof(szOpenProcName);
            memset (szOpenProcName, 0, sizeof(szOpenProcName));
            dwStatus = RegQueryValueExA (hPerfKey,
                                    caszOpenValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)szOpenProcName,
                                    &dwSize);
        }

		// Open Timeout
        if (dwStatus == ERROR_SUCCESS) 
		{
            // add in size of previous string
            // the size value includes the Term. NULL
            dwMemBlockSize += DWORD_MULTIPLE(dwSize);

            // we have the procedure name so get the timeout value
            dwType = 0;
            dwSize = sizeof(dwOpenTimeout);
            dwStatus = RegQueryValueExW (hPerfKey,
                                    cszOpenTimeout,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwOpenTimeout,
                                    &dwSize);

            // if error, then apply default
            if ((dwStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) 
			{
                dwOpenTimeout = 10000;
                dwStatus = ERROR_SUCCESS;
            }
		}

		// Close Function
        if (dwStatus == ERROR_SUCCESS) 
		{
            dwType = 0;
            dwSize = sizeof(szCloseProcName);
            memset (szCloseProcName, 0, sizeof(szCloseProcName));
            dwStatus = RegQueryValueExA (hPerfKey,
                                    caszCloseValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)szCloseProcName,
                                    &dwSize);
        }

		// Collect Function
        if (dwStatus == ERROR_SUCCESS) 
		{
            // add in size of previous string
            // the size value includes the Term. NULL
            dwMemBlockSize += DWORD_MULTIPLE(dwSize);

            // try to look up the query function which is the
            // preferred interface if it's not found, then
            // try the collect function name. If that's not found,
            // then bail
            dwType = 0;
            dwSize = sizeof(szCollectProcName);
            memset (szCollectProcName, 0, sizeof(szCollectProcName));
            dwStatus = RegQueryValueExA (hPerfKey,
                                    caszQueryValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)szCollectProcName,
                                    &dwSize);

            if (dwStatus == ERROR_SUCCESS) 
			{
                // add in size of the Query Function Name
                // the size value includes the Term. NULL
                dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                // get next string

                bUseQueryFn = TRUE;
                // the query function can support a static object list
                // so look it up

            } 
			else 
			{
                // the QueryFunction wasn't found so look up the
                // Collect Function name instead
                dwType = 0;
                dwSize = sizeof(szCollectProcName);
                memset (szCollectProcName, 0, sizeof(szCollectProcName));
                dwStatus = RegQueryValueExA (hPerfKey,
                                        caszCollectValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szCollectProcName,
                                        &dwSize);

                if (dwStatus == ERROR_SUCCESS) 
				{
                    // add in size of Collect Function Name
                    // the size value includes the Term. NULL
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }
            }
		}
		
		// Collect Timeout
        if (dwStatus == ERROR_SUCCESS) 
		{
            // we have the procedure name so get the timeout value
            dwType = 0;
            dwSize = sizeof(dwCollectTimeout);
            dwStatus = RegQueryValueExW (hPerfKey,
                                    cszCollectTimeout,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwCollectTimeout,
                                    &dwSize);

            // if error, then apply default
            if ((dwStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) 
			{
                dwCollectTimeout = 10000;
                dwStatus = ERROR_SUCCESS;
            }
        }

		// Object List
        if (dwStatus == ERROR_SUCCESS) 
		{
			dwType = 0;
			dwSize = sizeof(mszObjectList);
			memset (mszObjectList, 0, sizeof(mszObjectList));
			dwStatus = RegQueryValueExW (hPerfKey,
									cszObjListValue,
									NULL,
									&dwType,
									(LPBYTE)mszObjectList,
									&dwSize);
		
            if (dwStatus == ERROR_SUCCESS) 
			{
                if (dwType != REG_MULTI_SZ) 
				{
                    // convert space delimited list to msz
                    for (szThisChar = mszObjectList; *szThisChar != 0; szThisChar++) 
					{
                        if (*szThisChar == L' ') *szThisChar = L'\0';
                    }
                    ++szThisChar;
                    *szThisChar = 0; // add MSZ term Null
                }

                for (szThisObject = mszObjectList, dwObjIndex = 0;
                    (*szThisObject != 0) && (dwObjIndex < MAX_PERF_OBJECTS_IN_QUERY_FUNCTION);
                    szThisObject += lstrlenW(szThisObject) + 1) 
					{
						dwObjectArray[dwObjIndex] = wcstoul(szThisObject, NULL, 10);
						dwObjIndex++;
					}
                if (*szThisObject != 0) 
				{
                    // BUGBUG: log error idicating too many object ID's are
                    // in the list.
                }
            } 
			else 
			{
                // reset status since not having this is
                //  not a showstopper
                dwStatus = ERROR_SUCCESS;
            }
		}

		// Keep Resident
        if (dwStatus == ERROR_SUCCESS) 
		{
            dwType = 0;
            dwKeep = 0;
            dwSize = sizeof(dwKeep);
            dwStatus = RegQueryValueExW (hPerfKey,
                                    cszKeepResident,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwKeep,
                                    &dwSize);

            if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) 
			{
                if (dwKeep == 1) 
				{
                    dwFlags |= PERF_EO_KEEP_RESIDENT;
                } 
				else 
				{
                    // no change.
                }
            } 
			else 
			{
                // not fatal, just use the defaults.
                dwStatus = ERROR_SUCCESS;
            }
        }

		// Linkage
        if (dwStatus == ERROR_SUCCESS) 
		{
            memset (szLinkageString, 0, sizeof(szLinkageString));

            lstrcpyW (szLinkageKeyPath, szServiceName);
            lstrcatW (szLinkageKeyPath, cszLinkageKey);

            dwStatus = RegOpenKeyExW (
                hServicesKey,
                szLinkageKeyPath,
                0L,
                KEY_READ,
                &hKeyLinkage);

            if (dwStatus == ERROR_SUCCESS) 
			{
                // look up export value string
                dwSize = sizeof(szLinkageString);
                dwType = 0;
                dwStatus = RegQueryValueExW (
                    hKeyLinkage,
                    cszExportValue,
                    NULL,
                    &dwType,
                    (LPBYTE)&szLinkageString,
                    &dwSize);

                if ((dwStatus != ERROR_SUCCESS) ||
                    ((dwType != REG_SZ) && (dwType != REG_MULTI_SZ))) 
				{
                    // clear buffer
                    memset (szLinkageString, 0, sizeof(szLinkageString));
                    dwLinkageStringLen = 0;

                    // not finding a linkage key is not fatal so correct
                    // status
                    dwStatus = ERROR_SUCCESS;
                } 
				else 
				{
                    // add size of linkage string to buffer
                    // the size value includes the Term. NULL
                    dwLinkageStringLen = dwSize;
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }

                RegCloseKey (hKeyLinkage);
            } 
			else 
			{
                // not finding a linkage key is not fatal so correct
                // status
                dwStatus = ERROR_SUCCESS;
            }
        }

	    if (hServicesKey != NULL) 
			RegCloseKey (hServicesKey);

		if (hPerfKey != NULL) 
			RegCloseKey (hPerfKey);


// Copy data to Performance Library Data Structure

        if (dwStatus == ERROR_SUCCESS) 
		{
            // allocate and initialize a new ext. object block
            szStringBlock = (LPBYTE)HeapAlloc(g_hTestHeap, HEAP_ZERO_MEMORY, dwMemBlockSize);

            if (szStringBlock != NULL) 
			{
                // copy values to new buffer (all others are NULL)
                pNextStringA = (LPSTR)szStringBlock;

                // copy Open Procedure Name
                pExtObj->szOpenProcName = pNextStringA;
                lstrcpyA (pNextStringA, szOpenProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                pExtObj->dwOpenTimeout = dwOpenTimeout;

                // copy collect function or query function, depending
                pExtObj->szCollectProcName = pNextStringA;
                lstrcpyA (pNextStringA, szCollectProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                pExtObj->dwCollectTimeout = dwCollectTimeout;

				// copy Close Procedure Name
                pExtObj->szCloseProcName = pNextStringA;
                lstrcpyA (pNextStringA, szCloseProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                // copy Library path
                pNextStringW = (LPWSTR)pNextStringA;
                pExtObj->szLibraryName = pNextStringW;
                lstrcpyW (pNextStringW, szLibraryExpPath);

                pNextStringW += lstrlenW (pNextStringW) + 1;
                pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);

                // copy Linkage String if there is one
                if (*szLinkageString != 0) {
                    pExtObj->szLinkageString = pNextStringW;
                    memcpy (pNextStringW, szLinkageString, dwLinkageStringLen);

                    // length includes extra NULL char and is in BYTES
                    pNextStringW += (dwLinkageStringLen / sizeof (WCHAR));
                    pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);
                }

                // load flags
                if (bUseQueryFn) {
                    dwFlags |= PERF_EO_QUERY_FUNC;
                }
                pExtObj->dwFlags =  dwFlags;

                // load Object array
                if (dwObjIndex > 0) {
                    pExtObj->dwNumObjects = dwObjIndex;
                    memcpy (pExtObj->dwObjList,
                        dwObjectArray, (dwObjIndex * sizeof(dwObjectArray[0])));
                }

                pExtObj->llLastUsedTime = 0;

				// create Mutex name
				lstrcpyW (szMutexName, pExtObj->szServiceName);
				lstrcatW (szMutexName, (LPCWSTR)L"_Perf_Library_Lock_PID_");
				_ultow ((ULONG)GetCurrentProcessId(), szPID, 16);
				lstrcatW (szMutexName, szPID);

                pExtObj->hMutex = CreateMutexW (NULL, FALSE, szMutexName);

				pExtObj->bValid = TRUE;
            } else {
                dwStatus = ERROR_OUTOFMEMORY;
            }
        }
	}

    HeapValidate (g_hTestHeap, 0, NULL);

	if (ERROR_SUCCESS != dwStatus)
	{
		pExtObj->bValid = FALSE;
	}

	return dwStatus;
}

DWORD
FinializeExtObj(PEXT_OBJECT pInfo)
{
	DWORD dwStatus = ERROR_SUCCESS;

    // then close everything
    if (pInfo->hMutex != NULL) {
        CloseHandle (pInfo->hMutex);
        pInfo->hMutex = NULL;
    }

	if ( NULL != pInfo->szOpenProcName )
		HeapFree(g_hTestHeap, 0, pInfo->szOpenProcName);

	if ( NULL != pInfo->szServiceName )
		HeapFree(g_hTestHeap, 0, pInfo->szServiceName);

	if ( NULL != pInfo->szQueryString )
		HeapFree(g_hTestHeap, 0, pInfo->szQueryString);

	return dwStatus;
}

DWORD
OpenLibrary (
    EXT_OBJECT  *pExtObj)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwOpenEvent;

    UINT    nErrorMode;

    // check to see if the library has already been opened

    LARGE_INTEGER   liStartTime, liEndTime, liFreq;

    if (pExtObj != NULL) 
	{
        // then load library & look up functions
        nErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);
        pExtObj->hLibrary = LoadLibraryExW (pExtObj->szLibraryName,
            NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

        if (pExtObj->hLibrary != NULL) {
            // lookup function names
            pExtObj->OpenProc = (OPENPROC)GetProcAddress(
                pExtObj->hLibrary, pExtObj->szOpenProcName);
            if (pExtObj->OpenProc == NULL) {
                wprintf ((LPCWSTR)L"\nOpen Procedure \"%s\" not found in \"%s\"",
                    pExtObj->szOpenProcName, pExtObj->szLibraryName);
            }
        } else {
            // unable to load library
			fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tLoadLibraryEx Failed for the \"%s\" Performance Library", GetCurrentThreadId(), pExtObj->szServiceName);
            dwStatus = GetLastError();
        }

        if (dwStatus == ERROR_SUCCESS) {
            if (pExtObj->dwFlags & PERF_EO_QUERY_FUNC) {
                pExtObj->QueryProc = (QUERYPROC)GetProcAddress (
                    pExtObj->hLibrary, pExtObj->szCollectProcName);
                pExtObj->CollectProc = (COLLECTPROC)pExtObj->QueryProc;
            } else {
                pExtObj->CollectProc = (COLLECTPROC)GetProcAddress (
                    pExtObj->hLibrary, pExtObj->szCollectProcName);
                pExtObj->QueryProc = (QUERYPROC)pExtObj->CollectProc;
            }

            if (pExtObj->CollectProc == NULL) {
                wprintf ((LPCWSTR)L"\nCollect Procedure \"%s\" not found in \"%s\"",
                    pExtObj->szCollectProcName, pExtObj->szLibraryName);
            }
        }

        if (dwStatus == ERROR_SUCCESS) {
            pExtObj->CloseProc = (CLOSEPROC)GetProcAddress (
                pExtObj->hLibrary, pExtObj->szCloseProcName);

            if (pExtObj->CloseProc == NULL) {
                wprintf ((LPCWSTR)L"\nClose Procedure \"%s\" not found in \"%s\"",
                    pExtObj->szCloseProcName, pExtObj->szLibraryName);
            }
        }

        if (dwStatus == ERROR_SUCCESS) {
            __try {

				if ((pExtObj->hMutex != NULL)   &&
					(pExtObj->OpenProc != NULL)){
					dwStatus =  WaitForSingleObject (
						pExtObj->hMutex,
						pExtObj->dwOpenTimeout);
					if (dwStatus != WAIT_TIMEOUT) {

						QueryPerformanceCounter (&liStartTime);

//						dwStatus = (*pExtObj->OpenProc)(pExtObj->szLinkageString);

						QueryPerformanceCounter (&liEndTime);

						// release the lock
						ReleaseMutex(pExtObj->hMutex);

						if ( dwStatus != ERROR_SUCCESS )
						{
							fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \t%S failed for the \"%s\" Performance Library: 0x%X", GetCurrentThreadId(), pExtObj->szOpenProcName, pExtObj->szServiceName, dwStatus);
						}

					} else {
						pExtObj->dwLockoutCount++;
					}
				} else {
					dwStatus = ERROR_LOCK_FAILED;
				}

                // check the result.
                if (dwStatus != ERROR_SUCCESS) {
                    dwOpenEvent = WBEMPERF_OPEN_PROC_FAILURE;
                } else {
                    InterlockedIncrement((LONG *)&pExtObj->dwOpenCount);
                    pExtObj->llFunctionTime = liEndTime.QuadPart - liStartTime.QuadPart;
                    pExtObj->llOpenTime += pExtObj->llFunctionTime;
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                dwStatus = GetExceptionCode();
                dwOpenEvent = WBEMPERF_OPEN_PROC_EXCEPTION;
            }

        }

        QueryPerformanceFrequency (&liFreq);
        pExtObj->llTimeBase = liFreq.QuadPart;

        if (dwStatus != ERROR_SUCCESS) {
            // clear fields
            pExtObj->OpenProc = NULL;
            pExtObj->CollectProc = NULL;
            pExtObj->QueryProc = NULL;
            pExtObj->CloseProc = NULL;
            if (pExtObj->hLibrary != NULL) {
                FreeLibrary (pExtObj->hLibrary);
                pExtObj->hLibrary = NULL;
            }
        } else {
            GetSystemTimeAsFileTime ((FILETIME *)&pExtObj->llLastUsedTime);
        }
    } // else no buffer returned

    return dwStatus;
}

DWORD 
ClearSafeBuffer( PSAFE_BUFFER pSafeBufferBlock )
{
	DWORD dwStatus = ERROR_SUCCESS;

	if (pSafeBufferBlock != NULL)
	{
		if (pSafeBufferBlock->lpBuffer != NULL) 
			HeapFree (g_hTestHeap, 0, pSafeBufferBlock->lpBuffer);

		pSafeBufferBlock->lpLowGuardPage = NULL;
		pSafeBufferBlock->lpHiGuardPage = NULL;
		pSafeBufferBlock->lpEndPointer = NULL;
		pSafeBufferBlock->lpBuffer = NULL;
		pSafeBufferBlock->lpSafeBuffer = NULL;
		pSafeBufferBlock->lpCallBuffer = NULL;
	}
	else
	{
		dwStatus = ERROR_INVALID_DATA;
	}

	return dwStatus;
}

DWORD
CreateSafeBuffer( PSAFE_BUFFER pSafeBufferBlock )
{
	DWORD dwStatus = ERROR_SUCCESS;

	if (NULL == pSafeBufferBlock)
	{
		dwStatus = ERROR_INVALID_DATA;
	}

	if (dwStatus == ERROR_SUCCESS)
	{
		if (pSafeBufferBlock->lpBuffer != NULL) 
			HeapFree (g_hTestHeap, 0, pSafeBufferBlock->lpBuffer);

		pSafeBufferBlock->dwBufSize += pSafeBufferBlock->dwBufSizeIncrement;
		pSafeBufferBlock->dwCallBufSize = pSafeBufferBlock->dwBufSize;

		pSafeBufferBlock->lpBuffer = HeapAlloc (g_hTestHeap, 
											   HEAP_ZERO_MEMORY, 
											   pSafeBufferBlock->dwBufSize + (2*GUARD_PAGE_SIZE));

		if (NULL != pSafeBufferBlock->lpBuffer)
		{
			// set buffer pointers
			pSafeBufferBlock->lpLowGuardPage = pSafeBufferBlock->lpBuffer;
			pSafeBufferBlock->lpSafeBuffer = (LPBYTE)pSafeBufferBlock->lpBuffer + GUARD_PAGE_SIZE;
			pSafeBufferBlock->lpCallBuffer = pSafeBufferBlock->lpSafeBuffer;
			pSafeBufferBlock->lpHiGuardPage = (LPBYTE)pSafeBufferBlock->lpCallBuffer + pSafeBufferBlock->dwBufSize;
			pSafeBufferBlock->lpEndPointer = (LPBYTE)pSafeBufferBlock->lpHiGuardPage + GUARD_PAGE_SIZE;

			memset (pSafeBufferBlock->lpLowGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
			memset (pSafeBufferBlock->lpHiGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
		}
		else
		{
			dwStatus = ERROR_OUTOFMEMORY;
		}
	}

	if (dwStatus != ERROR_SUCCESS)
	{
		dwStatus = ClearSafeBuffer( pSafeBufferBlock );
	}

	return dwStatus;
}

DWORD
CheckGuardBytes( PSAFE_BUFFER pSafeBufferBlock, PEXT_OBJECT pObj )
{
	DWORD	dwStatus = ERROR_SUCCESS;

	LPDWORD lpCheckPointer;

	//
	// check for buffer corruption here
	//
	if (lExtCounterTestLevel <= EXT_TEST_BASIC) 
	{
		//
		//  check 1: bytes left should be the same as
		//      new data buffer ptr - orig data buffer ptr
		//
		if (pSafeBufferBlock->dwCallBufSize != (DWORD)((LPBYTE)pSafeBufferBlock->lpCallBuffer - (LPBYTE)pSafeBufferBlock->lpSafeBuffer)) 
		{
			pObj->dwBadPointers++;

			dwStatus = ERROR_INVALID_DATA;
		}
		//
		//  check 2: buffer after ptr should be < hi Guard page ptr
		//
		if ((dwStatus == ERROR_SUCCESS) && 
			((LPBYTE)pSafeBufferBlock->lpCallBuffer >= (LPBYTE)pSafeBufferBlock->lpHiGuardPage))
		{
			// see if they exceeded the allocated memory
			if ((LPBYTE)pSafeBufferBlock->lpCallBuffer >= (LPBYTE)pSafeBufferBlock->lpEndPointer) 
			{
				// even worse!!
			}
			pObj->dwBufferSizeErrors++;
			dwStatus = ERROR_INVALID_DATA;
		}
		//
		//  check 3: check lo guard page for corruption
		//
		if (dwStatus == ERROR_SUCCESS ) 
		{
			for (lpCheckPointer = (LPDWORD)pSafeBufferBlock->lpLowGuardPage;
				 lpCheckPointer < (LPDWORD)pSafeBufferBlock->lpSafeBuffer;
				 lpCheckPointer++) 
			{
				if (*lpCheckPointer != GUARD_PAGE_DWORD) 
				{
					pObj->dwLowerGPViolations++;
					dwStatus = ERROR_INVALID_DATA;
					break;
				}
			}
		}
		//
		//  check 4: check hi guard page for corruption
		//
		if (dwStatus == ERROR_SUCCESS) 
		{
			for (lpCheckPointer = (LPDWORD)pSafeBufferBlock->lpHiGuardPage;
				 lpCheckPointer < (LPDWORD)pSafeBufferBlock->lpEndPointer;
				 lpCheckPointer++) 
			{
				if (*lpCheckPointer != GUARD_PAGE_DWORD) 
				{
					pObj->dwUpperGPViolations++;
					dwStatus = ERROR_INVALID_DATA;
					break;
				}
			}
		}
	}

	if (dwStatus != ERROR_SUCCESS)
	{
		fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tGuardbyte violation for the \"%s\" Performance Library: 0x%X", GetCurrentThreadId(), pObj->szServiceName, dwStatus);
	}

	return dwStatus;
}

DWORD
ValidateBuffer( PSAFE_BUFFER pSafeBufferBlock, EXT_OBJECT *pThisExtObj )
{
	DWORD dwStatus = ERROR_SUCCESS;

    DWORD	dwObjectBufSize;
    DWORD	dwIndex;

    LONG                lInstIndex;

    PERF_OBJECT_TYPE			*pObject, *pNextObject;
    PERF_INSTANCE_DEFINITION    *pInstance;
    PERF_DATA_BLOCK				*pPerfData;
    BOOL						bForeignDataBuffer;

	if (NULL == pSafeBufferBlock)
	{
		dwStatus = ERROR_INVALID_DATA;
	}

	// Validate the blob size
	if ( dwStatus == ERROR_SUCCESS )
	{
		if (( pSafeBufferBlock->dwCallBufSize < 0 ) ||
			( pSafeBufferBlock->dwCallBufSize > pSafeBufferBlock->dwBufSize ))
		{
			fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tBuffer size parameter does not match the buffer displacement in the data returned for the \"%s\" performance library", GetCurrentThreadId(), pThisExtObj->szServiceName);
			pThisExtObj->dwBufferSizeErrors++;
			dwStatus = ERROR_INVALID_PARAMETER;
		}
	}

	// Validate the byte alignment
	if (dwStatus == ERROR_SUCCESS)
	{
		if (pSafeBufferBlock->dwCallBufSize & 0x00000007) 
		{
			fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tByte Allignment Error in the data returned for the \"%s\" performance library", GetCurrentThreadId(), pThisExtObj->szServiceName);
			pThisExtObj->dwAlignmentErrors++;
			dwStatus = ERROR_INVALID_DATA;
		}
	}

	if ( dwStatus == ERROR_SUCCESS )
	{
		dwStatus = CheckGuardBytes( pSafeBufferBlock, pThisExtObj );
	}

	if ((lExtCounterTestLevel <= EXT_TEST_ALL) && (dwStatus == ERROR_SUCCESS)) 
	{
		//
		//  Internal consistency checks
		//
		//
		//  Check 5: Check object length field values
		//
		// first test to see if this is a foreign
		// computer data block or not
		//
		pPerfData = (PERF_DATA_BLOCK *)pSafeBufferBlock->lpSafeBuffer;
		if ((pPerfData->Signature[0] == (WCHAR)'P') &&
			(pPerfData->Signature[1] == (WCHAR)'E') &&
			(pPerfData->Signature[2] == (WCHAR)'R') &&
			(pPerfData->Signature[3] == (WCHAR)'F')) 
		{
			// if this is a foreign computer data block, then the
			// first object is after the header
			pObject = (PERF_OBJECT_TYPE *) ((LPBYTE)pPerfData + pPerfData->HeaderLength);
			bForeignDataBuffer = TRUE;
		}
		else 
		{
			// otherwise, if this is just a buffer from
			// an extensible counter, the object starts
			// at the beginning of the buffer
			pObject = (PERF_OBJECT_TYPE *)pSafeBufferBlock->lpSafeBuffer;
			bForeignDataBuffer = FALSE;
		}
		// go to where the pointers say the end of the
		// buffer is and then see if it's where it
		// should be
		dwObjectBufSize = 0;
		for (dwIndex = 0; dwIndex < pThisExtObj->dwNumObjectsRet; dwIndex++) 
		{
			dwObjectBufSize += pObject->TotalByteLength;
			pObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
				pObject->TotalByteLength);
		}
		if (((LPBYTE)pObject != (LPBYTE)pSafeBufferBlock->lpCallBuffer) || 
			(dwObjectBufSize > pSafeBufferBlock->dwCallBufSize)) 
		{
			// then a length field is incorrect. This is FATAL
			// since it can corrupt the rest of the buffer
			// and render the buffer unusable.
			fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tObject in blob overruns the buffer boundary in the data returned for the \"%s\" Performance Library", GetCurrentThreadId(), pThisExtObj->szServiceName);
			pThisExtObj->dwObjectSizeErrors++;
			dwStatus = ERROR_INVALID_DATA;
		}

		//
		//  Test 6: Test instance field size values
		//
		if (dwStatus == ERROR_SUCCESS) 
		{
			// set object pointer
			if (bForeignDataBuffer) 
			{
				pObject = (PERF_OBJECT_TYPE *) (
					(LPBYTE)pPerfData + pPerfData->HeaderLength);
			} 
			else 
			{
				// otherwise, if this is just a buffer from
				// an extensible counter, the object starts
				// at the beginning of the buffer
				pObject = (PERF_OBJECT_TYPE *)pSafeBufferBlock->lpSafeBuffer;
			}

			for (dwIndex = 0; dwIndex < pThisExtObj->dwNumObjectsRet; dwIndex++) 
			{
				pNextObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
					pObject->TotalByteLength);

				if (pObject->NumInstances != PERF_NO_INSTANCES) 
				{
					pInstance = (PERF_INSTANCE_DEFINITION *)
						((LPBYTE)pObject + pObject->DefinitionLength);
					lInstIndex = 0;
					while (lInstIndex < pObject->NumInstances) 
					{
						PERF_COUNTER_BLOCK *pCounterBlock;

						// NOTE: this does not walk the instance/counter block, nor does it check the validity of the addresses

						pCounterBlock = (PERF_COUNTER_BLOCK *)
							((PCHAR) pInstance + pInstance->ByteLength);

						pInstance = (PERF_INSTANCE_DEFINITION *)
							((PCHAR) pCounterBlock + pCounterBlock->ByteLength);

						lInstIndex++;
					}
					if ((LPBYTE)pInstance > (LPBYTE)pNextObject) 
					{
						fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tInsatnce data overruns the following object data in the data returned for the \"%s\" Performance Library", GetCurrentThreadId(), pThisExtObj->szServiceName);
						dwStatus = ERROR_INVALID_DATA;
					}
				}

				if (dwStatus != ERROR_SUCCESS) 
				{
					break;
				}
				else 
				{
					pObject = pNextObject;
				}
			}

			if (dwStatus != ERROR_SUCCESS) 
			{
				pThisExtObj->dwInstanceSizeErrors++;
			}
		}
	}

	return dwStatus;
}

DWORD
ValidateBlob( PSAFE_BUFFER pSafeBufferBlock, EXT_OBJECT *pThisExtObj )
{
	DWORD	dwStatus = ERROR_SUCCESS;
    DWORD   nObjIdx, nCtrIdx;
	DWORD   dwLastId = g_dwLastIndex;

    PERF_OBJECT_TYPE *  pObjDef = NULL;
    PERF_COUNTER_DEFINITION *   pCtrDef;

	// Validate the data
	// =================

	if (pSafeBufferBlock->dwBufSize >= MAX_BUF_SIZE) {
		fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tCollectFunction for %s requires a buffer > %d bytes", GetCurrentThreadId(), pThisExtObj->szServiceName, MAX_BUF_SIZE);
		if (pSafeBufferBlock->lpBuffer != NULL) HeapFree (g_hTestHeap, 0, pSafeBufferBlock->lpBuffer);
		dwStatus = ERROR_INVALID_PARAMETER;
	} else if (pSafeBufferBlock->lpBuffer == NULL) {
		dwStatus = ERROR_OUTOFMEMORY;
	} else {
		// Validate the objects
		// ====================

		pObjDef = (PERF_OBJECT_TYPE *)pSafeBufferBlock->lpSafeBuffer;
		for (nObjIdx = 0; nObjIdx < pThisExtObj->dwNumObjectsRet; nObjIdx++) {
			// test object name & help
			if ((pObjDef->ObjectNameTitleIndex <= dwLastId) && 
				(pObjDef->ObjectNameTitleIndex > 0)) {
				if (g_pNameTable[pObjDef->ObjectNameTitleIndex ] == NULL) {
					// no string
					fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:\tNo Object Name Display String for index %d", GetCurrentThreadId(), pObjDef->ObjectNameTitleIndex );
					dwStatus = ERROR_BADKEY;
				} else {
					// probably ok
				}
			} else {
				// id out of range
				fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:\tObject Name Index values are bad or missing", GetCurrentThreadId());
				dwStatus = ERROR_BADKEY;
			}
	
			if ((pObjDef->ObjectHelpTitleIndex <= dwLastId) && 
				(pObjDef->ObjectHelpTitleIndex> 0)) {
				if (g_pNameTable[pObjDef->ObjectHelpTitleIndex] == NULL) {
					// no string
					fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:\tNo Object Help Display String for index %d", GetCurrentThreadId(), pObjDef->ObjectHelpTitleIndex );
					dwStatus = ERROR_BADKEY;
				} else {
					// probably ok
				}
			} else {
				// id out of range
				fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:\tObject Help Index values are bad or missing", GetCurrentThreadId());
				dwStatus = ERROR_BADKEY;
			}

			// Validate the counters 
			// =====================

			pCtrDef = FirstCounter (pObjDef);
			for (nCtrIdx = 0; nCtrIdx < pObjDef->NumCounters; nCtrIdx++) {
				if ((pCtrDef->CounterNameTitleIndex <= dwLastId) && 
					(pCtrDef->CounterNameTitleIndex > 0)) {
					if ((g_pNameTable[pCtrDef->CounterNameTitleIndex ] == NULL) &&
						((pCtrDef->CounterType & PERF_COUNTER_BASE) == 0)) {
						// no string
						fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:\tNo Counter Name Display String for index %d", GetCurrentThreadId(), pCtrDef->CounterNameTitleIndex );
						dwStatus = ERROR_BADKEY;
					} else {
						// probably ok
					}
				} else {
					// id out of range
					fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:\tCounter Name Index values are bad or missing", GetCurrentThreadId());
					dwStatus = ERROR_BADKEY;
				}
				// test counter defs
				if ((pCtrDef->CounterHelpTitleIndex <= dwLastId) && 
					(pCtrDef->CounterHelpTitleIndex> 0)) {
					if ((g_pNameTable[pCtrDef->CounterHelpTitleIndex] == NULL) &&
						((pCtrDef->CounterType & PERF_COUNTER_BASE) == 0)) {
						// no string
						fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:\tNo Counter Help Display String for index %d", GetCurrentThreadId(), pCtrDef->CounterHelpTitleIndex );
						dwStatus = ERROR_BADKEY;
					} else {
						// probably ok
					}
				} else {
					// id out of range
					fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:\tCounter Help Index values are bad or missing", GetCurrentThreadId());
					dwStatus = ERROR_BADKEY;
				}
				if (nCtrIdx < ( pObjDef->NumCounters - 1 ) )
					pCtrDef = NextCounter (pCtrDef);
			}

			if ( nObjIdx < ( pThisExtObj->dwNumObjectsRet - 1 ) )
				pObjDef = NextObject (pObjDef);
		}                        
	}

	return dwStatus;
}

DWORD 
Validate( PSAFE_BUFFER pSafeBufferBlock, EXT_OBJECT *pThisExtObj )
{
	DWORD dwStatus = ERROR_SUCCESS;

	dwStatus = ValidateBuffer( pSafeBufferBlock, pThisExtObj );

	if (dwStatus == ERROR_SUCCESS)
	{
		dwStatus = ValidateBlob( pSafeBufferBlock, pThisExtObj );

		if ( dwStatus != ERROR_SUCCESS )
		{
			fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tBlob Data Validation failed for the \"%s\" Performance Library: 0x%X", GetCurrentThreadId(), pThisExtObj->szServiceName, dwStatus);
		}
	}
	else
	{
		fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tBuffer Validation failed for the \"%s\" Performance Library: 0x%X", GetCurrentThreadId(), pThisExtObj->szServiceName, dwStatus);
	}

	return dwStatus;
}

//***************************************************************************
//
//  CollectData (LPBYTE pBuffer, 
//              LPDWORD pdwBufferSize, 
//              LPWSTR pszItemList)
//
//  Collects data from the perf objects and libraries added to the access 
//  object
//
//      Inputs:
//
//          pBuffer              -   pointer to start of data block
//                                  where data is being collected
//
//          pdwBufferSize        -   pointer to size of data buffer
//
//          pszItemList        -    string to pass to ext DLL
//
//      Outputs:
//
//          *lppDataDefinition  -   set to location for next Type
//                                  Definition if successful
//
//      Returns:
//
//          0 if successful, else Win 32 error code of failure
//
//
//***************************************************************************
//
DWORD   
CollectData (EXT_OBJECT *pThisExtObj)
{
    DWORD			dwStatus = ERROR_SUCCESS;	//  Failure code

	SAFE_BUFFER		SafeBufferBlock;			// Buffer block

    DWORD			NumObjectTypes = 0;			// Number of object returned from collection function

    LARGE_INTEGER	liStartTime,				// Collect start time
					liEndTime,					// Collect end time
					liFreq;						// Timer frequency

    DOUBLE			dMs = 0;					// Timer data

	memset(&SafeBufferBlock, 0, sizeof(SAFE_BUFFER));
	SafeBufferBlock.dwBufSize = 4098;
	SafeBufferBlock.dwBufSizeIncrement = 1024;

// Collect the data
// ================

	dwStatus = ERROR_MORE_DATA;

    while ((dwStatus == ERROR_MORE_DATA) && (SafeBufferBlock.dwBufSize < MAX_BUF_SIZE)) 
	{
	    // allocate a local block of memory to pass to the
		// extensible counter function.

		dwStatus = CreateSafeBuffer( &SafeBufferBlock );

		if ( dwStatus == ERROR_SUCCESS ) 
		{
			// initialize values to pass to the extensible counter function
			NumObjectTypes = 0;

			if ((pThisExtObj->hMutex != NULL) && 
				(pThisExtObj->CollectProc != NULL)) 
			{
				dwStatus =  WaitForSingleObject ( pThisExtObj->hMutex, pThisExtObj->dwCollectTimeout);

				if (dwStatus != WAIT_TIMEOUT)
				{
					__try 
					{
						QueryPerformanceCounter (&liStartTime);
						{
							LPBYTE pBuffer = SafeBufferBlock.lpCallBuffer;
							DWORD dwBufSize = SafeBufferBlock.dwCallBufSize;
							dwStatus =  (*pThisExtObj->CollectProc) (
								(LPWSTR)pThisExtObj->szQueryString,
								&pBuffer,
								&dwBufSize,
								&NumObjectTypes);
						
							SafeBufferBlock.dwCallBufSize = dwBufSize;
							SafeBufferBlock.lpCallBuffer = pBuffer;
						}
						QueryPerformanceCounter (&liEndTime);

						if (( dwStatus != ERROR_SUCCESS ) && ( dwStatus != ERROR_MORE_DATA ))
						{
							fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \t%S failed for the \"%s\" Performance Library: 0x%X", GetCurrentThreadId(), pThisExtObj->szCollectProcName, pThisExtObj->szServiceName, dwStatus);
						}

					}
					__except (EXCEPTION_EXECUTE_HANDLER) 
					{
						dwStatus = GetExceptionCode();
						InterlockedIncrement ((LONG *)&pThisExtObj->dwExceptionCount);
					}

					ReleaseMutex (pThisExtObj->hMutex);
				}
				else 
				{
					pThisExtObj->dwLockoutCount++;
				}
			}
			else 
			{
				dwStatus = ERROR_LOCK_FAILED;
			}
		} // if CreateSafeBuffer()
	} // While

// Copy the data
// =============

	if (dwStatus == ERROR_SUCCESS)
	{
		// Validate the collection time
		if (dwStatus == ERROR_SUCCESS)
		{
			liFreq.QuadPart = 0;
			QueryPerformanceFrequency (&liFreq);
			pThisExtObj->llTimeBase = liFreq.QuadPart;

			pThisExtObj->llFunctionTime = liEndTime.QuadPart - liStartTime.QuadPart;
			pThisExtObj->llCollectTime += pThisExtObj->llFunctionTime;

			// check the time spent in this function
			dMs = (DOUBLE)pThisExtObj->llFunctionTime;
			dMs /= (DOUBLE)pThisExtObj->llTimeBase;
			dMs *= 1000.0;

			if (dMs > (DOUBLE)pThisExtObj->dwCollectTimeout) 
			{
				dwStatus = ERROR_TIMEOUT;
			} 
		}
	
		// Copy the data
		if (dwStatus == ERROR_SUCCESS)
		{
			// External object data
			GetSystemTimeAsFileTime((FILETIME*)&pThisExtObj->llLastUsedTime);
			pThisExtObj->dwNumObjectsRet = NumObjectTypes;
			pThisExtObj->dwRetBufSize = SafeBufferBlock.dwCallBufSize;

			// increment perf counters
			InterlockedIncrement ((LONG *)&pThisExtObj->dwCollectCount);
		}

		// Validate the data
		if ((dwStatus == ERROR_SUCCESS) &&
			(g_LTData.bTestContents))
		{
			dwStatus = Validate( &SafeBufferBlock, pThisExtObj );
		}
	}

	ClearSafeBuffer(&SafeBufferBlock);
	
	if ((dwStatus != ERROR_SUCCESS) && 
		(dwStatus != WAIT_TIMEOUT))		// don't count timeouts as function errors
	{
		InterlockedIncrement ((LONG *)&pThisExtObj->dwErrorCount);
	}

	return dwStatus;
}

DWORD
CloseLibrary (
    EXT_OBJECT  *pInfo
)
{
    DWORD   dwStatus = ERROR_SUCCESS;

    if (pInfo != NULL) {
	    // if there's a close proc to call, then 
	    // call close procedure to close anything that may have
	    // been allocated by the library

		if ((pInfo->hMutex != NULL)   &&
			(pInfo->CloseProc != NULL)){
			dwStatus =  WaitForSingleObject (
				pInfo->hMutex,
				pInfo->dwOpenTimeout);
			if (dwStatus != WAIT_TIMEOUT) {

				if (pInfo->CloseProc != NULL) {
					dwStatus = (*pInfo->CloseProc) ();

					if ( dwStatus != ERROR_SUCCESS )
					{
						fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \t%S failed for the \"%s\" Performance Library: 0x%X", GetCurrentThreadId(), pInfo->szCloseProcName, pInfo->szServiceName, dwStatus);
					}
				}

				ReleaseMutex(pInfo->hMutex);
			} else {
				pInfo->dwLockoutCount++;
			}
		} else {
			dwStatus = ERROR_LOCK_FAILED;
		}
 
        if (pInfo->hLibrary != NULL) {
            FreeLibrary (pInfo->hLibrary);
            pInfo->hLibrary = NULL;
        }
    }

    return dwStatus;
}

static
LPWSTR
*BuildNameTable(
    LPCWSTR szMachineName,
    LPCWSTR lpszLangIdArg,     // unicode value of Language subkey
    PDWORD  pdwLastItem,     // size of array in elements
    PDWORD  pdwIdArray      // array for index ID's
)
/*++
   
BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:
     
    pointer to an allocated table. (the caller must MemoryFree it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{
    HKEY    hKeyRegistry;   // handle to registry db with counter names

    LPWSTR  *lpReturnValue;
    LPCWSTR lpszLangId;

    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;

    LPWSTR  lpThisName;

    LONG    lWin32Status;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    DWORD   dwThisCounter;
    
    DWORD   dwLastId;
    DWORD   dwLastHelpId;

    DWORD   dwLastCounterIdUsed;
    DWORD   dwLastHelpIdUsed;
    
    HKEY    hKeyValue;
    HKEY    hKeyNames;

    LPWSTR  lpValueNameString;
    WCHAR   CounterNameBuffer [50];
    WCHAR   HelpNameBuffer [50];

    SetLastError (ERROR_SUCCESS);
    szTestErrorMessage = NULL;

    if (szMachineName != NULL) {
        lWin32Status = RegConnectRegistryW (szMachineName,
            HKEY_LOCAL_MACHINE,
            &hKeyRegistry);
    } else {
        lWin32Status = ERROR_SUCCESS;
        hKeyRegistry = HKEY_LOCAL_MACHINE;
    }

    lpValueNameString = NULL;   //initialize to NULL
    lpReturnValue = NULL;
    hKeyValue = NULL;
    hKeyNames = NULL;
   
    // check for null arguments and insert defaults if necessary

    if (!lpszLangIdArg) {
        lpszLangId = cszDefaultLangId;
    } else {
        lpszLangId = lpszLangIdArg;
    }

    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyExW (
        hKeyRegistry,
        cszNamesKey,
        0L,
        KEY_READ,
        &hKeyValue);
    
    if (lWin32Status != ERROR_SUCCESS) {
        szTestErrorMessage = (LPWSTR)L"Unable to Open Perflib key";
        goto BNT_BAILOUT;
    }

    // get config info
    dwValueType = 0;
    dwBufferSize = sizeof (pdwIdArray[4]);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        (LPCWSTR)L"Disable Performance Counters",
        0L,
        &dwValueType,
        (LPBYTE)&pdwIdArray[4],
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        if (lWin32Status == ERROR_FILE_NOT_FOUND) {
            // this is OK since the value need not be present
            pdwIdArray[4] = (DWORD)-1;
            lWin32Status = ERROR_SUCCESS;
        } else {
            szTestErrorMessage = (LPWSTR)L"Unable to read Disable Performance Counters value";
            goto BNT_BAILOUT;
        }
    }
    
    dwValueType = 0;
    dwBufferSize = sizeof (pdwIdArray[5]);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        (LPCWSTR)L"ExtCounterTestLevel",
        0L,
        &dwValueType,
        (LPBYTE)&pdwIdArray[5],
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        if (lWin32Status == ERROR_FILE_NOT_FOUND) {
            // this is OK since the value need not be present
            pdwIdArray[5] = (DWORD)-1;
            lWin32Status = ERROR_SUCCESS;
        } else {
            szTestErrorMessage  = (LPWSTR)L"Unable to read ExCounterTestLevel value";
            goto BNT_BAILOUT;
        }
    }
    
    dwValueType = 0;
    dwBufferSize = sizeof (pdwIdArray[6]);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        (LPCWSTR)L"Base Index",
        0L,
        &dwValueType,
        (LPBYTE)&pdwIdArray[6],
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        szTestErrorMessage  = (LPWSTR)L"Unable to read Base Index value";
        goto BNT_BAILOUT;
    }
    
    // get number of items
    
    dwBufferSize = sizeof (dwLastHelpId);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        cszLastHelp,
        0L,
        &dwValueType,
        (LPBYTE)&dwLastHelpId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        szTestErrorMessage  = (LPWSTR)L"Unable to read Last Help value";
        goto BNT_BAILOUT;
    }

    pdwIdArray[2] = dwLastHelpId;

    // get number of items
    
    dwBufferSize = sizeof (dwLastId);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        cszLastCounter,
        0L,
        &dwValueType,
        (LPBYTE)&dwLastId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        szTestErrorMessage  = (LPWSTR)L"Unable to read Last Counter value";
        goto BNT_BAILOUT;
    }
    
    pdwIdArray[0] = dwLastId;
    
    if (dwLastId < dwLastHelpId)
        dwLastId = dwLastHelpId;

    dwArraySize = dwLastId * sizeof(LPWSTR);

    // get Perflib system version
    if (szMachineName[0] == 0) {
        hKeyNames = HKEY_PERFORMANCE_DATA;
    } else {
        lWin32Status = RegConnectRegistryW (szMachineName,
            HKEY_PERFORMANCE_DATA,
            &hKeyNames);
    }
    lstrcpyW (CounterNameBuffer, cszCounterName);
    lstrcatW (CounterNameBuffer, lpszLangId);

    lstrcpyW (HelpNameBuffer, cszHelpName);
    lstrcatW (HelpNameBuffer, lpszLangId);

    // get size of counter names and add that to the arrays
    
    dwBufferSize = 0;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        CounterNameBuffer,
        0L,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        szTestErrorMessage  = (LPWSTR)L"Unable to query counter string size";
        goto BNT_BAILOUT;
    }

    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays
    
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        HelpNameBuffer,
        0L,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        szTestErrorMessage  = (LPWSTR)L"Unable to query help string size";
        goto BNT_BAILOUT;
    }

    dwHelpSize = dwBufferSize;

    lpReturnValue = (LPWSTR *)HeapAlloc (g_hTestHeap, 0,dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) {
        lWin32Status = ERROR_OUTOFMEMORY;
        szTestErrorMessage  = (LPWSTR)L"Unable to allocate name string buffer";
        goto BNT_BAILOUT;
    }
    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        CounterNameBuffer,
        0L,
        &dwValueType,
        (LPBYTE)lpCounterNames,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        szTestErrorMessage  = (LPWSTR)L"Unable to query counter string contents";
        goto BNT_BAILOUT;
    }
 
    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        HelpNameBuffer,
        0L,
        &dwValueType,
        (LPBYTE)lpHelpText,
        &dwBufferSize);
                            
    if (lWin32Status != ERROR_SUCCESS) {
        szTestErrorMessage  = (LPWSTR)L"Unable to query help string contents";
        goto BNT_BAILOUT;
    }

    dwLastCounterIdUsed = 0;
    dwLastHelpIdUsed = 0;

    // load counter array items

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlenW(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) {
            lWin32Status = ERROR_BADKEY;
            szTestErrorMessage  = (LPWSTR)L"Bad counter string entry, CONFIG_String_LastCounter is last valid counter string index";
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name

        lpThisName += (lstrlenW(lpThisName)+1);  

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastCounterIdUsed) dwLastCounterIdUsed = dwThisCounter;

    }

    pdwIdArray[1] = dwLastCounterIdUsed;

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlenW(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) {
            lWin32Status = ERROR_BADKEY;
            szTestErrorMessage  = (LPWSTR)L"Bad help string entry, CONFIG_String_LastHelp is last valid counter string index";
            goto BNT_BAILOUT;  // bad entry
        }
        // point to corresponding counter name

        lpThisName += (lstrlenW(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastHelpIdUsed) dwLastHelpIdUsed= dwThisCounter;
    }

    pdwIdArray[3] = dwLastHelpIdUsed;

    dwLastId = dwLastHelpIdUsed;
    if (dwLastId < dwLastCounterIdUsed) dwLastId = dwLastCounterIdUsed;

    if (pdwLastItem) *pdwLastItem = dwLastId;

    HeapFree (g_hTestHeap, 0, (LPVOID)lpValueNameString);
    RegCloseKey (hKeyValue);
    RegCloseKey (hKeyNames);
	RegCloseKey(hKeyRegistry);

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        SetLastError (lWin32Status);
    }

    if (lpValueNameString) {
        HeapFree (g_hTestHeap, 0, (LPVOID)lpValueNameString);
    }
    
    if (lpReturnValue) {
        HeapFree (g_hTestHeap, 0, (LPVOID)lpValueNameString);
    }
    
    if (hKeyValue) 
		RegCloseKey (hKeyValue);

	if (hKeyNames)
		RegCloseKey (hKeyNames);

	if (hKeyRegistry)
		RegCloseKey(hKeyRegistry);

    return NULL;
}


DWORD 
CycleTest (
    DWORD   dwThreadId,
    PEXT_OBJECT  pObj
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwLoopCount = g_LTData.dwLoopCount;
    BOOL    bPrintData = g_LTData.bDisplay;
    DOUBLE  dMs;

    UNREFERENCED_PARAMETER (dwThreadId);

// Open the Library
// ================

    dwStatus = OpenLibrary (pObj);

    if ((dwStatus == ERROR_SUCCESS) && 
		(pObj != NULL)) {
         // an object info block was returned
        dMs = (DOUBLE)pObj->llOpenTime;     // ticks used
        dMs /= (DOUBLE)pObj->llTimeBase;    // ticks/sec
        dMs *= 1000.0;                      // ms/Sec
		fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:INFO_OpenServiceName:	   \t%s", GetCurrentThreadId(), pObj->szServiceName);
        fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:INFO_OpenProcTime:       \t%12.5f mSec", GetCurrentThreadId(), dMs);
//        fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:INFO_OpenProcTimeout:    \t%6d.00000 mSec", GetCurrentThreadId(), pObj->dwOpenTimeout);

        // check for timeout
        if (dMs > (DOUBLE)pObj->dwOpenTimeout) {
            dwStatus = ERROR_TIMEOUT;
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tOpen procedure exceeded timeout", GetCurrentThreadId());
			CloseLibrary (pObj);
        }
    } else {
        // no object block returned
        fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tUnable to open the \"%s\" Performance Library", GetCurrentThreadId(), pObj->szServiceName);
        fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORCODE:\t0x%8.8x (%dL)", GetCurrentThreadId(), dwStatus, dwStatus);
    }

// Collect Data for "dwLoopCount" times
// ====================================

    if (dwStatus == ERROR_SUCCESS) 
	{
        HeapValidate (g_hTestHeap, 0, NULL);

        // call collect function
        do 
		{
            // get the data again
            dwStatus = CollectData (pObj);

			HeapValidate (g_hTestHeap, 0, NULL);
 
        } while (--dwLoopCount > 0);

// Close Library
// =============

		// Even if we get an error, we should try to close the library
		// ===========================================================

		CloseLibrary (pObj);

// Report Status
// =============

        if (dwStatus == ERROR_SUCCESS) {
			// dump collect fn stats.
			fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:INFO_ServiceName:        \t%s", GetCurrentThreadId(), pObj->szServiceName);
            if ((pObj->dwCollectCount > 0)  && (pObj->dwNumObjectsRet > 0)){
                // don't compute time if no objects were returned
                dMs = (DOUBLE)pObj->llCollectTime;
                dMs /= (DOUBLE)pObj->llTimeBase;
                dMs *= 1000.0;
                dMs /= (DOUBLE)pObj->dwCollectCount;
                fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:INFO_AvgCollectProcTime: \t%12.5f mSec", GetCurrentThreadId(), dMs);
                fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:INFO_CollectProcTimeout: \t%6d.00000 mSec", GetCurrentThreadId(), pObj->dwCollectTimeout);
            }
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:INFO_ObjectsRet:         \t%d", GetCurrentThreadId(), pObj->dwNumObjectsRet);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:INFO_RetBuffSize:        \t%d", GetCurrentThreadId(), pObj->dwRetBufSize);
        } else {
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERROR:    \tCollect procedure returned an error", GetCurrentThreadId());
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORCODE:\t0x%8.8x (%dL)", GetCurrentThreadId(), dwStatus, dwStatus);
		
            // output the contents of the info buffer
            if (dwStatus == ERROR_TIMEOUT) {
                // dump collect fn stats.
                dMs = (DOUBLE)pObj->llFunctionTime;
                dMs /= (DOUBLE)pObj->llTimeBase;
                dMs *= 1000.0;
				fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_CollectService: \t%s", GetCurrentThreadId(), pObj->szServiceName);
                fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_CollectProcTime:\t%12.5f mSec", GetCurrentThreadId(), dMs);
                fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_CollectTimeout: \t%6d.00000 mSec", GetCurrentThreadId(), pObj->dwCollectTimeout);
			}

			fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_CollectService: \t%s", GetCurrentThreadId(), pObj->szServiceName);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_CollectTime: \t%I64u", GetCurrentThreadId(), pObj->llCollectTime);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_CollectCount:\t%d", GetCurrentThreadId(), pObj->dwCollectCount);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_OpenCount:   \t%d", GetCurrentThreadId(), pObj->dwOpenCount);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_CloseCount:  \t%d", GetCurrentThreadId(), pObj->dwCloseCount);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_LockoutCount:\t%d", GetCurrentThreadId(), pObj->dwLockoutCount);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_ErrorCount:  \t%d", GetCurrentThreadId(), pObj->dwErrorCount);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_Exceptions:  \t%d", GetCurrentThreadId(), pObj->dwExceptionCount);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_LowerGPErrs: \t%d", GetCurrentThreadId(), pObj->dwLowerGPViolations);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_UpperGPErrs: \t%d", GetCurrentThreadId(), pObj->dwUpperGPViolations);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_BadPointers: \t%d", GetCurrentThreadId(), pObj->dwBadPointers);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_BufSizeErrs: \t%d", GetCurrentThreadId(), pObj->dwBufferSizeErrors);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_AlignErrors: \t%d", GetCurrentThreadId(), pObj->dwAlignmentErrors);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_ObjSizeErrs: \t%d", GetCurrentThreadId(), pObj->dwObjectSizeErrors);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_InstSizeErrs:\t%d", GetCurrentThreadId(), pObj->dwInstanceSizeErrors);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_TimeBase:    \t%I64u", GetCurrentThreadId(), pObj->llTimeBase);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_FunctionTime:\t%I64u", GetCurrentThreadId(), pObj->llFunctionTime);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_ObjectsRet:  \t%d", GetCurrentThreadId(), pObj->dwNumObjectsRet);
            fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ERRORINFO_RetBuffSize: \t%d", GetCurrentThreadId(), pObj->dwRetBufSize);
		}
    }

    HeapValidate (g_hTestHeap, 0, NULL);

    return dwStatus;
}


unsigned __stdcall CycleThreadProc( void * lpThreadArg )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD	dwCycleCount = g_LTData.dwCycleCount;
	DWORD	dwThreadNum = *((DWORD*)lpThreadArg);

	PEXT_OBJECT pObj = NULL;
	EXT_OBJECT ThreadObj;

    DWORD   dwThisThread = GetCurrentThreadId();

    HeapValidate (g_hTestHeap, 0, NULL);

	srand( GetTickCount() );

    do {
		// If the rand flag is set, randomly choose an object to hit

		if (g_fRand)
		{
			pObj = &g_pExtObjects[rand()%g_LTData.dwNumObjects];
		}
		else
		{
			pObj = &g_pExtObjects[dwThreadNum];
		}

		if ( pObj->bValid )
		{
			memcpy(&ThreadObj, pObj, sizeof(EXT_OBJECT));

			dwStatus = CycleTest(dwThisThread, &ThreadObj);

			// What error handling mode are we using?
			if (g_LTData.bStopOnError)
			{
				if (( ERROR_SUCCESS != dwStatus ) &&
					(ERROR_INVALID_DATA != dwStatus))
				{
					SetEvent( g_hEvent );
				}
				else
				{
					if ( WAIT_OBJECT_0 == WaitForSingleObject( g_hEvent, 0 ) )
						break;
					dwStatus = ERROR_SUCCESS;
				}
			}
		}
    } while (--dwCycleCount > 0);

    HeapValidate (g_hTestHeap, 0, NULL);

    return dwStatus;
}


DWORD Initialize( WCHAR* szIniFileName, DWORD* pdwThreadCount )
{
	DWORD	dwStatus	= ERROR_SUCCESS;
	BOOL	bStatus		= FALSE;
	WCHAR				wcsReturnBuff[256];
	WCHAR				wcsKeyName[256];
	DWORD				dwCtr = 0;

    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_INI_File_Name:\t%s", szIniFileName);
	fwprintf (g_pOutput, (LPCWSTR)L"\n");

	// LTData

	GetPrivateProfileStringW( L"Main", L"NumObjects", L"0", wcsReturnBuff, 256, szIniFileName );
	g_LTData.dwNumObjects = wcstoul(wcsReturnBuff, NULL, 10);

	GetPrivateProfileStringW( L"Main", L"CycleCount", L"0", wcsReturnBuff, 256, szIniFileName );
	g_LTData.dwCycleCount = wcstoul(wcsReturnBuff, NULL, 10);

	GetPrivateProfileStringW( L"Main", L"LoopCount", L"0", wcsReturnBuff, 256, szIniFileName );
	g_LTData.dwLoopCount = wcstoul(wcsReturnBuff, NULL, 10);

	GetPrivateProfileStringW( L"Main", L"StopOnError", L"0", wcsReturnBuff, 256, szIniFileName );
	g_LTData.bStopOnError = wcstoul(wcsReturnBuff, NULL, 10);

	g_LTData.bDisplay = TRUE;

	g_LTData.bTestContents = TRUE;

	// Other

	GetPrivateProfileStringW( L"Main", L"NumThreads", L"0", wcsReturnBuff, 256, szIniFileName );
	*pdwThreadCount = wcstoul(wcsReturnBuff, NULL, 10);
	if ( *pdwThreadCount < g_LTData.dwNumObjects )
	{
		*pdwThreadCount = g_LTData.dwNumObjects;
	}

	GetPrivateProfileStringW( L"Main", L"Random", L"0", wcsReturnBuff, 256, szIniFileName );
	g_fRand = wcstoul(wcsReturnBuff, NULL, 10);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_Number_Of_Perf_Objects:      \t%d", g_LTData.dwNumObjects);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_Number_Of_Test_Cycles:       \t%d", g_LTData.dwCycleCount);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_Number_Of_Collects_Per_Cycle:\t%d", g_LTData.dwLoopCount);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_Display_Results:             \t%s", (g_LTData.bDisplay?L"Yes":L"No"));
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_Validate_Data:               \t%s", (g_LTData.bTestContents?L"Yes":L"No"));
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_Number_Of_Threads:           \t%d", *pdwThreadCount);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_Randomize_Perf_Objects:      \t%s", (g_fRand?L"Yes":L"No"));
	fwprintf (g_pOutput, (LPCWSTR)L"\n");

	g_pExtObjects = (EXT_OBJECT*) HeapAlloc(g_hTestHeap, 
											HEAP_ZERO_MEMORY, 
											g_LTData.dwNumObjects * sizeof(EXT_OBJECT));

	if ( NULL != g_pExtObjects )
	{
		for( dwCtr = 0; dwCtr < g_LTData.dwNumObjects; dwCtr++ )
		{
			// Service name
			swprintf( wcsKeyName, L"Object%d", dwCtr );
			GetPrivateProfileStringW( L"Main", wcsKeyName, L"PerfProc", wcsReturnBuff, 256, szIniFileName );
			g_pExtObjects[dwCtr].szServiceName = (WCHAR*) HeapAlloc( g_hTestHeap, 0,
																( wcslen( wcsReturnBuff ) + 1 ) * sizeof(WCHAR) );
			wcscpy( g_pExtObjects[dwCtr].szServiceName, wcsReturnBuff );

			// Query string
			swprintf( wcsKeyName, L"Counter%d", dwCtr );
			GetPrivateProfileStringW( L"Main", wcsKeyName, L"Global", wcsReturnBuff, 256, szIniFileName );
			g_pExtObjects[dwCtr].szQueryString = (WCHAR*) HeapAlloc( g_hTestHeap, 0,
																( wcslen( wcsReturnBuff ) + 1 ) * sizeof(WCHAR) );
			wcscpy( g_pExtObjects[dwCtr].szQueryString, wcsReturnBuff );

			// At least one object has to succeed
			bStatus = ( ( ERROR_SUCCESS == InitializeExtObj( &g_pExtObjects[dwCtr] )) || bStatus);
		
			fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_Perf_Object:    \t%s : %s",g_pExtObjects[dwCtr].szServiceName, (g_pExtObjects[dwCtr].bValid?L"Active":L"Inactive"));
		}
	}

	fwprintf (g_pOutput, (LPCWSTR)L"\n");

	if (!bStatus)
	{
		dwStatus = ERROR_INVALID_DATA;
	}

	return dwStatus;
}

int
WriteTestResultHeader()
{
    OSVERSIONINFOW       osInfo;
    WCHAR               szMachineName[MAX_PATH];
    DWORD               dwSize;
    SYSTEMTIME          stStart;

    memset (&osInfo, 0, sizeof(osInfo));
    osInfo.dwOSVersionInfoSize = sizeof(osInfo);

    memset (szMachineName, 0, sizeof(szMachineName));
    memset (&stStart, 0, sizeof(stStart));

    GetVersionExW (&osInfo);

    dwSize = sizeof(szMachineName) / sizeof (szMachineName[0]);
    GetComputerNameW (&szMachineName[0], &dwSize);

    GetLocalTime (&stStart);

    fwprintf (g_pOutput, (LPCWSTR)L"\n[TESTRESULT]");
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tTEST:    \tPerf Counter DLL Validation");
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tBUILD:   \t%d", osInfo.dwBuildNumber);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tMACHINE:\t%s", szMachineName);
 
    fwprintf (g_pOutput, (LPCWSTR)L"\n\t%d:START TIME:\t%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d",
                    GetCurrentThreadId(),
					stStart.wMonth, stStart.wDay, stStart.wYear % 100,
                    stStart.wHour, stStart.wMinute, stStart.wSecond );

    return 0;
}

int
WriteTestConfigData(
    LPDWORD pdwIdInfo
)
{
    fwprintf (g_pOutput, (LPCWSTR)L"\n\t");
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_Perflib_LastCounter:\t%d", pdwIdInfo[0]);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_String_LastCounter: \t%d", pdwIdInfo[1]);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_Perflib_LastHelp:   \t%d", pdwIdInfo[2]);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_String_LastHelp:    \t%d", pdwIdInfo[3]);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_Disabled:           \t%d", pdwIdInfo[4]);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_ExtCounterTestLevel:\t%d", pdwIdInfo[5]);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_BaseIndex:          \t%d", pdwIdInfo[6]);
//    fwprintf (g_pOutput, (LPCWSTR)L"\n\tCONFIG_BaseOsObject   :    \t%d", pdwIdInfo[7]);
    
    return 0;
}

DWORD
WriteGroupConfig(
    HKEY    hKeyPerfSubKey,
    DWORD   *pIds
)
{
    DWORD   nRetStatus = (int)ERROR_SUCCESS;
    DWORD   lStatus;
    DWORD   dwData;
    DWORD   dwBufferSize;
    DWORD   dwValueType;
    WCHAR   szStringBuffer[MAX_PATH*2];

    dwBufferSize = sizeof(szStringBuffer);
    dwValueType = 0;
    memset (szStringBuffer, 0, sizeof(szStringBuffer));
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Library",
        0L,
        &dwValueType,
        (LPBYTE)&szStringBuffer[0],
        &dwBufferSize);
 
    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:ONFIG_Library:\t%s", 
		GetCurrentThreadId(), 
        (lStatus == ERROR_SUCCESS ? szStringBuffer : cszNotFound));
    if (lStatus != ERROR_SUCCESS) nRetStatus = lStatus;

    dwBufferSize = sizeof(szStringBuffer);
    dwValueType = 0;
    memset (szStringBuffer, 0, sizeof(szStringBuffer));
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Open",
        0L,
        &dwValueType,
        (LPBYTE)&szStringBuffer[0],
        &dwBufferSize);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:CONFIG_Open:\t%s", 
		GetCurrentThreadId(),
        (lStatus == ERROR_SUCCESS ? szStringBuffer : cszNotFound));
    if (lStatus != ERROR_SUCCESS) nRetStatus = lStatus;
        

    dwBufferSize = sizeof(szStringBuffer);
    dwValueType = 0;
    memset (szStringBuffer, 0, sizeof(szStringBuffer));
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Collect",
        0L,
        &dwValueType,
        (LPBYTE)&szStringBuffer[0],
        &dwBufferSize);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:CONFIG_Collect:\t%s", 
		GetCurrentThreadId(), 
        (lStatus == ERROR_SUCCESS ? szStringBuffer : cszNotFound));
    if (lStatus != ERROR_SUCCESS) nRetStatus = lStatus;

    dwBufferSize = sizeof(szStringBuffer);
    dwValueType = 0;
    memset (szStringBuffer, 0, sizeof(szStringBuffer));
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Object List",
        0L,
        &dwValueType,
        (LPBYTE)&szStringBuffer[0],
        &dwBufferSize);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:CONFIG_Object List:\t%s", 
		GetCurrentThreadId(),
        (lStatus == ERROR_SUCCESS ? szStringBuffer : cszNotFound));

    dwBufferSize = sizeof(szStringBuffer);
    dwValueType = 0;
    memset (szStringBuffer, 0, sizeof(szStringBuffer));
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Close",
        0L,
        &dwValueType,
        (LPBYTE)&szStringBuffer[0],
        &dwBufferSize);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:CONFIG_Close:\t%s", 
		GetCurrentThreadId(), 
        (lStatus == ERROR_SUCCESS ? szStringBuffer : cszNotFound));
    if (lStatus != ERROR_SUCCESS) nRetStatus = lStatus;

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"First Counter",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:CONFIG_First Counter:\t%d", 
		GetCurrentThreadId(), 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)-1));
    if (lStatus != ERROR_SUCCESS) {
        if (lStatus == ERROR_FILE_NOT_FOUND) {
            if (!pIds[4]) {
                // then this hasn't been installed yet
                nRetStatus = ERROR_SERVICE_DISABLED;
            } else {
                // then this is a base OS service
                nRetStatus = ERROR_SUCCESS;
            }
        } else {
            // some other error so return
            nRetStatus = lStatus;
        }
        pIds[0] = (DWORD)-1;
    } else {
        pIds[0] = dwData;
    }

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Last Counter",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:CONFIG_Last Counter:\t%d", 
		GetCurrentThreadId(), 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)-1));
    if (lStatus != ERROR_SUCCESS) {
        if (lStatus == ERROR_FILE_NOT_FOUND) {
            if (!pIds[4]) {
                // then this hasn't been installed yet
                nRetStatus = ERROR_SERVICE_DISABLED;
            } else {
                // then this is a base OS service
                nRetStatus = ERROR_SUCCESS;
            }
        } else {
            // some other error so return
            nRetStatus = lStatus;
        }
        pIds[1] = (DWORD)-1;
    } else {
        pIds[1] = dwData;
    }

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"First Help",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:CONFIG_First Help:\t%d", 
		GetCurrentThreadId(), 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)-1));
    if (lStatus != ERROR_SUCCESS) {
        if (lStatus == ERROR_FILE_NOT_FOUND) {
            if (!pIds[4]) {
                // then this hasn't been installed yet
                nRetStatus = ERROR_SERVICE_DISABLED;
            } else {
                // then this is a base OS service
                nRetStatus = ERROR_SUCCESS;
            }
        } else {
            // some other error so return
            nRetStatus = lStatus;
        }
        pIds[2] = (DWORD)-1;
    } else {
        pIds[2] = dwData;
    }

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Last Help",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:CONFIG_Last Help:\t%d", 
		GetCurrentThreadId(), 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)-1));
    if (lStatus != ERROR_SUCCESS) {
        if (lStatus == ERROR_FILE_NOT_FOUND) {
            if (!pIds[4]) {
                // then this hasn't been installed yet
                nRetStatus = ERROR_SERVICE_DISABLED;
            } else {
                // then this is a base OS service
                nRetStatus = ERROR_SUCCESS;
            }
        } else {
            // some other error so return
            nRetStatus = lStatus;
        }
        pIds[3] = (DWORD)-1;
    } else {
        pIds[3] = dwData;
    }

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Open Timeout",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:CONFIG_Open Timeout:\t%d", 
		GetCurrentThreadId(), 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)10000));

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Collect Timeout",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:CONFIG_Collect Timeout:\t%d", 
		GetCurrentThreadId(), 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)10000));

    dwBufferSize = sizeof(dwData);
    dwValueType = 0;
    dwData = 0;
    lStatus = RegQueryValueExW (
        hKeyPerfSubKey,
        (LPCWSTR)L"Disable Performance Counters",
        0L,
        &dwValueType,
        (LPBYTE)&dwData,
        &dwBufferSize);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\t%d:CONFIG_Disable Performance Counters:\t%d", 
		GetCurrentThreadId(), 
        (lStatus == ERROR_SUCCESS ? dwData : (DWORD)0));
    if ((lStatus == ERROR_SUCCESS) && (dwData != 0)){
        nRetStatus = ERROR_SERVICE_DISABLED;
    }

    return nRetStatus;
}

int
WriteTestResultTrailer(
    DWORD dwTestResult
)
{
    SYSTEMTIME          stEnd;
    LPWSTR              szResult;

    memset (&stEnd, 0, sizeof(stEnd));

    GetLocalTime (&stEnd);

    switch (dwTestResult) {
        case PERFVAL_PASS:
            szResult = (LPWSTR)L"PASS"; break;

        case PERFVAL_FAIL:
            szResult = (LPWSTR)L"FAIL"; break;

        case PERFVAL_TIMEOUT:
            szResult = (LPWSTR)L"TIMEOUT"; break;

        case PERFVAL_NOCONFIG:
        default:
            szResult = (LPWSTR)L"NOCONFIG"; break;
    }

    fwprintf (g_pOutput, (LPCWSTR)L"\n\n\tRESULT:   \t%s", szResult);
        
    fwprintf (g_pOutput, (LPCWSTR)L"\n\tEND TIME:\t%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d", 
                    stEnd.wMonth, stEnd.wDay, stEnd.wYear % 100,
                    stEnd.wHour, stEnd.wMinute, stEnd.wSecond);

    fwprintf (g_pOutput, (LPCWSTR)L"\n[/TESTRESULT]");

    fwprintf (g_pOutput, (LPCWSTR)L"\n");
    return 0;
}

int
WriteGroupHeader(
	LPCWSTR szGroupName
)
{
    SYSTEMTIME          stStart;

    memset (&stStart, 0, sizeof(stStart));

    GetLocalTime (&stStart);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\n\t[GROUP: %s]", szGroupName);

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\tSTART TIME:\t%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%3.3d",
                    stStart.wMonth, stStart.wDay, stStart.wYear % 100,
                    stStart.wHour, stStart.wMinute, stStart.wSecond, stStart.wMilliseconds );

    return 0;
}

int
WriteGroupTrailer(
	DWORD dwTestResult
)
{
    LPWSTR              szResult;
    SYSTEMTIME          stEnd;

    memset (&stEnd, 0, sizeof(stEnd));

    GetLocalTime (&stEnd);

    switch (dwTestResult) {
        case PERFVAL_PASS:
            szResult = (LPWSTR)L"PASS"; break;

        case PERFVAL_FAIL:
            szResult = (LPWSTR)L"FAIL"; break;

        case PERFVAL_TIMEOUT:
            szResult = (LPWSTR)L"TIMEOUT"; break;

        case PERFVAL_NOCONFIG:
        default:
            szResult = (LPWSTR)L"NOCONFIG"; break;
    }

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\tEND TIME:\t%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%3.3d",
                    stEnd.wMonth, stEnd.wDay, stEnd.wYear % 100,
                    stEnd.wHour, stEnd.wMinute, stEnd.wSecond, stEnd.wMilliseconds );

    fwprintf (g_pOutput, (LPCWSTR)L"\n\t\tRESULT:   %s", szResult);
    fwprintf (g_pOutput, (LPCWSTR)L"\n\t[/GROUP]");

    return 0;
}

int
WriteTestError (
    DWORD   dwTabLevel,
    DWORD   dwStatus
)
{
    DWORD   dwIndent;
    fwprintf (g_pOutput, (LPCWSTR)L"\n");
    for (dwIndent = 0; dwIndent < dwTabLevel; dwIndent++) {
        fwprintf (g_pOutput, (LPCWSTR)L"\t");
    }
    fwprintf (g_pOutput, (LPCWSTR)L"%d:ERROR:    \t%s", GetCurrentThreadId(), (szTestErrorMessage != NULL ? szTestErrorMessage : (LPCWSTR)L"No Error"));

    fwprintf (g_pOutput, (LPCWSTR)L"\n");
    for (dwIndent = 0; dwIndent < dwTabLevel; dwIndent++) {
        fwprintf (g_pOutput, (LPCWSTR)L"\t");
    }
    fwprintf (g_pOutput, (LPCWSTR)L"%d:ERRORCODE:\t0x%8.8x (%d)", GetCurrentThreadId(), dwStatus, dwStatus);
    return 0;
}  

int
__cdecl 
wmain(
    int argc,
    WCHAR *argv[]
)
{
    DWORD   dwStatus;
    DWORD   dwLastElement = 0;
    DWORD   dwIdArray[8];
	DWORD	dwTID = 0;
	DWORD	dwObj;

    DWORD   dwTestResult = PERFVAL_NOCONFIG;

    DWORD   dwThreadCount = 0;
	LOCAL_THREAD_DATA*	pCurLTData = NULL;
    HANDLE  hThreads[MAXIMUM_WAIT_OBJECTS];
    DWORD   dwThisThread;
	WCHAR*	pwcsINIFile = L".\\ctrtest.ini";
	BOOL	fRand = FALSE;
	int		nIndex = 0;

	// Set up environment

	g_hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

	if ( NULL == g_hEvent )
		return ERROR_INVALID_ACCESS;

	g_pOutput = stdout;

	g_hTestHeap = HeapCreate (HEAP_GENERATE_EXCEPTIONS, 0x10000, 0);

	if (g_hTestHeap == NULL) 
		return (ERROR_OUTOFMEMORY);

	WriteTestResultHeader(g_pOutput);

    memset (&dwIdArray[0], 0, sizeof(dwIdArray));

    g_pNameTable = BuildNameTable (
        (LPCWSTR)L"",
        (LPCWSTR)L"009",
        &dwLastElement,     // size of array in elements
        &dwIdArray[0]);

	g_dwLastIndex = dwLastElement;

    WriteTestConfigData(&dwIdArray[0]);

    if (g_pNameTable == NULL) {
        // check for name table errors
        dwStatus = GetLastError();       // so we don't continue
        dwTestResult = PERFVAL_FAIL;
        WriteTestError (1, dwStatus);
    } 
	else 
	{
		if ( argc > 1 )
		{
			pwcsINIFile = argv[1];
		}

		// Load up object/ctr data
		dwStatus = Initialize( pwcsINIFile, &dwThreadCount );

		if ( ERROR_SUCCESS == dwStatus )
		{
			srand( GetTickCount() );

			// create threads
			for (dwThisThread = 0; dwThisThread < dwThreadCount; dwThisThread++) 
			{
				hThreads[dwThisThread] = (HANDLE) _beginthreadex( NULL, 0,
										CycleThreadProc, (void*) &dwThisThread, 0, &dwTID );
			}

			// Let these all run through
			dwStatus = WaitForMultipleObjects (dwThreadCount, hThreads, TRUE, INFINITE);
			if (dwStatus != WAIT_TIMEOUT) 
				dwStatus = ERROR_SUCCESS;
			for (dwThisThread = 0; dwThisThread < dwThreadCount; dwThisThread++) {
				CloseHandle (hThreads[dwThisThread]);
			}
		}
	}

    WriteTestResultTrailer(dwTestResult);

	for (dwObj = 0; dwObj < g_LTData.dwNumObjects; dwObj++)
	{
		FinializeExtObj(&g_pExtObjects[dwObj]);
	}

	if ( NULL != g_pNameTable )
		HeapFree(g_hTestHeap, 0, g_pNameTable);

	if ( NULL != g_pExtObjects )
		HeapFree(g_hTestHeap, 0, g_pExtObjects);

	if ( NULL != g_hTestHeap )
		HeapDestroy (g_hTestHeap);

	CloseHandle( g_hEvent );

    return (int)dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\ctrtest\ctrtest.h ===
#ifndef _CTRTEST_H_
#define _CTRTEST_H_

#define WBEMPERF_OPEN_PROC_NOT_FOUND    0xC0100002
#define WBEMPERF_COLLECT_PROC_NOT_FOUND 0xC0100003
#define WBEMPERF_CLOSE_PROC_NOT_FOUND   0xC0100004
#define WBEMPERF_OPEN_PROC_FAILURE      0xC0100005
#define WBEMPERF_OPEN_PROC_EXCEPTION    0xC0100006

#define DWORD_PTR	DWORD

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes)
#define ALIGN_ON_DWORD(x) ((VOID *)(((DWORD_PTR)x & 3) ? (((DWORD_PTR)x & ~3) + 4) : ((DWORD_PTR)x)))

#define QWORD_MULTIPLE(x) (((x+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))

//    (assumes quadword is 8 bytes)
#define ALIGN_ON_QWORD(x) ((VOID *)(((DWORD_PTR)x & 7) ? (((DWORD_PTR)x & ~7) + 8) : ((DWORD_PTR)x)))

//
//      constants used by guard page testing
//
#define GUARD_PAGE_SIZE 1024
#define GUARD_PAGE_CHAR 0xA5
#define GUARD_PAGE_DWORD 0xA5A5A5A5

#define  LOG_UNDEFINED  ((LONG)-1)
#define  LOG_NONE       0
#define  LOG_USER       1
#define  LOG_DEBUG      2
#define  LOG_VERBOSE    3

#define     EXT_TEST_UNDEFINED  0
#define     EXT_TEST_ALL        1
#define     EXT_TEST_BASIC      2
#define     EXT_TEST_NONE       3
#define     EXT_TEST_NOMEMALLOC 4

//
//  Definition of handle table for extensible objects
//
typedef PM_OPEN_PROC    *OPENPROC;
typedef PM_COLLECT_PROC *COLLECTPROC;
typedef PM_QUERY_PROC   *QUERYPROC;
typedef PM_CLOSE_PROC   *CLOSEPROC;

#define EXT_OBJ_INFO_NAME_LENGTH    32

typedef struct _EXT_OBJECT {
        LPVOID      pNext;   // not used
        HANDLE      hMutex;         // sync mutex for this function
        OPENPROC    OpenProc;       // address of the open routine
        LPSTR       szOpenProcName; // open procedure name
        LPWSTR      szLinkageString; // param for open proc
        DWORD       dwOpenTimeout;  // wait time in MS for open proc
        COLLECTPROC CollectProc;    // address of the collect routine
        QUERYPROC   QueryProc;      // address of query proc
        LPSTR       szCollectProcName;  // collect procedure name
        DWORD       dwCollectTimeout;   // wait time in MS for collect proc
        CLOSEPROC   CloseProc;     // address of the close routine
        LPSTR       szCloseProcName;    // close procedure name
        HMODULE     hLibrary ;     // handle returned by LoadLibraryW
        LPWSTR      szLibraryName;  // full path of library
        DWORD       dwNumObjects;  // number of supported objects
        DWORD       dwObjList[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];    // address of array of supported objects
        DWORD       dwFlags;        // flags
        LPWSTR      szServiceName;  // service name
        LONGLONG    llLastUsedTime; // FILETIME of last access
// Performance statistics
        LONGLONG    llOpenTime;     // total time spent in open procedure
        LONGLONG    llCollectTime;  // time spent in call in 100Ns Units
        DWORD       dwCollectCount; // number of times Collect successfully called
        DWORD       dwOpenCount;    // number of Loads & opens
        DWORD       dwCloseCount;   // number of Unloads & closes
        DWORD       dwLockoutCount; // count of lock timeouts
        DWORD       dwErrorCount;   // count of errors (other than timeouts)
        DWORD       dwExceptionCount; // exceptions
        DWORD       dwLowerGPViolations;
        DWORD       dwUpperGPViolations;
        DWORD       dwBadPointers;
        DWORD       dwBufferSizeErrors;
        DWORD       dwAlignmentErrors;
        DWORD       dwObjectSizeErrors;
        DWORD       dwInstanceSizeErrors;
        DWORD       dwInstanceNameErrors;
        // last function call values
        LONGLONG    llTimeBase;     // time base frequency
        LONGLONG    llFunctionTime; // time spent in call in 100Ns Units
        DWORD       dwNumObjectsRet; // number of objects returned by collect function
        DWORD       dwRetBufSize;   // buffer size returned by function
		BOOL		bValid;			// Is the object valid on this machine?
		LPWSTR		szQueryString;	// The string to query
} EXT_OBJECT , *PEXT_OBJECT ;


// ext object flags
#define PERF_EO_QUERY_FUNC  ((DWORD)0x00000001)     // use query proc
#define PERF_EO_BAD_DLL     ((DWORD)0x00000002)     // true when DLL ret. error
#define PERF_EO_KEEP_RESIDENT ((DWORD)0x00000004)    // true if lib should not be trimmed
#define PERF_EO_OBJ_IN_QUERY ((DWORD)0x80000000)    // true when in query list


typedef struct _EXT_CTR_PERF_DATA {
        // accumulating functions
        LONGLONG    llElapsedTime;  // cumulative time spent in call in 100Ns Units
        DWORD       dwCollectCount; // number of times Collect successfully called
        DWORD       dwOpenCount;    // number of Loads & opens
        DWORD       dwCloseCount;   // number of Unloads & closes
        DWORD       dwLockoutCount; // count of lock timeouts
        DWORD       dwErrorCount;   // count of errors (other than timeouts)
        DWORD       dwExceptionCount; // exceptions
        DWORD       dwLowerGPViolations;
        DWORD       dwUpperGPViolations;
        DWORD       dwBadPointers;
        DWORD       dwBufferSizeErrors;
        DWORD       dwAlignmentErrors;
        DWORD       dwObjectSizeErrors;
        DWORD       dwInstanceSizeErrors;
        DWORD       dwReserved1;
        // last function call values
        LONGLONG    llTimeBase;     // time base frequency
        LONGLONG    llFunctionTime; // time spent in call in 100Ns Units
        DWORD       dwNumObjects;   // number of objects returned by collect function
        DWORD       dwRetBufSize;   // buffer size returned by function
} EXT_CTR_PERF_DATA, *PEXT_CTR_PERF_DATA;

typedef struct _OPEN_PROC_WAIT_INFO {
    struct _OPEN_PROC_WAIT_INFO *pNext;
    LPWSTR  szLibraryName;
    LPWSTR  szServiceName;
    DWORD   dwWaitTime;
    DWORD   dwEventMsg;
    LPVOID  pData;
} OPEN_PROC_WAIT_INFO, FAR * LPOPEN_PROC_WAIT_INFO;

#define NextObject(pObject)            \
   ((PERF_OBJECT_TYPE *) ((PBYTE) pObject + pObject->TotalByteLength))

#define FirstCounter(pObjectDef)       \
   ((PERF_COUNTER_DEFINITION *) ((PCHAR)pObjectDef + pObjectDef->HeaderLength))

#define NextCounter(pCounterDef)       \
   ((PERF_COUNTER_DEFINITION *) ((PCHAR)pCounterDef + pCounterDef->ByteLength))

typedef struct _SAFE_BUFFER
{
	DWORD	dwBufSize;			// Size of safe buffer
	DWORD	dwCallBufSize;		// Buffer size call parameter
	DWORD	dwBufSizeIncrement;	// Size of reallocation increment
    LPVOID  lpLowGuardPage;		// Pointer to the low guard bytes
    LPVOID  lpHiGuardPage;		// Pointer to the high guard bytes
    LPVOID  lpEndPointer;		// Pointer to the end of the buffer
    LPVOID  lpBuffer;			// Pointer to the full buffer
	LPVOID	lpSafeBuffer;		// Pointer to the safe buffer
    LPVOID  lpCallBuffer;		// Pointer to the call parameter
} SAFE_BUFFER, *PSAFE_BUFFER;

#endif //_CTRTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\ctrtest\strings.h ===
// strings.h
//
// central definition file of common static strings
// these strings SHOULD NOT be localized as they are internal
// to the program and not intended for any display to the user
//
#include "windows.h"

#ifdef __cplusplus
extern "C" {
#endif

// single character constants
#define wcSpace     L' '
#define wcSlash     L'/'
#define wcPoundSign L'#'
#define wc_0        L'0'
#define wc_a        L'a'
#define wc_A        L'A'
#define wc_E        L'E'
#define wc_F        L'F'
#define wc_P        L'P'
#define wc_R        L'R'
#define wc_z        L'z'
   
// OLE and  Registry strings
extern LPCWSTR cszOleRegistryComment;
extern LPCWSTR cszClsidFormatString;
extern LPCWSTR cszThreadingModel;
extern LPCWSTR cszInprocServer;
extern LPCWSTR cszClsidKey;
extern LPCWSTR cszPerflibKey;
extern LPCWSTR cszDLLValue;
extern LPCWSTR cszObjListValue;
extern LPCWSTR cszLinkageKey;
extern LPCWSTR cszExportValue;
extern LPCWSTR cszOpenTimeout;
extern LPCWSTR cszCollectTimeout;
extern LPCWSTR cszExtCounterTestLevel;
extern LPCWSTR cszOpenProcedureWaitTime;
extern LPCWSTR cszLibraryUnloadTime;
extern LPCWSTR cszKeepResident;
extern LPCWSTR cszDisablePerformanceCounters;
extern LPCWSTR cszProviderName;
extern LPCWSTR cszHklmServicesKey;
extern LPCWSTR cszPerformance;
extern LPCWSTR cszGlobal;
extern LPCWSTR cszForeign;
extern LPCWSTR cszCostly;
extern LPCWSTR cszCounter;
extern LPCWSTR cszExplain;
extern LPCWSTR cszHelp;
extern LPCWSTR cszAddCounter;
extern LPCWSTR cszAddHelp;
extern LPCWSTR cszOnly;
extern LPCWSTR cszBoth;

extern LPCSTR  caszOpenValue;
extern LPCSTR  caszCloseValue;
extern LPCSTR  caszCollectValue;
extern LPCSTR  caszQueryValue;

// "well known" property names
extern LPCWSTR cszPropertyCount;
extern LPCWSTR cszClassName;
extern LPCWSTR cszName;
extern LPCWSTR cszTimestampPerfTime;
extern LPCWSTR cszFrequencyPerfTime;
extern LPCWSTR cszTimestampSys100Ns;
extern LPCWSTR cszFrequencySys100Ns;
extern LPCWSTR cszTimestampObject;
extern LPCWSTR cszFrequencyObject;

// "well known" qualifier names
extern LPCWSTR cszPerfIndex;
extern LPCWSTR cszSingleton;
extern LPCWSTR cszCountertype;
extern LPCWSTR cszProvider;
extern LPCWSTR cszRegistryKey;

// other random strings
extern LPCWSTR cszSpace;
extern LPCWSTR cszSlash;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\ctrtest\strings.cpp ===
// strings.cpp
//
// central definition file of common static strings
// these strings SHOULD NOT be localized as they are internal
// to the program and not intended for any display to the user
//
#include "strings.h"

// OLE and  Registry strings
LPCWSTR cszOleRegistryComment   = L"WBEM NT5 Base Perf Provider";
LPCWSTR cszClsidFormatString    = L"Software\\Classes\\CLSID\\\\%s";
LPCWSTR cszThreadingModel       = L"ThreadingModel";
LPCWSTR cszInprocServer         = L"InprocServer32";
LPCWSTR cszClsidKey             = L"Software\\Classes\\CLSID";
LPCWSTR cszPerflibKey           = L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR cszDLLValue             = L"Library";
LPCWSTR cszObjListValue         = L"Object List";
LPCWSTR cszLinkageKey           = L"\\Linkage";
LPCWSTR cszExportValue          = L"Export";
LPCWSTR cszOpenTimeout          = L"Open Timeout";
LPCWSTR cszCollectTimeout       = L"Collect Timeout";
LPCWSTR cszExtCounterTestLevel  = L"ExtCounterTestLevel";
LPCWSTR cszOpenProcedureWaitTime = L"OpenProcedureWaitTime";
LPCWSTR cszLibraryUnloadTime    = L"Library Unload Time";
LPCWSTR cszKeepResident         = L"Keep Library Resident";
LPCWSTR cszDisablePerformanceCounters = L"Disable Performance Counters";
LPCWSTR cszProviderName         = L"NT5_GenericPerfProvider_V1";
LPCWSTR cszHklmServicesKey      = L"SYSTEM\\CurrentControlSet\\Services";
LPCWSTR cszPerformance          = L"\\Performance";
LPCWSTR cszGlobal               = L"Global";
LPCWSTR cszForeign              = L"FOREIGN";
LPCWSTR cszCostly               = L"COSTLY";
LPCWSTR cszCounter              = L"COUNTER";
LPCWSTR cszExplain              = L"EXPLAIN";
LPCWSTR cszHelp                 = L"HELP";
LPCWSTR cszAddCounter           = L"ADDCOUNTER";
LPCWSTR cszAddHelp              = L"ADDEXPLAIN";
LPCWSTR cszOnly                 = L"ONLY";
LPCWSTR cszBoth                 = L"Both";

LPCSTR  caszOpenValue           = "Open";
LPCSTR  caszCloseValue          = "Close";
LPCSTR  caszCollectValue        = "Collect";
LPCSTR  caszQueryValue          = "Query";

// "well known" property names
LPCWSTR cszPropertyCount        = L"__PROPERTY_COUNT";
LPCWSTR cszClassName            = L"__CLASS";
LPCWSTR cszName                 = L"Name";
LPCWSTR cszTimestampPerfTime    = L"Timestamp_PerfTime";
LPCWSTR cszFrequencyPerfTime    = L"Frequency_PerfTime";
LPCWSTR cszTimestampSys100Ns    = L"Timestamp_Sys100NS";
LPCWSTR cszFrequencySys100Ns    = L"Frequency_Sys100NS";
LPCWSTR cszTimestampObject      = L"Timestamp_Object";
LPCWSTR cszFrequencyObject      = L"Frequency_Object";

// "well known" qualifier names
LPCWSTR cszPerfIndex            = L"PerfIndex";
LPCWSTR cszSingleton            = L"Singleton";
LPCWSTR cszCountertype          = L"countertype";
LPCWSTR cszProvider             = L"Provider";
LPCWSTR cszRegistryKey          = L"registrykey";

// other random strings
LPCWSTR cszSpace                = L" ";
LPCWSTR cszSlash                = L"/";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdhstress\errormessages.cpp ===
// #include "StdAfx.h"
#include "pdhtest.h"

SErrorMessage sErrMsg[] = 
{
	{ ((DWORD)0x00000000L), L"PDH_CSTATUS_VALID_DATA" },
	{ ((DWORD)0x00000001L), L"PDH_CSTATUS_NEW_DATA" },
	{ ((DWORD)0x800007D0L), L"PDH_CSTATUS_NO_MACHINE" },
	{ ((DWORD)0x800007D1L), L"PDH_CSTATUS_NO_INSTANCE" },
	{ ((DWORD)0x800007D2L), L"PDH_MORE_DATA" },
	{ ((DWORD)0x800007D3L), L"PDH_CSTATUS_ITEM_NOT_VALIDATED" },
	{ ((DWORD)0x800007D4L), L"PDH_RETRY" },
	{ ((DWORD)0x800007D5L), L"PDH_NO_DATA" },
	{ ((DWORD)0x800007D6L), L"PDH_CALC_NEGATIVE_DENOMINATOR" },
	{ ((DWORD)0x800007D7L), L"PDH_CALC_NEGATIVE_TIMEBASE" },
	{ ((DWORD)0x800007D8L), L"PDH_CALC_NEGATIVE_VALUE" },
	{ ((DWORD)0x800007D9L), L"PDH_DIALOG_CANCELLED" },
	{ ((DWORD)0x800007DAL), L"PDH_END_OF_LOG_FILE" },
	{ ((DWORD)0xC0000BB8L), L"PDH_CSTATUS_NO_OBJECT" },
	{ ((DWORD)0xC0000BB9L), L"PDH_CSTATUS_NO_COUNTER" },
	{ ((DWORD)0xC0000BBAL), L"PDH_CSTATUS_INVALID_DATA" },
	{ ((DWORD)0xC0000BBBL), L"PDH_MEMORY_ALLOCATION_FAILURE" },
	{ ((DWORD)0xC0000BBCL), L"PDH_INVALID_HANDLE" },
	{ ((DWORD)0xC0000BBDL), L"PDH_INVALID_ARGUMENT" },
	{ ((DWORD)0xC0000BBEL), L"PDH_FUNCTION_NOT_FOUND" },
	{ ((DWORD)0xC0000BBFL), L"PDH_CSTATUS_NO_COUNTERNAME" },
	{ ((DWORD)0xC0000BC0L), L"PDH_CSTATUS_BAD_COUNTERNAME" },
	{ ((DWORD)0xC0000BC1L), L"PDH_INVALID_BUFFER" },
	{ ((DWORD)0xC0000BC2L), L"PDH_INSUFFICIENT_BUFFER" },
	{ ((DWORD)0xC0000BC3L), L"PDH_CANNOT_CONNECT_MACHINE" },
	{ ((DWORD)0xC0000BC4L), L"PDH_INVALID_PATH" },
	{ ((DWORD)0xC0000BC5L), L"PDH_INVALID_INSTANCE" },
	{ ((DWORD)0xC0000BC6L), L"PDH_INVALID_DATA" },
	{ ((DWORD)0xC0000BC7L), L"PDH_NO_DIALOG_DATA" },
	{ ((DWORD)0xC0000BC8L), L"PDH_CANNOT_READ_NAME_STRINGS" },
	{ ((DWORD)0xC0000BC9L), L"PDH_LOG_FILE_CREATE_ERROR" },
	{ ((DWORD)0xC0000BCAL), L"PDH_LOG_FILE_OPEN_ERROR" },
	{ ((DWORD)0xC0000BCBL), L"PDH_LOG_TYPE_NOT_FOUND" },
	{ ((DWORD)0xC0000BCCL), L"PDH_NO_MORE_DATA" },
	{ ((DWORD)0xC0000BCDL), L"PDH_ENTRY_NOT_IN_LOG_FILE" },
	{ ((DWORD)0xC0000BCEL), L"PDH_DATA_SOURCE_IS_LOG_FILE" },
	{ ((DWORD)0xC0000BCFL), L"PDH_DATA_SOURCE_IS_REAL_TIME" },
	{ ((DWORD)0xC0000BD0L), L"PDH_UNABLE_READ_LOG_HEADER" },
	{ ((DWORD)0xC0000BD1L), L"PDH_FILE_NOT_FOUND" },
	{ ((DWORD)0xC0000BD2L), L"PDH_FILE_ALREADY_EXISTS" },
	{ ((DWORD)0xC0000BD3L), L"PDH_NOT_IMPLEMENTED" },
	{ ((DWORD)0xC0000BD4L), L"PDH_STRING_NOT_FOUND" },
	{ ((DWORD)0x80000BD5L), L"PDH_UNABLE_MAP_NAME_FILES" },
	{ ((DWORD)0xC0000BD6L), L"PDH_UNKNOWN_LOG_FORMAT" },
	{ ((DWORD)0xC0000BD7L), L"PDH_UNKNOWN_LOGSVC_COMMAND" },
	{ ((DWORD)0xC0000BD8L), L"PDH_LOGSVC_QUERY_NOT_FOUND" },
	{ ((DWORD)0xC0000BD9L), L"PDH_LOGSVC_NOT_OPENED" },
	{ ((DWORD)0xC0000BDAL), L"PDH_WBEM_ERROR" },
	{ ((DWORD)0xC0000BDBL), L"PDH_ACCESS_DENIED" },
	{ ((DWORD)0xC0000BDCL), L"PDH_LOG_FILE_TOO_SMALL" }
};


WCHAR * GetPdhErrMsg (DWORD dwCode)
{
	int i;
	WCHAR * pwcsRet = L"????";

	for (i = 0;i < sizeof(sErrMsg)/sizeof(SErrorMessage); i++)
	{
		if (dwCode == sErrMsg[i].dwCode)
		{
			pwcsRet = sErrMsg[i].wcsDescr;
			break;
		}
	}

	return pwcsRet;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdhstress\pdh.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PDH.H

Abstract:

    Header file for the Performance Data Helper (PDH) DLL functions.

--*/
#ifndef _PDH_H_
#define _PDH_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4201)

// system include files required for datatype and constant definitions
#include <windows.h>    // necessary for data types used in this file
#include <winperf.h>    // necessary for the Detail Level definitions

#ifdef __cplusplus
extern "C" {
#endif

typedef LONG            PDH_STATUS;

#define PDH_FUNCTION    PDH_STATUS __stdcall

// version info
#define PDH_CVERSION_WIN40  ((DWORD)(0x0400))
#define PDH_CVERSION_WIN50  ((DWORD)(0x0500))
// v1.1 revision of PDH -- basic log functions
// v1.2 of the PDH -- adds variable instance counters
// v1.3 of the PDH -- adds log service control & stubs for NT5/PDH v2 fn's
// v2.0 of the PDH -- is the NT v 5.0 B2 version
#define PDH_VERSION         ((DWORD)((PDH_CVERSION_WIN50) + 0x0003))

// define severity masks
#define IsSuccessSeverity(ErrorCode)    \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x00000000L) ? TRUE : FALSE)
#define IsInformationalSeverity(ErrorCode)    \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x40000000L) ? TRUE : FALSE)
#define IsWarningSeverity(ErrorCode)    \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x80000000L) ? TRUE : FALSE)
#define IsErrorSeverity(ErrorCode)      \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0xC0000000L) ? TRUE : FALSE)

// data type definitions

typedef HANDLE  HCOUNTER;
typedef HANDLE  HQUERY;
typedef HANDLE  HLOG;

typedef struct _PDH_RAW_COUNTER {
    DWORD       CStatus;
    FILETIME    TimeStamp;
    LONGLONG    FirstValue;
    LONGLONG    SecondValue;
    DWORD       MultiCount;
} PDH_RAW_COUNTER, *PPDH_RAW_COUNTER;

typedef struct _PDH_RAW_COUNTER_ITEM_A {
    LPSTR           szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_A, *PPDH_RAW_COUNTER_ITEM_A;

typedef struct _PDH_RAW_COUNTER_ITEM_W {
    LPWSTR          szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_W, *PPDH_RAW_COUNTER_ITEM_W;

typedef struct _PDH_FMT_COUNTERVALUE {
    DWORD    CStatus;
    union {
        LONG        longValue;
        double      doubleValue;
        LONGLONG    largeValue;
        LPCSTR      AnsiStringValue;
        LPCWSTR     WideStringValue;
    };
} PDH_FMT_COUNTERVALUE, *PPDH_FMT_COUNTERVALUE;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_A {
    LPSTR                   szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_A, *PPDH_FMT_COUNTERVALUE_ITEM_A;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_W {
    LPWSTR                  szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_W, *PPDH_FMT_COUNTERVALUE_ITEM_W;

typedef struct _PDH_STATISTICS {
    DWORD                   dwFormat;
    DWORD                   count;
    PDH_FMT_COUNTERVALUE    min;
    PDH_FMT_COUNTERVALUE    max;
    PDH_FMT_COUNTERVALUE    mean;
} PDH_STATISTICS, *PPDH_STATISTICS;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    LPSTR   szObjectName;
    LPSTR   szInstanceName;
    LPSTR   szParentInstance;
    DWORD   dwInstanceIndex;
    LPSTR   szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_A, *PPDH_COUNTER_PATH_ELEMENTS_A;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    LPWSTR  szObjectName;
    LPWSTR  szInstanceName;
    LPWSTR  szParentInstance;
    DWORD   dwInstanceIndex;
    LPWSTR  szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_W, *PPDH_COUNTER_PATH_ELEMENTS_W;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPSTR   szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_A, * PPDH_DATA_ITEM_PATH_ELEMENTS_A;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPWSTR  szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_W, * PPDH_DATA_ITEM_PATH_ELEMENTS_W;

typedef struct _PDH_COUNTER_INFO_A {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPSTR   szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_A DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_A CounterPath;
        struct {
            LPSTR   szMachineName;
            LPSTR   szObjectName;
            LPSTR   szInstanceName;
            LPSTR   szParentInstance;
            DWORD   dwInstanceIndex;
            LPSTR   szCounterName;
        };
    };
    LPSTR   szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_A, *PPDH_COUNTER_INFO_A;

typedef struct _PDH_COUNTER_INFO_W {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPWSTR  szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_W DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_W CounterPath;
        struct {
            LPWSTR   szMachineName;
            LPWSTR   szObjectName;
            LPWSTR   szInstanceName;
            LPWSTR   szParentInstance;
            DWORD    dwInstanceIndex;
            LPWSTR   szCounterName;
        };
    };
    LPWSTR  szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_W, *PPDH_COUNTER_INFO_W;

typedef struct _PDH_TIME_INFO {
    LONGLONG    StartTime;
    LONGLONG    EndTime;
    DWORD       SampleCount;
} PDH_TIME_INFO, *PPDH_TIME_INFO;

typedef struct _PDH_RAW_LOG_RECORD {
    DWORD       dwStructureSize;
    DWORD       dwRecordType;
    DWORD       dwItems;
    UCHAR       RawBytes[1];
} PDH_RAW_LOG_RECORD, *PPDH_RAW_LOG_RECORD;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_A {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPSTR   szLogFileCaption;
    LPSTR   szDefaultDir;
    LPSTR   szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPSTR   PdlCommandFilename;
            LPSTR   PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPSTR   TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_A, *PPDH_LOG_SERVICE_QUERY_INFO_A;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_W {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPWSTR  szLogFileCaption;
    LPWSTR  szDefaultDir;
    LPWSTR  szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPWSTR  PdlCommandFilename;
            LPWSTR  PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPWSTR  TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_W, *PPDH_LOG_SERVICE_QUERY_INFO_W;

//
//  Time value constants
//
#define MAX_TIME_VALUE      ((LONGLONG)0x7FFFFFFFFFFFFFFF)
#define MIN_TIME_VALUE      ((LONGLONG)0)

// function definitions

PDH_FUNCTION
PdhGetDllVersion(
    IN  LPDWORD lpdwVersion
);

//
//  Query Functions
//

PDH_FUNCTION
PdhOpenQueryW (
    IN      LPCWSTR     szDataSource,
    IN      DWORD_PTR   dwUserData,
    IN      HQUERY      *phQuery
);

PDH_FUNCTION
PdhOpenQueryA (
    IN      LPCSTR      szDataSource,
    IN      DWORD_PTR   dwUserData,
    IN      HQUERY      *phQuery
);

PDH_FUNCTION
PdhAddCounterW (
    IN      HQUERY      hQuery,
    IN      LPCWSTR     szFullCounterPath,
    IN      DWORD_PTR   dwUserData,
    IN      HCOUNTER    *phCounter
);

PDH_FUNCTION
PdhAddCounterA (
    IN      HQUERY      hQuery,
    IN      LPCSTR      szFullCounterPath,
    IN      DWORD_PTR   dwUserData,
    IN      HCOUNTER    *phCounter
);

PDH_FUNCTION
PdhRemoveCounter (
    IN      HCOUNTER    hCounter
);

PDH_FUNCTION
PdhCollectQueryData (
    IN      HQUERY      hQuery
);

PDH_FUNCTION
PdhCloseQuery (
    IN      HQUERY      hQuery
);

//
//  Counter Functions
//

PDH_FUNCTION
PdhGetFormattedCounterValue (
    IN      HCOUNTER                hCounter,
    IN      DWORD                   dwFormat,
    IN      LPDWORD                 lpdwType,
    IN      PPDH_FMT_COUNTERVALUE   pValue
);

PDH_FUNCTION
PdhGetFormattedCounterArrayA (
    IN      HCOUNTER                hCounter,
    IN      DWORD                   dwFormat,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_FMT_COUNTERVALUE_ITEM_A    ItemBuffer
);

PDH_FUNCTION
PdhGetFormattedCounterArrayW (
    IN      HCOUNTER                hCounter,
    IN      DWORD                   dwFormat,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_FMT_COUNTERVALUE_ITEM_W    ItemBuffer
);


// dwFormat flag values
//
#define PDH_FMT_RAW     ((DWORD)0x00000010)
#define PDH_FMT_ANSI    ((DWORD)0x00000020)
#define PDH_FMT_UNICODE ((DWORD)0x00000040)
#define PDH_FMT_LONG    ((DWORD)0x00000100)
#define PDH_FMT_DOUBLE  ((DWORD)0x00000200)
#define PDH_FMT_LARGE   ((DWORD)0x00000400)
#define PDH_FMT_NOSCALE ((DWORD)0x00001000)
#define PDH_FMT_1000    ((DWORD)0x00002000)
#define PDH_FMT_NODATA  ((DWORD)0x00004000)
#define PDH_FMT_NOCAP100 ((DWORD)0x00008000)

#define PERF_DETAIL_COSTLY   ((DWORD)0x00010000)
#define PERF_DETAIL_STANDARD ((DWORD)0x0000FFFF)

PDH_FUNCTION
PdhGetRawCounterValue (
    IN      HCOUNTER            hCounter,
    IN      LPDWORD             lpdwType,
    IN      PPDH_RAW_COUNTER    pValue
);

PDH_FUNCTION
PdhGetRawCounterArrayA (
    IN      HCOUNTER                hCounter,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_RAW_COUNTER_ITEM_A ItemBuffer
);

PDH_FUNCTION
PdhGetRawCounterArrayW (
    IN      HCOUNTER                hCounter,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_RAW_COUNTER_ITEM_W ItemBuffer
);

PDH_FUNCTION
PdhCalculateCounterFromRawValue (
    IN      HCOUNTER                hCounter,
    IN      DWORD                   dwFormat,
    IN      PPDH_RAW_COUNTER        rawValue1,
    IN      PPDH_RAW_COUNTER        rawValue2,
    IN      PPDH_FMT_COUNTERVALUE   fmtValue
);

PDH_FUNCTION
PdhComputeCounterStatistics (
    IN      HCOUNTER            hCounter,
    IN      DWORD               dwFormat,
    IN      DWORD               dwFirstEntry,
    IN      DWORD               dwNumEntries,
    IN      PPDH_RAW_COUNTER    lpRawValueArray,
    IN      PPDH_STATISTICS     data
);

PDH_FUNCTION
PdhGetCounterInfoW (
    IN      HCOUNTER            hCounter,
    IN      BOOLEAN             bRetrieveExplainText,
    IN      LPDWORD             pdwBufferSize,
    IN      PPDH_COUNTER_INFO_W lpBuffer
);

PDH_FUNCTION
PdhGetCounterInfoA (
    IN      HCOUNTER            hCounter,
    IN      BOOLEAN             bRetrieveExplainText,
    IN      LPDWORD             pdwBufferSize,
    IN      PPDH_COUNTER_INFO_A lpBuffer
);

#define PDH_MAX_SCALE    (7L)
#define PDH_MIN_SCALE   (-7L)

PDH_FUNCTION
PdhSetCounterScaleFactor (
    IN      HCOUNTER    hCounter,
    IN      LONG        lFactor
);
//
//   Browsing and enumeration functions
//
PDH_FUNCTION
PdhConnectMachineW (
    IN      LPCWSTR  szMachineName
);

PDH_FUNCTION
PdhConnectMachineA (
    IN      LPCSTR  szMachineName
);

PDH_FUNCTION
PdhEnumMachinesW (
    IN      LPCWSTR szDataSource,
    IN      LPWSTR  mszMachineList,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhEnumMachinesA (
    IN      LPCSTR   szDataSource,
    IN      LPSTR    mszMachineList,
    IN      LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhEnumObjectsW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPWSTR  mszObjectList,
    IN      LPDWORD pcchBufferSize,
    IN      DWORD   dwDetailLevel,
    IN      BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectsA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPSTR   mszObjectList,
    IN      LPDWORD pcchBufferSize,
    IN      DWORD   dwDetailLevel,
    IN      BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectItemsW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN      LPWSTR  mszCounterList,
    IN      LPDWORD pcchCounterListLength,
    IN      LPWSTR  mszInstanceList,
    IN      LPDWORD pcchInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags
);

PDH_FUNCTION
PdhEnumObjectItemsA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPCSTR  szObjectName,
    IN      LPSTR   mszCounterList,
    IN      LPDWORD pcchCounterListLength,
    IN      LPSTR   mszInstanceList,
    IN      LPDWORD pcchInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags
);

PDH_FUNCTION
PdhMakeCounterPathW (
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPWSTR                      szFullPathBuffer,
    IN      LPDWORD                     pcchBufferSize,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhMakeCounterPathA (
    IN      PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    IN      LPSTR                       szFullPathBuffer,
    IN      LPDWORD                     pcchBufferSize,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhParseCounterPathW (
    IN      LPCWSTR                     szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPDWORD                     pdwBufferSize,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhParseCounterPathA (
    IN      LPCSTR                      szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    IN      LPDWORD                     pdwBufferSize,
    IN      DWORD                       dwFlags
);

#define PDH_PATH_WBEM_RESULT        ((DWORD)0x00000001)
#define PDH_PATH_WBEM_INPUT         ((DWORD)0x00000002)

#define PDH_PATH_LANG_FLAGS(LangId, Flags)  ((DWORD)(((LangId & 0x0000FFFF) << 16) | (Flags & 0x0000FFFF)))

PDH_FUNCTION
PdhParseInstanceNameW (
    IN      LPCWSTR szInstanceString,
    IN      LPWSTR  szInstanceName,
    IN      LPDWORD pcchInstanceNameLength,
    IN      LPWSTR  szParentName,
    IN      LPDWORD pcchParentNameLength,
    IN      LPDWORD lpIndex
);

PDH_FUNCTION
PdhParseInstanceNameA (
    IN      LPCSTR  szInstanceString,
    IN      LPSTR   szInstanceName,
    IN      LPDWORD pcchInstanceNameLength,
    IN      LPSTR   szParentName,
    IN      LPDWORD pcchParentNameLength,
    IN      LPDWORD lpIndex
);

PDH_FUNCTION
PdhValidatePathW (
    IN      LPCWSTR szFullPathBuffer
);

PDH_FUNCTION
PdhValidatePathA (
    IN      LPCSTR  szFullPathBuffer
);

PDH_FUNCTION
PdhGetDefaultPerfObjectW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPWSTR  szDefaultObjectName,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPSTR   szDefaultObjectName,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN      LPWSTR  szDefaultCounterName,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPCSTR  szObjectName,
    IN      LPSTR   szDefaultCounterName,
    IN      LPDWORD pcchBufferSize
);

typedef PDH_STATUS (__stdcall *CounterPathCallBack)(DWORD_PTR);

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4214 )  // Disable warning messages
typedef struct _BrowseDlgConfig_W {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bReserved:23;

    HWND                hWndOwner;
    LPWSTR              szDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_W, *PPDH_BROWSE_DLG_CONFIG_W;

typedef struct _BrowseDlgConfig_A {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bReserved:23;

    HWND                hWndOwner;
    LPSTR               szDataSource;
    LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_A, *PPDH_BROWSE_DLG_CONFIG_A;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4214 )
#endif

PDH_FUNCTION
PdhBrowseCountersW (
    IN      PPDH_BROWSE_DLG_CONFIG_W    pBrowseDlgData
);

PDH_FUNCTION
PdhBrowseCountersA (
    IN      PPDH_BROWSE_DLG_CONFIG_A    pBrowseDlgData
);

PDH_FUNCTION
PdhExpandCounterPathW (
    IN      LPCWSTR     szWildCardPath,
    IN      LPWSTR      mszExpandedPathList,
    IN      LPDWORD     pcchPathListLength
);

PDH_FUNCTION
PdhExpandCounterPathA (
    IN      LPCSTR      szWildCardPath,
    IN      LPSTR       mszExpandedPathList,
    IN      LPDWORD     pcchPathListLength
);

//
//  v2.0 functions
//
PDH_FUNCTION
PdhLookupPerfNameByIndexW (
    LPCWSTR szMachineName,
    DWORD   dwNameIndex,
    LPWSTR  szNameBuffer,
    LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfNameByIndexA (
    LPCSTR  szMachineName,
    DWORD   dwNameIndex,
    LPSTR   szNameBuffer,
    LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfIndexByNameW (
    LPCWSTR szMachineName,
    LPCWSTR szNameBuffer,
    LPDWORD pdwIndex
);

PDH_FUNCTION
PdhLookupPerfIndexByNameA (
    LPCSTR  szMachineName,
    LPCSTR  szNameBuffer,
    LPDWORD pdwIndex
);

#define     PDH_NOEXPANDCOUNTERS    1
#define     PDH_NOEXPANDINSTANCES   2

PDH_FUNCTION
PdhExpandWildCardPathA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szWildCardPath,
    IN      LPSTR   mszExpandedPathList,
    IN      LPDWORD pcchPathListLength,
    IN      DWORD   dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathW (
    IN      LPCWSTR  szDataSource,
    IN      LPCWSTR  szWildCardPath,
    IN      LPWSTR  mszExpandedPathList,
    IN      LPDWORD pcchPathListLength,
    IN      DWORD   dwFlags
);

//
//   Logging Functions
//

#define PDH_LOG_READ_ACCESS     ((DWORD)0x00010000)
#define PDH_LOG_WRITE_ACCESS    ((DWORD)0x00020000)
#define PDH_LOG_UPDATE_ACCESS   ((DWORD)0x00040000)
#define PDH_LOG_ACCESS_MASK     ((DWORD)0x000F0000)

#define PDH_LOG_CREATE_NEW      ((DWORD)0x00000001)
#define PDH_LOG_CREATE_ALWAYS   ((DWORD)0x00000002)
#define PDH_LOG_OPEN_ALWAYS     ((DWORD)0x00000003)
#define PDH_LOG_OPEN_EXISTING   ((DWORD)0x00000004)
#define PDH_LOG_CREATE_MASK     ((DWORD)0x0000000F)

#define PDH_LOG_OPT_USER_STRING ((DWORD)0x01000000)
#define PDH_LOG_OPT_CIRCULAR    ((DWORD)0x02000000)
#define PDH_LOG_OPT_MAX_IS_BYTES ((DWORD)0x04000000)
#define PDH_LOG_OPT_MASK        ((DWORD)0x0F000000)

#define PDH_LOG_TYPE_UNDEFINED      0
#define PDH_LOG_TYPE_CSV            1
#define PDH_LOG_TYPE_TSV            2
#define PDH_LOG_TYPE_BINARY         3
#define PDH_LOG_TYPE_TRACE_KERNEL   4
#define PDH_LOG_TYPE_TRACE_GENERIC  5
#define PDH_LOG_TYPE_PERFMON        6

PDH_FUNCTION
PdhOpenLogW (
    IN      LPCWSTR szLogFileName,
    IN      DWORD   dwAccessFlags,
    IN      LPDWORD lpdwLogType,
    IN      HQUERY  hQuery,
    IN      DWORD   dwMaxSize,
    IN      LPCWSTR szUserCaption,
    IN      HLOG    *phLog
);

PDH_FUNCTION
PdhOpenLogA (
    IN      LPCSTR  szLogFileName,
    IN      DWORD   dwAccessFlags,
    IN      LPDWORD lpdwLogType,
    IN      HQUERY  hQuery,
    IN      DWORD   dwMaxSize,
    IN      LPCSTR  szUserCaption,
    IN      HLOG    *phLog
);

PDH_FUNCTION
PdhUpdateLogW (
    IN      HLOG    hLog,
    IN      LPCWSTR szUserString
);

PDH_FUNCTION
PdhUpdateLogA (
    IN      HLOG    hLog,
    IN      LPCSTR  szUserString
);

PDH_FUNCTION
PdhUpdateLogFileCatalog (
    IN      HLOG    hLog
);

PDH_FUNCTION
PdhGetLogFileSize (
    IN  HLOG        hLog,
    IN  LONGLONG    *llSize
);

PDH_FUNCTION
PdhCloseLog(
    IN  HLOG        hLog,
    IN  DWORD       dwFlags
);

#define PDH_FLAGS_CLOSE_QUERY   ((DWORD)0x00000001)
//
//  Data source selection dialog
//
#define PDH_FLAGS_FILE_BROWSER_ONLY ((DWORD)0x00000001)

PDH_FUNCTION
PdhSelectDataSourceW (
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPWSTR  szDataSource,
    IN  LPDWORD pcchBufferLength
);

PDH_FUNCTION
PdhSelectDataSourceA (
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPSTR   szDataSource,
    IN  LPDWORD pcchBufferLength
);

BOOL
PdhIsRealTimeQuery (
    IN  HQUERY  hQuery
);

PDH_FUNCTION
PdhSetQueryTimeRange (
    IN      HQUERY          hQuery,
    IN      PPDH_TIME_INFO  pInfo
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeW (
    IN      LPCWSTR         szDataSource,
    IN      LPDWORD         pdwNumEntries,
    IN      PPDH_TIME_INFO  pInfo,
    IN      LPDWORD         pdwBufferSize
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeA (
    IN      LPCSTR          szDataSource,
    IN      LPDWORD         pdwNumEntries,
    IN      PPDH_TIME_INFO  pInfo,
    IN      LPDWORD         dwBufferSize
);

PDH_FUNCTION
PdhCollectQueryDataEx (
    IN      HQUERY      hQuery,
    IN      DWORD       dwIntervalTime,
    IN      HANDLE      hNewDataEvent
);

PDH_FUNCTION
PdhFormatFromRawValue (
    IN      DWORD               dwCounterType,
    IN      DWORD               dwFormat,
    IN      LONGLONG            *pTimeBase,
    IN      PPDH_RAW_COUNTER    pRawValue1,
    IN      PPDH_RAW_COUNTER    pRawValue2,
    IN      PPDH_FMT_COUNTERVALUE   pFmtValue
);

PDH_FUNCTION
PdhGetCounterTimeBase (
    IN  HCOUNTER    hCounter,
    IN  LONGLONG    *pTimeBase
);

PDH_FUNCTION
PdhReadRawLogRecord (
    IN  HLOG                    hLog,
    IN  FILETIME                ftRecord,
    IN  PPDH_RAW_LOG_RECORD     pRawLogRecord,
    IN  LPDWORD                 pdwBufferLength
);


#define DATA_SOURCE_REGISTRY    ((DWORD)0x00000001)
#define DATA_SOURCE_LOGFILE     ((DWORD)0x00000002)
#define DATA_SOURCE_WBEM        ((DWORD)0x00000004)

PDH_FUNCTION
PdhSetDefaultRealTimeDataSource (
    IN  DWORD   dwDataSourceId
);

// flags for the log service api's
#define PDH_LOGSVC_NO_WAIT          ((DWORD)0x80000000)
#define PDH_LOGSVC_ALL_QUERIES      ((DWORD)0x00000001)
#define PDH_LOGSVC_TRACE_LOG        ((DWORD)0x00000002)

#define PDH_LOGSVC_CMD_START        ((DWORD)0x00000010)
#define PDH_LOGSVC_CMD_STOP         ((DWORD)0x00000020)

#define PDH_LOGSVC_CTRL_ADD         ((DWORD)0x00000100)
#define PDH_LOGSVC_CTRL_REMOVE      ((DWORD)0x00000200)
#define PDH_LOGSVC_CTRL_INFO        ((DWORD)0x00000400)

#define PDH_LOGSVC_STATUS_RUNNING   ((DWORD)0x00001000)
#define PDH_LOGSVC_STATUS_STOPPED   ((DWORD)0x00002000)
#define PDH_LOGSVC_STATUS_PAUSED    ((DWORD)0x00004000)
#define PDH_LOGSVC_STATUS_ERROR     ((DWORD)0x00008000)
#define PDH_LOGSVC_STATUS_PENDING   ((DWORD)0x00010000)

#define PDH_LOGSVC_NAME_UNDEFINED  ((DWORD)-1)
#define PDH_LOGSVC_NAME_MMDDHH     ((DWORD)0)
#define PDH_LOGSVC_NAME_NNNNNN     ((DWORD)1)
#define PDH_LOGSVC_NAME_YYDDD      ((DWORD)2)
#define PDH_LOGSVC_NAME_YYMM       ((DWORD)3)
#define PDH_LOGSVC_NAME_YYMMDD     ((DWORD)4)
#define PDH_LOGSVC_NAME_YYMMDDHH   ((DWORD)5)

#define PDH_LOGSVC_RENAME_UNDEFINED ((DWORD)-1)
#define PDH_LOGSVC_RENAME_HOURS    ((DWORD)0)
#define PDH_LOGSVC_RENAME_DAYS     ((DWORD)1)
#define PDH_LOGSVC_RENAME_MONTHS   ((DWORD)2)
#define PDH_LOGSVC_RENAME_KBYTES   ((DWORD)3)
#define PDH_LOGSVC_RENAME_MBYTES   ((DWORD)4)

PDH_FUNCTION
PdhLogServiceCommandA (
    IN  LPCSTR          szMachineName,
    IN  LPCSTR          szQueryName,
    IN  DWORD           dwFlags,
    IN  LPDWORD         pdwStatus
);

PDH_FUNCTION
PdhLogServiceCommandW (
    IN  LPCWSTR         szMachineName,
    IN  LPCWSTR         szQueryName,
    IN  DWORD           dwFlags,
    IN  LPDWORD         pdwStatus
);

PDH_FUNCTION
PdhLogServiceControlA (
    IN  LPCSTR          szMachineName,
    IN  LPCSTR          szQueryName,
    IN  DWORD           dwFlags,
    IN  PPDH_LOG_SERVICE_QUERY_INFO_A pInfoBuffer,
    IN  LPDWORD         pdwBufferSize
);

PDH_FUNCTION
PdhLogServiceControlW (
    IN  LPCWSTR         szMachineName,
    IN  LPCWSTR         szQueryName,
    IN  DWORD           dwFlags,
    IN  PPDH_LOG_SERVICE_QUERY_INFO_W pInfoBuffer,
    IN  LPDWORD         pdwBufferSize
);
//
//   Unicode/ANSI compatibility section
//
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif

#ifdef UNICODE
// start of UNICODE definitions
#define PdhOpenQuery                PdhOpenQueryW
#define PdhAddCounter               PdhAddCounterW
#define PdhGetCounterInfo           PdhGetCounterInfoW
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_W
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_W
#define PdhConnectMachine           PdhConnectMachineW
#define PdhEnumMachines             PdhEnumMachinesW
#define PdhEnumObjects              PdhEnumObjectsW
#define PdhEnumObjectItems          PdhEnumObjectItemsW
#define PdhMakeCounterPath          PdhMakeCounterPathW
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_W
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_W
#define PdhParseCounterPath         PdhParseCounterPathW
#define PdhParseInstanceName        PdhParseInstanceNameW
#define PdhValidatePath             PdhValidatePathW
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectW
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterW
#define PdhBrowseCounters           PdhBrowseCountersW
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_W
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_W
#define PdhExpandCounterPath        PdhExpandCounterPathW
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_W
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_W
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_W
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_W
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayW
#define PdhGetRawCounterArray       PdhGetRawCounterArrayW
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexW
#define PdhLookupIndexByPerfName    PdhLookupIndexByPerfNameW
#define PdhOpenLog                  PdhOpenLogW
#define PdhUpdateLog                PdhUpdateLogW
#define PdhSelectDataSource         PdhSelectDataSourceW
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeW
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_W
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_W
#define PdhLogServiceControl        PdhLogServiceControlW
#define PdhLogServiceQuery          PdhLogServiceQueryW
#define PdhExpandWildCardPath       PdhExpandWildCardPathW

// end of UNICODE definitions
#else
// start of ANSI definitions
#define PdhOpenQuery                PdhOpenQueryA
#define PdhAddCounter               PdhAddCounterA
#define PdhGetCounterInfo           PdhGetCounterInfoA
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_A
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_A
#define PdhConnectMachine           PdhConnectMachineA
#define PdhEnumMachines             PdhEnumMachinesA
#define PdhEnumObjects              PdhEnumObjectsA
#define PdhEnumObjectItems          PdhEnumObjectItemsA
#define PdhMakeCounterPath          PdhMakeCounterPathA
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_A
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_A
#define PdhParseCounterPath         PdhParseCounterPathA
#define PdhParseInstanceName        PdhParseInstanceNameA
#define PdhValidatePath             PdhValidatePathA
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectA
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterA
#define PdhBrowseCounters           PdhBrowseCountersA
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_A
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_A
#define PdhExpandCounterPath        PdhExpandCounterPathA
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_A
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_A
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_A
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_A
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayA
#define PdhGetRawCounterArray       PdhGetRawCounterArrayA
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexA
#define PdhLookupIndexByPerfName    PdhLookupIndexByPerfNameA
#define PdhOpenLog                  PdhOpenLogA
#define PdhUpdateLog                PdhUpdateLogA
#define PdhSelectDataSource         PdhSelectDataSourceA
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeA
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_A
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_A
#define PdhLogServiceControl        PdhLogServiceControlA
#define PdhLogServiceQuery          PdhLogServiceQueryA
#define PdhExpandWildCardPath       PdhExpandWildCardPathA

// end of ANSI definitions
#endif  // UNICODE

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4201 )
#endif


#ifdef __cplusplus
}
#endif

#endif //_PDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdhstress\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	PdhStress.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdhstress\pdhstress.cpp ===
// PdhStress.cpp : Defines the entry point for the console application.
//

#define _WIN32_DCOM	

#define WIN32_LEAN_AND_MEAN 1
#include <stdio.h>
#include <windows.h>
#include <winperf.h>
#include <malloc.h>
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>
#include <pdh.h>
#include <OAIDL.H>
#include <comdef.H>
#include "stdafx.h"
#include "Stuff.h"
#include "pdhtest.h"

CRITICAL_SECTION g_cs;

extern "C" void wmain(int argc, wchar_t *argv[])
{
	WCHAR c;
	WCHAR wcsFileName[1024] = { 0 };
	WCHAR wcsMachineName[512] = { 0 };
	bool bDontStop = TRUE;
	
	if (argc == 1)
	{
		// wprintf(L"\nUsage:\n\tflag 'l'\t Log file path and name\n\tflag 'm'\t Machine name [optional - default local machine] \n\nExample: \'pdhtest -l test.log\'\n");
		// return;

		wcscpy(wcsFileName, L"PdhStress.log");
	}

	//read all the cmdline args and set the file name params
	while (argc > 1 && ((*++argv)[0]== '-') || (*argv[0]== '/'))
	{
		--argc;
		while (c=*++argv[0])
		{
			switch (c)
			{

			case 'l':
				wcscpy(wcsFileName, (*++argv));
				--argc;
			 	break;

			case 'm':
				wcscpy(wcsMachineName, (*++argv));
				--argc;
			 	break;

			default: //usage
				wprintf(L"\nUsage:\n\tflag 'l'\t Log file path and name\n\tflag 'm'\t Machine name [optional - default local machine] \n\nExample: \'pdhtest -l test.log\'\n");
				return;
				break;
			}

			break;
		}
	}

	//Create test object
	CPdhtest *pCPdhtest = new CPdhtest((WCHAR *)_bstr_t(wcsFileName), wcsMachineName);
	InitializeCriticalSection (&g_cs);
	DWORD dwSleep = 20000;
		 
	do
	{
		pCPdhtest->Execute();
		Sleep(dwSleep);
	}
	while(bDontStop);

	DeleteCriticalSection(&g_cs);

	delete pCPdhtest;

	return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdhstress\pdhtest.h ===
#ifndef _PDHTEST_H_
#define _PDHTEST_H_

#include <pdh.h>
#include <stdio.h>
#include <stdarg.h>

#define MAX_COUNTERS 256


typedef struct PdhQueryStruct
{
	HQUERY		hQuery;
	int			iQueryCount;
	
	PdhQueryStruct() : hQuery(NULL), iQueryCount(0) {};
} SPdhQuery;

class CPdhtest
{
public:

	HRESULT Execute();	
	
	CPdhtest(WCHAR *wcsFileName, WCHAR *wcsMachineName);

	~CPdhtest();
	void GenerateCounterList(int nNumObject, WCHAR *szThisObject, SPdhQuery *pPdhQuery, HLOG *phLog);
	static DWORD WINAPI CPdhtest::StartTest(LPVOID pHold);
	int OpenLogFile(WCHAR *pwcsFileName);
	

private:

	WCHAR *m_pwcsFileName;
	WCHAR *m_pwcsMachineName;
				
};

typedef struct SErrorMessageTag
{
	DWORD	dwCode;
	WCHAR *	wcsDescr;
} SErrorMessage;

WCHAR * GetPdhErrMsg (DWORD dwCode);

void ThreadLog(DWORD errCode, WCHAR *strFmt, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdhstress\pdhtest.cpp ===
// pdhtest.cpp : Defines the entry point for the application.
//

/*
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE  1
#endif
#define tmain   wmain
#else
#define tmain   main
#endif
*/

#include "StdAfx.h"

#define _WIN32_DCOM
#include <objbase.h>
#include <windows.h>
#include <comdef.h>

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <winperf.h>
#include <malloc.h>
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>
#include <pdh.h>

// #define DWORD_PTR DWORD *
// #include "pdh.h"
#include <OAIDL.H>
#include "Stuff.h"
#include "pdhtest.h"

extern CRITICAL_SECTION g_cs;
FILE *g_fLogFile = 0;

#define BUFFER_SIZE 1024
//HQUERY		hQuery = NULL;
//HCOUNTER	hCounter[MAX_COUNTERS] = {0};
//char g_szMachine[512];


PDH_STATUS RandWrapPdhOpenQuery(_bstr_t bstrtDataSource,
			 DWORD_PTR dwUserData,
			 HQUERY * phQuery)
{
	switch (randrange(2))
	{
	case 2:
		return PdhOpenQueryW (bstrtDataSource, dwUserData, phQuery);
		break;
	default:
		return PdhOpenQueryA (bstrtDataSource, dwUserData, phQuery);
		break;
	}
};


PdhEnumObjects (_bstr_t szDataSource,    
				_bstr_t szMachineName,   
				_bstr_t & mszObjectList,    
				LPDWORD pcchBufferLength, 
				DWORD dwDetailLevel,     
				BOOL bRefresh);


// CPdhtest Constructor

CPdhtest::CPdhtest(WCHAR *wcsFileName, WCHAR *wcsMachineName):
	m_pwcsFileName (wcsFileName),
	m_pwcsMachineName (NULL)	
		
{
	
	
}

// CPdhtest Destructor

CPdhtest::~CPdhtest()
{
	

}

//**********************************************************************************
//  CQuery Member function Execute.  Query passed in from script file
//**********************************************************************************

HRESULT CPdhtest::Execute()

{
	HRESULT hr = S_OK;
	int threads = 10;
	int itimes = 3;		
	

	HANDLE hThread[300];

	DWORD d;
	DWORD lpExitCode;

	
	for(int n = 0; n < itimes; n++)
	{
	
		for(int i = 0; i < threads; i++)
		{		
			hThread[i] = CreateThread(0, 0, StartTest, (LPVOID)this, 0, &d);		
		}	

		for(i = 0; i < threads; i++)
		{
			do 
			{
				Sleep(100);
				GetExitCodeThread(hThread[i], &lpExitCode);
			} 
			while(lpExitCode == STILL_ACTIVE);
			CloseHandle(hThread[i]);
		}
	}
	
	return hr;
}

int CPdhtest::OpenLogFile(WCHAR *pwcsFileName)
{
	char szFile[2048];

	wcstombs(szFile, pwcsFileName, 12288);

    g_fLogFile = fopen(szFile, "w");

	if (g_fLogFile == NULL)
	{
		wprintf(L"---- Can't open Log file: %S - Error 0x%X\n", pwcsFileName, GetLastError());
		return 1;
	}

	return 0;
}

//***************************************************************************
//*  StartTest
//***************************************************************************

DWORD WINAPI CPdhtest::StartTest(LPVOID pHold)
{
	 
	
	CPdhtest *pThis=(CPdhtest *)pHold;

	SPdhQuery pdhQuery;
		

	PDH_STATUS pdhStat = ERROR_SUCCESS;

	WCHAR *szObjectListBuffer = NULL;
	DWORD dwObjectListSize = 0;
	WCHAR *szThisObject	= NULL;
	WCHAR *wszCounterListBuffer = NULL;
	DWORD dwCounterListSize	= 0;
	WCHAR *wszThisCounter = NULL;
	WCHAR *wszInstanceListBuffer	= NULL;
	DWORD dwInstanceListSize = 0;
	WCHAR *wszThisInstance = NULL;
	WCHAR *pBuffAllocate = NULL;
	WCHAR *pBuffDetermine = NULL;
	WCHAR *pObjectName = NULL;
	HRESULT hr = 0;
	WCHAR *g_lpwszMachineName = NULL;

	int NumObject = 0;
	int iCount = 0;
	int ObjCount = 0;

	HLOG hLog = NULL;
	DWORD dwLastErr;

	// CoInitializeEx (NULL, COINIT_MULTITHREADED);

	//open a new query
	PdhOpenQueryW(0, 0, &(pdhQuery.hQuery));

	//ask for all the performance objects on the system
	pdhStat = PdhEnumObjectsW(NULL, pThis->m_pwcsMachineName, szObjectListBuffer, 
							&dwObjectListSize, PERF_DETAIL_WIZARD, TRUE);

    if (pdhStat == ERROR_SUCCESS) 
	{
        // allocate the buffers and try the call again
        szObjectListBuffer = (WCHAR*)malloc ((dwObjectListSize * sizeof (WCHAR)));

        if (szObjectListBuffer != NULL) 
		{		
			//call the function again, To obtain number of objects returned for randomization
			pdhStat = PdhEnumObjectsW(NULL, pThis->m_pwcsMachineName, szObjectListBuffer, 
								&dwObjectListSize, PERF_DETAIL_WIZARD, FALSE);
			
            if (pdhStat == ERROR_SUCCESS) 
			{
			    // walk the returned Object list to get number of objects
                if (dwObjectListSize > 0)
					for (szThisObject = szObjectListBuffer;
                     *szThisObject != 0;
                     szThisObject += lstrlenW(szThisObject) + 1) 
					{
						ObjCount++;
					}
				
            }			
		
			if (ObjCount == 0)
			{
				dwLastErr = GetLastError();
				EnterCriticalSection(&g_cs);
				ThreadLog (dwLastErr, L"---- ERROR: No Object found [GetLastError=0x%X]!!!!!!!!",
					dwLastErr);
				//fwprintf (g_fLogFile, L"Unable to allocate buffer for Objects\n");
				LeaveCriticalSection(&g_cs);

			}
			else
			{
				int i = 0;
				WCHAR **ObjArray;
					
				ObjArray = new WCHAR *[ObjCount];				

				// walk the returned Object list
				for (szThisObject = szObjectListBuffer;
					*szThisObject != 0;
					szThisObject += lstrlenW(szThisObject) + 1) 
				{
					if(i < ObjCount)
					{
						
						ObjArray[i] = szThisObject;
						i++;
					}
				
				}

				for(int x = 0; x < ObjCount; x++)
				{
		
					WCHAR *szObject = ObjArray[randrange(ObjCount)-1];
						
					pThis->GenerateCounterList(NumObject, szObject, &pdhQuery, &hLog);
					NumObject++;
				
				} 
	             
				delete [] ObjArray;
				
			}

        } 
		else 
		{
			EnterCriticalSection(&g_cs);
			ThreadLog (GetLastError(),
					   L"---- Error 0x%X: Unable to allocate buffer for Objects", 
					   GetLastError());
			
			//fwprintf (g_fLogFile, L"Unable to allocate buffer for Objects\n");
            LeaveCriticalSection(&g_cs);
        }
		
		if (szObjectListBuffer != NULL) free (szObjectListBuffer);
		
    } 
	else
	{
		dwLastErr = GetLastError();
		EnterCriticalSection(&g_cs);
		ThreadLog (dwLastErr,
				   L"---- Failure in PdhEnumObjects - 0x%X", 
				   GetLastError());
		//fwprintf (g_fLogFile, L"Unable to determine the necessary buffer size required for Objects\n");
        LeaveCriticalSection(&g_cs);
    }

	//close the query
	pdhStat = PdhCloseQuery(pdhQuery.hQuery);
	if (pdhStat != ERROR_SUCCESS)
	{
		dwLastErr = GetLastError();
		EnterCriticalSection(&g_cs);
		ThreadLog (dwLastErr,
				   L"---- Error 0x%X (%s) [GetLastError=0x%X] closing the query", 
				   pdhStat,
				   GetPdhErrMsg(pdhStat),
				   dwLastErr );
		LeaveCriticalSection(&g_cs);
	}

	pdhQuery.iQueryCount = 0;

	// CoUninitialize();

	return 0;

}

//***************************************************************************
//*  GenerateCounterList
//***************************************************************************

void CPdhtest::GenerateCounterList(int NumObject, WCHAR *szThisObject, SPdhQuery *pPdhQuery, HLOG *phLog)
{

	WCHAR *wszCounterListBuffer = NULL;
	char *szCounterListBuffer = NULL;
    DWORD dwCounterListSize = 0;
    WCHAR *wszThisCounter = NULL;
	char *szThisCounter = NULL;
	HRESULT hr = 0;
    WCHAR *wszInstanceListBuffer = NULL;
	char *szInstanceListBuffer = NULL;
    DWORD dwInstanceListSize = 0;
	WCHAR *wszThisInstance = NULL;
	char *szThisInstance = NULL;
	int i = 0;
	WCHAR wszCounter[BUFFER_SIZE];
	char szCounter[BUFFER_SIZE];
	PDH_STATUS pdhStat = ERROR_SUCCESS;
	WCHAR *g_lpwszMachineName = NULL;
	char *g_lpszMachineName = NULL;
	HCOUNTER	hCounter[MAX_COUNTERS] = {0};
	DWORD dwLastErr;
	DWORD dwLogType;

//	szThisObject = L"Indexing Service";
	
	//now we do exactly the same for the counters
	pdhStat = PdhEnumObjectItemsW(NULL, m_pwcsMachineName, szThisObject, wszCounterListBuffer,
								&dwCounterListSize, wszInstanceListBuffer, &dwInstanceListSize,
								PERF_DETAIL_WIZARD, 0);

			
	if (pdhStat == ERROR_SUCCESS)
	{
		// allocate the buffers and try the call again
		wszCounterListBuffer = (WCHAR*)malloc ((dwCounterListSize * sizeof (WCHAR)));
		wszInstanceListBuffer = (WCHAR*)malloc ((dwInstanceListSize * sizeof (WCHAR)));

		if ((wszCounterListBuffer != NULL) && (wszInstanceListBuffer != NULL))
		{
			
			
			//second call with all the right buffer sizes
			pdhStat = PdhEnumObjectItemsW(NULL, m_pwcsMachineName, szThisObject,wszCounterListBuffer,
									&dwCounterListSize, wszInstanceListBuffer, &dwInstanceListSize,
									PERF_DETAIL_WIZARD, 0);

		
			if (pdhStat == ERROR_SUCCESS)
			{
				// take the first returned instance 
				wszThisInstance = ((dwInstanceListSize > 0) && (wszInstanceListBuffer)) ?  
							wszInstanceListBuffer : L"";

				//create the counter string and add it to the query
				i = 0;
				if (dwCounterListSize == 0)
				{
					EnterCriticalSection(&g_cs);
					// ThreadLog(0, L"---- WARNING : No counter found for %s",szThisObject);
					LeaveCriticalSection(&g_cs);
				}
				else for (wszThisCounter = wszCounterListBuffer; *wszThisCounter != 0;
					 wszThisCounter += lstrlenW(wszThisCounter) + 1) 
				{
					 
					if (g_lpwszMachineName != NULL) 
					{
						if (wcsicmp(wszThisInstance, L""))
						{
							swprintf(wszCounter, L"\\\\\\\\%s\\\\%s(%s)\\%s", g_lpwszMachineName, szThisObject, wszThisInstance, wszThisCounter);
						}
						else 
						{
							swprintf(wszCounter, L"\\\\\\\\%s\\\\%s\\%s", g_lpwszMachineName, szThisObject, wszThisCounter);
						}
					} 
					else
					{
						if (wcsicmp(wszThisInstance, L""))
						{
							swprintf(wszCounter, L"\\%s(%s)\\%s", szThisObject, wszThisInstance, wszThisCounter);
							EnterCriticalSection(&g_cs);
							// ThreadLog (0, L"\tCounter for:\tObject=\"%s\"",szThisObject);
							// ThreadLog (0, L"\t\t\tCounter=\"%s\"",wszThisCounter);
							// ThreadLog (0, L"\t\t\tInstance=\"%s\"",wszThisInstance);
							LeaveCriticalSection(&g_cs);
						}
						else 
						{
							swprintf(wszCounter, L"\\%s\\%s", szThisObject, wszThisCounter);
							EnterCriticalSection(&g_cs);
							// ThreadLog (0, L"\tCounter for:\tObject=\"%s\"",szThisObject);
							// ThreadLog (0, L"\t\t\tCounter=\"%s\"",wszThisCounter);
							LeaveCriticalSection(&g_cs);
						}

						pdhStat = PdhAddCounterW(pPdhQuery->hQuery, wszCounter, 0, &hCounter[i]);
	
						if (pdhStat != ERROR_SUCCESS)
						{
							dwLastErr = GetLastError();
							WCHAR wszTemp1[1024];
							WCHAR wszTemp2[1024];
							WCHAR *wszPos = wszTemp2;
							
							swprintf(wszTemp1,L"---- ERROR 0x%X (%s) [GetLastError=0x%X] adding counter %s", 
								pdhStat,
								GetPdhErrMsg(pdhStat),
								dwLastErr,
								wszCounter);

							for (int j=0;wszTemp1[j] != 0;j++)
							{
								*wszPos++ = wszTemp1[j];

								if (j && (j%75 == 0))
								{
									*wszPos++ = '\n';
									for (int k=0;k<32;k++)
										*wszPos++ = ' ';
								}
							}
							 
							*wszPos = 0;

							EnterCriticalSection(&g_cs);
							ThreadLog(pdhStat, wszTemp2); 
							LeaveCriticalSection(&g_cs);
						}
	
						// PDH_CSTATUS_BAD_COUNTERNAME The counter name path string could not be parsed or interpreted. 
						// PDH_CSTATUS_NO_COUNTER The specified counter was not found. 
						// PDH_CSTATUS_NO_COUNTERNAME An empty counter name path string was passed in. 
						// PDH_CSTATUS_NO_MACHINE A machine entry could not be created. 
						// PDH_CSTATUS_NO_OBJECT The specified object could not be found. 
						// PDH_FUNCTION_NOT_FOUND The calculation function for this counter could not be determined. 
						// PDH_INVALID_ARGUMENT One or more arguments are invalid. 
						// PDH_INVALID_HANDLE The query handle is not valid. 
						// PDH_MEMORY_ALLOCATION_FAILURE A memory buffer could not be allocated. 
	
						else
						{
							WCHAR wszTemp1[1024];
							WCHAR wszTemp2[1024];
							WCHAR *wszPos = wszTemp2;
							
							i++;						
							pPdhQuery->iQueryCount++;

							swprintf(wszTemp1,L"++++ Added counter %s (count=%d)", 
								wszCounter,
								pPdhQuery->iQueryCount); 

							for (int j=0;wszTemp1[j] != 0;j++)
							{
								*wszPos++ = wszTemp1[j];

								if (j && (j%75 == 0))
								{
									*wszPos++ = '\n';
									for (int k=0;k<22;k++)
										*wszPos++ = ' ';
								}

							}
							 
							*wszPos = 0;

							EnterCriticalSection(&g_cs);
							ThreadLog(pdhStat, wszTemp2); 
							LeaveCriticalSection(&g_cs);
						}
					
					}


				}						
						
					
				//*************************************
				//execute the query 
				//*************************************

				int success = 0;

				for (int j=0;j<(int)(randrange(200)+10);j++)
				{
					pdhStat = PdhCollectQueryData(pPdhQuery->hQuery);
					if (pdhStat == ERROR_SUCCESS)
							success++;
				}
				
				
				EnterCriticalSection(&g_cs);
				ThreadLog (success > (j*3/4) ? ERROR_SUCCESS : !ERROR_SUCCESS,
						   L"=========================================================================");
				ThreadLog (success > (j*3/4) ? ERROR_SUCCESS : !ERROR_SUCCESS,
						   L"%sCollecting data: %d succeess out of %d (%.2f)",
						   success > (j*3/4) ? L"++++ " : L"---- ",
						   success, j, 100.0 * float(success)/float(j)); 
				ThreadLog (success > (j*3/4) ? ERROR_SUCCESS : !ERROR_SUCCESS,
						   L"=========================================================================");
				LeaveCriticalSection(&g_cs);
				
				if (pdhStat != ERROR_SUCCESS)
				{
					dwLastErr = GetLastError();
					EnterCriticalSection(&g_cs);
					ThreadLog (pdhStat,
						      L"---- ERROR 0x%X (%s) [GetLastError=0x%X] collecting data",
							  pdhStat,
							  GetPdhErrMsg(pdhStat),
							  dwLastErr); 
					LeaveCriticalSection(&g_cs);
				}
				else
				{
					WCHAR wcsLogFileName[64];
					WCHAR wcsComment[64];
					WCHAR wcsHostName[64];
					WCHAR *pwcsStr;

					wcscpy(wcsHostName,L"XXXXXX");

					pwcsStr = _wgetenv(L"COMPUTERNAME");

					if (pwcsStr) wcscpy(wcsHostName,pwcsStr);


					EnterCriticalSection(&g_cs);
					ThreadLog (ERROR_SUCCESS, L"++++ Data successfully collected"); 
					LeaveCriticalSection(&g_cs);

					if (*phLog == 0)
					{
						dwLogType = PDH_LOG_TYPE_CSV;

						swprintf (wcsLogFileName,L"\\\\wbemstress\\pdhstresslog\\Logs\\%s_%lu.log",
									wcsHostName,GetCurrentThreadId());
					
						swprintf (wcsComment,L"I am thread 0x%x !!!!!!\n",GetCurrentThreadId());
	

						//pdhStat = PdhOpenLogW(wcsLogFileName,
						//					  PDH_LOG_WRITE_ACCESS | PDH_LOG_CREATE_ALWAYS,
						//					  &dwLogType,   
						//					  pPdhQuery->hQuery,
						//					  10000,
						//					  NULL,
						//					  phLog);

						pdhStat = !ERROR_SUCCESS;
						if (pdhStat != ERROR_SUCCESS)
						{
							// dwLastErr = GetLastError();

							// EnterCriticalSection(&g_cs);
							// ThreadLog(pdhStat,
							//			L"---- ERROR 0x%X (%s) [GetLastError=0x%X]: cannot open file %s [retrying locally]",
							//			pdhStat,
							//			GetPdhErrMsg(pdhStat),
							//			dwLastErr,
							// 			wcsLogFileName);
							// 
							// LeaveCriticalSection(&g_cs);

							swprintf (wcsLogFileName,L"%s_%lu.log",	wcsHostName);

							pdhStat = PdhOpenLogW(wcsLogFileName,
											  PDH_LOG_WRITE_ACCESS | PDH_LOG_CREATE_ALWAYS,
											  &dwLogType,   
											  pPdhQuery->hQuery,
											  10000,
											  NULL,
											  phLog);

							if (pdhStat != ERROR_SUCCESS)
							{
								dwLastErr = GetLastError();
								EnterCriticalSection(&g_cs);
								ThreadLog(pdhStat,
										L"---- ERROR 0x%X (%s) [GetLastError=0x%X]: cannot open file %s",
										pdhStat,
										GetPdhErrMsg(pdhStat),
										dwLastErr,
										wcsLogFileName);
								LeaveCriticalSection(&g_cs);
							}
						}


						// PDH_INVALID_ARGUMENT == 0xC0000BBD
						// PDH_FILE_NOT_FOUND   == 0xC0000BD1L
						
					}

					if (*phLog)
					{
						int success = 0;

						for (int j=0;j<(int)(randrange(100)+5);j++)
						{
							pdhStat = PdhUpdateLogW(*phLog, wcsComment); 
							if (pdhStat == ERROR_SUCCESS)
								success++;
						}

						EnterCriticalSection(&g_cs);
						ThreadLog (success > (j*3/4) ? ERROR_SUCCESS : !ERROR_SUCCESS,
								  L"=========================================================================");
						ThreadLog (success > (j*3/4) ? ERROR_SUCCESS : !ERROR_SUCCESS,
								  L"%sCollecting data and updating log file : %d succeess out of %d (%.2f)",
								  success > (j*3/4) ? L"++++ " : L"---- ",
								  success, j, 100.0 * float(success)/float(j)); 
						ThreadLog (success > (j*3/4) ? ERROR_SUCCESS : !ERROR_SUCCESS,
								   L"=========================================================================");
						LeaveCriticalSection(&g_cs);
  
					}

		
				}

								
				//*************************************
			
				//remove the counters from query
				for (i--; i >= 0; i--) 
				{
					pdhStat = PdhRemoveCounter(hCounter[i]);
					if (pdhStat != ERROR_SUCCESS)
					{
						dwLastErr = GetLastError();
						EnterCriticalSection(&g_cs);
						ThreadLog(pdhStat,
							L"---- ERROR 0x%X (%s) [GetLastError=0x%X] deleting counter %d", 
							pdhStat, 
							GetPdhErrMsg(pdhStat),
							dwLastErr,
							i);
						LeaveCriticalSection(&g_cs);
					}
					else
					{
						pPdhQuery->iQueryCount--;

						EnterCriticalSection(&g_cs);
						ThreadLog(pdhStat,
							L"++++ Counter %d deleted (current count=%d)", 
							i, pPdhQuery->iQueryCount);
						LeaveCriticalSection(&g_cs);
					}
					
				}				
							
			}
			else
			{
				dwLastErr = GetLastError();
				EnterCriticalSection(&g_cs);
				ThreadLog(dwLastErr,
					L"---- ERROR 0x%X (%s) [GetLastError=0x%X] enumerating objects for %s", 
					pdhStat,
					GetPdhErrMsg(pdhStat),
					dwLastErr,
					szThisObject);
				LeaveCriticalSection(&g_cs);
			}

		} 
		else
		{
			dwLastErr = GetLastError();
			EnterCriticalSection(&g_cs);
			ThreadLog (dwLastErr,
				L"Unable to allocate buffer for Counters of Object [GetLastError=0x%X0]", 
				dwLastErr);
			//fwprintf (g_fLogFile, L"Unable to allocate buffer for Counters of Object %S%d\n", szThisObject, GetLastError());
			LeaveCriticalSection(&g_cs);
		}

		if (wszCounterListBuffer != NULL) free (wszCounterListBuffer);

		if (wszInstanceListBuffer != NULL) free (wszInstanceListBuffer);

	} 
	else 
	{
		dwLastErr = GetLastError();
		EnterCriticalSection(&g_cs);
		//fwprintf (g_fLogFile, L"Unable to determine necessary buffer size for Counters and Instances for object %S%d\n", szThisObject, GetLastError());		
		ThreadLog(dwLastErr,
				L"---- ERROR 0x%X (%s) [GetLastError=0x%X] querying available counters", 
				pdhStat,
				GetPdhErrMsg(pdhStat),
				dwLastErr);
		LeaveCriticalSection(&g_cs);
	}
					
	return;
}

CRITICAL_SECTION ThreadLog_cs;
bool ThreadLog_csInitialized = false;

void ThreadLog(DWORD errCode, WCHAR *strFmt, ...)
{
	static bool bFirstCall = true;
	static bool bReopen = true;
	static int callCounter = 0;

	static int iFail = 0;
	static int iSuccess = 0;
	int iPercentFail;

	struct _stat stt;

	struct tm *lctm = NULL;
	time_t tm;
	time_t latfilelogtime = NULL;
	
	static WCHAR strLocalFmt[2000]; 
	static WCHAR strLogMsg[2048];
	static WCHAR strFirstTimeLog[32];

	WCHAR * wcsPos;
	FILE * fp = NULL;

	WCHAR * logdatafile = L"PdhStress.log";

	int ret;
	va_list        valist;

	if (!ThreadLog_csInitialized)
	{
		ThreadLog_csInitialized = true;
		InitializeCriticalSection(&ThreadLog_cs);
	}


	if (errCode == ERROR_SUCCESS)
		iSuccess++;
	else
		iFail++;


	EnterCriticalSection(&ThreadLog_cs);
	
	iPercentFail = iFail  * 100 / (iFail + iSuccess);
	if ((iPercentFail >= 0) || bFirstCall)
		fp = _wfopen (logdatafile,L"a+t");

	swprintf (strLocalFmt,L"[Thr=%3X] ", GetCurrentThreadId());

	wcsPos = strLocalFmt + wcslen(strLocalFmt);
	
	wcscpy (wcsPos, L"??/??/?? ??:??:?? : ");
	time (&tm);
	lctm = localtime (&tm);
	if (lctm) 
	{
		ret = wcsftime (wcsPos,sizeof(strLocalFmt) - wcslen(strLocalFmt),L"%x %X: ",lctm);
		if (bFirstCall)
		{
			ret = wcsftime (strFirstTimeLog,sizeof(strFirstTimeLog),L"%x %X",lctm);
		}
	}
	else if (bFirstCall)
		strFirstTimeLog[0] = 0;


	if (bFirstCall || bReopen)
	{
		wprintf (strLocalFmt);
		wprintf (L"============================================================\n");
		
		wprintf (strLocalFmt);
		wprintf (L"New log file opened (PID=%lu)\n",GetCurrentProcessId());
		wprintf (strLocalFmt);
		wprintf (L"This process first log @ %s\n",strFirstTimeLog); 
		if (fp)
		{
			fwprintf (fp, strLocalFmt);
			fwprintf (fp, L"============================================================\n");
		
			fwprintf (fp, strLocalFmt);
			fwprintf (fp, L"New log file opened (PID=%lu)\n",GetCurrentProcessId());
			fwprintf (fp, strLocalFmt);
			fwprintf (fp, L"This process first log @ %s\n",strFirstTimeLog); 
		}
	}
	
	wcsncat (strLocalFmt, strFmt, sizeof(strLocalFmt) - wcslen(strLocalFmt) - 1);
	va_start(valist,strFmt);
	_vsnwprintf (strLogMsg, sizeof(strLogMsg) - 1, strLocalFmt, valist);
	va_end(valist);
	
	wprintf (L"{fails=%2d%%} %s\n", iPercentFail, strLogMsg);

	bFirstCall = false;
	bReopen = false;

	if ((fp) && (errCode != ERROR_SUCCESS))
	{
		fwprintf (fp,L"{fails=%2d%%} %s\n", iPercentFail, strLogMsg);
	}

	if (fp) 
	{
		fclose(fp);
		
		if ((++callCounter > 10) && (_wstat(logdatafile, &stt) == 0))
		{
			callCounter = 0;
			
			if (stt.st_size > 100000)
			{
				swprintf (strLogMsg, L"%s.old", logdatafile);
				
				_wunlink (strLogMsg);
				
				_wrename (logdatafile, strLogMsg);

				bReopen = true;
			}
		}
	}



	LeaveCriticalSection (&ThreadLog_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdhstress\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__D67445F8_3B92_4D93_85C4_44339E3A7E04__INCLUDED_)
#define AFX_STDAFX_H__D67445F8_3B92_4D93_85C4_44339E3A7E04__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D67445F8_3B92_4D93_85C4_44339E3A7E04__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\brwsctrs.cpp ===
// brwsctrs.cpp : implementation file
//

#include "stdafx.h"
#include "DPH_TEST.h"
#include "brwsctrs.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBrowseCountersDlg dialog


CBrowseCountersDlg::CBrowseCountersDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CBrowseCountersDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CBrowseCountersDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CBrowseCountersDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBrowseCountersDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBrowseCountersDlg, CDialog)
	//{{AFX_MSG_MAP(CBrowseCountersDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CBrowseCountersDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\browsctr.cpp ===
// browsctr.cpp : implementation file
//

#include "stdafx.h"
#include "DPH_TEST.h"
#include "browsctr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBrowsCountersDlg dialog


CBrowsCountersDlg::CBrowsCountersDlg(CWnd* pParent /*=NULL*/,
	UINT nTemplate 	/* = IDD_BROWSE_COUNTERS_DLG_EXT */)
	: CDialog(nTemplate, pParent)
{
	//{{AFX_DATA_INIT(CBrowsCountersDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// initialize the private/public variables here
	wpLastMachineSel = 0;

	cpeLastSelection.szMachineName = &cpeMachineName[0];
	memset (cpeMachineName, 0, sizeof(cpeMachineName));

	cpeLastSelection.szObjectName = &cpeObjectName[0];
	memset (cpeObjectName, 0, sizeof(cpeObjectName));

	cpeLastSelection.szInstanceName = &cpeInstanceName[0];
	memset (cpeInstanceName, 0, sizeof(cpeInstanceName));

	cpeLastSelection.szParentInstance = &cpeParentInstance[0];
	memset (cpeParentInstance, 0, sizeof(cpeParentInstance));

	cpeLastSelection.dwInstanceIndex = (DWORD)-1;

	cpeLastSelection.szCounterName = &cpeCounterName[0];
	memset (cpeCounterName, 0, sizeof(cpeCounterName));

	memset (cpeLastPath, 0, sizeof(cpeLastPath));

	bShowIndex = FALSE;

	bSelectMultipleCounters = FALSE;
	bAddMultipleCounters = TRUE;
	bIncludeMachineInPath = FALSE;

	szUsersPathBuffer = NULL;
	dwUsersPathBufferLength = 0;
	pCallBack = NULL;
}


void CBrowsCountersDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBrowsCountersDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBrowsCountersDlg, CDialog)
	//{{AFX_MSG_MAP(CBrowsCountersDlg)
	ON_CBN_SETFOCUS(IDC_MACHINE_COMBO, OnSetfocusMachineCombo)
	ON_CBN_KILLFOCUS(IDC_MACHINE_COMBO, OnKillfocusMachineCombo)
	ON_CBN_SELCHANGE(IDC_OBJECT_COMBO, OnSelchangeObjectCombo)
	ON_LBN_SELCHANGE(IDC_COUNTER_LIST, OnSelchangeCounterList)
	ON_LBN_SELCHANGE(IDC_INSTANCE_LIST, OnSelchangeInstanceList)
	ON_BN_CLICKED(IDC_USE_LOCAL_MACHINE, OnUseLocalMachine)
	ON_BN_CLICKED(IDC_SELECT_MACHINE, OnSelectMachine)
	ON_BN_CLICKED(IDC_ALL_INSTANCES, OnAllInstances)
	ON_BN_CLICKED(IDC_USE_INSTANCE_LIST, OnUseInstanceList)
	ON_BN_CLICKED(IDC_HELP, OnHelp)
	ON_BN_CLICKED(IDC_NETWORK, OnNetwork)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Utility Functions
#define MACHINE_LIST_SIZE	1024
#define OBJECT_LIST_SIZE	4096
#define	COUNTER_LIST_SIZE	8192
#define INSTANCE_LIST_SIZE	8192

void CBrowsCountersDlg::LoadKnownMachines ()
{
	TCHAR	mszMachineList[MACHINE_LIST_SIZE];
	LPTSTR	szThisMachine;
	DWORD	dwLength;
	PDH_STATUS	status;

	HCURSOR	hOldCursor;

	hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));

	dwLength = MACHINE_LIST_SIZE;
	status = PdhEnumConnectedMachines (
		&mszMachineList[0],
		&dwLength);

	SendDlgItemMessage(IDC_MACHINE_COMBO, CB_RESETCONTENT);

	if (status == ERROR_SUCCESS) {
		// update the combo box
		for (szThisMachine = &mszMachineList[0]; 
			*szThisMachine != 0;
			szThisMachine += lstrlen(szThisMachine)+1) {
			SendDlgItemMessage (IDC_MACHINE_COMBO, CB_ADDSTRING, 
				0, (LPARAM)szThisMachine);
		}
		SendDlgItemMessage (IDC_MACHINE_COMBO, CB_SETCURSEL);
	}		
	::SetCursor (hOldCursor);
}

void CBrowsCountersDlg::LoadMachineObjects (BOOL bRefresh)
{
	TCHAR	szMachineName[MAX_PATH];
	TCHAR	szDefaultObject[MAX_PATH];
	TCHAR	mszObjectList[OBJECT_LIST_SIZE];
	DWORD	dwLength;
	LPTSTR	szThisObject;
	HCURSOR	hOldCursor;

	hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));
	// get current machine name
	(GetDlgItem(IDC_MACHINE_COMBO))->GetWindowText(szMachineName, MAX_PATH);

	// get object list 
	dwLength = OBJECT_LIST_SIZE;
	PdhEnumObjects (szMachineName, mszObjectList, &dwLength, bRefresh);

	// load object list
	SendDlgItemMessage (IDC_OBJECT_COMBO, CB_RESETCONTENT);

	for (szThisObject = &mszObjectList[0];
		*szThisObject != 0;
		szThisObject += lstrlen(szThisObject) + 1) {
		SendDlgItemMessage (IDC_OBJECT_COMBO, CB_ADDSTRING, 
			0, (LPARAM)szThisObject);
	}

	// get default Object
	dwLength = MAX_PATH;
	PdhGetDefaultPerfObject (
		szMachineName,
		szDefaultObject,
		&dwLength);

	if (SendDlgItemMessage (IDC_OBJECT_COMBO, CB_SELECTSTRING,
		(WPARAM)-1, (LPARAM)szDefaultObject) == CB_ERR) {
			// default object not found in list so select the first one
		SendDlgItemMessage (IDC_OBJECT_COMBO, CB_SETCURSEL);
	}
	::SetCursor (hOldCursor);
}

void CBrowsCountersDlg::LoadCountersAndInstances () 
{
	TCHAR	szMachineName[MAX_PATH];
	TCHAR	szObjectName[MAX_PATH];
	TCHAR	szDefaultCounter[MAX_PATH];
	TCHAR	mszCounterList[COUNTER_LIST_SIZE];
	TCHAR 	mszInstanceList[INSTANCE_LIST_SIZE];
	TCHAR	szInstanceString[MAX_PATH];
	LPTSTR	szIndexStringPos;
	DWORD	dwCounterLen;
	DWORD	dwDefaultIndex;
	DWORD	dwCounterListLength;
	DWORD	dwInstanceListLength;
	DWORD	dwInstanceMatch;
	DWORD	dwInstanceIndex;
	LPTSTR	szThisItem;
	CWnd	*pcCounterListBox;
	CWnd	*pcInstanceListBox;
	HCURSOR	hOldCursor;

	hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));

	// get current machine & object name
	(GetDlgItem(IDC_MACHINE_COMBO))->GetWindowText(szMachineName, MAX_PATH);
	(GetDlgItem(IDC_OBJECT_COMBO))->GetWindowText(szObjectName, MAX_PATH);

	// get object list 
	dwCounterListLength = sizeof(mszCounterList) / sizeof(TCHAR);
	dwInstanceListLength = sizeof(mszInstanceList) / sizeof(TCHAR);
	
	PdhEnumObjectItems (
		szMachineName,
		szObjectName,
		mszCounterList,
		&dwCounterListLength,
		mszInstanceList,
		&dwInstanceListLength,
		0);

	//reset contents of both list boxes

	pcCounterListBox = GetDlgItem (IDC_COUNTER_LIST);
	pcInstanceListBox = GetDlgItem (IDC_INSTANCE_LIST);

	pcCounterListBox->SendMessage (LB_RESETCONTENT);
	pcInstanceListBox->SendMessage (LB_RESETCONTENT);

	// now fill 'em up
	// start with the counters
	for (szThisItem = mszCounterList;
		*szThisItem != 0;
		szThisItem += lstrlen(szThisItem) + 1) {
		pcCounterListBox->SendMessage (LB_ADDSTRING, 0, (LPARAM)szThisItem);
	}
	
	dwCounterLen = MAX_PATH;
	PdhGetDefaultPerfCounter (
		szMachineName,
		szObjectName,
		szDefaultCounter,
		&dwCounterLen);

	dwDefaultIndex = pcCounterListBox->SendMessage (LB_FINDSTRINGEXACT, 
		(WPARAM)-1, (LPARAM)szDefaultCounter);
	if (dwDefaultIndex == LB_ERR) {
		pcCounterListBox->SendMessage (LB_SETSEL, TRUE, 0);
	} else {
		pcCounterListBox->SendMessage (LB_SETSEL, TRUE, dwDefaultIndex);
		pcCounterListBox->SendMessage (LB_SETCARETINDEX, (WPARAM)dwDefaultIndex,
			MAKELPARAM(FALSE, 0));
	}

	// now the instance list
	if (dwInstanceListLength > 0) {
		pcInstanceListBox->EnableWindow(TRUE);
		GetDlgItem(IDC_ALL_INSTANCES)->EnableWindow(TRUE);
		GetDlgItem(IDC_USE_INSTANCE_LIST)->EnableWindow(TRUE);
		for (szThisItem = mszInstanceList;
			*szThisItem != 0;
			szThisItem += lstrlen(szThisItem) + 1) {
			if (bShowIndex) {
				dwInstanceIndex = 0;
				dwInstanceMatch = (DWORD)-1;
				// find the index of this instance
				lstrcpy (szInstanceString, szThisItem);
				lstrcat	(szInstanceString, TEXT("#"));
				szIndexStringPos = &szInstanceString[lstrlen(szInstanceString)];
				
				do {
					LongToString ((long)dwInstanceIndex++, szIndexStringPos, 10);
					dwInstanceMatch = (DWORD)SendDlgItemMessage (IDC_INSTANCE_LIST, 
						LB_FINDSTRINGEXACT, 
						(WPARAM)dwInstanceMatch, (LPARAM)szInstanceString);			
				} while (dwInstanceMatch != LB_ERR);
				pcInstanceListBox->SendMessage (LB_ADDSTRING, 0, (LPARAM)szInstanceString);
			} else {
				pcInstanceListBox->SendMessage (LB_ADDSTRING, 0, (LPARAM)szThisItem);
			}
		}
		if (bWildCardInstances) {
			// disable instance list
			pcInstanceListBox->EnableWindow(FALSE);
		} else {
			if (pcInstanceListBox->SendMessage (LB_GETCOUNT) != LB_ERR) {
				pcInstanceListBox->SendMessage (LB_SETSEL, TRUE, 0);
			}
		}
	} else 	{
		pcInstanceListBox->SendMessage (LB_ADDSTRING, 0, (LPARAM)TEXT("<No Instances>"));
		pcInstanceListBox->EnableWindow(FALSE);
		GetDlgItem(IDC_ALL_INSTANCES)->EnableWindow(FALSE);
		GetDlgItem(IDC_USE_INSTANCE_LIST)->EnableWindow(FALSE);
	}
	::SetCursor (hOldCursor);
}

void CBrowsCountersDlg::CompileSelectedCounters()
{
	DWORD	dwBufferRemaining;

	DWORD	dwCountCounters;
	DWORD	dwThisCounter;
	DWORD	dwCountInstances;
	DWORD	dwThisInstance;

	DWORD	dwSize1, dwSize2;

	PDH_COUNTER_PATH_ELEMENTS	lszPath;
	TCHAR	lszMachineName[MAX_PATH];
	TCHAR 	lszObjectName[MAX_PATH];
	TCHAR	lszInstanceName[MAX_PATH];
	TCHAR	lszParentInstance[MAX_PATH];
	TCHAR	lszCounterName[MAX_PATH];

	TCHAR	szWorkBuffer[MAX_PATH];
	LPTSTR	szCounterStart;

	CWnd	*cwCounterList, *cwInstanceList;

	// clear user's string
	if (szUsersPathBuffer != NULL) {
		*szUsersPathBuffer = 0;
		dwBufferRemaining = dwUsersPathBufferLength;
		szCounterStart = szUsersPathBuffer;
	} else {
	 	return; // no point in continuing if user doesn't have a buffer
	}
	
	// build base string using selected machine and object

	if (bIncludeMachineInPath) {
		lszPath.szMachineName = &lszMachineName[0];
		memset (lszMachineName, 0, sizeof(lszMachineName));
		GetDlgItemText (IDC_MACHINE_COMBO, lszMachineName, MAX_PATH);
	} else {
		lszPath.szMachineName = NULL;
	}

	lszPath.szObjectName = &lszObjectName[0];
	memset (lszObjectName, 0, sizeof(lszObjectName));
	GetDlgItemText (IDC_OBJECT_COMBO, lszObjectName, MAX_PATH);

	cwCounterList = GetDlgItem (IDC_COUNTER_LIST);
	cwInstanceList = GetDlgItem (IDC_INSTANCE_LIST);

	if (bSelectMultipleCounters) {
		if (bWildCardInstances) {
			lszPath.szInstanceName = &lszInstanceName[0];
			memset (lszInstanceName, 0, sizeof(lszInstanceName));
			lstrcpy (lszInstanceName, TEXT("*"));
			lszPath.szParentInstance = NULL;
			lszPath.dwInstanceIndex = (DWORD)-1;

			dwSize1 = sizeof (szWorkBuffer) / sizeof (TCHAR);
			PdhMakeCounterPath (&lszPath,
				szWorkBuffer,
				&dwSize1,
				0);

			if ((dwSize1 + 1) < dwBufferRemaining) {
				// then this will fit so add it to the string
				lstrcpy (szCounterStart, szWorkBuffer);
				szCounterStart += lstrlen(szWorkBuffer);
				*szCounterStart++ = 0;
			}
		} else {
			// get selected instances from list
			dwCountCounters = cwCounterList->SendMessage (LB_GETCOUNT);
			for (dwThisCounter = 0; dwThisCounter < dwCountCounters; dwThisCounter++) {
				if (cwCounterList->SendMessage (LB_GETSEL, (WPARAM)dwThisCounter)) {
					lszPath.szCounterName = &lszCounterName[0];
					memset (lszCounterName, 0, sizeof(lszCounterName));
					cwCounterList->SendMessage (LB_GETTEXT, (WPARAM)dwThisCounter, (LPARAM)lszCounterName);
						
					if (cwInstanceList->IsWindowEnabled()) {
						dwCountInstances = cwInstanceList->SendMessage (LB_GETCOUNT);
						for (dwThisInstance = 0; dwThisInstance < dwCountInstances; dwThisInstance++) {
							if (cwInstanceList->SendMessage (LB_GETSEL, (WPARAM)dwThisInstance)) {
								lszPath.szInstanceName = &lszInstanceName[0];
								memset (lszInstanceName, 0, sizeof(lszInstanceName));
								cwInstanceList->SendMessage (LB_GETTEXT, 
									(WPARAM)dwThisInstance, (LPARAM)lszInstanceName);

								lszPath.szParentInstance = &lszParentInstance[0];
								memset (lszParentInstance, 0, sizeof(lszParentInstance));

								dwSize1 = dwSize2 = MAX_PATH;
								PdhParseInstanceName (lszInstanceName,
									lszInstanceName,
									&dwSize1,
									lszParentInstance,
									&dwSize2,
									&lszPath.dwInstanceIndex);


								// parse instance name adds in the default index of one is
								// not present. so if it's not wanted, this will remove it
								if (!bShowIndex) lszPath.dwInstanceIndex = (DWORD)-1;

								if (dwSize1 > 0) {
									lszPath.szInstanceName = &lszInstanceName[0];
								} else {
									lszPath.szInstanceName = NULL;
								}
								if (dwSize2 > 0) {
									lszPath.szParentInstance = &lszParentInstance[0];
								} else {
									lszPath.szParentInstance = NULL;
								}

								dwSize1 = sizeof (szWorkBuffer) / sizeof (TCHAR);
								PdhMakeCounterPath (&lszPath,
									szWorkBuffer,
									&dwSize1,
									0);

								if ((dwSize1 + 1) < dwBufferRemaining) {
									// then this will fit so add it to the string
									lstrcpy (szCounterStart, szWorkBuffer);
									szCounterStart += lstrlen(szWorkBuffer);
									*szCounterStart++ = 0;
								}
							
							} // end if instance is selected
						} // end for each instance in list
					} else {
						// this counter has no instances so process now
						lszPath.szInstanceName = NULL;
						lszPath.szParentInstance = NULL;
						lszPath.dwInstanceIndex = (DWORD)-1;

						dwSize1 = sizeof (szWorkBuffer) / sizeof (TCHAR);
						PdhMakeCounterPath (&lszPath,
							szWorkBuffer,
							&dwSize1,
							0);

						if ((dwSize1 + 1) < dwBufferRemaining) {
							// then this will fit so add it to the string
							lstrcpy (szCounterStart, szWorkBuffer);
							szCounterStart += lstrlen(szWorkBuffer);
							*szCounterStart++ = 0;
						}
					
					} // end if counter has instances
				} // else counter is not selected
			} // end for each counter in list
		} // end if not wild card instances
		*szCounterStart++ = 0; // terminate MSZ
	} else {
		// only single selections are allowed
		// FIXFIX: add this code.
	}
}

////////////////////////////////////////////////////////////////////////////
// CBrowsCountersDlg message handlers

BOOL CBrowsCountersDlg::OnInitDialog() 
{
	HCURSOR	hOldCursor;

	hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));

	CDialog::OnInitDialog();
	
	// limit text to machine name
	(GetDlgItem(IDC_MACHINE_COMBO))->SendMessage(EM_LIMITTEXT, MAX_PATH);

	// set check boxes to the caller defined setting

	CheckRadioButton (IDC_USE_LOCAL_MACHINE, IDC_SELECT_MACHINE, 
		(bIncludeMachineInPath ? IDC_SELECT_MACHINE : IDC_USE_LOCAL_MACHINE));
	GetDlgItem(IDC_MACHINE_COMBO)->EnableWindow (
		(bIncludeMachineInPath ? TRUE : FALSE));
		
	CheckRadioButton (IDC_ALL_INSTANCES, IDC_USE_INSTANCE_LIST, 
		IDC_USE_INSTANCE_LIST);

	// set button text strings to reflect mode of dialog
	if (bAddMultipleCounters) {
		(GetDlgItem(IDOK))->SetWindowText(TEXT("Add"));
		(GetDlgItem(IDCANCEL))->SetWindowText(TEXT("Close"));
	}

	// connect to this machine
	PdhConnectMachine(NULL);	// Null is local machine

	LoadKnownMachines();	// load machine list
	LoadMachineObjects(TRUE);	// load object list
	LoadCountersAndInstances();

	wpLastMachineSel = 0;
		
	::SetCursor (hOldCursor);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CBrowsCountersDlg::OnOK() 
{
	HCURSOR	hOldCursor;

	hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));
	
	CompileSelectedCounters();
	if (pCallBack != NULL) {
		(*pCallBack)(dwArg);
	}
	if (!bAddMultipleCounters) {
		CDialog::OnOK();
	}
	::SetCursor (hOldCursor);
}

void CBrowsCountersDlg::OnCancel() 
{
	CDialog::OnCancel();
}

void CBrowsCountersDlg::OnSetfocusMachineCombo() 
{
	wpLastMachineSel = SendDlgItemMessage (IDC_MACHINE_COMBO, CB_GETCURSEL);		
}

void CBrowsCountersDlg::OnKillfocusMachineCombo() 
{
	TCHAR	szNewMachineName[MAX_PATH];
	CWnd	*pcMachineCombo;
	long	lMatchIndex;
	PDH_STATUS	status;	
	int		mbStatus;
	HCURSOR	hOldCursor;

	hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));

	pcMachineCombo = GetDlgItem(IDC_MACHINE_COMBO);

	// Get current combo box text
	
	pcMachineCombo->GetWindowText (szNewMachineName, MAX_PATH);
	
	// see if it's in the combo box already

	lMatchIndex = (long)pcMachineCombo->SendMessage (
		CB_FINDSTRING,(WPARAM)-1, (LPARAM)szNewMachineName);

	// if name is in list, then select it

	if (lMatchIndex != CB_ERR) {
		// this name is already in the list so see if it's the same as the last selected machine
		if (lstrcmpi (szNewMachineName, cpeMachineName) != 0) {
			// this is a different machine so  update the display
			pcMachineCombo->SendMessage (CB_SETCURSEL, (WPARAM)lMatchIndex);
			LoadMachineObjects (TRUE);
			LoadCountersAndInstances ();
		} 
	} else {
		// not in list so try to add it 
		status = PdhConnectMachine (szNewMachineName);
		
		if (status == ERROR_SUCCESS) {
			// if successful, add string to combo box
			lMatchIndex = pcMachineCombo->SendMessage (CB_ADDSTRING, 0, (LPARAM)szNewMachineName);
			pcMachineCombo->SendMessage (CB_SETCURSEL, (WPARAM)lMatchIndex);
			// update other fields
			LoadMachineObjects ();	// no need to update since it was just connected
			LoadCountersAndInstances ();
		} else {
			mbStatus = MessageBox (TEXT("Unable to connect to machine"), NULL,
				MB_ICONEXCLAMATION | MB_TASKMODAL | MB_OKCANCEL);
			if (mbStatus == IDCANCEL) {
				GetDlgItem(IDC_MACHINE_COMBO)->SetFocus();
			} else {
				pcMachineCombo->SendMessage (CB_SETCURSEL, wpLastMachineSel);
			}
		}
	}
	::SetCursor (hOldCursor);
}

void CBrowsCountersDlg::OnSelchangeObjectCombo() 
{
	LoadCountersAndInstances();
}

void CBrowsCountersDlg::OnSelchangeCounterList() 
{
}

void CBrowsCountersDlg::OnSelchangeInstanceList() 
{
}

void CBrowsCountersDlg::OnUseLocalMachine() 
{
	BOOL	bMode;

	bMode = !(BOOL)IsDlgButtonChecked(IDC_USE_LOCAL_MACHINE);
	GetDlgItem(IDC_MACHINE_COMBO)->EnableWindow(bMode);
	bIncludeMachineInPath = bMode;
}

void CBrowsCountersDlg::OnSelectMachine() 
{
	BOOL	bMode ;

	bMode = (BOOL)IsDlgButtonChecked(IDC_SELECT_MACHINE);		
	GetDlgItem(IDC_MACHINE_COMBO)->EnableWindow(bMode);
	bIncludeMachineInPath = bMode;
}

void CBrowsCountersDlg::OnAllInstances() 
{
	BOOL	bMode;
	CWnd	*pInstanceList;

	bMode = (BOOL)IsDlgButtonChecked(IDC_ALL_INSTANCES);
	pInstanceList = GetDlgItem(IDC_INSTANCE_LIST);
	// if "Sselect ALL" then clear list box selections and disable
	if (bMode) {
		pInstanceList->SendMessage(LB_SETSEL, FALSE, (LPARAM)-1);
	}
	pInstanceList->EnableWindow(!bMode);
	bWildCardInstances = bMode;
}

void CBrowsCountersDlg::OnUseInstanceList() 
{
	BOOL	bMode;
	CWnd	*pInstanceList;

	bMode = (BOOL)IsDlgButtonChecked(IDC_USE_INSTANCE_LIST);
	pInstanceList = GetDlgItem(IDC_INSTANCE_LIST);

	// enable list box and select 1st Instance
	pInstanceList->EnableWindow(bMode);
	if (bMode) {
		if (pInstanceList->SendMessage(LB_GETCOUNT) > 0) {
			pInstanceList->SendMessage (LB_SETSEL, TRUE, 0);
		}
	}
	bWildCardInstances = !bMode;
}

void CBrowsCountersDlg::OnHelp() 
{

}

void CBrowsCountersDlg::OnNetwork() 
{

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\browsctr.h ===
// browsctr.h : header file
//

#ifdef _UNICODE
#define 	LongToString	_ltow
#else
#define		LongToString	_ltoa
#endif

typedef long (* CounterPathCallBack)(DWORD);

/////////////////////////////////////////////////////////////////////////////
// CBrowsCountersDlg dialog

class CBrowsCountersDlg : public CDialog
{
// Construction
public:
	CBrowsCountersDlg(CWnd* pParent = NULL, 
		UINT nTemplate = IDD_BROWSE_COUNTERS_DLG_EXT);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CBrowsCountersDlg)
	enum { IDD = IDD_BROWSE_COUNTERS_DLG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowsCountersDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CBrowsCountersDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnSetfocusMachineCombo();
	afx_msg void OnKillfocusMachineCombo();
	afx_msg void OnSelchangeObjectCombo();
	afx_msg void OnSelchangeCounterList();
	afx_msg void OnSelchangeInstanceList();
	afx_msg	void OnUseLocalMachine();
	afx_msg void OnSelectMachine();
	afx_msg void OnAllInstances();
	afx_msg void OnUseInstanceList();
	afx_msg void OnHelp();
	afx_msg void OnNetwork();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	// configured by caller before calling DoModal;
	LPTSTR						szUsersPathBuffer;
	DWORD						dwUsersPathBufferLength;
	CounterPathCallBack			pCallBack;
	DWORD						dwArg;

	BOOL 	bShowIndex;
	BOOL	bSelectMultipleCounters;
	BOOL	bAddMultipleCounters;
	BOOL	bIncludeMachineInPath;
	BOOL	bWildCardInstances;

	// configured and set by the dialog procedure
	PDH_COUNTER_PATH_ELEMENTS	cpeLastSelection;
	TCHAR						cpeLastPath[MAX_PATH];

private:
	void	UpdateCurrentPath ();
	void	LoadKnownMachines ();
	void	LoadMachineObjects (BOOL bRefresh = FALSE);
	void	LoadCountersAndInstances ();
	void	CompileSelectedCounters();

	WPARAM	wpLastMachineSel;
	TCHAR	cpeMachineName[MAX_PATH];
	TCHAR 	cpeObjectName[MAX_PATH];
	TCHAR	cpeInstanceName[MAX_PATH];
	TCHAR	cpeParentInstance[MAX_PATH];
	TCHAR	cpeCounterName[MAX_PATH];
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdhstress\stuff.h ===
#ifndef __STUFF_H_
#define __STUFF_H_


#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <time.h>



DWORD randrange(DWORD);
void GetTheRealCurrentDirectory(char *szDir, int iSize);
void GetWbemDirectory(char *szDir, DWORD dwSize);
WCHAR *Clone(WCHAR *wsIn);


enum WINDOWSVER
{
	WINVER_WIN95,
	WINVER_WIN98,
	WINVER_NT351,
	WINVER_NT4,
	WINVER_NT5,
	WINVER_OTHER
};

WINDOWSVER GetWindowsVersion();

class JTSTRING {

public:
	JTSTRING(WCHAR *wsIn=NULL);
	JTSTRING(DWORD dwIn);
	JTSTRING(const JTSTRING &jts);
	~JTSTRING();
	JTSTRING& operator=(WCHAR *wsIn);
	JTSTRING& operator=(char *szIn);
	JTSTRING& operator=(DWORD dwIn);
	JTSTRING& operator+(const WCHAR *wsIn);
	JTSTRING& operator+(const char* szIn);
	JTSTRING& operator+(const DWORD dwIn);
	JTSTRING& operator!();
	JTSTRING& jsncpy(WCHAR *wsIn, int iNum);
	operator WCHAR*();
	void Clone(WCHAR **ppwsClone);

private:
	WCHAR *m_wsStr;
	int m_iLen;
	
};


class JSTRING 
{

public:
	JSTRING(char *szIn=NULL);
	JSTRING(DWORD dwIn);
	~JSTRING();
	JSTRING(const JSTRING &js);
	
	JSTRING& operator=(char *szIn);
	JSTRING& operator=(WCHAR *wsIn);
	JSTRING& operator=(DWORD dwIn);
	JSTRING& operator+(const char *szIn);
	JSTRING& operator+(const WCHAR* wsIn);
	JSTRING& operator+(const DWORD dwIn);
	JSTRING& operator!();
	JSTRING& jsncpy(char *szIn, int iNum);
	operator char*();

private:
	char *m_szStr;
	int m_iLen;
	
};


class JVARIANT
{
private:
	VARIANT m_Var;
	
	void Clear()
	{
		VariantClear(&m_Var);
	}

public:
	JVARIANT()
	{
		VariantInit(&m_Var);
	}
 	
	JVARIANT(WCHAR *wsIn)
	{
		VariantInit(&m_Var);
		Set(wsIn);
	}

	~JVARIANT()
	{
		Clear();
	}
	
	void Set(WCHAR *wsIn)
	{
		Clear();
		m_Var.vt=VT_BSTR;
		
		if (wsIn==NULL)
			m_Var.bstrVal=SysAllocString(L"");
		else
			m_Var.bstrVal=SysAllocString(wsIn);
	}
 
    VARIANT *operator &() { return &m_Var; } 

};


class CBSTR
{
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { m_pStr = SysAllocString(pSrc); }
   ~CBSTR() { if (m_pStr) SysFreeString(m_pStr); }
    operator BSTR() { return m_pStr; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\dphcidlg.cpp ===
// dphcidlg.cpp : implementation file
//
#include <tchar.h>
#include "stdafx.h"
#include "DPH_TEST.h"
#include "dphcidlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define LODWORD(x) ((DWORD)((x) & 0x00000000FFFFFFFF))
#define HIDWORD(x) ((DWORD)(((x)>>32) & 0x00000000FFFFFFFF))

/////////////////////////////////////////////////////////////////////////////
// CDphCounterInfoDlg dialog


CDphCounterInfoDlg::CDphCounterInfoDlg(CWnd* pParent /*=NULL*/, 
	HCOUNTER hCounterArg /*=NULL*/,
	HQUERY	 hQueryArg /*=NULL*/)
	: CDialog(CDphCounterInfoDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDphCounterInfoDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// save this counter's handle for updates
	hCounter = hCounterArg;
	hQuery = hQueryArg;

	// init the timer variables
	nTimerId = 0;
	bTimerRunning = FALSE;
	bGetDefinitions = TRUE;

	// clear the statistical data buffer
	memset (RawDataArray, 0, sizeof(RawDataArray));
	dwFirstIndex = 0;
	dwNextIndex = 0;
	dwItemsUsed = 0;
}


void CDphCounterInfoDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDphCounterInfoDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDphCounterInfoDlg, CDialog)
	//{{AFX_MSG_MAP(CDphCounterInfoDlg)
	ON_BN_CLICKED(IDC_GET_NEW_DATA, OnGetNewData)
	ON_BN_CLICKED(IDC_1SEC_BTN, On1secBtn)
	ON_WM_TIMER()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDphCounterInfoDlg message handlers

BOOL CDphCounterInfoDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	OnGetNewData();
	
	SetDefID (IDC_GET_NEW_DATA);

	// set button text to reflect current state
	SetDlgItemText (IDC_1SEC_BTN, TEXT("&Start Timer"));
	// clear statistics display
	SetDlgItemText (IDC_CI_DATA_POINTS, TEXT(""));
	SetDlgItemText (IDC_CI_AVERAGE_VALUE, TEXT(""));
	SetDlgItemText (IDC_CI_MIN_VALUE, TEXT(""));
	SetDlgItemText (IDC_CI_MAX_VALUE, TEXT(""));

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDphCounterInfoDlg::OnGetNewData() 
{
	PPDH_COUNTER_INFO	pciData;
	PDH_RAW_COUNTER 	RawData;
	PDH_STATUS			Status;
	DWORD				dwCounterType;
	DWORD				dwBufLen = 4096;
	LPTSTR				szTextBuffer;
	PDH_FMT_COUNTERVALUE	dfValue;
	double				dValue;
	LONGLONG			llValue;
	LONG				lValue;
	SYSTEMTIME			stTimeStamp;
	
	pciData = (PPDH_COUNTER_INFO)new char[dwBufLen];
	szTextBuffer = new TCHAR[dwBufLen];

	if ((pciData == NULL) || (szTextBuffer == NULL)) {
		Status = ERROR_OUTOFMEMORY;
	} else {
		Status = ERROR_SUCCESS;
	}

	if (Status == ERROR_SUCCESS) {

		Status = PdhCollectQueryData (hQuery);

		if (Status == PDH_NO_MORE_DATA) {
			if (bTimerRunning) {
				// stop the timer to prevent updating the display
				KillTimer (nTimerId);
				nTimerId = 0;
				bTimerRunning = FALSE;
				SetDlgItemText (IDC_1SEC_BTN, TEXT("&Start Timer"));
			}
			// disable the data buttons
			GetDlgItem(IDC_1SEC_BTN)->EnableWindow(FALSE);
			GetDlgItem(IDC_GET_NEW_DATA)->EnableWindow(FALSE);
		} else {
			// update the display values
			Status = PdhGetRawCounterValue (
				hCounter,
				&dwCounterType,
				&RawData);

			if ((Status == ERROR_SUCCESS) && bGetDefinitions) {

				Status = PdhGetCounterInfo (
					hCounter,
					TRUE,
					&dwBufLen,
					pciData);
			}

			if (Status == ERROR_SUCCESS) {
				// get formatted values
				Status = PdhGetFormattedCounterValue (
					hCounter,
					PDH_FMT_LONG,
					NULL,
					&dfValue);
				if (Status == ERROR_SUCCESS) {
					lValue = dfValue.longValue;
				} else {
			 		lValue = (LONG)-1;
				}
			}

			if (Status == ERROR_SUCCESS) {
				// get formatted values
				Status = PdhGetFormattedCounterValue (
					hCounter,
					PDH_FMT_DOUBLE,
					NULL,
					&dfValue);
				if (Status == ERROR_SUCCESS) {
					dValue = dfValue.doubleValue;
				} else {
			 		dValue = (double)-1.0;
				}
			}

			if (Status == ERROR_SUCCESS) {
				// get formatted values
				Status = PdhGetFormattedCounterValue (
					hCounter,
					PDH_FMT_LARGE,
					NULL,
					&dfValue);
				if (Status == ERROR_SUCCESS) {
					llValue = dfValue.largeValue;
				} else {
			 		llValue = (LONGLONG)-1;
				}
			}
		}
	}


	if (Status == ERROR_SUCCESS) {
		if (bGetDefinitions) {
			bGetDefinitions = FALSE; 	// only do once
			// load dialog box
			_stprintf (szTextBuffer, TEXT("%d"), pciData->dwLength);
			SetDlgItemText (IDC_CI_LENGTH, szTextBuffer);

			_stprintf (szTextBuffer, TEXT("0x%8.8x"), pciData->dwType);
			SetDlgItemText (IDC_CI_TYPE, szTextBuffer);

			_stprintf (szTextBuffer, TEXT("0x%8.8x"), pciData->CVersion);
			SetDlgItemText (IDC_CI_VERSION, szTextBuffer);

			_stprintf (szTextBuffer, TEXT("0x%8.8x"), pciData->CStatus);
			SetDlgItemText (IDC_CI_STATUS, szTextBuffer);

			_stprintf (szTextBuffer, TEXT("%d"), pciData->lScale);
			SetDlgItemText (IDC_CI_SCALE, szTextBuffer);

			_stprintf (szTextBuffer, TEXT("%d"), pciData->lDefaultScale);
			SetDlgItemText (IDC_CI_DEFAULT_SCALE, szTextBuffer);

			_stprintf (szTextBuffer, TEXT("0x%8.8x"), pciData->dwUserData);
			SetDlgItemText (IDC_CI_USER_DATA, szTextBuffer);

			SetDlgItemText (IDC_CI_MACHINE_NAME, 	pciData->szMachineName);
			SetDlgItemText (IDC_CI_OBJECT_NAME,		pciData->szObjectName);

			_stprintf (szTextBuffer, TEXT("%s:%d"), 
				pciData->szInstanceName,
				pciData->dwInstanceIndex);
			SetDlgItemText (IDC_CI_INSTANCE_NAME, szTextBuffer);

			SetDlgItemText (IDC_CI_PARENT_NAME,		pciData->szParentInstance);
			SetDlgItemText (IDC_CI_COUNTER_NAME, 	pciData->szCounterName);
			SetDlgItemText (IDC_CI_EXPLAIN_TEXT, 	pciData->szExplainText);

			SetDlgItemText (IDC_CI_FULL_NAME, pciData->szFullPath);
		}

		_stprintf (szTextBuffer, TEXT("0x%8.8x"), RawData.CStatus);
		SetDlgItemText (IDC_RV_STATUS, szTextBuffer);

		FileTimeToSystemTime ((LPFILETIME)&RawData.TimeStamp, &stTimeStamp);
		_stprintf (szTextBuffer, TEXT("%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%3.3d"),
			stTimeStamp.wMonth,
			stTimeStamp.wDay,
			stTimeStamp.wYear,
			stTimeStamp.wHour,
			stTimeStamp.wMinute,
			stTimeStamp.wSecond,
			stTimeStamp.wMilliseconds);
		SetDlgItemText (IDC_TIME_STAMP, szTextBuffer);

		_stprintf (szTextBuffer, TEXT("0x%8.8x%8.8x"), 
			HIDWORD(RawData.FirstValue), 
			LODWORD(RawData.FirstValue));
		SetDlgItemText (IDC_RV_FIRST, szTextBuffer);

		_stprintf (szTextBuffer, TEXT("0x%8.8x%8.8x"), 
			HIDWORD(RawData.SecondValue), 
			LODWORD(RawData.SecondValue));
		SetDlgItemText (IDC_RV_SECOND, szTextBuffer);

		_stprintf (szTextBuffer, TEXT("0x%8.8x"), dwCounterType);
		SetDlgItemText (IDC_RV_TYPE, szTextBuffer);

		_stprintf (szTextBuffer, TEXT("%d"), lValue);
		SetDlgItemText (IDC_FMT_LONG_VALUE, szTextBuffer);

		_stprintf (szTextBuffer, TEXT("%f"), dValue);
		SetDlgItemText (IDC_FMT_DBL_VALUE, szTextBuffer);

		_stprintf (szTextBuffer, TEXT("0x%8.8x%8.8x"), 
			HIDWORD(llValue), LODWORD(llValue));
		SetDlgItemText (IDC_FMT_LARGE_VALUE, szTextBuffer);
	} else if (Status != PDH_NO_MORE_DATA) {
		// clear fields and display error message
		// in explain text
		// if any error but the end of the log file
		szTextBuffer[0] = 0;
		SetDlgItemText (IDC_CI_LENGTH, szTextBuffer);
		SetDlgItemText (IDC_CI_TYPE, szTextBuffer);
		SetDlgItemText (IDC_CI_VERSION, szTextBuffer);
		SetDlgItemText (IDC_CI_STATUS, szTextBuffer);
		SetDlgItemText (IDC_CI_SCALE, szTextBuffer);
		SetDlgItemText (IDC_CI_USER_DATA, szTextBuffer);
		SetDlgItemText (IDC_CI_FULL_NAME, szTextBuffer);
		SetDlgItemText (IDC_CI_COUNTER_NAME, szTextBuffer);
		SetDlgItemText (IDC_RV_STATUS, szTextBuffer);
		SetDlgItemText (IDC_RV_FIRST, szTextBuffer);
		SetDlgItemText (IDC_RV_SECOND, szTextBuffer);
		SetDlgItemText (IDC_RV_TYPE, szTextBuffer);
		SetDlgItemText (IDC_FMT_LONG_VALUE, szTextBuffer);
		SetDlgItemText (IDC_FMT_DBL_VALUE, szTextBuffer);
		SetDlgItemText (IDC_FMT_LARGE_VALUE, szTextBuffer);

		_stprintf (szTextBuffer, TEXT("Unable to query counter data, Error 0x%8.8x"),
			Status);
		SetDlgItemText (IDC_CI_EXPLAIN_TEXT, szTextBuffer);
	} else {
		_stprintf (szTextBuffer, TEXT("End of Log File Reached."),
			Status);
		SetDlgItemText (IDC_CI_EXPLAIN_TEXT, szTextBuffer);
	}

	if (pciData != NULL) delete pciData;
	if (szTextBuffer != NULL) delete szTextBuffer;
}

void CDphCounterInfoDlg::On1secBtn() 
{
	if (bTimerRunning) {
		KillTimer (nTimerId);
		nTimerId = 0;
		bTimerRunning = FALSE;
		SetDlgItemText (IDC_1SEC_BTN, TEXT("&Start Timer"));
		// clear display
		SetDlgItemText (IDC_CI_DATA_POINTS, TEXT(""));
		SetDlgItemText (IDC_CI_AVERAGE_VALUE, TEXT(""));
		SetDlgItemText (IDC_CI_MIN_VALUE, TEXT(""));
		SetDlgItemText (IDC_CI_MAX_VALUE, TEXT(""));
	} else {
		nTimerId = SetTimer (ID_TIMER, 1000, NULL);
		if (nTimerId != 0) {
			bTimerRunning = TRUE;
			SetDlgItemText (IDC_1SEC_BTN, TEXT("&Stop Timer"));
		} else {
			MessageBeep (0xFFFFFFFF);	//standard beep
		}
	}
}

void CDphCounterInfoDlg::OnTimer(UINT nIDEvent) 
{
	PDH_RAW_COUNTER 	RawDataItem;
	PDH_STATUS			Status;
	DWORD				dwCounterType;
	PDH_STATISTICS		CtrStats;
	TCHAR				szValue[MAX_PATH];

	// get data
	OnGetNewData();

	Status = PdhGetRawCounterValue (
		hCounter,
		&dwCounterType,
		&RawDataItem);

	// add raw value to array

	RawDataArray[dwNextIndex] = RawDataItem;

	// get statistics on raw data
	Status = PdhComputeCounterStatistics (
		hCounter,
		PDH_FMT_DOUBLE,
		dwFirstIndex,
		++dwItemsUsed,
		RawDataArray,
		&CtrStats);

	// display in window

	if (Status == ERROR_SUCCESS) {
		_stprintf (szValue, TEXT("%d/%d"), CtrStats.count, dwItemsUsed);
		SetDlgItemText (IDC_CI_DATA_POINTS, szValue);

		_stprintf (szValue, TEXT("%f"), CtrStats.mean.doubleValue);
		SetDlgItemText (IDC_CI_AVERAGE_VALUE, szValue);

		_stprintf (szValue, TEXT("%f"), CtrStats.min.doubleValue);
		SetDlgItemText (IDC_CI_MIN_VALUE, szValue);

		_stprintf (szValue, TEXT("%f"), CtrStats.max.doubleValue);
		SetDlgItemText (IDC_CI_MAX_VALUE, szValue);
	} else {
		_stprintf (szValue, TEXT("%d"), dwItemsUsed);
		SetDlgItemText (IDC_CI_DATA_POINTS, szValue);
		// unable to compute statistics
		lstrcpy (szValue, TEXT("Error"));
		SetDlgItemText (IDC_CI_AVERAGE_VALUE, szValue);
		SetDlgItemText (IDC_CI_MIN_VALUE, szValue);
		SetDlgItemText (IDC_CI_MAX_VALUE, szValue);
	}
	
	// update pointers & indeces
	if (dwItemsUsed < RAW_DATA_ITEMS) {
		dwNextIndex = ++dwNextIndex % RAW_DATA_ITEMS;
	} else { 
		--dwItemsUsed;
		dwNextIndex = dwFirstIndex;
		dwFirstIndex = ++dwFirstIndex % RAW_DATA_ITEMS;
	}		

	CDialog::OnTimer(nIDEvent);
}

void CDphCounterInfoDlg::OnDestroy() 
{
	CDialog::OnDestroy();
	
	if (bTimerRunning) {
		KillTimer (nTimerId);
		nTimerId = 0;
		bTimerRunning = FALSE;
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdhstress\stuff.cpp ===
#include "stdafx.h"
#include "Stuff.h"


//======================
//Return a cloned string
//======================

WCHAR *Clone(WCHAR *wsIn)
{
	WCHAR *wsOut=new WCHAR[wcslen(wsIn)+1];
	wcscpy(wsOut,wsIn);

	return wsOut;
}

//=============================================================
//COM objects start with a current directory of winnt\system32.
//This sets it to the directory of the .exe
//=============================================================

void GetTheRealCurrentDirectory(char *szDir, int iSize)
{
	ZeroMemory(szDir,iSize);
	char *szIt=new char[iSize];
	char *szEnd=NULL;
	GetModuleFileName(NULL,szIt,iSize);
	szEnd=strrchr(szIt,'\\');
	strncpy(szDir,szIt,szEnd-szIt);
	delete []szIt;
}

void GetWbemDirectory(char *szDir, DWORD dwSize)
{
    long lResult;
	HKEY hCimomReg;
	
	lResult=RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\WBEM\\CIMOM", NULL, KEY_READ, &hCimomReg);
    
	if (lResult==ERROR_SUCCESS)
	{
		lResult=RegQueryValueEx(hCimomReg, "Working Directory", NULL, NULL, (unsigned char *)szDir, &dwSize);
		RegCloseKey(hCimomReg);
	}
}

WINDOWSVER GetWindowsVersion()
{
	WINDOWSVER lReturn = WINVER_OTHER;
	OSVERSIONINFO OSInfo;

	OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;
	GetVersionEx(&OSInfo);
	switch (OSInfo.dwPlatformId)
	{
		case VER_PLATFORM_WIN32_WINDOWS:
			{
				if (OSInfo.dwMajorVersion == 4 && OSInfo.dwMinorVersion == 0)
				  lReturn = WINVER_WIN95;
				else
				  lReturn = WINVER_WIN98;
				break;
					
			}
		case VER_PLATFORM_WIN32_NT:
			{
				switch (OSInfo.dwMajorVersion)
				{
					case 3:
					{
						lReturn = WINVER_NT351;
						break;
					}
					case 4:
					{
						lReturn = WINVER_NT4;
						break;
					}
					default:
						lReturn = WINVER_NT5;
				}
				break;
			}
		default:
			lReturn = WINVER_OTHER;
	
	}
    return lReturn ;

}





//==========================================================
// randrange() -- generates a random number from 1 to iRange
//==========================================================

DWORD randrange(DWORD iRange) 
{
	if (iRange==0)
		return 0;
	
    float f=((float)rand())/(RAND_MAX+1);
    
	DWORD dwRet=(((DWORD)(iRange*f))+1);

	dwRet=((dwRet+GetCurrentThreadId()) % iRange)+1;

    return dwRet;

}

// =======================================
// member-function definitions for JTSTRING
// =======================================


JTSTRING& JTSTRING::operator=(WCHAR *wsIn)
{
	if (!(&wsIn==&m_wsStr))
	{
		delete []m_wsStr;
		m_wsStr=NULL;
		m_iLen=0;
	}
	*this=*this+wsIn;
	return *this;
}

JTSTRING& JTSTRING::operator=(char *szIn)
{
	delete []m_wsStr;
	m_wsStr=NULL;
	m_iLen=0;
	*this=*this+szIn;
	return *this;
}

JTSTRING& JTSTRING::operator=(DWORD dwIn)
{

	delete []m_wsStr;
	m_wsStr=NULL;
	m_iLen=0;

	*this=*this+dwIn;
	return *this;
}


JTSTRING& JTSTRING::operator!()
{
	delete []m_wsStr;
	m_wsStr=NULL;
	m_iLen=0;
	return *this;
}

JTSTRING& JTSTRING::operator+(const WCHAR *wsIn) //NULL wsIn will crash
{
	if (wsIn)
	{
		bool bEmpty=(m_iLen==0);
		m_iLen=m_iLen+wcslen(wsIn);
		WCHAR *temp= new WCHAR[m_iLen+1];
		wcscpy(temp,(bEmpty)?L"\0":m_wsStr);
		wcscat(temp,wsIn);
		delete []m_wsStr;
		m_wsStr=temp;
	}
	return *this;
}

JTSTRING& JTSTRING::operator+(const char* szIn)
{
	if (szIn)
	{
		WCHAR *wsTemp=new WCHAR[strlen(szIn)+1];
		mbstowcs(wsTemp,szIn,strlen(szIn));
		wsTemp[strlen(szIn)]=atoi("0");
		*this=*this+wsTemp;
		delete []wsTemp;
	}
	return *this;
}

JTSTRING& JTSTRING::operator+(const DWORD dwIn)
{
	WCHAR wsHold[12];
	_itow(dwIn,wsHold,10);
	*this=*this+wsHold;
	return *this;
}


JTSTRING& JTSTRING::jsncpy(WCHAR *wsIn, int iNum)
{
	WCHAR *wsTemp=new WCHAR[iNum+1];
	wcsncpy(wsTemp,wsIn,iNum);
	wsTemp[iNum]='\0';
	*this=(!*this)+wsTemp;
	delete []wsTemp;
	return *this;
}

void JTSTRING::Clone(WCHAR **ppwsClone)
{
	*ppwsClone=new WCHAR[wcslen(m_wsStr)+1];
	wcscpy(*ppwsClone,m_wsStr);
}

JTSTRING::operator WCHAR*()
{
	return m_wsStr;
}


JTSTRING::JTSTRING(WCHAR *wsIn):
	m_iLen(0),
	m_wsStr(NULL)
{
	if(wsIn!=NULL)
	{
		*this=*this+wsIn;
	}
}

JTSTRING::JTSTRING(DWORD dwIn):
	m_iLen(0),
	m_wsStr(NULL)
{
	*this=*this+dwIn;
}


JTSTRING::~JTSTRING()
{
	delete []m_wsStr;
}

JTSTRING::JTSTRING(const JTSTRING &jts)
{
	m_wsStr=new WCHAR[wcslen(jts.m_wsStr)+1];
	wcscpy(m_wsStr,jts.m_wsStr);
	m_iLen=jts.m_iLen;
}

// ===================================================
// member-function definitions for JSTRING
// could this have been accomplished using templates??
// ===================================================


JSTRING& JSTRING::operator=(char *szIn)
{
	if (!(&szIn==&m_szStr))
	{
		delete []m_szStr;
		m_szStr=NULL;
		m_iLen=0;
	}
	*this=*this+szIn;
	return *this;
}

JSTRING& JSTRING::operator=(WCHAR *wsIn)
{
	delete []m_szStr;
	m_szStr=NULL;
	m_iLen=0;
	*this=*this+wsIn;
	return *this;
}


JSTRING& JSTRING::operator=(DWORD dwIn)
{

	delete []m_szStr;
	m_szStr=NULL;
	m_iLen=0;

	*this=*this+dwIn;
	return *this;
}


JSTRING& JSTRING::operator!()
{
	delete []m_szStr;
	m_szStr=NULL;
	m_iLen=0;
	return *this;
}

JSTRING& JSTRING::operator+(const char *szIn) //NULL wsIn will crash
{
	if(szIn)
	{
		bool bEmpty=(m_iLen==0);
		m_iLen=m_iLen+strlen(szIn);
		char *temp= new char[m_iLen+1];
		strcpy(temp,(bEmpty)?"\0":m_szStr);
		strcat(temp,szIn);
		delete []m_szStr;
		m_szStr=temp;
	}
	return *this;
}

JSTRING& JSTRING::operator+(const WCHAR* wsIn)
{
	if(wsIn)
	{
		char *szTemp=new char[wcslen(wsIn)+1];
		ZeroMemory(szTemp,wcslen(wsIn)+1);
		wcstombs(szTemp,wsIn,wcslen(wsIn));
		*this=*this+szTemp;
		delete []szTemp;
	}
	return *this;
}

JSTRING& JSTRING::operator+(const DWORD dwIn)
{
	char szHold[12];
	itoa(dwIn,szHold,10);
	*this=*this+szHold;
	return *this;
}


JSTRING& JSTRING::jsncpy(char *szIn, int iNum)
{
	char *szTemp=new char[iNum+1];
	strncpy(szTemp,szIn,iNum);
	szTemp[iNum]='\0';
	*this=*this+szTemp;
	delete []szTemp;
	return *this;
}

JSTRING::operator char*()
{
	return m_szStr;
}
 

JSTRING::JSTRING(char *szIn):
	m_iLen(0),
	m_szStr(NULL)
{
	if(szIn!=NULL)
	{
		*this=*this+szIn;
	}
}

JSTRING::JSTRING(DWORD dwIn):
	m_iLen(0),
	m_szStr(NULL)
{
	*this=*this+dwIn;
}


JSTRING::~JSTRING()
{
	delete []m_szStr;
}

JSTRING::JSTRING(const JSTRING &js)
{
	m_szStr=new char[strlen(js.m_szStr)+1];
	strcpy(m_szStr,js.m_szStr);
	m_iLen=js.m_iLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\dph_tdlg.h ===
// DPH_Tdlg.h : header file
//
#include <winperf.h>
#include <pdh.h>
#include "PdhPathTestDialog.h"

/////////////////////////////////////////////////////////////////////////////
// CDPH_TESTDlg dialog

class CDPH_TESTDlg : public CDialog
{
// Construction

public:

	CDPH_TESTDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CDPH_TESTDlg)
	enum { IDD = IDD_DPH_TEST_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDPH_TESTDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CDPH_TESTDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnAddCounter();
	virtual void OnOK();
	afx_msg void OnDestroy();
	afx_msg void OnDblclkCounterList();
	afx_msg void OnBrowse();
	afx_msg void OnRemoveBtn();
	afx_msg void OnSetfocusCounterList();
	afx_msg void OnKillfocusCounterList();
	afx_msg void OnKillfocusNewCounterName();
	afx_msg void OnSetfocusNewCounterName();
	afx_msg void OnSelectData();
	afx_msg void OnCheckPathBtn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void	SetDialogCaption (void);

public:
	LPTSTR	szCounterListBuffer;
	DWORD	dwCounterListLength;
	TCHAR	szDataSource[MAX_PATH];
	BOOL	bUseLogFile;

	HQUERY	hQuery1;
	HQUERY	hQuery2;
	HQUERY	hQuery3;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\dphcidlg.h ===
// dphcidlg.h : header file
//
#include <pdh.h>
#include <pdhmsg.h>

#define ID_TIMER	2
#define RAW_DATA_ITEMS	100

/////////////////////////////////////////////////////////////////////////////
// CDphCounterInfoDlg dialog

class CDphCounterInfoDlg : public CDialog
{
// Construction
public:
	CDphCounterInfoDlg(CWnd* pParent = NULL, 
		HCOUNTER 	hCounterArg = NULL,
		HQUERY 		hQueryArg = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDphCounterInfoDlg)
	enum { IDD = IDD_COUNTER_INFO };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDphCounterInfoDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDphCounterInfoDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnGetNewData();
	afx_msg void On1secBtn();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	HQUERY		hQuery;
	HCOUNTER	hCounter;

	UINT		nTimerId;
	BOOL		bTimerRunning;
	BOOL		bGetDefinitions;

	// statistical items
	PDH_RAW_COUNTER	RawDataArray[RAW_DATA_ITEMS];
	DWORD		dwFirstIndex;
	DWORD		dwNextIndex;
	DWORD		dwItemsUsed;
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\brwsctrs.h ===
// brwsctrs.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBrowseCountersDlg dialog

class CBrowseCountersDlg : public CDialog
{
// Construction
public:
	CBrowseCountersDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CBrowseCountersDlg)
	enum { IDD = IDD_BROWSE_COUNTERS_DLG_SIM };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowseCountersDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CBrowseCountersDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\dph_test.cpp ===
// DPH_TEST.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "DPH_TEST.h"
#include "DPH_Tdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPH_TESTApp

BEGIN_MESSAGE_MAP(CDPH_TESTApp, CWinApp)
	//{{AFX_MSG_MAP(CDPH_TESTApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPH_TESTApp construction

CDPH_TESTApp::CDPH_TESTApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDPH_TESTApp object

CDPH_TESTApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDPH_TESTApp initialization

BOOL CDPH_TESTApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

	Enable3dControls();
	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    SetPriorityClass (GetCurrentProcess(), HIGH_PRIORITY_CLASS);

	CDPH_TESTDlg dlg(NULL);
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\dph_tdlg.cpp ===
// DPH_Tdlg.cpp : implementation file
//

#include "stdafx.h"
#include "DPH_TEST.h"
#include "DPH_Tdlg.h"
#include "dphcidlg.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

void DialogCallBack(CDPH_TESTDlg *pDlg);

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg message handlers

BOOL CAboutDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	CenterWindow();
	
	// TODO: Add extra about dlg initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

/////////////////////////////////////////////////////////////////////////////
// CDPH_TESTDlg dialog

CDPH_TESTDlg::CDPH_TESTDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDPH_TESTDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDPH_TESTDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	memset (&szDataSource[0], 0, sizeof(szDataSource)); 
	bUseLogFile = FALSE;

	hQuery1 = INVALID_HANDLE_VALUE;
	hQuery2 = INVALID_HANDLE_VALUE;
	hQuery3 = INVALID_HANDLE_VALUE;
	szCounterListBuffer = NULL;
	dwCounterListLength = 0;

}

void CDPH_TESTDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPH_TESTDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDPH_TESTDlg, CDialog)
	//{{AFX_MSG_MAP(CDPH_TESTDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_ADD_COUNTER, OnAddCounter)
	ON_WM_DESTROY()
	ON_LBN_DBLCLK(IDC_COUNTER_LIST, OnDblclkCounterList)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	ON_BN_CLICKED(IDC_REMOVE_BTN, OnRemoveBtn)
	ON_LBN_SETFOCUS(IDC_COUNTER_LIST, OnSetfocusCounterList)
	ON_LBN_KILLFOCUS(IDC_COUNTER_LIST, OnKillfocusCounterList)
	ON_EN_KILLFOCUS(IDC_NEW_COUNTER_NAME, OnKillfocusNewCounterName)
	ON_EN_SETFOCUS(IDC_NEW_COUNTER_NAME, OnSetfocusNewCounterName)
	ON_BN_CLICKED(IDC_SELECT_DATA, OnSelectData)
	ON_BN_CLICKED(IDC_CHECK_PATH_BTN, OnCheckPathBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CDPH_TESTDlg::SetDialogCaption ()
{
	CString		cCaption;

	if (bUseLogFile) {
		// then append the log file to the caption
		cCaption = TEXT("DPH Test Dialog - ");
		cCaption += szDataSource;
	} else {
		cCaption = TEXT("DPH Test Dialog - Current Activity");
	}
	SetWindowText (cCaption);
}

/////////////////////////////////////////////////////////////////////////////
// CDPH_TESTDlg message handlers

BOOL CDPH_TESTDlg::OnInitDialog()
{
	PDH_STATUS	dphStatus;
	DWORD 	dwUserData = 0;
	CDialog::OnInitDialog();
	CenterWindow();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}

	// allocate the counter string buffer

	szCounterListBuffer = new TCHAR[8192];
	dwCounterListLength = 8192;
	
	// open query structure
	dphStatus =PdhOpenQuery(NULL, dwUserData, &hQuery1);	
	dphStatus =PdhOpenQuery(NULL, dwUserData, &hQuery2);	
	dphStatus =PdhOpenQuery(NULL, dwUserData, &hQuery3);
	
		
	// clear list box & edit box
	SendDlgItemMessage (IDC_COUNTER_LIST, LB_RESETCONTENT, 0, 0);
	
	SetDlgItemText (IDC_NEW_COUNTER_NAME, TEXT(""));
	SendDlgItemMessage (IDC_NEW_COUNTER_NAME, EM_LIMITTEXT, (WPARAM)MAX_PATH, 0);
	 
	SetDefID (IDC_ADD_COUNTER);
	// enable the add button
	GetDlgItem(IDC_ADD_COUNTER)->EnableWindow(TRUE);
	// disable the remove button
	GetDlgItem(IDC_REMOVE_BTN)->EnableWindow(FALSE);

	GetDlgItem(IDC_NEW_COUNTER_NAME)->SetFocus();	// set focus to edit control

	return FALSE;  // return TRUE  unless you set the focus to a control
}

void CDPH_TESTDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDPH_TESTDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDPH_TESTDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CDPH_TESTDlg::OnAddCounter() 
{
	TCHAR	NewCounterName[MAX_PATH];
	HCOUNTER	hCounter;
	LRESULT	lIndex;
	DWORD	dwSize1, dwSize2;
	PDH_STATUS	dphStatus;
	
	GetDlgItemText (IDC_NEW_COUNTER_NAME, NewCounterName, MAX_PATH);
	if (_tcsstr (NewCounterName, TEXT("*")) == NULL) {
		// then this is not a wildcard path, that has been entered
		dphStatus = PdhAddCounter (hQuery1, NewCounterName, 0, &hCounter);
		if (dphStatus == ERROR_SUCCESS) {
			// this is a valid counter so add it to the list
			lIndex = SendDlgItemMessage (IDC_COUNTER_LIST, 
				LB_INSERTSTRING, (WPARAM)-1, (LPARAM)NewCounterName);
			if (lIndex != LB_ERR) {
				// then set item data to be the counter handle
				SendDlgItemMessage (IDC_COUNTER_LIST,
					LB_SETITEMDATA, (WPARAM)lIndex, (LPARAM)hCounter);
				// clear the edit box for the next entry
				SetDlgItemText (IDC_NEW_COUNTER_NAME, TEXT(""));
			}
		} else {
			MessageBeep (MB_ICONEXCLAMATION); 
		}
	} else {
		// there's a wild card path character so expand it then enter them
		// clear the list buffer
		*(LPDWORD)szCounterListBuffer = 0;
		dwSize1 = dwSize2 = dwCounterListLength;
		PdhExpandCounterPath (NewCounterName, szCounterListBuffer, &dwSize2);
		if (dwSize2 < dwSize1) {
			// then the returned buffer fit 
			// so update the dialog
			DialogCallBack (this);
			// clear the edit box for the next entry
			SetDlgItemText (IDC_NEW_COUNTER_NAME, TEXT(""));
		} else {
			MessageBox (TEXT("There are too many wild cards in the path. Re-enter and try again."));
			GetDlgItem(IDC_NEW_COUNTER_NAME)->SetFocus();	// set focus to edit control
		}
	}
	GetDlgItem(IDC_NEW_COUNTER_NAME)->SetFocus();	// set focus to edit control
}

void CDPH_TESTDlg::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}

void CDPH_TESTDlg::OnDestroy() 
{
	if (hQuery1 != INVALID_HANDLE_VALUE) 
		PdhCloseQuery (hQuery1);

	if (hQuery2 != INVALID_HANDLE_VALUE) 
		PdhCloseQuery (hQuery2);

	if (hQuery3 != INVALID_HANDLE_VALUE) 
		PdhCloseQuery (hQuery3);

	if (szCounterListBuffer != NULL) delete (szCounterListBuffer);
	dwCounterListLength = 0;

	CDialog::OnDestroy();
}

void CDPH_TESTDlg::OnDblclkCounterList() 
{
	LONG		lIndex;
	HCOUNTER	hCounter;
	PDH_TIME_INFO  tiRange;

	lIndex = (LONG)SendDlgItemMessage (IDC_COUNTER_LIST, LB_GETCURSEL, 0, 0);
	if (lIndex != LB_ERR) {
		hCounter = (HCOUNTER)SendDlgItemMessage (IDC_COUNTER_LIST, 
			LB_GETITEMDATA, (LPARAM)lIndex, 0);
		if (hCounter != (HCOUNTER)LB_ERR) {
			{
                if (!PdhIsRealTimeQuery(hQuery1)) {
					// reset logp pointer to beginning of log file
					*(LONGLONG *)(&tiRange.StartTime) = 0;
					*(LONGLONG *)(&tiRange.EndTime) = (LONGLONG)0x7FFFFFFFFFFFFFFF;
					tiRange.SampleCount = 0;
					PdhSetQueryTimeRange (hQuery1, &tiRange);
				}
				CDphCounterInfoDlg 		CounterInfoDlg (this, hCounter, hQuery1);
				CounterInfoDlg.DoModal() ;		
			}
		} else {
			// unable to read Item Data
			MessageBeep (MB_ICONEXCLAMATION); 
		}
	} else {
		// nothing selected
		MessageBeep (MB_ICONEXCLAMATION); 
	}
}

void DialogCallBack(CDPH_TESTDlg *pDlg)
{
	// add strings in buffer to list box
	LPTSTR 		NewCounterName;
	LPTSTR 		NewCounterName2;
	HCOUNTER	hCounter;
	LRESULT		lIndex;
	LPTSTR		szExpandedPath;
	DWORD		dwSize1, dwSize2;
	PDH_STATUS	dphStatus;

	for (NewCounterName = pDlg->szCounterListBuffer;
		*NewCounterName != 0;
		NewCounterName += (lstrlen(NewCounterName) + 1)) {
		if (_tcsstr (NewCounterName, TEXT("*")) == NULL) {
			dphStatus = PdhAddCounter (pDlg->hQuery1, NewCounterName, 0, &hCounter);
			if (dphStatus == ERROR_SUCCESS) {
				ASSERT (hCounter != (HCOUNTER)0);
				// this is a valid counter so add it to the list
				lIndex = pDlg->SendDlgItemMessage (IDC_COUNTER_LIST, 
					LB_INSERTSTRING, (WPARAM)-1, (LPARAM)NewCounterName);
				if (lIndex != LB_ERR) {
					// then set item data to be the counter handle
					pDlg->SendDlgItemMessage (IDC_COUNTER_LIST,
						LB_SETITEMDATA, (WPARAM)lIndex, (LPARAM)hCounter);
				}
			} else {
				MessageBeep (MB_ICONEXCLAMATION); 
			}
		} else {
			szExpandedPath = new TCHAR[8192];
			// there's a wild card path character so expand it then enter them
			// clear the list buffer
			*(LPDWORD)szExpandedPath = 0;
			dwSize1 = dwSize2 = 8192;
			PdhExpandCounterPath (NewCounterName, szExpandedPath, &dwSize2);
			if (dwSize2 < dwSize1) {
				// then the returned buffer fit 
				// so update the dialog
				for (NewCounterName2 = szExpandedPath;
					*NewCounterName2 != 0;
					NewCounterName2 += (lstrlen(NewCounterName2) + 1)) {

					dphStatus = PdhAddCounter (pDlg->hQuery1, NewCounterName2, 0, &hCounter);
					if (dphStatus == ERROR_SUCCESS) {
						// this is a valid counter so add it to the list
						lIndex = pDlg->SendDlgItemMessage (IDC_COUNTER_LIST, 
							LB_INSERTSTRING, (WPARAM)-1, (LPARAM)NewCounterName2);
						if (lIndex != LB_ERR) {
							// then set item data to be the counter handle
							pDlg->SendDlgItemMessage (IDC_COUNTER_LIST,
								LB_SETITEMDATA, (WPARAM)lIndex, (LPARAM)hCounter);
						}
					} else {
						MessageBeep (MB_ICONEXCLAMATION); 
					}
				}
			} else {
				MessageBeep (MB_ICONEXCLAMATION); 
			}
			if (szExpandedPath != NULL) delete (szExpandedPath);
		}
	}
	// clear buffer
	memset (pDlg->szCounterListBuffer, 0, sizeof(pDlg->szCounterListBuffer));
}

void CDPH_TESTDlg::OnBrowse() 
{
	PDH_BROWSE_DLG_CONFIG	dlgConfig;

    GetDlgItemText (IDC_NEW_COUNTER_NAME, szCounterListBuffer, MAX_PATH);
	
	dlgConfig.bReserved = 0;
    dlgConfig.bIncludeInstanceIndex = 0;
    dlgConfig.bSingleCounterPerAdd = 0;
    dlgConfig.bSingleCounterPerDialog = 0;
    dlgConfig.bLocalCountersOnly = 0;
    dlgConfig.bWildCardInstances = 1;
    dlgConfig.bHideDetailBox = 0;
    dlgConfig.bInitializePath = 1;
    dlgConfig.bDisableMachineSelection = 0;
    dlgConfig.bIncludeCostlyObjects = 0;

	dlgConfig.hWndOwner = this->m_hWnd;
    dlgConfig.szReturnPathBuffer = szCounterListBuffer;
    dlgConfig.cchReturnPathLength = 8192;
    dlgConfig.pCallBack = (CounterPathCallBack)DialogCallBack;
    dlgConfig.dwDefaultDetailLevel = PERF_DETAIL_WIZARD;
    dlgConfig.dwCallBackArg = (DWORD)this;
 	dlgConfig.szDialogBoxCaption = TEXT("My Browser");
	if (bUseLogFile) {
		dlgConfig.szDataSource = szDataSource;
	} else {
		// use current activity
		dlgConfig.szDataSource = NULL;
	}

	PdhBrowseCounters (&dlgConfig);

}

void CDPH_TESTDlg::OnRemoveBtn() 
{
	int	nCurrentSelection;
	HCOUNTER	hCounter;
	int	nItemsLeft;
	
	nCurrentSelection = (int)SendDlgItemMessage (IDC_COUNTER_LIST, LB_GETCURSEL, 0, 0);
	if (nCurrentSelection != LB_ERR) {
		hCounter = (HCOUNTER)SendDlgItemMessage (IDC_COUNTER_LIST, LB_GETITEMDATA,
			(WPARAM)nCurrentSelection, 0);
		if (PdhRemoveCounter(hCounter) == ERROR_SUCCESS) {
			nItemsLeft = (int)SendDlgItemMessage (IDC_COUNTER_LIST, LB_DELETESTRING,
				(WPARAM)nCurrentSelection, 0);
			if (nItemsLeft <= nCurrentSelection) {
				nCurrentSelection = nItemsLeft -1;	// set to last item
			}
			SendDlgItemMessage (IDC_COUNTER_LIST, LB_SETCURSEL, 
				(WPARAM)nCurrentSelection, 0);
		}
	} else {
		MessageBeep	(MB_ICONEXCLAMATION);
	}
}

void CDPH_TESTDlg::OnSetfocusCounterList() 
{
	// enable the remove button if there's anything in the list
	if (SendDlgItemMessage (IDC_COUNTER_LIST, LB_GETCOUNT, 0, 0) > 0) {
		GetDlgItem(IDC_REMOVE_BTN)->EnableWindow(TRUE);
	} else {
		// disable the remove button
		GetDlgItem(IDC_REMOVE_BTN)->EnableWindow(FALSE);
	}
}

void CDPH_TESTDlg::OnKillfocusCounterList() 
{
}

void CDPH_TESTDlg::OnKillfocusNewCounterName() 
{
	// disable the add button
	GetDlgItem(IDC_ADD_COUNTER)->EnableWindow(FALSE);
}

void CDPH_TESTDlg::OnSetfocusNewCounterName() 
{
	// enable the add button
	GetDlgItem(IDC_ADD_COUNTER)->EnableWindow(TRUE);
	
}

void CDPH_TESTDlg::OnSelectData() 
{
	PDH_STATUS		dphStatus;
	DWORD			dwBuffSize = sizeof(szDataSource);
	TCHAR			szOldDataSource[MAX_PATH];
	TCHAR			szDisplayBuffer[MAX_PATH];
	PDH_TIME_INFO	dphTime;
	DWORD			dwEntries;
	DWORD			dwSize;
	SYSTEMTIME		stStart, stEnd;
	int	            nCurrentSelection;
	HCOUNTER	    hCounter;
	int	            nItemsLeft;

	lstrcpy (szOldDataSource, szDataSource);

	dphStatus = PdhSelectDataSource (
		m_hWnd, 0,
		&szDataSource[0],
		&dwBuffSize);

	if (dphStatus == ERROR_SUCCESS) {
		if (lstrcmpi (szOldDataSource, szDataSource) != 0) {
			if (*szDataSource == 0) {
				// then use current activity
				bUseLogFile = FALSE;
			} else {
				bUseLogFile = TRUE;
			}
			SetDialogCaption();

            // remove any items in the list

	        nCurrentSelection = 0;
            nItemsLeft = (int)SendDlgItemMessage (IDC_COUNTER_LIST, LB_DELETESTRING,
				        (WPARAM)nCurrentSelection, 0);
	        while (nItemsLeft > 0) {
                hCounter = (HCOUNTER)SendDlgItemMessage (IDC_COUNTER_LIST, LB_GETITEMDATA,
			        (WPARAM)nCurrentSelection, 0);
		        if (PdhRemoveCounter(hCounter) == ERROR_SUCCESS) {
			        nItemsLeft = (int)SendDlgItemMessage (IDC_COUNTER_LIST, LB_DELETESTRING,
				        (WPARAM)nCurrentSelection, 0);
			    } else {
                    MessageBox ("Error Deleting counter");
                }
            };
			dphStatus = PdhCloseQuery (hQuery1);

            //open new query
            dphStatus = PdhOpenQuery (szDataSource, 0, &hQuery1);

			if (bUseLogFile) {
				dwEntries = 0;
				dwSize = sizeof(dphTime);
				dphStatus = PdhGetDataSourceTimeRange (
					szDataSource,
					&dwEntries,
					&dphTime,
					&dwSize);
				if (dphStatus == ERROR_SUCCESS) {
					FileTimeToSystemTime ((CONST LPFILETIME)&(dphTime.StartTime), &stStart);
					FileTimeToSystemTime ((CONST LPFILETIME)&(dphTime.EndTime), &stEnd);
					_stprintf (szDisplayBuffer,
						TEXT("%s\r\nStart Time: %2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%3.3d\r\n\
EndTime: %2.2d/%2.2d/%4.4d %2.2d:%2.2d:%2.2d.%3.3d\r\nData Items: %d"),
						szDataSource,
						stStart.wMonth, stStart.wDay, stStart.wYear,
						stStart.wHour, stStart.wMinute, stStart.wSecond, 
						stStart.wMilliseconds,
						stEnd.wMonth, stEnd.wDay, stEnd.wYear,
						stEnd.wHour, stEnd.wMinute, stEnd.wSecond, 
						stEnd.wMilliseconds, dphTime.SampleCount);
				} else {
					_stprintf (szDisplayBuffer, 
						TEXT("Unable to read time range:\r\nError: 0x%8.8x"),
						dphStatus);
				}
				MessageBox (szDisplayBuffer, TEXT("Data Source Information"));
			}
		}
	} else {
		// don't change anything
	}
}

void CDPH_TESTDlg::OnCheckPathBtn() 
{
    CPdhPathTestDialog  ptDlg(this);
    int nReturn;
    
    // pre-load the dialog entries
    ptDlg.m_CounterName = "";
    ptDlg.m_FullPathString = "";
    ptDlg.m_IncludeInstanceName = TRUE;
    ptDlg.m_InstanceNameString = "";
    ptDlg.m_IncludeMachineName = TRUE;
    ptDlg.m_ObjectNameString = "";
    ptDlg.m_MachineNameString = "";
    ptDlg.m_UnicodeFunctions = FALSE;
    ptDlg.m_WbemOutput = TRUE;
    ptDlg.m_WbemInput = FALSE;

    nReturn = ptDlg.DoModal();	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\nolib.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// global data

// The following symbol used to force inclusion of this module
#if defined(_X86_) || defined(_MAC)
extern "C" { int _afxForceEXCLUDE; }
#else
extern "C" { int __afxForceEXCLUDE; }
#endif

#ifndef _MAC
// Win32 library excludes
#ifndef _AFXDLL
	#pragma comment(linker, "/disallowlib:mfc42d.lib")
	#pragma comment(linker, "/disallowlib:mfco42d.lib")
	#pragma comment(linker, "/disallowlib:mfcd42d.lib")
	#pragma comment(linker, "/disallowlib:mfcn42d.lib")
	#pragma comment(linker, "/disallowlib:mfcs42d.lib")
	#pragma comment(linker, "/disallowlib:mfc42.lib")
	#pragma comment(linker, "/disallowlib:mfcs42.lib")
	#pragma comment(linker, "/disallowlib:mfc42ud.lib")
	#pragma comment(linker, "/disallowlib:mfco42ud.lib")
	#pragma comment(linker, "/disallowlib:mfcd42ud.lib")
	#pragma comment(linker, "/disallowlib:mfcn42ud.lib")
	#pragma comment(linker, "/disallowlib:mfcs42ud.lib")
	#pragma comment(linker, "/disallowlib:mfc42u.lib")
	#pragma comment(linker, "/disallowlib:mfcs42u.lib")
	#ifndef _UNICODE
		#pragma comment(linker, "/disallowlib:uafxcwd.lib")
		#pragma comment(linker, "/disallowlib:uafxcw.lib")
		#ifdef _DEBUG
			#pragma comment(linker, "/disallowlib:nafxcw.lib")
		#else
			#pragma comment(linker, "/disallowlib:nafxcwd.lib")
		#endif
	#else
		#pragma comment(linker, "/disallowlib:nafxcwd.lib")
		#pragma comment(linker, "/disallowlib:nafxcw.lib")
		#ifdef _DEBUG
			#pragma comment(linker, "/disallowlib:uafxcw.lib")
		#else
			#pragma comment(linker, "/disallowlib:uafxcwd.lib")
		#endif
	#endif
#else
	#pragma comment(linker, "/disallowlib:nafxcwd.lib")
	#pragma comment(linker, "/disallowlib:nafxcw.lib")
	#pragma comment(linker, "/disallowlib:uafxcwd.lib")
	#pragma comment(linker, "/disallowlib:uafxcw.lib")
	#ifndef _UNICODE
		#pragma comment(linker, "/disallowlib:mfc42ud.lib")
		#pragma comment(linker, "/disallowlib:mfco42ud.lib")
		#pragma comment(linker, "/disallowlib:mfcd42ud.lib")
		#pragma comment(linker, "/disallowlib:mfcn42ud.lib")
		#pragma comment(linker, "/disallowlib:mfcs42ud.lib")
		#pragma comment(linker, "/disallowlib:mfc42u.lib")
		#pragma comment(linker, "/disallowlib:mfcs42u.lib")
		#ifdef _DEBUG
			#pragma comment(linker, "/disallowlib:mfc42.lib")
			#pragma comment(linker, "/disallowlib:mfcs42.lib")
		#else
			#pragma comment(linker, "/disallowlib:mfc42d.lib")
			#pragma comment(linker, "/disallowlib:mfco42d.lib")
			#pragma comment(linker, "/disallowlib:mfcd42d.lib")
			#pragma comment(linker, "/disallowlib:mfcn42d.lib")
			#pragma comment(linker, "/disallowlib:mfcs42d.lib")
		#endif
	#else
		#pragma comment(linker, "/disallowlib:mfc42d.lib")
		#pragma comment(linker, "/disallowlib:mfco42d.lib")
		#pragma comment(linker, "/disallowlib:mfcd42d.lib")
		#pragma comment(linker, "/disallowlib:mfcn42d.lib")
		#pragma comment(linker, "/disallowlib:mfcs42d.lib")
		#pragma comment(linker, "/disallowlib:mfc42.lib")
		#pragma comment(linker, "/disallowlib:mfcs42.lib")
		#ifdef _DEBUG
			#pragma comment(linker, "/disallowlib:mfc42u.lib")
			#pragma comment(linker, "/disallowlib:mfcs42u.lib")
		#else
			#pragma comment(linker, "/disallowlib:mfc42ud.lib")
			#pragma comment(linker, "/disallowlib:mfco42ud.lib")
			#pragma comment(linker, "/disallowlib:mfcd42ud.lib")
			#pragma comment(linker, "/disallowlib:mfcn42ud.lib")
			#pragma comment(linker, "/disallowlib:mfcs42ud.lib")
		#endif
	#endif
#endif
#else
// Mac68K library excludes
#ifdef _68K_
	#pragma comment(linker, "/disallowlib:libc.lib /disallowlib:sane.lib")
	#pragma comment(linker, "/nodefaultlib:libcs.lib /nodefaultlib:sanes.lib")
	#ifdef _DEBUG
		#pragma comment(linker, "/disallowlib:nafxcm.lib")
		#pragma comment(linker, "/nodefaultlib:swap.lib")
	#else
		#pragma comment(linker, "/disallowlib:nafxcmd.lib")
	#endif
#endif
// MacPPC library excludes
#ifdef _MPPC_
	#ifndef _AFXDLL
		#pragma comment(linker, "/disallowlib:mfc42pd.lib")
		#pragma comment(linker, "/disallowlib:mfco42pd.lib")
		#pragma comment(linker, "/disallowlib:mfcd42pd.lib")
		#pragma comment(linker, "/disallowlib:mfcn42pd.lib")
		#pragma comment(linker, "/disallowlib:mfcs42pd.lib")
		#pragma comment(linker, "/disallowlib:mfc42p.lib")
		#pragma comment(linker, "/disallowlib:mfco42p.lib")
		#pragma comment(linker, "/disallowlib:mfcd42p.lib")
		#pragma comment(linker, "/disallowlib:mfcn42p.lib")
		#pragma comment(linker, "/disallowlib:mfcs42p.lib")
		#ifdef _DEBUG
			#pragma comment(linker, "/disallowlib:nafxcp.lib")
		#else
			#pragma comment(linker, "/disallowlib:nafxcpd.lib")
		#endif
	#else
		#pragma comment(linker, "/disallowlib:nafxcpd.lib")
		#pragma comment(linker, "/disallowlib:nafxcp.lib")
		#ifdef _DEBUG
			#pragma comment(linker, "/disallowlib:mfc42p.lib")
			#pragma comment(linker, "/disallowlib:mfco42p.lib")
			#pragma comment(linker, "/disallowlib:mfcd42p.lib")
			#pragma comment(linker, "/disallowlib:mfcn42p.lib")
			#pragma comment(linker, "/disallowlib:mfcs42p.lib")
		#else
			#pragma comment(linker, "/disallowlib:mfc42pd.lib")
			#pragma comment(linker, "/disallowlib:mfco42pd.lib")
			#pragma comment(linker, "/disallowlib:mfcd42pd.lib")
			#pragma comment(linker, "/disallowlib:mfcn42pd.lib")
			#pragma comment(linker, "/disallowlib:mfcs42pd.lib")
		#endif
	#endif
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\dph_test.h ===
// DPH_TEST.h : main header file for the DPH_TEST application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include <pdh.h>
#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CDPH_TESTApp:
// See DPH_TEST.cpp for the implementation of this class
//

class CDPH_TESTApp : public CWinApp
{
public:
	CDPH_TESTApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDPH_TESTApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CDPH_TESTApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DPH_TEST.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\pdhpathtestdialog.cpp ===
// PdhPathTestDialog.cpp : implementation file
//

#include "stdafx.h"
#include "assert.h"
#include "dph_test.h"
#include "PdhPathTestDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPdhPathTestDialog dialog


CPdhPathTestDialog::CPdhPathTestDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CPdhPathTestDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPdhPathTestDialog)
	m_CounterName = _T("");
	m_FullPathString = _T("");
	m_IncludeInstanceName = FALSE;
	m_InstanceNameString = _T("");
	m_IncludeMachineName = FALSE;
	m_ObjectNameString = _T("");
	m_MachineNameString = _T("");
	m_UnicodeFunctions = FALSE;
	m_WbemOutput = FALSE;
	m_WbemInput = FALSE;
	//}}AFX_DATA_INIT
}


void CPdhPathTestDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPdhPathTestDialog)
	DDX_Text(pDX, IDC_COUNTER_NAME_EDIT, m_CounterName);
	DDV_MaxChars(pDX, m_CounterName, 255);
	DDX_Text(pDX, IDC_FULL_PATH_STRING_EDIT, m_FullPathString);
	DDV_MaxChars(pDX, m_FullPathString, 255);
	DDX_Check(pDX, IDC_INSTANCE_NAME_CHK, m_IncludeInstanceName);
	DDX_Text(pDX, IDC_INSTANCE_NAME_EDIT, m_InstanceNameString);
	DDV_MaxChars(pDX, m_InstanceNameString, 255);
	DDX_Check(pDX, IDC_MACHINE_NAME_CHK, m_IncludeMachineName);
	DDX_Text(pDX, IDC_OBJECT_NAME_EDIT, m_ObjectNameString);
	DDV_MaxChars(pDX, m_ObjectNameString, 255);
	DDX_Text(pDX, IDC_MACHINE_NAME_EDIT, m_MachineNameString);
	DDV_MaxChars(pDX, m_MachineNameString, 255);
	DDX_Check(pDX, IDC_UNICODE_CHK, m_UnicodeFunctions);
	DDX_Check(pDX, IDC_WBEM_OUTPUT_CHK, m_WbemOutput);
	DDX_Check(pDX, IDC_WBEM_INPUT_CHK, m_WbemInput);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPdhPathTestDialog, CDialog)
	//{{AFX_MSG_MAP(CPdhPathTestDialog)
	ON_BN_CLICKED(IDC_MACHINE_NAME_CHK, OnMachineNameChk)
	ON_BN_CLICKED(IDC_INSTANCE_NAME_CHK, OnInstanceNameChk)
	ON_BN_CLICKED(IDC_PROCESS_BTN, OnProcessBtn)
	ON_BN_CLICKED(IDC_ENTER_ELEM_BTN, OnEnterElemBtn)
	ON_BN_CLICKED(IDC_ENTER_PATH_BTN, OnEnterPathBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CPdhPathTestDialog::SetDialogMode() 
{
    // reads the mode of the dialog box and enables the appropriate controls
    BOOL    bEnterComponents;

    if (((CButton *)GetDlgItem(IDC_ENTER_ELEM_BTN))->GetCheck() == 0) {
        bEnterComponents = FALSE;
    } else {
        bEnterComponents = TRUE;
    }

    // enabled for component entries
    GetDlgItem(IDC_MACHINE_NAME_EDIT)->EnableWindow(bEnterComponents);
    GetDlgItem(IDC_MACHINE_NAME_CHK)->EnableWindow(bEnterComponents);
    GetDlgItem(IDC_OBJECT_NAME_EDIT)->EnableWindow(bEnterComponents);
    GetDlgItem(IDC_INSTANCE_NAME_CHK)->EnableWindow(bEnterComponents);
    GetDlgItem(IDC_INSTANCE_NAME_EDIT)->EnableWindow(bEnterComponents);
    GetDlgItem(IDC_COUNTER_NAME_EDIT)->EnableWindow(bEnterComponents);

    if (bEnterComponents) {
        // set the edit box state based on check box selections
        if (((CButton *)GetDlgItem(IDC_MACHINE_NAME_CHK))->GetCheck()==0) {
            GetDlgItem(IDC_MACHINE_NAME_EDIT)->EnableWindow(FALSE);
        }

        if (((CButton *)GetDlgItem(IDC_INSTANCE_NAME_CHK))->GetCheck() == 0) {
            GetDlgItem(IDC_INSTANCE_NAME_EDIT)->EnableWindow(FALSE);
        }
    }

    // enabled for path string entries
    GetDlgItem(IDC_FULL_PATH_STRING_EDIT)->EnableWindow(!bEnterComponents);
    
}


/////////////////////////////////////////////////////////////////////////////
// CPdhPathTestDialog message handlers

void CPdhPathTestDialog::OnMachineNameChk() 
{
    BOOL    bMode;
    bMode = (((CButton *)GetDlgItem(IDC_MACHINE_NAME_CHK))->GetCheck()==1);
    GetDlgItem(IDC_MACHINE_NAME_EDIT)->EnableWindow(bMode);
}

void CPdhPathTestDialog::OnInstanceNameChk() 
{
    BOOL    bMode;
    bMode = (((CButton *)GetDlgItem(IDC_INSTANCE_NAME_CHK))->GetCheck() == 1);
    GetDlgItem(IDC_INSTANCE_NAME_EDIT)->EnableWindow(bMode);
}

void CPdhPathTestDialog::OnProcessBtn() 
{
/*
typedef struct _PDH_COUNTER_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    LPSTR   szObjectName;
    LPSTR   szInstanceName;
    LPSTR   szParentInstance;
    DWORD   dwInstanceIndex;
    LPSTR   szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_A, *PPDH_COUNTER_PATH_ELEMENTS_A;
*/
    
    PDH_COUNTER_PATH_ELEMENTS_A pdhPathElemA;
    PDH_COUNTER_PATH_ELEMENTS_W pdhPathElemW;
    PPDH_COUNTER_PATH_ELEMENTS_A ppdhPathElemA;
    PPDH_COUNTER_PATH_ELEMENTS_W ppdhPathElemW;

    PDH_STATUS  pdhStatus;
    CHAR        szRtnBuffer[1024];
    WCHAR       wszRtnBuffer[1024];
    DWORD       dwBufSize;
    DWORD       dwFlags;
    BYTE        pBuffer[2048];

    WCHAR       wszMachineName[MAX_PATH];
    WCHAR       wszObjectName[MAX_PATH];
    WCHAR       wszInstanceName[MAX_PATH];
    WCHAR       wszCounterName[MAX_PATH];

    UpdateData (TRUE);  // get values from Dialog box

    // set flags values
    dwFlags = 0;
    dwFlags |= (m_WbemOutput ? PDH_PATH_WBEM_RESULT : 0);
    dwFlags |= (m_WbemInput ? PDH_PATH_WBEM_INPUT : 0);

    if (((CButton *)GetDlgItem(IDC_ENTER_ELEM_BTN))->GetCheck() == 1) {
        // then read elements and produce path string
        if (((CButton *)GetDlgItem(IDC_UNICODE_CHK))->GetCheck() == 0) {
            // use ANSI functions
            if (m_IncludeMachineName) {
                pdhPathElemA.szMachineName = (LPSTR)(LPCSTR)m_MachineNameString;
            } else {
                pdhPathElemA.szMachineName = NULL;
            }
            pdhPathElemA.szObjectName = (LPSTR)(LPCSTR)m_ObjectNameString;
            if (m_IncludeInstanceName) {
                pdhPathElemA.szInstanceName = (LPSTR)(LPCSTR)m_InstanceNameString;
            } else {
                pdhPathElemA.szInstanceName = NULL;
            }
            pdhPathElemA.szParentInstance = NULL;
            pdhPathElemA.dwInstanceIndex = 0;
            pdhPathElemA.szCounterName = (LPSTR)(LPCSTR)m_CounterName;
            
            dwBufSize = sizeof(szRtnBuffer)/sizeof(szRtnBuffer[0]);
            pdhStatus = PdhMakeCounterPathA (
                &pdhPathElemA,
                szRtnBuffer,
                &dwBufSize,
                dwFlags);

            if (pdhStatus != ERROR_SUCCESS) {
                // return error in string buffer
                sprintf (szRtnBuffer, "PDH Error 0x%8.8x", pdhStatus);
            }
           
            m_FullPathString = szRtnBuffer;

        } else {
            // use unicode functions
            if (m_IncludeMachineName) {
                mbstowcs (wszMachineName, 
                    (LPCSTR)m_MachineNameString, 
                    m_MachineNameString.GetLength() + 1);
                pdhPathElemW.szMachineName = wszMachineName;
            } else {
                pdhPathElemW.szMachineName = NULL;
            }

            mbstowcs (wszObjectName, 
                (LPCSTR)m_ObjectNameString, 
                m_ObjectNameString.GetLength() + 1);
            pdhPathElemW.szObjectName = wszObjectName;

            if (m_IncludeInstanceName) {
                mbstowcs (wszInstanceName, 
                    (LPCSTR)m_InstanceNameString, 
                    m_InstanceNameString.GetLength() + 1);
                pdhPathElemW.szInstanceName = wszInstanceName;
            } else {
                pdhPathElemW.szInstanceName = NULL;
            }

            pdhPathElemW.szParentInstance = NULL;
            pdhPathElemW.dwInstanceIndex = 0;

            mbstowcs (wszCounterName, 
                (LPCSTR)m_CounterName, 
                m_CounterName.GetLength() + 1);
            pdhPathElemW.szCounterName = wszCounterName;
            
            dwBufSize = sizeof(wszRtnBuffer)/sizeof(wszRtnBuffer[0]);
            pdhStatus = PdhMakeCounterPathW (
                &pdhPathElemW,
                wszRtnBuffer,
                &dwBufSize,
                dwFlags);

            if (pdhStatus != ERROR_SUCCESS) {
                // return error in string buffer
                sprintf (szRtnBuffer, "PDH Error 0x%8.8x", pdhStatus);
            } else {
                wcstombs (szRtnBuffer, wszRtnBuffer, lstrlenW(wszRtnBuffer)+1);
            }
            m_FullPathString = szRtnBuffer;
        }
    } else {
        // read path string and produce elements
        if (((CButton *)GetDlgItem(IDC_UNICODE_CHK))->GetCheck() == 0) {
            // use ANSI functions
            dwBufSize = sizeof(pBuffer);
            pdhStatus = PdhParseCounterPathA (
                (LPCSTR)m_FullPathString,
                (PDH_COUNTER_PATH_ELEMENTS_A *)&pBuffer[0],
                &dwBufSize,
                dwFlags);

            if (pdhStatus != ERROR_SUCCESS) {
                // return error in string buffer
                sprintf (szRtnBuffer, "PDH Error 0x%8.8x", pdhStatus);
                m_MachineNameString = szRtnBuffer;
                m_ObjectNameString = "";
                m_InstanceNameString = "";
                m_CounterName = "";
            } else {
                // update fields
                ppdhPathElemA = (PDH_COUNTER_PATH_ELEMENTS_A *)&pBuffer[0];
                if (ppdhPathElemA->szMachineName != NULL) {
                    m_MachineNameString = ppdhPathElemA->szMachineName;
                    m_IncludeMachineName = TRUE;
                } else {
                    m_MachineNameString = "";
                    m_IncludeMachineName = FALSE;
                }

                assert (ppdhPathElemA->szObjectName != NULL);
                m_ObjectNameString = ppdhPathElemA->szObjectName;

                if (ppdhPathElemA->szInstanceName != NULL) {
                    m_InstanceNameString = ppdhPathElemA->szInstanceName;
                    m_IncludeInstanceName = TRUE;
                } else {
                    m_InstanceNameString = "";
                    m_IncludeInstanceName = FALSE;
                }

                assert (ppdhPathElemA->szCounterName != NULL);
                m_CounterName = ppdhPathElemA->szCounterName;
            }
        } else {
            // do unicode functions
            dwBufSize = sizeof(pBuffer);
            mbstowcs (wszRtnBuffer, 
                (LPCSTR)m_FullPathString,
                m_FullPathString.GetLength());
            pdhStatus = PdhParseCounterPathW (
                wszRtnBuffer,
                (PDH_COUNTER_PATH_ELEMENTS_W *)&pBuffer[0],
                &dwBufSize,
                dwFlags);

            if (pdhStatus != ERROR_SUCCESS) {
                // return error in string buffer
                sprintf (szRtnBuffer, "PDH Error 0x%8.8x", pdhStatus);
                m_MachineNameString = szRtnBuffer;
                m_ObjectNameString = "";
                m_InstanceNameString = "";
                m_CounterName = "";
            } else {
                // update fields
                ppdhPathElemW = (PDH_COUNTER_PATH_ELEMENTS_W *)&pBuffer[0];
                if (ppdhPathElemW->szMachineName != NULL) {
                    wcstombs (szRtnBuffer, ppdhPathElemW->szMachineName,
                        lstrlenW(ppdhPathElemW->szMachineName)+1);
                    m_MachineNameString = szRtnBuffer;
                    m_IncludeMachineName = TRUE;
                } else {
                    m_MachineNameString = "";
                    m_IncludeMachineName = FALSE;
                }

                assert (ppdhPathElemW->szObjectName != NULL);
                wcstombs (szRtnBuffer, ppdhPathElemW->szObjectName,
                    lstrlenW(ppdhPathElemW->szObjectName)+1);
                m_ObjectNameString = szRtnBuffer;

                if (ppdhPathElemW->szInstanceName != NULL) {
                    wcstombs (szRtnBuffer, ppdhPathElemW->szInstanceName,
                        lstrlenW(ppdhPathElemW->szInstanceName)+1);
                    m_InstanceNameString = szRtnBuffer;
                    m_IncludeInstanceName = TRUE;
                } else {
                    m_InstanceNameString = "";
                    m_IncludeInstanceName = FALSE;
                }

                assert (ppdhPathElemA->szCounterName != NULL);
                wcstombs (szRtnBuffer, ppdhPathElemW->szCounterName,
                    lstrlenW(ppdhPathElemW->szCounterName)+1);
                m_CounterName = szRtnBuffer;
            }
        }
    }

    UpdateData (FALSE);  // put values back into Dialog box

}

BOOL CPdhPathTestDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    UpdateData (FALSE); // update controls

    ((CButton *)GetDlgItem(IDC_ENTER_ELEM_BTN))->SetCheck(TRUE);
    ((CButton *)GetDlgItem(IDC_ENTER_PATH_BTN))->SetCheck(FALSE);

    SetDialogMode();
	
    // force unicode functions for now
    ((CButton *)GetDlgItem(IDC_UNICODE_CHK))->SetCheck(TRUE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPdhPathTestDialog::OnEnterElemBtn() 
{
    SetDialogMode();
}

void CPdhPathTestDialog::OnEnterPathBtn() 
{
    SetDialogMode();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\pdhpathtestdialog.h ===
#if !defined(AFX_PDHPATHTESTDIALOG_H__24E84783_AC7F_11D1_BE7E_00A0C913CAD4__INCLUDED_)
#define AFX_PDHPATHTESTDIALOG_H__24E84783_AC7F_11D1_BE7E_00A0C913CAD4__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PdhPathTestDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPdhPathTestDialog dialog

class CPdhPathTestDialog : public CDialog
{
// Construction
public:
	CPdhPathTestDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPdhPathTestDialog)
	enum { IDD = IDD_CHECK_PATH };
	CString	m_CounterName;
	CString	m_FullPathString;
	BOOL	m_IncludeInstanceName;
	CString	m_InstanceNameString;
	BOOL	m_IncludeMachineName;
	CString	m_ObjectNameString;
	CString	m_MachineNameString;
	BOOL	m_UnicodeFunctions;
	BOOL	m_WbemOutput;
	BOOL	m_WbemInput;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPdhPathTestDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    void SetDialogMode(void);

	// Generated message map functions
	//{{AFX_MSG(CPdhPathTestDialog)
	afx_msg void OnMachineNameChk();
	afx_msg void OnInstanceNameChk();
	afx_msg void OnProcessBtn();
	virtual BOOL OnInitDialog();
	afx_msg void OnEnterElemBtn();
	afx_msg void OnEnterPathBtn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PDHPATHTESTDIALOG_H__24E84783_AC7F_11D1_BE7E_00A0C913CAD4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\pdh_test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DPH_TEST.rc
//
#define IDC_REMOVE_BTN                  2
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_DPH_TEST_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDD_COUNTER_INFO                129
#define IDD_BROWSE_COUNTERS_DLG         130
#define IDD_BROWSE_COUNTERS_DLG_EXT     130
#define IDD_BROWSE_COUNTERS_DLG1        131
#define IDD_LOG_FILE_INFO               131
#define IDD_BROWSE_COUNTERS_DLG_SIM     132
#define IDD_CHECK_PATH                  132
#define IDC_COUNTER_LIST                1002
#define IDC_NEW_COUNTER_NAME            1003
#define IDC_ADD_COUNTER                 1004
#define IDC_GET_NEW_DATA          