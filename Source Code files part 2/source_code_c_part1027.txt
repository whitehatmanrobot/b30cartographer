urn code
 *      wf - the wait flag
 *         - 0 = Wait for process completion
 *         - 1 = Return immediately (Pipes)
 *
 *  Returns:
 *      If syncronous execution, the return code of the command is returned.
 *      If asyncronous execution, the return code of the exec call is returned.
 *
 *  Notes:
 *      The pid of a program that will be waited on is placed in the global
 *      variable Retcds.ptcod so that WaitProc can use it and so SigHand()
 *      can kill it if necessary (only during SYNC exec's).
 *      M024 - Added wait flag parm so pipes can get immediate return while
 *             still doing an AI_KEEP async exec.
 *           - Considerable revisions to structure.
 */

int ECWork(n, ai, wf)
struct cmdnode *n ;
unsigned ai ;
unsigned wf ;
{
        TCHAR *fnptr,                           /* Ptr to filename         */
             *argptr,                           /* Command Line String     */
             *tptr;                             /* M034 - Temps            */
        int i ;                                 /* Work variable           */
        TCHAR *  onb ;                           /* M035 - Obj name buffer  */
        ULONG   rc;


        if (!(fnptr = mkstr(MAX_PATH*sizeof(TCHAR)+sizeof(TCHAR))))    /* Loc/nam of file to exec */
                return(FAILURE) ;

        argptr = GetTitle( n );
        tptr = argptr;
        if (argptr == NULL) {

            return( FAILURE );

        }

        i = SearchForExecutable(n, fnptr) ;
        if (i == SFE_ISEXECOM) {                /* Found .com or .exe file */

                if (!(onb = (TCHAR *)mkstr(MAX_PATH*sizeof(TCHAR)+sizeof(TCHAR))))  /* M035    */
                   {
                        return(FAILURE) ;

                   }

            SetConTitle( tptr );
            rc = ExecPgm( n, onb, ai, wf, argptr, fnptr, tptr);
            ResetConTitle( pszTitleCur );

            return( rc  );

        } ;

        if (i == SFE_ISBAT) {            /* Found .cmd file, call BatProc  */

                SetConTitle(tptr);
                rc = BatProc(n, fnptr, BT_CHN) ;
                ResetConTitle( pszTitleCur );
                return(rc) ;
        } ;

        if (i == SFE_ISDIR) {
                return ChangeDir2(fnptr, TRUE);
        }

        LastRetCode = DosErr;
        if (i == SFE_FAIL) {            /* Out of Memory Error             */
                return(FAILURE) ;
        } ;

        if (DosErr == MSG_DIR_BAD_COMMAND_OR_FILE) {
            PutStdErr(DosErr, ONEARG, n->cmdline);
            }
        else {
            PutStdErr(DosErr, NOARGS);
            }
        return(FAILURE) ;
}


#ifndef WIN95_CMD
VOID
RestoreCurrentDirectories( VOID )

/* this routine sets the current process's current directories to
   those of the child if the child was the VDM to fix DOS batch files.
*/

{
    ULONG cchCurDirs;
    UINT PreviousErrorMode;
    PTCHAR pCurDirs,pCurCurDir;
    BOOL CurDrive=TRUE;
#ifdef UNICODE
    PCHAR pT;
#endif

    cchCurDirs = GetVDMCurrentDirectories( 0,
                                           NULL
                                         );
    if (cchCurDirs == 0)
        return;

    pCurDirs = gmkstr(cchCurDirs*sizeof(TCHAR));
#ifdef UNICODE
    pT = gmkstr(cchCurDirs);
#endif

    GetVDMCurrentDirectories( cchCurDirs,
#ifdef UNICODE
                               pT
#else
                               pCurDirs
#endif
                            );
#ifdef UNICODE
    MultiByteToWideChar(CurrentCP, MB_PRECOMPOSED, pT, -1, pCurDirs, cchCurDirs);
#endif

    // set error mode so we don't get popup if trying to set curdir
    // on empty floppy drive

    PreviousErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    for (pCurCurDir=pCurDirs;*pCurCurDir!=NULLC;pCurCurDir+=(_tcslen(pCurCurDir)+1)) {
        ChangeDir2(pCurCurDir,CurDrive);
        CurDrive=FALSE;
    }
    SetErrorMode(PreviousErrorMode);
    //free(pCurDirs);
#ifdef UNICODE
    FreeStr((PTCHAR)pT);
#endif
}
#endif // WIN95_CMD


/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: ExecPgm                                            */
/*                                                                     */
/* DESCRIPTIVE NAME: Call DosExecPgm to execute External Command       */
/*                                                                     */
/* FUNCTION: Execute External Commands with DosExecPgm                 */
/*           This routine calls DosExecPgm to execute the command.     */
/*                                                                     */
/*                                                                     */
/* NOTES: This is a new routine added for OS/2 1.1 release.            */
/*                                                                     */
/*                                                                     */
/* ENTRY POINT: ExecPgm                                                */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT: n - the parse tree node containing the command to be executed*/
/*                                                                     */
/*        ai - the asynchronous indicator                              */
/*           - 0 = Exec synchronous with parent                        */
/*           - 1 = Exec asynchronous and discard child return code     */
/*           - 2 = Exec asynchronous and save child return code        */
/*                                                                     */
/*        wf - the wait flag                                           */
/*           - 0 = Wait for process completion                         */
/*           - 1 = Return immediately (Pipes)                          */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         If synchronous execution, the return code of the command is */
/*         returned.                                                   */
/*                                                                     */
/*         If asynchronous execution, the return code of the exec call */
/*         is returned.                                                */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to the caller.                               */
/*                                                                     */
/* EFFECTS:                                                            */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       ExecError - Handles execution error                           */
/*       PutStdErr - Print an error message                            */
/*       WaitProc - wait for the termination of the specified process, */
/*                  its child process, and  related pipelined          */
/*                  processes.                                         */
/*                                                                     */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       DOSEXECPGM      - Execute the specified program               */
/*       DOSSMSETTITLE   - Set title for the presentation manager      */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

int
ExecPgm(
    IN struct cmdnode *n,
    IN TCHAR *onb,
    IN unsigned int ai,
    IN unsigned int  wf,
    IN TCHAR * argptr,
    IN TCHAR * fnptr,
    IN TCHAR * tptr
    )
{
    int i ;                                 /* Work variable           */
    BOOL b;
    BOOL VdmProcess = FALSE;
    BOOL WowProcess = FALSE;
    BOOL GuiProcess = FALSE;
    LPTSTR CopyCmdValue;

    HDESK   hdesk;
    LPTSTR  lpDesktop;
    DWORD   cbDesktop = 0;
    HWINSTA hwinsta;
    LPTSTR  p;
    DWORD   cbWinsta = 0;

    TCHAR   szValEqExitCodeEnvVar [20];
    TCHAR   szValEqExitCodeAsciiEnvVar [12];


    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ChildProcessInfo;

    memset( &StartupInfo, 0, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );
    StartupInfo.lpTitle = tptr;
    StartupInfo.dwX = 0;
    StartupInfo.dwY = 1;
    StartupInfo.dwXSize = 100;
    StartupInfo.dwYSize = 100;
    StartupInfo.dwFlags = 0;//STARTF_SHELLOVERRIDE;
    StartupInfo.wShowWindow = SW_SHOWNORMAL;

    // Pass current Desktop to a new process.

    hwinsta = GetProcessWindowStation();
    GetUserObjectInformation( hwinsta, UOI_NAME, NULL, 0, &cbWinsta );

    hdesk = GetThreadDesktop ( GetCurrentThreadId() );
    GetUserObjectInformation (hdesk, UOI_NAME, NULL, 0, &cbDesktop);

    if ((lpDesktop = HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, cbDesktop + cbWinsta + 32) ) != NULL ) {
        p = lpDesktop;
        if ( GetUserObjectInformation (hwinsta, UOI_NAME, p, cbWinsta, &cbWinsta) ) {
            if (cbWinsta > 0) {
                p += ((cbWinsta/sizeof(TCHAR))-1);
                *p++ = L'\\';
            }
            if ( GetUserObjectInformation (hdesk, UOI_NAME, p, cbDesktop, &cbDesktop) ) {
                StartupInfo.lpDesktop = lpDesktop;
            }
        }
    }

    //
    //  Incredibly ugly hack for Win95 compatibility.
    //
    //  XCOPY in Win95 reaches up into it's parent process to see if it was
    //  invoked in a batch file.  If so, then XCOPY pretends COPYCMD=/Y
    //
    //  There is no way we can do this for NT.  The best that can be done is
    //  to detect if we're in a batch file starting XCOPY and then temporarily
    //  change COPYCMD=/Y.
    //

    {
        const TCHAR *p = MyGetEnvVarPtr( TEXT( "COPYCMD" ));

        if (p == NULL) {
            p = TEXT( "" );
        }

        CopyCmdValue = malloc( (mystrlen( p ) + 1) * sizeof( TCHAR ));
        if (CopyCmdValue == NULL) {
            PutStdErr( MSG_NO_MEMORY, NOARGS );
            return FAILURE;
        }
        mystrcpy( CopyCmdValue, p );

        if ((SingleBatchInvocation
             || SingleCommandInvocation
             || CurrentBatchFile )
            && (p = mystrrchr( fnptr, TEXT( '\\' ))) != NULL
            && !lstrcmp( p, TEXT( "\\XCOPY.EXE" ))
           ) {

            SetEnvVar( TEXT( "COPYCMD" ), TEXT( "/Y" ), NULL );

        }
    }

    //
    // If the restricted token exists then create the process with the 
    // restricted token. 
    // Else create the process without any restrictions.
    //

    if ((CurrentBatchFile != NULL) && (CurrentBatchFile->hRestrictedToken != NULL)) {

        b = CreateProcessAsUser( CurrentBatchFile->hRestrictedToken,
                                 fnptr,
                                 argptr,
                                 (LPSECURITY_ATTRIBUTES) NULL,
                                 (LPSECURITY_ATTRIBUTES) NULL,
                                 TRUE,
                                 0,
                                 NULL,
                                 CurDrvDir,
                                 &StartupInfo,
                                 &ChildProcessInfo
                                 );


    } else {
        b = CreateProcess( fnptr,
                           argptr,
                           (LPSECURITY_ATTRIBUTES) NULL,
                           (LPSECURITY_ATTRIBUTES) NULL,
                           TRUE,
                           0,
                           NULL,
                           CurDrvDir,
                           &StartupInfo,
                           &ChildProcessInfo
                         );
    }

    if (!b) {
        DosErr = i = GetLastError();
    } else {
        hChildProcess = ChildProcessInfo.hProcess;
#if !defined( WIN95_CMD ) && DBG
        if (hChildProcess == NULL) {
            DbgBreakPoint( );
        }
#endif
        CloseHandle(ChildProcessInfo.hThread);
    }

    //
    //  Undo ugly hack
    //

    SetEnvVar( TEXT( "COPYCMD" ), CopyCmdValue, NULL );
    free( CopyCmdValue );

    HeapFree (GetProcessHeap(), 0, lpDesktop);
    if (!b) {

        if (fEnableExtensions && DosErr == ERROR_BAD_EXE_FORMAT) {
            SHELLEXECUTEINFO sei;

            memset(&sei, 0, sizeof(sei));

            //
            // Use the DDEWAIT flag so apps can finish their DDE conversation
            // before ShellExecuteEx returns.  Otherwise, apps like Word will
            // complain when they try to exit, confusing the user.
            //

            sei.cbSize = sizeof(sei);
            sei.fMask = SEE_MASK_HASTITLE |
                        SEE_MASK_NO_CONSOLE |
                        SEE_MASK_FLAG_DDEWAIT |
                        SEE_MASK_NOCLOSEPROCESS;
            sei.lpFile = fnptr;
            sei.lpParameters = n->argptr;
            sei.lpDirectory = CurDrvDir;
            sei.nShow = StartupInfo.wShowWindow;

            try {
                b = ShellExecuteEx( &sei );

                if (b) {
                    hChildProcess = sei.hProcess;
                    leave;
                }

                if (sei.hInstApp == NULL) {
                    DosErr = ERROR_NOT_ENOUGH_MEMORY;
                } else if ((DWORD_PTR)sei.hInstApp == HINSTANCE_ERROR) {
                    DosErr = ERROR_FILE_NOT_FOUND;
                } else {
                    DosErr = HandleToUlong(sei.hInstApp);
                }

            } except( DosErr = GetExceptionCode( ), EXCEPTION_EXECUTE_HANDLER ) {
                b = FALSE;
            }

        }

        if (!b) {
            mystrcpy( onb, fnptr );
            ExecError( onb ) ;

            return (FAILURE) ;
        }
    }

#ifndef WIN95_CMD
    VdmProcess = ((UINT_PTR)(hChildProcess) & 1) ? TRUE : FALSE;
    WowProcess = ((UINT_PTR)(hChildProcess) & 2) ? TRUE : FALSE;
#endif // WIN95_CMD
    if (hChildProcess == NULL
        || (fEnableExtensions 
            && CurrentBatchFile == 0 
            && !SingleBatchInvocation 
            && !SingleCommandInvocation 
            && ai == AI_SYNC 
            && (WowProcess 
                || GetProcessSubsystemType(hChildProcess) == IMAGE_SUBSYSTEM_WINDOWS_GUI
                )
            )
       ) {
        //
        // If extensions enabled and doing a synchronous exec of a GUI
        // application, then change it into an asynchronous exec, with the
        // return code discarded, ala Win 3.x and Win 95 COMMAND.COM
        //
        ai = AI_DSCD;
        GuiProcess = TRUE;
    }

    i = SUCCESS;
    start_type = EXECPGM;

    if (ai == AI_SYNC) {             /* Async exec...   */
        LastRetCode = WaitProc( hChildProcess );
        i = LastRetCode ;

        //
        // this is added initially to support new network batch scripts
        // but it can be used by any process.
        //
        // always set "=ExitCode" env. variable as string of 8 hex digits
        // representing LastRetCode

        _stprintf (szValEqExitCodeEnvVar, TEXT("%08X"), i);
        SetEnvVar(szNameEqExitCodeEnvVar, szValEqExitCodeEnvVar, &CmdEnv);

        // IF   LastRetCode printable
        // THEN set "=ExitCodeAscii" env. variable equal LastRetCode
        // ELSE remove "=ExitCodeAscii" env. variable

        if ( (i >= 0x20) &&  (i <= 0x7e) ) {       // isprint
            _stprintf (szValEqExitCodeAsciiEnvVar, TEXT("%01C"), i);
            SetEnvVar(szNameEqExitCodeAsciiEnvVar, szValEqExitCodeAsciiEnvVar, &CmdEnv);
        } else
            SetEnvVar(szNameEqExitCodeAsciiEnvVar, TEXT("\0"), &CmdEnv);


#ifndef WIN95_CMD
        if (VdmProcess) {
            RestoreCurrentDirectories();
        }
#endif // WIN95_CMD
    }

/*  If real async (discarding retcode), just print PID and return.  If
 *  piped process (keeping retcode but not waiting) just store PID for
 *  ePipe and return SUCCESS from exec.  Else, wait around for the return
 *  code before going back.
 */
    if (ai == AI_DSCD) {                    /* DETach only     */
        if (!GuiProcess)
            PutStdErr(MSG_PID_IS, ONEARG, argstr1(TEXT("%u"), HandleToUlong(hChildProcess)));
        if (hChildProcess != NULL) {
            CloseHandle( hChildProcess );
            hChildProcess = NULL;
        }
    } else if (ai == AI_KEEP) {             /* Async exec...   */
        if (wf == CW_W_YES) {           /* ...normal type  */
            LastRetCode = WaitProc(hChildProcess);
            i = LastRetCode ;
        } else {                        /* Async exec...   */
            PipePid = hChildProcess ;        /* M035      */
        }
    } else {
    }


    return (i) ;             /* i == return from DOSEXECPGM     */
}

/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: SearchForExecutable                                */
/*                                                                     */
/* DESCRIPTIVE NAME:  Search for Executable File                       */
/*                                                                     */
/* FUNCTION: This routine searches the specified executable file.      */
/*           If the file extension is specified,                       */
/*           CMD.EXE searches for the file with the file extension     */
/*           to execute.  If the specified file with the extension     */
/*           is not found, CMD.EXE will display an error message to    */
/*           indicate that the file is not found.                      */
/*           If the file extension is not specified,                   */
/*           CMD.EXE searches for the file with the order of these     */
/*           file extensions, .COM, .EXE, .CMD, and .BAT.              */
/*           The file which is found first will be executed.           */
/*                                                                     */
/* NOTES:    1) If a path is given, only the specified directory is    */
/*              searched.                                              */
/*           2) If no path is given, the current directory of the      */
/*              drive specified is searched followed by the            */
/*              directories in the PATH environment variable.          */
/*           3) If no executable file is found, an error message is    */
/*              printed.                                               */
/*                                                                     */
/* ENTRY POINT: SearchForExecutable                                    */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:                                                              */
/*    n - parse tree node containing the command to be searched for    */
/*    loc - the string in which the location of the command is to be   */
/*          placed                                                     */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Returns:                                                    */
/*             SFE_EXECOM, if a .EXE or .COM file is found.            */
/*             SFE_ISBAT, if a .CMD file is found.                     */
/*             SFE_ISDIR, if a directory is found.                     */
/*             SFE_NOTFND, if no executable file is found.             */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE or                                           */
/*             SFE_FAIL, if out of memory.                             */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       DoFind    - Find the specified file.                          */
/*       GetEnvVar - Get full path.                                    */
/*       FullPath  - build a full path name.                           */
/*       TokStr    - tokenize argument strings.                        */
/*       mkstr     -  allocate space for a string.                     */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       None                                                          */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

SearchForExecutable(n, loc)
struct cmdnode *n ;
TCHAR *loc ;
{
    TCHAR *tokpath ;
    TCHAR *extPath ;
    TCHAR *extPathWrk ;
    TCHAR *fname;
    TCHAR *p1;
    TCHAR *tmps01;
    TCHAR *tmps02 = NULL;
    TCHAR pcstr[3];
    LONG BinaryType;

    size_t cName;   // number of characters in file name.

    int tplen;              // Length of the current tokpath token
    int dotloc;             // loc offset where extension is appended
    int pcloc;              // M014 - Flag. True=user had partial path
    int addpchar;   // True - append PathChar to string   @@5g
    TCHAR *j ;

    TCHAR wrkcmdline[MAX_PATH] ;
    unsigned tokpathlen;

    //
    //      Test for name too long first.  If it is, we avoid wasting time
    //
    p1 = StripQuotes( n->cmdline );
    if ((cName = mystrlen(p1)) >= MAX_PATH) {
        DosErr = MSG_LINES_TOO_LONG;
        return(SFE_NOTFND) ;
    }

    //
    // If cmd extensions enable, then treat CMD without an extension
    // or path as a reference to COMSPEC variable.  Guarantees we dont
    // get a random copy of CMD.EXE
    //

    if (fEnableExtensions && (p1 == NULL || !_tcsnicmp( p1, TEXT( "cmd " ), 4))) {
        p1 = GetEnvVar( ComSpecStr );
        if (p1 == NULL) {
            DosErr = MSG_INVALID_COMSPEC;
            return SFE_NOTFND;
        }
    }

    mytcsnset(wrkcmdline, NULLC, MAX_PATH);
    mystrcpy(wrkcmdline, p1);
    FixPChar( wrkcmdline, SwitChar );

    //
    // Create the path character string, this will be search string
    //
    pcstr[0] = PathChar;
    pcstr[1] = COLON;
    pcstr[2] = NULLC;

    //
    // The variable pcloc is used as a flag to indicate whether the user
    // did or didn't specify a drive or a partial path in his original
    // input.  It will be NZ if drive or path was specified.
    //

    pcloc = ((mystrcspn(wrkcmdline,pcstr)) < cName) ;
    pcstr[1] = NULLC ;      // Fixup pathchar string

    //
    // handle the case of the user typing in a file name of
    // ".", "..", or ending in "\"
    // pcloc true say string has to have either a pathchar or colon
    //
    if ( pcloc ) {
        if (!(p1 = mystrrchr( wrkcmdline, PathChar ))) {
            p1 = mystrchr( wrkcmdline, COLON );
        }
        p1++; // move to terminator if hanging ":" or "\"
    } else {
        p1 = wrkcmdline;
    }

    //
    // p1 is guaranteed to be non-zero
    //
    if ( !(*p1) || !_tcscmp( p1, TEXT(".") ) || !_tcscmp( p1, TEXT("..") ) ) {
        //
        // If CMD.EXE extensions enable, see if name matches
        // subdirectory name.
        //
        if (fEnableExtensions) {
            DWORD dwFileAttributes;

            dwFileAttributes = GetFileAttributes( loc );
            if (dwFileAttributes != 0xFFFFFFFF &&
                (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0
               ) {
                return(SFE_ISDIR);
            }
        }

        DosErr = MSG_DIR_BAD_COMMAND_OR_FILE;
        return(SFE_NOTFND) ;
    }

    if (!(tmps01 = mkstr(2*sizeof(TCHAR)*MAX_PATH))) {
        DosErr = ERROR_NOT_ENOUGH_MEMORY;
        return(SFE_FAIL) ;
    }

    //
    // Handle the case of file..ext on a fat drive
    //
    mystrcpy( loc, wrkcmdline );
    loc[ &p1[0] - &wrkcmdline[0] ] = 0;
    mystrcat( loc, TEXT(".") );

    //
    // Check for a malformed name
    //
    if (FullPath(tmps01, loc,MAX_PATH*2)) {
        //
        // If CMD.EXE extensions enable, see if name matches
        // subdirectory name.
        //
        if (fEnableExtensions) {
            DWORD dwFileAttributes;

            dwFileAttributes = GetFileAttributes( loc );
            if (dwFileAttributes != 0xFFFFFFFF &&
                (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0
               ) {
                return(SFE_ISDIR);
            }
        }
        DosErr = MSG_DIR_BAD_COMMAND_OR_FILE;
        return(SFE_NOTFND);
    }

    if ( *lastc(tmps01) != PathChar ) {
        mystrcat( tmps01, TEXT("\\") );
    }

    //
    // tmps01 contains full path + file name
    //
    mystrcat( tmps01, p1 );

    tmps01 = resize(tmps01, (mystrlen(tmps01)+1)*sizeof(TCHAR)) ;
    if (tmps01 == NULL) {
        DosErr = ERROR_NOT_ENOUGH_MEMORY;
        return( SFE_FAIL ) ;
    }

    //
    // fname will point to last '\'
    // tmps01 is to be path and fname is to be name
    //
    fname = mystrrchr(tmps01,PathChar) ;
    *fname++ = NULLC ;

    DEBUG((DBENV, DBENVSCAN, "SearchForExecutable: Command:%ws",fname));

    //
    // If only fname type in get path string
    //
    if (!pcloc) {
        tmps02 = GetEnvVar(PathStr) ;
    }

    DEBUG((DBENV, DBENVSCAN, "SearchForExecutable: PATH:%ws",tmps02));

    //
    // tmps02 is PATH environment variable
    // compute enough for PATH environment plus file default path
    //
    tokpath = mkstr( (2 + mystrlen(tmps01) + mystrlen(tmps02) + 2)*sizeof(TCHAR)) ;
    if ( ! tokpath ) {
        DosErr = ERROR_NOT_ENOUGH_MEMORY;
        return( SFE_FAIL ) ;
    }

    //
    // Copy default path
    //
    mystrcat(tokpath,TEXT("\""));
    mystrcat(tokpath,tmps01) ;
    mystrcat(tokpath,TEXT("\""));

    //
    // If only name type in get also delim and path string
    //
    if (!pcloc) {
        mystrcat(tokpath, TEXT(";")) ;
        mystrcat(tokpath,tmps02) ;
    }

    //
    // Shift left string at ';;'
    //
    tokshrink(tokpath);
    tokpath = TokStr(tokpath, TEXT(";"), TS_WSPACE) ;
    cName = mystrlen(fname) + 1 ; // file spec. length

    //
    // Build up the list of extensions we are going to search
    // for.  If extensions are enabled, get the list from the PATHEXT
    // variable, otherwise use the hard coded default.
    //
    extPath = NULL;
    if (fEnableExtensions)
        extPath = GetEnvVar(PathExtStr);

    if (extPath == NULL)
        extPath = PathExtDefaultStr;

    tokshrink(extPath);
    extPath = TokStr(extPath, TEXT(";"), TS_WSPACE) ;

    //
    // Everything is now set up.    Var tokpath contains a sequential series
    // of asciz strings terminated by an extra null. If the user specified
    // a drive or partial path, it contains only that one converted to full
    // root-based form.     If the user typed only a filename (pcloc = 0) it
    // begins with the current directory and contains each directory that
    // was contained in the PATH variable.  This loop will search each of
    // the tokpath elements once for each possible executable extention.
    // Note that 'i' is used as a constant to test for excessive string
    // length prior to performing the string copies.
    //
    for ( ; ; ) {

        //
        // Length of current path
        //
        tplen = mystrlen(tokpath) ;
        mystrcpy( tokpath, StripQuotes( tokpath ) );
        tokpathlen = mystrlen(tokpath);

        if (*lastc(tokpath) != PathChar) {
            addpchar = TRUE;
            tplen++;
            tokpathlen++;
        } else {
            addpchar = FALSE;
        }
        /* path + name too long */
        //
        // Check if path + name is too long
        //
        if (*tokpath && (tokpathlen + cName) > MAX_PATH) {
            tokpath += addpchar ? tplen : tplen+1; // get next path
            continue;
        }

        //
        // If no more paths to search return descriptive error
        //
        if (*(tokpath) == NULLC) {
            if (pcloc) {
                if (DosErr == 0 || DosErr == ERROR_FILE_NOT_FOUND)
                    DosErr = MSG_DIR_BAD_COMMAND_OR_FILE;
            } else {                   /* return generic message */
                DosErr = MSG_DIR_BAD_COMMAND_OR_FILE;
            }
            return(SFE_NOTFND) ;
        }

        //
        // Install this path and setup for next one
        //
        mystrcpy(loc, tokpath) ;
        tokpath += addpchar ? tplen : tplen+1;


        if (addpchar) {
            mystrcat(loc, pcstr) ;
        }

        mystrcat(loc, fname) ;
        mystrcpy(loc, StripQuotes(loc) );
        dotloc = mystrlen(loc) ;

        DEBUG((DBENV, DBENVSCAN, "SearchForExecutable: PATH:%ws",loc));

        //
        // Check drive in each path to insure it is valid before searching
        //
        if (*(loc+1) == COLON) {
            if (!IsValidDrv(*loc))
                continue ;
        };

        //
        // If fname has ext & ext > "." look for given filename
        // this says that all executable files must have an extension
        //
        j = mystrrchr( fname, DOT );
        if ( j && j[1] ) {
            //
            // If access was denied and the user included a path,
            // then say we found it.  This handles the case where
            // we don't have permission to do the findfirst and so we
            // can't see the binary, but it actually exists -- if we
            // have execute permission, CreateProcess will work
            // just fine.
            //
            if (exists_ex(loc,TRUE) || (pcloc && (DosErr == ERROR_ACCESS_DENIED))) {
                //
                // Recompute j as exists_ex trims trailing spaces
                //
                j = mystrrchr( loc, DOT );
                if (j != NULL) {
                    if ( !_tcsicmp(j,CmdExt) ) {
                        return(SFE_ISBAT) ;
                    } else if ( !_tcsicmp(j,BatExt) ) {
                        return(SFE_ISBAT) ;
                    } else {
                        return(SFE_ISEXECOM) ;
                    }
                }
            }

            if ((DosErr != ERROR_FILE_NOT_FOUND) && DosErr)
                continue;  // Try next path
        }
        if (mystrchr( fname, STAR ) || mystrchr( fname, QMARK ) ) {
            DosErr = MSG_DIR_BAD_COMMAND_OR_FILE;
            return(SFE_NOTFND);
        }

        //
        // Search for each type of extension
        //

        extPathWrk = extPath;
        if (DoFind(loc, dotloc, TEXT(".*"), FALSE))         // Found anything?
            while (*extPathWrk) {
                //
                // if name + path + ext is less then max path length
                //
                if ( (cName + tokpathlen + mystrlen(extPathWrk)) <= MAX_PATH) {
                    //
                    // See if this extension is a match.
                    //

                    if (DoFind(loc, dotloc, extPathWrk, TRUE)) {
                        if (!_tcsicmp(extPathWrk, BatExt) || !_tcsicmp(extPathWrk, CmdExt))
                            return(SFE_ISBAT) ;     // found .bat or .cmd
                        else
                            return(SFE_ISEXECOM) ;  // found executable

                    } else {
                        //
                        // Any kind of error other than file not found, bail from
                        // search and try next element in path
                        //
                        if ((DosErr != ERROR_FILE_NOT_FOUND) && DosErr)
                            break;
                    }
                }

                //
                // Not this extension, try next.

                while (*extPathWrk++)
                    ;
            }

        //
        // If we get here, then no match with list of extensions.
        // If no wierd errors, deal with NUll extension case.
        //

        if (DosErr == NO_ERROR || DosErr == ERROR_FILE_NOT_FOUND) {
            if (DoFind(loc, dotloc, TEXT("\0"), TRUE)) {
                if (GetBinaryType(loc,&BinaryType) &&
                    BinaryType == SCS_POSIX_BINARY) {          // Found .
                    return(SFE_ISEXECOM) ;
                }
            }
        }
    } // end for

    return(SFE_NOTFND);
}




/***    DoFind - does indiviual findfirsts during searching
 *
 *  Purpose:
 *      Add the extension to loc and do the find first for
 *      SearchForExecutable().
 *
 *  DoFind(TCHAR *loc, int dotloc, TCHAR *ext)
 *
 *  Args:
 *      loc - the string in which the location of the command is to be placed
 *      dotloc - the location loc at which the extension is to be appended
 *      ext - the extension to append to loc
 *
 *  Returns:
 *      1 if the file is found.
 *      0 if the file isn't found.
 *
 */

int DoFind(loc, dotloc, ext, metas)
TCHAR *loc ;
int dotloc ;
TCHAR *ext ;
BOOL metas;
{
        *(loc+dotloc) = NULLC ;
        mystrcat(loc, ext) ;

        DEBUG((DBENV, DBENVSCAN, "DoFind: exists_ex(%ws)",loc));

        return(exists_ex(loc,metas)) ;                  /*@@4*/
}




/***    ExecError - handles exec errors
 *
 *  Purpose:
 *      Print the exec error message corresponding to the error number in the
 *      global variable DosErr.
 *  @@ lots of error codes added.
 *  ExecError()
 *
 */

void ExecError( onb )
TCHAR *onb;
{
        unsigned int errmsg;
        unsigned int count;

        count = ONEARG;

        switch (DosErr) {

           case ERROR_BAD_DEVICE:
                   errmsg = MSG_DIR_BAD_COMMAND_OR_FILE;
                   count = NOARGS;
                   break;

           case ERROR_LOCK_VIOLATION:
                   errmsg = ERROR_SHARING_VIOLATION;
                   break ;

           case ERROR_NO_PROC_SLOTS:
                   errmsg =  ERROR_NO_PROC_SLOTS;
                   count = NOARGS;
                   break ;

           case ERROR_NOT_DOS_DISK:
                   errmsg = ERROR_NOT_DOS_DISK;
                   break ;

           case ERROR_NOT_ENOUGH_MEMORY:
                   errmsg =  ERROR_NOT_ENOUGH_MEMORY;
                   count = NOARGS;
                   break ;

           case ERROR_PATH_NOT_FOUND:
                   errmsg =  MSG_CMD_FILE_NOT_FOUND;
                   break ;

           case ERROR_FILE_NOT_FOUND:
                   errmsg =  MSG_CMD_FILE_NOT_FOUND;
                   break ;

           case ERROR_ACCESS_DENIED:
                   errmsg =  ERROR_ACCESS_DENIED;
                   break ;

           case ERROR_EXE_MACHINE_TYPE_MISMATCH:
                   errmsg =  ERROR_EXE_MACHINE_TYPE_MISMATCH;
                   break;

           case ERROR_DRIVE_LOCKED:
                   errmsg =  ERROR_DRIVE_LOCKED;
                   break ;

           case ERROR_INVALID_STARTING_CODESEG:
                   errmsg =  ERROR_INVALID_STARTING_CODESEG;
                   break ;

           case ERROR_INVALID_STACKSEG:
                   errmsg = ERROR_INVALID_STACKSEG;
                   break ;

           case ERROR_INVALID_MODULETYPE:
                   errmsg =  ERROR_INVALID_MODULETYPE;
                   break ;

           case ERROR_INVALID_EXE_SIGNATURE:
                   errmsg =  ERROR_INVALID_EXE_SIGNATURE;
                   break ;

           case ERROR_EXE_MARKED_INVALID:
                   errmsg =  ERROR_EXE_MARKED_INVALID;
                   break ;

           case ERROR_BAD_EXE_FORMAT:
                   errmsg =  ERROR_BAD_EXE_FORMAT;
                   break ;

           case ERROR_INVALID_MINALLOCSIZE:
                   errmsg =  ERROR_INVALID_MINALLOCSIZE;
                   break ;

           case ERROR_SHARING_VIOLATION:
                   errmsg =  ERROR_SHARING_VIOLATION;
                   break ;

           case ERROR_BAD_ENVIRONMENT:
                   errmsg =  ERROR_INFLOOP_IN_RELOC_CHAIN;
                   count = NOARGS;
                   break ;

           case ERROR_INVALID_ORDINAL:
                   errmsg =  ERROR_INVALID_ORDINAL;
                   break ;

           case ERROR_CHILD_NOT_COMPLETE:
                   errmsg =  ERROR_CHILD_NOT_COMPLETE;
                   break ;

           case ERROR_DIRECTORY:
                   errmsg = MSG_BAD_CURDIR;
                   count = NOARGS;
                   break;

           case ERROR_NOT_ENOUGH_QUOTA:
                   errmsg = ERROR_NOT_ENOUGH_QUOTA;
                   count = NOARGS;
                   break;


           case MSG_REAL_MODE_ONLY:
                   errmsg =  MSG_REAL_MODE_ONLY;
                   count = NOARGS;
                   break ;

           default:
//                 printf( "Exec failed code %x\n", DosErr );    
                   count = NOARGS;
                   errmsg = MSG_EXEC_FAILURE ;             /* M031    */

        }


        LastRetCode = errmsg;
        PutStdErr(errmsg, count, onb );
}

/*
 * tokshrink @@4
 *
 * remove duplicate ';' in a path
 */

void tokshrink( tokpath )
TCHAR *tokpath;
{
   int i, j;

   i = 0;
   do {
      if ( tokpath[i] == QUOTE ) {
         do {
            i++;
         } while ( tokpath[i] && tokpath[i] != QUOTE );
      }
      if ( tokpath[i] && tokpath[i] != TEXT(';') ) {
         i++;
      }
      if ( tokpath[i] == TEXT(';') ) {
         j = i;
         while ( tokpath[j+1] == TEXT(';') ) {
            j++;
         }
         if ( j > i ) {
            mystrcpy( &tokpath[i], &tokpath[j] );
         }
         i++;
      }
   } while ( tokpath[i] );
}



/***    eAssoc - execute an Assoc command
 *
 *  Purpose:
 *      To set/modify the file associations stored in the registry under the
 *      HKEY_LOCAL_MACHINE\Software\Classes key
 *
 *  int eAssoc(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the set command
 *
 *  Returns:
 *      If setting and the command is syntactically correct, whatever SetAssoc()
 *      returns.  Otherwise, FAILURE.
 *
 *      If displaying, SUCCESS is always returned.
 *
 */

int eAssoc(n)
struct cmdnode *n ;
{
    if (glBatType != CMD_TYPE)  {
        //  if set command is executed from .bat file OR entered at command prompt
        return( SetLastRetCodeIfError(AssocWork( n )));
    }
    else {
        return( LastRetCode = AssocWork( n ) );
    }
}

int AssocWork(n)
struct cmdnode *n ;
{
        HKEY hKeyClasses;
        TCHAR *tas ;    /* Tokenized argument string    */
        TCHAR *wptr ;   /* Work pointer                 */
        int i ;                 /* Work variable                */
        int rc ;


        rc = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Classes"), &hKeyClasses);
        if (rc) {
            return rc;
        }

        tas = TokStr(n->argptr, ONEQSTR, TS_WSPACE|TS_SDTOKENS) ;
        if (!*tas)
                rc = DisplayAssoc(hKeyClasses, NULL) ;

        else {
                for (wptr = tas, i = 0 ; *wptr ; wptr += mystrlen(wptr)+1, i++)
                        ;
                /* If too many parameters were given, the second parameter */
                /* wasn't an equal sign, or they didn't specify a string   */
                /* return an error message.                                */
                if ( i > 3 || *(wptr = tas+mystrlen(tas)+1) != EQ ||
                    !mystrlen(mystrcpy(tas, StripQuotes(tas))) ) {
                        if (i==1) {
                            rc =DisplayAssoc(hKeyClasses, tas);
                        } else {
                            PutStdErr(MSG_BAD_SYNTAX, NOARGS);
                            rc = FAILURE ;
                        }
                } else {
                        rc = SetAssoc(hKeyClasses, tas, wptr+2) ;
                }
        } ;

        RegCloseKey(hKeyClasses) ;

        return rc;
}




/***    DisplayAssoc - display a specific file association or all
 *
 *  Purpose:
 *      To display a specific file association or all
 *
 *  int DisplayAssoc( hKeyClasses, tas )
 *
 *  Returns:
 *      SUCCESS if all goes well
 *      FAILURE if it runs out of memory or cannot lock the env. segment
 */

int DisplayAssoc(hKeyClasses, tas)
HKEY hKeyClasses;
TCHAR *tas;
{
        int i;
        int rc = SUCCESS;
        TCHAR NameBuffer[MAX_PATH];
        TCHAR ValueBuffer[MAX_PATH];
        TCHAR *vstr ;
        DWORD cb;

        if (tas == NULL) {
            for (i=0 ; rc == SUCCESS ; i++) {
                rc =RegEnumKey(hKeyClasses, i, NameBuffer, sizeof( NameBuffer ) / sizeof( TCHAR ));
                if (rc != 0) {
                    if (rc==ERROR_NO_MORE_ITEMS)
                        rc = SUCCESS;
                    break;
                } else
                if (NameBuffer[0] == DOT) {
                    cb = sizeof(ValueBuffer);
                    rc = RegQueryValue(hKeyClasses, NameBuffer, ValueBuffer, &cb);
                    if (rc != 0) {
                        break;
                    }

                    rc = cmd_printf(Fmt16, NameBuffer, ValueBuffer);
                }

                if (CtrlCSeen) {
                    return(FAILURE);
                }
            }
        }
        else {
            tas = EatWS(tas, NULL);
            if ((vstr = mystrrchr(tas, ' ')) != NULL)
                *vstr = NULLC;

            cb = sizeof(ValueBuffer);
            rc = RegQueryValue(hKeyClasses, tas, ValueBuffer, &cb);
            if (rc == 0)
                rc = cmd_printf(Fmt16, tas, ValueBuffer);
            else
                PutStdErr(MSG_ASSOC_NOT_FOUND, ONEARG, tas);
        }

        return(rc);
}



/***    SetAssoc - controls adding/changing a file association
 *
 *  Purpose:
 *      Add/replace a file association
 *
 *  int SetAssoc(HKEY hKeyClasses, TCHAR *fileext, TCHAR *filetype)
 *
 *  Args:
 *      hKeyClasses - handle to HKEY_LOCAL_MACHINE\Software\Classes key
 *      fileext - file extension string to associate
 *      filetype - file type associate
 *
 *  Returns:
 *      SUCCESS if the association could be added/replaced.
 *      FAILURE otherwise.
 *
 */

int SetAssoc(hKeyClasses, fileext, filetype)
HKEY hKeyClasses;
TCHAR *fileext ;
TCHAR *filetype ;
{
    int rc;
    int i;
    DWORD cb;

    if (filetype==NULL || *filetype==NULLC) {
        rc = RegDeleteKey(hKeyClasses, fileext);
        if (rc != 0)
            PutStdErr(MSG_ASSOC_NOT_FOUND, ONEARG, fileext);
    }
    else {
        rc = RegSetValue(hKeyClasses, fileext, REG_SZ, filetype, _tcslen(filetype));
        if (rc == 0) {
            try {
                SHChangeNotify( SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL );
                cmd_printf( Fmt16, fileext, filetype );
            } except (DosErr = GetExceptionCode( ), EXCEPTION_EXECUTE_HANDLER) {
            }

        }
        else
            PutStdErr(MSG_ERR_PROC_ARG, ONEARG, fileext);
    }

    return rc;
}


/***    eFType - execute an FType command
 *
 *  Purpose:
 *      To set/modify the file types stored in the registry under the
 *      HKEY_LOCAL_MACHINE\Software\Classes key
 *
 *  int eFType(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the set command
 *
 *  Returns:
 *      If setting and the command is syntactically correct, whatever SetFType()
 *      returns.  Otherwise, FAILURE.
 *
 *      If displaying, SUCCESS is always returned.
 *
 */

int eFType(n)
struct cmdnode *n ;
{
    if (glBatType != CMD_TYPE)  {
        //  if set command is executed from .bat file OR entered at command prompt
        return( SetLastRetCodeIfError(FTypeWork( n )));
    }
    else {
        return( LastRetCode = FTypeWork( n ) );
    }
}

int FTypeWork(n)
struct cmdnode *n ;
{
        HKEY hKeyClasses;
        TCHAR *tas ;    /* Tokenized argument string    */
        TCHAR *wptr ;   /* Work pointer                 */
        int i ;                 /* Work variable                */
        int rc ;


        rc = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Classes"), &hKeyClasses);
        if (rc) {
            return rc;
        }

        tas = TokStr(n->argptr, ONEQSTR, TS_WSPACE|TS_SDTOKENS) ;
        if (!*tas)
                rc = DisplayFType(hKeyClasses, NULL) ;

        else {
                for (wptr = tas, i = 0 ; *wptr ; wptr += mystrlen(wptr)+1, i++)
                        ;
                /* If too many parameters were given, the second parameter */
                /* wasn't an equal sign, or they didn't specify a string   */
                /* return an error message.                                */
                if ( i > 3 || *(wptr = tas+mystrlen(tas)+1) != EQ ||
                    !mystrlen(mystrcpy(tas, StripQuotes(tas))) ) {
                        if (i==1) {
                            rc =DisplayFType(hKeyClasses, tas);
                        } else {
                            PutStdErr(MSG_BAD_SYNTAX, NOARGS);
                            rc = FAILURE ;
                        }
                } else {
                        rc = SetFType(hKeyClasses, tas, wptr+2) ;
                }
        } ;

        RegCloseKey(hKeyClasses) ;

        return rc;
}




/***    DisplayFType - display a specific file type or all
 *
 *  Purpose:
 *      To display a specific file type or all
 *
 *  int DisplayFType( hKeyClasses, tas )
 *
 *  Returns:
 *      SUCCESS if all goes well
 *      FAILURE if it runs out of memory or cannot lock the env. segment
 */

int DisplayFType(hKeyClasses, tas)
HKEY hKeyClasses;
TCHAR *tas;
{
        int i;
        int rc;
        HKEY hKeyOpenCmd;
        TCHAR NameBuffer[MAX_PATH];
        TCHAR ValueBuffer[MAX_PATH];
        TCHAR *vstr ;
        DWORD cb, j, Type;

        if (tas == NULL) {
            for (i=0;;i++) {
                rc =RegEnumKey(hKeyClasses, i, NameBuffer, sizeof( NameBuffer ) / sizeof( TCHAR ));
                if (rc != 0) {
                    if (rc==ERROR_NO_MORE_ITEMS)
                        rc = SUCCESS;
                    break;
                } else
                if (NameBuffer[0] != DOT) {
                    j = _tcslen(NameBuffer);
                    _tcscat(NameBuffer, TEXT("\\Shell\\Open\\Command"));
                    _tcscpy(ValueBuffer,TEXT("*** no open command defined ***"));
                    rc = RegOpenKey(hKeyClasses, NameBuffer, &hKeyOpenCmd);
                    if (!rc) {
                        NameBuffer[j] = TEXT('\0');
                        cb = sizeof(ValueBuffer);
                        rc = RegQueryValueEx(hKeyOpenCmd, TEXT(""), NULL, &Type, (LPBYTE)ValueBuffer, &cb);
                        RegCloseKey(hKeyOpenCmd);
                    }

                    if (!rc) {
                        cmd_printf(Fmt16, NameBuffer, ValueBuffer);
                    }
                }
                if (CtrlCSeen) {
                    return(FAILURE);
                }
            }
        }
        else {
            if (*tas == DOT) {
                PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, tas);
                return ERROR_INVALID_NAME;
            }

            tas = EatWS(tas, NULL);
            if ((vstr = mystrrchr(tas, ' ')) != NULL)
                *vstr = NULLC;

            _sntprintf(NameBuffer, MAX_PATH, TEXT("%s\\Shell\\Open\\Command"), tas);
            rc = RegOpenKey(hKeyClasses, NameBuffer, &hKeyOpenCmd);
            if (rc) {
                PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, tas);
                return rc;
            }

            cb = sizeof(ValueBuffer);
            rc = RegQueryValueEx(hKeyOpenCmd, TEXT(""), NULL, &Type, (LPBYTE)ValueBuffer, &cb);
            if (rc == 0) {
                ValueBuffer[ (cb / sizeof( TCHAR )) - 1 ];
                cmd_printf(Fmt16, tas, ValueBuffer);
            }
            else
                PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, tas);
        }

        return(rc);
}



/***    SetFType - controls adding/changing the open command associated with a file type
 *
 *  Purpose:
 *      Add/replace an open command string associated with a file type
 *
 *  int SetFType(HKEY hKeyOpenCmd, TCHAR *filetype TCHAR *opencmd)
 *
 *  Args:
 *      hKeyClasses - handle to HKEY_LOCAL_MACHINE\Software\Classes
 *      filetype - file type name
 *      opencmd - open command string
 *
 *  Returns:
 *      SUCCESS if the file type could be added/replaced.
 *      FAILURE otherwise.
 *
 */

int SetFType(hKeyClasses, filetype, opencmd)
HKEY hKeyClasses;
TCHAR *filetype ;
TCHAR *opencmd ;
{
    HKEY hKeyOpenCmd;
    TCHAR NameBuffer[MAX_PATH];
    TCHAR c, *s;
    DWORD Disposition;
    int rc;
    int i;
    DWORD cb;

    _sntprintf(NameBuffer, MAX_PATH, TEXT("%s\\Shell\\Open\\Command"), filetype);
    rc = RegOpenKey(hKeyClasses, NameBuffer, &hKeyOpenCmd);
    if (rc) {
        if (opencmd==NULL || *opencmd==NULLC) {
            PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, filetype);
            return rc;
        }

        s = NameBuffer;
        while (TRUE) {
            while (*s && *s != TEXT('\\')) {
                s += 1;
            }
            c = *s;
            *s = TEXT('\0');
            rc = RegCreateKeyEx(hKeyClasses,
                                NameBuffer,
                                0,
                                NULL,
                                0,
                                (REGSAM)MAXIMUM_ALLOWED,
                                NULL,
                                &hKeyOpenCmd,
                                &Disposition
                               );
            if (rc) {
                PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, filetype);
                return rc;
            }

            if (c == TEXT('\0')) {
                break;
            }

            *s++ = c;
            RegCloseKey(hKeyOpenCmd);
        }
    }

    if (opencmd==NULL || *opencmd==NULLC) {
        rc = RegDeleteKey(hKeyOpenCmd, NULL);
        if (rc != 0)
            PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, filetype);
    }
    else {
        rc = RegSetValueEx(hKeyOpenCmd, TEXT(""), 0, REG_EXPAND_SZ, (LPBYTE)opencmd, (_tcslen(opencmd)+1)*sizeof(TCHAR));
        if (rc == 0)
            cmd_printf(Fmt16, filetype, opencmd);
        else
            PutStdErr(MSG_ERR_PROC_ARG, ONEARG, filetype);
    }

    RegCloseKey(hKeyOpenCmd);
    return rc;
}


typedef
NTSTATUS
(NTAPI *PNTQUERYINFORMATIONPROCESS)(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

HMODULE hNtDllModule;
PNTQUERYINFORMATIONPROCESS lpNtQueryInformationProcess;

WORD
GetProcessSubsystemType(
    HANDLE hProcess
    )
{
    PIMAGE_NT_HEADERS NtHeader;
    PPEB PebAddress;
    PEB Peb;
    SIZE_T SizeOfPeb;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInfo;
    BOOL b;
    PVOID ImageBaseAddress;
    LONG e_lfanew;
    WORD Subsystem;

    Subsystem = IMAGE_SUBSYSTEM_UNKNOWN;
    if (hNtDllModule == NULL) {
        hNtDllModule = LoadLibrary( TEXT("NTDLL.DLL") );
        if (hNtDllModule != NULL) {
            lpNtQueryInformationProcess = (PNTQUERYINFORMATIONPROCESS)
                                          GetProcAddress( hNtDllModule,
                                                          "NtQueryInformationProcess"
                                                        );
            }
        else {
            hNtDllModule = INVALID_HANDLE_VALUE;
            }
        }

    if (lpNtQueryInformationProcess != NULL) {
        //
        // Get the Peb address
        //

        Status = (*lpNtQueryInformationProcess)( hProcess,
                                                 ProcessBasicInformation,
                                                 &ProcessInfo,
                                                 sizeof( ProcessInfo ),
                                                 NULL
                                               );
        if (NT_SUCCESS( Status )) {
            PebAddress = ProcessInfo.PebBaseAddress;

            //
            // Read the subsystem type from the Peb
            //

            if (ReadProcessMemory( hProcess,
                                   PebAddress,
                                   &Peb,
                                   sizeof( Peb ),
                                   &SizeOfPeb
                                 )
               ) {
                //
                // See if we are running on a system that has the image subsystem
                // type captured in the PEB.  If so use it.  Otherwise go the slow
                // way and try to get it from the image header.
                //
                if (SizeOfPeb >= FIELD_OFFSET( PEB, ImageSubsystem ) &&
                    ((UINT_PTR)Peb.ProcessHeaps - (UINT_PTR)PebAddress) > FIELD_OFFSET( PEB, ImageSubsystem )
                   ) {
                    Subsystem = (WORD)Peb.ImageSubsystem;
                    }
                else {
                    //
                    // read e_lfanew from imageheader
                    //

                    if (ReadProcessMemory( hProcess,
                                           &((PIMAGE_DOS_HEADER)Peb.ImageBaseAddress)->e_lfanew,
                                           &e_lfanew,
                                           sizeof( e_lfanew ),
                                           NULL
                                         )
                       ) {
                        //
                        // Read subsystem version info
                        //

                        NtHeader = (PIMAGE_NT_HEADERS)((PUCHAR)Peb.ImageBaseAddress + e_lfanew);
                        if (ReadProcessMemory( hProcess,
                                               &NtHeader->OptionalHeader.Subsystem,
                                               &Subsystem,
                                               sizeof( Subsystem ),
                                               NULL
                                             )
                           ) {
                            }
                        }
                    }
                }
            }
        }

    return Subsystem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cfile.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cfile.c

Abstract:

    File manipulation support

--*/

#include "cmd.h"

#define Wild(spec)  ((spec)->flags & (CI_NAMEWILD))

extern int LastRetCode ;
extern jmp_buf CmdJBuf2 ;

extern TCHAR Fmt19[], Fmt17[];
extern TCHAR CurDrvDir[] ;

extern TCHAR YesChar, NoChar ;

extern TCHAR *SaveDir ;

extern TCHAR PathChar, TmpBuf[], SwitChar;

extern unsigned DosErr ;
extern unsigned flgwd ;                 /* M021 */

extern int LastRetCode ;

extern BOOL CtrlCSeen;
extern PTCHAR    pszTitleCur;
extern BOOLEAN  fTitleChanged;

//
// Internal prototypes
//
PCPYINFOSetFsSetSaveDir() ;

/***    ErrorDisplayAndJumnp - handle errors
 *
 *  Purpose:
 *      eRename and eMove error handler.  Returns to routine via longjmp
 *
 *  ErrorDisplayAndJump(unsigned int errmsg)
 *
 *
 *  Args:
 *      errmsg - the error message to print
 *
 */

void ErrorDisplayAndJump( unsigned int errmsg )
{

    PutStdErr( errmsg, NOARGS );

    RestoreSavedDirectory( );

    longjmp( CmdJBuf2, 1 ) ;
}


/*
** This routine returns the longest pathlength possible from the input path
** It assumes that the input path is a buffer that it can extend by a
** wildcard '\*' to search the file, if it is a directory.
** The input path must be fully qualified, eg: "c:\winnt\system32\kernel32.dll"
**
** Input:
**      pPath   fully qualified Pathname
**      pCch    pointer to length of pathname
** Returns:
**      TRUE    succeeded, pCch contains length
**      FALSE   error occurred
*/
BOOL
GreatestLength(
              TCHAR       *pPath,
              int         *pCch
              )
{
    WIN32_FIND_DATA     fd;
    HANDLE              hFind;
    DWORD               err;
    int                 cch;
    int                 cchThis;
    DWORD               attr;
    TCHAR               *pLast;
    BOOL        MoreFiles;

    /* assume a file, or empty directory */
    *pCch = cch = _tcslen(pPath) - 2;   /* _tcslen(TEXT("C:")) */

    if ((attr=GetFileAttributes(pPath)) == 0xffffffff) {
        PutStdErr(GetLastError(), NOARGS);
        return FALSE;
    }
    if ( !(attr & FILE_ATTRIBUTE_DIRECTORY)) {   /* if just a file... */
        return TRUE;
    }

    /* path is a directory, search it ... */

    pLast = pPath + _tcslen(pPath);
    if (*(pLast-1) == BSLASH) {
        *pLast = STAR;
        *(pLast+1) = NULLC;
    } else {
        *pLast = BSLASH;
        *(pLast+1) = STAR;
        *(pLast+2) = NULLC;
    }

    if ((hFind=FindFirstFile(pPath, &fd)) == INVALID_HANDLE_VALUE) {
        //
        // Check that failure was not due to some system error such
        // as an abort on access to floppy
        //
        err = GetLastError();
        FindClose(hFind);
        if (err != ERROR_FILE_NOT_FOUND && err != ERROR_NO_MORE_FILES) {
            PutStdErr(err, NOARGS);
            return FALSE;
        }
        return TRUE;
    }

    MoreFiles = TRUE;
    do {
        if (!_tcscmp(fd.cFileName, TEXT(".")))
            continue;
        if (!_tcscmp(fd.cFileName, TEXT("..")))
            continue;
        if (_tcslen( fd.cFileName ) == 0) {
            continue;
        }

        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
            TCHAR       path[MAX_PATH];

            _tcscpy(path, pPath);
            *(path+_tcslen(path)-1) = NULLC;    /* zap asterisk */
            _tcscat(path, fd.cFileName);
            if (!GreatestLength(path, &cchThis))
                break;

            *pCch = max(*pCch, cch + cchThis);
        } else {
            *pCch = max(*pCch, (int) _tcslen(fd.cFileName));
        }

    } while ( MoreFiles = FindNextFile(hFind, &fd) );

    err = GetLastError();
    FindClose(hFind);

    if ( MoreFiles ) {
        return FALSE;
    } else if ( err != ERROR_NO_MORE_FILES ) {
        PutStdErr(err, NOARGS);
        return FALSE;
    }

    return TRUE;
}

void
RestoreSavedDirectory( void )
{
    if (SaveDir) {
        mystrcpy( CurDrvDir, SaveDir );
        SaveDir = NULL;
    }
}

BOOL
GetPromptOkay(
             const TCHAR *arg,
             BOOL *promptokay

             )
{
    BOOL Result;
    const TCHAR *p, *p1;

    Result = TRUE;
    if (arg != NULL) {
        p = arg;
        while (*p && *p <= SPACE)
            p += 1;
        p1 = p;
        while (*p1 && *p1 > SPACE)
            p1 += 1;
        if (!_tcsnicmp(p, TEXT("/Y"),(UINT)(p1-p)))
            *promptokay = FALSE;
        else
            if (!_tcsnicmp(p, TEXT("/-Y"),(UINT)(p1-p)))
            *promptokay = TRUE;
        else
            Result = FALSE;
    }

    return Result;
}

int eCopy(n)
struct cmdnode *n ;
{
    return(LastRetCode = copy(n->argptr)) ;
}


int eDelete(n)
struct cmdnode *n ;
{
    int DelWork() ;

    return(LastRetCode = DelWork(n->argptr));
}


/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: eRename                                            */
/*                                                                     */
/* DESCRIPTIVE NAME:  Rename Internal Command                          */
/*                                                                     */
/* FUNCTION: Rename files and subdirectories.  Wildcards only applies  */
/*           to file names.                                            */
/*                                                                     */
/* NOTES:    @@5*                                                      */
/*                                                                     */
/* ENTRY POINT: eRename                                                */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:                                                              */
/*            n - the parse tree node containing the rename command    */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return SUCCESS to the caller.                               */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to the caller.                               */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       RenWork     - Worker routine for rename.                      */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       None                                                          */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

int eRename(n)
struct cmdnode *n ;
{
    int RenWork();                           /* @@ */

    return(LastRetCode = RenWork( n ));      /* @@ */
}


/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: RenWork                                            */
/*                                                                     */
/* DESCRIPTIVE NAME:  Rename Internal Command Worker                   */
/*                                                                     */
/* FUNCTION: Rename files and subdirectories.  Wildcards only applies  */
/*           to file names.                                            */
/*                                                                     */
/* NOTES:    @@5*                                                      */
/*                                                                     */
/* ENTRY POINT: RenWork                                                */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:                                                              */
/*            n - The parse tree node containing the rename command    */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return SUCCESS to the caller.                               */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to the caller.                               */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       ffirst          - Find the first matching specified file.     */
/*       fnext           - Find the next matching specified file handle*/
/*       findclose - Close the file with the specified file handle,    */
/*                       hnFirst which is given by ffirst or fnext.    */
/*       TokStr          - Tokenize argument strings.                  */
/*       wildcard_rename - Obtain name based on wildcard specification.*/
/*       SetFsSetSaveDir - Save the current directory.                 */
/*       GetDir          - Get the specified directory.                */
/*       ChangeDir       - Change to the specified directory.          */
/*       PutStdErr - Displays an error message.                        */
/*       Wild      - check if the arg contains wild card.              */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       None                                                          */
/*        DOSMOVE      - Rename file and directory names.              */
/*        DOSCASEMAP   - Change lower case character to upper case.    */
/*        DOSFILEMODE  - Get attribute of specified file.              */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

int RenWork(n)                                  /* @@ */
struct cmdnode *n ;
{
    TCHAR *arg1 ;                          /* Ptr to 1st arg          */
    TCHAR *arg2 ;                          /* Ptr to 2nd arg          */
    PCPYINFO a1info ;                       /* Holds arg1 fspec info   */
    PCPYINFO SetFsSetSaveDir();
    TCHAR Source[MAX_PATH];
    TCHAR bufdst[MAX_PATH];                        /* path of destination file*/
    TCHAR Replacement[MAX_PATH];
    int wlen;                              /* length of source path       */
    int rc;                                        /* return code             */
    HANDLE hnFirst ;                               /* Findfirst handle            */
    unsigned attr ;
    unsigned i;                                    /* Temp Return Code        */
    TCHAR *j ;                                     /* Temp Ptr to dir name    */
    unsigned wild_flag ;                           /* wildcard flag           */
    TCHAR pcstr[3] ;
    unsigned retval = SUCCESS;

    DEBUG((FCGRP, RELVL, "RENAME: arptr = `%ws'", n->argptr)) ;

    if (setjmp(CmdJBuf2))
        return(FAILURE) ;

    /* There should be only two arguments */
    if (!*(arg1 = TokStr(n->argptr, NULL, TS_NOFLAGS)) ||
        !*(arg2 = arg1 + mystrlen(arg1) + 1) ||
        *(arg2 + mystrlen(arg2) +1)) {             /* @@5g */

        ErrorDisplayAndJump( MSG_BAD_SYNTAX );
    }

    mystrcpy( arg1, StripQuotes(arg1) );       /* 509 */
    mystrcpy( arg2, StripQuotes(arg2) );       /* 509 */

    if ((a1info = SetFsSetSaveDir(arg1)) == (PCPYINFO)FAILURE) {
        ErrorDisplayAndJump( DosErr );
    }

    mystrcpy( Source, CurDrvDir );

    mystrcpy(bufdst,CurDrvDir);                    /*  save path of dest   */

    wlen = mystrlen( Source );                       /*  get len of src path */

    if ( (a1info->buf->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
        mystrcpy(&Source[wlen],a1info->fnptr);
    } else {
        Source[--wlen] = NULLC ;
        bufdst[wlen] = NULLC ;
    }

    /* if not wild since    */
    if (!Wild(a1info)) {
        a1info->buf->dwFileAttributes =
        GetFileAttributes( StripQuotes(Source) );

        if (a1info->buf->dwFileAttributes == -1 ) {
            ErrorDisplayAndJump( GetLastError( )) ;
        }
    }


    if (*(arg2+1) == COLON ||
        mystrchr(arg2,PathChar)) {
        ErrorDisplayAndJump( MSG_BAD_SYNTAX );
    }

    /**********************************************/
    /*  M009 - Always specifiy drive, filename,   */
    /*         and extension.  Note, it is        */
    /*         assumed that SaveDir always starts */
    /*         with a drive letter                */
    /**********************************************/

    Replacement[0] = CurDrvDir[0] ;      /* @@5h */
    Replacement[1] = COLON ;


    /**********************************************/
    /* Set flag whether arg1 contains             */
    /* wildcard or not.                           */
    /**********************************************/

    pcstr[0] = STAR ;
    pcstr[1] = QMARK ;
    pcstr[2] = NULLC ;
    wild_flag = ((mystrcspn(arg1,pcstr)) < mystrlen(arg1)) ;

    /**********************************************/
    /* Issue ffirst for a file name               */
    /**********************************************/
    if ( !ffirst(Source, attr = FILE_ATTRIBUTE_ARCHIVE, a1info->buf, &hnFirst )) {

        /*********************************************/
        /* Issue ffirst for a directory name         */
        /*********************************************/
        if (!ffirst(Source, attr = FILE_ATTRIBUTE_DIRECTORY, a1info->buf, &hnFirst )) {
            if (DosErr == ERROR_NO_MORE_FILES) {
                DosErr = ERROR_FILE_NOT_FOUND;
            }
            ErrorDisplayAndJump( DosErr );
        } else {

            if (wild_flag) {
                findclose( hnFirst );
                ErrorDisplayAndJump( MSG_BAD_SYNTAX );
            }
        }
    }

    Source[wlen] = NULLC;                            /* make filename = NULL */

    rc = 0 ;                                         /* @@5 */

    do {

        if (CtrlCSeen) {
            findclose(hnFirst) ;
            RestoreSavedDirectory( );

            return(FAILURE);
        }

        /**********************************************/
        /* if the file attribute of Source is         */
        /* directory then concatenate arg2 after the  */
        /* last "\" character of bufdst               */
        /**********************************************/

        if ( a1info->buf->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {       /* @@5c*/
            j = mystrrchr(bufdst,PathChar) ;          /* @@5 */

            if ( !j ) {
                ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
            }

            *(++j) = NULLC;

            if ( (mystrlen(arg2) + 1 + mystrlen(bufdst)) > MAX_PATH ) {
                ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
            }

            mystrcpy(j,arg2);                             /* @@5 */

            bufdst[mystrlen(bufdst)] = NULLC ;            /* @@5 */
        }                                                /* @@5 */
        else {                                                /* @@5 */
            mystrcpy(&Source[wlen],a1info->buf->cFileName);

            wildcard_rename( Replacement, arg2, &Source[wlen], MAX_PATH );

            if ( (wlen + 1 + mystrlen( Replacement )) > MAX_PATH ) {
                ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
            }

            mystrcpy(&bufdst[wlen],&Replacement[0]); /*@@4 @J1*/
        }

        /**********************************************/
        /* Rename a file or directory                 */
        /**********************************************/
        DEBUG((FCGRP, RELVL, "RENAME: src:`%ws', dst:`%ws'", Source, bufdst)) ;
        if ( !MoveFile( Source, bufdst ) ) {
            /**********************************************/
            /* rename fails                               */
            /**********************************************/

            i = GetLastError();
            if (i == ERROR_ALREADY_EXISTS) {
                i = MSG_DUP_FILENAME_OR_NOT_FD;
            }

            rc = i ;                            /* @@5 Save the error code*/
            PutStdErr(rc,NOARGS);               /* @@5 Put our err message*/
        }

    } while (fnext(a1info->buf, attr, hnFirst ));

    /**********************************************/
    /* No more file is found                      */
    /**********************************************/
    findclose(hnFirst) ;

    RestoreSavedDirectory( );

    return( rc ? FAILURE : SUCCESS ); /* @@5 */
}


/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: eMove                                              */
/*                                                                     */
/* DESCRIPTIVE NAME: Move Internal Command                             */
/*                                                                     */
/* FUNCTION: Parse the parameter passed and                            */
/*           moves one or more files from directory to another         */
/*           directory on the same drive.  If you prefer you can give  */
/*           the files different names.                                */
/*                                                                     */
/* NOTES:    ( New routine for Relaese 1.2 )  @@5*                     */
/*                                                                     */
/* ENTRY POINT: eMove                                                  */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:                                                              */
/*            n - the parse tree node containing the copy command      */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return SUCCESS to the caller.                               */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to caller.                                   */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       MoveParse   - parse move command parameter                    */
/*       Move        - routine which actually call DosMove to move     */
/*                     file or directory.                              */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       None                                                          */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

int eMove(n)
struct cmdnode *n ;
{
    unsigned i;
    BOOL PromptOnOverwrite;
    TCHAR arg1[MAX_PATH] ;       /* Ptr to 1st arg   */
    TCHAR arg2[MAX_PATH] ;       /* Ptr to 2nd arg   */
    PCPYINFO a1info ;     /* Holds arg1 fspec info   */
    unsigned int is_dest_dir;    /* generated by MoveParse(), used by Move() */

    DEBUG((FCGRP, RELVL, "RENAME: arptr = `%ws'", n->argptr)) ;

    if (setjmp(CmdJBuf2))
        return(LastRetCode = FAILURE) ;

    //
    // Get default prompt okay flag from COPYCMD variable.  Allow
    // user to override with /Y or /-Y switch.  Always assume /Y
    // if command executed from inside batch script or via CMD.EXE
    // command line switch (/C or /K)
    //
    if (SingleBatchInvocation || SingleCommandInvocation || CurrentBatchFile != 0)
        PromptOnOverwrite = FALSE;      // Assume /Y
    else
        PromptOnOverwrite = TRUE;       // Assume /-Y

    /* MoveParse parses the command line parameters to arg1   */
    /* and arg1. In addition, a1info holds the fspec          */
    /* information for arg1.                                  */
    /* Based on arg1 and arg2, Move moves file(s)/directory.  */
    /* Move uses a1info to determine that arg1 contains       */
    /* wildcard.                                              */

    i = MoveParse( n,
                   &PromptOnOverwrite,
                   arg1,
                   arg2,
                   &a1info,
                   &is_dest_dir,
                   MAX_PATH,
                   MAX_PATH
                 );
    if (!i) {
        i = Move( arg1, arg2, PromptOnOverwrite, a1info, is_dest_dir ) ;
    }

    return(LastRetCode = i) ;
}


/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: MoveParse                                          */
/*                                                                     */
/* DESCRIPTIVE NAME: Move Parser                                       */
/*                                                                     */
/* FUNCTION: Move Internal Function Parser                             */
/*                                                                     */
/* NOTES:    This parser breaks up the command line information        */
/*           into two parameters.                                      */
/*           ( New routine for Relaese 1.2 )  @@5*                     */
/*                                                                     */
/* ENTRY POINT: MoveParse                                              */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:                                                              */
/*            n - the parse tree node containing the move command      */
/*                                                                     */
/* OUTPUT:   ptr1 - pointer to [drive:][path]filename to be moved from */
/*           ptr2 - pointer to [path]filename to be moved to           */
/*           a1info - pointer to cpyinfo which has arg1 fspec info     */
/*           is_dest_dir - flag used by Move()                         */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return SUCCESS to the caller.                               */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to the caller.                               */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*         TokStr       - Tokenize argument strings.                   */
/*         FullPath     - Figure out the full path for a file.         */
/*         SetFsSetSaveDir - Save current directory.                   */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*         DOSQFILEMODE - Get file mode of the specified file/dir.     */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/
int MoveParse(n, promptokay, source, target , a1info, is_dest_dir, sizpath1, sizpath2)
struct cmdnode *n ;
BOOL *promptokay ;
TCHAR *source ;                  /* Ptr to source file(s)/directory name  */
TCHAR *target ;                  /* Ptr to target file(s)/directory name  */
PCPYINFO* a1info ;               /* Holds arg1 fspec information          */
unsigned int *is_dest_dir;       /* to pass to move                       */
unsigned sizpath1;               /* size of source buffer                 */
unsigned sizpath2;               /* size of target buffer                 */

{       PCPYINFO SetFsSetSaveDir() ;
    TCHAR *arg1 ;                   /* Ptr to 1st arg          */
    TCHAR *arg2 ;                   /* Ptr to 2nd arg          */
    TCHAR *p1;
    TCHAR *p2;
    TCHAR arg22[MAX_PATH] ;        /* Ptr to modified 2nd arg */
    unsigned i;
    unsigned concat_flag ;
    unsigned att ; 
/*509*/unsigned arg1len, arg2len;

    //
    // Get default prompt okay flag from COPYCMD variable.  Allow
    // user to override with first token after command.
    //
    GetPromptOkay(MyGetEnvVarPtr(TEXT("COPYCMD")), promptokay);
    arg1 = TokStr(n->argptr, NULL, TS_NOFLAGS);
    if (GetPromptOkay(arg1, promptokay))
        while (*arg1++)
            ;

    /* Get arg1.  If fail to get arg1, display error message. */
    if (!*arg1) {
        ErrorDisplayAndJump( MSG_BAD_SYNTAX );
    }
/*509*/
    else if ( (arg1len = mystrlen(arg1)) > MAX_PATH) {
        ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
    }

    /*CurDrvDir = current directory or directory which is specified in arg1*/
/*509*/mystrcpy( arg1, StripQuotes( arg1 ) );
    if (((*a1info) = SetFsSetSaveDir(arg1)) == (PCPYINFO)FAILURE) {
        ErrorDisplayAndJump( DosErr );
    }
    /*                   */
    /* Get arg2 out of arg1 */

    arg2 = arg1 + arg1len + 1;

    if ( !(*arg2) ) {

        arg22[0] = SaveDir[0];    /* get current drive */
        arg22[1] = COLON;
        arg22[2] = NULLC;
    } else if (*(arg2 + mystrlen(arg2) + 1)) {  /* @@5g */
        ErrorDisplayAndJump( MSG_BAD_SYNTAX );
    }
/*509*/
    else if ( (arg2len = mystrlen(arg2)) > MAX_PATH) {
        ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
    } else {
        /* If arg2 conatins a drive name, display an error message. */

/*509*/
        mystrcpy

        ( arg2, StripQuotes( arg2 ) );

        // UNC names fix

        if (  ( *(arg2+1) != COLON )  &&  ( ! (  ( *arg2 == BSLASH ) && ( *(arg2+1) == BSLASH )  )  )  ) {
            arg22[0] = SaveDir[0];    /* get drive we're using */
            arg22[1] = COLON;
            arg22[2] = NULLC;
            if ((mystrlen(arg22) + mystrlen(arg2)+1) > MAX_PATH) {
                ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
            }
            mystrcat( arg22, arg2 ) ;

        } else

        {
            mystrcpy(arg22,arg2) ;
        }
    }


    /* source = complete path for arg1 */

    if ( i = FullPath(source, arg1,sizpath1) ) {
        ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
    }

    //
    // If preserve file name portion from arg1 as FullPath will map *. to * which
    // is not what the user wants.
    //
    if (!((*a1info)->buf->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        p1 = mystrrchr(source,PathChar) ;
        if (p1 != NULL)
            p1 += 1;
        else
            p1 = source;
        p2 = mystrrchr((*a1info)->fnptr,PathChar) ;
        if (p2 == NULL)
            p2 = (*a1info)->fnptr;
        mystrcpy(p1, p2);
    }

    /* target = complete path for arg2 */


    if ( i = FullPath(target, arg22,sizpath2) ) {
        ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
    }


    concat_flag = FALSE ;
    DosErr = NO_ERROR ;
    SetLastError(NO_ERROR);
    *is_dest_dir = 0;

    if (*lastc(target) == PathChar) {          /* test for last non DBCS character path char  @@5@J3 */
        concat_flag = TRUE ;
        target[mystrlen(target)-1] = NULLC ;
    };

    if ( (att = GetFileAttributes( target )) != -1 ) {
        if (att & FILE_ATTRIBUTE_DIRECTORY) {   /* if target is a directory, copy the file      */
            /* name from source.                            */
            *is_dest_dir = 1;
            concat_flag = TRUE ;
        };
    } else if ( (DosErr = GetLastError()) &&
                ( ( DosErr != ERROR_FILE_NOT_FOUND ) &&
                  ( DosErr !=  ERROR_PATH_NOT_FOUND )    )   ) {
        ErrorDisplayAndJump( DosErr );
    };

    if (concat_flag) {
        arg1 = mystrrchr(source,PathChar);
        if ((mystrlen(arg1) + mystrlen(target) + 1) > MAX_PATH) {
            ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
        }
        mystrcat( target, arg1 ) ;
    };

    return(SUCCESS) ;
}


BOOL
MyMoveFile(
          TCHAR *src,
          TCHAR *dst,
          BOOL *promptokay,
          BOOL *file_moved
          )
{
    DWORD dwFlags;

    dwFlags = MOVEFILE_COPY_ALLOWED;
    if (!*promptokay) {
        dwFlags |= MOVEFILE_REPLACE_EXISTING;
    }

    *file_moved = FALSE;
    if (!MoveFileEx(src, dst, dwFlags)) {
        if (GetLastError() == ERROR_ALREADY_EXISTS) {
            switch (PromptUser(dst, MSG_MOVE_COPY_OVERWRITE, MSG_NOYESALL_RESPONSE_DATA)) {
            case 0: // No
                return TRUE;
                break;
            case 2: // All
                *promptokay = FALSE;
            default: // Yes
                dwFlags |= MOVEFILE_REPLACE_EXISTING;
                return(*file_moved = MoveFileEx(src, dst, dwFlags));
                break;
            }
        }

        return FALSE;
    } else {
        *file_moved = TRUE;
        return TRUE;
    }
}

/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: Move                                               */
/*                                                                     */
/* DESCRIPTIVE NAME: Move Process                                      */
/*                                                                     */
/* FUNCTION: Moves one or more files from directory to another         */
/*           directory on the same drive.  If you prefer you can give  */
/*           the files different names.                                */
/*                                                                     */
/* NOTES:    ( New routine for Release 1.2 )  @@5*                     */
/*                                                                     */
/* ENTRY POINT: eMove                                                  */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:    ptr1 - pointer to [drive:][path]filename to be moved from */
/*           ptr2 - pointer to [path]filename to be moved to           */
/*           a1info - pointer to cpyinfo which has arg1 fspec info     */
/*           is_dest_dir - from MoveParse()                            */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return Success to the caller.                               */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return error code from DosMove API.                         */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       ChangeDir - Change back to the original directory.            */
/*       ffirst - Find the first file which matches the specified      */
/*                file name that may contain * or ?.                   */
/*       fnext  - Find the next file which matches the specified       */
/*                file name that may contain * or ?.                   */
/*       findclose - Close the file with the specified file handle,    */
/*                       hnFirst which is given by ffirst or fnext.    */
/*       PutStdErr - Displays an error message.                        */
/*       PutStdOut - Displays a message.                               */
/*       Wild      - check if the arg contains wild card.              */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       DOSMOVE     -  move directories and files.                    */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

int
Move( arg1, arg2, promptokay, a1info, is_dest_dir )
TCHAR *arg1 ;                         /* Ptr to 1st arg          */
TCHAR *arg2 ;                         /* Ptr to 2nd arg          */
BOOL promptokay ;
PCPYINFO a1info ;              /* Holds arg1 fspec info   */
unsigned int is_dest_dir;             /* flag if set--> dest. is a dir */

{
    unsigned attr ;
    unsigned i, n;
    unsigned long number_of_files_moved ;
    TCHAR Source[MAX_PATH];      /* path of source file     */
    TCHAR bufdst[MAX_PATH];      /* path of destination file*/
    HANDLE hnFirst ;                                  /* Findfirst handle    */
    TCHAR *j, *k,*l;                      /* Tmp Ptr                 */
    unsigned wild_flag ;                  /* wildcard flag           */
    BOOL file_moved;
    unsigned save_error ;                 /* Saved error code        */
    TCHAR pcstr[3] ;
    unsigned rc;
    int retc;
    int how_many_src=0;                   /* =f_RET_DIR if dir; =0 if none; = <number matching src files> else */
    char type_format_dest=0;              /* decide on how to format dest */
    char fl_move_once=0;                  /* if =1 execute move once only */



    how_many_src = f_how_many (arg1, (ULONG) (attr=FILE_ATTRIBUTE_ARCHIVE) );


    /**********************************************/
    /* Set flag whether arg1 contains             */
    /* wildcard or not.                           */
    /**********************************************/

    pcstr[0] = STAR ;
    pcstr[1] = QMARK ;
    pcstr[2] = NULLC ;
    wild_flag = ((mystrcspn(arg1,pcstr))
                 < mystrlen(arg1)) ;



    // Decide on what to do depending on: <1.multiple/single src; 2.is dest dir ?>

    if (how_many_src == f_RET_DIR) {
        if (is_dest_dir) {
            if (!MyMoveFile(arg1, arg2, &promptokay, &file_moved) ) {

                i = GetLastError();

                if (i == ERROR_ALREADY_EXISTS) {
                    i = MSG_DUP_FILENAME_OR_NOT_FD;
                }

                ErrorDisplayAndJump( i );
            } else {
                RestoreSavedDirectory( );

                return(SUCCESS) ;
            }
        } else {
            type_format_dest = 2;
            fl_move_once = 1;
        }
    }

    else if (how_many_src > 1 ) {
        if (is_dest_dir) {
            type_format_dest = 1;
            fl_move_once = 0;
        } else {
            ErrorDisplayAndJump( MSG_MOVE_MULTIPLE_FAIL );
        }
    }

    else { // single source or source doesn't exist
        if (is_dest_dir) {
            type_format_dest = 1;
            fl_move_once = 1;
        } else {
            type_format_dest = 2;
            fl_move_once = 1;
        }
    }


    /**********************************************/
    /* Issue ffirst for a file name               */
    /**********************************************/

/*M006*/        if (!ffirst(arg1, attr = FILE_ATTRIBUTE_ARCHIVE, a1info->buf, &hnFirst )) {

        /**********************************************/
        /* Issue ffirst for a directory name          */
        /**********************************************/

        rc = ffirst(arg1, attr = FILE_ATTRIBUTE_DIRECTORY, a1info->buf, &hnFirst ) ;

        if ( !rc) {
            /**********************************************/
            /* No file or directory which arg1            */
            /* specifies found                            */
            /**********************************************/

            if (!rc && DosErr == ERROR_NO_MORE_FILES) { /* @@5e */
                rc = ERROR_FILE_NOT_FOUND;
            } else if (wild_flag) {
                rc = MSG_DUP_FILENAME_OR_NOT_FD;
            } else {
                rc = DosErr;
            }
            ErrorDisplayAndJump( rc );
        }
    }

    number_of_files_moved = 0 ;                     /* Reset the counter to zero */
    save_error = NO_ERROR ;                         /* Reset error code to zero  */
    mystrcpy(Source,arg1) ;
    j = mystrrchr(Source,PathChar) ;
    ++j;                                            /* get to filename area      */


    do {
        if (CtrlCSeen) {
            findclose(hnFirst) ;
            RestoreSavedDirectory( );

            return(FAILURE);
        }

        /**********************************************/
        /* build bufdst                               */
        /**********************************************/


        mystrcpy(j,a1info->buf->cFileName) ;

        mystrcpy(bufdst,arg2);

        if (type_format_dest == 1 ) {
            l = mystrrchr(bufdst,PathChar);
            ++l;
            mystrcpy(l,a1info->buf->cFileName) ;
            if ((mystrlen(bufdst) ) > MAX_PATH) {
                ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME ) ;
            }
        }


        /**********************************************/
        /* check to see if filename is legal          */
        /**********************************************/

        {
            TCHAR TempBuffer[MAX_PATH];
            DWORD Length;
            
            Length = GetFullPathName( bufdst, MAX_PATH, TempBuffer, NULL );
            if (Length == 0 || Length >= MAX_PATH) {
                goto badness;
            }
            
            n = _tcslen( TempBuffer );
            
            Length = GetFullPathName( Source, MAX_PATH, TempBuffer, NULL );
            if (Length == 0 || Length >= MAX_PATH) {
                goto badness;
            }
            if (!GreatestLength( TempBuffer, &i))
                continue;

            i -= _tcslen( TempBuffer );
        }
        
        if (n + i > MAX_PATH) {
            i = ERROR_FILENAME_EXCED_RANGE;
            goto badness2;
        }

        /**********************************************/
        /* Move a file or directory                   */
        /**********************************************/


        if (!MyMoveFile(Source, bufdst, &promptokay, &file_moved)) {

            /**********************************************/
            /* Move fails                                 */
            /**********************************************/
            badness:
            i = GetLastError();
            badness2:

            if (i == ERROR_ALREADY_EXISTS) {
                i = MSG_DUP_FILENAME_OR_NOT_FD;
            }

            save_error = i ;         /* Save the error code      */

            PutStdErr(i, NOARGS);    /* Put out an error message */

            i = mystrlen(bufdst) ;

            if ( bufdst[--i] == DOT ) {             /* @@5a     */
                bufdst[i] = 0 ;                         /* @@5a     */
            }                                          /* @@5a     */
            /* @@5a     */
/*509*/if (!_tcsicmp(Source,bufdst)) {           /* @@5a     */
                break ;                                 /* @@5a     */
            }                                          /* @@5a     */

        } else
            if (file_moved) {
            number_of_files_moved += 1;
            if ( wild_flag ) {           /* If wild card is used */
                cmd_printf(Fmt17,Source); /* display the file name*/
            }

        }

        if (fl_move_once)
            break;

    } while (fnext(a1info->buf, attr, hnFirst ));


    /**********************************************/
    /*           No more files to be found        */
    /**********************************************/

    findclose(hnFirst) ;
    RestoreSavedDirectory( );

    /**********************************************/
    /* Display the total number of file(s) moved  */
    /**********************************************/

    if ( (a1info->buf->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 ) {
        PutStdOut(MSG_FILES_MOVED, ONEARG,
                  argstr1(TEXT("%9d"), (unsigned long)number_of_files_moved)) ;
    }

    return(save_error == NO_ERROR ? SUCCESS : FAILURE) ;
}


int
eTitle (

       IN  struct cmdnode *pcmdnode
       ) {

    LPTSTR NewTitle;
    if (!pszTitleCur) {

        pszTitleCur = HeapAlloc(GetProcessHeap(), 0, MAX_PATH*sizeof(TCHAR) + 2*sizeof(TCHAR));
        if (pszTitleCur == NULL) {

            PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
            return( FAILURE );

        }

    }

    if (mystrlen(pcmdnode->argptr) >= MAX_PATH) {

        PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
        return( FAILURE );

    }

    NewTitle = EatWS(pcmdnode->argptr, NULL);
    if (NewTitle && *NewTitle) {
        mystrcpy(pszTitleCur,NewTitle);
    }
    SetConsoleTitle(pszTitleCur);

    //
    // This insures that ResetConTitle does not undo what
    // we have just done
    //
    fTitleChanged = FALSE;
    return( SUCCESS );
}

/***    eStart - Entry point for Start routine
 *
 *  Purpose:
 *      to call Start and pass it a pointer to the command line
 *      arguments
 *
 *  Args:
 *      a pointer to the command node structure
 *
 */

int eStart( n )                     /* @@ */
struct cmdnode *n;                  /* @@ */
{                                       /* @@ */
    DBG_UNREFERENCED_PARAMETER( n );
    return( Start(n->argptr) );
}                                   /* @@ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cinfo.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cinfo.c

Abstract:

    Information command support

--*/

#include "cmd.h"

#define TYPEBUFSIZE     80
#define TYPEREADSIZE    512

extern UINT CurrentCP;

extern unsigned DosErr ;

extern unsigned tywild;     /* @@5@J1 type wild cards   */

extern TCHAR CurDrvDir[] ;

extern TCHAR VolSrch[] ;         /* M006 - Search string for Volume ID      */
extern TCHAR AppendStr[] ;

extern TCHAR Fmt26[], Fmt25[];

extern unsigned LastRetCode;
extern BOOL CtrlCSeen;

struct FSVol {
        unsigned long SerNum ;          /* Volume serial number            */
        TCHAR len ;                      /* Volume name len (excludes \0)   */
        TCHAR name[257] ;                /* Volume name asciz               */
        };

int ZScanA(BOOL flag, PCHAR buf, PULONG buflen, PULONG skip);

/**************** START OF SPECIFICATIONS ***********************/
/*                                                              */
/* SUBROUTINE NAME: eDirectory                                  */
/*                                                              */
/* DESCRIPTIVE NAME: Begin execution of the DIR command         */
/*                                                              */
/* FUNCTION: To list out the files on a disk.  eDirectory will  */
/*           be called whenever the user enters the DIR command */
/*           on the command line.  DIR will continue if it      */
/*           encounters an invalid argument.                    */
/*                                                              */
/* NOTES:                                                       */
/*                                                              */
/* ENTRY POINT: eDirectory                                      */
/*     LINKAGE: Near                                            */
/*                                                              */
/* INPUT: n - the parse tree node containing the DIR command    */
/*                                                              */
/* EXIT-NORMAL: return SUCCESS if no errors occur               */
/*                                                              */
/* EXIT-ERROR:  return FAILURE otherwise                        */
/*                                                              */
/* EFFECTS: None.                                               */
/*                                                              */
/* INTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*      Dir - lists out the files in a directory                */
/*                                                              */
/* EXTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*                                                              */
/**************** END OF SPECIFICATIONS *************************/

int eDirectory(n)
struct cmdnode *n ;
{
    return(LastRetCode = Dir(n->argptr)) ;
}




/***    eType - begin the execution of a Type command
 *
 *  Purpose:
 *      To type the contents of an arbitrary number of files.
 *
 *  int eType(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree note containing the type command
 *
 *  Returns:
 *      SUCCESS if all of the files were successfully typed.
 *      FAILURE otherwise.
 *
 */

int eType(n)
struct cmdnode *n ;
{

 //
 // Removed LTA_NOMATCH from flags. This caused a *.xxx to call the TyWork
 // function which would think that *.xxx is a file and try to open it.
 //
 return(LastRetCode = LoopThroughArgs(n->argptr, TyWork, LTA_EXPAND | LTA_CONT | LTA_NOMATCH)) ;
}




/***    TyWork - display a file
 *
 *  Purpose:
 *      Write the contents of the file specified in fspec to stdout.
 *      Output ends when all of fspec has been written or a ^Z is found in
 *      fspec.
 *
 *  int TyWork(TCHAR *fspec)
 *
 *  Args:
 *      fspec - the name of the file to write out
 *
 *  Returns:
 *      SUCCESS if the file was written.
 *      FAILURE otherwise, such as inability to allocate a temporary buffer
 */

int TyWork(TCHAR *fspec) {
    TCHAR       fspec_temp[MAX_PATH];
    TCHAR       TypeBufW[TYPEREADSIZE*3];
    CHAR        TypeBuf[TYPEREADSIZE+1];
    ULONG       result;
    BOOL        flag;
    const TCHAR       *bptr;
    ULONG       fDevice = 0;
    ULONG       maxbytes = 0xFFFFFFFF ; // max file size
    ULONG       bytestoctlz ;           // Number of bytes read
    ULONG       bytesread ;             // Number of bytes read
    ULONG       byteswrit ;             // Number of bytes read
    ULONG       brcopy ;                // Bytes to copy
    CRTHANDLE   fh ;                    // File handle
    int         first_read;             // first read on file for wild

    int         TypeBufSize;
    int         rc;
    LONG        bWrite;
    CHAR       *pType;
#ifdef UNICODE
    WCHAR       wc;
    BOOL        fUnicode=FALSE;
#endif // UNICODE

    TypeBufSize = TYPEREADSIZE;

    first_read = TRUE;      /* set flag to test for wilds   @@5@J1 */

    DEBUG((ICGRP, TYLVL, "TYWORK: fspec = `%ws'", fspec)) ;
    if ((fh = Copen(fspec, O_RDONLY)) == BADHANDLE) {

        bptr = MyGetEnvVarPtr(AppendStr);
        if ( bptr != NULL &&
             SearchPath( bptr,
                         (TCHAR *)fspec,
                         NULL,
                         (unsigned)MAX_PATH,
                         (TCHAR *)fspec_temp,
                         NULL ) != 0) {
           fh = Copen(fspec_temp, O_RDONLY);
        }
    }

    if ( fh == BADHANDLE )  {

        if (DosErr == ERROR_INVALID_NAME) {
            DosErr = ERROR_FILE_NOT_FOUND;
        }
        PrtErr(DosErr) ;
        rc = FAILURE;
        goto TypeExit;

    }

    /************************************************************/
    /*  M004 - Added code to get max file size if not device    */
    /************************************************************/

    bptr = (TCHAR*)TypeBuf;               /* Copy of original pointer*/
    if (!FileIsDevice(fh)) {
        maxbytes = GetFileSize(CRTTONT(fh), NULL) ; /* Get file size  */
        SetFilePointer(CRTTONT(fh), 0L, NULL, FILE_BEGIN) ;   /* Return pointer*/
        fDevice = 1 ;           /* Set no device flag      */
        DEBUG((ICGRP,TYLVL,"TYWORK: Is file, size=%d", maxbytes)) ;
    }

    do {
        if (CtrlCSeen) {
            Cclose(fh) ;
            rc = FAILURE;
            goto TypeExit;
        }
        if (!ReadFile(CRTTONT(fh), TypeBuf, TypeBufSize, (LPDWORD)&bytesread, NULL)) {
            DosErr = GetLastError();
            PutStdErr(DosErr, NOARGS);
            break;
        }
        if (bytesread == 0) {
            break;
        }

#ifdef UNICODE
        if (first_read) {
            fUnicode = *(LPWSTR)TypeBuf == BYTE_ORDER_MARK;
            if (fUnicode) {
                bytesread -= sizeof( TCHAR );
                MoveMemory( TypeBuf, TypeBuf + sizeof( TCHAR ), bytesread );
            }
        }
#endif // UNICODE

        bytestoctlz = bytesread;
#ifdef UNICODE
        if (fUnicode) {
            if (first_read) {
                DEBUG((ICGRP, TYLVL, "TYWORK: file is unicode")) ;
            }
            brcopy = bytesread / sizeof(TCHAR);
        } else
#endif // UNICODE
        if (FileIsConsole(STDOUT)
#ifdef UNICODE
              || fOutputUnicode
#endif // UNICODE
           ) {
            PCHAR   pch = TypeBuf;

            brcopy = bytesread;
            while (brcopy > 0) {
                if (is_dbcsleadchar(*pch)) {
                    pch++;
                    if (--brcopy == 0) {
                        if (!ReadFile(CRTTONT(fh), pch, 1, &brcopy, NULL)) {
                            DosErr = GetLastError();
                            PutStdErr(DosErr, NOARGS);
                            Cclose(fh) ;
                            rc = SUCCESS;
                            goto TypeExit;
                        }
                        bytesread++;
                        bytestoctlz = bytesread;
                        break;
                    }
                }
                pch++;
                brcopy--;
            }

            result = 0;
            flag = ZScanA(TRUE, (PCHAR)TypeBuf, &bytestoctlz, &result);
            DEBUG((ICGRP, TYLVL, "TYWORK: converting %d bytes to unicode", flag?bytesread:bytestoctlz)) ;

            if ( (!flag) && (bytestoctlz == 0) )
                break;

            brcopy = MultiByteToWideChar(CurrentCP, 0,
                (LPCSTR)TypeBuf, flag?bytesread:bytestoctlz,
                (LPWSTR)TypeBufW, TypeBufSize*2);
            if (brcopy == 0) {
                DEBUG((ICGRP, TYLVL, "TYWORK: Error converting to Unicode: %d", GetLastError())) ;
                brcopy = TypeBufSize*2;
            }
            bptr = TypeBufW;
        } else {
            brcopy = bytesread;
        }

        if (first_read) {
            if (tywild)
                PutStdErr(MSG_TYPE_FILENAME, ONEARG, fspec);
            first_read = FALSE;
        }

        DEBUG((ICGRP, TYLVL, "TYWORK: bytesread = %d, brcopy = %d", bytesread, brcopy)) ;

        bWrite = brcopy;
        pType  = (CHAR *)bptr;
        while ( bWrite > 0 ) {

            ULONG bToWrite = min( TYPEBUFSIZE, bWrite );

            if ( bToWrite == 0 ) {
                break;
            }

            if (CtrlCSeen) {
                Cclose(fh) ;
                rc = FAILURE;
                goto TypeExit;
            }

            if (FileIsConsole(STDOUT)) {

                DEBUG((ICGRP, TYLVL, "TYWORK: Writing to console")) ;
                flag = WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE), pType, bToWrite, &byteswrit, NULL);
                if (flag == 0 || byteswrit != bToWrite) {
                    goto try_again;
                }
                bWrite -= byteswrit;
                byteswrit *= sizeof(TCHAR);
                pType  += byteswrit;

#ifdef UNICODE
            } else if (fOutputUnicode || fUnicode) {

                if ( fUnicode ) {
                    wc = *((TCHAR*)pType + bToWrite);
                    *((TCHAR*)pType + bToWrite) = UNICODE_NULL;
                }

                DEBUG((ICGRP, TYLVL, "TYWORK: Writing unicode text to file")) ;
                flag = MyWriteFile(
                  STDOUT,       /* device         */
                  pType,                 /* bytes          */
                  bToWrite * sizeof(TCHAR), /* bytes to write */
                  &byteswrit);      /* bytes actually written   */

                if ( fUnicode ) {
                    *((TCHAR*)pType + bToWrite) = wc;
                }

                bWrite -= byteswrit/sizeof(TCHAR);
                pType  += byteswrit;
#endif // UNICODE

            } else {

try_again:
                DEBUG((ICGRP, TYLVL, "TYWORK: Writing dbcs text to file")) ;
                flag = WriteFile(CRTTONT(STDOUT), pType, bToWrite, &byteswrit, NULL);
                bWrite -= byteswrit;
                pType  += byteswrit;
                byteswrit *= sizeof(TCHAR);
            }

            DEBUG((ICGRP, TYLVL, "TYWORK: flag = %d, byteswrit = %d", flag, byteswrit)) ;
            if (flag == 0 || byteswrit != bToWrite*sizeof(TCHAR)) {
                DosErr = GetLastError();
                if (!DosErr) {
                    DosErr = ERROR_DISK_FULL ;
                }
                if (FileIsDevice(STDOUT)) {
                    PutStdErr(ERROR_WRITE_FAULT, NOARGS);
                } else {
                    if (FileIsPipe(STDOUT)) {
                        PutStdErr(MSG_CMD_INVAL_PIPE, NOARGS);
                    } else {
                        PrtErr(DosErr);
                    }
                    Cclose(fh);
                    rc = FAILURE;
                    goto TypeExit;
                }
            }

        }

        if (fDevice) {  /* If not device            */
            /* Get new position ptr     */
            fDevice = SetFilePointer(CRTTONT(fh), 0, NULL, FILE_CURRENT);
        }

        /*************************************************/
        /* Added check below for current file position   */
        /*   at original EOF                             */
        /*************************************************/

    } while((bytesread == bytestoctlz) && (maxbytes > fDevice));

    Cclose(fh) ;
    rc = SUCCESS;

TypeExit:
    return(rc) ;
}




/***    eVersion - execute the Version command
 *
 *  Purpose:
 *      To print DOS version information.
 *
 *  int eVersion(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the version command. N will be NULL
 *          if eVersion was called from PrintPrompt().
 *
 *  Returns:
 *      SUCCESS always.
 *
 */

int
eVersion(
    struct cmdnode *n
    )
{
    TCHAR VersionFormat[32];

    GetVersionString( VersionFormat, sizeof( VersionFormat ) / sizeof( VersionFormat[0] ));
    
    if (n)
        cmd_printf( CrLf );

    PutStdOut( MSG_MS_DOS_VERSION,
               ONEARG,
               VersionFormat );
    if (n)
        cmd_printf( CrLf );


    return(LastRetCode = SUCCESS) ;
}


/**************** START OF SPECIFICATIONS ***********************/
/*                                                              */
/* SUBROUTINE NAME: eVolume                                     */
/*                                                              */
/* DESCRIPTIVE NAME: Begin execution of the VOL command         */
/*                                                              */
/* FUNCTION: eVolume will print out the volume label and serial */
/*           number for an arbitrary number of drives, and will */
/*           continue if it encounters an invalid argument.     */
/*           This routine is called when the user enters VOL    */
/*           on the command line.                               */
/*                                                              */
/* NOTES:                                                       */
/*                                                              */
/* ENTRY POINT: eVolume                                         */
/*     LINKAGE: Near                                            */
/*                                                              */
/* INPUT: n - a parse tree node containing the VOL command      */
/*                                                              */
/* EXIT-NORMAL: returns SUCCESS if the command was well formed, */
/*              and was executed successfully.                  */
/*                                                              */
/* EXIT-ERROR:  returns FAILURE otherwise.                      */
/*                                                              */
/* EFFECTS: None.                                               */
/*                                                              */
/* INTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*      LoopThroughArgs - breaks up command line, calls VolWork */
/*                                                              */
/* EXTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*                                                              */
/**************** END OF SPECIFICATIONS *************************/

int eVolume(n)
struct cmdnode *n ;
{

    return(LastRetCode = LoopThroughArgs(n->argptr, VolWork, LTA_CONT|LTA_NULLOK)) ;
}


/**************** START OF SPECIFICATIONS ***********************/
/*                                                              */
/* SUBROUTINE NAME: VolWork                                     */
/*                                                              */
/* DESCRIPTIVE NAME: Display the volume ID of a drive           */
/*                                                              */
/* FUNCTION: VolWork will print the volume label and serial     */
/*           number of a specific drive.                        */
/*                                                              */
/* NOTES:                                                       */
/*                                                              */
/* ENTRY POINT: VolWork                                         */
/*     LINKAGE: Near                                            */
/*                                                              */
/* INPUT: drvspec - a pointer to a character specifying the     */
/*                  drive to print the information for.  If the */
/*                  character is null, the information for the  */
/*                  current drive is displayed.                 */
/*                                                              */
/* EXIT-NORMAL: returns SUCCESS if the command was executed     */
/*              successfully                                    */
/*                                                              */
/* EXIT-ERROR:  returns FAILURE otherwise                       */
/*                                                              */
/* EFFECTS: None.                                               */
/*                                                              */
/* INTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*      PutStdOut - Writes output to standard out               */
/*      PutStdErr - Writes output to standard error             */
/*                                                              */
/* EXTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*      DOSQFSINFO                                              */
/*                                                              */
/**************** END OF SPECIFICATIONS *************************/

int VolWork(drvspec)
TCHAR *drvspec ;
{
        struct FSVol vol ;
        unsigned DNum ;
        TCHAR c ;
        TCHAR VolumeRoot[] = TEXT(" :\\");
        DWORD Vsn[2];
        BOOL b;

        DEBUG((ICGRP, VOLVL, "VOLWORK: drvspec = `%ws'", drvspec)) ;

        if (*drvspec == NULLC) {
                DNum = 0 ;
                c = (TCHAR) _totupper(CurDrvDir[0]) ;
        } else if ((mystrlen(drvspec) == 2) &&
                   *(drvspec+1) == COLON &&
                   _istalpha(*drvspec)) {
                c = (TCHAR) _totupper(*drvspec) ;
                DNum = (unsigned)(c - 0x40) ;
        } else {
                cmd_printf(CrLf);
                PutStdErr(ERROR_INVALID_DRIVE, NOARGS) ;          /* M013    */
                return(FAILURE) ;
        } ;

        VolumeRoot[0] = c;
        b = GetVolumeInformation(VolumeRoot,vol.name,sizeof(vol.name),Vsn,NULL,NULL,NULL,0);

        if (!b) {

           DEBUG((ICGRP, VOLVL, "VOLWORK: GetVolumeInformation ret'd %d", GetLastError())) ;

           cmd_printf(CrLf);
           if (GetLastError() == ERROR_NOT_READY)
                   PutStdErr(ERROR_NOT_READY, NOARGS) ;
           else
                   PutStdErr(GetLastError(), NOARGS) ;                       /* @@5a */
           return(FAILURE) ;
        } else {
           if (b && vol.name[0]) {
/* M013 */    PutStdOut(MSG_DR_VOL_LABEL, TWOARGS,
                        argstr1( TEXT("%c"), (ULONG_PTR)c),
                        vol.name ) ;
           }
           else {
/* M013 */    PutStdOut(MSG_HAS_NO_LABEL, ONEARG,
                          argstr1( TEXT("%c"), (ULONG_PTR)c)) ;
           }
/* @@5 */  if (b) {           // FIX, FIX
              TCHAR Buffer[128];
              _sntprintf(Buffer, 128, Fmt26,
                          (Vsn[0] & 0xffff0000)>>16, (Vsn[0] & 0xffff));
              PutStdOut(MSG_DR_VOL_SERIAL, ONEARG, Buffer );
/* @@5 */  }
        } ;

        return(SUCCESS) ;
}

/****************************************************************
 *
 *  ZScanA - scan data in an arbitrary segment for ^Zs
 *
 *   Purpose:
 *      If flag is on, scan buffer for a ^Z.  If it is found, update the
 *      buffer length and return 0.  Otherwise return -1.
 *      Double byte characters are taken into account.
 *
 *   int ZScanA(int flag, long buffer, unsigned *buflenptr, int *skip_first)
 *
 *   Args:
 *      flag - nonzero if any scanning is to be done
 *      buffer - a long pointer to the buffer to use
 *      buflenptr - ptr to the length of buffer
 *      skip_first - ptr to an integer. The initial value of *skip_first
 *              must be 0 on the first call when scanning a file. There
 *              after, the caller leaves *skip_first alone. ZScan uses
 *              the variable to remember if the first byte of the next
 *              buffer is going to be the second have of a double
 *              byte character.
 *
 *   Returns:
 *      See above.
 *
 *   Notes:
 *      This routine will need to be modified once the MMU code is in the DOS.
 *      macro is defined in cmd.h.
 *
 *
 *      ZScanA
 *      if (flag) then
 *              buffer = buffer + *skip_first
 *              dbcs_flag = 0
 *              count = *buflenptr - *skip_first
 *              use rep scanb to find first ^Z in buffer
 *              if (no ^z was found)
 *                      goto FZSNoZ
 *              do {
 *                      count++;
 *                      buffer--;
 *              } until (*buffer < 0x80 || count = *buflenptr);
 *              while (--count > 0) loop
 *                      if (dbcs_flag == 0) then
 *                              if (*buffer == ^Z) then
 *                                      *buflenptr = count
 *                                      return(0)
 *                              else if (*buffer is a dbcs_lead_char) then
 *                                      dbcs_flag = 1
 *                              endif
 *                              endif
 *                      else
 *                              dbcs_flag = 0
 *                      buffer = buffer + 1
 *                      count = count - 1
 *              end loop
 *              *skip_first = dbcs_flag
 *      endif
 *FZSNoZ:
 *      return(-1)
 *----
 ****************************************************************/


int
ZScanA(BOOL flag, PCHAR buf, PULONG buflen, PULONG skip)
{
    PCHAR pbuf = buf,
          bufend;

    CHAR  c0;

    if ( flag ) {
        pbuf += *skip;
        bufend = buf + *buflen - *skip;

        while (pbuf < bufend) {
            if (is_dbcsleadchar(c0=*pbuf))
                pbuf++;
            if (c0 == CTRLZ)
                break;
            pbuf++;
        }

        if (c0 == CTRLZ) {
            // *buflen = pbuf+1 - buf;
            *buflen = (ULONG)(pbuf - buf);
            *skip = 0;
            return(0);
        }
        else {
            *skip = (ULONG)(pbuf - bufend);
        }
    }
    return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cinit.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cinit.c

Abstract:

    Initialization

--*/

#include "cmd.h"

#if CMD_DEBUG_ENABLE
unsigned DebGroup=0;
unsigned DebLevel=0;
#endif

TCHAR CurDrvDir[MAX_PATH] ;     /* Current drive and directory            */
BOOL SingleBatchInvocation = FALSE ;
BOOL SingleCommandInvocation = FALSE;
BOOLEAN  fDisableUNCCheck = FALSE;
int      cmdfound = -1;         /* @@5  - command found index              */
int      cpyfirst = TRUE;       /* @@5  - flag to ctrl DOSQFILEMODE calls  */
int      cpydflag = FALSE;      /* @@5  - flag save dirflag from las DQFMDE*/
int      cpydest  = FALSE;      /* @@6  - flag to not display bad dev msg  */
int      cdevfail = FALSE;      /* @@7  - flag to not display extra emsg   */
#ifdef UNICODE
BOOLEAN  fOutputUnicode = FALSE;/* Unicode/Ansi output */
#endif // UNICODE

BOOLEAN  fEnableExtensions = FALSE;
BOOLEAN  fDefaultExtensions = TRUE;
BOOLEAN  fDelayedExpansion = FALSE;

BOOLEAN ReportDelayLoadErrors = TRUE;

unsigned tywild = 0;          /* flag to tell if wild type args    @@5 @J1 */
int array_size = 0 ;     /* original array size is zero        */
CPINFO CurrentCPInfo;
UINT CurrentCP;

WORD    wDefaultColor = 0;      // default is whatever console currently has
                                // but default can be overriden by the registry.
TCHAR chCompletionCtrl = SPACE; // Default is no completion (must be Ctrl character)
TCHAR chPathCompletionCtrl = SPACE;



VOID InitLocale( VOID );

extern TCHAR ComSpec[], ComSpecStr[] ;       /* M021 */
extern TCHAR PathStr[], PCSwitch, SCSwitch, PromptStr[] ;
extern TCHAR PathExtStr[], PathExtDefaultStr[];
extern TCHAR BCSwitch ;  /* @@ */
extern TCHAR QCSwitch ;  /* @@dv */
extern TCHAR UCSwitch;
extern TCHAR ACSwitch;
extern TCHAR XCSwitch;
extern TCHAR YCSwitch;
extern TCHAR DevNul[], VolSrch[] ;       /*  M021 - To set PathChar */

extern TCHAR SwitChar, PathChar ;        /*  M000 - Made non-settable       */
extern int Necho ;                      /*  @@dv - true if /Q for no echo  */

extern TCHAR MsgBuf[];

extern struct envdata CmdEnv;
extern struct envdata * penvOrig;
struct envdata OrigEnv;

extern TCHAR TmpBuf[] ;                                      /* M034    */

extern TCHAR ComSpec[];

TCHAR *CmdSpec = &ComSpec[1];                                    /* M033    */

extern unsigned DosErr ;             /* D64 */

//
// TRUE if the ctrl-c thread has been run.
//
BOOL CtrlCSeen;

//
// Set TRUE when it is ok the print a control-c.
// If we are waiting for another process this will be
// FALSE
BOOLEAN fPrintCtrlC = TRUE;

//
// console mode at program startup time. Used to reset mode
// after running another process.
//
DWORD   dwCurInputConMode;
DWORD   dwCurOutputConMode;

//
// Initial Title. Used for restoration on abort etc.
// MAX_PATH was arbitrary
//
PTCHAR    pszTitleCur;
PTCHAR    pszTitleOrg;
BOOLEAN  fTitleChanged = FALSE;     // title has been changed and needs to be  reset

//
// used to gate access to ctrlcseen flag between ctrl-c thread
// and main thread
//
CRITICAL_SECTION    CtrlCSection;
LPCRITICAL_SECTION  lpcritCtrlC;

//
// Used to set and reset ctlcseen flag
//
VOID    SetCtrlC();
VOID    ResetCtrlC();

Handler(
    IN ULONG CtrlType
    )
{
    if ( (CtrlType == CTRL_C_EVENT) ||
         (CtrlType == CTRL_BREAK_EVENT) ) {

        //
        // Note that we had a ^C event
        //

        SetCtrlC();

        //
        //  Display the ^C if we are enabled and if we're not in a batch file
        //
        
        if (fPrintCtrlC && CurrentBatchFile != NULL) {

            fprintf( stderr, "^C" );
            fflush( stderr );

        }
        return TRUE;
    } else {
        return FALSE;
    }
}

/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: Init                                               */
/*                                                                     */
/* DESCRIPTIVE NAME: CMD.EXE Initialization Process                    */
/*                                                                     */
/* FUNCTION: Initialization of CMD.EXE.                                */
/*                                                                     */
/* NOTES:                                                              */
/*                                                                     */
/* ENTRY POINT: Init                                                   */
/*                                                                     */
/* INPUT: None.                                                        */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return the pointer to command line.                         */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return NULL string.                                         */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/
/***    Init - initialize Command
 *
 *  Purpose:
 *      Save current SIGINTR response (SIGIGN or SIGDEF) and set SIGIGN.
 *      If debugging
 *          Set DebGroup & DebLevel
 *      Get Environment and init CmdEnv structure (M034)
 *      Check for any switches.
 *      Make a version check.
 *          If version out of range
 *          Print error message.
 *          If Permanent Command
 *              Loop forever
 *          Else
 *              Exit.
 *      Save the current drive and directory.
 *      Check for other command line arguments.
 *      Set up the environment.
 *      Always print a bannner if MSDOS version of Command.
 *      Return any "comline" value found.
 *
 *  TCHAR *Init()
 *
 *  Args:
 *
 *  Returns:
 *      Comline (it's NULL if NOT in single command mode).
 *
 *  Notes:
 *      See CSIG.C for a description of the way ^Cs and INT24s are handled
 *      during initialization.
 *      M024 - Brought functionality for checking non-specific args into
 *      init from routines CheckOtherArgs and ChangeComSpec which have
 *      been eliminated.
 *
 */

BOOL Init(
    TCHAR *InitialCmds[]
    )
{
#if 0                          /* Set debug group and level words */

        int fh;
        PTCHAR nptr;

        nptr = TmpBuf;
        nptr = EatWS(nptr, NULL);
        nptr = mystrchr(nptr, TEXT(' '));
        nptr = EatWS(nptr, NULL);

        //
        // Assume a non-zero debugging group
        //
        DebGroup = hstoi(nptr) ;                        /* 1st debug arg   */
        if (DebGroup) {
            for (fh=0 ; fh < 2 ; fh++) {
                if (fh == 1)
                    DebLevel = hstoi(nptr) ;        /* 2nd debug arg   */
                while(*nptr && !_istspace(*nptr)) {       /* Index past it   */
                    ++nptr ;
                }
                nptr = EatWS(nptr, NULL) ;
            }
        }

        DEBUG((INGRP, RSLVL, "INIT: Debug GRP=%04x  LVL=%04x", DebGroup, DebLevel)) ;
        mystrcpy(TmpBuf, nptr) ;                  /* Elim from cmdline       */
#endif
        //
        // Initialize Critical Section to handle access to
        // flag for control C handling
        //
        lpcritCtrlC = &CtrlCSection;
        InitializeCriticalSection(lpcritCtrlC);
        ResetCtrlC();

        SetConsoleCtrlHandler(Handler,TRUE);

        //
        // Make sure we have the correct console modes.
        //
        ResetConsoleMode();

#ifndef UNICODE
        setbuf(stdout, NULL);           /* Don't buffer output       @@5 */
        setbuf(stderr, NULL);                                     /* @@5 */
        _setmode(1, O_BINARY);        /* Set output to text mode   @@5 */
        _setmode(2, O_BINARY);                                  /* @@5 */
#endif

        CmdEnv.handle = GetEnvironmentStrings();

        GetRegistryValues(InitialCmds);

        mystrcpy(TmpBuf, GetCommandLine());
        LexCopy( TmpBuf, TmpBuf, mystrlen( TmpBuf ) );  /* convert dbcs spaces */

        GetDir(CurDrvDir, GD_DEFAULT) ;

        SetUpEnvironment() ;

        /* Check cmdline switches  */
        CheckSwitches(InitialCmds, TmpBuf);

        if (CurDrvDir[0] == BSLASH && CurDrvDir[1] == BSLASH) {
#if 0
            if (fEnableExtensions) {
                struct cmdnode *n ;

                PutStdErr(MSG_SIM_UNC_CURDIR, ONEARG, CurDrvDir);
                n = mkstr(sizeof(*n));
                n->argptr = mkstr((_tcslen(CurDrvDir)+1) * sizeof(TCHAR));
                _tcscpy(n->argptr, CurDrvDir);
                GetWindowsDirectory(CurDrvDir, sizeof(CurDrvDir)/sizeof(TCHAR));
                ChangeDir2(CurDrvDir, TRUE);
                ePushDir(n);
            } else
#endif
            if (!fDisableUNCCheck) {
                PutStdErr(MSG_NO_UNC_INITDIR, ONEARG, CurDrvDir);
                GetWindowsDirectory(CurDrvDir, sizeof(CurDrvDir)/sizeof(TCHAR));
                ChangeDir2(CurDrvDir, TRUE);
            }
        }

        //
        // Get current CodePage Info.  We need this to decide whether
        // or not to use half-width characters.  This is actually here
        // in the init code for safety - the Dir command calls it before
        // each dir is executed, because chcp may have been executed.
        //
        GetCPInfo((CurrentCP=GetConsoleOutputCP()), &CurrentCPInfo);

        InitLocale();

        pszTitleCur = HeapAlloc(GetProcessHeap(), 0, MAX_PATH*sizeof(TCHAR) + 2*sizeof(TCHAR));
        pszTitleOrg = HeapAlloc(GetProcessHeap(), 0, MAX_PATH*sizeof(TCHAR) + 2*sizeof(TCHAR));
        if ((pszTitleCur != NULL) && (pszTitleOrg != NULL)) {

            if (GetConsoleTitle(pszTitleOrg, MAX_PATH)) {
                mystrcpy(pszTitleCur, pszTitleOrg);
            } else {
                *pszTitleCur = 0;
                *pszTitleOrg = 0;
            }
        }

        if (!SingleCommandInvocation) {
            if (FileIsConsole(STDOUT)) {
#ifndef WIN95_CMD
                CONSOLE_SCREEN_BUFFER_INFO  csbi;

                if (!wDefaultColor) {
                    if (GetConsoleScreenBufferInfo( GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {
                        wDefaultColor = csbi.wAttributes;
                    }
                }
#endif // WIN95_CMD
                if (wDefaultColor) {
                    SetColor( wDefaultColor );
                }
            }
        }

        /* Print banner if no command string on command line */
        if (!InitialCmds[2]) {
            TCHAR VersionFormat[32];

            GetVersionString( VersionFormat, sizeof( VersionFormat ) / sizeof( VersionFormat[0] ));
        
            PutStdOut( MSG_MS_DOS_VERSION,
                       ONEARG,
                       VersionFormat );
            
            cmd_printf( CrLf );
            
            PutStdOut( MSG_COPYRIGHT, NOARGS ) ;
            
            if (fDefaultExtensions) {
                //
                // DaveC says say nothing to user here.
                //
                // PutStdOut(MSG_EXT_ENABLED_BY_DEFAULT, NOARGS);
            } else
            if (fEnableExtensions) {
                PutStdOut(MSG_EXT_ENABLED, NOARGS) ;
            }
        }

        DEBUG((INGRP, RSLVL, "INIT: Returning now.")) ;

#ifndef WIN95_CMD
        {
            hKernel32 = GetModuleHandle( TEXT("KERNEL32.DLL") );
            lpCopyFileExW = (LPCOPYFILEEX_ROUTINE)
                GetProcAddress( hKernel32, "CopyFileExW" );
    
            lpIsDebuggerPresent = (LPISDEBUGGERPRESENT_ROUTINE)
                GetProcAddress( hKernel32, "IsDebuggerPresent" );
    
            lpSetConsoleInputExeName = (LPSETCONSOLEINPUTEXENAME_ROUTINE)
                GetProcAddress( hKernel32, "SetConsoleInputExeNameW" );
        }

#endif // WIN95_CMD

        return(InitialCmds[0] != NULL || InitialCmds[1] != NULL || InitialCmds[2] != NULL);
}


void GetRegistryValues(
    TCHAR *InitialCmds[]
    )
{
    long rc;
    HKEY hKey;
    ULONG ValueBuffer[ 1024 ];
    LPBYTE lpData;
    DWORD cbData;
    DWORD dwType;
    DWORD cchSrc, cchDst;
    PTCHAR s;
    int i;
    HKEY PredefinedKeys[2] = {HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER};

    if (fDefaultExtensions) {
        fEnableExtensions = TRUE;
    }

    for (i=0; i<2; i++) {
        rc = RegOpenKey(PredefinedKeys[i], TEXT("Software\\Microsoft\\Command Processor"), &hKey);
        if (rc) {
            continue;
        }

        dwType = REG_NONE;
        lpData = (LPBYTE)ValueBuffer;
        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("DisableUNCCheck"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                fDisableUNCCheck = (BOOLEAN)(*(PULONG)lpData != 0);
                }
            else
            if (dwType == REG_SZ) {
                fDisableUNCCheck = (BOOLEAN)(_wtol((PWSTR)lpData) == 1);
            }
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("EnableExtensions"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                fEnableExtensions = (BOOLEAN)(*(PULONG)lpData != 0);
                }
            else
            if (dwType == REG_SZ) {
                fEnableExtensions = (BOOLEAN)(_wtol((PWSTR)lpData) == 1);
            }
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("DelayedExpansion"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                fDelayedExpansion = (BOOLEAN)(*(PULONG)lpData != 0);
                }
            else
            if (dwType == REG_SZ) {
                fDelayedExpansion = (BOOLEAN)(_wtol((PWSTR)lpData) == 1);
            }
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("DefaultColor"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                wDefaultColor = (WORD) *(PULONG)lpData;
                }
            else
            if (dwType == REG_SZ) {
                wDefaultColor = (WORD)_tcstol((PTCHAR)lpData, NULL, 0);
            }
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("CompletionChar"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                chCompletionCtrl = (TCHAR)*(PULONG)lpData;
                }
            else
            if (dwType == REG_SZ) {
                chCompletionCtrl = (TCHAR)_tcstol((PTCHAR)lpData, NULL, 0);
            }

            if (chCompletionCtrl == 0 || chCompletionCtrl == 0x0d || chCompletionCtrl > SPACE) {
                chCompletionCtrl = SPACE;
            }
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("PathCompletionChar"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                chPathCompletionCtrl = (TCHAR)*(PULONG)lpData;
                }
            else
            if (dwType == REG_SZ) {
                chPathCompletionCtrl = (TCHAR)_tcstol((PTCHAR)lpData, NULL, 0);
            }

            if (chPathCompletionCtrl == 0 || chPathCompletionCtrl == 0x0d || chPathCompletionCtrl > SPACE) {
                chPathCompletionCtrl = SPACE;
            }
        }

        if (chCompletionCtrl == SPACE && chPathCompletionCtrl < SPACE) {
            chCompletionCtrl = chPathCompletionCtrl;
        } else
        if (chPathCompletionCtrl == SPACE && chCompletionCtrl < SPACE) {
            chPathCompletionCtrl = chCompletionCtrl;
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("AutoRun"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            s = (TCHAR *)lpData;
            if (dwType == REG_EXPAND_SZ) {
                cchSrc = cbData / sizeof( TCHAR );
                cchDst = (sizeof( ValueBuffer ) - cbData) / sizeof( TCHAR );
                if (ExpandEnvironmentStrings( s,
                                              &s[ cchSrc+2 ],
                                              cchDst
                                            )
                   )
                    _tcscpy( s, &s[ cchSrc+2 ] );
                else
                    *s = NULLC;
                }

            if (*s)
                InitialCmds[i] = mystrcpy( mkstr( (_tcslen(s)+1) * sizeof( TCHAR ) ), s );
        }

        RegCloseKey(hKey);
    }

    //
    // Initialize for %RANDOM%
    //
    srand( (unsigned)time( NULL ) );

    return;
}

/***    CheckSwitches - process Command's switches
 *
 *  Purpose:
 *      Check to see if Command was passed any switches and take appropriate
 *      action.  The switches are:
 *              /P - Permanent Command.  Set permanent CMD flag.
 *              /C - Single command.  Build a command line out of the rest of
 *                   the args and pass it back to Init.
 *      @@      /K - Same as /C but also set BatCom flag.
 *              /Q - No echo
 *              /A - Output in ANSI
 *              /U - Output in UNICODE
 *
 *      All other switches are ignored.
 *
 *  TCHAR *CheckSwitches(TCHAR *nptr)
 *
 *  Args:
 *      nptr = Ptr to cmdline to check for switches
 *
 *  Returns:
 *      Comline (it's NULL if NOT in single command mode).
 *
 *  Notes:
 *      M034 - This function revised to use the raw cmdline
 *      from the passed environment.
 *
 */

void
CheckSwitches(
    TCHAR *InitialCmds[],
    TCHAR *nptr
    )
{
    TCHAR a,                         /* Holds switch value              */
         *comline = NULL ,           /* Ptr to command line if /c found */
          store,
         *ptr,                       /* A temporary pointers */
         *ptr_b,
         *ptr_e;

    BOOLEAN  fAutoGen = FALSE;       // On if "/S" in cmdline meaning cmdline was parsed by CMD.EXE previously
    BOOLEAN fOrigEnableExt;
    struct  cmdnode cmd_node;        // need for SearchForExecutable()
    TCHAR   cmdline [MAX_PATH];
    TCHAR   argptr  [MAX_PATH];

    TCHAR   CmdBuf [MAXTOKLEN+3];
    int     retc;

    memset( &cmd_node, 0, sizeof( cmd_node ));
    
    fOrigEnableExt = fEnableExtensions;
    DEBUG((INGRP, ACLVL, "CHKSW: entered.")) ;

    while (nptr = mystrchr(nptr, SwitChar)) {
        a = (TCHAR) _totlower(nptr[1]) ;

        if (a == NULLC)
            break;

        if (a == QMARK) {

#define CTRLCBREAK  if (CtrlCSeen) break
            BeginHelpPause();
            do {
                CTRLCBREAK; PutStdOut(MSG_HELP_CMD, NOARGS);
                CTRLCBREAK; PutStdOut(MSG_HELP_CMD1, NOARGS);

                if (!fOrigEnableExt && !fEnableExtensions) break;

                CTRLCBREAK; PutStdOut(MSG_HELP_CMD_EXTENSIONS, NOARGS);
                CTRLCBREAK; PutStdOut(MSG_HELP_CMD_EXTENSIONS1, NOARGS);
                CTRLCBREAK; PutStdOut(MSG_HELP_CMD_COMPLETION1, NOARGS);
                CTRLCBREAK; PutStdOut(MSG_HELP_CMD_COMPLETION2, NOARGS);

            } while ( FALSE );

            EndHelpPause();

            CMDexit(1);
        } else if (a == QCSwitch)  {   /* Quiet cmd switch        */

            Necho = TRUE ;
            mystrcpy(nptr, nptr+2) ;

        } else if ((a == SCSwitch) || (a == BCSwitch) || a == TEXT('r')) {
            DEBUG((INGRP, ACLVL, "CHKSW: Single command switch")) ;

            if ( a == BCSwitch ) {
                SingleBatchInvocation = TRUE;        // /K specified
            } else {
                SingleCommandInvocation = TRUE;          // /C or /R specified
            }

            if (!(comline = mkstr(mystrlen(nptr+2)*sizeof(TCHAR)+2*sizeof(TCHAR)))) {
                PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
                CMDexit(1) ;
            } ;

            mystrcpy(comline, nptr+2) ;       /* Make comline    */

            *nptr = NULLC ;         /* Invalidate this arg     */

            comline = SkipWhiteSpace( comline );

//---------------------------------------------------------------------------------------------------------
// CMD.EXE uses quotes by two reasons:
// 1. to embed command symbols "&", "<", ">", "|", "&&", "||" into command arguments, e.g.
//    cmd /c " dir | more "
// 2. to embed spaces into filename, e.g.
//    cmd /c " my batfile with spaces.cmd"
// Note that the caret "^" has no effect when used in between quotes in the current implementation (941221).
// Also, CMD.EXE binds the quote with the next one.
//
// I see a problem here: the commands like
//    cmd /c "findstr " | " | find "smth" "        OR
//    cmd /c "ls | " my filterbat with spaces.cmd" | more"
// WON'T WORK unless we all decide to change CMD's syntax to better handle quotes!
//
// There is more to it: when CMD.EXE parses pipes,CMD creates process with the command argument like this:
//    <full path of CMD.EXE> /S /C"  <cmdname>  "
// so we've got spaces inside the quotes.
//
// I hope I am not missing anything else...
//
// With given design restrictions, I will at least solve simple but most wide-spread problem:
// using filenames with spaces by trying this:
//      IF  ( (there is no /S switch ) AND                      // it is not the result of prev. parsing
//            (there are exactly 2 quotes) AND                  // the existing design problem with multiple quotes
//            (there is no special chars between quotes) AND    // don't break command symbols parsing
//            (there is a whitespace between quotes) AND        // otherwise it is not filename with spaces
//            (the token between quotes is a valid executable) )// otherwise we can't help anyway
//      THEN
//            Preserve quotes   // Assume it is a filename with spaces
//      ELSE
//            Exec. old logic   // Strip first and last quotes
//
// Ugly, but what options do I have? Only to patch existing logic or change syntax.
//-----------------------------------------------------------------------------------------------------------

            if (fAutoGen)                                  // seen /S switch
                goto old_way;


            if (*comline == QUOTE) {
                ptr_b = comline + 1;
                ptr_e = mystrchr (ptr_b, QUOTE);
                if (ptr_e)  {                              // at least 2 quotes
                    ptr_b = ptr_e + 1;
                    ptr_e = mystrchr (ptr_b, QUOTE);
                    if (ptr_e)  {                          // more than 2 quotes
                        goto old_way;
                    }
                }
                else {                                     // only 1 quote
                    goto old_way;
                }
                                                           // exactly 2 quotes
                store = *ptr_b;
                *ptr_b = NULLC;

                if ( (mystrchr (comline, ANDOP) ) ||
                     (mystrchr (comline, INOP)  ) ||
                     (mystrchr (comline, OUTOP) ) ||
                     (mystrchr (comline, LPOP)  ) ||
                     (mystrchr (comline, RPOP)  ) ||
                     (mystrchr (comline, SILOP) ) ||
                     (mystrchr (comline, ESCHAR)) ||
                     (mystrchr (comline, PIPOP) ) )  {

                    *ptr_b = store;                        // special chars between quotes
                    goto old_way;
                }


                if ( ! mystrchr (comline, TEXT(' ')) ) {
                    *ptr_b = store;                        // no spaces between quotes
                    goto old_way;
                    }

                // the last check is for valid executable

                cmd_node.type = CMDTYP ;
                cmd_node.cmdline = cmdline;
                cmd_node.argptr = argptr;
                cmd_node.rio = NULL;

                mystrcpy (cmdline, comline);                // get token between quotes
                mystrcpy (argptr, TEXT (" ") );

                *ptr_b = store;                             // restore comline

                retc = SearchForExecutable (&cmd_node, CmdBuf);
                if ( ( retc == SFE_NOTFND) || ( retc == SFE_FAIL) )
                    goto old_way;

                goto new_way;                               // assume filename and DO NOT strip quotes.
            }

old_way:
            if (*comline == QUOTE) {
                ++comline ;
                ptr = mystrrchr(comline, QUOTE);
                if ( ptr ) {
                    *ptr = NULLC;
                    ++ptr;
                    mystrcat(comline,ptr);
                }
            }
new_way:

            *(comline+mystrlen(comline)) = NLN ;

            DEBUG((INGRP, ACLVL, "CHKSW: Single command line = `%ws'", comline)) ;
            InitialCmds[2] = comline;
            break ;         /* Once /K or /C found, no more args exist */

        } else if (a == UCSwitch) {     /* Unicode output switch    */
#ifdef UNICODE
            fOutputUnicode = TRUE;
            mystrcpy(nptr, nptr+2) ;
#else
            PutStdErr(MSG_UNICODE_NOT_SUPPORTED, NOARGS);
#endif // UNICODE
        } else if (a == ACSwitch) {     /* Ansi output switch    */
#ifdef UNICODE
            fOutputUnicode = FALSE;
#endif // UNICODE
                mystrcpy(nptr, nptr+2) ;
        //
        // Old style of enabling extensions with /X
        //
        } else if (a == XCSwitch) {     /* Enable extensions switch */
                fEnableExtensions = TRUE;
                mystrcpy(nptr, nptr+2) ;

        //
        // Old style of disabling extensions with /Y
        //
        } else if (a == YCSwitch) {     /* Disable extensions switch */
                fEnableExtensions = FALSE;
                mystrcpy(nptr, nptr+2) ;

        //
        // Enable/Disable command extensions. /E or /E:ON to enable
        // and /E:OFF to disable.
        //
        } else if (a == TEXT('e')) {
                mystrcpy(nptr, nptr+2) ;
                if (*nptr == COLON && !_tcsnicmp(nptr+1, TEXT("OFF"), 3)) {
                    fEnableExtensions = FALSE;
                    mystrcpy(nptr, nptr+4) ;
                } else {
                    fEnableExtensions = TRUE;
                    if (!_tcsnicmp(nptr, TEXT(":ON"), 3)) {
                        mystrcpy(nptr, nptr+3) ;
                    }
                }

        //
        // Disable AutoRun from Registry if /D specified.
        //
        } else if (a == TEXT('d')) {
                mystrcpy(nptr, nptr+2) ;
                InitialCmds[0] = NULL;
                InitialCmds[1] = NULL;

        //
        // Enable/Disable file and directory name completion. /F or /F:ON to
        // enable and /F:OFF to disable.
        //
        } else if (a == TEXT('f')) {
                mystrcpy(nptr, nptr+2) ;
                if (*nptr == COLON && !_tcsnicmp(nptr+1, TEXT("OFF"), 3)) {
                    chCompletionCtrl = SPACE;
                    chPathCompletionCtrl = SPACE;
                    mystrcpy(nptr, nptr+4) ;
                } else {
                    chCompletionCtrl = 0x6;         // Ctrl-F
                    chPathCompletionCtrl = 0x4;     // Ctrl-D
                    if (!_tcsnicmp(nptr, TEXT(":ON"), 3)) {
                        mystrcpy(nptr, nptr+3) ;
                    }
                }

        //
        // Enable/Disable delayed variable expansion inside FOR loops.  /V or /V:ON to
        // enable and /V:OFF to disable.
        //
        } else if (a == TEXT('v')) {
                mystrcpy(nptr, nptr+2) ;
                if (*nptr == COLON && !_tcsnicmp(nptr+1, TEXT("OFF"), 3)) {
                    fDelayedExpansion = FALSE;
                    mystrcpy(nptr, nptr+4) ;
                } else {
                    fDelayedExpansion = TRUE;
                    if (!_tcsnicmp(nptr, TEXT(":ON"), 3)) {
                        mystrcpy(nptr, nptr+3) ;
                    }
                }

        //
        // Set the foreground/background screen coler
        // enable and /F:OFF to disable.
        //
        } else if (fEnableExtensions && a == TEXT('t')) {   /* Define start color */
            if (*(nptr+2) == __TEXT(':') && _istxdigit(*(nptr+3)) &&
                _istxdigit(*(nptr+4)) && !_istxdigit(*(nptr+5))) {
                wDefaultColor = (WORD) (_istdigit(*(nptr+3)) ? (WORD)*(nptr+3) - (WORD)TEXT('0')
                                                             : (WORD)_totlower(*(nptr+3)) - (WORD)TEXT('W')) ;
                wDefaultColor <<= 4;
                wDefaultColor |= (WORD) (_istdigit(*(nptr+4)) ? (WORD)*(nptr+4) - (WORD)TEXT('0')
                                                              : (WORD)_totlower(*(nptr+4)) - (WORD)TEXT('W')) ;
                mystrcpy(nptr+2, nptr+5 );
            }
            mystrcpy(nptr, nptr+2) ;

        } else if (a == TEXT('s') )  {  /* CMD inserts when parsing pipes */
            fAutoGen = TRUE ;
            mystrcpy(nptr, nptr+2) ;
        } else {
            mystrcpy(nptr, nptr+2) ;  /* Remove any other switches */
        } ;
    } ;

    return;
}


/***    SetUpEnvironment - initialize Command's environment
 *
 *  Purpose:
 *      Take the environment pointer received earlier and initialize it
 *      with respect with respect to size and maxsize.  Initialize the
 *      PATH and COMSPEC variables as necessary.
 *
 *  SetUpEnvironment()
 *
 */

extern TCHAR KeysStr[];  /* @@5 */
extern int KeysFlag;    /* @@5 */

void SetUpEnvironment(void)
{
    TCHAR *cds ;            // Command directory string
    TCHAR *nptr ;                    // Temp cmd name ptr
    TCHAR *eptr ;                    // Temp cmd name ptr
    MEMORY_BASIC_INFORMATION MemInfo;


    eptr = CmdEnv.handle;
    CmdEnv.cursize = GetEnvCb( eptr );
    VirtualQuery( CmdEnv.handle, &MemInfo, sizeof( MemInfo ));
    CmdEnv.maxsize = (UINT)MemInfo.RegionSize;

    if (!(cds = mkstr(MAX_PATH*sizeof(TCHAR)))) {
        PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
        CMDexit(1) ;
    }
    GetModuleFileName( NULL, cds, MAX_PATH );

    //
    // If the PATH variable is not set, it must be added as a NULL.  This is
    // so that DOS apps inherit the current directory path.
    //
    if (!GetEnvVar(PathStr)) {

        SetEnvVar(PathStr, TEXT(""), &CmdEnv);
    }

    //
    // If the PATHEXT variable is not set, and extensions are enabled, set it to
    // the default list of extensions that will be searched.
    //
    if (!GetEnvVar(PathExtStr)) {

        SetEnvVar(PathExtStr, PathExtDefaultStr, &CmdEnv);

    }

    //
    // If the PROMPT variable is not set, it must be added as $P$G.  This is
    // special cased, since we do not allow users to add NULLs.
    //
    if (!GetEnvVar(PromptStr)) {

        SetEnvVar(PromptStr, TEXT("$P$G"), &CmdEnv);
    }

    if (!GetEnvVar(ComSpecStr)) {

        DEBUG((INGRP, EILVL, "SETENV: No COMSPEC var")) ;

        if(!mystrchr(cds,DOT)) {          /* If no fname, use default */
            _tcsupr(CmdSpec);
            if((cds+mystrlen(cds)-1) != mystrrchr(cds,PathChar)) {
                mystrcat(cds,ComSpec) ;
            } else {
                mystrcat(cds,&ComSpec[1]) ;
            }
        }

        SetEnvVar(ComSpecStr, cds, &CmdEnv) ;
    }

    if ( (nptr = GetEnvVar(KeysStr)) && (!_tcsicmp(nptr, TEXT("ON"))) ) {
        KeysFlag = 1;
    }

    ChangeDir(CurDrvDir);

    penvOrig = CopyEnv();
    if (penvOrig) {
        OrigEnv = *penvOrig;
        penvOrig = &OrigEnv;
    }

}


VOID
ResetCtrlC() {

    EnterCriticalSection(lpcritCtrlC);
    CtrlCSeen = FALSE;
    LeaveCriticalSection(lpcritCtrlC);

}

VOID
SetCtrlC() {

    EnterCriticalSection(lpcritCtrlC);
    CtrlCSeen = TRUE;
    LeaveCriticalSection(lpcritCtrlC);

}


void
CMDexit(int rc)
{
    while (ePopDir(NULL) == SUCCESS)
        ;

    exit(rc);
}

//
//  Get the current OS version and put it into the common version format
//

VOID 
GetVersionString(
    IN OUT PTCHAR VersionString,
    IN ULONG Length
    )
{
    ULONG vrs = GetVersion();

    //
    //  Version format is [Major.Minor(2).Build(4)]
    //
    
    _sntprintf( VersionString, Length, 
                TEXT( "%d.%d.%04d" ),
                vrs & 0xFF,
                (vrs >> 8) & 0xFF,
                (vrs >> 16) & 0x3FFF
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cenv.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cenv.c

Abstract:

    Environment variable support

--*/

#include "cmd.h"

struct envdata CmdEnv ;    // Holds info to manipulate Cmd's environment
struct envdata * penvOrig; // original environment setup used with eStart

extern TCHAR PathStr[], PromptStr[] ;
extern TCHAR AppendStr[]; /* @@ */

extern CHAR InternalError[] ;
extern TCHAR Fmt16[], Fmt17[], EnvErr[] ;
extern TCHAR SetArithStr[] ;
extern TCHAR SetPromptStr[] ;
extern unsigned flgwd ;
extern TCHAR CdStr[] ;
extern TCHAR DatStr[] ;
extern TCHAR TimStr[] ;
extern TCHAR ErrStr[] ;
extern TCHAR CmdExtVerStr[] ;

extern unsigned LastRetCode;
extern BOOL CtrlCSeen;
extern UINT CurrentCP;
extern BOOLEAN PromptValid;

extern int  glBatType;     // to distinguish OS/2 vs DOS errorlevel behavior depending on a script file name

int SetArithWork(TCHAR *tas);


unsigned
SetLastRetCodeIfError(
    unsigned RetCode
    )
{
    if (RetCode != 0) {
        LastRetCode = RetCode;
    }

    return RetCode;
}

/***    ePath - Begin the execution of a Path Command
 *
 *  Purpose:
 *      If the command has no argument display the current value of the PATH
 *      environment variable.  Otherwise, change the value of the Path
 *      environment variable to the argument.
 *
 *  int ePath(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the path command
 *
 *  Returns:
 *      If changing the PATH variable, whatever SetEnvVar() returns.
 *      SUCCESS, otherwise.
 *
 */

int ePath(n)
struct cmdnode *n ;
{
    if (glBatType != CMD_TYPE)  {
        //  if set command is executed from .bat file OR entered at command prompt
        return( SetLastRetCodeIfError(PathWork( n, 1 )));
    }
    else {
        return( LastRetCode = PathWork( n, 1 ) );
    }

}

/***    eAppend - Entry point for Append routine
 *
 *  Purpose:
 *      to call Append and pass it a pointer to the command line
 *      arguments
 *
 *  Args:
 *      a pointer to the command node structure
 *
 */

int eAppend(n)
struct cmdnode *n ;
{

    if (glBatType != CMD_TYPE)  {
        //  if set command is executed from .bat file OR entered at command prompt
        return( SetLastRetCodeIfError(PathWork( n, 0 )));
    }
    else {
        return( LastRetCode = PathWork( n, 0 ) );
    }

}

int PathWork(n, flag)
struct cmdnode *n ;
int flag;   /* 0 = AppendStr, 1 = PathStr */
{
        TCHAR *tas ;    /* Tokenized argument string    */
        TCHAR c ;

/*  M014 - If the only argument is a single ";", then we have to set
 *  a NULL path.
 */
        if ( n->argptr ) {
            c = *(EatWS(n->argptr, NULL)) ;
        } else {
            c = NULLC;
        }

        if ((!c || c == NLN) &&         /* If args are all whitespace      */
            mystrchr(n->argptr, TEXT(';'))) {

                return(SetEnvVar(flag ? PathStr : AppendStr, TEXT(""), &CmdEnv)) ;

        } else {

                tas = TokStr(n->argptr, TEXT(";"), TS_WSPACE | TS_NWSPACE) ;

                if (*tas)
                  {
                   return(SetEnvVar(flag ? PathStr : AppendStr, tas, &CmdEnv)) ;
                  }

               cmd_printf(Fmt16, flag ? PathStr : AppendStr,
                          GetEnvVar(flag ? PathStr : AppendStr), &CmdEnv) ;
        }
        return(SUCCESS) ;
}




/***    ePrompt - begin the execution of the Prompt command
 *
 *  Purpose:
 *      To modifiy the Prompt environment variable.
 *
 *  int ePrompt(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the prompt command
 *
 *  Returns:
 *      Whatever SetEnvVar() returns.
 *
 */

int ePrompt(n)
struct cmdnode *n ;
{
    if (glBatType != CMD_TYPE)  {
        //  if set command is executed from .bat file OR entered at command prompt
        return(SetLastRetCodeIfError(SetEnvVar(PromptStr, TokStr(n->argptr, NULL, TS_WSPACE), &CmdEnv))) ;
    }
    else {
        return(LastRetCode = SetEnvVar(PromptStr, TokStr(n->argptr, NULL, TS_WSPACE), &CmdEnv) ) ;
    }
}




/***    eSet - execute a Set command
 *
 *  Purpose:
 *      To set/modify an environment or to display the current environment
 *      contents.
 *
 *  int eSet(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the set command
 *
 *  Returns:
 *      If setting and the command is syntactically correct, whatever SetEnvVar()
 *      returns.  Otherwise, FAILURE.
 *
 *      If displaying, SUCCESS is always returned.
 *
 */

int eSet(n)
struct cmdnode *n ;
{
    if (glBatType != CMD_TYPE)  {
        //  if set command is executed from .bat file OR entered at command prompt
        return( SetLastRetCodeIfError(SetWork( n )));
    }
    else {
        return( LastRetCode = SetWork( n ) );
    }
}

/***    SetPromptUser - set environment variable to value entered by user.
 *
 *  Purpose:
 *      Set environment variable to value entered by user.
 *
 *  int SetPromptUser(TCHAR *tas)
 *
 *  Args:
 *      tas - pointer to null terminated string of the form:
 *
 *          VARNAME=promptString
 *
 *  Returns:
 *      If valid expression, return SUCCESS otherwise FAILURE.
 *
 */

int SetPromptUser(TCHAR *tas)
{
    TCHAR *wptr;
    TCHAR *tptr;
    ULONG    dwOutputModeOld;
    ULONG    dwOutputModeCur;
    ULONG    dwInputModeOld;
    ULONG    dwInputModeCur;
    BOOLEAN  fOutputModeSet = FALSE;
    BOOLEAN  fInputModeSet = FALSE;
    HANDLE   hndStdOut = NULL;
    HANDLE   hndStdIn = NULL;
    DWORD    cch;
    TCHAR    szValueBuffer[ 1024 ];

    //
    // Find first non-blank argument.
    //
    if (tas != NULL)
    while (*tas && *tas <= SPACE)
        tas += 1;


    // If no input, declare an error
    //
    if (!tas || !*tas) {
        PutStdErr(MSG_BAD_SYNTAX, NOARGS);
        return(FAILURE) ;
    }

    //
    // See if first argument is quoted.  If so, strip off
    // leading quote, spaces and trailing quote.
    //
    if (*tas == QUOTE) {
        tas += 1;
        while (*tas && *tas <= SPACE)
            tas += 1;
        tptr = _tcsrchr(tas, QUOTE);
        if (tptr)
            *tptr = NULLC;
    }

    //
    // Find the equal sign in the argument.
    //
    wptr = _tcschr(tas, EQ);

    //
    // If no equal sign, error.
    //
    if (!wptr) {
        PutStdErr(MSG_BAD_SYNTAX, NOARGS);
        return(FAILURE) ;
    }

    //
    // Found the equal sign, so left of equal sign is variable name
    // and right of equal sign is prompt string.  Dont allow user to set
    // a variable name that begins with an equal sign, since those
    // are reserved for drive current directories.
    //
    *wptr++ = NULLC;

    //
    // See if second argument is quoted.  If so, strip off
    // leading quote, spaces and trailing quote.
    //
    if (*wptr == QUOTE) {
        wptr += 1;
        while (*wptr && *wptr <= SPACE)
            wptr += 1;
        tptr = _tcsrchr(wptr, QUOTE);
        if (tptr)
            *tptr = NULLC;
    }

    if (*wptr == EQ) {
        PutStdErr(MSG_BAD_SYNTAX, NOARGS);
        return(FAILURE) ;
    }

    hndStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (GetConsoleMode( hndStdOut, &dwOutputModeOld) ) {

        // make sure CRLF is processed correctly

        dwOutputModeCur = dwOutputModeOld | ENABLE_PROCESSED_OUTPUT;
        fOutputModeSet = TRUE;
        SetConsoleMode(hndStdOut,dwOutputModeCur);
        GetLastError();
    }

    hndStdIn = GetStdHandle(STD_INPUT_HANDLE);
    if (GetConsoleMode( hndStdIn, &dwInputModeOld) ) {

        // make sure input is processed correctly

        dwInputModeCur = dwInputModeOld | ENABLE_LINE_INPUT |
                         ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT;
        fInputModeSet = TRUE;
        SetConsoleMode(hndStdIn,dwInputModeCur);
        GetLastError();
    }

    //
    // Loop till the user enters a value for the variable.
    //

    while (TRUE) {
        PutStdOut(MSG_LITERAL_TEXT, ONEARG, wptr );
        szValueBuffer[0] = NULLC;
        if (ReadBufFromInput( GetStdHandle(STD_INPUT_HANDLE),
                              szValueBuffer,
                              sizeof(szValueBuffer)/sizeof(TCHAR),
                              &cch
                            ) != 0 &&
                            cch != 0
           ) {
            //
            // Strip off any trailing CRLF
            //
            while (cch > 0 && szValueBuffer[cch-1] < SPACE)
                cch -= 1;

            break;
        }
        else {
            cch = 0;
            break;
        }

        if (!FileIsDevice(STDIN) || !(flgwd & 1))
            cmd_printf(CrLf) ;
    }

    if (fOutputModeSet) {
        SetConsoleMode( hndStdOut, dwOutputModeOld );
    }
    if (fInputModeSet) {
        SetConsoleMode( hndStdIn, dwInputModeOld );
    }

    if (cch) {
        szValueBuffer[cch] = NULLC;
        return(SetEnvVar(tas, szValueBuffer, &CmdEnv)) ;
    } else {
        return(FAILURE);
    }
}


int SetWork(n)
struct cmdnode *n ;
{
        TCHAR *tas ;    /* Tokenized argument string    */
        TCHAR *wptr ;   /* Work pointer                 */
        int i ;                 /* Work variable                */

        //
        // If extensions are enabled, things are different
        //
        if (fEnableExtensions) {
            tas = n->argptr;
            //
            // Find first non-blank argument.
            //
            if (tas != NULL)
            while (*tas && *tas <= SPACE)
                tas += 1;

            //
            // No arguments, same as old behavior.  Display current
            // set of environment variables.
            //
            if (!tas || !*tas)
                return(DisplayEnv()) ;

            //
            // See if /A switch given.  If so, let arithmetic
            // expression evaluator do the work.
            //
            if (!_tcsnicmp(tas, SetArithStr, 2))
                return SetArithWork(tas+2);

            //
            // See if /P switch given.  If so, prompt user for value
            //
            if (!_tcsnicmp(tas, SetPromptStr, 2))
                return SetPromptUser(tas+2);

            //
            // See if first argument is quoted.  If so, strip off
            // leading quote, spaces and trailing quote.
            //
            if (*tas == QUOTE) {
                tas += 1;
                while (*tas && *tas <= SPACE)
                    tas += 1;
                wptr = _tcsrchr(tas, QUOTE);
                if (wptr)
                    *wptr = NULLC;
            }

            //
            // Dont allow user to set a variable name that begins with
            // an equal sign, since those are reserved for drive current
            // directories.  This check will also detect missing variable
            // name, e.g.
            //
            //      set %LOG%=c:\tmp\log.txt
            //
            // if LOG is not defined is an invalid statement.
            //
            if (*tas == EQ) {
                PutStdErr(MSG_BAD_SYNTAX, NOARGS);
                return(FAILURE) ;
            }

            //
            // Find the equal sign in the argument.
            //
            wptr = _tcschr(tas, EQ);

            //
            // If no equal sign, then assume argument is variable name
            // and user wants to see its value.  Display it.
            //
            if (!wptr)
                return DisplayEnvVariable(tas);

            //
            // Found the equal sign, so left of equal sign is variable name
            // and right of equal sign is value.
            //
            *wptr++ = NULLC;
            return(SetEnvVar(tas, wptr, &CmdEnv)) ;
        }

        tas = TokStr(n->argptr, ONEQSTR, TS_WSPACE|TS_SDTOKENS) ;
        if (!*tas)
                return(DisplayEnv()) ;

        else {
                for (wptr = tas, i = 0 ; *wptr ; wptr += mystrlen(wptr)+1, i++)
                        ;
                /* If too many parameters were given, the second parameter */
                /* wasn't an equal sign, or they didn't specify a string   */
                /* return an error message.                                */
                if ( i > 3 || *(wptr = tas+mystrlen(tas)+1) != EQ ||
                    !mystrlen(mystrcpy(tas, StripQuotes(tas))) ) {
/* M013 */              PutStdErr(MSG_BAD_SYNTAX, NOARGS);
                        return(FAILURE) ;

                } else {
                        return(SetEnvVar(tas, wptr+2, &CmdEnv)) ;
                }
        }
}




/***    DisplayEnvVariable -  display a specific variable from the environment
 *
 *  Purpose:
 *      To display a specific variable from the current environment.
 *
 *  int DisplayEnvVariable( tas )
 *
 *  Returns:
 *      SUCCESS if all goes well
 *      FAILURE if it runs out of memory or cannot lock the env. segment
 */

int DisplayEnvVariable(tas)
TCHAR *tas;
{
    TCHAR *envptr ;
    TCHAR *vstr ;
    unsigned size ;
    UINT PrefixLength;
    int rc;

    //
    //  Get environment.  If there's none, we're done.
    //

    envptr = GetEnvironmentStrings();
    if (envptr == (TCHAR *)NULL) {
        fprintf ( stderr, InternalError , "Null environment" ) ;
        return ( FAILURE ) ;
    }

    //
    //  Isolate the prefix to match against.
    //

    tas = EatWS(tas, NULL);
    if ((vstr = mystrrchr(tas, SPACE)) != NULL) {
        *vstr = NULLC;
    }

    PrefixLength = mystrlen(tas);

    //
    //  Walk through the environment looking for prefixes that match.
    //

    rc = FAILURE;
    while ((size = mystrlen(envptr)) > 0) {

        //
        //  Stop soon if we see ^C
        //

        if (CtrlCSeen) {
            return(FAILURE);
        }

        //
        //  If the prefix is long enough, then terminate the string and
        //  look for a prefix match.  If we match, restore the string
        //  and display it
        //

        if (size >= PrefixLength) {
            TCHAR SavedChar = envptr[PrefixLength];
            envptr[PrefixLength] = NULLC;
            if (!lstrcmpi( envptr, tas )) {
                envptr[PrefixLength] = SavedChar;
                cmd_printf(Fmt17, envptr );
                rc = SUCCESS;
            } else {
                envptr[PrefixLength] = SavedChar;
            }

        }

        //
        //  Advance to the next string
        //

        envptr += size+1 ;
    }

    if (rc != SUCCESS) {
        PutStdErr(MSG_ENV_VAR_NOT_FOUND, ONEARG, tas);
    }

    return(rc) ;
}


/***    MyGetEnvVar - get a pointer to the value of an environment variable
 *
 *  Purpose:
 *      Return a pointer to the value of the specified environment variable.
 *
 *      If the variable is not found, return NULL.
 *
 *  TCHAR *MyGetEnvVar(TCHAR *varname)
 *
 *  Args:
 *      varname - the name of the variable to search for
 *
 *  Returns:
 *      See above.
 *
 *  Side Effects:
 *      Returned value points to within the environment block itself, so is
 *      not valid after a set environment variable operations is perform.
 */


const TCHAR *
MyGetEnvVarPtr(TCHAR *varname)
{
        TCHAR *envptr ; /* Ptr to environment                      */
        TCHAR *vstr ;
        unsigned size ;         /* Length of current env string             */
        unsigned n ;

        if (varname == NULL) {
            return ( NULL ) ;
        }

        envptr = GetEnvironmentStrings();
        if (envptr == (TCHAR *)NULL) {
            return ( NULL ) ;
        }

        varname = EatWS(varname, NULL);
        if ((vstr = mystrrchr(varname, SPACE)) != NULL)
            *vstr = NULLC;

        n = mystrlen(varname);
        while ((size = mystrlen(envptr)) > 0) {                 /* M015    */
                if (CtrlCSeen) {
                    return(NULL);
                }
                if (!_tcsnicmp(varname, envptr, n) && envptr[n] == TEXT( '=' )) {
                    return envptr+n+1;
                }

                envptr += size+1 ;
        }

        return(NULL);
}


/***    DisplayEnv -  display the environment
 *
 *  Purpose:
 *      To display the current contents of the environment.
 *
 *  int DisplayEnv()
 *
 *  Returns:
 *      SUCCESS if all goes well
 *      FAILURE if it runs out of memory or cannot lock the env. segment
 */

int DisplayEnv()
{
    TCHAR *envptr ; /* Ptr to environment                      */
    unsigned size ;         /* Length of current env string             */

    envptr = GetEnvironmentStrings();
    if (envptr == (TCHAR *)NULL) {
        fprintf ( stderr, InternalError , "Null environment" ) ;
        return( FAILURE ) ;
    }
    
    while ((size = mystrlen(envptr)) > 0) {                 /* M015    */
        if (CtrlCSeen) {
            return(FAILURE);
        }
#if !DBG
        // Dont show current directory variables in retail product
        if (*envptr != EQ)
#endif // DBG
            cmd_printf(Fmt17, envptr) ;   /* M005 */
        envptr += size+1 ;
    }

    return(SUCCESS) ;
}




/***    SetEnvVar - controls adding/changing an environment variable
 *
 *  Purpose:
 *      Add/replace an environment variable.  Grow it if necessary.
 *
 *  int SetEnvVar(TCHAR *varname, TCHAR *varvalue, struct envdata *env)
 *
 *  Args:
 *      varname - name of the variable being added/replaced
 *      varvalue - value of the variable being added/replaced
 *      env - environment info structure being used
 *
 *  Returns:
 *      SUCCESS if the variable could be added/replaced.
 *      FAILURE otherwise.
 *
 */

int SetEnvVar(varname, varvalue, env)
TCHAR *varname ;
TCHAR *varvalue ;
struct envdata *env ;
{
    int retvalue;

    PromptValid = FALSE;        // Force it to be recalculated

    DBG_UNREFERENCED_PARAMETER( env );
    if (!_tcslen(varvalue)) {
        varvalue = NULL; // null to remove from env
    }
    retvalue = SetEnvironmentVariable(varname, varvalue);
    if (CmdEnv.handle != GetEnvironmentStrings()) {
        MEMORY_BASIC_INFORMATION MemoryInfo;

        CmdEnv.handle = GetEnvironmentStrings();
        CmdEnv.cursize = GetEnvCb(CmdEnv.handle);
        if (VirtualQuery( CmdEnv.handle, &MemoryInfo, sizeof( MemoryInfo ) ) == sizeof( MemoryInfo )) {
            CmdEnv.maxsize = (UINT)MemoryInfo.RegionSize;
            }
        else {
            CmdEnv.maxsize = CmdEnv.cursize;
            }
        }
    else {
        CmdEnv.cursize = GetEnvCb(CmdEnv.handle);
        }

    return !retvalue;
}

/***    GetEnvVar - get the value of an environment variable
 *
 *  Purpose:
 *      Return a string containing the value of the specified environment
 *      variable. The string value has been placed into a static buffer
 *      that is valid until the next GetEnvVar call.
 *
 *      If the variable is not found, return NULL.
 *
 *  TCHAR *GetEnvVar(TCHAR *varname)
 *
 *  Args:
 *      varname - the name of the variable to search for
 *
 *  Returns:
 *      See above.
 *
 */


TCHAR GetEnvVarBuffer[LBUFLEN];

PTCHAR GetEnvVar(varname)
PTCHAR varname ;
{
    GetEnvVarBuffer[0] = TEXT( '\0' );

    if (GetEnvironmentVariable(varname, GetEnvVarBuffer, sizeof(GetEnvVarBuffer) / sizeof(TCHAR))) {
        return(GetEnvVarBuffer);
    }
    else
    if (fEnableExtensions) {
        if (!_tcsicmp(varname, CdStr)) {
            GetDir(GetEnvVarBuffer, GD_DEFAULT) ;
            return GetEnvVarBuffer;
        }
        else
        if (!_tcsicmp(varname, ErrStr)) {
            _stprintf( GetEnvVarBuffer, TEXT("%d"), LastRetCode );
            return GetEnvVarBuffer;
        }
        else
        if (!_tcsicmp(varname, CmdExtVerStr)) {
            _stprintf( GetEnvVarBuffer, TEXT("%d"), CMDEXTVERSION );
            return GetEnvVarBuffer;
        }
        else
        if (!_tcsicmp(varname, TEXT("CMDCMDLINE"))) {
            return GetCommandLine();
        }
        else
        if (!_tcsicmp(varname, DatStr)) {
            GetEnvVarBuffer[ PrintDate(NULL, PD_DATE, GetEnvVarBuffer, LBUFLEN) ] = NULLC;
            return GetEnvVarBuffer;
        }
        if( !_tcsicmp(varname, TimStr)) {
            GetEnvVarBuffer[ PrintTime(NULL, PT_TIME, GetEnvVarBuffer, LBUFLEN) ] = NULLC;
            return GetEnvVarBuffer;
        }
        if( !_tcsicmp(varname, TEXT("RANDOM"))) {
            _stprintf( GetEnvVarBuffer, TEXT("%d"), rand() );
            return GetEnvVarBuffer;
        }
    }
    return(NULL);
}


/***    CopyEnv -  make a copy of the current environment
 *
 *  Purpose:
 *      Make a copy of CmdEnv and put the new handle into the newly
 *      created envdata structure.  This routine is only called by
 *      eSetlocal and init.
 *
 *  struct envdata *CopyEnv()
 *
 *  Returns:
 *      A pointer to the environment information structure.
 *      Returns NULL if unable to allocate enough memory
 *
 *  Notes:
 *    - M001 - This function was disabled, now reenabled.
 *    - The current environment is copied as a snapshot of how it looked
 *      before SETLOCAL was executed.
 *    - M008 - This function's copy code was moved to new function MoveEnv.
 *
 */

struct envdata *CopyEnv()
{
    struct envdata *cce ;   /* New env info structure          */

    cce = (struct envdata *) HeapAlloc( GetProcessHeap( ), HEAP_ZERO_MEMORY, sizeof( *cce ));
    if (cce == NULL) {
        return NULL;
    }

    cce->cursize = CmdEnv.cursize ;
    cce->maxsize = CmdEnv.maxsize ;
    cce->handle  = VirtualAlloc( NULL,
                                 cce->maxsize,
                                 MEM_COMMIT,
                                 PAGE_READWRITE
                               );
    if (cce->handle == NULL) {
        HeapFree( GetProcessHeap( ), 0, cce );
        PutStdErr( MSG_OUT_OF_ENVIRON_SPACE, NOARGS );
        return NULL;
    }

    if (!MoveEnv( cce->handle, CmdEnv.handle, GetEnvCb( CmdEnv.handle ))) {
        VirtualFree( cce->handle, 0, MEM_RELEASE );
        HeapFree( GetProcessHeap( ), 0, cce );
        return NULL;
    }

    return cce;
}


/***    ResetEnv - restore the environment
 *
 *  Purpose:
 *      Restore the environment to the way it was before the execution of
 *      the SETLOCAL command.  This function only called by eEndlocal.
 *
 *  ResetEnv(struct envdata *env)
 *
 *  Args:
 *      env - structure containing handle, size and max dimensions of an
 *            environment.
 *
 *  Notes:
 *    - M001 - This function was disabled, but has been reenabled.
 *    - M001 - This function used to test for OLD/NEW style batch files
 *             and delete the copy or the original environment as
 *             appropriate.  It now always deletes the original.
 *    - M014 - Note that the modified local environment will never be
 *             shrunk, so we can assume it will hold the old one.
 *
 */

void ResetEnv( struct envdata *env)
{
    ULONG cursize;

    cursize = GetEnvCb( env->handle );
    if (MoveEnv( CmdEnv.handle, env->handle, cursize )) {
        CmdEnv.cursize = cursize ;
    }

    VirtualFree( env->handle, 0, MEM_RELEASE );
    HeapFree( GetProcessHeap( ), 0, env );
}




/***    MoveEnv - Move the contents of the environment (M008 - New function)
 *
 *  Purpose:
 *      Used by CopyEnv, this function moves the existing
 *      environment contents to the new location.
 *
 *  MoveEnv(unsigned thndl, unsigned shndl, unsigned cnt)
 *
 *  Args:
 *      thndl - Handle of target environment
 *      shndl - Handle of source environment
 *      cnt   - byte count to move
 *
 *  Returns:
 *      TRUE if no errors
 *      FALSE otherwise
 *
 */

MoveEnv(tenvptr, senvptr, cnt)
TCHAR *senvptr ;                /* Ptr into source env seg         */
TCHAR *tenvptr ;                /* Ptr into target env seg         */
ULONG    cnt ;
{
        if ((tenvptr == NULL) ||
            (senvptr == NULL)) {
                fprintf(stderr, InternalError, "Null environment") ;
                return(FALSE) ;
        }
        memcpy(tenvptr, senvptr, cnt) ;         /* M015    */
        return(TRUE) ;
}


ULONG
GetEnvCb( TCHAR *penv ) {

        ULONG cb = 0;

        if (penv == NULL) {
            return (0);
        }

        while ( (*penv) || (*(penv+1))) {
                cb++;
                penv++;
        }
        return (cb+2) * sizeof(TCHAR);

}

//
//      expr -> assign [, assign]*                          ,
//
//      assign -> orlogexpr |                               
//                VAR ASSIGNOP assign                       <op>=
//
//      orlogexpr -> xorlogexpr [| xorlogexpr]*             |
//
//      xorlogexpr ->  andlogexpr [^ andlogexpr]*           ^
//
//      andlogexpr ->  shiftexpr [& shiftexpr]*             &
//
//      shiftexpr -> addexpr [SHIFTOP addexpr]*             <<, >>
//
//      addexpr -> multexpr [ADDOP multexpr]*               +, -
//
//      multexpr -> unaryexpr [MULOP unaryexpr]*            *, /, %
//
//      unaryexpr -> ( expr ) |                             ()
//                   UNARYOP unaryexpr                      +, -, !, ~
//

TCHAR szOps[] = TEXT("<>+-*/%()|^&=,");
TCHAR szUnaryOps[] = TEXT("+-~!");

typedef struct {
    PTCHAR Token;
    LONG Value;
    DWORD Error;
} PARSESTATE, *PPARSESTATE;

VOID
APerformUnaryOperation( PPARSESTATE State, TCHAR Op, LONG Value )
{
    switch (Op) {
    case TEXT( '+' ):
        State->Value = Value;
        break;
    case TEXT( '-' ):
        State->Value = -Value;
        break;
    case TEXT( '~' ):
        State->Value = ~Value;
        break;
    case TEXT( '!' ):
        State->Value = !Value;
        break;
    default:
        printf( "APerformUnaryOperation: '%c'\n", Op);
        break;
    }
}

VOID
APerformArithmeticOperation( PPARSESTATE State, TCHAR Op, LONG Left, LONG Right )
{
    switch (Op) {
    case TEXT( '<' ):
        State->Value = (Right >= 8 * sizeof( Left << Right))
                            ? 0
                            : (Left << Right);
        break;
    case TEXT( '>' ):
        State->Value = (Right >= 8 * sizeof( Left >> Right ))
                        ? (Left < 0 ? -1 : 0)
                        : (Left >> Right);
        break;
    case TEXT( '+' ):
        State->Value = Left + Right;
        break;
    case TEXT( '-' ):
        State->Value = Left - Right;
        break;
    case TEXT( '*' ):
        State->Value = Left * Right;
        break;
    case TEXT( '/' ):
        if (Right == 0) {
            State->Error = MSG_SET_A_DIVIDE_BY_ZERO;
        } else {
            State->Value = Left / Right;
        }
        break;
    case TEXT( '%' ):
        if (Right == 0) {
            State->Error = MSG_SET_A_DIVIDE_BY_ZERO;
        } else {
            State->Value = Left % Right;
        }
        break;
    case TEXT( '|' ):
        State->Value = Left | Right;
        break;
    case TEXT( '^' ):
        State->Value = Left ^ Right;
        break;
    case TEXT( '&' ):
        State->Value = Left & Right;
        break;
    case TEXT( '=' ):
        State->Value = Right;
        break;
    default:
        printf( "APerformArithmeticOperation: '%c'\n", Op);
    }
}


//
//  Return the numeric value of an environment variable (or 0)
//

LONG
AGetValue( PTCHAR Start, PTCHAR End )
{
    TCHAR c = *End;
    const TCHAR *Value;
    PTCHAR Dummy;
    
    *End = NULLC;

    Value = MyGetEnvVarPtr( Start );
    *End = c;

    if (Value == NULL) {
        return 0;
    }

    return _tcstol( Value, &Dummy, 0);
}

DWORD
ASetValue( PTCHAR Start, PTCHAR End, LONG Value )
{
    TCHAR Result[32];
    TCHAR c = *End;
    DWORD Return = SUCCESS;

    *End = NULLC;

    _sntprintf( Result, 32, TEXT("%d"), Value ) ;
    
    if (SetEnvVar( Start, Result, &CmdEnv ) != SUCCESS) {
        Return = GetLastError();
    }

    *End = c;
    return Return;
}


//
//  Forward decls
//
PARSESTATE AParseAddExpr( PARSESTATE State );
PARSESTATE AParseAndLogExpr( PARSESTATE State );
PARSESTATE AParseAssign( PARSESTATE State );
PARSESTATE AParseExpr( PARSESTATE State );
PARSESTATE AParseMultExpr( PARSESTATE State );
PARSESTATE AParseOrLogExpr( PARSESTATE State );
PARSESTATE AParseShiftExpr( PARSESTATE State );
PARSESTATE AParseUnaryExpr( PARSESTATE State );
PARSESTATE AParseXorLogExpr( PARSESTATE State );

//
//  Skip whitespace and return next character
//

BOOL ASkipWhiteSpace( PPARSESTATE State )
{
    while (*State->Token != NULLC && *State->Token <= SPACE) {
        State->Token++;
    }

    return *State->Token != NULLC;
}

TCHAR ANextChar( PPARSESTATE State )
{
    ASkipWhiteSpace( State );
    return *State->Token;
}

BOOL AParseVariable( PPARSESTATE State, PTCHAR *FirstChar, PTCHAR *EndOfName )
{
    TCHAR c = ANextChar( State );

    //
    //  Next char is a digit or operator, can't be a variable
    //
    
    if (c == NULLC
        || _istdigit( c )
        || _tcschr( szOps, c ) != NULL
        || _tcschr( szUnaryOps, c ) != NULL) {
        
        return FALSE;
    
    }

    *FirstChar = State->Token;

    //
    //  find end of variable
    //

    while (*State->Token &&
           *State->Token > SPACE &&
           !_tcschr( szUnaryOps, *State->Token ) &&
           !_tcschr( szOps, *State->Token ) ) {
        State->Token += 1;
    }

    *EndOfName = State->Token;
    return TRUE;
}

//      expr -> assign [, assign]*
PARSESTATE AParseExpr( PARSESTATE State )
{
    State = AParseAssign( State );

    while (State.Error == SUCCESS) {

        if (ANextChar( &State ) != TEXT( ',' )) {
            break;
        }
        State.Token++;

        State = AParseAssign( State );
    
    }
    
    return State;
}

//      assign -> VAR ASSIGNOP assign |                               
//                orlogexpr  
PARSESTATE AParseAssign( PARSESTATE State )
{
    TCHAR c = ANextChar( &State );
    PARSESTATE SavedState;

    SavedState = State;

    if (c == NULLC) {
        State.Error = MSG_SET_A_MISSING_OPERAND;
        return State;
    }
    
    //
    //  See if we have VAR ASSIGNOP
    //
    
    do {
        PTCHAR FirstChar;
        PTCHAR EndOfName;
        TCHAR OpChar;
        LONG OldValue;

        //
        //  Parse off variable
        //
        
        if (!AParseVariable( &State, &FirstChar, &EndOfName )) {
            break;
        }
        
        //
        //  Look for <op>=
        //

        OpChar = ANextChar( &State );

        if (OpChar == NULLC) {
            break;
        }

        if (OpChar != TEXT( '=' )) {
            if (_tcschr( szOps, OpChar ) == NULL) {
                break;
            }
            State.Token++;
            
            if (OpChar == TEXT( '<' ) || OpChar == TEXT( '>')) {
                if (ANextChar( &State ) != OpChar) {
                    break;
                }
                State.Token++;
            }
            
        }

        if (ANextChar( &State ) != TEXT( '=' )) {
            break;
        }
        State.Token++;
        
        //
        //  OpChar is the sort of operation to apply before assignment
        //  State has been advance to, hopefully, another assign.  Parse it
        //  and see where we get
        //

        State = AParseAssign( State );
        if (State.Error != SUCCESS) {
            return State;
        }

        OldValue = AGetValue( FirstChar, EndOfName );
        
        //
        //  Perform the operation and the assignment 
        //

        APerformArithmeticOperation( &State, OpChar, OldValue, State.Value );
        if (State.Error != SUCCESS) {
            return State;
        }

        State.Error = ASetValue( FirstChar, EndOfName, State.Value );

        return State;
    } while ( FALSE );

    //
    //  Must be orlogexpr.  Go back and parse over
    //

    return AParseOrLogExpr( SavedState );
}

//      orlogexpr -> xorlogexpr [| xorlogexpr]*             |
PARSESTATE
AParseOrLogExpr( PARSESTATE State )
{
    State = AParseXorLogExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '|' )) {
            break;
        }
        State.Token++;
        
        State = AParseXorLogExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      xorlogexpr ->  andlogexpr [^ andlogexpr]*           ^
PARSESTATE
AParseXorLogExpr( PARSESTATE State )
{
    State = AParseAndLogExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '^' )) {
            break;
        }
        State.Token++;
        
        State = AParseAndLogExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      andlogexpr ->  shiftexpr [& shiftexpr]*             &
PARSESTATE
AParseAndLogExpr( PARSESTATE State )
{
    State = AParseShiftExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '&' )) {
            break;
        }
        State.Token++;
        
        State = AParseShiftExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      shiftexpr -> addexpr [SHIFTOP addexpr]*             <<, >>
PARSESTATE
AParseShiftExpr( PARSESTATE State )
{
    State = AParseAddExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '<' ) && Op != TEXT( '>' )) {
            break;
        }
        State.Token++;
        
        if (Op != ANextChar( &State )) {
            State.Error = MSG_SET_A_MISSING_OPERATOR;
            return State;
        }
        State.Token++;
        
        State = AParseAddExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      addexpr -> multexpr [ADDOP multexpr]*               +, -
PARSESTATE
AParseAddExpr( PARSESTATE State )
{
    State = AParseMultExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '+' ) && Op != TEXT( '-' )) {
            break;
        }
        State.Token++;
        
        State = AParseMultExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      multexpr -> unaryexpr [MULOP unaryexpr]*            *, /, %
PARSESTATE
AParseMultExpr( PARSESTATE State )
{
    State = AParseUnaryExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '*' ) && Op != TEXT( '/' ) && Op != TEXT( '%' )) {
            break;
        }
        State.Token++;
        
        State = AParseUnaryExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      unaryexpr -> UNARYOP unaryexpr                      +, -, !, ~
//                   ( expr ) |                             ()
//                   NUMBER
//                   LITERAL
PARSESTATE
AParseUnaryExpr( PARSESTATE State )
{
    TCHAR c = ANextChar( &State );
    PTCHAR FirstChar;
    PTCHAR EndOfName;
    
    if (c == NULLC) {
        State.Error = MSG_SET_A_MISSING_OPERAND;
        return State;
    }
    
    //  ( expr )
    if (c == TEXT( '(' )) {
        State.Token++;
        State = AParseExpr( State );
        if (State.Error != SUCCESS) {
            return State;
        }
        c = ANextChar( &State );
        if (c != TEXT( ')' )) {
            State.Error = MSG_SET_A_MISMATCHED_PARENS;
        } else {
            State.Token++;
        }
        return State;
    }

    //  UNARYOP unaryexpr
    if (_tcschr( szUnaryOps, c ) != NULL) {
        State.Token++;
        State = AParseUnaryExpr( State );
        if (State.Error != SUCCESS) {
            return State;
        }
        APerformUnaryOperation( &State, c, State.Value );
        return State;
    }
    
    //  NUMBER
    if (_istdigit(c)) {
        State.Value = _tcstoul( State.Token, &State.Token, 0 );
        if (State.Value == ULONG_MAX && errno == ERANGE) {
            State.Error = MSG_SET_NUMBER_TOO_LARGE;
        } else if (_istdigit( *State.Token ) || _istalpha( *State.Token )) {
            State.Error = MSG_SET_A_INVALID_NUMBER;
        }
        return State;
    }
    
    //  Must be literal

    if (!AParseVariable( &State, &FirstChar, &EndOfName )) {
        State.Error = MSG_SET_A_MISSING_OPERAND;
        return State;
    }
    
    State.Value = AGetValue( FirstChar, EndOfName );
    return State;
}

/***    SetArithWork - set environment variable to value of arithmetic expression
 *
 *  Purpose:
 *      Set environment variable to value of arithmetic expression
 *
 *  int SetArithWork(TCHAR *tas)
 *
 *  Args:
 *      tas - pointer to null terminated string of the form:
 *
 *          VARNAME=expression
 *
 *  Returns:
 *      If valid expression, return SUCCESS otherwise FAILURE.
 *
 */

int SetArithWork(TCHAR *tas)
{
    PARSESTATE State;

    //
    // If no input, declare an error
    //
    if (!tas || !*tas) {
        PutStdErr(MSG_BAD_SYNTAX, NOARGS);
        return(FAILURE) ;
    }

    //
    //  Set up for parsing
    //
    
    State.Token = StripQuotes( tas );
    State.Value = 0;
    State.Error = SUCCESS;

    State = AParseExpr( State );
    if (State.Error == SUCCESS && ANextChar( &State ) != NULLC) {
        State.Error = MSG_SET_A_MISSING_OPERATOR;
    }
    
    if (State.Error != SUCCESS) {
        PutStdErr( State.Error, NOARGS );
        //printf( "%ws\n", tas );
        //printf( "%*s\n", State.Token - tas + 1, "^" );

    } else if (!CurrentBatchFile) {
        cmd_printf( TEXT("%d"), State.Value ) ;
    }

    return State.Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\clex.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    clex.c

Abstract:

    Lexical processing support

--*/

#include "cmd.h"

extern unsigned int DosErr;
extern jmp_buf CmdJBuf2; /* Used for error handling  */

extern TCHAR DTNums[];
extern TCHAR MsgBuf[];
extern unsigned msglen;                    /*    @@@@@@@@   */
int Necho = 0;                             /* No echo option */
extern BOOLEAN fDumpTokens;
extern int KeysFlag; /* @@5 */

unsigned DataFlag;      /* Tells FillBuf where to get its input    */
UINT_PTR DataPtr;       /* File handle/string ptr FillBuf...       */

int Ctrlc = 0;  /* flag - if set print a ctrl/c before next prompt */
int ExtCtrlc = 0; /* @@4 flag, if set print msg */
int AtIsToken;    /* @@4 flag, true if @ is a token */

/***
 * The lex buffer is called LexBuf. It holds characters as they are
 * retrieved one by one by GetByte. With the advent of double byte
 * characters, UnGetByte may be sometimes called upon to put back
 * up to two characters. To facilitate this, LexBuf is really an
 * alias for &LexBuffer[1]. This gives an extra byte in front of the
 * buffer for character push back. Every time fillbuf is called, it
 * copies the last character of the previous buffer into the byte
 * preceeding the normal buffer. Thus, when UnGetByte does a
 * LexBufPtr-- the pointer will correctly point at the preceeding character.
 */
TCHAR LexBuffer[LBUFLEN+3];      /* @@4 */
                                /* ...reads from Lexer input buffer   *M011*/
                                /* LBUFLEN characters + newline + null +   */
                                /* an extra byte for UnGetByte             */
#define LexBuf (&LexBuffer[1])
TCHAR *LexBufPtr;        /* Ptr to next byte in Lex's input buffer  */

TCHAR *PrevLexPtr;       /* M013 - New previous token pointer       */

TCHAR FrsBuf[LBUFLEN+1];

extern CHAR  AnsiBuf[];

extern TCHAR Fmt27[];

extern int NulNode;
extern TCHAR Fmt19[];
extern TCHAR DBkSpc[];
#if defined(FE_SB) // DDBkSpc[]
extern TCHAR DDBkSpc[];
#endif // defined(FE_SB)
extern unsigned global_dfvalue;            /* @@4 */

extern int EchoFlag;
extern TCHAR PromptStr[], CurDrvDir[], Delimiters[];
extern unsigned flgwd;
extern BOOL CtrlCSeen;

VOID    SetCtrlC();
VOID    ResetCtrlC();

//
// Prompt string special characters and associated print character/flag.
//
// These are the flags which may be placed in the flag field of the
// prompt_table structure to control PrintPrompt
//

#define PNULLFLAG   0
#define PTIMFLAG    1
#define PDATFLAG    2
#define PPATFLAG    3
#define PVERFLAG    4
#define PBAKFLAG    5   // destructive backspace flag
#define PNLNFLAG    6   // newline prompt flag
#define PDRVFLAG    7
#define PLITFLAG    8   // Print character in SpecialChar field
#define PDPTFLAG    9   // Print depth of pushd stack
#define PNETFLAG   10   // Print \\server\share or local for current drive

//
// Esc character used to mark a special prompt char. in prompt string
//
#define PROMPTESC DOLLAR

//
// Table of prompts for user.
//
typedef struct {
    TCHAR Char;         // Used to match esc. char. in user prompt
    TCHAR  Format;       // Used to print some string that has to be computed
    TCHAR Literal;      // When Format == PLITFLAG this is printed in prompt
    } PROMPT_ENTRY;

PROMPT_ENTRY PromptTable[] = {

       { TEXT('P'),PPATFLAG, NULLC },
       { TEXT('E'),PLITFLAG,'\033' },
       { TEXT('D'),PDATFLAG, NULLC },
       { TEXT('T'),PTIMFLAG, NULLC },
       { TEXT('B'),PLITFLAG, PIPOP   },
       { TEXT('G'),PLITFLAG, OUTOP   },
       { TEXT('H'),PBAKFLAG, NULLC },
       { TEXT('L'),PLITFLAG, INOP   },
       { TEXT('N'),PDRVFLAG, NULLC },
       { TEXT('S'),PLITFLAG, SPACE   },
       { TEXT('Q'),PLITFLAG, EQ   },
       { TEXT('V'),PVERFLAG, NULLC },
       { TEXT('_'),PNLNFLAG, NULLC },
       { DOLLAR,   PLITFLAG, DOLLAR   },
       { TEXT('A'),PLITFLAG, ANDOP   },
       { TEXT('C'),PLITFLAG, LPOP   },
       { TEXT('F'),PLITFLAG, RPOP   },
       { TEXT('+'),PDPTFLAG, NULLC },
       { TEXT('M'),PNETFLAG, NULLC },
       { NULLC,PNULLFLAG, NULLC}};

/***    InitLex - initialize the lexer's global variables
 *
 *  Purpose:
 *      Initialize DataFlag, DataPtr, LexBuf, and LexBufPtr.
 *
 *  InitLex(unsigned dfvalue, INT_PTR dpvalue)
 *
 *  Args:
 *      dfvalue - the value to be assigned to DataFlag
 *      dpvalue - the value to be assigned to DataPtr
 *
 */

void InitLex(dfvalue, dpvalue)
unsigned dfvalue;
INT_PTR dpvalue;
{
        DataFlag = dfvalue;
        DataPtr = dpvalue;
        *LexBuf = NULLC;
        PrevLexPtr = LexBufPtr = LexBuf;       /* M013 - Init new ptr     */


        DEBUG((PAGRP, LXLVL, "INITLEX: Dataflag = %04x  DataPtr = %04x", DataFlag, DataPtr));
}




/***    Lex - controls data input and token lexing
 *
 *  Purpose:
 *      Read in the next token or argstring and put it in tokbuf.
 *
 *  unsigned Lex(TCHAR *tokbuf, unsigned lflag)
 *
 *  Args:
 *      tokbuf - buffer used by lex to store the next token or
 *             - M013 if zero, indicates unget last token.
 *      lflag - bit 0 on if lex is to return an argument string, ie white space
 *          other than NLN is not considered a token delimiter
 *
 *  Returns:
 *      If the token is an operator, EOS, or NLN ret the 1st byte of the token.
 *      If the token is a command, REM arg or argstring, return TEXTOKEN.
 *      If the token is longer than MAXTOKLEN or the token is illegal, LEXERROR
 *      is returned.
 *
 *  Notes:
 *      The parser depends on the fact that the only values returned by
 *      Lex that are greater than 0xff are TEXTOKEN and LEXERROR.
 *
 */

unsigned Lex(tokbuf, lflag)
TCHAR *tokbuf;
unsigned lflag;
{
        int i;        /* Length of text token                    */
        TCHAR c,                 /* Current character                       */
                *tbcpy;         /* Copy of tokbuf                          */

        if(setjmp(CmdJBuf2)) {          /* M026 - Now msg printed prior    */
            return((unsigned)LEXERROR);  /* ...to arrival here              */
        }

/*  M013 - This code detects request to unget last token and if so, performs
           that function.  If not, it sets the previous token pointer to
           to equal the current token pointer.
*/
        if (tokbuf == LX_UNGET) {               /* Unget last token?       */

                DEBUG((PAGRP, LXLVL, "LEX: Ungetting last token."));

                if (fDumpTokens)
                    cmd_printf( TEXT("Ungetting: '%s'\n"), PrevLexPtr);
                LexBufPtr = PrevLexPtr;        /* If so, reset ptr...     */
                return(LX_UNGET);              /* ...and return           */
        } else {                                /* If not, set previous... */
                PrevLexPtr = LexBufPtr;        /* ...ptr to current...    */

                DEBUG((PAGRP, LXLVL, "LEX: lflag = %d", lflag));

        }                                     /* ...ptr and continue     */
/*  M013 ends   */

        tbcpy = tokbuf;


/*  M005 - Altered conditional below to also fail if the LX_REM bit
 *         is set making it "If !(arg | rem), eat whtspc & delims".
 */
        if (!(lflag & (LX_ARG|LX_REM))) {

                DEBUG((PAGRP, LXLVL, "LEX: Trashing white space."));

                while (TRUE) {
                    c = GetByte();
                    if (((_istspace(c) && c != NLN)
                        || (mystrchr(((lflag & LX_EQOK) ? &Delimiters[1] : Delimiters), c) && c)))
                       ;
                    else
                        break;
                }
                UnGetByte();
        }

/*  As of M016, operators of more than 2 characters can be lexed.  For now,
 *  these are assumed to be specific-handle redirection operators of the form
 *  'n>>' or 'n<<' and always begin with a digit.  TextCheck will not return
 *  a digit as an operator unless it is preceeded by whitespace and followed
 *  by '>' or '<'.  To simplify matters, handle substitution (ie., '...&n')
 *  is now lexed as part of a special five character operator, instead of
 *  looking at the '&n' as an argument.  ASCII filename arguments, however,
 *  are still lexed as separate tokens via another call to Lex.
 */
        if (TextCheck(&c, &lflag) == LX_DELOP) {
                *tokbuf++ = c;         /* The token is an operator        */

                if (_istdigit(c)) {               /* Next is '<' or '>'...   */
                        DEBUG((PAGRP, LXLVL, "LEX: Found digit operator."));
                        c = GetByte();         /* ...by definition or ... */
                        *tokbuf++ = c;         /* ...we wouldn't be here  */
                }

                if (c == PIPOP || c == ANDOP || c == OUTOP || c == INOP) {
                        if ((c = GetByte()) == *(tokbuf-1)) {
                                *tokbuf++ = c;
                                c = GetByte();
                        }

                        if (*(tokbuf-1) == OUTOP || *(tokbuf-1) == INOP) {
                                DEBUG((PAGRP,LXLVL, "LEX: Found redir."));
                                if (c == CSOP) {
                                        DEBUG((PAGRP,LXLVL, "LEX: Found >&"));
                                        *tokbuf++ = c;
                                        do {
                                                c = GetByte();
                                        } while (_istspace(c) ||
                                               mystrchr(Delimiters,c));

                                        if (_istdigit(c)) {
                                                *tokbuf++ = c;
                                                c = GetByte();
                                        }
                                }
/*  M016 ends   */
                        }
                        UnGetByte();
                }

                *tokbuf = NULLC;

                DEBUG((PAGRP, LXLVL, "LEX: Returning op = `%ws'", tbcpy));

                return(*tbcpy);
        }

        DEBUG((PAGRP, LXLVL, "LEX: Found text token %04x, Getting more.", c));

        *tokbuf++ = c;         /* Found text token, read the rest         */
        lflag |= LX_DBLOK;
        AtIsToken = 0;          /* @@4, treat @ as text now */
        for (i = (int)(tokbuf-tbcpy); TextCheck(&c, &lflag) != LX_DELOP && i < MAXTOKLEN; i++)
            *tokbuf++ = c;

        lflag &= ~LX_DBLOK;
        *tokbuf = NULLC;
        if (i < MAXTOKLEN)
                UnGetByte();

        if (i >= MAXTOKLEN && c != (TCHAR) -1) { /* Token too long, complain */

/* M025 */      PutStdErr(MSG_TOKEN_TOO_LONG, ONEARG, tbcpy );
                return((unsigned)LEXERROR);
        }

        DEBUG((PAGRP, LXLVL, "LEX: Return text = `%ws'  type = %04x", tbcpy, TEXTOKEN));

        return(TEXTOKEN);
}




/***    TextCheck - get the next character and determine its type
 *
 *  Purpose:
 *      Store the next character in LexBuf in *c.  If that character is a
 *      valid text token character, return it.  Otherwise return LX_DELOP.
 *
 *  int TextCheck(TCHAR *c, unsigned &lflag)
 *
 *  Args:
 *      c - the next character in the lexer input buffer is stored here.
 *      lflag - Bit 0 = On if lex is to return an argument string, ie.,
 *                      white space other than NLN is not a token delimiter.
 *              Bit 1 = On if a quoted string is being read, ie., only NLN
 *                      or a closing quote are delimiters.
 *              Bit 2 = On if equalsigns are NOT to be considered delimiters.
 *              Bit 3 = On if left parens are to be considered operators.
 *              Bit 4 = On if right parens are to be considered operators.
 *              Bit 5 = On if only NLN is to be a delimiter.
 *              Bit 6 = On iff the caller is willing to accept the second
 *                      half of a double byte character
 *
 *  Returns:
 *      Next character or LX_DELOP if a delimeter/operator character is found.
 *
 */

int TextCheck(c, lflag)
TCHAR *c;
unsigned *lflag;
{
        TCHAR i;                        /* M016 - Temp byte holder         */
        static int saw_dbcs_lead = 0;   /* remember if we're in the middle
                                           of a double byte character */
        *c = GetByte();

        if (saw_dbcs_lead) {
                saw_dbcs_lead = 0;
                if (*lflag & LX_DBLOK)  /* If second half of double byte is */
                        return(*c);     /* ok, return it, otherwise. . . */
                else
                        *c = GetByte(); /* go on to next character */
        }

        DEBUG((PAGRP, BYLVL, "TXTCHK: c = %04x  lflag = %04x", *c, *lflag));

        switch (*c) {
                case SILOP:             /* M017 - New unary operator       */
                                        /* ...binds like left paren        */

                        if ((*lflag & (LX_QUOTE|LX_REM)))      /* M005    */
                                break;

                        if( !AtIsToken )   /* If @ is not to be treated */
                          {                /* as token, then indicate  */
                            return( *c );  /* such  @@4    */
                          }

                case LPOP:              /* M002 - Moved these two cases    */

                        if ((*lflag & (LX_QUOTE|LX_REM)))      /* M005    */
                                break;

                        if(!(*lflag & GT_LPOP)) /* ...up and break if      */
                                break;         /* ...they are not to      */

                case RPOP:                      /* ...be treated as ops    */

                        if ((*lflag & (LX_QUOTE|LX_REM)))      /* M005    */
                                break;

                        if((!(*lflag & GT_RPOP)) && *c == RPOP)
                                break; /* M002 ends                       */

                case NLN:       /* M005 - NLN turns off QUOTE/REM flags    */
                case EOS:       /* @@5a - treat like NLN                   */

                        *lflag &= (~LX_QUOTE & ~LX_REM);       /* M005    */

                case CSOP:
                case INOP:      /* M005 - Note below that LX_DELOP...      */
                case PIPOP:     /* ...QUOTE mode or REM mode is in...      */
                case OUTOP:     /* ...in effect at the time                */

                        if (!(*lflag & (LX_QUOTE|LX_REM)))      /* M005    */
                                return(LX_DELOP);
        }

/*  M003 - If the character is '^', and the QUOTE mode flag is off,
 *         discard the current character, get the next one and return
 *         it as text.
 *  M005 - Extended this conditional to insure that both QUOTE and
 *         REM flags must be off for "escape" to occur.
 */
        if (*c == ESCHAR && !(*lflag & (LX_QUOTE|LX_REM))) {
            *c = GetByte();
            if (*c == NLN) {
                *c = GetByte( );

                //
                //  If we are at the end of the string, meaning that the
                //  command ended with ^ and there is an empty next command
                //  (most likely from a batch file), then we just treat
                //  this as a standard delimeter.
                //

                if (*c == EOS) {
                    return(LX_DELOP);
                }
            }

            return(*c);
        }

/*  M003/M005 end       */

        if (*c == QUOTE)                /* Flip quote mode flag bit        */
                *lflag ^= LX_QUOTE;

/*  M005 - Altered conditional below to also insure that REM flag was
 *         off before checking for any delimiters
 */
        if (!(*lflag & (LX_ARG|LX_QUOTE|LX_REM)) &&
            (_istspace(*c) ||
             mystrchr(((*lflag & LX_EQOK) ? &Delimiters[1] : Delimiters), *c)))
                return(LX_DELOP);

/*  As of M016, before accepting this character as text, it is now tested
 *  for being a digit followed by one of the redirection operators and;
 *  1) is the first character on a line, 2) is preceeded by whitespace or
 *  3) is preceeded by a delimiter (including Command's operators).  If it
 *  meets these conditions, it is a special, specific-handle redirection
 *  operator and TextCheck must return LX_DELOP so that Lex can build the
 *  remainder.  NOTE: LexBufPtr is advanced during GetByte, so that the
 *  current byte is *(LexBufPtr-1).
 */
        if (_istdigit(*c)) {
                DEBUG((PAGRP,BYLVL,"TXTCHK: Found digit character."));
                if ((LexBufPtr-LexBuf) < 2 ||
                    _istspace(i = *(LexBufPtr-2)) ||
                    mystrchr(TEXT("()|&=,;\""), i)) {

                        DEBUG((PAGRP,BYLVL,"TXTCHK: Digit follows delim."));

                        if (*LexBufPtr == INOP || *LexBufPtr == OUTOP) {
                            DEBUG((PAGRP,BYLVL,"TXTCHK: Found hdl redir"));

                            if (!(*lflag & (LX_QUOTE|LX_REM)))  /* M005 */
                                return(LX_DELOP);
                        }
                }
        }
/*  M016 ends   */

        return(*c);
}




/***    GetByte - return the next byte in the buffer
 *
 *  Purpose:
 *      Get the next byte from the lexer's input buffer.  If the buffer is
 *      empty, fill it first.  Update the buffer pointer.
 *
 *  TCHAR GetByte()
 *
 *  Return:
 *      The next character in the buffer or EOF.
 *
 *  Notes:
 *      All three types of input STDIN, FILE and STRING are treated
 *      the same now when it comes to dealing with CR/LF combinations.
 *      Keyboard input is massaged to look like file input.
 *      Invalid double byte characters are thrown away and not returned
 *      to the caller.
 *
 */

TCHAR GetByte()
{
        static int saw_dbcs_lead = 0;   /* remember if we're in the middle
                                           of a double byte character */
        TCHAR lead;                     /* variables for remember parts of
                                           double byte characters */

        if (!*LexBufPtr)
                FillBuf();

        DEBUG((PAGRP, BYLVL, "GTTCHAR: byte = %04x", *LexBufPtr));

        if (*LexBufPtr == CR && !saw_dbcs_lead) {
                                        /* M000 - removed file-only test   */
                LexBufPtr++;
                return(GetByte());
        }

        /* if this is a double byte character, look ahead to the next character
           and check for legality */
        if (saw_dbcs_lead) {
                saw_dbcs_lead = 0;
                return(*LexBufPtr++);
        }
        else {
                lead = *LexBufPtr++;
                return(lead);
        }
}




/***    UnGetByte - rewind the lexer buffer pointer 1 byte
 *
 *  Purpose:
 *      Back up the lexer's buffer pointer.  If the pointer already points
 *      to the beginning of the buffer, do nothing.
 *
 *  UnGetByte()
 *
 *  Return:
 *      Nothing.
 *
 */

void UnGetByte()
{
        if (!(LexBufPtr == LexBuffer))
                LexBufPtr--;
}


int
EditLine(
    CRTHANDLE CrtHandle,
    TCHAR *Buffer,	   /* the buffer to be filled */
    int MaxLength,	   /* the Maximum length of the buffer, */
	            	   /* including <CR> */
    int *ReturnLength  /* the number of characters in the buffer, not */
	            	   /* including the <CR> */
    )
{
    BOOL flag;

    flag = ReadBufFromInput( CRTTONT(CrtHandle), (TCHAR*)Buffer, MaxLength, ReturnLength);

    if (flag == 0 || *ReturnLength == 0) {
        return(GetLastError());
    } else {
        return(0);
    }
}



/***    FillBuf - read data to fill the lexer's buffer
 *
 *  Purpose:
 *      To fill the lexer's buffer with data from whatever source is indicated
 *      by the global variables DataFlag and DataPtr.  If reading from
 *      stdin, prompt for data.
 *
 *  FillBuf()
 *
 *  Notes:
 *    - Algorithm after M021 is as follows:
 *      copy last char of current buffer into LexBuffer[0] (which preceeds
 *              LexBuf by one byte) so the UnGetByte can unget two bytes
 *      If READSTDIN or READFILE
 *              If input is STDIN
 *                      Print correct prompt
 *              Use DOSREAD to fill primary buffer
 *              Copy to Lexer buffer so that primary buffer is usable by F3 key.
 *              Null terminate total input.
 *              Scan buffer for NLN || ^Z
 *              If none found
 *                      Error out
 *              Else
 *                      Terminate statement at NLN or ^Z (exclude ^Z iteself)
 *              If read was from file
 *                      Rewind to end of first statement
 *                      If file handle is STDIN
 *                              Echo statement to STDOUT
 *      Else
 *              Read first statement from string and reset pointer
 *      Reset Lexer Buffer Pointer to start of buffer
 *      Substitute for batch and environment variables (M026)
 *      Reset Previous Lexer Buffer Pointer to start of buffer
 *
 */

BOOL ReadFromStdInOkay = FALSE;

void FillBuf()
{

        long l;                        /* M004 - Data count in buffer     */

        TCHAR *sptr;           /* Copy of DataPtr                 */
        size_t i;                      /* Work variable                   */

        DWORD cnt;              /* Count of input bytes    */
        BOOL flag;

        //
        // clear this flag in case it was hit from previous command
        // if it is true we would not execute the next command
        //
        ResetCtrlC();
        LexBuffer[0] = *(LexBufPtr - 1);
        switch (DataFlag & FIRSTIME) {
                case READFILE:
                case READSTDIN:
                        if ((DataFlag & FIRSTIME) == READSTDIN ||
                            DataPtr == STDIN) {
                                if (DataFlag & NOTFIRSTIME) {
/* M025 */                              PutStdOut(MSG_MS_MORE, NOARGS);
                                } else {
                                        PrintPrompt();
                                        DataFlag |= NOTFIRSTIME;

                                        DEBUG((PAGRP, LFLVL, "FLBF: Reading stdin"));
                                }
                        }

                        //
                        // clear in case ^c seen while printing prompt
                        //
                        ResetCtrlC();
                        DEBUG((PAGRP, LFLVL, "FLBF: Reading handle %d", DataPtr));
                        //
                        // If input is STDIN and piped or input is from a
                        // device but not console input (flgwd == 1)
                        //
                        if ( ( DataPtr == STDIN ) && ( FileIsPipe( STDIN ) ||
                           ( FileIsDevice( STDIN ) && (!(flgwd & 1)) ) ) ) {

                          cnt = 0;
                          while (
                          ( cnt < LBUFLEN) &&   /* ##1 */
                          ( (ReadBufFromFile(CRTTONT((CRTHANDLE)DataPtr),
                                  &FrsBuf[cnt], 1, (LPDWORD)&i)) != 0 ||
                            GetLastError() == ERROR_MORE_DATA) &&
                          ( i != 0 )
                          ) {
                               cnt++;
                               if ( FrsBuf[cnt-1] == NLN ){
                                  break;
                               } /* endif */
                            }
                        } else if ( ( DataPtr == STDIN ) &&
                                      FileIsDevice( STDIN ) &&
                                      (flgwd & 1) ) {

                            //
                            // Are reading from stdin and it is a device
                            // (not a file) and it is console input
                            //
                            if ( KeysFlag ) {
                                i = EditLine( (CRTHANDLE)DataPtr, FrsBuf, LBUFLEN, &cnt );
                            }
                            else {
                                ResetCtrlC();
                                if (ReadBufFromConsole(
                                             CRTTONT((CRTHANDLE)DataPtr),
                                             FrsBuf,
                                             LBUFLEN,
                                             &cnt) ) {

                                    //
                                    // Check that ^c's on the current line.
                                    // Could be the case where ^c thread
                                    // came in from a previous line
                                    //
                                    //
                                    // also if cnt is 0 then outpt crlf to
                                    // prevent two prompts on command line
                                    //

                                    if (cnt == 0) {

                                        if (GetLastError() == ERROR_OPERATION_ABORTED) {
                                            cmd_printf(CrLf);
                                            longjmp(CmdJBuf2, -1);
                                        }
                                        cmd_printf(CrLf);
                                    }
                                    i = 0;
                                    DEBUG((PAGRP, LFLVL, "FLBF: ReadFile %d bytes", cnt));
                                } else {
                                    cnt = 0;
                                    i = GetLastError();
                                    DEBUG((PAGRP, LFLVL, "FLBF: ReadFile %d bytes and error %d", cnt, i));
                                }
                            }
                        }
                        else {
                          flag = ReadBufFromFile(
                                        CRTTONT((CRTHANDLE)DataPtr),
                                        FrsBuf, LBUFLEN, (LPDWORD)&cnt);
                          DEBUG((PAGRP, LFLVL, "FLBF: Read %d bytes", cnt));
                          if (CtrlCSeen) {
                              ResetCtrlC();
                              longjmp(CmdJBuf2, -1);
                              //  Abort();
                          }

                          if (flag == 0 || (int)cnt <= 0) {
                            cnt = 0;
                            i = GetLastError();
                          }
                          else {
                            i = 0;
                          }
                        }
                        DEBUG((PAGRP, LFLVL, "FLBF: I made it here alive"));
                        if (!cnt && DataPtr == STDIN) {

                                DEBUG((PAGRP,LFLVL,"FLBF: ^Z from STDIN!"));
                                DEBUG((PAGRP,LFLVL,"      READFILE retd %d",i));

                                if (FileIsDevice(STDIN) && ReadFromStdInOkay) {

                                        DEBUG((PAGRP,LFLVL,"FLBF: Is device, fixing up buffer"));
                                        FrsBuf[0] = NLN;
                                        ++cnt;
                                } else {

                                        DEBUG((PAGRP,LFLVL,"FLBF: Is file, aborting!!!"));
                                        ExitAbort(EXIT_EOF);
                                }
                        } else if (!ReadFromStdInOkay && cnt && DataPtr == STDIN) {
                            ReadFromStdInOkay = TRUE;
                        }

                        cnt = LexCopy(LexBuf, FrsBuf, cnt);

                        DEBUG((PAGRP, LFLVL, "FLBF: Received %d characters.", cnt));

                        *(LexBuf+cnt) = NULLC;         /* Term with NULL  */

/* Have total bytes read.  Now scan for NLN or ^Z.  Either means end of
 * input statement, neither in 128 bytes means buffer overflow error.
 */
                        if((i = mystrcspn(LexBuf, TEXT("\n\032"))) < mystrlen(LexBuf)
                                || cnt == 0) {  /*M029*/

                DEBUG((PAGRP, LFLVL, "FLBF: Scan found %04x", *(LexBuf+i)));
                DEBUG((PAGRP, LFLVL, "FLBF: At position %d", i));

                                sptr = LexBuf+i;       /* Set pointer     */

                                if(*sptr == CTRLZ) {
                                    *sptr = NLN;
                                }

                                if(*sptr == NLN) {      /* If \n, inc...   */
                                        ++sptr;        /* ...ptr & sub    */
                                        l = cnt - ++i; /* ....whats used  */
/*  M014 ends   */                      i = FILE_CURRENT;
                                } else {                /* If ^Z, go EOF   */
                                        l = 0;
                                        i = FILE_END;
                                }

                DEBUG((PAGRP,LFLVL,"FLBF: Changing %04x to NULLC",*(sptr-1)));

                                *sptr = NULLC;         /* Term valid input */
                                if (!FileIsDevice((CRTHANDLE)DataPtr)) {
                                        SetFilePointer(CRTTONT((CRTHANDLE)DataPtr), -l, NULL, i);

                                DEBUG((PAGRP, LFLVL, "FLBF: Rewound %ld", l));

                                        if ((DataPtr == STDIN) && (!Necho)) {
                                            CmdPutString( LexBuf );
                                        }
                                }

                        } else if(i >= LBUFLEN) {       /*M029*/

/* @@4 */                      if ( global_dfvalue == READFILE )
/* @@4 */                         {
/* @@4 */                         if ( EchoFlag == E_ON )
/* @@4 */                            {
/* @@4 */                                DEBUG((PAGRP, LXLVL,
/* @@4 */                                "BLOOP: Displaying Statement."));
/* @@4 */
/* @@4 */                                PrintPrompt();
/* @@4 */                                cmd_printf(&LexBuffer[1]);
/* @@4 */                                cmd_printf(CrLf);
/* @@4 */                            }
/* @@4 */                             PutStdErr(MSG_LINES_TOO_LONG, NOARGS);
/* @@4 */                             Abort();
/* @@4 */                         }

                                PutStdErr(MSG_LINES_TOO_LONG, NOARGS);
/* M028 */                      if(DataPtr == STDIN && FileIsDevice((CRTHANDLE)DataPtr))
                                        FlushKB();
                                longjmp(CmdJBuf2,-1);
                        }
                        break;

                case READSTRING:

                        DEBUG((PAGRP, LFLVL, "FLBF: Reading string."));

                        *(LexBuf+LBUFLEN) = NULLC;     /* Term max string */
                        _tcsncpy(LexBuf, (TCHAR *) DataPtr, LBUFLEN);
                        DataPtr += mystrlen(LexBuf)*sizeof(TCHAR);   /* Update DataPtr  */

                        DEBUG((PAGRP, LFLVL, "FLBF: New DataPtr = %ws", DataPtr));
                        break;
        }

        LexBufPtr = LexBuf;            /* M004 - Reset pointer            */

        SubVar();                      /* Sub env & batch vars (M026)     */

        DEBUG((PAGRP, LFLVL, "FLBF: Buffer contents: `%ws'", LexBufPtr));

/*  Insure that when buffer is refilled, the previous token pointer is
 *  reset to the start of the lexer buffer
 */
        PrevLexPtr = LexBufPtr;
}


/***   LexCopy - copy the lex buffer
 *
 *  Purpose:
 *      To copy the contents read into the dos buffer into LexBuf,
 *      translating double byte spaces into regular spaces in the
 *      process.
 *  Input:
 *      A to and from pointer and a byte count.
 *  Returned:
 *      A new byte count which might be smaller than that passed in.
 */
int LexCopy(to, from, count)
TCHAR *to, *from;
int count;
{

    _tcsncpy( to, from, count );
    return count;

}

BOOLEAN PromptValid;
TCHAR PromptVariableBuffer[ 512 ];
TCHAR PromptBuffer[ 1024 ];

void
PrintPrompt()

/*++

Routine Description:

    To print Command's main input prompt and to interpret the special
    characters in it (see MSDOS manual for list of special prompt
    characters).

    An array of PROMPT_ENTRY structures called PromptTable is searched for
    the special characters.  If a match is found , then either print out
    the special character if the format field is PLITFLAG or do some
    sort of special processing to print out the prompt string such as
    get time of day etc.

Arguments:


Return Value:


--*/

{
        TCHAR *pszPrompt;
        TCHAR *s;
        int nLeft, nUsed;
        ULONG idx;
#if defined(FE_SB)
        // This local variable is used for determine the last
        // character is full width character (=DBCS) or not.
        TCHAR chLast = NULLC;
#endif
        if (CtrlCSeen) {
                PutStdOut(MSG_C, NOARGS);
                ResetCtrlC();
                // Abort();
        }

//
// The newline which must preceed the prompt is tied to prompt rather than to
// command completion in Dispatch.
//
// Also return without newline or prompt if echo status is "echo off".
//
    if (EchoFlag == E_OFF) {
        return;
    }

    if (!NulNode) {
        cmd_printf(CrLf);
    }

    if ( PromptValid ) {
        pszPrompt = PromptVariableBuffer;
        }
    else {
        //
        // Fetch user prompt string from environment (should be PROMPT)
        //
        pszPrompt = GetEnvVar(PromptStr);
        if ( pszPrompt ) {
            mystrcpy( PromptVariableBuffer, pszPrompt);
            pszPrompt = PromptVariableBuffer;
            PromptValid = TRUE;
            }
        }
    //
    // refetch the current directory,  since we may have lost the
    // drive letter due to net disconnect
    //
    GetDir(CurDrvDir, GD_DEFAULT);
    DEBUG((PAGRP, LFLVL, "PRINTPROMPT: pszPrompt = `%ws'", pszPrompt));

    s = PromptBuffer;
    *s = NULLC;
    nLeft = sizeof(PromptBuffer) / sizeof(TCHAR);

    //
    // Check if there was a prompt string.
    // If there is not prompt string then just print current drive
    //
    if (!pszPrompt || !*pszPrompt) {
        nUsed = _sntprintf( s, nLeft, Fmt27, CurDrvDir);
        s += nUsed;
        nLeft -= nUsed;

    } else {

        //
        // Loop through interpreting prompt string
        //
        for (; *pszPrompt; pszPrompt++) {

            //
            // Look for the escape character in prompt for special
            // processing
            //
            if (*pszPrompt != PROMPTESC) {

                nUsed = _sntprintf( s, nLeft, Fmt19, *pszPrompt);
                s += nUsed;
                nLeft -= nUsed;

#if defined(FE_SB)
                // If character is full width character, mark it.
                if (IsDBCSCodePage() &&
                    IsFullWidth(*pszPrompt))
                    chLast = *pszPrompt;
                 else
                    chLast = NULLC;
#endif

            } else {

                //
                // There is an escape character in prompt string.
                // Try to find a match for next character after escape
                // character from prompt table.
                //
                pszPrompt++;
                for (idx = 0; PromptTable[idx].Char != NULLC; idx++)
                    if (_totupper(*pszPrompt) == PromptTable[idx].Char) {

                        break;
                    }

                if (PromptTable[idx].Char == NULLC) {

                    //
                    // Could find no match for escape. Exit loop to print
                    // what we have so far
                    //
                    break;

                } else {

                    if (PromptTable[idx].Format == PLITFLAG) {

                        nUsed = _sntprintf( s, nLeft, Fmt19, PromptTable[idx].Literal);
                        s += nUsed;
                        nLeft -= nUsed;

                    } else {

                        switch (PromptTable[idx].Format) {

                        case PTIMFLAG:

                            nUsed = PrintTime(NULL, PT_TIME, s, nLeft);
                            s += nUsed;
                            nLeft -= nUsed;
                            break;

                        case PDATFLAG:

                            nUsed = PrintDate(NULL, PD_DATE, s, nLeft);
                            s += nUsed;
                            nLeft -= nUsed;
                            break;

                        case PPATFLAG:

                            nUsed = _sntprintf( s, nLeft, TEXT( "%s" ), CurDrvDir);
                            s += nUsed;
                            nLeft -= nUsed;
                            break;

                        case PVERFLAG:
                            {
                                TCHAR VersionFormat[32];
                                PTCHAR Message;
                                GetVersionString( 
                                    VersionFormat, 
                                    sizeof( VersionFormat ) / sizeof( VersionFormat[0] ));
                                Message = GetMsg( MSG_MS_DOS_VERSION, VersionFormat );
                                nUsed = _sntprintf( s, nLeft, TEXT( "%s" ), Message );
                                s += nUsed;
                                nLeft -= nUsed;
                                LocalFree( Message );
                            }

                            break;

                        case PBAKFLAG:

#if defined(FE_SB) // PrintPrompt()
                            // if the last character is full width character.
                            // we should delete 2 bytes.
                            if (chLast != NULLC)
                                nUsed = _sntprintf( s, nLeft, DDBkSpc);
                             else
                                nUsed = _sntprintf( s, nLeft, DBkSpc);
#else
                            nUsed = _sntprintf( s, nLeft, DBkSpc);
#endif
                            s += nUsed;
                            nLeft -= nUsed;
                            break;

                        case PNLNFLAG:

                            nUsed = _sntprintf( s, nLeft, CrLf);
                            s += nUsed;
                            nLeft -= nUsed;
                            break;

                        case PDPTFLAG:
                            //
                            //  $+ generates from zero to N plus characters, depending upon
                            //     the depth of the PUSHD directory stack.
                            //
                            if (fEnableExtensions) {
                                int Depth = GetDirStackDepth( );

                                while (nLeft && Depth--) {
                                    *s++ = TEXT( '+' );
                                    nLeft--;
                                }
                            }
                                
                            break;

                        case PNETFLAG:
                            //
                            //  $m generates the empty string if the current drive is not a
                            //     network drive.  If it is, then $m generates the \\server\share
                            //     name with a trailing space.
                            //
                            if (!fEnableExtensions) {
                                break;
                            }

                            {
                                TCHAR CurDrive[4];
                                TCHAR NetPath[MAX_PATH];
                                DWORD n, Err;


                                _tcsncpy( CurDrive, CurDrvDir, 2 );
                                CurDrive[2] = BSLASH;
                                CurDrive[3] = NULLC;
                                if (GetDriveType( CurDrive ) != DRIVE_REMOTE) {
                                    break;
                                }
                                
                                CurDrive[2] = NULLC;
                                n = MAX_PATH;
                                
                                try {
                                    Err = WNetGetConnection( CurDrive, NetPath, &n );
                                } except( Err = GetExceptionCode( ), EXCEPTION_EXECUTE_HANDLER) {
                                }
                                
                                switch (Err) {
                                case NO_ERROR:
                                    nUsed = _sntprintf( s, nLeft, TEXT("%s "), NetPath);
                                    s += nUsed;
                                    nLeft -= nUsed;
                                    break;

                                case ERROR_NOT_CONNECTED:
                                    break;

                                default:
                                    nUsed = _sntprintf( s, nLeft, TEXT("Unknown"));
                                    s += nUsed;
                                    nLeft -= nUsed;
                                    break;
                                }
                            }
                            break;

                        default:
                            nUsed = _sntprintf( s, nLeft, Fmt19, CurDrvDir[0]);
                            s += nUsed;
                            nLeft -= nUsed;
                        }
                    }
                }
            }
        } // for
    } // else

    *s = NULLC;
    CmdPutString( PromptBuffer );

    //
    // If ^c seen while printing prompt blow it away
    //
    if (CtrlCSeen) {
        ResetCtrlC();
    }

}




/***    IsData - check the input buffer
 *
 *  Purpose:
 *      Check the lexer's input buffer to see if there is data in it.
 *
 *  int IsData()
 *
 *  Returns:
 *      TRUE if the buffer has data in it.
 *      FALSE if the buffer is empty.
 *
 */

int IsData()
{
        DEBUG((PAGRP, LXLVL, "ISDATA: *LexBufPtr = %04x", *LexBufPtr));

        if (*LexBufPtr)
                return(TRUE);

        return(FALSE);
}




/***    SubVar - Substitute for environment variables. (M004)
 *
 *  Purpose:
 *      This function scans the lexer input buffer looking for percent
 *      signs and substituting batch variables and environment variables
 *      as they are found.
 *
 *  void SubVar()
 *
 *  NOTES:
 *    - This function does not return if expansion causes length to exceed
 *      maximum line length (LBUFLEN).
 *    - M026 caused complete rewrite to perform batch variable substitution
 *      at the lexer stage rather than in batch processing.  Note that the
 *      printing of error messages can now be either line too long or token
 *      too long, so error printing occurs before the longjmp() call.
 */

void SubVar()
{
    TCHAR lxtmp[LBUFLEN+1];         /* Temporary holding buffer        */
    int dlen;             /* Temps & counters                */
    int j, slen;
    TCHAR *srcp = lxtmp;            /* Src byte pointer                */
    TCHAR *substr = NULL;           /* Possible Env Var pointer        */
    TCHAR c;               /* Temp byte holder                */

    mystrcpy(srcp,LexBufPtr);      /* Make a copy of the input        */

    DEBUG((PAGRP, LXLVL, "SBENV: Copy = %ws", srcp));

    dlen = j = slen = 0;   /* Zero the counters               */

    while ((c = *srcp++) && dlen <= LBUFLEN + 1) {
        if (c != PERCENT) {
            *LexBufPtr++ = c;
            ++dlen;
            if (c == NLN)    /* Stop subst. if statement end    */
                break;
            continue;
        }

        DEBUG((PAGRP,LXLVL,"SBVAR: Found `%%' in input"));
        DEBUG((PAGRP,LXLVL,"SBVAR: Current pair is `%c%c'",c,*srcp));

        if (CurrentBatchFile && *srcp == PERCENT) {

            DEBUG((PAGRP,LXLVL,"SBVAR: Found `%%%%' in batch file"));

            *LexBufPtr++ = *srcp++;
            ++dlen;
            continue;
        }

        //
        // If inside a command script and extensions are enabled,
        // expand %* into all the arguments (%1 through %n).
        //
        if (CurrentBatchFile && fEnableExtensions && *srcp == STAR) {
            ++srcp;                /* Kick past star          */

            slen = mystrlen(CurrentBatchFile->orgargs);
            substr = CurrentBatchFile->orgargs;
            DEBUG((PAGRP,LXLVL,"SBVAR: Found batch var %*"));
            DEBUG((PAGRP,LXLVL,"SBVAR:   - len = %d", slen));
            DEBUG((PAGRP,LXLVL,"SBVAR:   - var = %ws", substr));

            if (slen > 0) {
                if (dlen+slen > MAXTOKLEN) {

                    DEBUG((PAGRP,LXLVL,"SBVAR: Too Long!"));

                    _tcsncpy(LexBufPtr,substr,MAXTOKLEN - dlen);
                    LexBuf[MAXTOKLEN] = NULLC;
                    PutStdErr(MSG_TOKEN_TOO_LONG, ONEARG,LexBuf);
                    longjmp(CmdJBuf2,-1);
                }

                mystrcpy(LexBufPtr, substr);
                dlen += slen;
                LexBufPtr += slen;

                DEBUG((PAGRP,LXLVL,"SBVAR: Subst complete; dest = `%ws'", LexBuf));
            } else {

                DEBUG((PAGRP,LXLVL,"SBVAR: Var %* undefined"));
            }

            continue;
        }

        //
        // If inside a command script attempt to expand variable references
        // of the form %n where n is a digit from 0 to 9
        //
        // If not in a command script or not a variable reference see if
        // this is an environment variable expansion request.
        //
        if ((CurrentBatchFile != NULL
             && (substr = MSCmdVar( &CmdJBuf2, srcp, &j, TEXT("0123456789"), CurrentBatchFile->aptrs ))) 
            || (substr = MSEnvVar( &CmdJBuf2, srcp, &j, PERCENT )) != NULL ) {

            DEBUG((PAGRP,LXLVL,"SBVAR: Found var %ws", substr));

            //
            // Either variable reference or environment variable reference.
            // Copy the result to the input buffer
            //
            slen = mystrlen( substr );
            dlen += slen;
            if (dlen  > LBUFLEN + 1) {
                PutStdErr( MSG_LINES_TOO_LONG, NOARGS );
                longjmp( CmdJBuf2, -1 );
            }
            mystrcpy( LexBufPtr, substr );
            LexBufPtr += slen;
            srcp += j;
        } else {

            DEBUG((PAGRP,LXLVL,"SBVAR: No var found"));

            //
            // Variable not found.  If inside of command script, toss
            // the variable reference in the bit bucket.  If not in a
            // command script pass the characters that make up the reference
            // into the input buffer.  User will see their mistake shortly.
            //
            if (CurrentBatchFile) {
                srcp += j;
            } else {
                *LexBufPtr++ = c;
                dlen++;
            }
        }
    }

    *LexBufPtr = NULLC;            /* Terminate Statement             */
    LexBufPtr = LexBuf;            /* Reset Pointer to start          */

    if (dlen > LBUFLEN+1) {          /* Statement too long??            */
        *LexBufPtr = NULLC;    /* If so, kill line, print err     */
        PutStdErr(MSG_LINES_TOO_LONG, NOARGS);
        longjmp(CmdJBuf2,-1);
    }
}




/***    MSEnvVar - Does environment variable substitution
 *
 *  Purpose:
 *      When percent signs are found in the newly filled lexer buffer,
 *      this function is called to determine if there is an environment
 *      variable substitution possible.
 *
 *  TCHAR *MSEnvVar(TCHAR *str, int *supdate, TCHAR delim)
 *
 *  Args:
 *      errjmp  - optional pointer to jmp_buf for errors
 *      str     - pointer to a possible environment variable name
 *      supdate - location to place env variable name length in
 *      delim   - delimiter character to look for (e.g. PERCENT)
 *
 *  Returns:
 *      If there is no ending delim,
 *              set supdate to 0
 *              return NULL
 *      else
 *              set supdate to the enclosed string length
 *              if the string is not an environment variable
 *                      return NULL
 *              else
 *                      return a pointer to the replacement string
 *
 *  Notes:
 *    - M026 changed the way this function works so that supdate will
 *      contain the string length if any string was found.  This allows
 *      the string to be deleted if within a batch file.
 *
 */

TCHAR *MSEnvVar(errjmp, str, supdate, delim)
jmp_buf *errjmp;
TCHAR *str;
int *supdate;
const TCHAR delim;
{
    TCHAR TempBuf[LBUFLEN];
    TCHAR *w0;                     /* Points to ending delim          */
    TCHAR *w1;                     /* Will hold ptr to env var value  */
    TCHAR *w2;
    TCHAR *SearchString;
    TCHAR *SearchStringEnd;
    int SearchLength;
    TCHAR *ReplaceString;
    TCHAR *ReplaceStringEnd;
    int ReplaceLength;
    TCHAR TerminatingChar;
    int noff, nlen;
    BOOL PrefixMatch;

    //
    //  Search for character that terminates the environment variable.
    //  This can be either the passed-in delimiter or a COLON
    //  (when extensions are enabled) as long as the colon isn't
    //  immediately followed by the delimiter.  In this case, we
    //  treat the colon as part of the environment variable name.
    //

    w0 = str;
    while (
           //   Stop at end of string
           *w0 != NULLC &&

           //   Stop at delimiter
           *w0 != delim &&

           //   Stop if extensions and colon not followed by delimiter
           (!fEnableExtensions || w0[0] != COLON || w0[1] == delim)) {

        w0++;
    }

    DEBUG((PAGRP, LFLVL, "MSENVVAR: *w0 = %04x", *w0));

    //
    //  If there is no further text or if there are two delimiters
    //  in a row then the env var is not well formed and we terminate
    //

    if ( *w0 == NULLC || w0 == str) {
        *supdate = 0;
        return NULL;
    }

    //
    //  We have pointers to the start and end of the environment variable name.
    //  Terminate the name, look it up in the environment and restore the
    //  original name
    //

    TerminatingChar = *w0;
    *w0 = NULLC;

    DEBUG((PAGRP, LFLVL, "MSENVVAR: Possible env var = `%ws'", str));

    w1 = GetEnvVar(str);

    //
    //  w1 points to the environment variable value in a buffer that we 
    //  can use.  This static buffer is good until the next GetEnvVar call.
    //

    *w0++ = TerminatingChar;

    //
    //  If Command Extensions are enabled, then we support munging the
    //  output of environment variable expansion.  Here is the supported
    //  syntax, all keyed off a trailing COLON character at the end of
    //  the environment variable name.  Note, that %FOO:% is treated
    //  as it was before.
    //
    //  Environment variable substitution has been enhanced as follows:
    //
    //      %PATH:str1=str2%
    //
    //  would expand the PATH environment variable, substituting each
    //  occurrence of "str1" in the expanded result with "str2".  "str2" can
    //  be the empty string to effectively delete all occurrences of "str1"
    //  from the expanded output.  Additionally:
    //
    //      %PATH:~10,5%
    //
    //  would expand the PATH environment variable, and then use only the 5
    //  characters that begin at the 11th character of the expanded result.
    //  If the ,5 is left off, it will take the entire remainder of the
    //  expanded result.
    //

    //
    //  If we aren't doing extensions or we have a simple replacement
    //  or the named environment variable has no value then we're done.
    //
    //  Note that we must do this for non-existent environment variables
    //  since the following will generate big problems:
    //      for %i in (c:foo) do ...
    //  The % will introduce an environment variable and the : will indicate
    //  a substitution.  If we were to delete the above text, things break.
    //

    if (!fEnableExtensions 
        || TerminatingChar != COLON 
        || w1 == NULL) {
        *supdate = (int)(w0 - str);
        return w1;
    }

    if (*w0 == EQI) {

        //
        //  We are extracting a substring   %PATH:~10,5%
        //

        w0 += 1;

        //
        //  Parse the offset within the environment string.  A
        //  negative number indicates an offset from the right end of
        //  the string.
        //

        noff = _tcstol( w0, &w0, 0 );
        if (noff < 0) {
            noff += _tcslen( w1 );
        }

        noff = max( 0, min( noff, (int)_tcslen( w1 )));

        //
        //  If a comma is present, what follows is the maximum length
        //  to be copied.  Parse off this number, negative turns into
        //  an offset from the right of the string
        //

        if (*w0 == COMMA) {
            //
            //  The length is specified; extract it and bound it by the
            //  length of the entire string
            //
            w0 += 1;
            nlen = _tcstol( w0, &w0, 0 );

            if (nlen < 0) {
                nlen += _tcslen( w1 + noff );
            }

            nlen = max( 0, nlen );
            nlen = min( nlen, (int)_tcslen( w1 + noff ));
        } else {
            nlen = _tcslen( w1 + noff );
        }

        //
        //  Copy from the string up to the requested length or the
        //  terminating NUL
        //

        _tcsncpy( w1, w1+noff, nlen );
        
        //
        //  Terminate the string.  We need to be extra careful here since the string
        //  may be the null string above which is in READ/ONLY memory.
        //
        
        if (w1[nlen] != NULLC) {
            w1[nlen] = NULLC;
        }

        //
        //  We must have a terminating delimiter to make this a valid
        //  substitution.
        //

        if (*w0++ != delim) {
            *supdate = 0;
            return NULL;
        }

        *supdate = (int)(w0 - str);

    } else {

        //
        // Not extracting a string, so must be search and replacing
        //
        //  %PATH:str1=str2%
        //
        //  Test for asterisk and skip forward looking for = sign or
        //  end of string
        //

        if (*w0 == STAR) {
            w0++;
            PrefixMatch = TRUE;
        } else {
            PrefixMatch = FALSE;
        }

        SearchString = w0;
        while (*w0 != NULLC && *w0 != EQ) {
            w0 += 1;
        }

        //
        //  No equal sign is no substitution
        //

        if (*w0 == NULLC) {
            *supdate = 0;
            return NULL;
        }

        SearchStringEnd = w0;
        SearchLength = (int)(SearchStringEnd - SearchString);

        //
        //  An empty search string is a syntax error
        //

        if (SearchLength == 0) {
            if (errjmp != NULL) {
                PutStdErr( MSG_SYNERR_GENL, ONEARG, SearchStringEnd );
                longjmp( *errjmp, -1 );
            }

            *supdate = 0;
            return NULL;
        }

        //
        //  Find end of replacement string
        //

        w0++;
        ReplaceString = w0;
        while (*w0 && *w0 != delim) {
            w0 += 1;
        }

        //
        //  No terminating delimiter is no substitution
        //

        if (*w0 == NULLC) {
            *supdate = 0;
            return NULL;
        }

        ReplaceStringEnd = w0++;
        ReplaceLength = (int)(ReplaceStringEnd - ReplaceString);

        //
        //  Everything is well-formed now.  Set the correct number
        //  of source chars to be skipped.
        //

        *supdate = (int)(w0 - str);

        //
        //  If there's actually a string to replace
        //
        
        if (*w1 != TEXT( '\0' )) {
            
            //
            //  Copy env var into temp buffer so that we can
            //  perform a replacement copy back to original buffer
            //

            _tcscpy( TempBuf, w1 );
            w2 = TempBuf;
            w0 = w1;

            //
            //  Walk forward through w2 trying to find instances of
            //  the search string and replacing them into w2
            //

            while (TRUE) {
                if (!_tcsnicmp( w2, SearchString, SearchLength )) {

                    //
                    //  A prefix match means replacing everything from the
                    //  beginning of the string through the end of the search
                    //  match with the replacement string and then bailing
                    //

                    if (PrefixMatch) {
                        _tcsncpy( w1, ReplaceString, ReplaceLength );
                        _tcscpy( w1 + ReplaceLength, w2 + SearchLength );
                        break;
                    }

                    //
                    //  Otherwise, we copy in the replacement string and
                    //  skip over the search string
                    //

                    _tcsncpy( w0, ReplaceString, ReplaceLength );
                    w0 += ReplaceLength;
                    w2 += SearchLength;

                } else {

                    //
                    //  Not a match, copy this one character
                    //

                    *w0++ = *w2++;
                    if (w0[-1] == NULLC) {
                        break;
                    }
                }
            }
        }
    }

    return w1;
}


struct {
    ULONG dwAttributeFlag;
    TCHAR chAttributeChar;
} rgAttrToCharMap[] = {
    {FILE_ATTRIBUTE_DIRECTORY ,     TEXT('d')},
    {FILE_ATTRIBUTE_READONLY  ,     TEXT('r')},
    {FILE_ATTRIBUTE_ARCHIVE   ,     TEXT('a')},
    {FILE_ATTRIBUTE_HIDDEN    ,     TEXT('h')},
    {FILE_ATTRIBUTE_SYSTEM    ,     TEXT('s')},
    {FILE_ATTRIBUTE_COMPRESSED,     TEXT('c')},
    {FILE_ATTRIBUTE_OFFLINE   ,     TEXT('o')},
    {FILE_ATTRIBUTE_TEMPORARY ,     TEXT('t')},
    {FILE_ATTRIBUTE_REPARSE_POINT,  TEXT('l')},
    {0, NULLC}
};

/***    MSCmdVar - Does command variable substitution
 *
 *  Purpose:
 *      When percent signs are found in the newly filled lexer buffer,
 *      this function is called to determine if there is a command processor
 *      variable substitution possible.
 *
 *  TCHAR *MSCmdVar(TCHAR *srcp, int *supdate, TCHAR *vars, TCHAR *subs[])
 *
 *  Args:
 *      errjmp  - optional pointer to jmp_buf for errors
 *      srcp    - pointer to a possible variable name
 *      supdate - location to place variable name length in
 *      vars    - array of character variable names to look for
 *      subs    - array of substitution strings for each variable name.
 *
 *  Returns:
 *      If there is no ending delimiter
 *              set supdate to 0
 *              return NULL
 *      else
 *              set supdate to the enclosed string length
 *              if the string is not a variable
 *                      return NULL
 *              else
 *                      return a pointer to the replacement string
 */

TCHAR *MSCmdVar(errjmp, srcp, supdate, vars, subs)
jmp_buf *errjmp;
TCHAR *srcp;
int *supdate;
TCHAR *vars;
TCHAR *subs[];
{
    static TCHAR ValidModifiers[] = TEXT( "fdpnxsatz" );
    TCHAR *substr;
    TCHAR *s1;

    substr = NULL;
    *supdate = 0;
    //
    // If extensions are enabled, we support the following syntax for expanding
    // variable values:
    //     %~fi         - expands %i to a fully qualified path name
    //     %~di         - expands %i to a drive letter only
    //     %~pi         - expands %i to a path only
    //     %~ni         - expands %i to a file name only
    //     %~xi         - expands %i to a file extension only
    //     %~si         - changes the meaning of n and x options to
    //                     reference the short name instead
    //     %~$PATH:i    - searches the directories listed in the PATH
    //                     environment variable and expands %i to the
    //                     fully qualified name of the first one found.
    //                     If the environment variable name is not
    //                     defined or the file is not found by the
    //                     search, then this modifier expands to the
    //                     empty string
    //
    // The modifiers can be combined to get compound results:
    //
    //     %~dpi       - expands %i to a drive letter and path only
    //     %~nxi       - expands %i to a file name and extension only
    //     %~dp$PATH:i - searches the directories listed in the PATH
    //                    environment variable for %i and expands to the
    //                    drive letter and path of the first one found.
    //

    //
    // See if new syntax is being specified
    //
    if (fEnableExtensions && *srcp == EQI) {

#define PATHMODIFIER    0x8000
#define ATTRMODIFIER    0x4000

#define WANTFULLPATH    (0x0001)
#define WANTDRIVE       (0x0002)
#define WANTPATH        (0x0004)
#define WANTNAME        (0x0008)
#define WANTEXTENSION   (0x0010)
#define WANTSHORTNAME   (0x0020)
#define PATHBITS        (0x00FF)

#define WANTATTRIB      (0x0100)
#define WANTTIMESTAMP   (0x0200)
#define WANTSIZE        (0x0400)
#define ATTRBITS        (0x0F00)
        
        ULONG Modifiers = 0;
        ULONG LastModifierValue = 0;
        TCHAR *LastVariablePosition;

        TCHAR FullPath[ 2 * MAX_PATH], NullExt;
        TCHAR *FilePart, *Extension, *StartPath, *VarName, *StartBuf;
        const TCHAR *SearchVar;
        DWORD FullPathLength;

        FullPathLength = 0;
        SearchVar = NULL;
        StartBuf = srcp-1;
        s1 = NULL;
        
        
        srcp++;
        
        LastVariablePosition = srcp;
        
        //
        //  Walk forward through the string, remembering where we see variables
        //  and saving the position and status of the modifiers at the most
        //  recent variable.  We stop when we encounter a char that cannot be a
        //  modifier.  If that char is a variable, we use it.  Otherwise, we
        //  reset the pointer to the most recently found variable.
        //

        while (*srcp != TEXT( '\0' ) && 
               *srcp != TEXT( '$' ) && 
               _tcsrchr( ValidModifiers, _totlower( *srcp )) != NULL) {
            //
            //  The character we are looking at is a valid modifier. If it is 
            //  a variable, save this location
            //

            if ( _tcsrchr( vars, *srcp ) != NULL) {
                LastVariablePosition = srcp;
                LastModifierValue = Modifiers;
            }

            //
            //  Add up the functions that this modifier demands
            //

            switch (_totlower( *srcp )) {
            case TEXT('f'): Modifiers |= PATHMODIFIER | WANTFULLPATH;   break;
            case TEXT('d'): Modifiers |= PATHMODIFIER | WANTDRIVE;      break;
            case TEXT('p'): Modifiers |= PATHMODIFIER | WANTPATH;       break;
            case TEXT('n'): Modifiers |= PATHMODIFIER | WANTNAME;       break;
            case TEXT('x'): Modifiers |= PATHMODIFIER | WANTEXTENSION;  break;
            case TEXT('s'): Modifiers |= PATHMODIFIER | WANTSHORTNAME;  break;
            case TEXT('a'): Modifiers |= ATTRMODIFIER | WANTATTRIB;     break;
            case TEXT('t'): Modifiers |= ATTRMODIFIER | WANTTIMESTAMP;  break;
            case TEXT('z'): Modifiers |= ATTRMODIFIER | WANTSIZE;       break;
            default:
                //
                //  This had better not occur
                //

                
                if (errjmp != NULL) {
                    PutStdErr(MSG_PATH_OPERATOR_INVALID, ONEARG, StartBuf);
                    longjmp(*errjmp,-1);
                } else {
                    return NULL;
                }
            }

            srcp++;
        }

        //
        //  *srcp is no longer pointing at a valid modifier. 
        //  It may be:
        //      EOS - we back up to the previously saved variable position
        //      $ - perform special environment variable scanning
        //      some other char - 
        //          if this is not a variable, we back up to the prevously
        //          saved variable position
        //

        if (*srcp == TEXT( '\0' )) {
            
            //
            //  Restore bak to last found variable
            //

            srcp = LastVariablePosition;
            Modifiers = LastModifierValue;
        
        } else if (*srcp == TEXT( '$' )) {
            
            //
            //  Save beginning of environment variable
            //

            VarName = ++srcp;
            
            //
            //  Look for :  If not present, then error
            //

            srcp = _tcschr( srcp, COLON );
            if (srcp == NULL) {
                if (errjmp != NULL) {
                    PutStdErr(MSG_PATH_OPERATOR_INVALID, ONEARG, StartBuf);
                    longjmp(*errjmp,-1);
                } else {
                    return NULL;
                }
            }
            
            //
            //  Look up environment variable to search
            //
            
            *srcp = NULLC;
            SearchVar = MyGetEnvVarPtr( VarName );
            if (SearchVar == NULL) {
                SearchVar = (TCHAR *)-1;
            }
            *srcp++ = COLON;
            Modifiers |= PATHMODIFIER;
        
        } else if (_tcsrchr( vars, *srcp) == NULL) {
            
            //
            //  Restore back to last found variable
            //

            srcp = LastVariablePosition;
            Modifiers = LastModifierValue;
        
        }
        
        //
        //  If we didn't find a variable, bail out.
        //
        
        s1 = _tcsrchr( vars, *srcp );
        if (s1 == NULL) {
            if (errjmp != NULL) {
                PutStdErr(MSG_PATH_OPERATOR_INVALID, ONEARG, StartBuf);
                longjmp(*errjmp,-1);
            } else {
                return NULL;
            }
        }
    
        //
        // Get current value of variable (strip surrounding quotes)
        //
        
        substr = subs[s1 - vars];
        if (substr != NULL) {
            if (*substr == QUOTE) {
                substr = dupstr( substr + 1 );
                if (substr == NULL) {
                    if (errjmp != NULL) {
                        PutStdErr( ERROR_NOT_ENOUGH_MEMORY, NOARGS );
                        longjmp( *errjmp, -1 );
                    } else {
                        return NULL;
                    }
                }
                s1 = lastc( substr );
                if (*s1 == QUOTE)
                    *s1 = NULLC;

            } else if (*srcp == TEXT('0') &&
                       CurrentBatchFile != NULL &&
                       CurrentBatchFile->orgaptr0 == substr &&
                       SearchVar == NULL &&
                       (Modifiers & (PATHMODIFIER | ATTRMODIFIER)) != 0
                      ) {

                substr = CurrentBatchFile->filespec;

            }

        }

        //
        // Skip past the variable name letter and tell caller how much of the
        // source string we consumed.
        //
        
        ++srcp;
        *supdate = (int)(srcp - StartBuf) - 1;

        //
        // If the variable has a value, then apply the modifiers to the
        // value.
        //
        
        if (substr != NULL && *substr != TEXT( '\0' )) {
            
            //
            // If no path or attribute modifiers request then all done.
            //

            if ((Modifiers & (PATHMODIFIER | ATTRMODIFIER)) == 0) {

                substr = dupstr( substr );
                goto alldone;
            }

            //
            // If requested searching an environment variable path, do that.
            //
            
            FullPath[0] = NULLC;
            if (SearchVar != NULL) {
                if (SearchVar != (TCHAR *)-1) {
                    FullPathLength = SearchPath( SearchVar, 
                                                 substr,
                                                 NULL,
                                                 sizeof( FullPath ) / sizeof( FullPath[0] ),
                                                 FullPath,
                                                 &FilePart);
                    if (FullPathLength == 0) {
                        SearchVar = (TCHAR *)-1;
                    } else if ((Modifiers & PATHBITS) == 0) {
                        Modifiers |= PATHMODIFIER | WANTFULLPATH;
                    }
                }
            }

            if (SearchVar == NULL) {
                
                //
                // If not searching environment variable path, start with full path.
                //

                FullPathLength = GetFullPathName( substr,
                                                  sizeof( FullPath ) / sizeof( FullPath[0] ),
                                                  FullPath,
                                                  &FilePart);

            } else if (SearchVar == (TCHAR *)-1) {
                
                //
                // If search of environment variable path failed, result is empty string
                //
                substr = NULL;

            }

            if (FilePart == NULL)
                FilePart = _tcschr( FullPath, NULLC );

            //
            // Fixup the path to have same case as on disk, substituting short
            // names if requested.
            //
            
            FixupPath( FullPath, (Modifiers & WANTSHORTNAME) );

            //
            // If we have a full path, the result gets the portions requested by
            // the user, unless they wanted the full path, in which case there is
            // nothing more to do.
            //
            if (FullPathLength != 0) {
                TCHAR Buffer[ 2 * MAX_PATH ];
                TCHAR *s;

                s = Buffer;
                if ((Modifiers & ATTRMODIFIER) != 0) {
                    struct tm FileTime;
                    LARGE_INTEGER FileSize;
                    WIN32_FILE_ATTRIBUTE_DATA FileInfo;
                    int i;
                    BOOL bResult;

#ifdef WIN95_CMD
                    WIN32_FIND_DATA Win95FileInfo;
                    HANDLE hFind;

                    hFind = FindFirstFile( FullPath, &Win95FileInfo );
                    if (hFind != INVALID_HANDLE_VALUE) {
                        FileInfo.dwFileAttributes = Win95FileInfo.dwFileAttributes;
                        FileInfo.ftCreationTime = Win95FileInfo.ftCreationTime;
                        FileInfo.ftLastAccessTime = Win95FileInfo.ftLastAccessTime;
                        FileInfo.ftLastWriteTime = Win95FileInfo.ftLastWriteTime;
                        FileInfo.nFileSizeHigh = Win95FileInfo.nFileSizeHigh;
                        FileInfo.nFileSizeLow = Win95FileInfo.nFileSizeLow;
                        FindClose( hFind );
                        bResult = TRUE;
                    } else {
                        bResult = FALSE;
                    }

#else
                    bResult = GetFileAttributesEx( FullPath,
                                                   GetFileExInfoStandard,
                                                   &FileInfo
                                                 );
#endif
                    if (bResult) {
                        if ((Modifiers & WANTATTRIB) != 0) {
                            i = 0;
                            while (rgAttrToCharMap[i].chAttributeChar) {
                                if (FileInfo.dwFileAttributes & rgAttrToCharMap[i].dwAttributeFlag)
                                    *s++ = rgAttrToCharMap[i].chAttributeChar;
                                else
                                    *s++ = TEXT('-');
                                i += 1;
                            }
                        }

                        if ((Modifiers & WANTTIMESTAMP) != 0) {
                            ConvertFILETIMETotm( &FileInfo.ftLastWriteTime, &FileTime );
                            if (s != Buffer)
                                *s++ = SPACE;
                            s += PrintDate( &FileTime, PD_DIR, s, MAX_PATH );
                            *s++ = SPACE;
                            s += PrintTime( &FileTime, PT_DIR, s, MAX_PATH );
                        }

                        if ((Modifiers & WANTSIZE) != 0) {
                            if (s != Buffer)
                                *s++ = SPACE;
                            FileSize.LowPart = FileInfo.nFileSizeLow;
                            FileSize.HighPart = FileInfo.nFileSizeHigh;
                            // THOUSANDSEPSWITCH
                            s += FormatFileSize( 0, &FileSize, 0, s );
                        }

                    }
                }

                if ((Modifiers & PATHMODIFIER) != 0 ||
                    (Modifiers & ATTRMODIFIER) == 0) {
                    if (s != Buffer)
                        *s++ = SPACE;

                    if ((Modifiers & WANTFULLPATH) == 0 &&
                        ((Modifiers & WANTSHORTNAME) == 0 ||
                         (Modifiers & (WANTDRIVE | WANTPATH | WANTEXTENSION | WANTNAME)) != 0
                         
                        )
                       ) {
                        StartPath = FullPath + 2;
                        if ((Modifiers & WANTDRIVE) == 0) {
                            StartPath = _tcscpy(FullPath, StartPath);
                            FilePart -= 2;
                        }
                        if ((Modifiers & WANTPATH) == 0)
                            FilePart = _tcscpy(StartPath, FilePart);
                        Extension = _tcsrchr(FilePart, DOT);
                        if (Extension == NULL) {
                            NullExt = NULLC;
                            Extension = &NullExt;
                        }
                        if ((Modifiers & WANTEXTENSION) == 0)
                            *Extension = NULLC;
                        if ((Modifiers & WANTNAME) == 0)
                            _tcscpy(FilePart, Extension);
                    }

                    _tcscpy(s, FullPath);
                    s += _tcslen(s);
                }

                *s = NULLC;
                substr = dupstr( Buffer );
            }
        }
    } else if (*srcp && (s1 = _tcsrchr(vars, *srcp))) {
        
        //
        // Old syntax.  Result is value of variable
        //
        substr = subs[s1 - vars]; /* Found variable*/

        //
        // Skip past the variable name letter and tell caller how much of the
        // source string we consumed.
        //
        ++srcp;            /* Kick past name*/
        *supdate += 1;
    }

alldone:
    //
    // If result was empty, then return the null string.  Otherwise return the result
    //
    if (!substr && *supdate != 0)
        return TEXT("");
    else
        return substr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\ckeys.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    ckeys.c

Abstract:

    Dummy support for DOS KEYS command

--*/

#include "cmd.h"

extern TCHAR KeysStr[];
extern struct envdata CmdEnv ;

/* global variables */
int KeysFlag = 0;	   /* KeysFlag indicates on / off */

/**************** START OF SPECIFICATIONS ***********************/
/*								*/
/* SUBROUTINE NAME: eKeys					*/
/*								*/
/* DESCRIPTIVE NAME: Keys internal command			*/
/*								*/
/* FUNCTION: If no argument supplied then display the state	*/
/*	     of on / off.  If argument is on / off then 	*/
/*	     change the state.	If argument is list then	*/
/*	     display the stack. 				*/
/*								*/
/* NOTES: New for OS/2 1.2.					*/
/*								*/
/* ENTRY POINT: eKeys						*/
/*    LINKAGE:							*/
/*								*/
/* INPUT:							*/
/*	n							*/
/*								*/
/* EXIT-NORMAL: 						*/
/*	returns SUCCESS 					*/
/*								*/
/* EXIT-ERROR:							*/
/*	none.							*/
/*								*/
/* EFFECTS:							*/
/*								*/
/* INTERNAL REFERENCES: 					*/
/*    ROUTINES: 						*/
/*	PutStdErr						*/
/*	PutStdOut						*/
/*	TokStr							*/
/*	strcmpi 						*/
/*	strncpy 						*/
/*								*/
/* EXTERNAL REFERENCES: 					*/
/*    ROUTINES: 						*/
/**************** END OF SPECIFICATIONS *************************/

eKeys( n )
struct cmdnode *n; /* the command node for the Keys command */
{
    TCHAR *argptr;		 /* pointer to tozenized argument */

    /* get the value of the argument pointer */
    argptr = TokStr( n->argptr, 0, TS_NOFLAGS );

    /* take action based on the argument */

    if ((*argptr == 0) && (KeysFlag)) {
        PutStdOut( MSG_KEYS_ON, NOARGS );
        }

    else if ((*argptr == 0) && (!KeysFlag)) {
        PutStdOut( MSG_KEYS_OFF, NOARGS );
        }

    else if (!(argptr[ mystrlen( argptr ) + 1 ] == 0)) {
        /* too many parameters */
        PutStdErr( MSG_BAD_SYNTAX, NOARGS );
        }

    else if (_tcsicmp( argptr, TEXT("ON") ) == 0) {
        /* set keys on */
        KeysFlag = TRUE;
        SetEnvVar(KeysStr, TEXT("ON"), &CmdEnv);
        }
    else if (_tcsicmp( argptr, TEXT("OFF") ) == 0) {
        /* set keys off */
        KeysFlag = FALSE;
        SetEnvVar(KeysStr, TEXT("OFF"), &CmdEnv);
        }

    else if (_tcsicmp( argptr, TEXT("LIST") ) == 0) {
        }

    else {
        /* invalid parameter */
        PutStdErr( MSG_BAD_PARM1, NOARGS );
        }

    return SUCCESS;

} /* eKeys */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cmd.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cmd.c

Abstract:

    Top-level driver for CMD

--*/

#include "cmd.h"


//
// Used in rebuilding command lines for display
//
#define NSPC    0                                                               // Don't use space
#define YSPC    1                                                               // Do use space

extern CPINFO CurrentCPInfo;
extern UINT   CurrentCP;
extern ULONG  LastMsgNo;
//
// Jump buffers used to return to main loop after some error condition
//
jmp_buf MainEnv;               // SigHand() uses to return to main
jmp_buf CmdJBuf1;              // Both of these buffers are used by
jmp_buf CmdJBuf2;              // various parts of Command for error

//
// rioCur points to a linked list of rio structures dynamically
// allocated when redirection is performed.  Note that memory is automatically
// freed when Dispatch completed work. rioCur points to last entry.
//
struct rio *rioCur = NULL;

//
// Retrun code for last external program
//
int LastRetCode;

//
// Constants used in parsing
//
extern TCHAR PathChar;
extern TCHAR SwitChar;

extern TCHAR Delimiters[];
extern TCHAR Delim2[];
extern TCHAR Delim4[];
extern TCHAR Delim5[];
extern TCHAR ForStr[];
extern TCHAR ForLoopStr[];
extern TCHAR ForDirTooStr[];
extern TCHAR ForParseStr[];
extern TCHAR ForRecurseStr[];

//
// Current Drive:Directory. Set in ChDir
// It it is change temp. SaveDir used used to old original
//
extern TCHAR CurDrvDir[];

//
// Name of NULL device. Used to output to nothing
//
extern TCHAR DevNul[];

//
// Number of elements in Data stack
//
extern ULONG DCount;

//
// Environment string to locate command shell.
//
extern TCHAR ComSpecStr[];

//
// DOS error code
//
extern unsigned DosErr;


//
// Alternative path (DDPATH) to search
//
extern TCHAR AppendStr[];

//
// flag if control-c was seen
//
extern  BOOL CtrlCSeen;
extern  BOOLEAN fPrintCtrlC;

extern PTCHAR    pszTitleCur;
extern BOOLEAN  fTitleChanged;

//
// Prototypes
//


PTCHAR
GetEnvVar();

PTCHAR
EatWS();

int
UnParse(struct node   *, PTCHAR);

int
UnBuild(struct node   *, PTCHAR);

void
UnDuRd(struct node   *, PTCHAR);

void
SPutC(PTCHAR, PTCHAR,int );

PTCHAR
argstr1();

int DelayedEnvVarSub(struct cmdnode *, struct savtype *, BOOLEAN);
int DESubWork(BOOLEAN, TCHAR **, TCHAR **);
VOID GetCmdPolicy(INT * iDisabled);

#define CMD_POLICY_NORMAL           0
#define CMD_POLICY_DISABLE_SCRIPTS  1
#define CMD_POLICY_ALLOW_SCRIPTS    2

//
// Used to set and reset ctlcseen flag
//
VOID    SetCtrlC();
VOID    ResetCtrlC();


//
// to monitor stack usage
//
extern BOOLEAN  flChkStack;
extern PVOID    FixedPtrOnStack;

typedef struct {
    PVOID   Base;
    PVOID   GuardPage;
    PVOID   Bottom;
    PVOID   ApprxSP;
} STACK_USE;

extern STACK_USE   GlStackUsage;

extern int ChkStack (PVOID pFixed, STACK_USE *pStackUse);



int
__cdecl
main()

/*++

Routine Description:

    Main entry point for command interpreter

Arguments:
    Command line:

        /P - Permanent Command.  Set permanent CMD flag.
        /C - Single command.  Build a command line out of the rest of
             the args and pass it back to Init.
        /K - Same as /C but also set SingleBatchInvocation flag.
        /Q - No echo

Return Value:

    Return: 0    - If success
            1    - Parsing Error
            0xFF - Could  not init
            n    - Return code from command
--*/

{
    CHAR        VarOnStack;
    struct node *pnodeCmdTree;

    //
    // When in multi-cmd mode tells parser where to get input from.
    //
    int InputType;


    //
    // Pointer to initial command lines
    //
    PTCHAR InitialCmds[ 3 ];
    int i, iDisabled;
    BOOL bInit;

    //
    // flag used when a setjmp returns while processing /K
    // error and move to next line.
    //
    unsigned fIgnore = FALSE;
    unsigned ReturnCode, rc;


    //
    //  Since we operate in a multilingual environment, we must set up the
    //  system/user/thread locales correctly BEFORE ever issuing a message
    //
    
#if !defined( WIN95_CMD )
    CmdSetThreadUILanguage(0);
#endif
        
    __try {

        //
        // Check policy to see if cmd is disabled
        //

        GetCmdPolicy (&iDisabled);

        //
        // flChkStack is turned ON initially here and it stays ON while
        // I believe the information returned by ChkStack() is correct.
        //
        // It is turned OFF the first time I don't believe that info and
        // therefore I don't want to make any decisions changing the CMD's
        // behavior.
        //
        // It will stay OFF until CMD terminates so we will never check
        // stack usage again.
        //
        // I implemented one method to prevent CMD.EXE from the stack overflow:
        // Have count and limit of recursion in batch file processing and check
        // stack every time we exceed the limit of recursion until we reach 90%
        // of stack usage.
        // If (stack usage >= 90% of 1 MByte) then terminate batch file
        // unconditionally and handle such termination properly (freeing memory
        // and stack and saving CMD.EXE)
        //
        // It is also possible to implement SEH but then we won't know about
        // CMD problems.
        //

        flChkStack = 1;

        FixedPtrOnStack = (VOID *) &VarOnStack;     // to be used in ChkStack()

        if ( ChkStack (FixedPtrOnStack, &GlStackUsage) == FAILURE ) {
            flChkStack = 0;
        }


        //
        // Initialize the DBCS lead byte table based on the current locale.
        //

        InitializeDbcsLeadCharTable( );

        //
        // Set base APIs to operate in OEM mode
        //
    #ifndef UNICODE
        SetFileApisToOEM();
    #endif  /* Unicode */

        //
        // Init returns TRUE if there are any commands to run before
        // entering the main loop (e.g. /C or /K and/or AutoRun from registry)
        //
        memset( &InitialCmds, 0, sizeof( InitialCmds ) );
        ReturnCode = 0;

        bInit = Init( InitialCmds );

        if (CMD_POLICY_DISABLE_SCRIPTS == iDisabled) {
            PutStdOut( MSG_DISABLED_BY_POLICY, NOARGS ) ;
            ePause(0);
            CMDexit( 0xFF );
        }

        if ( bInit ) {
            if (setjmp(MainEnv)) {
                //
                // If processing /K and setjmp'd out of init. then ignore
                //
                fIgnore = TRUE;
                if ( SingleCommandInvocation )
                    ReturnCode = 0xFF;
            }

            if ( !fIgnore ) {
                //
                // Loop over any initial commands read from registry of from /C or /K
                //
                for (i=0; i<3; i++)
                    if (InitialCmds[i] != NULL) {
                        DEBUG((MNGRP, MNLVL, "MAIN: Single command mode on `%ws'", InitialCmds[i]));

                        if ((pnodeCmdTree = Parser(READSTRING, (INT_PTR)InitialCmds[i], DCount)) == (struct node *) PARSERROR)
                            CMDexit(MAINERROR);

                        if (pnodeCmdTree == (struct node *) EOF)
                            CMDexit(SUCCESS);

                        DEBUG((MNGRP, MNLVL, "MAIN: Single command parsed successfully."));
                        rc = Dispatch(RIO_MAIN, pnodeCmdTree);
                        if (rc != 0)
                            ReturnCode = rc;
                    }

                //
                // Make sure we have the correct console modes.
                //
                ResetConsoleMode();

                //
                // Get current CodePage Info.  We need this to decide whether
                // or not to use half-width characters.
                //
                GetCPInfo((CurrentCP=GetConsoleOutputCP()), &CurrentCPInfo);
                //
                // Maybe console output code page was changed by CHCP or MODE,
                // so need to reset LanguageID to correspond to code page.
                //
#if !defined( WIN95_CMD )
                CmdSetThreadUILanguage(0);
#endif
        
            }

            //
            // All done if /C specified.
            //
            if ( SingleCommandInvocation )
                CMDexit( ReturnCode );

            SingleBatchInvocation = FALSE;       // Allow ASync exec of GUI apps now
        }

        //
        // Through init and single command processing. reset our Setjmp location
        // to here for error processing.
        //
        if (ReturnCode = setjmp(MainEnv)) {

            //
            //  fix later to have a generalized abort
            //  for now assume this is a real abort from
            //  eof on stdin redirected.

            if (ReturnCode == EXIT_EOF) {
                CMDexit(SUCCESS);
            }
        }

        //
        // Exit now if the interactive command prompt
        //

        if (CMD_POLICY_ALLOW_SCRIPTS == iDisabled) {
            PutStdOut( MSG_DISABLED_BY_POLICY, NOARGS ) ;
            ePause(0);
            CMDexit( 0xFF );
        }

        //
        // Check if our I/O has been redirected. This is used to tell
        // where we should read input from.
        //
        InputType = (FileIsDevice(STDIN)) ? READSTDIN : READFILE;

        DEBUG((MNGRP,MNLVL,"MAIN: Multi command mode, InputType = %d", InputType));

        //
        // If we are reading from a file, make sure the input mode is binary.
        // CRLF translations mess up the lexer because FillBuf() wants to
        // seek around in the file.
        //
        if(InputType == READFILE) {
            _setmode(STDIN,_O_BINARY);
        }

        //
        // Loop till out of input or error parsing.
        //
        while (TRUE) {

            DEBUG((MNGRP, MNLVL, "MAIN: Calling Parser."));

            GotoFlag = FALSE;
            ResetCtrlC();

            if ((pnodeCmdTree = Parser(InputType, STDIN, FS_FREEALL)) == (struct node *) PARSERROR) {
                DEBUG((MNGRP, MNLVL, "MAIN: Parse failed."));

            } else if (pnodeCmdTree == (struct node *) EOF)
                CMDexit(SUCCESS);

            else {
                ResetCtrlC();
                DEBUG((MNGRP, MNLVL, "MAIN: Parsed OK, DISPATCHing."));
                //
                // Get current CodePage Info.  We need this to decide whether
                // or not to use half-width characters.
                //
                GetCPInfo((CurrentCP=GetConsoleOutputCP()), &CurrentCPInfo);
                //
                // Maybe console output code page was changed by console property sheet
                // so need to reset LanguageID to correspond to code page.
                //
#if !defined( WIN95_CMD )
                CmdSetThreadUILanguage(0);
#endif
        
                Dispatch(RIO_MAIN, pnodeCmdTree);

                //
                // Make sure we have the correct console modes.
                //
                ResetConsoleMode();

                //
                // Get current CodePage Info.  We need this to decide whether
                // or not to use half-width characters.
                //
                GetCPInfo((CurrentCP=GetConsoleOutputCP()), &CurrentCPInfo);
                //
                // Maybe console output code page was changed by CHCP or MODE,
                // so need to reset LanguageID to correspond to code page.
                //
#if !defined( WIN95_CMD )
                CmdSetThreadUILanguage(0);
#endif

                DEBUG((MNGRP, MNLVL, "MAIN: Dispatch returned."));
            }
        }

        CMDexit(SUCCESS);
        ReturnCode = SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        ReturnCode = -1;
    }

    return ReturnCode;
}


FARPROC WINAPI CmdDelayHook(
    UINT dliNotify,
    PDelayLoadInfo pdli
    )
{
    
    if (ReportDelayLoadErrors) {
        if (dliNotify == dliFailLoadLib) {
            PutStdErr( MSG_CANNOT_LOAD_LIB, ONEARG, pdli->szDll );
            PutStdErr( pdli->dwLastError, NOARGS );
        } else if (dliNotify == dliFailGetProc) {
            if (pdli->dlp.fImportByName) {
                PutStdErr( MSG_CANNOT_FIND_FUNC_NAME, TWOARGS, pdli->szDll, pdli->dlp.szProcName );
            } else {
                PutStdErr( MSG_CANNOT_FIND_FUNC_ORDINAL, TWOARGS, pdli->szDll, pdli->dlp.dwOrdinal );
            }
            PutStdErr( pdli->dwLastError, NOARGS );
        }
    }
    return 0;
}

//
// Override the standard definition of __pfnDliNotifyHook that's part of
// DELAYHLP.LIB
//

PfnDliHook __pfnDliFailureHook = CmdDelayHook;

int
Dispatch(
    IN int RioType,
    IN struct node *pnodeCmdTree
    )
/*++

Routine Description:

    Set up any I/O redirection for the current node.  Find out who is
    supposed to process this node and call the routine to do it.  Reset
    stdin/stdout if necessary.

    Dispatch() must now be called with all args present since the RioType
    is needed to properly identify the redirection list element.

    Dispatch() determines the need for redirection by examination of the
    RioType and command node and calls SetRedir only if necessary. Also,
    in like manner, Dispatch() only calls ResetRedir if redirection was
    actually performed.

    The conditional that determines whether newline will be issued
    following commands (prior to prompt), had to be altered so that the
    execution of piped commands did not each issue a newline.  The pre-
    prompt newline for pipe series is now issued by ePipe().

Arguments:

    RioType     - tells SetRedir the routine responsible for redirection
    pnodeCmdTree        - the root of the parse tree to be executed

Return Value:

    The return code from the command/function that was executed or
    FAILURE if redirection error.

--*/

{


    int comretcode;                // Retcode of the cmnd executed
    struct cmdnode *pcmdnode;      // pointer to current command node
    PTCHAR pbCmdBuf;               // Buffer used in building command
    struct savtype save;


    DEBUG((MNGRP, DPLVL, "DISP: pnodeCmdTree = 0x%04x, RioType = %d", pnodeCmdTree, RioType));


    //
    // If we don't have a parse tree or
    // we have a goto label or
    // we have a comment line
    // then don't execute anything and return.
    //
    if (!pnodeCmdTree ||
        GotoFlag ||
        pnodeCmdTree->type == REMTYP) {

        return(SUCCESS);
    }

    comretcode = DISPERROR;

    DEBUG((MNGRP, DPLVL, "DISP: type = 0x%02x", pnodeCmdTree->type));

    //
    // Copy node ptr pnodeCmdTree to new node ptr pcmdnode
    // If command is to be detached or pipelined (but not a pipe)
    //  If command is Batch file or Internal or Multi-statement command
    //      "Unparse" tree into string approximating original commandline
    //      Build new command node (pcmdnode) to spawn a child Command.com
    //      Make the string ("/C" prepended) the argument of the new node
    //  Perform redirection on node c
    //  If node pcmdnode is to be detatched
    //      Exec async/discard
    //  else
    //      Exec async/keep but don't wait for retcode (pipelined)
    //  else
    //  If this is a CMDTYP, PARTYP or SILTYP node and there is explicit redirection
    //
    //      Perform redirection on this node
    //  If operator node or a special type (FOR, IF, DET or REM)
    //      Call routine identified by GetFuncPtr() to execute it
    //  Else call FindFixAndRun() to execute the CMDTYP node.
    //  If redirection was performed
    //     Reset redirection
    //

    pcmdnode = (struct cmdnode *)pnodeCmdTree;
    if (fDelayedExpansion) {
        memset(&save, 0, sizeof(save));
        if (DelayedEnvVarSub(pcmdnode, &save, FALSE)) {
            goto dispatchExit;
        }
    }

    //
    // If we are called from ePipe and PIPE command then we need
    // to rebuild the command in ascii form (UnParse) and fork
    // off another cmd.exe to execute it.
    //
    if ((RioType == RIO_PIPE && pcmdnode->type != PIPTYP)) {

        //
        // pbCmdbuf is used as tmp in FindCmd and SFE
        //
        if (!(pbCmdBuf = mkstr( MAXTOKLEN * sizeof( TCHAR )))) {
            goto dispatchExit;
        }

        //
        // If current node to execute is not a command or
        // could not find it as an internal command or
        // it was found as a batch file then
        //    Do the unparse
        //
        if (pcmdnode->type != CMDTYP ||
            FindCmd(CMDHIGH, pcmdnode->cmdline, pbCmdBuf) != -1 ||
            SearchForExecutable(pcmdnode, pbCmdBuf) == SFE_ISBAT) {

            DEBUG((MNGRP, DPLVL, "DISP: Now UnParsing"));

            //
            // if pcmdnode an intrnl cmd then pbCmdBuf holds it's switches
            // if pcmdnode was a batch file then pbCmdBuf holds location
            //
            if (UnParse((struct node *)pcmdnode, pbCmdBuf)) {
                goto dispatchExit;
            }

            DEBUG((MNGRP, DPLVL, "DISP: UnParsed cmd = %ws", pbCmdBuf));

            //
            // Build a command node with unparsed command
            // Will be exec'd later after redirection is applied
            //
            pcmdnode = (struct cmdnode *)mknode();

            if (pcmdnode == NULL)  {
                goto dispatchExit;
            }

            pcmdnode->type = CMDTYP;
            pcmdnode->cmdline = GetEnvVar(ComSpecStr);
            pcmdnode->argptr = pbCmdBuf;
        }

        //
        // Setup I/O redirection
        //
        if (SetRedir((struct node *)pcmdnode, RioType)) {
            goto dispatchExit;
        }

        DEBUG((MNGRP, DPLVL, "DISP:Calling ECWork on piped cmd"));

        pbCmdBuf[1] = SwitChar;
        pbCmdBuf[2] = TEXT('S');

        comretcode = ECWork(pcmdnode, AI_KEEP, CW_W_NO);

        DEBUG((MNGRP, DPLVL, "DISP: ECWork returned %d", comretcode));

    } else {

        //
        // We are here if command was not PIPE
        //
        // If it was a command node or a paren or a silent operator and
        // we have redirection then set redirection.
        //
        if ((pnodeCmdTree->type == CMDTYP ||
             pnodeCmdTree->type == PARTYP ||
             pnodeCmdTree->type == SILTYP ||
             pnodeCmdTree->type == HELPTYP) &&
            pnodeCmdTree->rio) {

            //
            // Set redirection on node.
            //
            if (SetRedir(pnodeCmdTree, RioType)) {
                goto dispatchExit;
            }
        }

        //
        // If it is an internal command then find it and execute
        // otherwise locate file load and execute
        //
        if (pnodeCmdTree->type != CMDTYP) {
            comretcode = (*GetFuncPtr(pnodeCmdTree->type))((struct cmdnode *)pnodeCmdTree);
        } else {
            comretcode = FindFixAndRun((struct cmdnode *)pnodeCmdTree);
        }
    }  // else

    //
    // Reset and redirection that was previously setup
    // pcmdnode is always current node.
    //
    if ((rioCur) && (rioCur->rnod == (struct node *)pcmdnode)) {
        ResetRedir();
    }

dispatchExit:
    if (fDelayedExpansion) {
        DelayedEnvVarSub(pcmdnode, &save, TRUE);
    }

    DEBUG((MNGRP, DPLVL, "DISP: returning %d", comretcode));
    return(comretcode);
}

int
SetRedir(
    IN struct node *pnodeCmdTree,
    IN int RioType
    )

/*++

Routine Description:

    Perform the redirection required by the current node

    Only individual commands and parenthesised statement groups can have
    explicit I/O redirection.  All nodes, however, can tolerate redirection of an
    implicit nature.

Arguments:

    pNode - pointer node containing redirection information
    RioType - indicator of source of redirection request

Return Value:

    SUCCESS if the redirection was successfully set up.
    FAILURE if the redirection was NOT successfully set up.


--*/
{

    struct rio *prio;
    int i;

    CRTHANDLE OpenStatus;

    BOOLEAN fInputRedirected = FALSE;

    //
    // Temps. Used to hold all of the relocation information for a
    // command.
    //
    struct relem *prelemT;
    struct relem *prelemT2;

    TCHAR rgchFileName[MAX_PATH];
    const TCHAR *p;



    DEBUG((MNGRP, RIOLVL, "SETRD:RioType = %d.",RioType));

    prelemT = pnodeCmdTree->rio;

    //
    // Loop through redirections removing ":" from device names
    // and determining if input has been redirected
    //
    while (prelemT) {

        mystrcpy(prelemT->fname, StripQuotes(prelemT->fname) );

        //
        // skip any redirection that already has been done
        //
        if (prelemT->svhndl) {
            prelemT = prelemT->nxt;
            continue;
        }

        //
        // check for and remove any COLON that might be in a device name
        //
        if ((i = mystrlen(prelemT->fname)-1) > 1 && *(prelemT->fname+i) == COLON)
            *(prelemT->fname+i) = NULLC;

        //
        // If input redirection specified then set flag for later use
        //
        if (prelemT->rdhndl == STDIN) {
            fInputRedirected = TRUE;
        }

        prelemT = prelemT->nxt;
    }

    DEBUG((MNGRP, RIOLVL, "SETRD: fInputRedirected = %d",fInputRedirected));

    //
    // Allocate, activate and initialize the rio list element.
    // We must skip this if called from AddRedir (test for RIO_REPROCESS)
    //
    if (RioType != RIO_REPROCESS) {

        if (!(prio=(struct rio *)mkstr(sizeof(struct rio)))) {
            PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
            return ( FAILURE );
        }

        prio->back = rioCur;
        rioCur = prio;
        prio->rnod = pnodeCmdTree;
        prio->type = RioType;

        DEBUG((MNGRP, RIOLVL, "SETRD: rio element built."));

    } else {

        prio = rioCur;
    }

    //
    // Once the list has been set up for standard and special cases
    // the actual handle redirection is performed.
    //
    // loop thru the list performing all redirection and error recovery.
    //
    prelemT = pnodeCmdTree->rio;
    while (prelemT) {
        //
        // Skip any already done.
        //
        if (prelemT->svhndl) {
            prelemT = prelemT->nxt;
            continue;
        }

        DEBUG((MNGRP, RIOLVL, "SETRD: Old osf handle = %x", CRTTONT(prelemT->rdhndl)));

        //
        // Make sure read handle is open and valid before saving it.
        //
        if (CRTTONT(prelemT->rdhndl) == INVALID_HANDLE_VALUE) {
            prelemT->svhndl = BADHANDLE;
            }
        else
        if (FileIsDevice(prelemT->rdhndl) || FileIsPipe(prelemT->rdhndl) ||
            SetFilePointer(CRTTONT(prelemT->rdhndl), 0L, NULL, FILE_CURRENT) != -1) {
                DEBUG((MNGRP, RIOLVL, "SETRD: duping %d", prelemT->rdhndl));
                if ((prelemT->svhndl = Cdup(prelemT->rdhndl)) == BADHANDLE) {

                    DEBUG((MNGRP, RIOLVL, "SETRD: Cdup error=%d, errno=%d", GetLastError(), errno));
                    PutStdErr(MSG_RDR_HNDL_CREATE, ONEARG, argstr1(TEXT("%d"), (unsigned long)prelemT->rdhndl));
                    prelemT->svhndl = 0;
                    ResetRedir();
                    return(FAILURE);
                }

                DEBUG((MNGRP, RIOLVL, "SETRD: closing %d", prelemT->rdhndl));
                Cclose(prelemT->rdhndl);

                DEBUG((MNGRP,RIOLVL,"SETRD: save handle = %d", prelemT->svhndl));
                DEBUG((MNGRP,RIOLVL,"SETRD: --->osf handle = %x", CRTTONT(prelemT->svhndl)));

        } else {

            DEBUG((MNGRP, RIOLVL, "SETRD: FileIsOpen ret'd FALSE"));
            PutStdErr(MSG_RDR_HNDL_OPEN, ONEARG, argstr1(TEXT("%d"), (unsigned long)prelemT->rdhndl));
            prelemT->svhndl = 0;
            ResetRedir();
            return(FAILURE);

        }


        //
        // Is file name the command seperator character '&'
        //
        if (*prelemT->fname == CSOP) {

            DEBUG((MNGRP,RIOLVL,"SETRD: Handle substitution, %ws %d", prelemT->fname, prelemT->rdhndl));

            *(prelemT->fname+2) = NULLC;
            if (Cdup2(*(prelemT->fname+1) - TEXT('0'), prelemT->rdhndl) == BADHANDLE) {
                DEBUG((MNGRP, RIOLVL, "SETRD: Cdup2 error=%d, errno=%d", GetLastError(), errno));
                ResetRedir();

                PutStdErr(MSG_RDR_HNDL_CREATE, ONEARG, argstr1(TEXT("%d"), (ULONG)prelemT->rdhndl));
                return(FAILURE);
            }

            DEBUG((MNGRP,RIOLVL,"SETRD: %c forced to %d",*(prelemT->fname+1), (ULONG)prelemT->rdhndl));

        } else {

            //
            // redirecting input from a file. Check to see if file
            // exists and can be opened for input.
            //
            if (prelemT->rdop == INOP) {

                DEBUG((MNGRP,RIOLVL,"SETRD: File in = %ws",prelemT->fname));

                //
                // Try to open file localy first
                //
                if ((OpenStatus = Copen(prelemT->fname, O_RDONLY|O_BINARY)) == BADHANDLE) {

                    //
                    // Now try the DPATH (data path)
                    //
                    p = MyGetEnvVarPtr(AppendStr);
                    if ( p != NULL &&
                         SearchPath( p,
                                    prelemT->fname,
                                    NULL,
                                    MAX_PATH,
                                    rgchFileName,
                                    NULL ) != 0 ) {
                            OpenStatus = Copen(rgchFileName, O_RDONLY|O_BINARY);
                    }
                }

            } else {

                //
                // We are not redirecting input so must be output
                //

                DEBUG((MNGRP,RIOLVL,"SETRD: File out = %ws",prelemT->fname));

                //
                // Make sure sure we can open the file for output
                //
                OpenStatus = Copen(prelemT->fname, prelemT->flag ? OP_APPEN : OP_TRUNC);
            }

            //
            // If the handle to be redirected was not the lowest numbered,
            // unopened handle when open was called, the current handle must
            // be forced to it, the handle returned by open must be closed.
            //
            if (OpenStatus != BADHANDLE && OpenStatus != prelemT->rdhndl) {

                DEBUG((MNGRP,RIOLVL,"SETRD: Handles don't match..."));
                DEBUG((MNGRP,RIOLVL,"SETRD: ...forcing %d to %d", i, (ULONG)prelemT->rdhndl));

                if (Cdup2(OpenStatus, prelemT->rdhndl) == BADHANDLE) {

                    DEBUG((MNGRP, RIOLVL, "SETRD: Cdup2 error=%d, errno=%d", GetLastError(), errno));
                    Cclose(OpenStatus);
                    ResetRedir();

                    PutStdErr(MSG_RDR_HNDL_CREATE, ONEARG, argstr1(TEXT("%d"), (ULONG)prelemT->rdhndl));
                    return(FAILURE);

                } else {

                    Cclose(OpenStatus);
                    OpenStatus = prelemT->rdhndl;
                }
            }

            //
            // Copen error processing must be delayed to here to allow the
            // above Cdup2 to occur if necessary.  Otherwise, the call to
            // ResetRedir in the error handler would attempt to close the
            // wrong handle and leave a bogus handle open.
            //
            if (OpenStatus == BADHANDLE) {

                DEBUG((MNGRP,RIOLVL,"SETRD: Bad Open, DosErr = %d",DosErr));
                ResetRedir();

                PrtErr(DosErr);
                return(FAILURE);
            }

            DEBUG((MNGRP, RIOLVL, "SETRD: new handle = %d", OpenStatus));
            DEBUG((MNGRP,RIOLVL,"SETRD: --->osf handle = %x", CRTTONT(OpenStatus)));

            //
            // Keep highest numbered handle
            //
            prio->stdio = OpenStatus;

        } // else

        prelemT = prelemT->nxt;

    } // while


    return(SUCCESS);
}


AddRedir(
    IN struct cmdnode *pcmdnodeOriginal,
    IN struct cmdnode *pcmdnodeNew
    )
/*++

Routine Description:

    Add redirection from a new node to an existing one.  Walk the
    redirection list of the old node for each element in the new.
    Duplicates are removed from the old and replaced by the new,
    while unique new ones are added to the end.  When the two lists
    are merged, reprocess the redirection.

Arguments:

    pcmdnodeOriginal - original node to be added to
    pcmdnodeNew      - new node to merge.

Return Value:

    SUCCESS if the redirection was successfully merged.
    FAILURE otherwise.

--*/

{

    struct relem *prelemOriginal;
    struct relem *prelemNew;
    struct relem *prelemEnd;           // Ptr to end of original list

    //
    // Flag to set Stack Minimum
    //
    BOOLEAN fSetStackMin = FALSE;

    PTCHAR oldname;            /* Sanity check                    */
    struct rio *rn;    /* Possible rio element    */

    //
    // Won't be here unless pcmdnodeNew-reio exists
    //
    prelemNew = pcmdnodeNew->rio;

    // If there was no redirection associated with the original node, we must
    // also create a rio element so that the redirection can be reset at
    // command completion or receipt of signal.  We have to create it here
    // rather than in SetRedir in order to include it on the data stack when
    // we set a new level.

    if (!(prelemEnd = prelemOriginal = pcmdnodeOriginal->rio)) {

        DEBUG((MNGRP, RIOLVL, "ADDRD: No old redirection."));

        //
        // New list becomes original
        //
        pcmdnodeOriginal->rio = prelemNew;

        if (!(rn=(struct rio *)mkstr(sizeof(struct rio)))) {
            PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
            return(FAILURE);
        }

        //
        // Create dummy redirection node.
        //
        rn->back = rioCur;
        rioCur = rn;
        rn->rnod = (struct node *)pcmdnodeOriginal;
        rn->type = RIO_BATLOOP;

        DEBUG((MNGRP, RIOLVL, "ADDRD: rio element built."));

        fSetStackMin = TRUE;       /* Must save current datacount     */
        prelemNew = NULL;            /* Skip the while loops            */
    } else {

        //
        // Find the end of the orignal list
        //
        while (prelemEnd->nxt) {
            prelemEnd = prelemEnd->nxt;
        }
    }

    //
    // If prelemNew is non-null, we've two lists which we integrate by
    // eliminating any duplicate entries and adding any unique entries in
    // the new list to the end of the original.  Note that if unique entries
    // exist, we must save the current data count to avoid losing their
    // malloc'd data when we go on to SetBat().
    //

    //
    // For each new redirection, look at the original
    //
    while (prelemNew) {

        while(prelemOriginal) {

            //
            // Do we have a duplicate
            //
            if (prelemNew->rdhndl != prelemOriginal->rdhndl) {
                prelemOriginal = prelemOriginal->nxt;
                continue;
            } else {

                if (prelemOriginal->svhndl && (prelemOriginal->svhndl != BADHANDLE)) {
                    //
                    // put an assert here
                    //
                    Cdup2(prelemOriginal->svhndl, prelemOriginal->rdhndl);
                    Cclose(prelemOriginal->svhndl);
                } else {
                    if (prelemOriginal->svhndl == BADHANDLE) {
                        Cclose(prelemOriginal->rdhndl);
                    }
                }
                prelemOriginal->svhndl = 0; /* ...and replace it     */
                prelemOriginal->flag = prelemNew->flag;
                prelemOriginal->rdop = prelemNew->rdop;
                oldname = prelemOriginal->fname;
                prelemOriginal->fname = 
                    resize( prelemOriginal->fname, 
                            (mystrlen( prelemNew->fname ) + 1) * sizeof( TCHAR ));
                mystrcpy(prelemOriginal->fname, prelemNew->fname);
                if (prelemOriginal->fname != oldname) {
                    fSetStackMin = TRUE;
                }
                pcmdnodeNew->rio = prelemNew->nxt;
                break;
            }
        }

        //
        // If no old entry remove from new and add to original
        // update the end pointer, zero next pointer and preserve datacount
        //
        if (prelemNew == pcmdnodeNew->rio) {
            pcmdnodeNew->rio = prelemNew->nxt;
            prelemEnd->nxt = prelemNew;
            prelemEnd = prelemEnd->nxt;
            prelemEnd->nxt = NULL;
            fSetStackMin = TRUE;
        }
        prelemNew = pcmdnodeNew->rio;
        prelemOriginal = pcmdnodeOriginal->rio;
    }

    //
    // All duplicates are eliminated.   Now save the data count and call
    // SetRedir to reprocess the redirection list for any unimplimented
    // redirection (io->svhndl == 0).
    //

    if (fSetStackMin) {
        if (CurrentBatchFile->stacksize < (CurrentBatchFile->stackmin = DCount)) {
            CurrentBatchFile->stacksize = DCount;
        }
    }
    return(SetRedir((struct node *)pcmdnodeOriginal, RIO_REPROCESS));
}
void
ResetRedir()

/*++

Routine Description:

    Reset the redirection identified by the last rio list element
    as pointed to by rioCur.  When finished, remove the rio element
    from the list.

Arguments:


Return Value:


--*/

{
    struct rio *prio = rioCur;
    struct relem *prelemT;
    CRTHANDLE handleT;

    DEBUG((MNGRP, RIOLVL, "RESETR: Entered."));

    prelemT = prio->rnod->rio;

    while (prelemT) {

        if (prelemT->svhndl && (prelemT->svhndl != BADHANDLE)) {

            DEBUG((MNGRP,RIOLVL,"RESETR: Resetting %d",(ULONG)prelemT->rdhndl));
            DEBUG((MNGRP,RIOLVL,"RESETR: From save %d",(ULONG)prelemT->svhndl));

            handleT = Cdup2(prelemT->svhndl, prelemT->rdhndl);
            Cclose(prelemT->svhndl);

            DEBUG((MNGRP,RIOLVL,"RESETR: Dup2 retcode = %d", handleT));

        } else {

            if (prelemT->svhndl == BADHANDLE) {

                DEBUG((MNGRP,RIOLVL,"RESETR: Closing %d",(ULONG)prelemT->rdhndl));

                Cclose(prelemT->rdhndl);
            }
        }

        prelemT->svhndl = 0;
        prelemT = prelemT->nxt;
    }

    //
    // Kill list element
    //
    rioCur = prio->back;

    DEBUG((MNGRP, RIOLVL, "RESETR: List element destroyed."));
}



int
FindFixAndRun (
    IN struct cmdnode *pcmdnode
    )
/*++

Routine Description:

    If the command name is in the form d: or, just change drives.
    Otherwise, search for the nodes command name in the jump table.
    If it is found, check the arguments for bad drivespecs or unneeded
    switches and call the function which executes the command.
    Otherwise, assume it is an external command and call ExtCom.


Arguments:

    pcmdnode - the node of the command to be executed


Return Value:

    SUCCESS or FAILURE if changing drives.
    Otherwise, whatever is returned by the function which is called to
    execute the command.

--*/

{
    PTCHAR pszTokStr;

    USHORT DriveNum;
    ULONG  JmpTblIdx;
    TCHAR  cname[MAX_PATH];
    TCHAR   cflags;
    int    (*funcptr)(struct cmdnode *);
    unsigned cbTokStr;
    PTCHAR   pszTitle;
    ULONG   rc;


    //
    // I haven't found where in CMD we end up with NULL pointer here
    // (all failing mallocs cause CMD to exit)
    // however I saw one strange stress failure.
    // So lets not cause AV and just return FAILURE if NULL.
    //

    if (pcmdnode->cmdline == NULL)
        return(FAILURE);


    //
    // Validate any drive letter
    //
    if (*(pcmdnode->cmdline+1) == COLON) {
        if (!IsValidDrv(*pcmdnode->cmdline)) {

            PutStdErr(ERROR_INVALID_DRIVE, NOARGS);
            return(FAILURE);

        } else {

            //
            // Make sure it isn't locked either
            //
            if ( IsDriveLocked(*pcmdnode->cmdline)) {
                PutStdErr( GetLastError() , NOARGS);
                return(FAILURE);
            }
        }

        //
        // Pull out drive letter and convert to drive number
        //
        DriveNum = (USHORT)(_totupper(*pcmdnode->cmdline) - SILOP);

        //
        // If this is just a change in drive do it here
        //
        if (mystrlen(pcmdnode->cmdline) == 2) {

            //
            // ChangeDrive set CurDrvDir in addition to changing the drive
            ChangeDrive(DriveNum);
            DEBUG((MNGRP,DPLVL,"FFAR: Drv chng to %ws", CurDrvDir));
            return(SUCCESS);
        }

        //
        // Note that if the cmdline contains a drivespec, no attempt is made at
        // internal command matching whatsoever.
        //
        return(ExtCom(pcmdnode));
    }

    //
    // The sequence below works as follows:
    // - A match between the previously-parsed first non-delimiter character
    //   group in the cmdline and the command table is attempted.  A match
    //   sets JmpTblIdx to the command index; no match sets JmpTblIdx to -1.
    // - FixCom is then called, and using the value of 'i', it detects cases
    //   of internal commands only (i == -1) which have no standard delimiter
    //   (whitespace or "=;,") between them and their arguments such as the
    //   "cd\foo". Note that a file foo.exe in subdirectory "cd" cannot be
    //   executed except through full path or drive specification. FixCom
    //   actually fixes up the cmdline and argptr fields of the node.
    // - The command is then executed using ExtCom (i == -1) or the internal
    //   function indicated by the index
    //
    // Added second clause to detect REM commands which were parsed incorrectly
    // as CMDTYP due to semi-delimiter characters appended.  If REM, we know
    // its OK, so just return success.  If any other of the special types,
    // FOR, DET, EXT, etc., allow to continue and fail in ExtCom since they
    // weren'tparsed correctly and will bomb.
    //
    JmpTblIdx = FindAndFix( pcmdnode, (PTCHAR )&cflags );

    DEBUG((MNGRP, DPLVL, "FFAR: After FixCom pcmdnode->cmdline = '%ws'", pcmdnode->cmdline));

    //
    // Check if it was not an internal command, if so then exec it
    //
    if (JmpTblIdx == -1) {

        DEBUG((MNGRP, DPLVL, "FFAR: Calling ExtCom on %ws", pcmdnode->cmdline));
        return(ExtCom(pcmdnode));

    }

    //
    // CMD was found in table.  If function field is NULL as in the
    // case of REM, this is a dummy entry and must return SUCCESS.
    //
    if ((funcptr = GetFuncPtr(JmpTblIdx)) == NULL) {

        DEBUG((MNGRP, DPLVL, "FFAR: Found internal with NULL entry"));
        DEBUG((MNGRP, DPLVL, "      Returning SUCESS"));
        return(SUCCESS);

    }

    //
    // If the command is supposed to have the drivespecs on its args
    // validated before the command is executed, do it. If the command
    // is not allowed toto contain switches and it has one, complain.
    //

    //
    // Set up extra delimiter for seperating out switches
    //
    cname[0] = SwitChar;
    cname[1] = NULLC;

    pszTokStr = TokStr(pcmdnode->argptr, cname, TS_SDTOKENS);

    // this hack to allow environment variables to contain /?
    if (JmpTblIdx != SETTYP || !pszTokStr || (_tcsncmp(pszTokStr,TEXT("/\0?"),4) == 0)) {
        // this is to exclude START command
        if (JmpTblIdx != STRTTYP) {
            if (CheckHelpSwitch(JmpTblIdx, pszTokStr) ) {
                return( FAILURE );
            }
        }
    }
    DEBUG((MNGRP, DPLVL, "FFAR: Internal command, about to validate args"));
    for (;(pszTokStr != NULL) && *pszTokStr; pszTokStr += mystrlen(pszTokStr)+1) {

        cbTokStr = mystrlen(pszTokStr);
        mystrcpy( pszTokStr, StripQuotes( pszTokStr ) );

        DEBUG((MNGRP, DPLVL, "FFAR: Checking args; arg = %ws", pszTokStr));

        if ((cflags & CHECKDRIVES) && *(pszTokStr+1) == COLON) {

            if (!IsValidDrv(*pszTokStr)) {

                PutStdErr(ERROR_INVALID_DRIVE, NOARGS);
                return(LastRetCode = FAILURE);

            } else {

                //
                // If not the copy command (A->B B->A swaps)
                // then check if drive is locked
                // if drive locked then
                // display error return code message
                // terminate this command's processing
                //
                if (JmpTblIdx != CPYTYP) {

                    if ( IsDriveLocked(*pszTokStr)) {

                        PutStdErr( GetLastError() , NOARGS);
                        return(LastRetCode = FAILURE);
                    }
                }
            }
        }

        if ((cflags & NOSWITCHES) && (pszTokStr != NULL) && *pszTokStr == SwitChar) {

            PutStdErr(MSG_BAD_SYNTAX, NOARGS);
            return(LastRetCode = FAILURE);
        }

    }

    DEBUG((MNGRP, DPLVL, "FFAR: calling function, cmd = `%ws'", pcmdnode->cmdline));
    //
    // Call internal routine to execute the command
    //
    if ((pszTitle = GetTitle(pcmdnode)) != NULL) {
        SetConTitle(pszTitle);
    }

    rc = (*funcptr)(pcmdnode);

    ResetConTitle(pszTitleCur);

    return(rc);
}

int
FindAndFix (
    IN struct cmdnode *pcmdnode,
    IN PTCHAR pbCmdFlags
    )

/*++

Routine Description:

    This routine separates the command and its following
    switch character if there is no space between the
    command and the switch character.

    This routine is used for both left side and right side
    of PIPE.

Arguments:

    pcmdnode - pointer to node the contains command to locate
    pbCmdFlags -

Return Value:


--*/

{
    TCHAR  chCur;           // current character we are looking at
    TCHAR  rgchCmdStr[MAX_PATH];
    PTCHAR pszArgT;         // Temp. used to build a new arguemt string

    ULONG JmpTableIdx;      // index into jump table of function pointers
    ULONG iCmdStr;          // index into  command string
    LONG  iDelim5CmdStr;          // index into  command string
    ULONG cbCmdStr;         // length of command string
    DWORD dwFileAttr;

    BOOLEAN fQuoteFound, fQuoteFound2;
    BOOLEAN fDone;

    fQuoteFound =  FALSE;
    fQuoteFound2 = FALSE;
    iDelim5CmdStr = -1;

    //
    // Extract only commnand from the command string (pcmdnode->cmdline)
    //
    for (iCmdStr = 0; iCmdStr < MAX_PATH-1; iCmdStr++) {

        chCur = *(pcmdnode->cmdline + iCmdStr);

        //
        // If we found a quote invert the current quote state
        // for both first quote (fQuoteFound) and end quote (fQuoteFound2)
        //
        if ( chCur == QUOTE ) {

            fQuoteFound = (BOOLEAN)!fQuoteFound;
            fQuoteFound2 = (BOOLEAN)!fQuoteFound;
        }

        //
        // If we have a character and
        // have found either a begin or end quote or cur char is not delimiter
        // and cur char is not a special (+[] etc.) delimiter
        //
        if ((chCur) &&
            ( fQuoteFound || fQuoteFound2 || !mystrchr(Delim4,chCur))) {

            if (iDelim5CmdStr == -1 && mystrchr(Delim5,chCur)) {
                //
                // If extensions not enabled, then path characters terminate
                // the scan

                if (!fEnableExtensions)
                    break;
                iDelim5CmdStr = iCmdStr;
            }

            rgchCmdStr[iCmdStr] = chCur;
            fQuoteFound2 = FALSE;

        }
        else {

            break;
        }
    }
    if (iCmdStr == 0) {
        return -1;
    }

    //
    // Null terminate command name.  If a path delimiter was found somewhere
    // in the command name, then see if the whole command name is the name of
    // an existing file.  If so, then that is the command, which will launch
    // the file through its association
    //
    rgchCmdStr[iCmdStr] = NULLC;
    if (iDelim5CmdStr != -1 &&
        ((dwFileAttr = GetFileAttributes(rgchCmdStr)) == -1 ||
         (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY)
        )
       ) {
        iCmdStr = iDelim5CmdStr;
        rgchCmdStr[iCmdStr] = NULLC;
    }

    //
    // See if command is in jump table (is an internal command)
    // If it is not found amoung the normal internal command
    // check amoung the special parse type if it was a comment
    //
    if ((JmpTableIdx = FindCmd(CMDHIGH, rgchCmdStr, pbCmdFlags)) == -1) {
        if (FindCmd(CMDMAX, rgchCmdStr, pbCmdFlags) == REMTYP) {
                    return(REMTYP);
        }
    } else if (JmpTableIdx == GOTYP)
        pcmdnode->flag = CMDNODE_FLAG_GOTO;

    fQuoteFound = FALSE;
    fQuoteFound2 = FALSE;

    //
    // If the command is not found, check the length of command string
    // for the case of DBCS. Count the characters that are not white space
    // remaining in command
    if ( JmpTableIdx == -1 ) {

        iCmdStr = 0;
        fDone = FALSE;
        while ( !fDone ) {
            chCur = *(pcmdnode->cmdline+iCmdStr);
            if ( chCur && chCur == QUOTE ) {
                fQuoteFound = (BOOLEAN)!fQuoteFound;
                fQuoteFound2 = (BOOLEAN)!fQuoteFound;
            }
            if ( chCur && ( fQuoteFound || fQuoteFound2 ||
                !_istspace(chCur) &&
                !mystrchr(Delimiters, chCur) &&
                !(chCur == SwitChar))) {

                iCmdStr++;
                fQuoteFound2 = FALSE;
            } else {
                fDone = TRUE;
            }
        }
    }

    //
    // If cmdstr contains more than command, strip of extra part
    // and put it in front of the existing command argument pcmdnode-argptr
    //
    //
    if (iCmdStr != (cbCmdStr = mystrlen(pcmdnode->cmdline))) {
        int ArgLen;

        ArgLen = mystrlen(pcmdnode->argptr);
        ArgLen += cbCmdStr;

        if (!(pszArgT = mkstr(ArgLen*sizeof(TCHAR)))) {

            PutStdErr(MSG_NO_MEMORY, NOARGS);
            Abort();
        }
        //
        // create argument string and copy the 'extra' part of command
        // it.
        //
        mystrcpy(pszArgT, pcmdnode->cmdline+iCmdStr);
        //
        // If we have a argument pointer stuff in the front
        //
        if (pcmdnode->argptr) {

            mystrcat(pszArgT, pcmdnode->argptr);

        }
        pcmdnode->argptr = pszArgT;
        *(pcmdnode->cmdline+iCmdStr) = NULLC;
    }

    return(JmpTableIdx);
}





int
UnParse(
    IN struct node *pnode,
    IN PTCHAR pbCmdBuf )

/*++

Routine Description:

    Do setup and call UnBuild to deparse a node tree.

Arguments:

    pnode - pointer to root of parse tree to UnParse
    pbCmdBuf -
    Uses Global pointer CBuf and assumes a string of MAXTOKLEN+1 bytes
    has already been allocated to it (as done by Dispatch).

Return Value:


--*/

{

    int rc;

    DEBUG((MNGRP, DPLVL, "UNPRS: Entered"));

    if (!pnode) {

        DEBUG((MNGRP, DPLVL, "UNPRS: Found NULL node"));
        return(FAILURE);
    }

    //
    // Leave space in front of command for a /s
    // Setup command buffer for a single command execution
    //

    mystrcpy( pbCmdBuf, TEXT( "    /D /c\"" ));

    //
    // Setup to handle an exception during detach.
    if (setjmp(CmdJBuf2)) {
        DEBUG((MNGRP, DPLVL, "UNPRS: Longjmp return occurred!"));
        return(FAILURE);
    }

    //
    // DisAssemble the current command
    //
    rc = (UnBuild(pnode, pbCmdBuf));
    mystrcat( pbCmdBuf, TEXT("\"") );
    return( rc );
}

UnBuild(
    IN struct node *pnode,
    IN PTCHAR pbCmdBuf
    )

/*++

Routine Description:

    Recursively take apart a parse tree of nodes, building a string of
    their components.

Arguments:

    pnode - root of parse tree to UnBuild
    pbCmdBuf - Where to put UnBuilt command

Return Value:


--*/

{

    //
    // Different kinds of nodes to Unbuild
    //
    struct cmdnode *pcmdnode;
    struct fornode *pfornode;
    struct ifnode *pifnode;
    PTCHAR op;

    DEBUG((MNGRP, DPLVL, "UNBLD: Entered"));

    switch (pnode->type) {

    case LFTYP:
    case CSTYP:
    case ORTYP:
    case ANDTYP:
    case PIPTYP:
    case PARTYP:
    case SILTYP:

        DEBUG((MNGRP, DPLVL, "UNBLD: Found OPERATOR"));

        UnDuRd(pnode, pbCmdBuf);

        switch (pnode->type) {

        case LFTYP:
        case CSTYP:

            op = CSSTR;
            break;

        case ORTYP:

            op = ORSTR;
            break;

        case ANDTYP:

            op = ANDSTR;
            break;

        case PIPTYP:

            op = PIPSTR;
            break;

        case PARTYP:

            SPutC(pbCmdBuf, LEFTPSTR,YSPC);
            op = RPSTR;
            break;

        case SILTYP:

            SPutC(pbCmdBuf, SILSTR,YSPC);
            op = SPCSTR;
            break;
        }

        //
        // Recurse down undoing the left hand side
        //
        UnBuild(pnode->lhs, pbCmdBuf);

        //
        // Now that left side there copy in operator and do right side
        //
        SPutC(pbCmdBuf, op,YSPC);
        if (pnode->type != PARTYP && pnode->type != SILTYP)
                UnBuild(pnode->rhs, pbCmdBuf);
        break;

    case FORTYP:

        DEBUG((MNGRP, DPLVL, "UNBLD: Found FORTYP"));
        pfornode = (struct fornode *) pnode;

        //
        // Put in the FOR keyword, arguements and list
        //
        SPutC( pbCmdBuf, ForStr,YSPC);
        if (fEnableExtensions) {
            if (pfornode->flag & FOR_LOOP) {
                SPutC( pbCmdBuf, ForLoopStr,YSPC);
            }
            else
            if (pfornode->flag & FOR_MATCH_DIRONLY) {
                SPutC( pbCmdBuf, ForDirTooStr,YSPC);
            }
            else
            if (pfornode->flag & FOR_MATCH_PARSE) {
                SPutC( pbCmdBuf, ForParseStr,YSPC);
                if (pfornode->parseOpts)
                    SPutC( pbCmdBuf, pfornode->parseOpts,YSPC);
            }
            else
            if (pfornode->flag & FOR_MATCH_RECURSE) {
                SPutC( pbCmdBuf, ForRecurseStr,YSPC);
                if (pfornode->recurseDir)
                    SPutC( pbCmdBuf, pfornode->recurseDir,YSPC);
            }
        }
        SPutC( pbCmdBuf, pfornode->cmdline+_tcslen(ForStr),YSPC);
        SPutC( pbCmdBuf, LEFTPSTR,YSPC);
        SPutC( pbCmdBuf, pfornode->arglist,NSPC);
        SPutC( pbCmdBuf, RPSTR,NSPC);
        SPutC( pbCmdBuf, pfornode->cmdline+DOPOS,YSPC);

        //
        // Now get the for body
        //
        UnBuild(pfornode->body, pbCmdBuf);
        break;

    case IFTYP:

        DEBUG((MNGRP, DPLVL, "UNBLD: Found IFTYP"));

        //
        // put ine IF keyword
        pifnode = (struct ifnode *) pnode;
        SPutC( pbCmdBuf, pifnode->cmdline,YSPC);
        op = NULL;
        if (pifnode->cond->type != NOTTYP) {
            if (pifnode->cond->flag == CMDNODE_FLAG_IF_IGNCASE)
                op = TEXT("/I");
        }
        else
        if (((struct cmdnode *)(pifnode->cond->argptr))->flag == CMDNODE_FLAG_IF_IGNCASE)
                op = TEXT("/I");

        if (op)
            SPutC( pbCmdBuf, op,YSPC);

        //
        // Get the condition part of the statement
        //
        UnBuild((struct node *)pifnode->cond, pbCmdBuf);

        //
        // Unbuild the body of the IF
        //
        UnBuild(pifnode->ifbody, pbCmdBuf);
        if (pifnode->elsebody) {
                SPutC( pbCmdBuf, pifnode->elseline,YSPC);
                UnBuild(pifnode->elsebody, pbCmdBuf);
        }
        break;

    case NOTTYP:
        DEBUG((MNGRP, DPLVL, "UNBLD: Found NOTTYP"));
        pcmdnode = (struct cmdnode *) pnode;
        SPutC( pbCmdBuf, pcmdnode->cmdline,YSPC);
        UnBuild((struct node *)pcmdnode->argptr, pbCmdBuf);
        break;

    case REMTYP:
    case CMDTYP:
    case ERRTYP:
    case EXSTYP:
    case DEFTYP:
    case CMDVERTYP:
        DEBUG((MNGRP, DPLVL, "UNBLD: Found CMDTYP"));
        pcmdnode = (struct cmdnode *) pnode;
        SPutC( pbCmdBuf, pcmdnode->cmdline,YSPC);
        if (pcmdnode->argptr)
                SPutC( pbCmdBuf, pcmdnode->argptr,NSPC);
        UnDuRd((struct node *)pcmdnode, pbCmdBuf);
        break;

    case CMPTYP:
    case STRTYP:
        pcmdnode = (struct cmdnode *) pnode;
        op = TEXT("== ");
        //
        // If extensions are enabled, handle displaying the
        // new forms of comparison operators.
        //
        if (fEnableExtensions) {
            if (pcmdnode->cmdarg == CMDNODE_ARG_IF_EQU)
                op = TEXT("EQU ");
            else
            if (pcmdnode->cmdarg == CMDNODE_ARG_IF_NEQ)
                op = TEXT("NEQ ");
            else
            if (pcmdnode->cmdarg == CMDNODE_ARG_IF_LSS)
                op = TEXT("LSS ");
            else
            if (pcmdnode->cmdarg == CMDNODE_ARG_IF_LEQ)
                op = TEXT("LEQ ");
            else
            if (pcmdnode->cmdarg == CMDNODE_ARG_IF_GTR)
                op = TEXT("GTR ");
            else
            if (pcmdnode->cmdarg == CMDNODE_ARG_IF_GEQ)
                op = TEXT("GEQ ");
        }
        SPutC( pbCmdBuf, pcmdnode->cmdline,YSPC);
        SPutC( pbCmdBuf, op, NSPC);
        if (pcmdnode->argptr)
                SPutC( pbCmdBuf, pcmdnode->argptr,NSPC);
        UnDuRd((struct node *)pcmdnode, pbCmdBuf);
        break;

    case HELPTYP:
        DEBUG((MNGRP, DPLVL, "UNBLD: Found HELPTYP"));
        if (LastMsgNo == MSG_HELP_FOR) {
            SPutC( pbCmdBuf, TEXT("FOR /?"), YSPC);
        }
        else if (LastMsgNo == MSG_HELP_IF) {
            SPutC( pbCmdBuf, TEXT("IF /?"), YSPC);
        }
        else if (LastMsgNo == MSG_HELP_REM) {
            SPutC( pbCmdBuf, TEXT("REM /?"), YSPC);
        }
        else {
            DEBUG((MNGRP, DPLVL, "UNBLD: Unknown Type!"));
            longjmp(CmdJBuf2,-1);
        }

        break;

    default:

        DEBUG((MNGRP, DPLVL, "UNBLD: Unknown Type!"));
        longjmp(CmdJBuf2,-1);
    }

    return(SUCCESS);

}

void
UnDuRd(
    IN struct node *pnode,
    IN PTCHAR pbCmdBuf
    )
/*++

Routine Description:

    Unparse any input or output redirection associated with the
    current node.

Arguments:

    pnode - current parse tree node
    pbCmdBuf - buffer holding command

Return Value:


--*/

{

    struct relem *prelem;
    TCHAR tmpstr[2];

    DEBUG((MNGRP, DPLVL, "UNDURD: Entered"));

    tmpstr[1] = NULLC;
    prelem = pnode->rio;
    while (prelem) {

        //
        // this makes big time assumption about size of handle
        //
        
        tmpstr[0] = (TCHAR)prelem->rdhndl + (TCHAR)'0';

        SPutC( pbCmdBuf, tmpstr,YSPC);

        if (prelem->rdop == INOP)
            SPutC( pbCmdBuf, INSTR,NSPC);
        else
            SPutC( pbCmdBuf, prelem->flag ? APPSTR : OUTSTR,NSPC);

        SPutC( pbCmdBuf, prelem->fname,NSPC);
        prelem = prelem->nxt;
    }
}


void SPutC(
    IN PTCHAR pbCmdBuf,
    IN PTCHAR pszInput,
    IN int flg
    )
/*++

Routine Description:

    If within length limits, add the current substring to the
    command under construction delimiting with a space.

Arguments:

    pbCmdBuf - Where to put string
    pszInputString - String to put in pbCmdBuf
    flg - Flags controling placement of spaces

Return Value:


--*/

{
    DEBUG((MNGRP, DPLVL, "SPutC: Entered, Adding '%ws'",pszInput));

    if ((mystrlen(pbCmdBuf) + mystrlen(pszInput) + 1) > MAXTOKLEN) {

        PutStdErr(MSG_LINES_TOO_LONG, NOARGS);
        longjmp(CmdJBuf2,-1);
    }

    if (flg && (*(pbCmdBuf+mystrlen(pbCmdBuf)-1) != SPACE) && (*pszInput != SPACE)) {

        SpaceCat(pbCmdBuf,pbCmdBuf,pszInput);

    } else {

        mystrcat(pbCmdBuf,pszInput);

    }
}


/***    DelayedEnvVarSub - controls execution time substitution of environment variables.
 *
 *  Purpose:
 *      Examine a parse tree node and make delayed environment variable substitutions
 *      for those fields in the node that we care about.  Don't need to walk
 *      into child parse nodes, as they will go back through Dispatch when
 *      executed and hence to us here.
 *
 *  int DelayedEnvVarSub(struct node *n)
 *
 *  Args:
 *      n - pointer to the statement subtree in which the substitutions are
 *          to be made
 *      save - place to save original strings, if we change any
 *      bRestore - TRUE if we are restoring original strings from save parameter
 *                 instead of doing substitution.
 *
 *  Returns:
 *      SUCCESS if all goes well.
 *      FAILURE if an oversized command is found.
 *
 *  Note:
 *      The variables to be substituted for are found the current environment
 *      block.  Only variables names surrounded by exclamation marks will be
 *      substituted (e.g. !varname!).  Actual substitution is done by DESubWork
 *      routine.
 *
 */

int DelayedEnvVarSub(n, save, bRestore)
struct cmdnode *n;
struct savtype *save;
BOOLEAN bRestore;
{
    int j; /* Temps used to make substitutions...     */
    struct relem *io;      /* M017 - Pointer to redir list            */

    if (!n)
        return(SUCCESS);

    switch (n->type) {
    case LFTYP:
    case CSTYP:
    case ORTYP:
    case ANDTYP:
    case PIPTYP:
    case PARTYP:
    case SILTYP:
        for (j=0, io=n->rio; j < 10 && io; j++, io=io->nxt) {
            if (DESubWork(bRestore, &io->fname, &save->saveptrs[j]))
                return(FAILURE);
        }
        return(SUCCESS);

    case FORTYP:
        if (DESubWork(bRestore, &((struct fornode *) n)->arglist, &save->saveptrs[0]))
            return(FAILURE);
        return(SUCCESS);

    case IFTYP:
        n = ((struct ifnode *)n)->cond;
        if (n->type == NOTTYP)
            n = (struct cmdnode *)n->argptr;

        if (DESubWork(bRestore, &n->cmdline, &save->saveptrs[0]))
            return(FAILURE);
        if (DESubWork(bRestore, &n->argptr, &save->saveptrs[1]))
            return(FAILURE);
        return(SUCCESS);


    case REMTYP:
    case CMDTYP:
    case CMDVERTYP:
    case ERRTYP:
    case DEFTYP:
    case EXSTYP:
    case STRTYP:
    case CMPTYP:
        if (DESubWork(bRestore, &n->cmdline, &save->saveptrs[0]) ||
            DESubWork(bRestore, &n->argptr, &save->saveptrs[1]))
            return(FAILURE);

        for (j=2, io=n->rio; j < 12 && io; j++, io=io->nxt) {
            if (DESubWork(bRestore, &io->fname, &save->saveptrs[j]))
                return(FAILURE);

        }
        return(SUCCESS);
    }

    return(SUCCESS);
}


/***    DESubWork - does runtime environment variable substitutions
 *
 *  Purpose:
 *      Make environment variable substitutions for those references in the
 *      passed string.  References are identified by valid environment variable
 *      names bracketed by exclamation marks (e.g. !PATH!).  If the source
 *      string is modified, a copy of the original is saved in the save
 *      parameter.
 *
 *  DESubWork(BOOLEAN bRestore, TCHAR **src, TCHAR **save)
 *
 *  Args:
 *      bRestore - TRUE if we are restoring original strings from save parameter
 *                 instead of doing substitution.
 *      src   - the string being examined
 *      save  - pointer to where to save *src if *src modified.
 *
 *  Returns:
 *      SUCCESS if substitutions could be made.
 *      FAILURE if the new string is too long.
 *
 *  Notes:
 *
 */

DESubWork(bRestore, src, save)
BOOLEAN bRestore;
TCHAR **src;
TCHAR **save;
{
    TCHAR *dest;
    TCHAR *dststr;
    TCHAR *srcstr, *srcpy, *substr, c; 
    int dlen;      /* Length of dest string                   */
    int slen;       /* Length of src string used               */
    int sslen;      /* Length of substr                        */

    DEBUG((BPGRP, FOLVL, "SFW: Entered."));

    //
    //  If we've performed some substitutions and are restoring
    //  the original strings
    //
    
    if (bRestore) {

        //
        //  If we've saved something then we have work to do
        //

        if (*save != NULL) {

            //
            //  If we have a substitution that we've made, then we
            //  must free this string
            //

            if (*src != NULL) {
                FreeStr( *src );
            }

            //
            //  If the original was saved, then we need to restore it.
            //

            if (*save != NULL)
                *src = *save;
            else
                *save = NULL;
        }

        return(SUCCESS);
    }

    srcpy = *src;
    
    //
    //  If there's no source or there's no delayed-sub char !
    //  then we have nothing to do
    //

    if (srcpy == NULL || !_tcschr(srcpy, TEXT('!'))) {
        return(SUCCESS);
    }

    
    //
    //  Create a substitution string
    //

    if (!(dest = mkstr( (MAXTOKLEN+1)*sizeof(TCHAR)))) {
        return(FAILURE);
    }

    srcstr = srcpy;
    dststr = dest;
    dlen = 0;
    
    //
    //  Walk through the source expanding each found environment variable
    //
    
    while (TRUE) {
        
        //
        //  If we have produced a token that's too long, break out
        //

        if (dlen > MAXTOKLEN) {
            break;
        }
        
        //
        //  Get the next character from the input
        //

        c = *srcstr++;
        if (c == TEXT('\0')) {
            break;
        }
        
        //
        // See if we have a exclamation character indicating a variable
        // reference.  Process the environment variable when we see it.
        //
        
        if (c == TEXT('!')) {
            
            //
            //  Perform complex substitution
            //
            
            substr = MSEnvVar( NULL, srcstr, &slen, c );

            //
            //  If we were able to generate a substitution, do a length
            //  check, append the string, and then advance over the 
            //  source of the substitution
            //

            if (substr != NULL) {
                sslen = mystrlen( substr );
                dlen += sslen;
                if (dlen > MAXTOKLEN) {
                    break;
                }

                _tcscpy( dststr, substr );
                dststr += sslen;
                srcstr += slen;
            
            //
            //  No substitution was possible, if we're in a batch file
            //  simply skip over the source
            //
            
            } else if (CurrentBatchFile) {
                
                srcstr += slen;
            
            //
            //  WEIRD: No substitution, no batch file, just copy the % char and keep
            //  on processing
            //

            } else {
                
                *dststr++ = c;
                dlen++;
            
            }
        } else {
            //
            //  Non-exclamation.  If this is a quote and there's a next character, use it.
            //  No next character is end of parsing 
            //

            if (c == TEXT( '^' )) {
                c = *srcstr++;
                if (c == TEXT( '\0' )) {
                    break;
                }
            }

            //
            //  Copy in the single character
            //

            *dststr++ = c;
            dlen++;
        }
    }

    //
    //  If we've gotten too long then free the string and bail
    //
    
    if (dlen > MAXTOKLEN) {
        FreeStr( dest );
        return(FAILURE);
    }

    *save = srcpy;
    if (!(*src = resize( dest, (dlen+1)*sizeof(TCHAR*)))) {
        FreeStr( dest );
        return(FAILURE);
    }

    return(SUCCESS);
}

//
// Queries for cmd policy
//
//     0 = no policy, normal operation
//     1 = completely disabled
//     2 = interactive prompt disabled, but scripts allowed to run
//

VOID GetCmdPolicy(INT * iDisabled)
{
    DWORD  dwSize, dwType;
    HKEY   hKey;


    //
    // Set default
    //

    *iDisabled = CMD_POLICY_NORMAL;

    if (RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Policies\\Microsoft\\Windows\\System"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(INT);
        RegQueryValueEx (hKey, TEXT("DisableCMD"), NULL, &dwType,
                                   (LPBYTE) iDisabled, &dwSize);

        RegCloseKey (hKey);
    }

}


/*++

Routine Description:

    This routine dumps string data

Arguments:

    Bytes - Points to bytes to be dumped

    Length - length of bytes to dump.  -1 means dump up to the first zero byte

Return Value:

    None.

--*/

void 
DumpBytes(
    PBYTE Bytes,
    ULONG Length
    )
{
    ULONG i;

    if (Length == -1) {
        Length = strlen( Bytes );
    }

    for (i = 0; i < Length; i++) {
        if ((i%16) == 0) {
            printf( "\n%04x: ", i );
        }
        printf( " %02x", Bytes[i] & 0xFF );
    }
    if (Length != 0) {
        printf( "\n" );
    }
}

void 
DumpTchars(
    PTCHAR Chars,
    ULONG Length
    )
{
    ULONG i;

    if (Length == -1) {
        Length = _tcslen( Chars );
    }


    for (i = 0; i < Length; i++) {
        if ((i%16) == 0) {
            printf( "\n%04x: ", i );
        }
        if (sizeof( TCHAR ) == 1) {
            printf( " %02x", Chars[i] & 0xFF );
        } else {
            printf( " %04x", Chars[i] & 0xFFFF );
        }
    }
    if (Length != 0) {
        printf( "\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cmdproto.h ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cmdproto.h

Abstract:

    Forward procedure prototypes

--*/

//
// Define structures names that are forward referenced in prototypes.
//

struct batdata;
struct cmdnode;
typedef struct cpyinfo CPYINFO, *PCPYINFO;
struct detnode;
struct envdata;
struct FEA2List;
struct fornode;
struct ifnode;
struct node;
struct relem;

//
// Define routine types.
//

typedef
int
(*PLOOP_THROUGH_ARGS_ROUTINE) (
    TCHAR *String
    );

typedef
struct node *
(*PPARSE_ROUTINE) (
    void
    );

//
// Define function prototypes.
//

void CMDexit(int rc);

VOID
InitializeDbcsLeadCharTable(
    );
TCHAR * mystrchr(register TCHAR const *string, TCHAR c);
TCHAR * mystrrchr(register TCHAR const *string, TCHAR c);
size_t mystrcspn(TCHAR const *str1, TCHAR const *str2);

#if CMD_DEBUG_ENABLE
void Deb(ULONG, ULONG, CHAR *, ...);
#endif
/* Do Not Delete The Following Line - Or Put Anything After It */
/* Global Declarations Follow */
int BatProc(struct cmdnode   *,TCHAR   *,int );
int BatLoop(struct batdata   *,struct cmdnode   *);
int SetBat(struct cmdnode   *,TCHAR   *);
void DisplayStatement(struct node   *,int );
void DisplayOperator(struct node   *,TCHAR   *);
void DisplayRedirection(struct node   *);
CRTHANDLE OpenPosBat(struct batdata     *);
int eEcho(struct cmdnode   *);
int eKeys(struct cmdnode   *);
void FvarRestore(void );
int eFor(struct fornode *);
int FWork(struct node   *,BOOL);
int SubFor(struct node   *,BOOL);
int SFWork(struct node   *,TCHAR   *   *,int ,BOOL);
int ForFree(int );
int eGoto(struct cmdnode   *);
int eIf(struct ifnode   *);
int eCmdExtVer(struct cmdnode   *);
int eErrorLevel(struct cmdnode   *);
int eDefined(struct cmdnode   *);
int eExist(struct cmdnode   *);
int eNot(struct cmdnode   *);
int eStrCmp(struct cmdnode   *);
int eGenCmp(struct cmdnode   *);
int ePause(struct cmdnode   *);
int eShift(struct cmdnode   *);
int eSetlocal(struct cmdnode   *);
int eEndlocal(struct cmdnode   *);
void EndAllLocals(struct batdata   *);
void ElclWork(struct batdata   *);
int eCall(struct cmdnode   *);
int eExtproc(struct cmdnode   *);
int Dir(TCHAR   *);
int DirSwitches(TCHAR   *, int, int *, int *, int *, int *);
int DirDevCheck(TCHAR   *,int );
void DirPrintPerFileInfo(PWIN32_FIND_DATA, int, TCHAR *, int *);
long DiskFreeSpace(TCHAR );
void DirError(unsigned int );
unsigned SetLastRetCodeIfError(unsigned);
int ePath(struct cmdnode   *);
int PathWork(struct cmdnode   *,int );
int ePrompt(struct cmdnode   *);
int eSet(struct cmdnode   *);
int SetWork(struct cmdnode   *);
int DisplayEnvVariable(TCHAR *);

const TCHAR *
MyGetEnvVarPtr(TCHAR *varname);

int DisplayEnv(void );
int SetEnvVar(TCHAR *,TCHAR *,struct envdata   *);
TCHAR *DeleteEnvVar(struct envdata   *,TCHAR *,TCHAR *);
TCHAR *FindEnvVar(TCHAR *,TCHAR *);
int AddEnvVar(struct envdata   *,TCHAR *,TCHAR *,TCHAR *,int );
PTCHAR GetEnvVar(PTCHAR);
struct envdata   *CopyEnv(void );
void ResetEnv(struct envdata   *);
int MoveEnv(TCHAR *, TCHAR *, ULONG );
int eAppend(struct cmdnode *);
int ExtCom(struct cmdnode *);
int ECWork(struct cmdnode *,unsigned int ,unsigned int );
int ExecPgm(struct cmdnode *,TCHAR *,unsigned int ,unsigned int, TCHAR *, TCHAR *, TCHAR *  );
int SearchForExecutable(struct cmdnode   *,TCHAR   *);
int DoFind(TCHAR   *,int ,TCHAR   *, BOOL);
void ExecError(TCHAR *);
int eAssoc(struct cmdnode *);
int AssocWork(struct cmdnode *);
int DisplayAssoc(HKEY, TCHAR *);
int SetAssoc(HKEY, TCHAR *, TCHAR *);
int eFType(struct cmdnode *);
int FTypeWork(struct cmdnode *);
int DisplayFType(HKEY, TCHAR *);
int SetFType(HKEY, TCHAR *, TCHAR *);

//  CFile.c
void RestoreSavedDirectory( void );
BOOL GetPromptOkay(const TCHAR *,BOOL *);
int eCopy(struct cmdnode *);
int eDelete(struct cmdnode *);
int DelWork(TCHAR   *);
int eMove(struct cmdnode *);
int MoveParse(struct cmdnode *,BOOL *,TCHAR *,TCHAR *,PCPYINFO*, unsigned int *,unsigned, unsigned);
int Move(TCHAR *,TCHAR *,BOOL, PCPYINFO, unsigned int);
int eRename(struct cmdnode   *);
int RenWork(struct cmdnode   *);
// int eChcp(struct cmdnode   *);
int eTitle(struct cmdnode *);
int eStart(struct cmdnode   *);
int eDirectory(struct cmdnode   *);
int eType(struct cmdnode   *);
int TyWork(TCHAR   *);
int eVersion(struct cmdnode   *);
int eVolume(struct cmdnode   *);
int VolWork(TCHAR   *);
BOOL Init(TCHAR *InitialCmds[]);
void GetRegistryValues(TCHAR *InitialCmds[]);
void CheckSwitches(TCHAR *InitialCmds[], TCHAR *);
void SetUpEnvironment(void);
void InitLex(unsigned int ,INT_PTR );
unsigned int Lex(TCHAR   *,unsigned int );
int TextCheck(TCHAR   *,unsigned int   *);
TCHAR GetByte(void );
void UnGetByte(void );
void FillBuf(void );
int LexCopy(TCHAR   *,TCHAR   *,int );
void PrintPrompt(void );
int IsData(void );
void SubVar(void );
TCHAR   *MSEnvVar(jmp_buf *, TCHAR   *,int   *, const TCHAR);
TCHAR   *MSCmdVar(jmp_buf *, TCHAR   *,int   *, TCHAR *, TCHAR *subs[]);
int Dispatch(int ,struct node   *);
int SetRedir(struct node   *,int );
int AddRedir(struct cmdnode   *,struct cmdnode   *);
void ResetRedir(void );
int FindFixAndRun(struct cmdnode   *);
int FindAndFix(struct cmdnode   *,TCHAR   *);

void FreeBigBuf(int );
void FreeStack(ULONG );
void FreeStr( IN  PTCHAR   pbFree );
PVOID GetBigBuf(ULONG, ULONG, unsigned int *, int);
struct node   *mknode(void );
void   *mkstr(int );
TCHAR *dupstr( TCHAR *String );
void   *gmkstr(int );
void   *resize(void*, unsigned int );

int eDetach(struct detnode   *);
int eComSep(struct node   *);
int eOr(struct node   *);
int eAnd(struct node   *);
int ePipe(struct node   *);
void PipeErr(void );
int PipeWait(void );
void BreakPipes(void );
int eParen(struct node   *);
int eCls(struct cmdnode   *);
int eExit(struct cmdnode   *);
int eVerify(struct cmdnode   *);
int VerifyWork(struct cmdnode   *);
BOOLEAN GetSetVerMode(BYTE);
struct node   *Parser(unsigned int ,INT_PTR ,int );
struct node   *ParseStatement(int);
struct node   *ParseFor(void );
struct node   *ParseIf(void );
struct node   *ParseDetach(void );
struct node   *ParseRem(void );
struct node   *ParseS0(void );
struct node   *ParseS1(void );
struct node   *ParseS2(void );
struct node   *ParseS3(void );
struct node   *ParseS4(void );
struct node   *ParseS5(void );
struct cmdnode   *ParseCond(unsigned int );
void ParseArgEqArg(struct cmdnode   *);
struct node   *ParseCmd(void );
int ParseRedir(struct relem   *   *);


struct node *
BinaryOperator (
    TCHAR *,
    int,
    PPARSE_ROUTINE,
    PPARSE_ROUTINE
    );

TCHAR   *BuildArgList(void );
void GetCheckStr(TCHAR   *);
TCHAR   *GeTexTok(unsigned int );
unsigned int GeToken(unsigned int );
struct cmdnode   *LoadNodeTC(int );
void PError(void );
void PSError(void );
void SpaceCat(TCHAR   *,TCHAR   *,TCHAR   *);
int eMkdir(struct cmdnode   *);
int MdWork(TCHAR   *);
int eChdir(struct cmdnode   *);
int ChdirWork(TCHAR *);
int eRmdir(struct cmdnode   *);
int RdWork(TCHAR   *);

void 
parse_args(
    PTCHAR args, 
    PCPYINFO source, 
    PCPYINFO dest);

void handle_switch(
    TCHAR *tas, 
    PCPYINFO source, 
    PCPYINFO dest, 
    int parse_state, 
    int *current_copy_mode, 
    PBOOL ShortNameSwitch,
    PBOOL RestartableSwitch,
    PBOOL PromptOnOverwrite
    );

int
found_file(
    PTCHAR token,
    int parse_state,
    PCPYINFO *source,
    PCPYINFO *dest,
    int *num_sources,
    int *all_sources_wild,
    int mode);
void set_mode(int ,int ,int ,PCPYINFO);
PCPYINFO add_filespec_to_struct(PCPYINFO,TCHAR   *,int );
void Abort( void );
void ExitAbort( ULONG );
void SigCleanUp(void );
TCHAR   *TokStr(TCHAR   *,TCHAR   *,unsigned int );
int FullPath(TCHAR   *,TCHAR   *, ULONG);
int FileIsConsole( CRTHANDLE );
int FileIsDevice( CRTHANDLE );
int FileIsPipe( CRTHANDLE );
int FileIsRemote( LPTSTR );
int GetDir(TCHAR   *,TCHAR );

typedef enum  {
    CD_SET_DRIVE_DIRECTORY,
    CD_SET_DIRECTORY,
    CD_SET_ENV,
} CHANGE_OP;

int ChangeDirectory( TCHAR *newdir, CHANGE_OP op );
int ChangeDir(TCHAR   *);
int ChangeDir2(TCHAR *, BOOL);
BOOL FixupPath(TCHAR *, BOOL);

int ePushDir( struct cmdnode *);
int ePopDir( struct cmdnode *);
int GetDirStackDepth(void);

int ePriv( struct cmdnode *);

int
LoopThroughArgs (
    TCHAR *,
    PLOOP_THROUGH_ARGS_ROUTINE,
    int
    );

  STATUS BuildFSFromPatterns ( PDRP, BOOLEAN, BOOLEAN, PFS * );
  STATUS ParseDirParms( PTCHAR, PDRP );
  BOOL ScanFSpec(PCPYINFO);

  PCPYINFO SetFsSetSaveDir(TCHAR   *);
  int exists(TCHAR   *);
  int exists_ex(TCHAR   *, BOOL);      /*@@4*/
  void FixPChar(TCHAR   *, TCHAR);
  void FlushKB(void );
  int DriveIsFixed(TCHAR   *);
  int Start(TCHAR   *);
  int Chcp(TCHAR   *);
  void Q_KbdVioCp(void );
  void S_KbdVioCp(void );
  int OnOffCheck(TCHAR   *,int );
  void ChangeDrive(int );
  int PutStdOut(unsigned int MsgNum, unsigned int NumOfArgs, ...);
  int PutStdErr(unsigned int MsgNum, unsigned int NumOfArgs, ...);
  void BeginHelpPause( void );
  void EndHelpPause( void );
  int PutMsg(unsigned int MsgNum, CRTHANDLE Handle, unsigned int NumOfArgs, va_list *arglist);
  PTCHAR argstr1(TCHAR  *,ULONG_PTR);
  CRTHANDLE Copen_Work(TCHAR   *,unsigned int ,unsigned int );
  CRTHANDLE Copen_Work2(TCHAR *,unsigned int ,unsigned int, unsigned);
  CRTHANDLE Copen(TCHAR   *,unsigned int );
  CRTHANDLE Copen2(TCHAR *, unsigned int, unsigned);
  CRTHANDLE Copen_Copy2(TCHAR *,unsigned int);
  CRTHANDLE Copen_Copy3(TCHAR *);
  unsigned long InSetList( CRTHANDLE );
  CRTHANDLE Cdup( CRTHANDLE );
  CRTHANDLE Cdup2( CRTHANDLE , CRTHANDLE );
  int Cclose( CRTHANDLE );
  void SetList( CRTHANDLE );
  int ( * GetFuncPtr(int ))(struct cmdnode *);
int FindCmd(
    int entries, 
    const TCHAR *sname, 
    TCHAR *sflags);
  
int KillProc(HANDLE, int );
  int WaitProc(HANDLE);
  void ParseLabel(TCHAR   *,TCHAR buf[],ULONG, BOOLEAN );
  PTCHAR EatWS(TCHAR    *,TCHAR *);
  int IsValidDrv(TCHAR );
  int IsDriveLocked(TCHAR );
  void PrtErr(unsigned int );
  PTCHAR GetMsg(unsigned MsgNum, ...);
  TCHAR   *dayptr(unsigned int );
  int copy(TCHAR   *);
  int get_full_name(PCPYINFO, TCHAR *);

int
do_normal_copy(
    PCPYINFO source, 
    PCPYINFO dest);

  int do_combine_copy(PCPYINFO,PCPYINFO);

PCPYINFO 
NewCpyInfo( 
    void 
    );
  
void close_dest(PCPYINFO, PCPYINFO, TCHAR*, CRTHANDLE, LPFILETIME );
  int get_dest_name(PCPYINFO ,PCPYINFO ,TCHAR   *, unsigned, BOOL);
  
unsigned 
wildcard_rename(
    TCHAR *OutputBuffer,
    const TCHAR *dest,
    const TCHAR *source,
    ULONG sizbufr
    );

  void get_clean_filename(TCHAR   *,TCHAR   *,TCHAR   *);
  BOOL MyWriteFile(CRTHANDLE, CONST VOID *, DWORD, LPDWORD);
  int same_file(TCHAR   *,TCHAR   *);
  void copy_error(unsigned int ,int );
  BOOL DestinationNeedsCtrlZ( PCPYINFO );
  int eDate(struct cmdnode   *);
  int eTime(struct cmdnode   *);
  int PrintDate(struct tm *, int, TCHAR *, int );
  int PrintTime(struct tm *, int, TCHAR *, int );
  int GetVerSetDateTime(TCHAR   *,int );
  int VerifyDateString(LPSYSTEMTIME, TCHAR   *,TCHAR   *);
  int VerifyTimeString(LPSYSTEMTIME, TCHAR   *,TCHAR   *);
  BOOLEAN ffirst(PTCHAR, ULONG, PWIN32_FIND_DATA, PHANDLE);
  BOOLEAN fnext(PWIN32_FIND_DATA, ULONG, HANDLE);
  int     f_how_many (PTCHAR, ULONG);
  int hstoi(TCHAR   *);
  TCHAR   *lastc(TCHAR   *);
  TCHAR   *penulc(TCHAR   *);
  TCHAR   *prevc(TCHAR   *,TCHAR   *);

void InitLocale( VOID );

  unsigned WindowSwitch(void );
  int findclose(HANDLE);
  int isFATdrive(TCHAR *);
  
  int CmdPutChars( PTCHAR String, int Length );
  int CmdPutString( PTCHAR String );
  int cmd_printf(TCHAR *fmt,...);


TCHAR *StripQuotes( TCHAR * );
TCHAR *SkipWhiteSpace( TCHAR * );

ULONG GetEnvCb( TCHAR *);

int cmdfound;        /* command found from parser         */
int cpyfirst;        /* first time for DOSQFILEMODE           */
int cpydflag;        /* flag for DOSQFILEMODE fr pars         */
int cpydest;         /* flag for not disp bad dev msg twice   */
int cdevfail;        /* flag for dev failed ScanFSpec         */
int first_file;          /* @@5@J1 1st file flag from copy cmd    */
int first_fflag;         /* @@5@J3 1st file flag from copy EAs    */
#ifdef UNICODE
BOOLEAN  fOutputUnicode; /* Unicode/Ansi output */
#endif // UNICODE

VOID
ConverttmToFILETIME (
    struct tm *Time,
    LPFILETIME FileTime
    );

VOID
ConvertFILETIMETotm (
    LPFILETIME FileTime,
    struct tm *Time
    );

STATUS   DisplayBare ( PSCREEN, ULONG, PTCHAR, PWIN32_FIND_DATA );
VOID     SetDotForm ( PTCHAR, ULONG );
STATUS   DisplayDotForm ( PSCREEN, ULONG, PTCHAR, PWIN32_FIND_DATA );
STATUS   DisplaySpacedForm( PSCREEN, ULONG, PTCHAR, PWIN32_FIND_DATA );
STATUS   DisplayOldRest( PSCREEN, ULONG, ULONG, PWIN32_FIND_DATA );
STATUS   DisplayNewRest( PSCREEN, ULONG, ULONG, PWIN32_FIND_DATA );
STATUS   DisplayTimeDate( PSCREEN, ULONG, ULONG, PWIN32_FIND_DATA );
STATUS   DisplayWide ( PSCREEN, ULONG, PWIN32_FIND_DATA );
STATUS   DisplayFileSizes( PSCREEN, PLARGE_INTEGER, ULONG, ULONG );
STATUS   DisplayTotals( PSCREEN, ULONG, PLARGE_INTEGER, ULONG );
STATUS   DisplayDiskFreeSpace( PSCREEN, PTCHAR, ULONG, ULONG );
STATUS   DisplayVolInfo( PSCREEN, PTCHAR );
USHORT   GetMaxCbFileSize( PFS );
STATUS   FormatFileSize( DWORD, PLARGE_INTEGER, DWORD, PTCHAR );

STATUS   OpenScreen( PSCREEN * );
STATUS   WriteString( PSCREEN, PTCHAR );
STATUS   WriteMsgString( PSCREEN, ULONG , ULONG , ... );
STATUS   WriteFmtString(PSCREEN, PTCHAR, PVOID );
STATUS   WriteEol( PSCREEN );
STATUS   WriteTab( PSCREEN );
STATUS   WriteFlush( PSCREEN );
STATUS   WriteFlushAndEol( PSCREEN );
VOID     CheckPause( PSCREEN );
VOID     SetTab( PSCREEN, ULONG );
VOID     FillToCol ( PSCREEN, ULONG );

ULONG    PromptUser ( PTCHAR, ULONG, ULONG );
void     CheckCtrlC();

BOOLEAN  TokStrAndCheckHelp(struct cmdnode *, ULONG );
BOOLEAN  CheckHelpSwitch( ULONG, PTCHAR );
BOOLEAN  TokBufCheckHelp(PTCHAR , ULONG );

PTCHAR GetTitle(struct cmdnode * );
VOID SetConTitle(PTCHAR );
VOID ResetConTitle( PTCHAR );
void ResetConsoleMode( void );
void mytcsnset ( PTCHAR string, TCHAR val, int count);

BOOL ReadBufFromInput   (HANDLE h, TCHAR*pBuf, int cch, int*pcch);
BOOL ReadBufFromConsole (HANDLE h, TCHAR*pBuf, int cch, int*pcch);
BOOL ReadBufFromFile    (HANDLE h, TCHAR*pBuf, int cch, int*pcch);
#if defined(FE_SB)
BOOLEAN IsDBCSCodePage();
BOOL IsFullWidth(TCHAR wch);
int  SizeOfHalfWidthString(TCHAR *pwch);
#endif

#ifndef WIN95_CMD
typedef
BOOL
(WINAPI *LPCOPYFILEEX_ROUTINE)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    );

LPCOPYFILEEX_ROUTINE lpCopyFileExW;

typedef
VOID
(WINAPI *LPSETCONSOLEINPUTEXENAME_ROUTINE)(
    LPCWSTR         lpExeName
    );

LPSETCONSOLEINPUTEXENAME_ROUTINE lpSetConsoleInputExeName;


typedef
BOOL
(WINAPI *LPISDEBUGGERPRESENT_ROUTINE)( VOID );

LPISDEBUGGERPRESENT_ROUTINE lpIsDebuggerPresent;

#endif


int SetColor(WORD attr);
void DoCompleteInitialize( VOID );
int DoComplete(TCHAR *buffer,int len,int maxlen,int bForward,int bPathCompletion,int bTouched );

#ifdef WIN95_CMD
BOOL Win95ReadConsoleA(HANDLE hIn,LPSTR pBuf,DWORD cch,LPDWORD pcch,LPVOID lpReserved);
#undef ReadConsole
#define ReadConsole Win95ReadConsoleA
#endif

//  TREE.C
STATUS
AppendPath(
    OUT PTCHAR Buffer,
    IN ULONG BufferCount,
    IN PTCHAR Prefix,
    IN PTCHAR Suffix
    );

STATUS
WalkTree(
    IN  PFS     FileSpec,
    IN  PSCREEN pscr,
    IN  ULONG   AttribMask,
    IN  ULONG   AttribValues,
    IN  BOOL    Recurse,

    IN  PVOID   Data OPTIONAL,
    IN  VOID    (*ErrorFunction) (STATUS, PTCHAR, PVOID) OPTIONAL,
    IN  STATUS  (*PreScanFunction) (PFS, PSCREEN, PVOID) OPTIONAL,
    IN  STATUS  (*ScanFunction) (PFS, PFF, PSCREEN, PVOID) OPTIONAL,
    IN  STATUS  (*PostScanFunction) (PFS, PSCREEN, PVOID) OPTIONAL
    );

STATUS
ExpandAndApplyToFS(
    IN  PFS     FileSpec,
    IN  PSCREEN pscr,
    IN  ULONG   AttribMask,
    IN  ULONG   AttribValues,

    IN  PVOID   Data OPTIONAL,
    IN  VOID    (*ErrorFunction) (STATUS, PTCHAR, PVOID) OPTIONAL,
    IN  STATUS  (*PreScanFunction) (PFS, PSCREEN, PVOID) OPTIONAL,
    IN  STATUS  (*ScanFunction) (PFS, PFF, PSCREEN, PVOID) OPTIONAL,
    IN  STATUS  (*PostScanFunction) (PFS, PSCREEN, PVOID) OPTIONAL
    );


__inline
BOOL IsDrive( LPCTSTR Path )
{
    return Path[0] != TEXT('\0') && Path[1] == TEXT(':') && Path[2] == TEXT('\0');
}

__inline
VOID WINAPI
CmdSetThreadUILanguage( WORD wReserved )
{
    static LANGID (WINAPI *pSetThreadUILanguage)(  ) = NULL;

    if (pSetThreadUILanguage == NULL) {
        // This check has to put in because hKernel32 may not have been 
        // correctly set before a call to CmdSetThreadUILanguage is made
        if (hKernel32 == INVALID_HANDLE_VALUE) {
            hKernel32 = GetModuleHandle( TEXT("KERNEL32.DLL") );               
        }
        pSetThreadUILanguage = (PVOID) GetProcAddress( hKernel32, "SetThreadUILanguage" );
    }

    if (pSetThreadUILanguage == NULL) {
        SetThreadLocale( MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ), SORT_DEFAULT ));
    } else {
        (*pSetThreadUILanguage)( 0 );
    }
}


//  DIR.C

STATUS
SetAttribs(
    IN  PTCHAR  pszTok,
    OUT PDRP    pdrp
    );

//  CINIT.C

VOID 
GetVersionString(
    IN OUT PTCHAR VersionString,
    IN ULONG Length
    );


//  cmd.c

void DumpBytes( PBYTE Bytes, ULONG Length );
void DumpTchars( PTCHAR Chars, ULONG Length );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cmd.h ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cmd.h

Abstract:

    Global types and definitions

--*/

#define _WIN32_
#include <ctype.h>
/* use real function to avoid side effects */
#undef iswalpha
#undef iswdigit
#undef iswspace
#undef iswxdigit

#include <stdio.h>
#define  inpw _inpw                     /* To keep the compiler happy */
#define  outpw _outpw                   /* To keep the compiler happy */
#include <conio.h>
#include <fcntl.h>
#include <share.h>
#include <search.h>
#include <setjmp.h>
#include <sys\types.h>                  /* M001 - this file must...        */
#include <sys\stat.h>                   /* ...precede this one             */
#include <io.h>
#include <time.h>
#include <locale.h>
#include <memory.h>
#include <process.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <errno.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbasep.h>
#include <winnlsp.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlapip.h>
#include <winconp.h>
#include <tchar.h>
#include <aclapi.h>
#include <aclapip.h>
#include <winsafer.h>
#include <delayimp.h>

#ifndef UNICODE
#ifndef WIN95_CMD
#error Unicode must be defined!!!!
#endif // WIN95_CMD
#endif

#define BYTE_ORDER_MARK           0xFEFF

//
// No dynamic stack checking in CBATCH.C and CPARSE.C
//

#undef USE_STACKAVAIL

//
// CMDEXTVERSION is a number that is incremented whenever the Command
// Extensions enabled by CMD /X undergo a significant revision.  Allow
// batch scripts to use new features conditionally via the following
// syntax:
//
//      IF CMDEXTVERSION 1 statement
//

#define CMDEXTVERSION 2


/*  M000 - These are definitions for specific file classification and
 *  permission variables used in redirection
 */

#define OP_APPEN   (O_RDWR|O_APPEND|O_CREAT)    /* Append redir file       */
#define OP_TRUNC   (O_WRONLY|O_CREAT|O_TRUNC)   /* Truncate redir file     */
#define OP_PERM    (S_IREAD|S_IWRITE|S_IEXEC)   /* R/W/X permission 0700   */

//
// These 3 file handles are valid only for the Lowio routines exported
// by the C Runtimes IO.H
//

#define STDIN  0
#define STDOUT 1
#define STDERR 2

#include "cmdmsg.h"

/* Definitions used by or passed to functions in CMD.C
 *
 *      M000 - Args to Dispatch (ultimately Set/ResetRedir)
 *      M037 - Added REPROCESS for rewalking redirection list.
 *
 */

#define RIO_OTHER   0   /* Means call by misc. function                    */
#define RIO_MAIN    0   /* Means call by main()                            */
#define RIO_PIPE    1   /* Means call by ePipe()                           */
#define RIO_BATLOOP 2   /* Means call by BatLoop()                         */
#define RIO_REPROCESS 3 /* Means reprocessing redir by AddRedir            */


#define APP_FLG     1   /* Flag bit indicates append when redir stdout     */

/*  M000 ends   */

/* M016 begin   */
#define NOFLAGS         0  /* No flag bits set                             */
#define CHECKDRIVES     1  /* Check the drives of the args to this command */
#define NOSWITCHES      2  /* No switches are allowed for this command     */
#define EXTENSCMD       4  /* Only allowed if fEnableExtensions is TRUE    */
/* M016 ends    */

//
// Exit code used to abort processing (see ExitAbort and cmd.c)
//
// Exit due to eof on redirected stdin
//
#define EXIT_EOF    2
#define EOF         (-1)

/* The following defines are used by CPARSE.C and CLEX.C                   */

#define READSTRING          1   /* Flags which tell the parser             */
#define READSTDIN           2   /*  where and how to get its input         */
#define READFILE            3
#define FIRSTIME            3
#define NOTFIRSTIME    0x8000

#define ANDSTR       TEXT("&&")       /* And operator string                     */
#define ANDOP         TEXT('&')       /* And operator character                  */
#define CSOP          TEXT('&')       /* Command separator character             */
#define CSSTR         TEXT("&")       /* Command separator string                */
#define EQ            TEXT('=')       /* Equals character                        */
#define EQSTR        TEXT("==")       /* Equals string                           */
#define EQI           TEXT('~')       /* Equals character (case insensitive)     */
#define EQISTR       TEXT("=~")       /* Equals string (case insensitive)        */
#define INOP          TEXT('<')       /* Input redirection character             */
#define INSTR         TEXT("<")       /* M008 - Input redirection string         */
#define IAPSTR        TEXT("<<")      /* M022 - Will be used in future (<<foo)   */
#define LPOP          TEXT('(')       /* Left parenthesis character              */
#define LEFTPSTR      TEXT("(")       /* Left parenthesis string                 */
#define ORSTR        TEXT("||")       /* Or operator string                      */
#define OUTOP         TEXT('>')       /* Output redirection character            */
#define OUTSTR        TEXT(">")       /* M008 - Output redirection string        */
#define APPSTR        TEXT(">>")      /* M008 - Output w/append redir string     */
#define PIPOP         TEXT('|')       /* Pipe operator character                 */
#define PIPSTR        TEXT("|")       /* Pipe operator string                    */
#define RPOP          TEXT(')')       /* Right parenthesis character             */
#define RPSTR         TEXT(")")       /* Right parenthesis string                */
#define ESCHAR        TEXT('^')       /* M003/M013/M020 - Esc, next byte literal */
#define SPCSTR        TEXT(" ")       /* M022 - New string used in CMD.C         */
#define SILSTR        TEXT("@")       /* M024 - Suppress echo string             */
#define SILOP         TEXT('@')       /* M024 - Silent operator                  */

#define EOS             0       /* End of input stream                      */
#define DISPERROR       1   /* Dispatch error code                          */
#define DOPOS          22   /* Position in fornode->cmdline of do string    */
#define FORLINLEN      30   /* Length of for node command line              */
#define GT_NORMAL       0   /* Flag to GeToken(), get a normal token        */
#define GT_ARGSTR       1   /* Flag to GeToken(), get an argstring          */
#define GT_QUOTE        2       /* M007 - Term not used, reserves value     */
#define GT_EQOK         4   /* Flag to GeToken(), get equals not delimiter  */
#define GT_LPOP         8       /* M002 - Ok to parse '(' & '@' as oper's   */
#define GT_RPOP        16       /* M002 - Ok to parse ')' as operator      */
#define GT_REM         32       /* M007 - Parsing REM arg token            */
#define LEXERROR       -1   /* Lexer error code                             */
#define LX_UNGET        0   /* M020 - Lexer flag, Unget last token          */
#define LX_ARG          1   /* Lexer flag(), get an argstring               */
#define LX_QUOTE        2   /* Lexer flag(), getting a quoted string        */
#define LX_EQOK         4   /* Lexer flag(), equalsign not delimiter        */
#define LX_LPOP         8       /* M007 - Term not used, reserves value     */
#define LX_RPOP        16       /* M007 - Term not used, reserves value     */
#define LX_REM         32       /* M007 - Lexing REM arg token             */
#define LX_DBLOK       64       /* - ok for lexer to return second half
                                        of a double byte code               */
#define LX_DELOP   0x0100   /* Returned by TExtCheck, found delimeter/operator*/
#define MAINERROR       1   /* Main error code                              */
#define PC_NOTS         0   /* Flag to ParseCond(), "NOT"s are allowed      */
#define PC_NONOTS       1   /* Flag to ParseCond(), "NOT"s are not allowed  */
#define PIO_DO          1   /* Flag to ParseInOut(), do read token first    */
#define PIO_DONT        0   /* Flag to ParseInOut(), don't read token first */
#define PARSERROR       1   /* Parser error code                            */
#define TEXTOKEN   0x4000   /* Text token found flag                        */


#define LBUFLEN         8192
#define MAXTOKLEN       8192
#define TMPBUFLEN       8192


/* Definitions used by or passed to functions in CMEM.C                         */

#define FS_FREEALL  0           /* Tells FreeStack to free entire stack    */


/* Definitions used by or passed to functions in CEXT.C                     */

#define T_OFF           0       /* Execute with no trace active            */
#define T_ON            1       /* Execute with trace active               */
#define AI_SYNC         0       /* Async indicator - Exec synchronous      */
#define AI_DSCD         4       /* Async indicator - Exec async/discard @@ */
#define AI_KEEP         2       /* Async indicator - Exec async/save retcd */

#define SFE_NOTFND      0   /*  Ret'd by SearchForExecutable, not found     */
#define SFE_ISEXECOM    1   /*  Ret'd by SearchForExecutable, exe/com found */
#define SFE_ISBAT       2   /*  Ret'd by SearchForExecutable, bat found     */
#define SFE_FAIL        3   /*  Ret'd by SearchForExecutable, out of memory */
#define SFE_BADPATH     4   /*  Ret'd by SearchForExecutable, specified
                                                        path is bad         */
#define SFE_ISDIR       5   /*  Ret'd by SearchForExecutable, directory     */


/* Definitions used by or passed to the functions in CBATCH.C                */

#define BT_CHN      0   /* M011 - Arg to BatProc() Chain this batch job     */
#define BT_CALL     1   /* M011 - Arg to BatProc() Nest this batch job      */
#define E_OFF       0   /*  Echo mode off                                    */
#define E_ON        1   /*  Echo mode on                                     */
#define FORERROR    1   /*  For processor error                              */
#define MS_BAT      0   /*  Flag to MakeSubstitutions(), doing batch job subs*/
#define MS_FOR      1   /*  Flag to MakeSubstitutions(), doing FOR loop subs */
#define DSP_SCN     0   /* M024 - DisplayStatement called for scrn output  */
#define DSP_PIP     1   /* M024 - DisplayStatement called for pipe output  */
#define DSP_SIL     0   /* M024 - DisplayStatement uses "silent" mode      */
#define DSP_VER     1   /* M024 - DisplayStatement uses "verbose" mode     */
#define QUIETCH    TEXT('Q')  /* M024 - "QUIET" switch for batch files           */


/* Definitions used by or passed to functions in CDIR.C                     */

#define DAMASK          0x1F    /* All of these are used to isolated the    */
#define HRSHIFT           11    /*  different parts of a file's last        */
#define HRMASK          0x1F    /*  modification date and time.  This info  */
#define LOYR            1980    /*  is packed into 2 words in the following */
#define MOSHIFT            5    /*  format:                                 */
#define MOMASK          0x0F    /*                                          */
#define MNSHIFT            5    /*   Date word: bits 0-4 date, bits 5-8     */
#define MNMASK          0x3F    /*   month, bits 9-15 year-1980.            */
#define SCMASK          0x1F    /*                                          */
#define YRSHIFT            9    /*   Time: bits 0-4 seconds/2, bits 5-10    */
#define YRMASK          0x7F    /*   minutes, bits 11-15 month.             */
#define FFIRST_FAIL        2    /*   Flag to show ffirst failed             */


/* Definitions used by or passed to the functions in CPWORK.C and CPPARSE.C */

/*  M010 - This entire block added to facilitate rewritten copy files
 */

/*  different states for the parser  */

#define SEEN_NO_FILES                      1
#define JUST_SEEN_SOURCE_FILE              2
#define SEEN_PLUS_EXPECTING_SOURCE_FILE    3
#define SEEN_COMMA_EXPECTING_SECOND        4
#define SEEN_TWO_COMMAS                    5
#define SEEN_DEST                          6

/*  types of copy  */

#define COPY                               1
#define TOUCH                              2
#define CONCAT                             3
#define COMBINE                            4

/* Definitions used by or passed to the functions in CFILE.C                */

/* Values for the flags field of the copy information structure.            */
#define CI_BINARY       0x0001   /* File to be copied in binary mode         */
#define CI_ASCII        0x0002   /* File to be copied in ascii mode          */
#define CI_NOTSET       0x0004   /* Above mode given to file by default      */
#define CI_NAMEWILD     0x0008   /* Filename contains wildcards              */
#define CI_ALLOWDECRYPT 0x0010   /* Allow destination of copy to be decrypted */
#define CI_DONE         0x0020   /* No more files match this filespec        */
#define CI_FIRSTTIME    0x0040   /* First time file searched for             */
#define CI_ISDEVICE     0x0080   /* File is a device                         */
#define CI_FIRSTSRC     0x0100   /* First source in source list              */
#define CI_SHORTNAME    0x0200   /* if copying to FAT from NTFS, use short name */
#define CI_RESTARTABLE  0x0400   /* if the copy is restartable               */
#define CI_PROMPTUSER   0x2000   /* prompt if overwriting destination        */

//
//  These flags are filled in when we find out what the file type is
//

#define CI_UNICODE     0x4000   /* Buffer contains unicode chars            */
#define CI_NOT_UNICODE 0x8000   /* Buffer contains non-unicode chars        */

/* Flags passed to BuildFSpec()                                             */
#define BF_SRC              1   /* Called from OpenSrc()                    */
#define BF_DEST             2   /* Called from OpenDest()                   */
#define BF_DRVPATH          4   /* Add drive and path                       */

/* Flags passed to CopyError()                                              */
#define CE_PCOUNT           1   /* Print the copied files count             */
#define CE_NOPCOUNT         0   /* Don't print the copied files count       */

/* Flags passed to CSearchError()                                           */
#define CSE_OPENSRC         0   /* Called from OpenSrc()                    */
#define CSE_OPENDEST        1   /* Called from OpenDest()                   */


/* Definitions/structures used by or passed to the functions in CENV.C      */

struct envdata {
        TCHAR    *handle ;      /* Environment pointer                     */
        unsigned cursize ;      /* # of bytes used in the segment          */
        unsigned maxsize ;      /* # of bytes in the entire segment        */
} ;

#define AEV_ADDPROG 0   /* Flag to AddEnvVar, add a program name           */
#define AEV_NORMAL  1   /* Flag to AddEnvVar, add a normal variable        */


/* Definitions used by or passed to the functions in CCLOCK.C              */

#define PD_DIR      0   /* Flag to PrintDate, use Dir command date format   */
#define PD_DATE     1   /* Flag to PrintDate, use Date command date format  */
#define PD_PTDATE   2   /* Flag to PrintDate, prompt & use Date command format  */
#define PD_DIR2000  3   // Dir date format, four digit years
#define PT_DIR      0   /* Flag to PrintTime, use Dir command time format   */
#define PT_TIME     1   /* Flag to PrintTime, use Time command time format  */

#define EDATE       0       /* Flag for eDate                          */
#define ETIME       -1      /* Flag for eTime                          */

/* Definitions used by or passed to the functions in COTHER.C               */

#define GSVM_GET    2   /* Flag to GetSetVerMode(), just get current mode   */
#define GSVM_OFF    0   /* Flag to GetSetVerMode(), turn off                */
#define GSVM_ON     1   /* Flag to GetSetVerMode(), turn on                 */

/* Definitions used by CSTART.C     @WM2 */

#define FOREGRND 0         /* Start session in foreground */
#define BACKGRND 1         /* Start session in background */
#define ST_UNDEF   -1      /* Parameter isn't defined yet */
#define INDEPENDANT 0      /* New session will be independant */
#define ST_KSWITCH   1     /* Start parameter /K */
#define ST_CSWITCH   2     /* Start parameter /C */
#define ST_NSWITCH   3     /* Start parameter /N */
#define ST_FSSWITCH  PROG_FULLSCREEN     /* Start session in full screen mode */
#define ST_WINSWITCH PROG_WINDOWABLEVIO  /* Start session in winthorn mode */
#define ST_PMSWITCH  PROG_PM             /* Start session in presentation manager mode */
#define ST_DOSFSSWITCH  PROG_VDM      /* Start session in a VDM            */
#define ST_DOSWINSWITCH   PROG_WINDOWEDVDM /* Start session in windowed VDM */
#define NONWINSTARTLEN 30  /* Length of Data Structure when not using WIN */


/* Definitions used by or passed to the functions in CTOOLS.C               */

#define GD_DEFAULT  0   /* Flag to GetDir(), get dir for default drive      */
#define LTA_NOFLAGS 0   /* Flag to LoopThroughArgs()                        */
#define LTA_EXPAND  1   /* Flag to LoopThroughArgs(), expand wildcards      */
#define LTA_NULLOK  2   /* Flag to LoopThroughArgs(), null args ok          */
#define LTA_NOMATCH 4   /* Flag to LoopThroughArgs(), no match on wildcard ok */
#define LTA_CONT    8   /* Flag to LoopThroughArgs(), continue process  @@4 */
#define OOC_OFF     0   /* OnOffCheck() retcode, found "OFF"                */
#define OOC_ON      1   /* OnOffCheck() retcode, found "ON"                 */
#define OOC_EMPTY   2   /* OnOffCheck() retcode, found empty string         */
#define OOC_OTHER   3   /* OnOffCheck() retcode, found some other string    */
#define OOC_NOERROR 0   /* Flag to OnOffCheck(), OCC_OTHER is not an error  */
#define OOC_ERROR   1   /* Flag to OnOffCheck(), OCC_OTHER is an error      */
#define TS_NOFLAGS  0   /* Flag to TokStr(),                                */
#define TS_WSPACE   1   /* Flag to TokStr(), whitespace aren't delimiters   */
#define TS_SDTOKENS 2   /* Flag to TokStr(), special delimiters are tokens  */
#define TS_NWSPACE  4   /* Flag to TokStr(), spec delims are not white sp @@*/
#define RAW         4   /* Bit pattern for setting KBD RAW mode (M032)      */
#define COOKED      8   /* Bit pattern for setting KBD COOKED mode (M032)   */

/* Defines used to define and manage file handle from the C runtime */
typedef int CRTHANDLE;
#define BADHANDLE   (CRTHANDLE)-1 // bad handle from different opens
#define CRTTONT(fh) (HANDLE)_get_osfhandle(fh)


/***     Definitions and structures used by COP.C                          */

/*  Added structure to hold temporary pipe file information.  It is used
 *  to communicate with SetRedir() when redirecting input during execution
 *  of piped commands and by SigHand() and BreakPipes() when necessary
 *  to terminate a piped operation.
 *  M027 - Modified structure for real pipes.
 */

struct pipedata {
        CRTHANDLE       rh;             /* Pipe read handle                */
        CRTHANDLE       wh;             /* Pipe write handle               */
        CRTHANDLE       shr;            /* Handles where the normal...     */
        CRTHANDLE       shw;            /* ...STDIN/OUT handles are saved  */
        HANDLE          lPID ;          /* Pipe lh side PID                */
        HANDLE          rPID ;          /* Pipe rh side PID                */
        unsigned lstart ;               /* Start Information of lh side D64*/
        unsigned rstart ;               /* Start Information of rh side D64*/
        struct pipedata *prvpds ;       /* Ptr to next pipedata struct     */
        struct pipedata *nxtpds ;       /* Ptr to next pipedata struct     */
} ;

#define FH_INHERIT      0x0080          /* M027 Bits used by the api...    */
#define FH_WRTTHRU      0x4000          /* ...DOSQ/SETFHANDSTATE           */
#define FH_FAILERR      0x2000

/* Miscellaneous defines used in the code for enhanced readability.        */

#define MAX_DRIVES  (TEXT('Z') - TEXT('A') + 1)
#define BSLASH        TEXT('\\')
#define SWITCHAR      TEXT('/')
#define COLON         TEXT(':')
#define COMMA         TEXT(',')
#define DEFENVSIZE   0xA0   /* Default environment size                    */
#define DOLLAR       TEXT('$')
#define WINLOW       0x00000004     // Lowest acceptable version of Win32
#define WINHIGH      0xFFFF0004     // Highest acceptable version of Win32
#define DOT           TEXT('.')
#define FAILURE         1   /* Command/function failed.                    */
#define MINSTACKNEED 2200   /* MIN stack needed to parse commands   @WM1   */
#define NLN          TEXT('\n')   /* Newline character                     */
#define CR           TEXT('\r')   /* M004 - Added def for carriage return  */
#define NULLC        TEXT('\0')   /* Null character                        */
#define ONEQSTR       TEXT("=")
#define PERCENT       TEXT('%')
#define PLUS          TEXT('+')
#define MINUS         TEXT('-')   /* M038 - Added def for CTRY code        */
#define QMARK         TEXT('?')
#define QUOTE         TEXT('"')
#define STAR          TEXT('*')
#define CTRLZ         0x1A  /* M004 - Def for ^Z for lexer                 */
#define CTRLC         0x03  /* M035 - Def for ^C for ePause                */
#define SPACE         TEXT(' ')  /* M014 - Def for space character         */
#define SUCCESS         0   /* Command/function succeeded                  */
#define MAXTOWRITE    160   /* maximum number of chars to write - for ctrl-s */

//
// type for return code on dir and related functions, can be migrated
// into rest of cmd later.
typedef ULONG STATUS;
#define CHECKSTATUS( p1 ) {STATUS rc; if ((rc = p1) != SUCCESS) return( rc );  }
// #define CHECKSTATUS( rc ) if (rc != SUCCESS) { return( rc ); }

/* CWAIT ACTION CODES */
#define CW_A_SNGL       0x00    /* Wait only on indicated process  */
#define CW_A_ALL        0x01    /* Wait on all grandchildren too   */

/* CWAIT OPTION CODES */
#define CW_W_YES        0x00    /* Wait if no child ends (or no children)  */
#define CW_W_NO         0x01    /* Don't wait if no child ends     */

/* CWAIT PID VALUE */
#define CW_PID_ANY      0x00    /* PID val for wait on any child   */

/* DOSKILLPROCESS flag */
#define SS_SUBTREE      0x00

#define f_RET_DIR      -1             /* from f_how_many() when directory */

/* This structure is used by the FOR loop processor to save parse tree node
 * strings in.
 *
 *  M022 - This structure was extended to enable it to store the 10 possible
 *  redirection strings and the cmdline and argptr strings of a command node.
 *  This added eight pointers to the structure.
 */

struct savtype {
        TCHAR *saveptrs[12] ;
} ;

//
//  Global handles for DLL's
//

extern HMODULE hKernel32;

//
// Types used in dir command
//
#define MAXSORTDESC 6

typedef struct PATDSC {

    PTCHAR          pszPattern;
    PTCHAR          pszDir;
    BOOLEAN         fIsFat;
    struct PATDSC * ppatdscNext;

    } PATDSC, *PPATDSC;

//
// Dir command parameters in conan form (post parsing)
//
//
// A sort descriptor is used to define a type of sorting on the
// files in a directory.  Currently these are
// Name, Extension, Date/Time, Size and group directories first
// Each can be sort either by Assending or descending order.
//
typedef struct {            // srtdsc

    USHORT  Order;
    USHORT  Type;
    int(__cdecl * fctCmp) (const void * elem1, const void * elem2);

} SORTDESC, *PSORTDESC;


typedef struct {

    //
    //  Switches for enumeration
    //

    ULONG           rgfSwitches;

    //
    //  Attributes that are of interest for this enumeration
    //

    ULONG           rgfAttribs;

    //
    //  Attributes (subject to rgfAttribs mask) that must be on or off
    //  for files that match this enumeration
    //

    ULONG           rgfAttribsOnOff;

    //
    //  Number of sort descriptions
    //

    ULONG           csrtdsc;

    //
    //  Individual sort descriptors
    //

    SORTDESC        rgsrtdsc[MAXSORTDESC];

    //
    //  Count of patterns that are later converted to FS's
    //

    ULONG           cpatdsc;

    //
    //  Pointer to first pattern
    //

    PATDSC          patdscFirst;

    //
    //  Form of timestamp to display
    //

    ULONG           dwTimeType;

    //
    //  Count of files and directories seen and total bytes
    //

    ULONG           FileCount;
    ULONG           DirectoryCount;
    LARGE_INTEGER   TotalBytes;

} DRP;

typedef DRP *PDRP;

//
// The following number is also in makefile.inc as a parameter to MC.EXE
// to prevent it from generating a message that is bigger than we can handle.
//

#define MAXCBMSGBUFFER LBUFLEN
TCHAR MsgBuf[MAXCBMSGBUFFER] ;

//
// The buffers holding WIN32_FIND_DATA for dir use a USHORT size field
// for each WIN32_FIND_DATA entry and place the each data entry one after the
// other, plus DWORD align each entry. This is to avoid allocating MAX_PATH
// for each file name or maintaining a seperate filename buffer.
// The size of the entry is maintained so that we can quickly run over
// all of the data entries generating a seperate array of pointers to each
// entry that is used in sorting.
//
// obAlternative is the offset from the cFileName field to the alternative
// file name field if any. A 0 indication no alternative file name.
//
typedef struct {
        USHORT  cb;
        USHORT  obAlternate;
        WIN32_FIND_DATA data;
        } FF, *PFF, **PPFF;

typedef struct FS {

    //
    //  Link to next directory to be enumerated
    //

    struct FS * pfsNext;
    //
    //  Text of directory to be enumerated
    //

    PTCHAR      pszDir;

    //
    //  Count of patterns in directory
    //

    ULONG       cpatdsc;

    //
    //  Linked list of patterns within directory to be enumerated
    //

    PPATDSC     ppatdsc;

    //
    //  Various state flags
    //

    BOOLEAN     fIsFat;
    BOOLEAN     fDelPrompted;

    //
    //  Total count of entries stored in pff
    //

    ULONG       cff;

    //
    //  Pointer to packed FF's
    //

    PFF         pff;

    //
    //  Array of pointers into packed FF's.  Used for sorting.
    //

    PPFF        prgpff;

    //
    //  Number of files/directories in FF's
    //

    ULONG       FileCount;
    ULONG       DirectoryCount;

    //
    //  Total disk usage by all files satisfying this enumeration
    //

    LARGE_INTEGER cbFileTotal;

} FS, *PFS;

//
// used in dir to control display of screen.
//

typedef struct {            // scr

    HANDLE hndScreen;  // Screen handle (NULL if not a device)
    ULONG  crow;       // row position on current screen
    ULONG  ccol;       // column position in current row
    ULONG  cbMaxBuffer;// size of allocated buffer
    PTCHAR pbBuffer;   // bytes in buffer
    ULONG  ccolTab;    // column position for each tab
    ULONG  ccolTabMax; // max. cols to allow tabing into.
    ULONG  crowMax;    // no. of rows on screen
    ULONG  ccolMax;    // no. of cols on screen
    ULONG  crowPause;  // no. of rows to pause on.
    ULONG  cb;         // no. of characters in row - different than
                       // ccol, since Kanjii characters are half-width

} SCREEN, *PSCREEN;


/* Parse tree node structure declarations.  The basic structure type is called
 * node and is used for all operators.  All of the rest are based on it.  There
 * are several types of structures because some commands need special fields.
 * Functions that manipulate a parse tree node will either not care what type
 * of node it is getting or will know in advance what to expect.  All of the
 * nodes are the same size to make their manipulation easier.
 *
 *  M022 - The structures for node and cmdnode have been changed so that
 *  their redirection information is now a single pointer to a linked list
 *  of 'relem' structures rather than two simple byte pointers for STDIN and
 *  STDOUT and a single append flag.
 */

struct node {                   /* Used for operators                      */
        int type ;              /* Type of operator                        */
        struct savtype save ;   /* FOR processor saves orig strings here   */
        struct relem *rio ;     /* M022 - Linked redirection list          */
        struct node *lhs ;      /* Ptr to left hand side of the operator   */
        struct node *rhs ;      /* Ptr to right hand side of the operator  */
        INT_PTR extra[ 4 ] ;    /* M022 - Padding now needed               */
} ;

struct cmdnode {                /* Used for all commands except ones below */
        int type ;              /* Type of command                         */
        struct savtype save ;   /* FOR processor saves orig strings here   */
        struct relem *rio ;     /* M022 - Linked redirection list          */
        PTCHAR cmdline ;         /* Ptr to command line                    */
        PTCHAR  argptr ;         /* Ptr to type of command                 */
        int flag ;              /* M022 - Valid for cond and goto types    */
        int cmdarg ;            /* M022 - Argument to STRTYP routine       */
} ;

#define CMDNODE_FLAG_GOTO           0x0001
#define CMDNODE_FLAG_IF_IGNCASE     0x0002
#define CMDNODE_ARG_IF_EQU 1
#define CMDNODE_ARG_IF_NEQ 2
#define CMDNODE_ARG_IF_LSS 3
#define CMDNODE_ARG_IF_LEQ 4
#define CMDNODE_ARG_IF_GTR 5
#define CMDNODE_ARG_IF_GEQ 6

struct fornode {                /* Used for FOR commands                   */
        int type ;              /* FOR command type                        */
        struct savtype save ;   /* FOR processor saves orig strings here   */
        struct relem *rio ;     /* M022 - Linked redirection list          */
        PTCHAR cmdline ;        /* Ptr to command line                     */
        PTCHAR arglist ;        /* Ptr to the FOR argument list            */
        struct node *body ;     /* Ptr to the body of the FOR              */
        unsigned forvar ;       /* FOR variable - MUST BE UNSIGNED         */
        int flag ;              /* Flag                                    */
        union {
            PTCHAR recurseDir ;
            PTCHAR parseOpts ;
        } ;
} ;

#define FOR_LOOP            0x0001
#define FOR_MATCH_DIRONLY   0x0002
#define FOR_MATCH_RECURSE   0x0004
#define FOR_MATCH_PARSE     0x0008

struct ifnode {                 /* Used for IF commands                    */
        int type ;              /* IF command type                         */
        struct savtype save ;   /* FOR processor saves orig strings here   */
        struct relem *rio ;     /* M022 - Linked redirection list          */
        PTCHAR cmdline ;        /* Ptr to command line                     */
        struct cmdnode *cond ;  /* Ptr to the IF condition                 */
        struct node *ifbody ;   /* Ptr to the body of the IF               */
        PTCHAR elseline ;       /* Ptr to ELSE command line                */
        struct node *elsebody ; /* Ptr to the body of the ELSE             */
} ;

/* Operator and Command type values.  These definitions are the values
 * assigned to the type fields in the parse tree nodes and can be used as
 * indexes into the Operator and command jump table.  Because of this last
 * point these values ***>MUST<*** be kept in sync with the jump table.
 */

#define CMDTYP      0
#define CMDLOW      0   /* Lowest type number for an internal command   */
#define DIRTYP      0   /* DIR          */
#define DELTYP      1   /* DEL, ERASE       */
#define TYTYP       3   /* TYPE         */
#define CPYTYP      4   /* COPY         */
#define CDTYP       5   /* CD, CHDIR        */
#define RENTYP      7   /* REN, RENAME      */
#define ECHTYP      9   /* ECHO         */
#define SETTYP     10   /* SET          */
#define PAUTYP     11   /* PAUSE        */
#define DATTYP     12   /* DATE         */
#define TIMTYP     13   /* TIME         */
#define PROTYP     14   /* PROMPT       */
#define MDTYP      16   /* MD, MKDIR        */
#define RDTYP      18   /* RD, RMDIR        */
#define PATTYP     19   /* PATH         */
#define GOTYP      20   /* GOTO         */
#define SHFTYP     21   /* SHIFT        */
#define CLSTYP     22   /* CLS          */
#define CALTYP     23   /* M007 - New CALL command                         */
#define VRITYP     24   /* VERIFY       */
#define VERTYP     25   /* VER          */
#define VOLTYP     26   /* VOL          */
#define EXITYP     27   /* EXIT         */
#define SLTYP      28   /* M006 - Definition for SETLOCAL command          */
#define ELTYP      29   /* M006 - Definition for ENDLOCAL command          */
#define CHPTYP     30   /* CHCP @@*/
#define STRTTYP    31   /* START @@*/
#define APPDTYP    32   /* APPEND @@ */
#define KEYSTYP    33   /* KEYS @@5 */
#define MOVETYP    34   /* MOVE @@5 */

#define PUSHTYP    35   /* PushD        */
#define POPTYP     36   /* PopD         */
#define BRKTYP     37   /* M012 - Added new command type                  @@*/
#define ASSOCTYP   38   /* M012 - Added new command type                  @@*/
#define FTYPETYP   39   /* M012 - Added new command type                  @@*/
#define COLORTYP   40   /* COLOR */

#define CMDHIGH    40   /* Cmds higher than this are unique parse types @@*/

#define FORTYP     41   /* FOR */
#define IFTYP      42   /* IF  */
#define REMTYP     43   /* REM */

#define CMDMAX     43   /* Values higher are not commands */

#define LFTYP      44   /* Command separator (NL) */
#define CSTYP      45   /* Command separator (&) */
#define ORTYP      46   /* Or operator   */
#define ANDTYP     47   /* And operator  */
#define PIPTYP     48   /* Pipe operator */
#define PARTYP     49   /* Parenthesis   */

#define CMDVERTYP  50   /* CMDEXTVERSION         (used by if) */
#define ERRTYP     51   /* ERRORLEVEL            (used by if) */
#define DEFTYP     52   /* DEFINED               (used by if) */
#define EXSTYP     53   /* EXIST                 (used by if) */
#define NOTTYP     54   /* NOT                   (used by if) */
#define STRTYP     55   /* String comparison (used by if) */
#define CMPTYP     56   /* General comparison (used by if) */
#define SILTYP     57   /* M024 - "SILENT" unary operator */
#define HELPTYP    58   /* Help for FOR, IF and REM */

#define TBLMAX     58   /* M012 - Highest numbered table entry */



/* The following macros are for my debugging statements.  DEBUG expands to
 * a call to my debug statement printer if the DBGugging variable is
 * defined.  Otherwise, it expands to NULL.
 */

#if DBG
#define CMD_DEBUG_ENABLE 1
#define DEBUG(a) Deb a

/* The following are definitions of the debugging group and level bits
 * for the code in cbatch.c
 */

#define BPGRP   0x0100          /* Batch processor group                   */
#define BPLVL   0x0001          /* Batch processor level                   */
#define FOLVL   0x0002          /* FOR processor level                     */
#define IFLVL   0x0004          /* IF processor level                      */
#define OTLVL   0x0008          /* Other batch commands level              */

/* The following are definitions of the debugging group and level bits
 * for the code in cclock.c
 */

#define CLGRP   0x4000  /* Other commands group     */
#define DALVL   0x0001  /* Date command level       */
#define TILVL   0x0002  /* Time command level       */

/* The following are definitions of the DEBUGging group and level bits
 * for the code in cfile.c, cpparse.c, cpwork.c
 */

#define FCGRP   0x0020  // File commands group
#define COLVL   0x0001  // Copy level
#define DELVL   0x0002  // Delete level
#define RELVL   0x0004  // Rename level


/* The following are definitions of the debugging group and level bits
 * for the code in cinfo.c and display.c
 */

#define ICGRP   0x0040  /* Informational commands group */
#define DILVL   0x0001  /* Directory level              */
#define TYLVL   0x0002  /* Type level                   */
#define VOLVL   0x0008  /* Volume level                 */
#define DISLVL  0x0040  /* Directory level              */

/* The following are definitions of the debugging group and level bits
 * for the code in cinit.c
 */

#define INGRP   0x0002          /* Command Initialization group            */
#define ACLVL   0x0001          /* Argument checking level                 */
#define EILVL   0x0002          /* Environment initialization level        */
#define RSLVL   0x0004          /* Rest of initialization level            */

/* The following are definitions of the debugging group and level bits
 * for the code in clex.c, cparse.c
 */

#define PAGRP   0x0004  /* Parser                                          */
#define PALVL   0x0001  /* Parsing          */
#define LXLVL   0x0002  /* Lexing                                          */
#define LFLVL   0x0004  /* Input routine                                   */
#define DPLVL   0x0008  /* Dump parse tree      */
#define BYLVL   0x0010  /* Byte input routines                             */

//
// The following are definitions of the debugging group and level bits
// for the code in cmd.c
//

#define MNGRP   0x0001                  // Main command loop code group
#define MNLVL   0x0001                  // Main function level
#define DFLVL   0x0002                  // Dispatch function level
#define RIOLVL  0x0004                  // Redirection function level

/* The following are definitions of the debugging group and level bits
 * for the code in cmem.c
 */

#define MMGRP   0x1000  /* Memory Manager                                  */
#define MALVL   0x0001  /* Memory allocators                               */
#define LMLVL   0x0002  /* List managers                                   */
#define SMLVL   0x0004  /* Segment manipulators                            */


/* The following are definitions of the debugging group and level bits
 * for the code in cop.c
 */

#define OPGRP	0x0008	/* Operators group	    */
#define PILVL	0x0001	/* Pipe level		    */
#define PNLVL   0x0002  /* Paren operator level     */


/* The following are definitions of the debugging group and level bits
 * for the code in cother.c
 */

#define OCGRP   0x0400  /* Other commands group     */
#define BRLVL   0x0001  /* Break command level      */
#define CLLVL   0x0002  /* Cls command level        */
#define CTLVL   0x0004  /* Ctty command level       */
#define EXLVL   0x0008  /* Exit command level       */
#define VELVL   0x0010  /* Verify command level     */


/* The following are definitions of the debugging group and level bits
 * for the code in cpath.c
 */

#define PCGRP   0x0010  /* Path commands group      */
#define MDLVL   0x0001  /* Mkdir level              */
#define CDLVL   0x0002  /* Chdir level              */
#define RDLVL   0x0004  /* Rmdir level              */


/* The following are definitions of the debugging group and level bits
 * for the code in csig.c
 */

#define SHGRP   0x0800  /* Signal handler group     */
#define MSLVL   0x0001  /* Main Signal handler level     */
#define ISLVL   0x0002  /* Init Signal handler level     */

/* The following are definitions of the debugging group and level bits
 * for the code in ctools1.c, ctools2.c, ctools3.c and ffirst.c
 */

#define CTGRP   0x2000  /* Common tools group           */
#define CTMLVL  0x0400  /* Common tools misc. level     */
#define BFLVL   0x0800  /* BuildFSpec() level           */
#define SFLVL   0x1000  /* ScanFSpec() level            */
#define SSLVL   0x2000  /* SetAndSaveDir() level        */
#define TSLVL   0x4000  /* TokStr() level               */
#define FPLVL   0x8000  /* FullPath level               */

#else
#define CMD_DEBUG_ENABLE 0
#define DEBUG(a)
#endif


/* File attributes */

#define FILE_ATTRIBUTE_READONLY         0x00000001
#define FILE_ATTRIBUTE_HIDDEN           0x00000002
#define FILE_ATTRIBUTE_SYSTEM           0x00000004
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020
#define FILE_ATTRIBUTE_NORMAL           0x00000080

#define IsDirectory(a)                  ((a) & FILE_ATTRIBUTE_DIRECTORY)
#define IsReparse(a)                    ((a) & FILE_ATTRIBUTE_REPARSE_POINT)
//#define A_AEV   0x37
#define A_ALL                           (FILE_ATTRIBUTE_READONLY |  \
                                         FILE_ATTRIBUTE_HIDDEN |    \
                                         FILE_ATTRIBUTE_SYSTEM |    \
                                         FILE_ATTRIBUTE_DIRECTORY | \
                                         FILE_ATTRIBUTE_ARCHIVE )

//#define A_AEDV  0x27      /* all attributes except dir & vol   */
#define A_AEDV                          (A_ALL & ~FILE_ATTRIBUTE_DIRECTORY)

//#define A_AEDVH 0x25      /* all except dir/vol/hidden (M040)  */
#define A_AEDVH                         (FILE_ATTRIBUTE_READONLY |  \
                                         FILE_ATTRIBUTE_SYSTEM |    \
                                         FILE_ATTRIBUTE_ARCHIVE )


//#define A_AEVH  0x35      /* all except vol/hidden             */
#define A_AEVH                          (A_ALL & ~FILE_ATTRIBUTE_HIDDEN)

/*  Batdata is the structure which contains all of the information needed to
 *  start/continue executing a batch job.  The fields are:
 *  filespec - full file specification of the batch file
 *  dircpy - ptr to copy of current drive and directory (used by the
 *      setlocal/endlocal commands.
 *  filepos - the current position in the file
 *  stackmin - M037 - the number of elements on the data stack comprising
 *      only the batch data structure itself.  Used when chaining to free
 *      memory prior to reconstructing the data structure.
 *  stacksize - the number of elements on the data stack before the
 *      execution of the batch job begins.  This number is past to
 *      FreeStack() via Parser() to make sure that only that data which
 *      is used to execute batch file statements is freed.
 *  hRestrictedToken - Handle to the restricted token with which the batch file
 *      should be run.
 *  envcpy - ptr to structure containing info on environment copy
 *  orgargs - pointer to original argument string
 *  args - tokenized string containing the the unused batch job arguments
 *  aptrs - pointers into args to individual arguments, NULL if no arg for
 *      that number
 *  alens - the lengths of individual args, 0 if no arg
 *  backptr - the structures are stacked using this pointer.  Through it,
 *      nestable batch jobs are achieved.
 */

#define CMD_MAX_SAVED_ENV 32

struct batsaveddata {
    TCHAR *dircpy ;
    struct envdata * envcpy;
    BOOLEAN fEnableExtensions;
    BOOLEAN fDelayedExpansion;
} ;

struct batdata {
        TCHAR *filespec ;
        long filepos ;
        int stackmin ;
        int stacksize ;
        int SavedEnvironmentCount;
        HANDLE hRestrictedToken;
        TCHAR *orgargs ;
        TCHAR *args ;
        TCHAR *aptrs[10] ;
        int alens[10] ;
        TCHAR *orgaptr0 ;
        struct batsaveddata *saveddata[CMD_MAX_SAVED_ENV] ;
        struct batdata *backptr ;
} ;

//
//  The following variables are used to detect the current batch state
//

//
//  Set for /K on command line
//

extern BOOL SingleBatchInvocation;          //  fSingleBatchLine

//
//  Set of /c switch on command line set.
//

extern BOOL SingleCommandInvocation;        //  fSingleCmdLine

//
// Data for start and executing a batch file. Used in calls
//


extern struct batdata *CurrentBatchFile;    //  CurBat

//
//  Set during the execution of a GOTO command.  All sequential dispatch
//  routines muse examine this and return success when set in order
//  to let the top-level batch file execution continue at the next
//  point
//

extern BOOLEAN GotoFlag;

/*  M022 - This structure has been changed.  It is still used in a linked
 *  list, but now stores no actual redirection information.  Instead the
 *  node pointer is used to access this data which is in another linked
 *  list of relem structures whose head element is pointed to by n->rio in
 *  the node.  The riodata list is reverse linked and its tail element is
 *  still pointed to by CurRIO (global).
 */

struct rio {
        int type ;                  /* Type of redir'ing process       */
        CRTHANDLE stdio ;           /* Highest handle for this node    */
        struct node *rnod ;         /* Associated parse node ptr       */
        struct rio *back ;          /* Pointer to prior list element   */
} ;

// relem is used in a linked list, the head element of which is pointed to by
// n->rio in a 'node' or 'cmdnode'. It contains the following parse information;
// the handle to be redirected, a pointer to the filename (or "&n" for handle
// substitution), the handle where the original is saved (by duping it), the
// operator, ('>' or '<'), specifying the redirection type, a flag to indicate
// whether this is to be appended and a pointer to the next list element.

struct relem {
        CRTHANDLE rdhndl ;      // handle to be redirected
        TCHAR *fname ;          // filename (or &n)
        CRTHANDLE svhndl ;      // where orig handle is saved
        int flag ;              // Append flag
        TCHAR rdop ;            // Type ('>' | '<')
        struct relem *nxt ;     // Next structure
};

/* Used to hold information on Copy sources and destinations.               */

struct cpyinfo {
        TCHAR *fspec ;                   /* Source/destination filespec      */
        TCHAR *curfspec ;                /* Current filespec being used      */
        TCHAR *pathend ;                 /* Ptr to end of pathname in fspec  */
        TCHAR *fnptr ;                   /* Ptr to filename in fspec         */
        TCHAR *extptr ;                  /* Ptr to file extension in fspec   */
        PWIN32_FIND_DATA buf ;               /* Buffer used for findfirst/next   */
        int flags ;                     /* Wildcards, device, etc           */
        struct cpyinfo *next ;          /* Next ptr, used with sources only */
} ;


/* Following is true if user specifically enable the potentially incompatible */
/* extensions to CMD.EXE.                                                     */

extern BOOLEAN fEnableExtensions;
extern BOOLEAN fDelayedExpansion;

//
//  Suppress/allow delay load errors
//

extern BOOLEAN ReportDelayLoadErrors;

/* Message Retriever definitions */

#define NOARGS          0
#define ONEARG          1
#define TWOARGS         2
#define THREEARGS       3

/* length of double byte character set (DBCS) buffer */
#define DBCS_BUF_LEN 10

/* DBCS_SPACE is the code for the second byte of a dbcs space character
 * DBCS_SPACE is not a space unless it immediatly follows a bdcs lead
 * character */
/* I don't know what value the double byte space is, so I made a guess.
 * I know this guess is wrong, but, you've gotta suffer if you're going
 * to sing the blues!
 * (Correct the value for BDCS_SPACE and everything should work fine)
 */
#define DBCS_SPACE 64 /* @@ */
#define LEAD_DBCS_SPACE 129 /* @@ */

/*
 * is_dbcsleadchar(c) returns TRUE if c is a valid first character of a double
 * character code, FALSE otherwise.
 *
 */

extern BOOLEAN DbcsLeadCharTable[ ];

//
// AnyDbcsLeadChars can be tested to determine if there are any TRUE values
// in DbcsLeadCharTable i.e. do we have to do any look-ups.
//

extern BOOLEAN AnyDbcsLeadChars;

#define     is_dbcsleadchar( c )  DbcsLeadCharTable[((UCHAR)(c))]

//
//  Line terminator
//

extern TCHAR CrLf[] ;

//
// The following macros are copies of the C Runtime versions that test
// for NULL string pointer arguments and return NULL instead of generating
// an access violation dereferencing a null pointer.
//

#define mystrlen( str )                     \
    ( (str) ? _tcslen( str ) : ( 0 ))

#define mystrcpy( s1, s2 )                  \
    ( ((s1) && (s2)) ? _tcscpy( s1, s2 ) : ( NULL ))

#define mystrcat( s1, s2 )                  \
    ( ((s1) && (s2)) ? _tcscat( s1, s2 ) : ( NULL ))

extern TCHAR DbcsFlags[];


#define W_ON      1     /* Whinthorn.DLL exists */
#define W_OFF     0     /* Whinthorn.DLL exists */

#define FIFO      0     /* FIFO Queue           */

#define FULLSCRN  0     /* Full Screen Mode     */
#define VIOWIN    1     /* VIO Windowable Mode  */
#define DETACHED  2     /* Detached Mode */

#define NONEPGM         0       /* Program is not started                */
#define EXECPGM         1       /* Program is started by DosExecPgm      */
#define STARTSESSION    2       /* Program is started by DosStartSession */

#define WAIT            0       /* WAIT for DosReadQueue                 */
#define NOWAIT          1       /* NOWAIT for DosReadQueue               */

#define READ_TERMQ      0       /* Read TermQ                            */

#define ALL_STOP        0       /* Terminate All Sessions                */
#define SPEC_STOP       1       /* Terminate Specified Session           */


// to handle OS/2 vs DOS behavior (e.g. errorlevel) in a script files

#define NO_TYPE         0
#define BAT_TYPE        1
#define CMD_TYPE        2

#include "cmdproto.h"
#include "console.h"
#include "dir.h"
#include <vdmapi.h>
#include <conapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\complete.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    complete.c

Abstract:

    File/path name completion support

--*/

#include "cmd.h"

//
//  Upon the first completion, pCompleteBuffer is a pointer to an array
//  of matching full path names
//

TCHAR  	**pCompleteBuffer;

//
//  The count of strings stored in pCompleteBuffer
//

int     nBufSize;

//
//  The index in pCompleteBuffer of the current match displayed
//

int     nCurrentSpec;


//
//  There are two types of completion matching, path and directory. This is the current
//  matching being done.
//

int     bCurrentSpecType;

//
//  When called for completion, the location of the beginning of the path is found
//  and stored in nCurrentSpecPathStart.  This is relative to the buffer passed
//  in to DoComplete
//

int     nCurrentSpecPathStart;

int     CompleteDir( TCHAR *pFileSpecBuffer, int, int );

//
//  Characters that CMD uses for its own grammar.  To use these in filenames
//  requires quoting
//

TCHAR   szSpecialFileCharsToQuote[] = TEXT(" &()[]{}^=;!%'+,`~");

void
DoCompleteInitialize( VOID )
{
    pCompleteBuffer = NULL;
    nBufSize = 0;
    bCurrentSpecType = 0;
    nCurrentSpecPathStart = 0;
    nCurrentSpec = 0;
    return;
}



int
DoComplete(
    TCHAR *buffer,
    int len,
    int maxlen,
    int bForward,
    int bPathCompletion,
    int bTouched)
/*++

Routine Description:

    This is used whenever a path completion character is seen on input.  It updates the 
    input buffer with the next matching text and returns the updated size.

Arguments:

    buffer - input string that contains the prefix of the path to match at the end. 
    
    len - length of the input string.
    
    maxlen - maximum string length that can be stored in buffer.
    
    bForward - TRUE => matching goes forward through the storted match list.  Otherwise
        move backwards through the list.
        
    bPathCompletion - TRUE => we match ONLY directories and not files+directories.
    
    bTouched - TRUE => the user has edited the path.  This usually means that we need to
        begin the matching process anew.

Return Value:

    Zero if no matching entries were found, otherwise the length of the updated buffer.

--*/
{
    TCHAR  	pFileSpecBuffer[512];
    int nBufPos;
    int nPathStart;
    int nFileStart;
    int k;
    BOOL bWildSeen;

    //
    //  If the user edited the previous match or if the form of completion (dir vs 
    //  dir/file) changed, then we must rebuild the matching information
    //
    
    if ( bTouched || (bCurrentSpecType != bPathCompletion)) {

        BOOL InQuotes = FALSE;

        //
        //  The following code was shipped in NT 4 and Windows 2000.  It presented
        //  a usability problem when changing matching forms in mid-stream.  We will
        //  now treat a simple change of completion type the same as being touched
        //  by the user: rebuild the matching database from where we are presently.
        //
        
        //  //
        //  //  if the buffer was left alone but the matching style
        //  //  was changed, then start the matching process at the
        //  //  beginning of the path
        //  //
        //  
        //  if (!bTouched && (bCurrentSpecType != bPathCompletion)) {
        //      buffer[nCurrentSpecPathStart] = NULLC;
        //      len = nCurrentSpecPathStart;
        //  }

        //
        //  Determine the beginning of the path and file name.  We
        //  need to take into account the presence of quotes and the
        //  need for CMD to introduce quoting as well
        //

        nPathStart = 0;
        nFileStart = -1;
        bWildSeen = FALSE;
        for ( k = 0; k < len; k++ ) {
            if (buffer[k] == SWITCHAR) {
                nPathStart = k + 1;
                bWildSeen = FALSE;
                
            } else if ( buffer[k] == QUOTE ) {
                if ( !InQuotes )
                    nPathStart = k;

                InQuotes = !InQuotes;
            } else if ( !InQuotes &&
                     _tcschr(szSpecialFileCharsToQuote, buffer[k]) != NULL
                   ) {
                nPathStart = k+1;
                bWildSeen = FALSE;
            } else if (buffer[k] == COLON ||
                    buffer[k] == BSLASH
                   ) {
                nFileStart = k+1;
                bWildSeen = FALSE;
            } else if (buffer[k] == STAR || buffer[k] == QMARK) {
                bWildSeen = TRUE;
            }
        }

        if (nFileStart == -1 || nFileStart < nPathStart)
            nFileStart = nPathStart;

        _tcsncpy( pFileSpecBuffer, &(buffer[nPathStart]), len-nPathStart );
        if (!bWildSeen) {
            pFileSpecBuffer[len-nPathStart+0] = TEXT('*');
            pFileSpecBuffer[len-nPathStart+1] = TEXT('\0');
        } else {
            pFileSpecBuffer[len-nPathStart+0] = TEXT('\0');
        }

        // do the DIR into a buffer
        nBufSize = CompleteDir( pFileSpecBuffer, bPathCompletion, nFileStart - nPathStart );

        // reset the current completion string
        nCurrentSpec = nBufSize;
        nCurrentSpecPathStart = nPathStart;
        bCurrentSpecType = bPathCompletion;
    }

    // if no matches, do nothing.
    if ( nBufSize == 0 ) {
        return 0;
    }

    // find our postion in the completion buffer.
    if ( bForward ) {
        nCurrentSpec++;
        if ( nCurrentSpec >= nBufSize )
            nCurrentSpec = 0;
    } else {
        nCurrentSpec--;
        if ( nCurrentSpec < 0 )
            nCurrentSpec = nBufSize - 1;

    }

    // Return nothing if buffer not big enough
    if ((int)(nCurrentSpecPathStart+_tcslen(pCompleteBuffer[nCurrentSpec])) >= maxlen)
        return 0;

    // copy the completion path onto the end of the command line
    _tcscpy(&buffer[nCurrentSpecPathStart], pCompleteBuffer[nCurrentSpec] );
    return nBufSize;
}


int
CompleteDir(
    TCHAR *pFileSpecBuffer,
    int bPathCompletion,
    int nFileStart
    )
{
    PFS pfsCur;
    PSCREEN pscr;
    DRP         drpCur = {0, 0, 0, 0, 
                          {{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}}, 
                          0, 0, NULL, 0, 0, 0, 0} ;
    int hits = 0;
    int i, j, nFileLen;
    unsigned Err;
    TCHAR *s, *d, *pszFileStart;
    BOOLEAN bNeedQuotes;
    ULONG rgfAttribs, rgfAttribsOnOff;

    if (pCompleteBuffer != NULL) {
        // free the old buffer
        for( i=0; i<nBufSize; i++ ){
            free( pCompleteBuffer[i] );
        }
        free( pCompleteBuffer );
        pCompleteBuffer = NULL;
    }

    // fake up a screen to print into
    pscr = (PSCREEN)gmkstr(sizeof(SCREEN));
    pscr->ccol = 2048;

    rgfAttribs = 0;
    rgfAttribsOnOff = 0;
    if (bPathCompletion) {
        rgfAttribs = FILE_ATTRIBUTE_DIRECTORY;
        rgfAttribsOnOff = FILE_ATTRIBUTE_DIRECTORY;
    }

    ParseDirParms(pFileSpecBuffer, &drpCur);
    if ( (drpCur.patdscFirst.pszPattern == NULL) ||
         (SetFsSetSaveDir(drpCur.patdscFirst.pszPattern) == (PCPYINFO) FAILURE) ||
         (BuildFSFromPatterns(&drpCur, FALSE, TRUE, &pfsCur) == FAILURE) ) {
        RestoreSavedDirectory( );
        return( 0 );
    }

    Err = 
        ExpandAndApplyToFS( pfsCur, 
                            pscr,
                            rgfAttribs,
                            rgfAttribsOnOff,
                            
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL );

    if (Err) {
        RestoreSavedDirectory( );
        return 0;
    }
    
    //
    // Make sure there is something to sort, then sort
    //
    if (pfsCur->cff) {
        qsort( pfsCur->prgpff,
               pfsCur->cff,
               sizeof(PTCHAR),
               CmpName
             );
    }

    s = pFileSpecBuffer;
    d = s;
    bNeedQuotes = FALSE;
    while (*s) {
        if (*s == QUOTE) {
            bNeedQuotes = TRUE;
            s += 1;
            if (nFileStart >= (s-pFileSpecBuffer))
                nFileStart -= 1;
            if (*s == QUOTE)
                *d++ = *s++;
        }
        else {
            if (_tcschr(szSpecialFileCharsToQuote, *s) != NULL)
                bNeedQuotes = TRUE;

            *d++ = *s++;
        }
    }
    *d = NULLC;

    hits = pfsCur->cff;
    pCompleteBuffer = calloc( sizeof(TCHAR *), hits );
    if (pCompleteBuffer == NULL) {
        RestoreSavedDirectory( );
        return 0;
    }

    for(i=0, j=0; i<hits; i++) {
        if (!_tcscmp((TCHAR *)(pfsCur->prgpff[i]->data.cFileName), TEXT(".") )
            || !_tcscmp((TCHAR *)(pfsCur->prgpff[i]->data.cFileName), TEXT("..") )) {
            continue;
        }
        nFileLen = _tcslen( (TCHAR *)(pfsCur->prgpff[i]->data.cFileName) );
        pCompleteBuffer[j] = (TCHAR *)calloc( (nFileStart + nFileLen + 4) , sizeof( TCHAR ));

        if (pCompleteBuffer[j] == NULL) {
            continue;
        }
        
        if (!bNeedQuotes) {
            s = (TCHAR *)(pfsCur->prgpff[i]->data.cFileName);
            while (*s) {
                if (_tcschr(szSpecialFileCharsToQuote, *s) != NULL)
                    bNeedQuotes = TRUE;
                s += 1;
            }
        }
        else
            s = NULL;

        d = pCompleteBuffer[j];
        if (bNeedQuotes)
            *d++ = QUOTE;
        _tcsncpy( d, pFileSpecBuffer, nFileStart );
        d += nFileStart;
        _tcsncpy( d, (TCHAR *)(pfsCur->prgpff[i]->data.cFileName), nFileLen );
        d += nFileLen;

        if (bNeedQuotes) {
            *d++ = QUOTE;
            if (s)
                bNeedQuotes = FALSE;
        }
        *d++ = NULLC;

        j++;
    }
    
    hits = j;

    FreeStr((PTCHAR)(pfsCur->pff));
    FreeStr(pfsCur->pszDir);
    FreeStr((PTCHAR)pfsCur);

    RestoreSavedDirectory( );

    return hits;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\console.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    console.c

Abstract:

    Support for video output and input

--*/

#include "cmd.h"

//
// Externals for message buffer translation
//

extern unsigned msglen;
extern CPINFO CurrentCPInfo;
#ifdef FE_SB
extern  UINT CurrentCP;
#endif /* FE_SB */

VOID  SetColRow( PSCREEN );
ULONG GetNumRows( PSCREEN, PTCHAR );

TCHAR   chLF = NLN;

VOID
DisableProcessedOutput(
    IN PSCREEN pscr
    )
{
    if (pscr->hndScreen)
        SetConsoleMode(pscr->hndScreen, ENABLE_WRAP_AT_EOL_OUTPUT);
}

VOID
EnableProcessedOutput(
    IN PSCREEN pscr
    )
{
    ResetConsoleMode();
}

STATUS
OpenScreen(

    OUT PSCREEN    *pscreen

)

/*++

Routine Description:

    Allocates and initializes a data structure for screen I/O buffering.

Arguments:

    crow - max rows on screen
    ccol - max column on screen
    ccolTab - spaces to insert for each tab call. This does not
              expand tabs in the character stream but is used with the
              WriteTab call.

    cbMaxBuff - Max. size of a line on screen


Return Value:

    pscreen - pointer to screen buffer, used in later calls.

    Return: SUCCESS - allocated and inited buffer.
        If failure to allocate an abort is executed and return to outer
        level of interpreter is executed.

--*/


{

    PSCREEN pscr;
    CONSOLE_SCREEN_BUFFER_INFO ConInfo;
    ULONG cbMaxBuff;

    pscr = (PSCREEN)gmkstr(sizeof(SCREEN));
    pscr->hndScreen = NULL;
    if (FileIsDevice(STDOUT)) {

        pscr->hndScreen = CRTTONT(STDOUT);

        if (!GetConsoleScreenBufferInfo(pscr->hndScreen,&ConInfo)) {

            // must be a device but not console (maybe NUL)

            pscr->hndScreen = NULL;

        }

    }

    if (GetConsoleScreenBufferInfo( pscr->hndScreen, &ConInfo)) {
        cbMaxBuff = (ConInfo.dwSize.X + _tcslen(CrLf)) < MAXCBMSGBUFFER ? MAXCBMSGBUFFER : (ConInfo.dwSize.X + _tcslen(CrLf));
    } else {
        cbMaxBuff = MAXCBMSGBUFFER + _tcslen(CrLf);
    }

    //
    // allocate enough to hold a buffer plus line termination.
    //
    pscr->pbBuffer = (PTCHAR)gmkstr(cbMaxBuff*sizeof(TCHAR));
    pscr->cbMaxBuffer = cbMaxBuff;
    pscr->ccolTab    = 0;
    pscr->crow = pscr->ccol = 0;
    pscr->crowPause  = 0;

    SetColRow(pscr);

    *pscreen = pscr;

    return( SUCCESS );

}

STATUS
WriteString(
    IN  PSCREEN pscr,
    IN  PTCHAR  pszString
    )
/*++

Routine Description:

    Write a zero terminated string to pscr buffer

Arguments:

    pscr - buffer into which to write.
    pszString - String to copy

Return Value:

    Return: SUCCESS - enough spaced existed in buffer for line.
            FAILURE

--*/

{

    return( WriteFmtString(pscr, TEXT("%s"), (PVOID)pszString ) );

}



STATUS
WriteMsgString(
    IN  PSCREEN pscr,
    IN  ULONG   MsgNum,
    IN  ULONG   NumOfArgs,
    ...
    )
/*++

Routine Description:

    Retrieve a message number and format with supplied arguments.

Arguments:

    pscr - buffer into which to write.
    MsgNum - message number to retrieve
    NumOfArgs - no. of arguments suppling data.
    ... - pointers to zero terminated strings as data.

Return Value:

    Return: SUCCESS
            FAILURE - could not find any message including msg not found
            message.

--*/


{

    PTCHAR   pszMsg = NULL;
    ULONG   cbMsg;
    CHAR    numbuf[ 32 ];
#ifdef UNICODE
    TCHAR   wnumbuf[ 32 ];
#endif
    PTCHAR  Inserts[ 2 ];
    STATUS  rc;


    va_list arglist;
    va_start(arglist, NumOfArgs);

    cbMsg = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE 
                          | FORMAT_MESSAGE_FROM_SYSTEM
                          | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                          NULL,                                 //  lpSource
                          MsgNum,                               //  dwMessageId
                          0,                                    //  dwLanguageId
                          (LPTSTR)&pszMsg,                      //  lpBuffer
                          10,                                   //  nSize
                          &arglist                              //  Arguments
                         );

    va_end(arglist);

    if (cbMsg == 0) {
        _ultoa( MsgNum, numbuf, 16 );
#ifdef UNICODE
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, numbuf, -1, wnumbuf, 32);
        Inserts[ 0 ]= wnumbuf;
#else
        Inserts[ 0 ]= numbuf;
#endif
        Inserts[ 1 ]= (MsgNum >= MSG_FIRST_CMD_MSG_ID ? TEXT("Application") : TEXT("System"));
        cbMsg = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM 
                              | FORMAT_MESSAGE_ARGUMENT_ARRAY
                              | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                              NULL,
                              ERROR_MR_MID_NOT_FOUND,
                              0,
                              (LPTSTR)&pszMsg,
                              10,
                              (va_list *)Inserts
                             );
    }


    if (cbMsg) {

        rc = WriteString(pscr, pszMsg);
        //
        // Flush out buffer if there is an  eol. If not then we
        // are printing part of a larger message
        //
        if (GetNumRows(pscr, pscr->pbBuffer) ) {
            WriteFlush(pscr);
        }
        
        LocalFree( pszMsg );
        
        return( SUCCESS );

    } else {
        return( FAILURE );
    }

}

STATUS
WriteFmtString(
    IN  PSCREEN pscr,
    IN  PTCHAR  pszFmt,
    IN  PVOID   pszString
    )

/*++

Routine Description:

    Write a zero terminated string to pscr

Note:

    Do not use Msgs with this call. Use only internal Fmt strings
    Use WriteMsgString for all system messages. It does not check for
    CrLf at end of string to keep row count but WriteMsgString does

Arguments:

    pscr - buffer into which to write.
    pszFmt - format to apply.
    pszString - String to copy

Return Value:

    Return: SUCCESS
            FAILURE

--*/

{

    ULONG   cbString;
    TCHAR   szString[MAXCBLINEBUFFER];

    //
    // Assume that the format overhead is small so this is a fair estimate
    // of the target size.
    //

    cbString = _sntprintf(szString, MAXCBLINEBUFFER, pszFmt, pszString);

    //
    // If string can not fit on line then flush out the buffer and reset
    // to beginning of line.
    //

    //
    // Check that string can fit in buffer
    //
    if ((pscr->ccol + cbString) < pscr->cbMaxBuffer) {

        mystrcat(pscr->pbBuffer, szString);
        pscr->ccol += cbString;
        return( SUCCESS );

    } else {

        //
        // String will not fit
        //

        return( FAILURE );
    }



}


STATUS
WriteEol(
    IN  PSCREEN  pscr
    )

/*++

Routine Description:

    Flush current buffer to screen and write a <cr>

Arguments:

    pscr - buffer to write to console.

Return Value:

    Return: SUCCESS
            FAILURE

--*/

{
    BOOL    CrLfWritten=FALSE;
    ULONG   cbWritten;

    //
    // Check if have to wait for user to hit a key before printing rest of
    // line.
    CheckPause( pscr );

    if ((pscr->ccol + mystrlen(CrLf)) >= pscr->cbMaxBuffer) {
        pscr->ccol += _stprintf(pscr->pbBuffer + pscr->ccol, TEXT("%s"), CrLf);
        CrLfWritten=TRUE;
    }

    //
    // If we do not write all that we wanted then there must have been some error
    //
    if (FileIsConsole(STDOUT)) {
        ULONG cbWritten;
        PTCHAR s, s1, LastChar;
        BOOL b;

        s = pscr->pbBuffer;

        LastChar = s + pscr->ccol;

        //
        //  s is the next character to output
        //  n is the number of chars to output.
        //
        //  Due to the vagaries of console character translation, we must output
        //  all but a small set of UNICODE characters in the "normal" processed
        //  output fashion.  However, for:
        //
        //      0x2022
        //
        //  we must revert to unprocessed output.  So, we scan forward until we
        //  find the end of string (or the special characters) display them in
        //  processed form and then handle the special characters in their own way.
        //

#define IsSpecialChar(c)    ((c) == 0x2022)

        while (s < LastChar) {

            //
            //  Skip across a group of contiguous normal chars
            //

            s1 = s;
            while (s1 < LastChar && !IsSpecialChar( *s1 )) {
                s1++;
            }

            //
            //  If we have any chars to output then do so with normal processing
            //

            if (s1 != s) {
                b = WriteConsole( CRTTONT( STDOUT ), s, (ULONG)(s1 - s), &cbWritten, NULL );
                if (!b || cbWritten != (ULONG)(s1 - s)) {
                    goto err_out_eol;
                }

                s = s1;
            }


            //
            //  Skip across a group of contiguous special chars
            //

            while (s1 < LastChar && IsSpecialChar( *s1 )) {
                s1++;
            }

            //
            //  If we have any special chars, output without processing
            //

            if (s1 != s) {
                DisableProcessedOutput( pscr );
                b = WriteConsole( CRTTONT( STDOUT ), s, (ULONG)(s1 - s), &cbWritten, NULL);
                EnableProcessedOutput(pscr);

                if (!b || cbWritten != (ULONG)(s1 - s)) {
                    goto err_out_eol;
                }

                s = s1;
            }
        }
#undef IsSpecialChar
    }
    else if (MyWriteFile(STDOUT,
                pscr->pbBuffer, pscr->ccol*sizeof(TCHAR),
                        (LPDWORD)&cbWritten) == 0 ||
                cbWritten != pscr->ccol*sizeof(TCHAR)) {

err_out_eol:
        if (FileIsDevice(STDOUT)) {

                //
                // If writing to a device then it must have been write fault
                // against the device.
                //
#if DBG
                fprintf(stderr, "WriteFlush - WriteConsole error %d, tried to write %d, did %d\n", GetLastError(), pscr->ccol, cbWritten);
#endif
                PutStdErr(ERROR_WRITE_FAULT, NOARGS) ;

        } else if (!FileIsPipe(STDOUT)) {

                //
                // If not a device (file) but not a pipe then the disk is
                // considered full.
                //
#if DBG
                fprintf(stderr, "WriteFlush - WriteFile error %d, tried to write %d, did %d\n", GetLastError(), pscr->ccol*sizeof(TCHAR), cbWritten);
#endif
                PutStdErr(ERROR_DISK_FULL, NOARGS) ;
        }

        //
        // if it was was a pipe do not continue to print out to pipe since it
        // has probably gone away. This is pretty serious so blow us out
        // to the outer loop.

        //
        // We do not print an error message since this could be normal
        // termination of the other end of the pipe. If it was command that
        // blew away we would have had an error message already
        //
        Abort();
    }
    if (!CrLfWritten) {
        if (FileIsConsole(STDOUT))
            WriteConsole(CRTTONT(STDOUT), CrLf, mystrlen(CrLf), &cbWritten, NULL);
        else
            MyWriteFile(STDOUT, CrLf, mystrlen(CrLf)*sizeof(TCHAR),
                        (LPDWORD)&cbWritten);
    }

    //
    // remember that crow is the number of rows printed
    // since the last screen full. Not the current row position
    //
    //
    // Computed the number of lines printed.
    //
    pscr->crow += GetNumRows( pscr, pscr->pbBuffer );
    if (!CrLfWritten) {
        pscr->crow += 1;
    }

    //
    // Check if have to wait for user to hit a key before printing rest of
    // line.

    CheckPause( pscr );

    if (pscr->crow > pscr->crowMax) {
        pscr->crow = 0;
    }
    pscr->pbBuffer[0] = 0;
    pscr->ccol = 0;

    DEBUG((ICGRP, CONLVL, "Console: end row = %d\n", pscr->crow)) ;

    return(SUCCESS);

}

VOID
CheckPause(
    IN  PSCREEN pscr
    )
/*++

Routine Description:

    Pause. Execution of screen is full, waiting for the user to type a key.

Arguments:

    pscr - buffer holding row information

Return Value:

    none

--*/


{
    DEBUG((ICGRP, CONLVL, "CheckPause: Pause Count %d, Row Count %d",
                pscr->crowPause, pscr->crow)) ;

    if (pscr->crowPause) {
        if (pscr->crow >= pscr->crowPause) {
            ePause((struct cmdnode *)0);
            pscr->crow = 0;
            SetColRow( pscr );
            SetPause(pscr, pscr->crowMax - 1);
        }
    }

}


VOID
SetTab(
    IN  PSCREEN  pscr,
    IN  ULONG    ccol
    )

/*++

Routine Description:

    Set the current tab spacing.

Arguments:

    pscr - screen info.
    ccol - tab spacing

Return Value:

    none

--*/

{

    pscr->ccolTabMax = pscr->ccolMax;

    if (ccol) {

        //
        // divide the screen up into tab fields, then do
        // not allow tabbing into past last field. This
        // insures that all name of ccol size can fit on
        // screen
        //
        pscr->ccolTabMax = (pscr->ccolMax / ccol) * ccol;
    }
    pscr->ccolTab = ccol;

}

STATUS
WriteTab(
    IN  PSCREEN  pscr
    )

/*++

Routine Description:

    Fills the buffer with spaces up to the next tab position

Arguments:

    pscr - screen info.
    ccol - tab spacing

Return Value:

    none

--*/

{

    ULONG ccolBlanks;
#ifdef FE_SB
    ULONG ccolActual;
#endif /* not Japan */

    //
    // Check that we have a non-zero tab spacing.
    //
    if ( pscr->ccolTab ) {

        //
        // Compute the number of spaces we will have to write.
        //
#ifdef FE_SB
        if (IsDBCSCodePage())
            ccolActual = SizeOfHalfWidthString(pscr->pbBuffer);
        else
            ccolActual = pscr->ccol;
        ccolBlanks = pscr->ccolTab - (ccolActual % pscr->ccolTab);
#else
        ccolBlanks = pscr->ccolTab - (pscr->ccol % pscr->ccolTab);
#endif
        //
        // check if the tab will fit on the screen
        //
#ifdef FE_SB
        if ((ccolBlanks + ccolActual) < pscr->ccolTabMax) {
#else
        if ((ccolBlanks + pscr->ccol) < pscr->ccolTabMax) {
#endif

            mytcsnset(pscr->pbBuffer + pscr->ccol, SPACE, ccolBlanks);
            pscr->ccol += ccolBlanks;
            pscr->pbBuffer[pscr->ccol] = NULLC;
            return( SUCCESS );

        } else {

            //
            // It could not so outpt <cr> and move to
            // next line
            //
            return(WriteEol(pscr));
        }
    }
    return( SUCCESS );

}

VOID
FillToCol (
    IN  PSCREEN pscr,
    IN  ULONG   ccol
    )
/*++

Routine Description:

    Fills the buffer with spaces up ccol

Arguments:

    pscr - screen info.
    ccol - column to fill to.

Return Value:

    none

--*/

{
#ifdef FE_SB
    ULONG ccolActual;
    ULONG cb;
    BOOL  fDBCS;

    if ( fDBCS = IsDBCSCodePage())
        ccolActual = SizeOfHalfWidthString(pscr->pbBuffer);
    else
        ccolActual = pscr->ccol;
#endif

#ifdef FE_SB
    cb = _tcslen(pscr->pbBuffer);
    if (ccolActual >= ccol) {
        if (fDBCS)
            ccol = cb - (ccolActual - ccol);
#else
    if (pscr->ccol >= ccol) {
#endif

        //
        // If we are there or past it then truncate current line
        // and return.
        //
        pscr->pbBuffer[ccol] = NULLC;
        pscr->ccol = ccol;
        return;

    }

    //
    // Only fill to column width of buffer
    //
#ifdef FE_SB
    mytcsnset(pscr->pbBuffer + cb, SPACE, ccol - ccolActual);
    if (fDBCS)
        ccol = cb + ccol - ccolActual;
#else
    mytcsnset(pscr->pbBuffer + pscr->ccol, SPACE, ccol - pscr->ccol);
#endif
    pscr->ccol = ccol;
    pscr->pbBuffer[ccol] = NULLC;

}

STATUS
WriteFlush(
    IN  PSCREEN pscr
    )

/*++

Routine Description:

    Write what ever is currently on the buffer to the screen. No EOF is
    printed.

Arguments:

    pscr - screen info.

Return Value:

    Will abort on write error.
    SUCCESS

--*/

{
    DWORD cb;

    //
    // If there is something in the buffer flush it out
    //
    if (pscr->ccol) {

        if (FileIsConsole(STDOUT)) {
        ULONG cbWritten;
        PTCHAR s, s1, LastChar;
        BOOL b;

        s = pscr->pbBuffer;

        LastChar = s + pscr->ccol;

        //
        //  s is the next character to output
        //  n is the number of chars to output.
        //
        //  Due to the vagaries of console character translation, we must output
        //  all but a small set of UNICODE characters in the "normal" processed
        //  output fashion.  However, for:
        //
        //      0x2022
        //
        //  we must revert to unprocessed output.  So, we scan forward until we
        //  find the end of string (or the special characters) display them in
        //  processed form and then handle the special characters in their own way.
        //

#define IsSpecialChar(c)    ((c) == 0x2022)

        while (s < LastChar) {

            //
            //  Skip across a group of contiguous normal chars
            //

            s1 = s;
            while (s1 < LastChar && !IsSpecialChar( *s1 )) {
                s1++;
            }

            //
            //  If we have any chars to output then do so with normal processing
            //

            if (s1 != s) {
                b = WriteConsole( CRTTONT( STDOUT ), s, (ULONG)(s1 - s), &cbWritten, NULL );
                if (!b || cbWritten != (ULONG)(s1 - s)) {
                    goto err_out_flush;
                }

                s = s1;
            }


            //
            //  Skip across a group of contiguous special chars
            //

            while (s1 < LastChar && IsSpecialChar( *s1 )) {
                s1++;
            }

            //
            //  If we have any special chars, output without processing
            //

            if (s1 != s) {
                DisableProcessedOutput( pscr );
                b = WriteConsole( CRTTONT( STDOUT ), s, (ULONG)(s1 - s), &cbWritten, NULL);
                EnableProcessedOutput(pscr);

                if (!b || cbWritten != (ULONG)(s1 - s)) {
                    goto err_out_flush;
                }

                s = s1;
            }
        }
#undef IsSpecialChar
        }
        else if (MyWriteFile(STDOUT,
                    pscr->pbBuffer, pscr->ccol*sizeof(TCHAR), &cb) == 0 ||
                 cb < pscr->ccol*sizeof(TCHAR)) {

err_out_flush:
            if (FileIsDevice(STDOUT)) {
                    PutStdErr(ERROR_WRITE_FAULT, NOARGS) ;
            } else if (!FileIsPipe(STDOUT)) {
                    PutStdErr(ERROR_DISK_FULL, NOARGS) ;
            }

            //
            // if it was was a pipe do not continue to print out to pipe since it
            // has probably gone away.

            Abort();
        }
    }

    pscr->crow += GetNumRows(pscr, pscr->pbBuffer);
    pscr->pbBuffer[0] = 0;
    pscr->ccol = 0;
    return(SUCCESS);

}


STATUS
WriteFlushAndEol(
    IN  PSCREEN pscr
    )
/*++

Routine Description:

    Write Flush with eof.

Arguments:

    pscr - screen info.

Return Value:

    Will abort on write error.
    SUCCESS

--*/

{

    STATUS rc = SUCCESS;

    //
    // Check if there is something on the line to print.
    //
    if (pscr->ccol) {

        rc = WriteEol(pscr);

    }
    return( rc );
}


void
SetColRow(
    IN  PSCREEN pscr
    )

{

    CONSOLE_SCREEN_BUFFER_INFO ConInfo;
    ULONG   crowMax, ccolMax;

    crowMax = 25;
    ccolMax = 80;

    if (pscr->hndScreen) {

        //
        // On open we checked if this was a valid screen handle so this
        // cannot fail for any meaning full reason. If we do fail then
        // just leave it at the default.
        //
        if (GetConsoleScreenBufferInfo( pscr->hndScreen, &ConInfo)) {

            //
            // The console size we use is the screen buffer size not the
            // windows size itself. The window is a frame upon the screen
            // buffer and we should always write to the screen buffer and
            // format based upon that information
            //
            ccolMax = ConInfo.dwSize.X;
            crowMax = ConInfo.srWindow.Bottom - ConInfo.srWindow.Top + 1;

        }

    }
    pscr->crowMax = crowMax;
    pscr->ccolMax = ccolMax;

}

ULONG
GetNumRows(
    IN  PSCREEN pscr,
    IN  PTCHAR  pbBuffer
    )

{

    PTCHAR  szLFLast, szLFCur;
    ULONG   crow, cb;

    szLFLast = pbBuffer;
    crow = 0;
    while ( szLFCur = mystrchr(szLFLast, chLF) ) {

        cb = (ULONG)(szLFCur - szLFLast);
        while ( cb > pscr->ccolMax ) {

            cb -= pscr->ccolMax;
            crow++;

        }

        crow++;
        szLFLast = szLFCur + 1;

    }

    //
    // if there were no LF's in the line then crow would be
    // 0. Count the number of lines the console will output in
    // wrapping
    //
    if (crow == 0) {

        crow = (pscr->ccol / pscr->ccolMax);

    }

    DEBUG((ICGRP, CONLVL, "Console: Num of rows counted = %d", crow)) ;

    //
    // a 0 returns means that there would not be a LF printed or
    // a wrap done.
    //
    return( crow );


}

#if defined(FE_SB)

BOOLEAN
IsDBCSCodePage()
{
    switch (CurrentCP) {
        case 932:
        case 936:
        case 949:
        case 950:
            return TRUE;
            break;
        default:
            return FALSE;
            break;
    }
}

/***************************************************************************\
* BOOL IsFullWidth(TCHAR wch)
*
* Determine if the given Unicode char is fullwidth or not.
*
* History:
* 04-08-92 ShunK       Created.
* 07-11-95 FloydR      Modified to be Japanese aware, when enabled for
*                      other DBCS languages.  Note that we could build
*                      KOREA/TAIWAN/PRC w/o this code, but we like single
*                      binary solutions.
* Oct-06-1996 KazuM    Not use RtlUnicodeToMultiByteSize and WideCharToMultiByte
*                      Because 950 only defined 13500 chars,
*                      and unicode defined almost 18000 chars.
*                      So there are almost 4000 chars can not be mapped to big5 code.
\***************************************************************************/

BOOL IsFullWidth(TCHAR wch)
{
#ifdef UNICODE
    /* Assert CP == 932/936/949/950 */
    if (CurrentCPInfo.MaxCharSize == 1)
        return FALSE;

    if (0x20 <= wch && wch <= 0x7e)
        /* ASCII */
        return FALSE;
    else if (0x3000 <= wch && wch <= 0x3036)
        /* CJK Symbols and Punctuation */
        return TRUE;
    else if (0x3041 <= wch && wch <= 0x3094)
        /* Hiragana */
        return TRUE;
    else if (0x30a1 <= wch && wch <= 0x30f6)
        /* Katakana */
        return TRUE;
    else if (0x3105 <= wch && wch <= 0x312c)
        /* Bopomofo */
        return TRUE;
    else if (0x3131 <= wch && wch <= 0x318e)
        /* Hangul Elements */
        return TRUE;
    else if (0x3200 <= wch && wch <= 0x32ff)
        /* Enclosed CJK Letters and Ideographics */
        return TRUE;
    else if (0x3300 <= wch && wch <= 0x33fe)
        /* CJK Squared Words and Abbreviations */
        return TRUE;
    else if (0xac00 <= wch && wch <= 0xd7a3)
        /* Korean Hangul Syllables */
        return TRUE;
    else if (0xe000 <= wch && wch <= 0xf8ff)
        /* EUDC */
        return TRUE;
    else if (0xff01 <= wch && wch <= 0xff5e)
        /* Fullwidth ASCII variants */
        return TRUE;
    else if (0xff61 <= wch && wch <= 0xff9f)
        /* Halfwidth Katakana variants */
        return FALSE;
    else if ( (0xffa0 <= wch && wch <= 0xffbe) ||
              (0xffc2 <= wch && wch <= 0xffc7) ||
              (0xffca <= wch && wch <= 0xffcf) ||
              (0xffd2 <= wch && wch <= 0xffd7) ||
              (0xffda <= wch && wch <= 0xffdc)   )
        /* Halfwidth Hangule variants */
        return FALSE;
    else if (0xffe0 <= wch && wch <= 0xffe6)
        /* Fullwidth symbol variants */
        return TRUE;
    else if (0x4e00 <= wch && wch <= 0x9fa5)
        /* CJK Ideographic */
        return TRUE;
    else if (0xf900 <= wch && wch <= 0xfa2d)
        /* CJK Compatibility Ideographs */
        return TRUE;
    else if (0xfe30 <= wch && wch <= 0xfe4f) {
        /* CJK Compatibility Forms */
        return TRUE;
    }

    else
        /* Unknown character */
        return FALSE;
#else
    if (IsDBCSLeadByteEx(CurrentCP, wch))
        return TRUE;
    else
        return FALSE;
#endif
}


/***************************************************************************\
* BOOL SizeOfHalfWidthString(PWCHAR pwch)
*
* Determine size of the given Unicode string, adjusting for half-width chars.
*
* History:
* 08-08-93 FloydR      Created.
\***************************************************************************/
int  SizeOfHalfWidthString(TCHAR *pwch)
{
    int         c=0;

    if (IsDBCSCodePage())
    {
        while (*pwch) {
            if (IsFullWidth(*pwch))
                c += 2;
            else
                c++;
            pwch++;
        }
        return c;
    }
    else
        return _tcslen(pwch);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\console.h ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    console.h

Abstract:

    Definitions for console support

--*/

#define MAXCBLINEBUFFER MAX_PATH + 20
#define GetCRowMax( pscr ) pscr->crowMax
#define SetPause( pscr, crow ) pscr->crowPause = crow
#define ICGRP   0x0040  // Informational commands group
#define CONLVL  0x0020  // Console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cmem.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cmem.c

Abstract:

    Memory allocation support

--*/

#include "cmd.h"

extern   DWORD DosErr ;

/* Data Stack - a stack of pointers to memory that has been allocated *M005*/

typedef struct _DSTACK {
    ULONG cb ;               /* malloc's length value (M011)            */
    struct _DSTACK *pdstkPrev; /* Pointer to the previous list element    */
    CHAR data ;             /* The data block                          */
} DSTACK, *PDSTACK;

#define PTRSIZE FIELD_OFFSET(DSTACK, data) /* Size of element header*/

PDSTACK DHead = NULL ;   /* Head of the data list           */
ULONG DCount = 0 ;       /* Number of elements in the list  */

#define MAX_NUM_BIG_BUF  2
PVOID BigBufHandle[MAX_NUM_BIG_BUF] = {0, 0};   /* Handle/segment of buffer used by type & copy */


#if DBG




/***    MemChk1 - Sanity check on one element of the data stack
 *
 *  Purpose:
 *      Verifies the integrity and length of a single data element
 *
 *  int MemChk1(PDSTACK s)
 *
 *  Args:
 *      s - Pointer to the data stack element to check on
 *
 *  Returns:
 *      0 - If element is intact and okay
 *      1 - If element size or integrity is off
 *
 */

MemChk1(
    IN  PDSTACK pdstk
    )
{
    return 0;
#if 0
        if (pdstk->cb != HeapSize(GetProcessHeap(), 0, pdstk)) {
            printf( "My Size is %x, heap says %x\n", pdstk->cb,   HeapSize(GetProcessHeap(), 0, pdstk));
            cmd_printf (TEXT("len = %d"), pdstk->cb) ;
                return(1) ;
        } else {
                return(0) ;
        } ;
#endif
}




/***    MemChkBk - Sanity check on data stack elements from here back
 *
 *  Purpose:
 *      Verifies the integrity of the CMD data stack from a single
 *      point back to the beginning.
 *
 *  int MemChkBk(PDSTACK s)
 *
 *  Args:
 *      s - Pointer to the data stack element to start with
 *
 *  Returns:
 *      0 - If elements are intact and okay
 *      1 - If elements' size or integrity are off
 *
 */

MemChkBk(
    IN  PDSTACK pdstk
    )
{
#if 0
        ULONG   cnt ;           // Element counter
        PDSTACK pdstkCur;   // Element pointer

        cnt = DCount ;

        for (pdstkCur = DHead, cnt = DCount ; pdstkCur ; pdstkCur = (PDSTACK)pdstkCur->pdstkPrev, cnt--) {
                if (pdstkCur == pdstk) {
                        break ;
                } ;
        } ;

        while (pdstkCur) {
                if (MemChk1(pdstkCur)) {
                        cmd_printf(TEXT("Memory Element %d @ %04x contaminated!"), cnt, pdstkCur) ;
                        abort() ;
                } ;
                pdstkCur = (PDSTACK)pdstkCur->pdstkPrev ;
                --cnt ;
        } ;

#endif
        return(0) ;
}




/***    MemChkAll - Sanity check on one element of the data stack
 *
 *  Purpose:
 *      Checks the entire data stack for integrity.
 *
 *  int MemChkAll()
 *
 *  Args:
 *
 *  Returns:
 *      0 - If elements are intact and okay
 *      1 - If elements' size or integrity are off
 *
 */

MemChkAll()
{
        return(MemChkBk(DHead)) ;
}

#endif


/***    FreeBigBuf - free the buffer used by the type and copy commands
 *
 *  Purpose:
 *      If BigBufHandle contains a handle, unlock it and free it.
 *
 *  FreeBigBuf()
 *
 * ***  NOTE:   This routine manipulates Command's Buffer handle, and   ***
 * ***          should be called with signal processing postponed.      ***
 */

void FreeBigBuf(
    int BigBufID
    )
{

    if (BigBufID >= MAX_NUM_BIG_BUF)
        return;

    if (BigBufHandle[BigBufID]) {
        DEBUG((MMGRP, LMLVL, "    FREEBIGBUF: Freeing bigbufhandle = 0x%04x", BigBufHandle[BigBufID])) ;

        VirtualFree(BigBufHandle[BigBufID],0,MEM_RELEASE) ;
        BigBufHandle[BigBufID] = 0 ;
    } ;
}




/***    FreeStack - free the memory on the data stack
 *
 *  Purpose:
 *      Free the memory pointed to by all but the first n elements of the
 *      data stack and free BigBufHandle if it is nonzero.
 *
 *  FreeStack(int n)
 *
 *  Args:
 *      n - the number of elements to leave on the stack
 *
 *                              W A R N I N G
 *      !!! THIS ROUTINE CAUSES AN ABORT IF DATA STACK CONTAMINATED !!!
 */

void FreeStack(
    IN ULONG n
    )
{
    PDSTACK pdstkPtr ;
    int i;

    DEBUG((MMGRP, LMLVL, "    FREESTACK: n = %d  DCount = %d", n, DCount)) ;

    while (DCount > n && (pdstkPtr = DHead)) {
        /* Free the top item in the data stack and pop the stack */

        DHead = (PDSTACK)DHead->pdstkPrev ;
        -- DCount ;
        DEBUG((MMGRP, LMLVL, "    FREESTACK: Freeing %x", pdstkPtr)) ;
        memset( pdstkPtr, 0, sizeof( *pdstkPtr ));
        HeapFree(GetProcessHeap(), 0, pdstkPtr) ;
    }

#if DBG

    MemChkAll() ;           /* CAUSES abort() IF CONTAMINATED          */

#endif
    for (i=0; i<MAX_NUM_BIG_BUF; i++) {
        FreeBigBuf(i) ;
    }

    DEBUG((MMGRP, LMLVL, "    FREESTACK: n = %d, DCount = %d", n, DCount)) ;
}

/***    FreeStr - free a memory block 
 *
 *  Purpose:
 *      Free a single memory block from the stack.
 *
 *  Args:
 *      pbFree - pointer to block being freed.
 *
 *                              W A R N I N G
 *      !!! THIS ROUTINE CAUSES AN ABORT IF DATA STACK CONTAMINATED !!!
 */

void
FreeStr(
    IN  PTCHAR   pbFree
    )
{

    PDSTACK pdstkCur;
    PDSTACK pdstkPtr, pdstkLast ;
    ULONG   cdstk;

    DEBUG(( MMGRP, LMLVL, "    FreeStr: pbFree = %x DCount = %d", pbFree, DCount )) ;

    if ((pbFree == NULL) || (DHead == NULL)) {
        return;
    }

    pdstkPtr = (PDSTACK)((CHAR*)pbFree - PTRSIZE);

    //
    //  Walk through current stack trying to find object
    //
    
    for (pdstkCur = DHead, cdstk = DCount; cdstk; cdstk--) {

        //
        //  If we've found the object, remove it from the list
        //
        
        if (pdstkCur == pdstkPtr) {

            //
            // remove from chain
            //
            DEBUG(( MMGRP, LMLVL, "    FreeStr: Prev %x, Cur %x, DCount %d",
                   pdstkLast, pdstkCur, DCount )) ;
            
            if (pdstkCur == DHead) {

                DHead = (PDSTACK)pdstkCur->pdstkPrev;

            } else {

                pdstkLast->pdstkPrev = pdstkCur->pdstkPrev;

            }

            HeapFree( GetProcessHeap( ), 0, pdstkCur );
            DCount--;
#if DBG
            MemChkAll( ) ;
#endif

            return;
        }
        pdstkLast = pdstkCur;
        pdstkCur = (PDSTACK)pdstkCur->pdstkPrev;

    }

    //
    //  The object wasn't in the stack at all!
    //

#if DBG
    DEBUG((MMGRP, LMLVL, "    FreeStr: object not in stack")) ;
    //  cmd_printf( TEXT( "Object @ %04x not in memory stack!" ), pbFree ) ;
    MemChkAll( ) ;
#endif
}


/***    GetBigBuf -  allocate a large buffer
 *
 *  Purpose:
 *      To allocate a buffer for data transferrals.
 *      The buffer will be as large as possible, up to MAXBUFSIZE bytes,
 *      but no smaller than MINBUFSIZE bytes.
 *
 *  TCHAR *GetBigBuf(unsigned *blen)
 *
 *  Args:
 *      blen = the variable pointed to by blen will be assigned the size of
 *          the buffer
 *
 *  Returns:
 *      A TCHAR pointer containing segment:0.
 *      Returns 0L if unable to allocate a reasonable length buffer
 *
 */

PVOID

GetBigBuf(
    IN  ULONG   CbMaxToAllocate,
    IN  ULONG   CbMinToAllocate,
    OUT unsigned int *CbAllocated,
    IN  int     BigBufID
    )


/*++

Routine Description:

    To allocate a buffer for data transferrals.

Arguments:

    CbMinToAllocate - Fail if can't allocate this number
    CbMaxToAllocate - Initial try and allocation will use this number
    CbAllocated - Number of bytes allocated
    BigBufID - BigBuf index

Return Value:

    Return: NULL - if failed to allocate anything
            pointer to allocated buffer if success
--*/

{
    ULONG   cbToDecrease;
    PVOID   handle ;

    DEBUG((MMGRP, MALVL, "GETBIGBUF: MinToAlloc %d, MaxToAlloc %d", CbMinToAllocate, CbMaxToAllocate)) ;

    cbToDecrease = CbMaxToAllocate;
    //bytesdecrease = CbMaxToAllocate ;

    while (!(handle = VirtualAlloc(NULL, CbMaxToAllocate,MEM_COMMIT,PAGE_READWRITE))) {

        //
        // Decrease the desired buffer size by CbToDecrease
        // If the decrease is too large, make it smaller
        //
        if ( cbToDecrease >= CbMaxToAllocate ) {
            cbToDecrease = ((CbMaxToAllocate >> 2) & 0xFE00) + 0x200;
        }

        if ( cbToDecrease < CbMinToAllocate ) {
            cbToDecrease = CbMinToAllocate ;
        }

        CbMaxToAllocate -= cbToDecrease ;

        if ( CbMaxToAllocate < CbMinToAllocate ) {

            //
            // Unable to allocate a reasonable buffer
            //
            *CbAllocated = 0 ;
            PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
            return ( NULL ) ;
        }
    }

    *CbAllocated = CbMaxToAllocate ;

    FreeBigBuf(BigBufID) ;
    BigBufHandle[BigBufID] = handle ;

    DEBUG((MMGRP, MALVL, " GETBIGBUF: Bytes Allocated = %d  Handle = 0x%04x", *CbAllocated, BigBufHandle[BigBufID])) ;

    return(handle) ;
}




/***    mknode - allocata a parse tree node
 *
 *  Purpose:
 *      To allocate space for a new parse tree node.  Grow the data segment
 *      if necessary.
 *
 *  struct node *mknode()
 *
 *  Returns:
 *      A pointer to the node that was just allocated.
 *
 *  Notes:
 *      This routine must always use calloc().  Many other parts of Command
 *      depend on the fact that the fields in these nodes are initialized to 0.
 *
 *      THIS ROUTINE RETURNS `NULL' IF THE C RUN-TIME CANNOT ALLOCATE MEMORY
 */

struct node *mknode()
{
    struct node *Node = (struct node *) mkstr( sizeof( struct node ));
    DEBUG((MMGRP, MALVL, "    MKNODE: Entered")) ;
    return Node;
}




/***    mkstr -  allocate space for a string
 *
 *  Purpose:
 *      To allocate space for a new string.  Grow the data segment if necessary.
 *
 *  TCHAR *mkstr(size)
 *
 *  Args:
 *      size - size of the string to be allocated
 *
 *  Returns:
 *      A pointer to the string that was just allocated.
 *
 *  Notes:
 *      This routine must always use calloc().  Many other parts of Command
 *      depend on the fact that memory that is allocated is initialized to 0.
 *
 *    - M005 * The piece of memory allocated is large enough to include
 *      a pointer at the beginning.  This pointer is part of the list of
 *      allocated memory.  The routine calling mkstr() receives the address
 *      of the first byte after that pointer.  resize() knows about this,
 *      and so must any other routines which directly modify memory
 *      allocation.
 *    - M011 * This function is the same as mentioned above except that the
 *      pointer is now preceeded by a header consisting of two signature
 *      bytes and the length of the memory allocated.  This was added for
 *      sanity checks.
 *
 *      THIS ROUTINE RETURNS `NULL' IF THE C RUN-TIME CANNOT ALLOCATE MEMORY
 *
 *                              W A R N I N G
 *      !!! THIS ROUTINE CAUSES AN ABORT IF DATA STACK CONTAMINATED !!!
 */

void*
mkstr(
    IN  int  cbNew
    )
{
    PDSTACK pdstkCur ;  // Ptr to the memory being allocated

    DEBUG((MMGRP, MALVL, "    MKSTR: Entered.")) ;

#if DBG

        MemChkAll() ;           /* CAUSES abort() IF CONTAMINATED          */

#endif

    if ((pdstkCur = (PDSTACK)(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbNew + PTRSIZE + 4))) == NULL) {
            PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
            return(0) ;
    } ;

    DEBUG((MMGRP, MALVL, "    MKSTR: Adding to stack")) ;

    pdstkCur->cb   = cbNew + PTRSIZE + 4 ;
    pdstkCur->pdstkPrev = (PDSTACK)DHead ;
    DHead = pdstkCur ;
    DCount++ ;

    DEBUG((MMGRP, MALVL, "    MKSTR: ptr = %04x  cbNew = %04x  DCount = %d",
           pdstkCur, cbNew, DCount)) ;

#if DBG

    MemChkBk(pdstkCur) ;           /* CAUSES abort() IF CONTAMINATED          */

#endif

    return(&(pdstkCur->data)) ;    /*M005*/
}


/***    dupstr -  Duplicate a string
 *
 *  Purpose:
 *      Create a copy of a string in a new heap block
 *
 *  TCHAR *dupstr( TCHAR *String )
 *
 *  Args:
 *      String to be duplicated
 *
 *  Returns:
 *      A pointer to the string that was just allocated and copied. The caller retains
 *      ownership of the input string and the returned string.
 *
 *  Notes:
 *
 *                              W A R N I N G
 *      !!! THIS ROUTINE CAUSES AN ABORT IF DATA STACK CONTAMINATED !!!
 */

TCHAR *
dupstr( TCHAR *String )
{
    TCHAR *New = mkstr( (mystrlen( String ) + 1) * sizeof( TCHAR ));

    mystrcpy( New, String );
    return New;
}



/***    gmkstr - allocate a piece of memory, with no return on failure
 *
 *  Purpose:
 *      Same as "mkstr" except that if memory cannot be allocated, this
 *      routine will jump out to code which will clean things up and
 *      return to the top level of command.
 *
 */

void*
gmkstr(
    IN  int   cbNew
    )

{
        PTCHAR pbNew ;

        if (!(pbNew = (PTCHAR)mkstr(cbNew)))
                Abort() ;

        return(pbNew) ;
}




/***    resize - resize a piece of memory
 *
 *  Purpose:
 *      Change the size of a previously allocated piece of memory.  Grow the
 *      data segment if necessary.  If a new different pointer is returned by
 *      realloc(0), search the dstk for the pointer to the old piece and
 *      update that pointer to point to the new piece.
 *
 *  TCHAR *resize(TCHAR *ptr, unsigned size)
 *
 *  Args:
 *      ptr - pointer to the memory to be resized
 *      size - the new size for the block of memory
 *
 *  Returns:
 *      A pointer to the new piece of memory.
 *
 *    - M005 * Modified for the new scheme for keeping a list of allocated
 *      blocks
 *    - M011 * Modified to use and check new header.
 *
 *      THIS ROUTINE RETURNS `NULL' IF THE C RUN-TIME CANNOT ALLOCATE MEMORY
 *
 *                              W A R N I N G
 *      !!! THIS ROUTINE CAUSES AN ABORT IF DATA STACK CONTAMINATED !!!
 */

void*
resize (
    IN  void* pv,
    IN  unsigned int cbNew
    )

{
    PDSTACK pdstkCur ;
             PDSTACK pdstkNew, pdstkOld;
    CHAR* pbOld = pv;

    DEBUG((MMGRP, MALVL, "    RESIZE: Entered %x.", pv)) ;

    pbOld -= PTRSIZE ;
    pdstkOld = (PDSTACK)pbOld ;

#if DBG

    if (MemChk1(pdstkOld)) {

        cmd_printf(TEXT("Memory Element @ %04x contaminated!"), pdstkOld) ;
        abort() ;

    } ;

#endif

    if (!(pdstkNew = (PDSTACK)HeapReAlloc(GetProcessHeap(), 0, pbOld, cbNew + PTRSIZE + 4))) {
            PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
            return(0) ;
    } ;



    pdstkNew->cb = cbNew + PTRSIZE + 4 ;   // Update to new length
    if (HeapSize(GetProcessHeap(), 0, pdstkNew) != pdstkNew->cb) {
        DEBUG((MMGRP, LMLVL, "    resize: My Size is %x, heap says %x", pdstkNew->cb,   HeapSize(GetProcessHeap(), 0, pdstkNew)));
    }

    //
    // revise Data Stack information, updating chain of pdstk's with
    // new pointer
    //
    if (pdstkNew != pdstkOld) {
        if (DHead == pdstkOld) {        // Is head of List
            DHead = pdstkNew ;
        } else {                        // Is in middle of list
            for (pdstkCur = DHead ; pdstkCur ; pdstkCur = (PDSTACK)(pdstkCur->pdstkPrev)) {
                if ((PDSTACK)(pdstkCur->pdstkPrev) == pdstkOld) {

                    pdstkCur->pdstkPrev = (PDSTACK)pdstkNew ;
                    break ;

                }
            }
        }
    }

#if DBG

    MemChkBk(pdstkOld) ;  // CAUSES abort() IF CONTAMINATED

#endif

    DEBUG((MMGRP, MALVL, "    RESIZE: pbOld = %04x  cbNew = %04x",&(pdstkNew->data),cbNew)) ;

    return(&(pdstkNew->data)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cop.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cop.c

Abstract:

    Conditional/sequential command execution

--*/

#include "cmd.h"

extern int LastRetCode;

extern int ExtCtrlc;		/* @@1 */

/*  M000 ends */

unsigned PipeCnt ;		/* M007 - Active pipe count		   */
struct pipedata *PdHead = NULL; /* M007 - 1st element of pipedata list	   */
struct pipedata *PdTail = NULL; /* M007 - Last element of pipedata list    */
HANDLE PipePid ;		/* M007 - Communication with ECWork	   */



/***	eComSep - execute a statement containing a command separator
 *
 *  Purpose:
 *	Execute the left and right hand sides of a command separator
 *	operator.
 *
 *  int eComSep(struct node *n)
 *
 *  Args:
 *	n - parse tree node containing the command separator node
 *
 *  Returns:
 *	Whatever the right hand side returns.
 *
 *  Notes:
 *	Revised to always supply both args to Dispatch().
 */

int eComSep(n)
struct node *n ;
{
	Dispatch(RIO_OTHER,n->lhs) ;
        if (GotoFlag) {
            return SUCCESS;
        } else {
            return(Dispatch(RIO_OTHER,n->rhs)) ;
        }
}


/***	eOr - execute an OR operation
 *
 *  Purpose:
 *	Execute the left hand side of an OR operator (||).  If it succeeds,
 *	quit.  Otherwise execute the right side of the operator.
 *
 *  int eOr(struct node *n)
 *
 *  Args:
 *	n - parse tree node containing the OR operator node
 *
 *  Returns:
 *	If the left hand side succeeds, return SUCCESS.  Otherwise, return
 *	whatever the right side returns.
 *
 *  Notes:
 *	Revised to always supply both args to Dispatch().
 */

int eOr(n)
struct node *n ;
{
        int i ;                         /* Retcode from L.H. side of OR   */
	if ((i = Dispatch(RIO_OTHER,n->lhs)) == SUCCESS)
	    return(SUCCESS) ;
	else {
            LastRetCode = i;
	    return(Dispatch(RIO_OTHER,n->rhs)) ;
        }
}




/***	eAnd - execute an AND operation
 *
 *  Purpose:
 *	Execute the left hand side of an AND operator (&&).  If it fails,
 *	quit.  Otherwise execute the right side of the operator.
 *
 *  int eAnd(struct node *n)
 *
 *  Args:
 *	n - parse tree node containing the AND operator node
 *
 *  Returns:
 *	If the left hand side fails, return its return code.  Otherwise, return
 *	whatever the right side returns.
 *
 *  Notes:
 *	Revised to always supply both args to Dispatch().
 */

int eAnd(n)
struct node *n ;
{
	int i ; 			/* Retcode from L.H. side of AND   */

	if ((i = Dispatch(RIO_OTHER,n->lhs)) != SUCCESS) {
            return(i) ;
        } else if (GotoFlag) {
            return SUCCESS;
        } else {
            return(Dispatch(RIO_OTHER,n->rhs)) ;
        }
}





/********************* START OF SPECIFICATION **************************/
/*								       */
/* SUBROUTINE NAME: ePipe					       */
/*								       */
/* DESCRIPTIVE NAME: Pipe Process				       */
/*								       */
/* FUNCTION: Execute the left side of the pipe and direct its output to*/
/*	     the right side of the pipe.			       */
/*								       */
/* NOTES: None							       */
/*								       */
/*								       */
/* ENTRY POINT: ePipe						       */
/*    LINKAGE: NEAR						       */
/*								       */
/* INPUT: n - parse tree node containing the pipe operator	       */
/*								       */
/* OUTPUT: None 						       */
/*								       */
/* EXIT-NORMAL: The return code of the right side process.	       */
/*								       */
/* EXIT-ERROR:	Failure if no pipe redirection can take place.	       */
/*								       */
/* EFFECTS:							       */
/*								       */
/*    struct pipedata { 					       */
/*	   unsigned rh ;	       Pipe read handle 	       */
/*	   unsigned wh ;	       Pipe write handle	       */
/*	   unsigned shr ;	       Handles where the normal...     */
/*	   unsigned shw ;	       ...STDIN/OUT handles are saved  */
/*	   unsigned lPID ;	       Pipe lh side PID 	       */
/*	   unsigned rPID ;	       Pipe rh side PID 	       */
/*	   unsigned lstart ;	       Start Information of lh side @@4*/
/*	   unsigned rstart ;	       Start Information of rh side @@4*/
/*	   struct pipedata *prvpds ;   Ptr to previous pipedata struct */
/*	   struct pipedata *nxtpds ;   Ptr to next pipedata struct     */
/*	      } 						       */
/*								       */
/*    unsigned PipePID; 	       Pipe Process ID		       */
/*								       */
/*    unsigned start_type;	       Start Information	       */
/*								       */
/*								       */
/* INTERNAL REFERENCES: 					       */
/*	ROUTINES:						       */
/*	 PutStdErr -  Print an error message			       */
/*	 Abort	   -  Terminate program with abort		       */
/*	 SetList   -  Set Link List for pipedata structure	       */
/*	 Cdup	   -  Duplicate supplied handle and save the new handle*/
/*	 Cdup2	   -  Duplicate supplied handle and save the new handle*/
/*	 Dispatch  -  Execute the program			       */
/*	 PipeErr   -  Handle pipe error 			       */
/*	 Cclose    -  Close the specified handle		       */
/*	 PipeWait  -  Wait for the all pipe process completion	       */
/*								       */
/* EXTERNAL REFERENCES: 					       */
/*	ROUTINES:						       */
/*	 DOSMAKEPIPE	 - Make pipe				       */
/*								       */
/********************** END  OF SPECIFICATION **************************/
/***	ePipe - Create a pipeline between two processes (M000)
 *
 *  Purpose:
 *	Execute the left side of the pipe and direct its output to
 *	the right side of the pipe.
 *
 *  int ePipe(struct node *n)
 *
 *  Args:
 *	n - parse tree node containing the pipe operator
 *
 *  Returns:
 *	The return code of the right side process or failure if no
 *	pipe redirection can take place.
 *
 *  Notes:
 *	M007 - This function has been completely rewritten for real pipes.
 *
 */

int ePipe(n)
struct node *n ;
{
    struct pipedata *Pd ;           /* Pipe struct pointer     */
    int k = 0 ;             /* RH side return code     */
    struct node *l ;            /* Copy of left side arg   */
    struct node *r ;            /* Copy of right side arg  */
    extern unsigned start_type ;        /* API type used to start  */
    TCHAR cflags ;              /*             */

    l = n->lhs ;                /* Equate locals to...     */
    r = n->rhs ;                /* ...L & R operations     */

    DEBUG((OPGRP,PILVL,"PIPES:LH = %d, RH = %d ",l->type,r->type)) ;

    if (!(Pd = (struct pipedata *)mkstr(sizeof(struct pipedata)))) {

        DEBUG((OPGRP,PILVL,"PIPES:Couldn't alloc structure!")) ;

        return(FAILURE) ;
    };


    //
    //  Create a pipe with a read handle and a write handle
    //

    if (_pipe((int *)Pd, 0, O_BINARY)) {

        DEBUG((OPGRP,PILVL,"PIPES:pipe failed!")) ;

        PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);     /* M013    */
        return(FAILURE) ;
        Abort() ;
    };

    SetList(Pd->rh) ;               /* M009 */
    SetList(Pd->wh) ;               /* M009 */

    DEBUG((OPGRP,PILVL,"PIPES:Pipe built. Handles: rd = %d wt = %d ",Pd->rh, Pd->wh)) ;
    DEBUG((OPGRP,PILVL,"PIPES:Pipe (pre-index) count = %d", PipeCnt)) ;

    if (!PipeCnt++) {           /* Already some pipes?     */
        PdHead = PdTail = Pd ;      /* No, set head/tail ptrs  */
        Pd->prvpds = NULL ;     /* No previous structure   */

        DEBUG((OPGRP,PILVL,"PIPES:This is first pipe.")) ;

    } else {

        DEBUG((OPGRP,PILVL,"PIPES:This is pipe %d.", PipeCnt)) ;

        PdTail->nxtpds = Pd ;
        Pd->prvpds = PdTail ;
        Pd->nxtpds = NULL ;
        PdTail = Pd ;
    } ;

    //
    //  Set up the redirection for the left-hand side; the writing side.
    //  We do this by saving the current stdout, duplicating the pipe-write
    //  handle onto stdout, and then invoking the left-hand side of the pipe.
    //  When we do this, the lefthand side will fill the pipe with data.
    //

    //
    //  Save stdout handle
    //

    if ((Pd->shw = Cdup(STDOUT)) == BADHANDLE) {   /* Save STDOUT (M009) */
        Pd->shw = BADHANDLE ;       /* If err, go process it   */
        PipeErr() ;         /* DOES NOT RETURN     */
    };

    DEBUG((OPGRP,PILVL,"PIPES:STDOUT dup'd to %d.", Pd->shw)) ;

    //
    //  Make stdout point to the write side of the pipe
    //

    if (Cdup2(Pd->wh, STDOUT) == BADHANDLE) /* Make wh STDOUT (M009)   */
        PipeErr() ;         /* DOES NOT RETURN     */

    Cclose(Pd->wh) ;            /* Close pipe hndl (M009)  */
    Pd->wh = 0 ;                /* And zero the holder     */

    if (l->type <= CMDTYP) {                /* @@5a */
        /* @@5a */
        FindAndFix( (struct cmdnode *) l, &cflags ) ; /* @@5a */
    }                       /* @@5a */

    DEBUG((OPGRP,PILVL,"PIPES:Write pipe now STDOUT")) ;

    //
    //  Execute the left side of the pipe, fillng the pipe
    //

    k = Dispatch(RIO_PIPE,l) ;


    //
    //  This closes the read handle in the left hand pipe.  I don't know
    //  why we're doing this.
    //

    if (PipePid != NULL) {
        DuplicateHandle( PipePid, 
                         CRTTONT(Pd->rh), 
                         NULL, 
                         NULL, 
                         0, 
                         FALSE, 
                         DUPLICATE_CLOSE_SOURCE);
    }

    //
    //  Restore the saved stdout
    //

    if (Cdup2(Pd->shw, STDOUT) == BADHANDLE)
        PipeErr( );

    //
    //  Closed the saved handle
    //

    Cclose(Pd->shw) ;           /* M009 */
    Pd->shw = 0 ;

    DEBUG((OPGRP,PILVL,"PIPES:STDOUT now handle 1 again.")) ;

    if (k) {
        ExtCtrlc = 2;           /* @@1 */
        Abort() ;
    }

    Pd->lPID = PipePid ;
    Pd->lstart = start_type ;  /* Save the start_type in pipedata struct */
    PipePid = 0 ;
    start_type = NONEPGM ;     /* Reset the start_type     D64       */

    DEBUG((OPGRP,PILVL,"PIPES:Dispatch LH side succeeded - LPID = %d.",Pd->lPID)) ;


    //
    //  Start on the right hand side of the pipe. Save the current stdin,
    //  copy the pipe read handle to stdin and then execute the right hand side
    //  of the pipe
    //  

    //
    //  Save stdin
    //

    if ((Pd->shr = Cdup(STDIN)) == BADHANDLE) {    /* Save STDIN (M009) */
        Pd->shr = BADHANDLE ;
        PipeErr() ;         /* DOES NOT RETURN     */
    };

    DEBUG((OPGRP,PILVL,"PIPES:STDIN dup'd to %d.", Pd->shr)) ;

    //
    //  Point stdin at the pipe read handle
    //

    if (Cdup2(Pd->rh, STDIN) == BADHANDLE)  /* Make rh STDIN (M009)    */
        PipeErr() ;         /* DOES NOT RETURN     */

    Cclose(Pd->rh) ;            /* Close pipe hndl (M009)  */
    Pd->rh = 0 ;                /* And zero the holder     */

    if (r->type <= CMDTYP) {                   /* @@5a */
        /* @@5a */
        FindAndFix( (struct cmdnode *) r, &cflags) ;     /* @@5a */
    };                            /* @@5a */

    DEBUG((OPGRP,PILVL,"PIPES:Read pipe now STDIN")) ;

    //
    //  Start off the right hand side of the pipe
    //

    k = Dispatch(RIO_PIPE,r) ;

    //
    //  Restore the saved stdin
    //

    if (Cdup2(Pd->shr, STDIN) == BADHANDLE) /* M009 */
        PipeErr() ;         /* DOES NOT RETURN     */

    //
    //  Get rid of the saved stdin
    //

    Cclose(Pd->shr) ;           /* M009 */
    Pd->shr = 0 ;

    DEBUG((OPGRP,PILVL,"PIPES:STDIN now handle 0 again.")) ;

    if (k) {
        ExtCtrlc = 2;           /* @@1 */
        Abort() ;
    }

    Pd->rPID = PipePid ;
    Pd->rstart = start_type ;  /* Save the start_type in pipedata struct */
    PipePid = 0 ;
    start_type = NONEPGM ;     /* Reset the start_type  D64          */

    DEBUG((OPGRP,PILVL,"PIPES:Dispatch RH side succeeded - RPID = %d.",Pd->rPID)) ;

    if (!(--PipeCnt)) {         /* Additional pipes?       */

        DEBUG((OPGRP,PILVL,"PIPES:Returning from top level pipe. Cnt = %d", PipeCnt)) ;

        return(PipeWait()) ;        /* No, return CWAIT    */
    };

    DEBUG((OPGRP,PILVL,"PIPES:Returning from pipe. Cnt = %d", PipeCnt)) ;

    return(k) ;             /* Else return exec ret    */
}




/***	PipeErr - Fixup and error out following pipe error
 *
 *  Purpose:
 *	To provide single error out point for multiple error conditions.
 *
 *  int PipeErr()
 *
 *  Args:
 *	None.
 *
 *  Returns:
 *	DOES NOT RETURN TO CALLER.  Instead it causes an internal Abort().
 *
 */

void PipeErr()
{

	PutStdErr(MSG_PIPE_FAILURE, NOARGS) ;			/* M013    */
	Abort() ;
}





/********************* START OF SPECIFICATION **************************/
/*								       */
/* SUBROUTINE NAME: PipeWait					       */
/*								       */
/* DESCRIPTIVE NAME: Wait and Collect Retcode for All Pipe Completion  */
/*								       */
/* FUNCTION: This routine calls WaitProc or WaitTermQProc for all      */
/*	     pipelined processes until entire pipeline is finished.    */
/*	     The return code of right most element is returned.        */
/*								       */
/* NOTES:    If the pipelined process is started by DosExecPgm,        */
/*	     WaitProc is called.  If the pipelined process is started  */
/*	     by DosStartSession, WaitTermQProc is called.	       */
/*								       */
/*								       */
/* ENTRY POINT: PipeWait					       */
/*    LINKAGE: NEAR						       */
/*								       */
/* INPUT: None							       */
/*								       */
/* OUTPUT: None 						       */
/*								       */
/* EXIT-NORMAL:  No error return code				       */
/*								       */
/* EXIT-ERROR:	Error return code from either WaitTermQProc or WaitProc*/
/*								       */
/*								       */
/* EFFECTS: None.						       */
/*								       */
/* INTERNAL REFERENCES: 					       */
/*	ROUTINES:						       */
/*	 WaitProc - wait for the termination of the specified process, */
/*		    its child process, and  related pipelined	       */
/*		    processes.					       */
/*								       */
/*	 WaitTermQProc - wait for the termination of the specified     */
/*			 session and related pipelined session.        */
/*								       */
/* EXTERNAL REFERENCES: 					       */
/*	ROUTINES:						       */
/*	 WINCHANGESWITCHENTRY -  Change switch list entry	       */
/*								       */
/********************** END  OF SPECIFICATION **************************/
/***	PipeWait - wait and collect retcode for all pipe completion (M007)
 *
 *  Purpose:
 *	To do cwaits on all pipelined processes until entire pipeline
 *	is finished.  The retcode of the rightmost element of the pipe
 *	is returned.
 *
 *  int PipeWait()
 *
 *  Args:
 *	None.
 *
 *  Returns:
 *	Retcode of rightmost pipe process.
 *
 */

PipeWait()
{
	unsigned i ;

	DEBUG((OPGRP,PILVL,"PIPEWAIT:Entered - PipeCnt = %d", PipeCnt)) ;

	while (PdHead) {
		if (PdHead->lPID) {
		     DEBUG((OPGRP, PILVL, "PIPEWAIT: lPID %d, lstart %d", PdHead->lPID, PdHead->lstart));

		     if ( PdHead->lstart == EXECPGM )
		       {
			i = WaitProc(PdHead->lPID) ;	/* M012 - Wait LH   */

			DEBUG((OPGRP,PILVL,"PIPEWAIT:CWAIT on LH - Ret = %d, SPID = %d", i, PdHead->lPID)) ;
		       }
//		     else
//		       {
//			WaitTermQProc(PdHead->lPID, &i) ;
//
//			DEBUG((OPGRP,PILVL,"PIPEWAIT:Read TermQ on LH - Ret = %d, PID = %d", i, PdHead->lPID)) ;
//		       } ;
//
		} ;
		if (PdHead->rPID) {
		     DEBUG((OPGRP, PILVL, "PIPEWAIT: rPID %d, rstart %d", PdHead->rPID, PdHead->rstart));
		     if ( PdHead->rstart == EXECPGM )
		       {
			i = WaitProc(PdHead->rPID) ;	/* M012 - Wait RH   */

			DEBUG((OPGRP,PILVL,"PIPEWAIT:CWAIT on RH - Ret = %d, PID = %d", i, PdHead->rPID)) ;
		       }
//		     else
//		       {
//			WaitTermQProc(PdHead->rPID, &i) ;
//
//			DEBUG((OPGRP,PILVL,"PIPEWAIT:Read TermQ on LH - Ret = %d, PID = %d", i, PdHead->rPID)) ;
//		       } ;

		} ;

		PdHead = PdHead->nxtpds ;
	} ;

	DEBUG((OPGRP,PILVL,"PIPEWAIT: complete, Retcode = %d", i)) ;

	PdTail = NULL ; 		/* Cancel linked list...	   */
	PipeCnt = 0 ; 	/* ...pipe count and pipe PID	   */
    PipePid = 0 ;
        LastRetCode = i;
	return(i) ;
}




/***	BreakPipes - disconnect all active pipes  (M000)
 *
 *  Purpose:
 *	To remove the temporary pipe files and invalidate the pipedata
 *	structure when pipes are to be terminated, either through the
 *	completion of the pipe operation or SigTerm.
 *
 *	This routine is called directly by the signal handler and must
 *	not generate any additional error conditions.
 *
 *  void BreakPipes()
 *
 *  Args:
 *	None.
 *
 *  Returns:
 *	Nothing.
 *
 *  Notes:
 *	M007 - This function has been completely rewritten for real pipes.
 *
 *			*** W A R N I N G ! ***
 *	THIS ROUTINE IS CALLED AS A PART OF SIGNAL/ABORT RECOVERY AND
 *	THEREFORE MUST NOT BE ABLE TO TRIGGER ANOTHER ABORT CONDITION.
 *
 */

void BreakPipes()
{
	unsigned i ;
	struct pipedata *pnode;

	DEBUG((OPGRP,PILVL,"BRKPIPES:Entered - PipeCnt = %d", PipeCnt)) ;

	/* The following two lines have been commented out */
	/* because the NULL test on PdTail should be enough, */
	/* and more importantly, even if PipeCnt is 0, you */
	/* may still have been servicing a pipe in Pipewait */

/*	if (!PipeCnt)	       */		/* If no active pipes...   */
/*		return ;       */		/* ...don't do anything    */

	pnode = PdTail;

	/* First, kill all of the processes */
	while (pnode) {
		if (pnode->lPID!=(HANDLE) NULL) {
/* M012 */		i = KillProc(pnode->lPID, FALSE) ; /* Kill LH   */

			DEBUG((OPGRP,PILVL,"BRKPIPES:LH (Pid %d) killed - Retcode = %d", PdTail->lPID, i)) ;
		} ;

		if (pnode->rPID!=(HANDLE) NULL) {
/* M012 */		i = KillProc(pnode->rPID, FALSE) ; /* Kill RH   */

			DEBUG((OPGRP,PILVL,"BRKPIPES:RH (Pid %d) killed - Retcode = %d", PdTail->rPID, i)) ;
		} ;
		pnode = pnode->prvpds ;
	}

	/* Wait for the processes to die, and clean up file handles */
	while (PdTail) {
		if (PdTail->lPID) {
		   if (PdTail->lstart == EXECPGM) {
		      i = WaitProc(PdTail->lPID);
//		   } else {
//		      WaitTermQProc(PdTail->lPID, &i) ;
		   }
		} ;

		if (PdTail->rPID) {
		   if (PdTail->rstart == EXECPGM) {
		      i = WaitProc(PdTail->rPID);
//		   } else {
//		      WaitTermQProc(PdTail->rPID, &i) ;
		   }
		} ;

		if (PdTail->rh) {
			Cclose(PdTail->rh) ;			/* M009 */

			DEBUG((OPGRP,PILVL,"BRKPIPES:Pipe read handle closed")) ;
		} ;
		if (PdTail->wh) {
			Cclose(PdTail->wh) ;			/* M009 */

			DEBUG((OPGRP,PILVL,"BRKPIPES:Pipe write handle closed")) ;
		} ;
		if(PdTail->shr) {
			FlushFileBuffers(CRTTONT(PdTail->shr));
			Cdup2(PdTail->shr, STDIN) ;		/* M009 */
			Cclose(PdTail->shr) ;			/* M009 */

			DEBUG((OPGRP,PILVL,"BRKPIPES:STDIN restored.")) ;

		} ;
		if(PdTail->shw) {
			Cdup2(PdTail->shw, STDOUT) ;		/* M009 */
			Cclose(PdTail->shw) ;			/* M009 */

			DEBUG((OPGRP,PILVL,"BRKPIPES:STDOUT restored.")) ;

		} ;
		PdTail = PdTail->prvpds ;
	} ;

	PdHead = NULL ; 		/* Cancel linked list...	   */
	PipeCnt = 0 ; 	/* ...pipe count and pipe PID	   */
    PipePid = 0;

	DEBUG((OPGRP,PILVL,"BRKPIPES:Action complete, returning")) ;
}




/***	eParen - execute a parenthesized statement group
 *
 *  Purpose:
 *	Execute the group of statements enclosed by a statement grouping
 *	operator; parenthesis().
 *
 *  int eParen(struct node *n)
 *
 *  Args:
 *	n - parse tree node containing the PAREN operator node
 *
 *  Returns:
 *	Whatever the statement group returns.
 *
 *  Notes:
 *	M000 - Altered to always supply both args to Dispatch().
 *	M004 - Debug statements were added for SILTYP operator.
 *			**  WARNING  **
 *	BOTH THE LEFT PAREN AND THE SILENT OPERATOR (@) USE eParen
 *	WHEN DISPATCHED.  CHANGING ONE WILL AFFECT THE OTHER !!
 */

int eParen(n)
struct node *n ;
{
        DEBUG((OPGRP,PNLVL,"ePAREN: Operator is %s", (n->type == PARTYP) ? "Paren" : "Silent")) ;
	return(Dispatch(RIO_OTHER,n->lhs)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\csig.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    csig.c

Abstract:

    Interrupt (^C) processing

--*/

#include "cmd.h"

//
// console mode at program startup time. Used to reset mode
// after running another process.
//
extern  DWORD   dwCurInputConMode;
extern  DWORD   dwCurOutputConMode;

extern int Ctrlc;

VOID    ResetCtrlC();
int SigHandFlag = FALSE ;

/* Commands that temporarily change directories, save a ptr to the original
 * directory string here so that it can be restored by SigHand() if the
 * command is interrupted before it has a chance to do it, itself.
 */
TCHAR *SaveDir = NULL ;
unsigned SIGNALcnt = 0;

extern int PipeCnt ;            /* M016 - Cnt of active pipes              */

extern int LastRetCode ;

extern jmp_buf MainEnv ;
extern jmp_buf CmdJBuf1 ;

extern unsigned long OHTbl[] ;  /* M024 - Revised to be bit map            */

extern PHANDLE FFhandles;                 /* @@1 */
extern unsigned FFhndlsaved;              /* @@1 */

extern struct sellist *prexxsellist;

extern struct rio *rioCur ;             /* M000                    */
extern TCHAR *Fvars ;                                           /* M026    */
extern TCHAR **Fsubs ;                                          /* M026    */
extern TCHAR *save_Fvars ;  /* @@ */
extern TCHAR **save_Fsubs ; /* @@ */
extern int FvarsSaved;     /* @@ */

extern TCHAR InternalError[] ;
extern int EchoFlag ;
extern int EchoSave ;           /* M013 - Used to restore echo status      */
extern TCHAR ComSpec[] ;        /* M008 - For clearing SM shared memory    */
extern TCHAR ComSpecStr[] ;     /* M026 - Use ComSpec for SM memory        */
extern TCHAR *CmdSpec ;                                         /* M026    */

extern unsigned Heof;
extern unsigned start_type ;    /* Flag to indicate which API started the  */
                                /* program.  D64                           */

extern BOOL CtrlCSeen;
extern PTCHAR    pszTitleCur;
extern BOOLEAN  fTitleChanged;

void
Abort( void )
{

    DEBUG((SHGRP, MSLVL, "SIGHAND: Aborting Command")) ;
    SigCleanUp();
    longjmp(MainEnv, 1) ;

    CMDexit( FAILURE );
}

void
CtrlCAbort( ) {

    struct batdata *bdat;

    if (CurrentBatchFile) {

        if (PromptUser(NULL, MSG_BATCH_TERM, MSG_NOYES_RESPONSE_DATA) != 1) {
            ResetCtrlC();
            return;

        }

        //
        //  End local environments ( Otherwise we can end up with garbage
        //  in the main environment if any batch file used the setlocal
        //  command ).
        //
        bdat = CurrentBatchFile;
        while ( bdat ) {
            EndAllLocals( bdat );
            bdat = bdat->backptr;
        }
    }

    SigCleanUp();
    longjmp(MainEnv, 1) ;

}

void
CheckCtrlC (
    ) {

    if (CtrlCSeen) {

        CtrlCAbort();

    }
}


void
ExitAbort(
    IN  ULONG   rcExitCode
    )
{

    SigCleanUp();
    longjmp(MainEnv, rcExitCode) ;

    CMDexit( FAILURE );
}



/***    SigCleanUp - close files and reset I/O after a signal
 *
 *  Purpose:
 *      This function is called to finish the cleanup after an int 23 or 24.
 *      It resets all redirection back to the main level and it closes all
 *      files except those for stdin, stdout, stderr, stdaux and stdprint.
 *
 *  void SigCleanUp()
 *
 *  Args:
 *      None.
 *
 *  Returns:
 *      Nothing.
 *
 *  Notes:
 *    - M024 * Revised handle closing to be bit map based rather than struct.
 *
 */

void SigCleanUp()                               /* M000 - Now void         */
{
        int cnt, cnt2 ;
        unsigned long mask;

        Heof = FALSE;

#ifndef WIN95_CMD
        if (CurrentBatchFile) {

            // Following CmdBatNotification call is a cleanup for the
            // same call made from BatProc (in cbatch.c).

            CmdBatNotification (CMD_BAT_OPERATION_TERMINATING);
            EchoFlag = EchoSave ;
            GotoFlag = FALSE ;
            eEndlocal( NULL ) ;
            CurrentBatchFile = NULL ;
        } ;
#endif // WIN95_CMD

        if (!FvarsSaved) {     /* @WM If already saved, don't save again */
           save_Fvars = Fvars; /* @@ */
           save_Fsubs = Fsubs; /* @@ */
           FvarsSaved = TRUE;  /* @@ */
        }
        Fvars = NULL ;                  /* M026 - Must kill FOR    */
        Fsubs = NULL ;                  /* ...variable subst's     */

/*  M000 - New method is simpler.  If redirection has been done, the highest
 *  numbered handle resulting from redirection is saved, then the linked
 *  riodata list is unlinked until the first (main) level of redirection is
 *  reached at which time ResetRedir is used to reset it.  Then all open
 *  handles from 5 to the highest numbered redirection handle (minimum of
 *  19) are freed.
 *  M014 - Altered this to use actual global pointer when unwinding the
 *  riodata list to fix bug.  Also revised the ->stdio element to conform
 *  to new data structure.  Note that ResetRedir automatically resets the
 *  rioCur pointer to the last valid riodata structure before returning;
 *  same as if "rioCur=rioCur->back" was in the while loop.
 */
        DEBUG((SHGRP, MSLVL, "SCLEANUP: Resetting redirection.")) ;

        while (rioCur)
            ResetRedir() ;

        DEBUG((SHGRP, MSLVL, "SCLEANUP: Breaking pipes.")) ;

        BreakPipes() ;

        DEBUG((SHGRP, MSLVL, "SCLEANUP: Now closing extra handles.")) ;

        for (cnt = 0; cnt < 3; cnt++) {
           if (OHTbl[cnt]) {  /* Any handles to reset? */
              mask = 1;                                             /* @@1 */
              for (cnt2 = 0; cnt2 < 32; cnt2++, mask <<= 1) {       /* @@1 */
                 if ((OHTbl[cnt] & mask) &&                         /* @@1 */
                     ((cnt == 0 && cnt2 > 2) || cnt != 0) ) {       /* @@1 */
                     /* Don't close STDIN, STDOUT, STDERR */        /* @@1 */
                    Cclose(cnt2 + 32*cnt);                          /* @@1 */
                 }                                                  /* @@1 */
              }                                                     /* @@1 */
           }                                                        /* @@1 */
        }

        /* Close find first handles */                              /* @@1 */

        while (FFhndlsaved) {           /* findclose will dec this     @@1 */
           findclose(FFhandles[FFhndlsaved - 1]);                   /* @@1 */
        }                                                           /* @@1 */

        ResetConTitle( pszTitleCur );

        ResetConsoleMode();

        DEBUG((SHGRP, MSLVL, "SCLEANUP: Returning.")) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cpwork.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cpwork.c

Abstract:

    Copy command internal workers

--*/

#include "cmd.h"

/*  useful macro  */

#define Wild(spec)      (((spec)->flags & CI_NAMEWILD) != 0)
#define TruncateOnCtrlZ(flags)   (((flags) & (CI_ASCII | CI_NOT_UNICODE)) == (CI_ASCII | CI_NOT_UNICODE))

/*
 * The following two constants determine the minimum and maximum
 * sizes (in bytes) for temporary buffers allocated by TYPE or COPY
 */
#define MINCOPYBUFSIZE      128
#define MAXCOPYBUFSIZE      (65536-512)


DWORD
WinEditName(
           const TCHAR *pSrc,
           const TCHAR *pEd,
           TCHAR *pRes,
           const unsigned ResBufLen
           );

int DoVerify(
            CRTHANDLE      *pdestptr,
            TCHAR          *curr_dest,
            ULONG          bytes_read,
            CHAR           *buf_seg,
            CHAR           *buf_seg_dest
            );

/*  Global Vars  */

int copy_mode;
int number_of_files_copied;

/*  Global Vars from command  */
extern jmp_buf CmdJBuf2;                          /*  used to return on error   */

extern UINT CurrentCP;
extern CHAR  AnsiBuf[];
extern TCHAR CurDrvDir[];
extern TCHAR SwitChar, PathChar ;                 /* M007 */

extern TCHAR Fmt11[], Fmt17[];

extern unsigned DosErr ;

extern TCHAR VolSrch[] ;                          /* M009 */

extern PHANDLE FFhandles;                 /* @@1 */
extern unsigned FFhndlsaved;              /* @@1 */
unsigned FFhndlCopy;

BOOL  VerifyCurrent;

int first_file;                                   /* flag first file process @@5@J1  */
int first_fflag;                                  /* flag first file process @@5@J3  */

unsigned Heof = FALSE ;                           /* M017 - EOF flag            */
TCHAR buffer1[2*MAX_PATH];                       /* Increased buffer size @WM1 */
/* PTM 1412 */

extern BOOL CtrlCSeen;

int     same_fcpy(int, TCHAR *, TCHAR *);
int     scan_bytes(CHAR*,unsigned int *,int);
int     ZScanA(BOOL flag, PCHAR buf, PULONG buflen, PULONG skip);
CRTHANDLE       open_for_append(PTCHAR, PCPYINFO source, PCHAR, ULONG);
void    source_eq_dest(PCPYINFO,CRTHANDLE *,int ,CHAR *,unsigned ,HANDLE);
int     read_bytes(CRTHANDLE ,PCHAR, ULONG, PULONG, PCPYINFO source, CRTHANDLE, PTCHAR);
VOID    write_bytes(CRTHANDLE, PCHAR, ULONG, PTCHAR, CRTHANDLE);


/***    copy - Copy one or more files
 *
 *  Purpose:
 *      This is the main routine for the copy command.
 *
 *  int copy(TCHAR *args)
 *
 *  Args:
 *      args = The raw arguments from the command line.
 *
 *  Returns:
 *      SUCCESS if able to perform the copy
 *      FAILURE if not
 *
 */

int 
copy(TCHAR *args)
{
    PCPYINFO source; /* list of source specs    */
    PCPYINFO dest;
/*@@J*/int rcp = SUCCESS;
/*@@4*/int rc = SUCCESS;

    VerifyCurrent = GetSetVerMode(GSVM_GET);

    if (setjmp(CmdJBuf2))                   /* in case of error        */
        return(FAILURE);

    GetDir(CurDrvDir, GD_DEFAULT);          /* @@5c */

    DEBUG((FCGRP,COLVL,"COPY: Entered."));

    first_file = TRUE;                      /* flag-first file? @@5@J1 */
    first_fflag= TRUE;                      /* flag-first file? @@5@J3 */

    number_of_files_copied = 0;             /* initialize global vars  */
    copy_mode = COPY;
    cpyfirst = TRUE;   /* @@5b reset flag for COPY DOSQFILEMODE indicator        */
    cpydflag = FALSE;  /* @@5b reset flag for COPY dirflag not found             */
    cpydest  = FALSE;  /* @@5b reset flag for not disp bad dev msg twice         */
    cdevfail = FALSE;  /* @@5b reset flag for not disp extra dev msg in copy     */
    //
    // Mark level of find first handle. If an copy_error
    // is called this will allow only copies find handles to be
    // closed. For statement processing will have handles open
    // and these should not be closed
    FFhndlCopy = FFhndlsaved;


    source = NewCpyInfo();
    dest   = NewCpyInfo();
    parse_args(args, source, dest);   /* do parsing     @@5d */

    DEBUG((FCGRP,COLVL,"COPY: Args parsed, copy_mode = %d.",copy_mode));
    if (copy_mode == COMBINE) {

        DEBUG((FCGRP,COLVL,"COPY: Going to do combined copy."));

        do_combine_copy(source, dest);  /* @@5d */
    } else {

        DEBUG((FCGRP,COLVL,"COPY: Going to do normal copy."));

        rc = do_normal_copy(source, dest); /* @@4 @@5d */
    } ;

    PutStdOut(MSG_FILES_COPIED, ONEARG, argstr1(TEXT("%9d"), (unsigned long)number_of_files_copied)) ;   /* M016 */

    VerifyCurrent = GetSetVerMode(GSVM_GET);


    return( rc ); /* @@4 */
}

/***    get_full_name - Init struct with full name
 *
 *  Purpose:
 *      Given a cpyinfo structure that has just been filled in by
 *      findfirst or findnext, put the full name of the file that
 *      was found in struct->curfspec.
 *
 *  int get_full_name(struct copyinfo *src, TCHAR *srcbuf)
 *
 *  Args:
 *      src = The copy information structure
 *      srcbuf = buffer to have curfspec point to
 *
 *  Returns:
 *      Returns SUCCESS normally
 *
 *  Notes:
 *                      *** W A R N I N G ! ***
 *      THIS ROUTINE WILL CAUSE AN ABORT IF MEMORY CANNOT BE ALLOCATED
 *              THIS ROUTINE MUST NOT BE CALLED DURING A SIGNAL
 *              CRITICAL SECTION OR DURING RECOVERY FROM AN ABORT
 */

int get_full_name(src, srcbuf)
PCPYINFO src;
TCHAR *srcbuf;
{
    int retval = SUCCESS;       /*           - return value boolean        */
    unsigned plen,flen,diff;    /*           - length of path & file name  */


    DEBUG((FCGRP,COLVL,"GetFullName: Entered fspec = TEXT('%ws')",src->fspec));

    src->curfspec = srcbuf;

    plen = mystrlen(src->fspec);
    flen = mystrlen(src->buf->cFileName);

    if (src->pathend) {
        diff = (UINT)(src->pathend - src->fspec) + 1;
        if ((plen+1 > MAX_PATH) ||
            (diff + flen + 1 > MAX_PATH)) {
            retval = FAILURE;
        } else {
            mystrcpy(src->curfspec,src->fspec);
            *(src->curfspec + diff) = NULLC;
            mystrcat(src->curfspec,src->buf->cFileName);
        }
    } else {
        mystrcpy(src->curfspec,src->buf->cFileName);
    }

    DEBUG((FCGRP,COLVL,"GetFullName: Exiting full name = TEXT('%ws')",src->curfspec));
    return( retval );
}


#ifndef WIN95_CMD

/***    CopyProgressRtn
 *
 *  Purpose:
 *      This is a callback routine for CopyFileEx().  This
 *      function is called once per chunk of data during a
 *      restartable file copy.
 *
 *  Args:
 *      See winbase.h
 *
 *  Returns:
 *      See winbase.h
 *
 */
DWORD WINAPI
CopyProgressRtn(
               LARGE_INTEGER TotalFileSize,
               LARGE_INTEGER TotalBytesTransferred,
               LARGE_INTEGER StreamSize,
               LARGE_INTEGER StreamBytesTransferred,
               DWORD         dwStreamNumber,
               DWORD         dwCallbackReason,
               HANDLE        hSourceFile,
               HANDLE        hDestinationFile,
               BOOL          ReallyRestartable
               )
{
    LARGE_INTEGER percent;
    if (TotalFileSize.QuadPart != 0) {
        percent.QuadPart = (TotalBytesTransferred.QuadPart * 100) / TotalFileSize.QuadPart;
    } else {
        percent.QuadPart = 100;
    }
    PutStdOut( MSG_PROGRESS, ONEARG, argstr1(TEXT("%3d"), (unsigned long)percent.LowPart) );

    if (CtrlCSeen) {

        PutStdOut( MSG_PROGRESS, ONEARG, argstr1(TEXT("%3d"), (unsigned long)percent.LowPart) );
        printf( "\n" );

        if (ReallyRestartable) {
            return PROGRESS_STOP;
        } else {
            return PROGRESS_CANCEL;
        }

    } else {

        return PROGRESS_CONTINUE;

    }
}
#endif


/***    do_normal_copy - Does actual copying for normal copy
 *
 *  Purpose:
 *      On entry, source points to the empty header of a list of
 *      source filespecs, and dest points an empty struct that
 *      points to the zero or one destination filespec given.
 *       This procedure does the actual copying.
 *
 *  int do_normal_copy(struct copyinfo *source, struct copyinfo *dest)
 *
 *  Args:
 *      source = The source copy information structure
 *      dest   = The destination copy information structure
 *
 *  Returns:
 *      FAILURE if not able to perform the copy
 *
 */

int
do_normal_copy(
    PCPYINFO source, 
    PCPYINFO dest)
{
    TCHAR       curr_dest[MAX_PATH];
    TCHAR       save_dest[MAX_PATH] = TEXT(" ");
    TCHAR       source_buff[MAX_PATH];
    CRTHANDLE   srcptr, destptr=BADHANDLE;
    FILETIME    src_dateTime;
    ULONG       buf_len, original_buflen;
    ULONG       buf_len_dest;
    ULONG       bytes_read;
    ULONG       bytes_read_dest;
    CHAR  *     buf_seg ;
    CHAR  *     buf_seg_dest;
    HANDLE      hnFirst ;
    unsigned    rc = SUCCESS;
    unsigned    rcode = TRUE;
    BOOL        OpenWorked;
    BOOL        DestIsDevice;
    BOOL        Rslt;
#ifndef WIN95_CMD
    BOOL        ReallyRestartable;
#endif

    int         fsames;
    int         skip_first_byte = 0;
    int         multfile = FALSE;
    int         save_flags = 0;
    int         first_dest = TRUE;
    int         dest_dirflag;
    int         save_cmode;
    int         dest_att;
    BOOL        DecryptFlags = 
#if !defined( WIN95_CMD )
                    ( ((dest->next == 0 ? dest->flags : dest->next->flags) & CI_ALLOWDECRYPT) != 0)
                    ? COPY_FILE_ALLOW_DECRYPTED_DESTINATION : 
#endif // !defined( WIN95_CMD )
                    FALSE;

    BOOL        fFixList2Copy = 0;      // fix "copy *.* foo" for FAT where foo does not exist.
                                        // work-around a problem with FindFirstFile/FindNextFile on FAT.

    BOOL                 fEof;
    DWORD                dwSrcFileSize,
    dwSrcFileSizeHigh,
    dwDestFileSize,
    dwDestFileSizeHigh;


    dest_att = 0;
    save_cmode = 0;
    dest_dirflag = FALSE;

    //
    // Allocate a large buffer to hold read on copy.
    //

    buf_seg = (CHAR*)GetBigBuf(MAXCOPYBUFSIZE, MINCOPYBUFSIZE, (unsigned int *)&original_buflen, 0);                        /* allocate large buffer   */

    if (!buf_seg) {
        return(FAILURE) ;
    }

    if (VerifyCurrent) {
        buf_seg_dest = (CHAR*)GetBigBuf(original_buflen, MINCOPYBUFSIZE, (unsigned int *)&buf_len_dest, 1);               /* allocate large buffer   */

        if (!buf_seg_dest) {
            return(FAILURE) ;
        }
    }


    //
    // Cycle through source files coping each to destination
    // This list along with parsing of file names occured in copy
    // paring code.
    //
    while (source = source->next) {

        //
        // Look for Read-Only (FILE_ATTRIBUTE_READONLY) and Archive (FILE_ATTRIBUTE_ARCHIVE) files in addition
        // to directories.
        //
        if (!ffirst(StripQuotes( source->fspec ),
                    (unsigned int)FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_ARCHIVE,
                    (PWIN32_FIND_DATA)source->buf,
                    &hnFirst)) {

            DEBUG((FCGRP,COLVL,"DoNormalCopy: FFirst  reports file %ws not found",source->fspec));

            //
            // Could not find file. Check if not concatinating files together
            // or this is the first file
            //
            if (copy_mode != CONCAT || first_file) {

                cmd_printf(Fmt11,source->fspec);
                cmd_printf(CrLf);
                PrtErr(DosErr) ;
                findclose(hnFirst);
                copy_error(0,CE_PCOUNT);

            } else {

                //
                // It is OK to fail for CONCAT. If it was the first file
                // a concat could have gone through the above loop and
                // printed out an error message
                //
                continue;
            }
        }

        DEBUG((FCGRP,COLVL,"DoNormalCopy: FFirst  found file %ws",source->fspec));

        //
        // In case source is a wild card cycle through each file found
        //
        do {

            if (CtrlCSeen) {

                findclose(hnFirst) ;

                if (destptr != BADHANDLE)
                    Cclose(destptr);

                return(FAILURE);

            }

            //
            // Put file name that was broken into pieces back together.
            //
            if (get_full_name(source, source_buff) == FAILURE) {

                findclose(hnFirst) ;
                return(FAILURE);

            }

            //
            // work-around a problem with FindFirstFile/FindNextFile on FAT
            // where just created dest. file is enumerated as one of the source files.
            //

            if ( (!first_file) && (copy_mode == CONCAT) ) {
                if ( same_file( save_dest, source->curfspec) ) {
                    continue;
                }

            }


            //
            // if there are sources files from wildcards or '+' operators
            // used for concating files print out each one copied.
            //
            if (Wild(source) || (copy_mode == CONCAT)) {

                cmd_printf(Fmt17,source->curfspec);

            }

            //
            // If the dest. has not been opened, which will be the case
            // when not concat'ing files or this is the first file copied
            // then get then dest. name to open. get_dest_name will use
            // the source and dest. pattern (wild cards etc.) to form this
            // name
            //
            if ((copy_mode != CONCAT) || first_file) {

                if (get_dest_name(source,dest,curr_dest,MAX_PATH,FALSE) == FAILURE) {

                    findclose(hnFirst) ;
                    return(FAILURE);

                }

                if ( copy_mode == CONCAT ) {
                    mystrcpy(save_dest, curr_dest);
                }

                //
                // If user said no to overwrite, then skip this file.
                //
                if (curr_dest[0] == NULLC)
                    continue;
            }

            //
            // Now that the source and dest. have been determined, open
            // the source file
            //

            DEBUG((FCGRP,COLVL,"Attempt open of %ws",source->curfspec));

            srcptr = Copen_Copy2(source->curfspec, (ULONG)O_RDONLY);

            if (srcptr == BADHANDLE) {

                //
                // Print the error if failed to open
                //
                PrtErr(DosErr);

                //
                // If it is a CONCAT and do not have a destination
                // and the source and destination are the same then
                // go no futhur otherwise not FAILURE and continue
                // cycling through source names.
                //

                if ( (copy_mode == CONCAT) &&
                     (destptr == BADHANDLE) &&
                     (same_file(curr_dest,source->curfspec) )) {

                    findclose(hnFirst);
                    copy_error(0,CE_PCOUNT);
                }

                rc = FAILURE;
                continue;

            }

            //
            // Set Device flag, needed below for perfoming DOSQHANDTYPE
            //

            //
            // FileIsDevice will return TRUE if we opened NUL
            // above, and we don't want that.
            //

            if (FileIsDevice(srcptr)) {

                buf_len = MINCOPYBUFSIZE;
                source->flags |= CI_ISDEVICE;

            } else {

                if (VerifyCurrent)
                    buf_len = min (original_buflen, buf_len_dest);
                else
                    buf_len = original_buflen;

                buf_len_dest = buf_len;

            }


            //
            // set default mode
            //
            if (source->flags & CI_NOTSET) {

                source->flags &= ~CI_NOTSET;

                if (source->flags & CI_ISDEVICE) {

                    //
                    // Always run ASCII mode for a device
                    //
                    source->flags |= CI_ASCII;

                } else {

                    //
                    // Assume binary if just a file
                    //
                    source->flags |= CI_BINARY;

                }


                //
                // If this is the first file and it's not wild cards but
                // it is CONCAT mode then default to ASCII. This will
                // cause binaries files to get truncated on a CONCAT.
                //
                if (!fEnableExtensions &&
                    first_file && !(Wild(source)) && (copy_mode == CONCAT)) {

                    source->flags &= ~CI_BINARY;
                    source->flags |= CI_ASCII;

                }

            } else {

                //
                // If they have been already set let them ride for
                // all file copies
                //
                save_flags = source->flags;
            }

            //
            // rcode is used to track read/write error. rc is used for
            // general track general FAILURES
            //
            rcode = TRUE;

            //
            // Prepare to handle the case where dest=source by
            // first getting the full source path name
            //
            fsames = FullPath(buffer1,source->curfspec,MAX_PATH*2);

            //
            // Let's start some copying
            //

            DEBUG((FCGRP,COLVL,"open %ws for writing",curr_dest));


            //
            // Read a buffer to check if source is bad. If source OK then
            // continue.
            //

            rcode = read_bytes(srcptr,
                               buf_seg,
                               512,
                               &bytes_read,
                               source,
                               destptr,
                               StripQuotes( curr_dest ) );
            if (DosErr ) {

                Cclose(srcptr) ;
                PrtErr(ERROR_OPEN_FAILED) ;

                //
                //  If not in CONCAT mode then read on source will fail copy
                //  We want to continue in concat mode, gathering everything
                //  together
                //

                if ( copy_mode != CONCAT ) {

                    rc = FAILURE;
                    continue;

                }
                findclose(hnFirst);
                copy_error(0,CE_PCOUNT) ;

            } else {

                //
                // If not combining files or the first file in a combine
                // check if source and dest. are the same.
                //
                if ((copy_mode != CONCAT) || (first_file)) {

                    if (same_fcpy(fsames,buffer1,curr_dest) && !(source->flags & CI_ISDEVICE)) {

                        Cclose(srcptr);
                        //
                        // If this is nither CONCAT or TOUCH mode then, this
                        // call will not return but go to copy error code.
                        //
                        source_eq_dest(source,
                                       &destptr,
                                       first_file,
                                       buf_seg,
                                       buf_len,
                                       hnFirst
                                      );

                        if (first_file) {

                            if (copy_mode == CONCAT) {

                                source->flags &= ~CI_BINARY;
                                if (save_flags == 0) {

                                    source->flags |= CI_ASCII;

                                } else {

                                    source->flags |= save_flags;
                                }
                            }

                            multfile = TRUE;
                        }

                        //
                        // In ASCII case can for a Ctrl-Z, used for file
                        // termination.
                        //
                        scan_bytes(buf_seg,(unsigned int *)&bytes_read,source->flags);
                        first_file = FALSE;
                        continue;
                    }
                    cpydflag = TRUE;
                    if (dest->next != NULL && first_file) {

                        //
                        // do not disp bad dev msg twice
                        //

                        cpydest = TRUE;
                        DosErr = 0;
                        ScanFSpec(dest->next);

                        //
                        // Do not fail if it was justa file name found.
                        // or copy *.c foo would not work. Likewise do not
                        // fail on just an invalid name, this would be
                        // returned for a wild card on dest.
                        //
                        //

                        if (DosErr == ERROR_NOT_READY || DosErr == ERROR_NO_MEDIA_IN_DRIVE) {
                            PutStdOut(DosErr, NOARGS);
                            Cclose(srcptr);
                            findclose(hnFirst) ;
                            return( FAILURE );
                        }
                    }

                    //
                    // this is called twice so that in the case where we're copying
                    // to a directory, the file name gets appended to the directory
                    // if it's not there.
                    //
                    if (get_dest_name(source,dest,curr_dest,MAX_PATH,TRUE) == FAILURE) {

                        //
                        // don't need to read it
                        Cclose(srcptr);
                        findclose(hnFirst) ;
                        return(FAILURE);

                    }
                    //
                    // If user said no to overwrite, then skip this file.
                    //
                    if (curr_dest[0] == NULLC) {
                        Cclose(srcptr);
                        continue;
                    }

                    if (same_fcpy(fsames,buffer1,curr_dest) && !(source->flags & CI_ISDEVICE)) {
                        Cclose(srcptr);

                        // set copy_mode so we don't delete the file in the case where
                        // we're copying the files in a directory to the same directory.
                        if (first_file && (dest->next != NULL && Wild(dest->next)) &&
                            (!source->next)) {
                            copy_mode = COPY;
                        }

                        //
                        // If this is nither CONCAT or TOUCH mode then, this
                        // call will not return but go to copy error code.
                        //
                        source_eq_dest(source,
                                       &destptr,
                                       first_file,
                                       buf_seg,
                                       buf_len,
                                       hnFirst
                                      );
                    }

                    //
                    // save_flags == 0 only if copy modes have not been set
                    //

                    dest_att = GetFileAttributes(curr_dest);
                    if (save_flags == 0) {

                        if (first_dest) {

                            //
                            // Determine if copying to a directory. The assumption
                            // that target is not a directory
                            //
                            dest_dirflag = FALSE;
                            if (dest_att != -1) {

                                if (dest_att & FILE_ATTRIBUTE_DIRECTORY) {

                                    dest_dirflag = TRUE;
                                }
                            }
                            first_dest = FALSE;
                        }

                        source->flags &= ~CI_NOTSET;

                        if (!fEnableExtensions &&
                            Wild(source) && (copy_mode == CONCAT)) {

                            save_cmode = CONCAT;
                            if (dest_dirflag == FALSE) {

                                if (dest->next == NULL || !(Wild(dest->next))) {

                                    source->flags |= CI_ASCII;

                                } else {

                                    source->flags |= CI_BINARY;

                                }
                            }

                        } else {

                            if ((dest_dirflag) && (save_cmode == CONCAT)) {

                                source->flags |= CI_BINARY;

                            }
                        }
                    }

                    if (first_file && (dest->next != NULL && Wild(dest->next)) &&
                        (!source->next)) {

                        copy_mode = COPY;
                    }

                    if (first_file) {

                        if (copy_mode == CONCAT) {

                            if (save_flags == 0) {

                                source->flags &= ~CI_BINARY;
                                source->flags |= CI_ASCII;

                            } else {

                                source->flags = save_flags;
                            }
                        }
                    }

                    // see if destination exists.  open it with write only
                    // access, no create.

                    if (dest_att & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) {
                        DosErr=ERROR_ACCESS_DENIED;
                        destptr = BADHANDLE;
                        if (copy_mode == CONCAT)
                            fFixList2Copy = 1;
                    } else {
                        if (!(source->flags & CI_RESTARTABLE)) {
                            destptr = Copen_Copy3((TCHAR *)curr_dest);
                        }
                    }
                    DestIsDevice=FALSE;
                    if (destptr != BADHANDLE) {
                        OpenWorked = TRUE;
                        if (FileIsDevice(destptr)) {
                            DestIsDevice=TRUE;
                            if (save_flags == 0) {

                                source->flags &= ~CI_BINARY;
                                source->flags |= CI_ASCII ;

                            }
                        }
                    } else {
                        OpenWorked = FALSE;
                    }

                }   // if on (copy_mode != CONCAT) || (first_file))

            } // else from no DosErr on File Read of current source

            if (multfile == TRUE) {

                if (copy_mode == CONCAT) {

                    source->flags &= ~CI_BINARY;
                    if (save_flags == 0) {

                        source->flags |= CI_ASCII;

                    } else {

                        source->flags |= save_flags;
                    }
                }
            }

            if (!Wild(source) && (copy_mode == CONCAT)) {

                if (save_flags == 0) {

                    source->flags &= ~CI_BINARY;
                    source->flags |= CI_ASCII;
                }
            }

            if (Wild(source) && (copy_mode == CONCAT) && (dest_dirflag == FALSE)) {

                if (save_flags == 0) {

                    source->flags &= ~CI_BINARY;
                    source->flags |= CI_ASCII;

                }
            }

            scan_bytes(buf_seg,(unsigned int *)&bytes_read,source->flags);

            if ((copy_mode != CONCAT) && (source->flags & CI_BINARY)) {

                if (destptr != BADHANDLE) {
                    Cclose(destptr);
                    destptr=BADHANDLE;
                }

#ifndef WIN95_CMD


                if (source->flags & CI_RESTARTABLE) {

                    if ( (!FileIsRemote( source->curfspec )) &&
                         (!FileIsRemote( curr_dest )) ) {

                        ReallyRestartable = FALSE;

                    } else {

                        ReallyRestartable = TRUE;

                    }

                    Rslt = (*lpCopyFileExW)(
                        source->curfspec,
                        curr_dest,
                        (LPPROGRESS_ROUTINE) CopyProgressRtn,
                        (LPVOID)IntToPtr(ReallyRestartable),
                        NULL,
                        COPY_FILE_RESTARTABLE | DecryptFlags
                        );

                } else {

                    if (lpCopyFileExW == NULL) {
#endif // WIN95_CMD
                        Rslt = CopyFile(
                                       source->curfspec,
                                       curr_dest,
                                       DecryptFlags
                                       );
#ifndef WIN95_CMD
                    } else {
                        Rslt = (*lpCopyFileExW)(
                                               source->curfspec,
                                               curr_dest,
                                               NULL,
                                               NULL,
                                               &CtrlCSeen,
                                               DecryptFlags
                                               );
                    }
                }
#endif // WIN95_CMD

                if (!Rslt) {

                    unsigned int msg = 0;

                    DosErr=GetLastError();
                    Cclose(srcptr) ;

                    if (DestIsDevice) {

                        msg = ERROR_WRITE_FAULT;

                    }/* else if (DosErr != ERROR_NO_MEDIA_IN_DRIVE &&
                               DosErr != ERROR_ACCESS_DENIED) {

                        DeleteFile( curr_dest );
                    } */

                    Heof = FALSE;
                    if (!DosErr) {

                        DosErr = ERROR_DISK_FULL ;

                    }

                    if (CtrlCSeen) {
                        msg = 0;

                    } else {

                        if (!msg) {
                            PrtErr(DosErr);
                        }

                    }
                    if (!OpenWorked) {
                        // copy failed because target was RO or hidden
                        rc = FAILURE;
                        first_fflag = TRUE;
                        continue;
                    }

                    copy_error(msg,CE_PCOUNT);

                } else
                    if (!DestIsDevice) {
                    //
                    // CopyFile preserves Read-Only. For DOS compat. need
                    // to remove.
                    //
                    DWORD   dwAttrib;

                    dwAttrib = GetFileAttributes(curr_dest);
                    dwAttrib &= ~FILE_ATTRIBUTE_READONLY;
                    SetFileAttributes(curr_dest, dwAttrib);

                    // need to get a handle to verify write.

                    if (VerifyCurrent) {
                        destptr = Copen2((TCHAR *)curr_dest,
                                         (unsigned int)O_WRONLY,
                                         FALSE);

                        if (destptr == BADHANDLE) {
// printf( "do_normal_copy: Unable to open file for verification %d\n", DosErr);
                            PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
                            goto l_out;
                        }

                        if ( FileIsDevice(destptr) ) {
// printf( "do_normal_copy: Somehow this is now a device for verification?\n" );
                            Cclose(destptr);
                            destptr=BADHANDLE;
                            goto l_out;
                        }

                        if (!FlushFileBuffers ( CRTTONT(destptr) ) ) {
// printf( "do_normal_copy: Unable to flush buffers verification %d\n", GetLastError( ));
                            PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
                            Cclose(destptr);
                            destptr=BADHANDLE;
                            goto l_out;
                        }

                        Cclose(destptr);
                        destptr=BADHANDLE;


                        // read the Src and Dest files back to memory and compare.

                        destptr = Copen_Copy2(curr_dest, (ULONG)O_RDONLY);

                        if (destptr == BADHANDLE) {
// printf( "do_normal_copy: Unable to open file for verification 2 %d\n", DosErr);
                            PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
                            goto l_out;
                        }

                        if ( FileIsDevice(destptr)  ) {
// printf( "do_normal_copy: Somehow this is now a device for verification 2?\n" );
                            PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
                            Cclose(destptr);
                            destptr=BADHANDLE;
                            goto l_out;
                        }

                        SetFilePointer( CRTTONT(srcptr),  0, NULL, FILE_BEGIN);
                        SetFilePointer( CRTTONT(destptr), 0, NULL, FILE_BEGIN);

                        dwSrcFileSize  = GetFileSize( CRTTONT(srcptr),  &dwSrcFileSizeHigh);
                        dwDestFileSize = GetFileSize( CRTTONT(destptr), &dwDestFileSizeHigh);

                        if ( (dwSrcFileSize != dwDestFileSize) || (dwSrcFileSizeHigh != dwDestFileSizeHigh ) ) {
// printf( "do_normal_copy: Files are different sizes %x:%08x %x:%08x\n", dwSrcFileSizeHigh, dwSrcFileSize, dwDestFileSizeHigh, dwDestFileSize );
                            PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
                            Cclose(destptr);
                            destptr=BADHANDLE;
                            goto l_out;
                        }

                        fEof = 0;

                        while (!fEof) {

                            if (!ReadFile( CRTTONT(srcptr), buf_seg, buf_len, &bytes_read,NULL ) ) {
// printf( "do_normal_copy: Failure to read source block - %d\n", GetLastError( ));
                                Cclose(destptr);
                                destptr=BADHANDLE;
                                goto l_out;
                            }

                            if ( bytes_read == 0 ) {
// printf( "do_normal_copy: Unexpectedly read 0 bytes from source\n" );
                                Cclose(destptr);
                                destptr=BADHANDLE;
                                goto l_out;
                            }


                            if (!ReadFile( CRTTONT(destptr), buf_seg_dest, bytes_read, &bytes_read_dest,NULL) ) {
// printf( "do_normal_copy: Failure to read dest block - %d\n", GetLastError( ) );
                                Cclose(destptr);
                                destptr=BADHANDLE;
                                PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
                                goto l_out;
                            }

                            if (bytes_read_dest != bytes_read ) {
// printf( "do_normal_copy: Unexpectedly read fewer bytes\n" );
                                Cclose(destptr);
                                destptr=BADHANDLE;
                                PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
                                goto l_out;
                            }

                            if (buf_len != bytes_read)
                                fEof = 1;

                            if ( memcmp (buf_seg, buf_seg_dest, bytes_read) != 0 ) {
// printf( "do_normal_copy: Data is different at offset %x\n", memcmp (buf_seg, buf_seg_dest, bytes_read) );
                                Cclose(destptr);
                                destptr=BADHANDLE;
                                PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
                                goto l_out;
                            }
                        }

                        Cclose(destptr);
                        destptr=BADHANDLE;
                    }

                    l_out:              ;
                    // check file timestamp in FUTURE to handle wildcard.
                }

            } else {

                //
                // open the destination
                //

                if (destptr == BADHANDLE) {
                    destptr = Copen2((TCHAR *)curr_dest,
                                     (unsigned int)O_WRONLY,
                                     FALSE);

                    if (destptr == BADHANDLE) {

                        Cclose(srcptr) ;
                        if (cdevfail == FALSE) {

                            PrtErr(DosErr);

                        }
                        if ( copy_mode != CONCAT ) {

                            rc = FAILURE;
                            first_fflag = TRUE;
                            continue;
                        }

                        findclose(hnFirst);
                        copy_error(0,CE_PCOUNT) ;

                    }
                }

                //
                //  Handle appending of unicode text files with byte order marks.
                //  Do this except on the first file and only when appending
                //  ascii files.
                //

                if (!first_file
                    && copy_mode == CONCAT
                    && (source->flags & CI_ASCII) != 0
                    && (source->flags & CI_UNICODE) != 0) {

                    bytes_read -= sizeof( WORD );
                    memmove( buf_seg, buf_seg + sizeof( WORD ), bytes_read );
                }

                if ((source->flags & CI_UNICODE) != 0) {
                    if (dest->next != NULL) {
                        dest->next->flags |= CI_UNICODE;
                    } else {
                        dest->flags |= CI_UNICODE;
                    }
                }

                //
                // If eof and bytesread > 0 then write the data.
                // If fail then exit through write_bytes
                //
                if (Heof && ((int)bytes_read > 0)) {

                    write_bytes(destptr,buf_seg,bytes_read,curr_dest,srcptr);

                    if (VerifyCurrent && !FileIsDevice(destptr) ) {
                        if ( DoVerify(&destptr, curr_dest, bytes_read, buf_seg, buf_seg_dest) == FAILURE ) {
                            findclose(hnFirst);
                            copy_error(0,CE_PCOUNT) ;
                        }
                    }

                } else {

                    //
                    // Loop through writing and reading bytes
                    // If fail then exit through write_bytes
                    //

                    while (!Heof && (rcode == TRUE)) {

                        write_bytes(destptr,buf_seg,bytes_read,curr_dest,srcptr);

                        if (VerifyCurrent && !FileIsDevice(destptr) ) {

                            if ( DoVerify(&destptr, curr_dest, bytes_read, buf_seg, buf_seg_dest) == FAILURE ) {
                                findclose(hnFirst);
                                copy_error(0,CE_PCOUNT) ;
                            }
                        }

                        rcode = read_bytes(srcptr,
                                           buf_seg,
                                           buf_len,
                                           (PULONG)&bytes_read,
                                           source,
                                           destptr,
                                           curr_dest);

                        DEBUG((FCGRP,COLVL,"In rd/wt loop 1, Heof = %d",Heof));

                    }

                    if (Heof && ((int)bytes_read > 0) && (rcode == TRUE)) {

                        write_bytes(destptr,buf_seg,bytes_read,curr_dest,srcptr);

                        if (VerifyCurrent && !FileIsDevice(destptr) ) {

                            if ( DoVerify(&destptr, curr_dest, bytes_read, buf_seg, buf_seg_dest) == FAILURE ) {
                                findclose(hnFirst);
                                copy_error(0,CE_PCOUNT) ;
                            }
                        }
                    }
                }
            }

            //
            // Clear when src closed
            //
            Heof = FALSE ;
            DEBUG((FCGRP,COLVL,"Closing, Heof reset to %d",Heof));

            //
            // update file data in dir
            //
            src_dateTime = source->buf->ftLastWriteTime ;
            Cclose(srcptr);

            //
            // keep dest open if concat since it will be used again
            //
            if (copy_mode != CONCAT) {

                if (CtrlCSeen) {
                    Cclose(destptr);
                    DeleteFile(curr_dest);
                    rc = FAILURE;
                } else {
                    close_dest(source,dest,curr_dest,destptr,&src_dateTime);
                }

                //
                // reset EA xfer flag from src
                //
                first_fflag = TRUE;
            }

            first_file = FALSE;

        } while (fnext( (PWIN32_FIND_DATA)source->buf, (unsigned int)FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_ARCHIVE,hnFirst));

        findclose(hnFirst) ;
    }

    //
    // Remember that dest was left open for concat
    //
    if (copy_mode == CONCAT && destptr != BADHANDLE) {

        close_dest(source,dest,curr_dest,destptr,NULL);

    }

    return( rc );
}




/***    source_eq_dest - Handles cases where source and dest files are same
 *
 *  Purpose:
 *      While copying, we ran across a source and destination that
 *      were the same.  In concatenation or touch mode this is
 *      acceptable, otherwise it isn't.  If we are concatenating
 *      and this is the first file, we can just open it for appending
 *      as the destination.  We save ourselves the copy and are ready
 *      to append the other files to it.  If this isn't the first
 *      file, * we have already messed up the contents of the source
 *      from previous concatenations, so we report that but keep
 *      going.  If we are doing a touch, go ahead and do it and
 *      increment the file counter.
 *
 *  int source_eq_dest(PCPYINFO source,int *destptr,int *first_file,
 *                      TCHAR *buf_seg, unsigned buf_len)
 *
 *  Args:
 *      source     = Source copy information structure
 *      destptr    = Destination file handle
 *      first_file = First file flag
 *      buf_seg    = Copy buffer
 *      buf_len    = Buffer length
 *
 *  Returns:
 *      Nothing.  Terminates through copy_error if unable to continue
 *
 */

void
source_eq_dest(source, destptr, first_file, buf_seg, buf_len, hnFirst)
PCPYINFO source;
CRTHANDLE *destptr;                  /* dest file handle                */
int first_file;
CHAR *buf_seg ;
unsigned buf_len;
HANDLE hnFirst;          /* ffirst/fnext handle @@5@J15 */
{
    CRTHANDLE fh ;      /*  file handle for touch              */
    FILETIME FileTime;

    DEBUG((FCGRP,COLVL,"SourceEqDest: Entered."));

    if (copy_mode == CONCAT) {   /* it's ok in concat mode          */
        if (!first_file) {        /* dest was wiped if not 1st file  */
/* M016 */
            PutStdOut(MSG_CONT_LOST_BEF_COPY, NOARGS);
        } else {                    /* must open so later files append */
            *destptr = open_for_append(
                                      source->curfspec,
                                      source,
                                      buf_seg,
                                      (unsigned int)buf_len
                                      );
        }
    } else {
        if (copy_mode == TOUCH) {    /*  just touch - no copy           */
            DEBUG((FCGRP,COLVL,"touching file"));

            fh = Copen2(        /* open file for destination file */
                                (TCHAR *)source->curfspec,  /* explicit cast */
                                (unsigned int)O_RDWR,    /* make explicit cast */
                                TRUE);

            if (fh == BADHANDLE) {
                findclose(hnFirst);
                PrtErr(ERROR_OPEN_FAILED) ;             /* M019    */
                copy_error(0,CE_PCOUNT) ;               /* M019    */
            }

            ConverttmToFILETIME( NULL, &FileTime );
            SetFileTime( CRTTONT(fh),
                         NULL,
                         NULL,
                         &FileTime
                       );
            Cclose(fh);
            number_of_files_copied++;
        } else {
            findclose(hnFirst);   /* close ffirst/fnext handle for dup file name @@5@J15 */
            copy_error(MSG_CANNOT_COPIED_ONTO_SELF,CE_PCOUNT);   /* M016 */
        }
    }
}




/***    do_combine_copy - Handle combining copy commands
 *
 *
 *  Purpose:
 *      This handles commands like "copy *.tmp+*.foo *.out".  The
 *      idea is to look through the source specs until one matches
 *      a file.  Generally this will be the first one.  Then, for
 *      each match for the first spec, cycle through the remaining
 *      source specs, seeing if they have a corresponding match.  If
 *      so, append it to the file matched by the first spec.
 *
 *  int do_combine_copy(PCPYINFO source, PCPYINFO dest)
 *
 *  Args:
 *      source = The source copy information structure
 *      dest   = The destination copy information structure
 *
 *  Returns:
 *      SUCCESS if able to perform the copy
 *      FAILURE if not
 *
 *  Notes:
 *      As an example, suppose the files a.tmp, b.tmp, c.tmp, and
 *      b.foo were in the current directory.  The example mentioned
 *      above would: copy a.tmp to a.out, append b.tmp and b.foo
 *      into b.out, and copy c.tmp to c.out.  The default mode when
 *      doing this type of copy is ascii, so all the .out files would
 *      have a ^Z appended to them.
 *
 */
do_combine_copy(source, dest)
PCPYINFO source;
PCPYINFO dest;
{
    TCHAR curr_dest[MAX_PATH];   /* buffer for src names      */
    TCHAR source_buff[MAX_PATH];           /* @@4 */
    TCHAR other_source[MAX_PATH];          /* same                    */
    PCPYINFO other_source_spec = source;     /* ptr to source   */
    CRTHANDLE srcptr,destptr;               /* file pointers           */
    unsigned buf_len,                       /* for GetBigBuf()         */
    buf_len_dest,
    bytes_read;                    /* for data copying funcs  */
    CHAR     *buf_seg ;
    CHAR     *buf_seg_dest;
    HANDLE   hnFirst ;
    unsigned rcode = TRUE;                  /* ret code from read @@J  */
    unsigned wrc;
    int      dest_att=0;

    DEBUG((FCGRP,COLVL,"DoCombineCopy: Entered."));

    buf_seg = (CHAR*)GetBigBuf(MAXCOPYBUFSIZE, MINCOPYBUFSIZE, (unsigned int *)&buf_len, 0);                        /* allocate large buffer   */

    if (!buf_seg) {
        return(FAILURE) ;
    }

    if (VerifyCurrent) {
        buf_seg_dest = (CHAR*)GetBigBuf(buf_len, MINCOPYBUFSIZE, (unsigned int *)&buf_len_dest, 1);               /* allocate large buffer   */

        if (!buf_seg_dest) {
            return(FAILURE) ;
        }

        buf_len = min(buf_len, buf_len_dest);
    }

/* find the first spec with any matching files  */
    source = source->next;                  /* point to first source   */
    while (!exists(source->fspec)) {
        DEBUG((FCGRP,COLVL,"exists() reports file %ws non-existant",source->fspec));

        if (!(source = source->next)) {       /* no match, try next spec */
            return(SUCCESS);                 /* no match for any source */
        }
    }

    DEBUG((FCGRP,COLVL,"Preparing to do ffirst  on %ws",source->fspec));

    ffirst(                                   /* get DOSFINDFIRST2 level 2 @@5@J1 */
                                              (TCHAR *)source->fspec,    /* make explicit cast               @@5@J1 */
                                              (unsigned int)FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_ARCHIVE,
                                              (PWIN32_FIND_DATA)source->buf,   /* make explicit cast               @@5@J1 */
                                              &hnFirst);

/* cycle through files, trying to match with other source specs  */
    do {

        source->flags &= ~(CI_UNICODE | CI_NOT_UNICODE);
        rcode = TRUE;
        if (source->flags & CI_NOTSET) {                                    /* set default copy mode      */
            source->flags = (source->flags & ~CI_NOTSET) | CI_ASCII;
        }

        if (CtrlCSeen) {
            findclose(hnFirst) ;
            return(FAILURE);
        }
        if (get_full_name(source, source_buff) == FAILURE) {          /* @@4 */
            findclose(hnFirst);
            return(FAILURE) ;              /* get matching file name     */
        }

        cmd_printf(Fmt17,source->curfspec);   /* and print it       */
        if (get_dest_name(source,dest,curr_dest,MAX_PATH,FALSE) == FAILURE) {
            findclose(hnFirst);
            return(FAILURE);     /* get full name of src */
        }

        //
        // If user said no to overwrite, then skip this file.
        //
        if (curr_dest[0] == NULLC)
            continue;
        if (same_file(source->curfspec,curr_dest)) {      /* append     */
            destptr = open_for_append(
                                     source->curfspec,
                                     source,
                                     buf_seg,
                                     (unsigned int)buf_len);
        } else {
            DEBUG((FCGRP,COLVL,"open %ws for reading",source->curfspec));
            DEBUG((FCGRP,COLVL,"open %ws for writing",curr_dest));

            srcptr = Copen_Copy2(          /* open a source file */
                                           (TCHAR *)source->curfspec,   /* using this file name */
                                           (unsigned int)O_RDONLY); /* for read-only */

            if (srcptr == BADHANDLE) {         /* if open failed  then */
                /*   then   */
                findclose(hnFirst);
                PrtErr(ERROR_OPEN_FAILED);    /*   display error */
                copy_error(0,CE_PCOUNT);
            }

            if (FileIsDevice(srcptr)) {
                buf_len = MINCOPYBUFSIZE;
            }
/* @@J */rcode = read_bytes( srcptr,buf_seg,   /* read first src data   */
/* @@J */                          buf_len,
                             (PULONG)&bytes_read,     /* to see if src bad     */
/* @@J */                          source,
                             destptr,
                             curr_dest);      /* if bad do not open    */

/* @@J */

if (DosErr )
            /* @@J */
            {
                /* dest file.                 */
                findclose(hnFirst);
/* M011 @@J */Cclose(srcptr) ;         /* close soure file           */
/* @@J */PrtErr(ERROR_OPEN_FAILED) ;         /* display error message      */
/* @@J */copy_error(0,CE_PCOUNT) ;   /* catch all copy terminate   */
/* @@J */
            }                            /* routine and display # files*/
/* @@J */
            else                           /* copied trailer info        */
            /* @@J */
            {

                dest_att = GetFileAttributes(curr_dest);

                if ( ! (dest_att & FILE_ATTRIBUTE_HIDDEN) )
                    destptr = Copen_Copy3((TCHAR *)curr_dest);
                else
/* @@5 @J1*/         destptr = Copen2(           /* open destination file */
                                                 (TCHAR *)curr_dest,    /* filename */
                                                 (unsigned int)O_WRONLY,
                                                 FALSE);

/* M011@@J */

if (destptr == BADHANDLE)       /* if open failed        @@5@J1*/
                /* @@J */
                {
                    /* then                        */
                    findclose(hnFirst);
/* M011 @@J */Cclose(srcptr) ;            /* Close src on dst open err   */
/* @@J */PrtErr(ERROR_OPEN_FAILED) ;
/* @@J */copy_error(0,CE_PCOUNT) ;
/* @@J */
                }
            }
/* @@J */      if (Heof && ((int)bytes_read > 0 )) /*  if eof but bytes read */
            /* @@J */
            {
         /*  then write data and       */
/* @@J */                                     /*  if fail then will exit    */
/* @@J */
                write_bytes(destptr,buf_seg,bytes_read,curr_dest,srcptr);

                if (VerifyCurrent && !FileIsDevice(destptr) ) {
                    if ( DoVerify(&destptr, curr_dest, bytes_read, buf_seg, buf_seg_dest) == FAILURE ) {
                        findclose(hnFirst);
                        Cclose(srcptr);
                        Cclose(destptr);
                        copy_error(0,CE_PCOUNT) ;
                    }
                }

/* @@J */
            }
/* @@J */                                       /*                          */
/* @@J */while (!Heof && (rcode == TRUE)) /* while not at EOF or bad rc */
            /* @@J */
            {
         /*  perform copy loop       */
/* @@J */                                       /*  if fail then will exit  */
/* @@J */
                write_bytes(destptr,buf_seg,bytes_read,curr_dest,srcptr);
/* @@J */                                       /*                          */
                if (VerifyCurrent && !FileIsDevice(destptr) ) {
                    if ( DoVerify(&destptr, curr_dest, bytes_read, buf_seg, buf_seg_dest) == FAILURE ) {
                        findclose(hnFirst);
                        Cclose(srcptr);
                        Cclose(destptr);
                        copy_error(0,CE_PCOUNT) ;
                    }
                }

/* @@J */rcode = read_bytes(srcptr,buf_seg, /*  read next src data */
/* @@J */             buf_len,(PULONG)&bytes_read,
/* @@J */             source,destptr,curr_dest);
/* @@J */
/* @@J */DEBUG((FCGRP,COLVL,"Closing, Heof reset to %d",Heof));
/* @@J */
/* @@J */
            };
            Heof = FALSE ;          /* Clear when src closed   */

            Cclose(srcptr);                         /* M011 */
        }

        first_file = FALSE;       /* set first file processed @@5@J1 */
/*  The source is handled, now cycle through the other wildcards that
 * were entered and see if they match a file that should be appended.
 * If the file they match is the same as the destination, report
 * contents lost and keep going.  Ex: "copy *.a+b*.b b.*" where a.b
 * and b.b exist.  b*.b matches b.b but the target file is b.b and
 * its contents were already destroyed when a.b was copied into it.
 */

        other_source_spec = source;
        while (other_source_spec = other_source_spec->next) {
            if (other_source_spec->flags & CI_NOTSET) {
                other_source_spec->flags &= ~CI_NOTSET;
                other_source_spec->flags |= CI_ASCII;
            }
            wrc = wildcard_rename(                             /* rename filename for wild      */
                                                               (TCHAR *)other_source,                    /* result filename               */
                                                               (TCHAR *)other_source_spec->fspec,        /* dest   input filename         */
                                                               (TCHAR *)source->curfspec,                /* source input filename         */
                                                               (unsigned)MAX_PATH);                      /* size of result filename area  */
            if (wrc) {
                PutStdOut(wrc,NOARGS);
            } else {
                cmd_printf(Fmt17,other_source); /* print filename  */
            }
            if (exists(other_source)) {
                if (same_file(other_source,curr_dest)) {
/* M016 */
                    PutStdOut(MSG_CONT_LOST_BEF_COPY,NOARGS);
                } else {            /* append to curr_dest     */
                    DEBUG((FCGRP,COLVL,
                           "open %s for reading",
                           other_source));

/* @@5 @J1 */

srcptr = Copen_Copy2(                 /* open a source file            @@5@J1*/
                                      (TCHAR *)other_source,/* using this file name          @@5@J1*/
                                      (unsigned int)O_RDONLY);      /* for read-only                 @@5@J1*/
                                                                    /*                               @@5@J1*/
                    if (srcptr == BADHANDLE) {  /* if open failed  then */
                        /*   then                              */
                        findclose(hnFirst);
                        Cclose(destptr);                   /*   close destination file            */
                        PrtErr(ERROR_OPEN_FAILED) ; /* M019    */
                        copy_error(0,CE_PCOUNT) ;    /* M019    */
                    }

                    if (FileIsDevice( srcptr )) {
                        buf_len = MINCOPYBUFSIZE;
                    }
                    while (!Heof && read_bytes(srcptr,
                                               buf_seg,
                                               buf_len,
                                               (PULONG)&bytes_read,
                                               other_source_spec,
                                               destptr,curr_dest)) {

                        write_bytes(destptr,
                                    buf_seg,
                                    bytes_read,
                                    curr_dest,
                                    srcptr);

                        if (VerifyCurrent && !FileIsDevice(destptr) ) {
                            if ( DoVerify(&destptr, curr_dest, bytes_read, buf_seg, buf_seg_dest) == FAILURE ) {
                                findclose(hnFirst);
                                Cclose(srcptr);
                                Cclose(destptr);
                                copy_error(0,CE_PCOUNT) ;
                            }
                        }


                        DEBUG((FCGRP,COLVL,
                               "In rd/wt loop 3, Heof = %d",
                               Heof));
                    } ;
                    Heof = FALSE ;  /* M017 - Clear it  */

                    DEBUG((FCGRP,COLVL,"Closing, Heof reset to %d",Heof));
                    Cclose(srcptr);         /* M011 */
                }
            }

        }

        close_dest(source,dest,curr_dest,destptr,NULL);
/*@@5@J3*/first_fflag = TRUE;
    } while (fnext ((PWIN32_FIND_DATA)source->buf,
                    (unsigned int)FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_ARCHIVE, hnFirst));


    findclose(hnFirst) ;
    return( SUCCESS );
}




/***    NewCpyInfo - Init the cpyinfo struct
 *
 *  Purpose:
 *      Allocate space for a cpyinfo struct and fill it in with null values.
 *
 *  CPYINFO NewCpyInfo()
 *
 *  Args:
 *      None
 *
 *  Returns:
 *      Pointer to cpyinfo struct if allocated,
 *      ABORT's if not.
 *
 *  Notes:
 *                      *** W A R N I N G ! ***
 *      THIS ROUTINE WILL CAUSE AN ABORT IF MEMORY CANNOT BE ALLOCATED
 *              THIS ROUTINE MUST NOT BE CALLED DURING A SIGNAL
 *              CRITICAL SECTION OR DURING RECOVERY FROM AN ABORT
 */

PCPYINFO
NewCpyInfo( VOID ) 
{
    PCPYINFO temp;

    DEBUG((FCGRP,COLVL,"InitStruct: Entered."));

    temp = (PCPYINFO) gmkstr(sizeof(CPYINFO)); /*WARNING*/
    temp->fspec = NULL;
    temp->flags = 0;
    temp->next = NULL;
    return(temp);
}




/***    close_dest - Handle close operation on destination file
 *
 *  Purpose:
 *    o Append a control-Z to the destination if the copy mode for it
 *      is ascii.  If a destination wasn't specified, the dest spec
 *      points to the empty header, the next field is NULL, and the
 *      parser put the copy mode into the empty header's flags field.
 *      If the dest was specified, then the mode is in the struct
 *      pointed to by the header.
 *
 *    o Set all the appropriate attributes.  Read-only and system
 *      don't stay, but the rest do.  Also, set the time and date if
 *      neither source nor target is a device and src_date is valid.
 *      The caller tell us it isn't valid by setting it to -1.
 *
 *    o Close the destination file.
 *
 *    o Update the number of files copied.
 *
 *  int close_dest(PCPYINFO source,PCPYINFO dest,
 *                 TCHAR *curr_dest,int destptr,LPFIMETIME src_dateTime)
 *
 *  Args:
 *      source    = Source copy information structure
 *      dest      = Source copy information structure
 *      curr_dest = Filename of current destination
 *      destptr   = Handle of current destination
 *      src_dateTime = Date and time of source file
 *
 *  Returns:
 *      Nothing
 *
 */

void
close_dest(
          PCPYINFO source,
          PCPYINFO dest,
          TCHAR *curr_dest,
          CRTHANDLE destptr,
          LPFILETIME src_dateTime
          )
{
    TCHAR contz = CTRLZ;
    DWORD bytes_writ ;
    PCPYINFO RealDest = dest->next != NULL ? dest->next : dest;

    DBG_UNREFERENCED_PARAMETER( curr_dest );

/* Append a ^Z if the destination was in ascii mode.  Don't check if
 * the write was successful as it is a waste of time anyway.
 */
    DEBUG((FCGRP,COLVL,"CloseDest: Entered."));

    if (DestinationNeedsCtrlZ( RealDest ) && !FileIsDevice( destptr )) {
        WriteFile( CRTTONT( destptr ), &contz, 1, &bytes_writ, NULL);
    }

/*  if source and dest aren't devices, we aren't touching, and the
 *  src_date is valid, set time and date
 *
 *         THE REMAINING DATE AND TIME VALUES MUST BE ZERO UNTIL
 *         THEY ARE FULLY IMPLIMENTED OR WILL CAUSE ERROR
 */
    if (source && !(source->flags & CI_ISDEVICE) && !FileIsDevice(destptr) &&
        (copy_mode != CONCAT) && (src_dateTime != NULL) && (copy_mode != TOUCH)) {
        SetFileTime( CRTTONT(destptr),
                     NULL,
                     NULL,
                     src_dateTime
                   );
    }
    Cclose(destptr);                                        /* M011 */
    number_of_files_copied++;
}

/***    get_dest_name - Create destination filename
 *
 *  Purpose:
 *      Given the source file and the destination filespec,
 *      come up with a destination name.
 *
 *  int get_dest_name(PCPYINFO source, PCPYINFO dest_spec,
 *                    TCHAR *dest_name)
 *
 *  Args:
 *      source    = Source copy information structure
 *      dest_spec = Destination copy information structure
 *      dest_name = Buffer to place the destination name in
 *
 *  Returns:
 *      Nothing
 *
 */
int
get_dest_name(
             PCPYINFO source,
             PCPYINFO dest,
             TCHAR *dest_name,
             unsigned sizbufr,
             BOOL checkmeta
             )
{
    TCHAR *i ;
    TCHAR *x, *y;
    TCHAR c;
    int retval = SUCCESS;
    unsigned rcode = NO_ERROR;
    PCPYINFO dest_spec;
    TCHAR FullName[MAX_PATH];

    DEBUG((FCGRP,COLVL,"GetDestName: Entered."));

    dest_spec = dest->next;
    if (dest_spec == NULL) {
        mystrcpy(dest_name,CurDrvDir);

        i= 0;
        y= dest_name + mystrlen(dest_name);
        for (x=dest_name; x < y; ++x) {
            c=*x;
            if (*x == PathChar) {
                i =  x;
            }
        }
        if ((i == NULLC) || (i < y-1)) {
            *y = PathChar;
            *(y+1) = NULLC;
        }

        if (!(source->flags & CI_SHORTNAME) ||
            (mystrlen(source->buf->cAlternateFileName) == 0)) {
            if ((mystrlen(dest_name) + 1 +
                 mystrlen(source->buf->cFileName))
                > MAX_PATH) {
                retval = FAILURE;
            } else {
                mystrcat(dest_name,source->buf->cFileName);
            }
        } else {
            if ((mystrlen(source->buf->cAlternateFileName) == 0) ||
                (mystrlen(dest_name) + 1 +
                 mystrlen(source->buf->cAlternateFileName))
                > MAX_PATH) {
                retval = FAILURE;
            } else {
                mystrcat(dest_name,source->buf->cAlternateFileName);
            }

        }
    } else {
        if (*(lastc(dest_spec->fspec)) == COLON) {
            if (!(source->flags & CI_SHORTNAME)||
                (mystrlen(source->buf->cAlternateFileName) == 0)) {
                if ((mystrlen(dest_spec->fspec) + 1 +
                     mystrlen(source->buf->cFileName))
                    > MAX_PATH) {
                    retval = FAILURE;
                } else {
                    mystrcpy(dest_name,dest_spec->fspec);
                    mystrcat(dest_name,source->buf->cFileName);
                }
            } else {
                if ((mystrlen(source->buf->cAlternateFileName) == 0) ||
                    (mystrlen(dest_spec->fspec) + 1 +
                     mystrlen(source->buf->cAlternateFileName))
                    > MAX_PATH) {
                    retval = FAILURE;
                } else {
                    mystrcpy(dest_name,dest_spec->fspec);
                    mystrcat(dest_name,source->buf->cAlternateFileName);
                }
            }
        } else {

            // this code does short name substitution when copying from
            // an NTFS volume to a FAT volume.
            if (checkmeta &&
                (*(lastc(dest_spec->fspec)) == STAR) &&
                (*(penulc(dest_spec->fspec)) == BSLASH)) {
                TCHAR *LastComponent;

                LastComponent = mystrrchr(source->curfspec,'\\');
                if (LastComponent) {
                    // skip the \.
                    LastComponent++;
                } else {
                    if (source->curfspec[1] == COLON) {
                        LastComponent = &source->curfspec[2];
                    } else {
                        LastComponent = source->curfspec;
                    }
                }
                if ((source->flags & CI_SHORTNAME) &&
                    (mystrlen(source->buf->cAlternateFileName) != 0) ) {
                    mystrcpy(LastComponent,source->buf->cAlternateFileName);
                }
            }
            rcode = wildcard_rename(
                                   (TCHAR *)dest_name,
                                   (TCHAR *)dest_spec->fspec,
                                   (TCHAR *)source->curfspec,
                                   (unsigned)sizbufr);
            if (rcode) {
                PrtErr(rcode);
                retval = FAILURE;
            }

            if (GetFullPathName( dest_name, MAX_PATH, FullName, NULL) > MAX_PATH) {
                PrtErr( ERROR_BUFFER_OVERFLOW );
                retval = FAILURE;
            }
        }
    }

    if (checkmeta &&
        ((dest_spec != NULL && (dest_spec->flags & CI_PROMPTUSER) != 0) ||
         (dest->flags & CI_PROMPTUSER) != 0)) {

        HANDLE Handle = CreateFile( dest_name,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    0 );
        BOOL IsFile = FALSE;

        if (Handle != INVALID_HANDLE_VALUE) {
            IsFile = (GetFileType( Handle ) & ~FILE_TYPE_REMOTE) == FILE_TYPE_DISK;
            CloseHandle( Handle );
        }

        if (IsFile) {
            switch (PromptUser(dest_name, MSG_MOVE_COPY_OVERWRITE, MSG_NOYESALL_RESPONSE_DATA)) {
            case 0: // No
                dest_name[0] = NULLC;
                break;
            case 2: // All
                if (dest_spec != NULL)
                    dest_spec->flags &= ~CI_PROMPTUSER;
                else
                    dest->flags &= ~CI_PROMPTUSER;
            default: // Yes
                break;
            }
        }
    }

    return(retval);
}





/***    wildcard_rename - Obtain name from wildcard spec
 *
 *  Purpose:
 *      This function converts the filenames into a nice clean form
 *      with get_clean_filename.  Then it extracts the correct
 *      filename using the wildcard renaming rules.  Basically,
 *      you have a template with wildcards in it, and a source
 *      filename.  Any time there is a letter in the template, it
 *      gets used.  Where the template has a wildcard, use the
 *      letter from the source filename.
 *
 *  int wildcard_rename(TCHAR *buffer, TCHAR *dest, TCHAR *source)
 *
 *  Args:
 *      OutputBuffer = The buffer to put the name in
 *      dest   = The destination filespec
 *      source = The source filename
 *
 *  Returns:
 *      Nothing
 *
 *  Notes:
 *      As an example, *.out + foo.bar = foo.out.  A more extreme
 *      example is: filename.ext + a?b??c*foo.?a* = aibencme.eat.
 *      The foo, because it comes after the '*', is ignored.  The
 *      dot causes the template's letters to be significant again.
 *
 */

unsigned
wildcard_rename(
               TCHAR *OutputBuffer,
               const TCHAR *dest,
               const TCHAR *source,
               ULONG sizbufr
               )
{

    TCHAR dest_buffer[MAX_PATH];
    unsigned wrc = 0;
    const TCHAR *temp1, *temp2;

    DEBUG((FCGRP,COLVL,"WildcardRename: Entered."));

    //
    //  Find the filename component.  The filename is the first
    //  character after the last \ or, if none, after the first : or,
    //  if none, the first character.
    //

    temp1 = mystrrchr( source, PathChar );
    if (temp1 == NULLC) {
        if (source[0] != TEXT( '\0' ) && source[1] == COLON) {
            temp1 = source + 2;
        } else {
            temp1 = source;
        }
    } else {
        temp1++;
    }

    //
    //  Find the filename component.  The filename is the first
    //  character after the last \ or, if none, after the first : or,
    //  if none, the first character.
    //

    temp2 = mystrrchr(dest,PathChar);
    if (temp2 == NULLC) {
        temp2 = mystrchr(dest, COLON);
        if (temp2 && (temp2 - dest == 1)) {
            ++temp2;
        } else {
            temp2 = dest;
        }
    } else {
        ++temp2;
    }

    wrc = WinEditName( temp1,
                       temp2,
                       dest_buffer,
                       sizbufr );


    if (wrc) {
        *OutputBuffer = NULLC;
    }
/*temp fix */
    else if (temp2 != dest) {

        if (mystrlen(dest) > MAX_PATH ) {
            wrc = ERROR_BUFFER_OVERFLOW;
            return(wrc);
        }

        mystrcpy( OutputBuffer, dest );
        *(OutputBuffer + (temp2-dest)) = NULLC;
        if ( mystrlen( OutputBuffer )+mystrlen(dest_buffer)+1 > MAX_PATH ) {
            wrc = ERROR_BUFFER_OVERFLOW;
        } else {
            mystrcat( OutputBuffer, dest_buffer );
        }
    } else {
        mystrcpy( OutputBuffer, dest_buffer );
    }


    return(wrc);
}


/***    scan_bytes - Scan bytes from file for Control-Z
 *
 *  Purpose:
 *      This just calls ZScanA.  It is called with a
 *      and some variables needed by ZScanA routine.
 *      Since we are reading in ASCII mode,
 *      we need to truncate after a ^Z is read.  ZScanA does this,
 *      changing bytes_read to the new length if it finds one.
 *
 *  int scan_bytes(int srcptr,unsigned int *buf_seg,unsigned buf_len,
 *                 unsigned *bytes_read,int mode,
 *                 int dstptr, TCHAR *dest_name );
 *
 *  Args:
 *      buf_seg    = Buffer address
 *      bytes_read = Location to put bytes read
 *      mode       = Read mode
 *      dstptr     = Handle of file to write
 *
 *  Returns:
 *      TRUE if read successful
 *      FALSE if not
 *
 */

scan_bytes(buf_seg,bytes_read,mode)                              /* @@6 */
CHAR *buf_seg ;                                                  /* @@6 */
unsigned int *bytes_read ;                                       /* @@6 */  /* @@5@J16 */
int mode;                                                        /* @@6 */
{                                                                /* @@6 */
    unsigned rdsav;                     /* storage for ZScanA */ /* @@6 */
    int skip_first_byte = 0;      /* storage for ZScanA */ /* @@6 */

/*************************************************************************/
/* if we are copying source in ascii mode, strip bytes after ^Z          */
/*  M017 - ^Z was not terminating input because although input was       */
/*  truncated, the caller had no idea that EOF had occurred and would    */
/*  read again.  This is especially true with devices.                   */
/*************************************************************************/
/* @@6 */if (TruncateOnCtrlZ( mode )) {
/* @@6 */
        rdsav = *bytes_read;
        if (rdsav == 0) {               /* if len = 0 @@5@J16 */
            Heof = TRUE ;
        }           /* Tell caller @@5@J16 */
        else {                          /* else        @@5@J16 */
        /* scan        @@5@J16 */
/* @@6 */
            ZScanA(TRUE, buf_seg, (PULONG)bytes_read, (PULONG)&skip_first_byte);            /* @@5@J16 */
/* @@6 */if (rdsav != *bytes_read)
            /* @@6 */
            {
/* @@6 */
                Heof = TRUE ;               /* Tell caller             */
/* @@6 */
/* @@6 */DEBUG((FCGRP,COLVL,
/* @@6 */                    "ReadBytes: Ascii mode, Found ^Z, Heof set to %d.",
/* @@6 */                    Heof));
/* @@6 */
            }
        }                           /*             @@5@J16 */
/* @@6 */
    }

    return(TRUE);
}


/***    read_bytes - Read bytes from file
 *
 *  Purpose:
 *      This just calls FarRead and ZScanA.  It is called with a
 *      file handle to read from, and some variables needed by those
 *      two routines.  FarRead gets as many bytes into the previously
 *      allocated buffer as it can.  If we are reading in ASCII mode,
 *      we need to truncate after a ^Z is read.  ZScanA does this,
 *      changing bytes_read to the new length if it finds one.
 *
 *  int read_bytes(int srcptr,TCHAR *buf_seg,unsigned buf_len,     @@5@J16
 *                 unsigned int *bytes_read,int mode,
 *                 int dstptr, TCHAR *dest_name );
 *
 *  Args:
 *      srcptr     = Handle of file to read
 *      buf_seg    = Buffer address
 *      buf_len    = Buffer length
 *      bytes_read = Location to put bytes read
 *      source     = copy source state
 *      dstptr     = Handle of file to write
 *      dest_name  = file name of destination file
 *
 *  Returns:
 *      TRUE if read successful
 *      FALSE if not
 *
 */

int
read_bytes(srcptr,buf_seg,buf_len,bytes_read,source,dstptr,dest_name)
CRTHANDLE  srcptr;
PCHAR  buf_seg ;
ULONG   buf_len ;
PULONG  bytes_read ;     /* @@5@J16 */
PCPYINFO source;
CRTHANDLE  dstptr;
PTCHAR  dest_name;
{
    unsigned rdsav ;
    int skip_first_byte = 0; /* storage for ZScanA */

    DEBUG((FCGRP,COLVL,"ReadBytes: Entered."));

    Heof = FALSE ;                          /* Clear flag              */

    DEBUG((FCGRP,COLVL,"ReadBytes: Heof reset to %d.",Heof));

    if (!ReadFile( CRTTONT(srcptr), buf_seg, buf_len, bytes_read, NULL) ||
        (*bytes_read == 0 && GetLastError() == ERROR_OPERATION_ABORTED)  // ctrl-c
       ) {

        DosErr=GetLastError();

        Cclose(srcptr);

        if (!FileIsDevice(dstptr)) {
            Cclose(dstptr);
            DeleteFile(dest_name );
        } else {
            Cclose(dstptr);
        }

        copy_error( DosErr, CE_PCOUNT );
    }

    if (*bytes_read == 0) {
        DosErr = 0;
        return(FALSE);                              /* M006            */
    }

    //
    //  Determine the contents of the buffer if we don't already
    //  know the sort of data inside it
    //

    if ((source->flags & (CI_UNICODE | CI_NOT_UNICODE)) == 0) {
        if (*bytes_read >= sizeof( WORD ) && *(PWORD)buf_seg == BYTE_ORDER_MARK) {
            source->flags |= CI_UNICODE;
        } else {
            source->flags |= CI_NOT_UNICODE;
        }
    }

    //
    //  Ascii, non-unicode copies are terminated at the first ^Z.  If a read
    //  succeeded but we truncated, indicate that we might be at EOF.
    //  Devices are not guaranteed to fill the buffer
    //

    if (TruncateOnCtrlZ( source->flags )) {
        rdsav = *bytes_read ;
        ZScanA(TRUE, buf_seg, bytes_read, (PULONG)&skip_first_byte);  /* @@5@J16 */
        if (rdsav != *bytes_read) {
            Heof = TRUE ;           /* Tell caller             */

            DEBUG((FCGRP,COLVL,
                   "ReadBytes: Ascii mode, Found ^Z, Heof set to %d.",
                   Heof));
        };
    };

    return(TRUE);
}




/***     write_bytes - Write bytes to destination file.
 *
 *  Purpose:
 *      Writes buffer of information to destination file using
 *      FarWrite.
 *
 *  int write_bytes(int destptr,CHAR *buf_seg,
 *                  unsigned bytes_read,TCHAR *dest_name, unsigned srcptr)
 *
 *  Args:
 *      destptr    = Handle of destination file
 *      buf_seg    = Buffer to write
 *      bytes_read = Bytes previously read into buffer
 *      dest_name  = Destination filename
 *      srcptr     = source file handle
 *
 *  Returns:
 *      Nothing if successful write
 *      Transfers to copy_error if not
 *
 *  Notes:
 *      M020 - Added srcptr handle to args so that source could be closed
 *      if write error occurred.
 *
 */

void
write_bytes(destptr,buf_seg,bytes_read,dest_name,srcptr)
CRTHANDLE   destptr ;
PCHAR   buf_seg ;
ULONG    bytes_read ;
PTCHAR   dest_name ;
CRTHANDLE   srcptr ;
{

    DWORD bytes_writ ;
    unsigned msg = 0 ;

    DEBUG((FCGRP,COLVL,"WriteBytes: Entered."));

    if (!WriteFile( CRTTONT(destptr), buf_seg, bytes_read, &bytes_writ, NULL ) ||
        bytes_read != bytes_writ ||
        CtrlCSeen ) {

        DosErr=GetLastError();

        Cclose(srcptr) ;
        Cclose(destptr);

        if (FileIsDevice( destptr )) {

            msg = ERROR_WRITE_FAULT;

        } else {

            DeleteFile( dest_name );
        }

        Heof = FALSE;
        if (!DosErr) {

            DosErr = ERROR_DISK_FULL ;

        }


        if (CtrlCSeen) {

            msg = 0;

        } else {

            if (!msg) {
                PrtErr(DosErr);
            }

        }

        copy_error(msg,CE_PCOUNT);
    }
}




/***    same_fcpy - Detects case where source equals destination
 *
 *  Purpose: (M015)
 *      The user might type something like "copy foo .\foo".  To recognize
 *      that these are the same, copy translates the names into root-based
 *      pathnames.  There is no internal DOS5 function to do this so we
 *      have partially simulated the old DOS3 functionality in the FullPath
 *      function in CTOOLS1.  Note that this does not translate net names
 *      or ASSIGN/JOIN/SUBST type filespecs.  It is called on both names
 *      returning FAILURE (1) if they are malformed and SUCCESS (0) if not.
 *      If there is a successful return, the two new strings are strcmp'd.
 *
 *  int same_fcpy(int fres, TCHAR *first, TCHAR *second)
 *
 *  Args:
 *      fsame  = The source FullPath return code
 *      buffer1= The source buffer from FullPath
 *      second = The destination filename
 *
 *  Returns:
 *      TRUE if names match
 *      FALSE if not
 *
 */

same_fcpy(fres,buffer1,second)
int fres;
TCHAR *buffer1;
TCHAR *second;
{
    /*Increased buffer size @WM1 */
    TCHAR buffer2[2*MAX_PATH] ;  /* PTM 1412 */

    DEBUG((FCGRP,COLVL,"SameFile: Entered."));

    if (fres || FullPath(buffer2,second,MAX_PATH*2)) /* M015  */
        return(FALSE) ;

    DEBUG((FCGRP,COLVL,"SameFile: name1 after FullPath = %ws",buffer1));
    DEBUG((FCGRP,COLVL,"SameFile: name2 after FullPath = %ws",buffer2));

/*509*/

return(_tcsicmp(buffer1,buffer2) == 0);
}



/***    same_file - Detects case where source equals destination
 *
 *  Purpose: (M015)
 *      The user might type something like "copy foo .\foo".  To recognize
 *      that these are the same, copy translates the names into root-based
 *      pathnames.  There is no internal DOS5 function to do this so we
 *      have partially simulated the old DOS3 functionality in the FullPath
 *      function in CTOOLS1.  Note that this does not translate net names
 *      or ASSIGN/JOIN/SUBST type filespecs.  It is called on both names
 *      returning FAILURE (1) if they are malformed and SUCCESS (0) if not.
 *      If there is a successful return, the two new strings are strcmp'd.
 *
 *  int same_file(TCHAR *first, TCHAR *second)
 *
 *  Args:
 *      first    = The source filename
 *      second   = The destination filename
 *
 *  Returns:
 *      TRUE if names match
 *      FALSE if not
 *
 */

same_file(first,second)
TCHAR *first,*second;
{
    TCHAR buffer1[2*MAX_PATH],   /* Increased buffer size @WM1 */
    buffer2[2*MAX_PATH] ;  /* PTM 1412 */

    DEBUG((FCGRP,COLVL,"SameFile: Entered."));

    if (FullPath(buffer1,first,MAX_PATH*2) || FullPath(buffer2,second,MAX_PATH*2)) /* M015  */
        return(FALSE) ;

    DEBUG((FCGRP,COLVL,"SameFile: name1 after FullPath = %ws",buffer1));
    DEBUG((FCGRP,COLVL,"SameFile: name2 after FullPath = %ws",buffer2));

    return(_tcsicmp(buffer1,buffer2) == 0);
}



/***    copy_error - Main error routine
 *
 *  Purpose:
 *      Accepts a message number and a flag which determines whether
 *      it should print the number of files copied before the error.
 *      Resets the verify mode and longjmp's out.
 *
 *  int copy_error(unsigned int messagenum, int flag)
 *
 *  Args:
 *      messagenum = The message number for the message retriever
 *      flag       = Print files copied message flag
 *
 *  Returns:
 *      Does not return
 *
 */

void copy_error(messagenum,flag)
unsigned int messagenum;
int flag;
{


    DEBUG((FCGRP,COLVL,"CopyError: Entered."));

    if (messagenum)                                         /* M019    */
        PutStdOut(messagenum, NOARGS);
    if (flag == CE_PCOUNT)

        PutStdOut(MSG_FILES_COPIED, ONEARG, argstr1(TEXT("%9d"), (unsigned long)number_of_files_copied)) ;

    VerifyCurrent = GetSetVerMode(GSVM_GET);


    while (FFhndlCopy < FFhndlsaved) {
        // while (FFhndlsaved) {                /* findclose will dec this     @@1 */
        findclose(FFhandles[FFhndlsaved - 1]);                   /* @@1 */
    }                                                           /* @@1 */
    longjmp(CmdJBuf2,1);
}




/***    DestinationNeedsCtrlZ - Test type of copy in progress
 *
 *  Purpose:
 *      Given a struct, check if the copy was in ascii mode by
 *      looking at its flags.  If it was, either the CI_ASCII flag
 *      was set or the user didn't specify and the operation was
 *      concat or combine, which default to ascii mode.
 *
 *  Args:
 *      dest = The destination copy information structure.
 *
 *  Returns:
 *      TRUE for ^Z termination needed,
 *      FALSE otherwise.
 *
 */

BOOL
DestinationNeedsCtrlZ( dest )
PCPYINFO dest;
{
    DEBUG((FCGRP,COLVL,"CopyWasAscii: Entered."));

    //
    //  We append a ^Z only if:
    //          This isn't a unicode copy
    //      and
    //          (explicit ^Z addition requested
    //           or
    //           (no flags were set 
    //            and 
    //            the copy mode was concat or combine)
    //

    return (dest->flags & CI_UNICODE) == 0
           && ((dest->flags & CI_ASCII) != 0 
               || ((dest->flags & CI_NOTSET) != 0
                   && (copy_mode == CONCAT || copy_mode == COMBINE)));
}




/***    open_for_append - Open and seek to end (or ^Z)
 *
 *  Purpose:
 *      Open a file for writing, and seek the pointer to the
 *      end of it.  If we are copying in ascii mode, seek to
 *      the first ^Z found.  If not, seek to the physical end.
 *
 *  int open_for_append(TCHAR *filename,int flags,
 *                      TCHAR *buf_seg,unsigned buf_len)
 *
 *  Args:
 *      filename = ASCII filename
 *      source   = copy info source
 *      buf_seg  = Read buffer
 *      buf_len  = Buffer length
 *
 *  Returns:
 *      Handle of open file if successful
 *      Error out if not
 *
 */

CRTHANDLE
open_for_append(
               PTCHAR      filename,
               PCPYINFO    source,
               PCHAR       buf_seg,
               ULONG       buf_len)
{
    ULONG       bytesread ;
    CRTHANDLE   ptr;
    int         foundz = FALSE ;
    unsigned    brcopy ;
    ULONG       skip_first_byte = 0; /* storage for ZScanA */

    DEBUG((FCGRP,COLVL,"OpenForAppend: Entered."));

    ptr = Copen2(                   /* open file for destination file */
                                    filename,               /* make explicit cast */
                                    (unsigned int)O_RDWR,   /* make explicit cast */
                                    FALSE);

    if (ptr == BADHANDLE) {                              /* M011    */
        PrtErr(ERROR_OPEN_FAILED) ;             /* M019    */
        copy_error(0,CE_PCOUNT) ;               /* M019    */
    }

    do {
        if (ReadFile( CRTTONT(ptr), buf_seg, buf_len, &bytesread, NULL)) {
            brcopy = bytesread ;

            //
            //  Determine the contents of the buffer if we don't already
            //  know the sort of data inside it
            //

            if ((source->flags & (CI_UNICODE | CI_NOT_UNICODE)) == 0) {
                if (bytesread > sizeof( WORD ) && *(PWORD)buf_seg == BYTE_ORDER_MARK) {
                    source->flags |= CI_UNICODE;
                } else {
                    source->flags |= CI_NOT_UNICODE;
                }
            }

            if (brcopy != 0) {
                foundz = ZScanA( TruncateOnCtrlZ( source->flags ),
                                 buf_seg,
                                 &bytesread,
                                 &skip_first_byte
                               ) ;
            }
        } else {
            DosErr = GetLastError();
            Cclose(ptr);
            PutStdErr(DosErr,NOARGS) ;
            copy_error(0,CE_PCOUNT) ;  /* end copy at this point         */
        }
    }  while (bytesread == buf_len) ;

    if (foundz == 0) {
        SetFilePointer(CRTTONT(ptr), -(long)(brcopy-bytesread), NULL, FILE_CURRENT) ;
    }

    return(ptr) ;
}

DWORD
WinEditName(
    const TCHAR *pSrc,
    const TCHAR *pEd,
    TCHAR *pRes,
    const unsigned ResBufLen
    )
/*++

Routine Description:

    This routine takes a source filename, an editing pattern, and produces
    an output name suitable for rename or copy.  It relies on the semantics
    of ? and * matching.  There are a whole raft of user-model issues here
    especially when doing things like:
    
        rename *.foo.bar *
        
    Does the user intend that the destination * match precisely what the
    source * matches?  This is a huge RATHOLE.

Arguments:

    pSrc 
        Input filename as produced by find-first/next
        
    pEd
        Editing string, containing *, ? and other characters
        
    pRes
        Output buffer where edited string is placed
        
    ResBufLen
        Length of output buffer


Return Value:

    Status code 

--*/

{
    DWORD ResLen;
    TCHAR delimit;
    TCHAR *pTmp;

    //
    //  Walk forward through the editing string processing the 
    //  editing chars:
    //
    //      : and /\ are not allowed
    //      * matches the current point in the source string 
    //          through either the end of string or through the
    //          LAST character that may follow the *:  *A will 
    //          match up to (but not including) the last A.
    //      ? matches the next character UNLESS it's a dot in 
    //          which case, it's ignored.
    //      . matches any number of dots, including zero.
    //
    //      all other characters match

    
    ResLen = 0;
    while (*pEd) {
        if (ResLen < ResBufLen) {
            switch (*pEd) {
            case COLON:
            case BSLASH:
                return(ERROR_INVALID_NAME);

            case STAR:
                delimit = *(pEd+1);
                if (!(pTmp = _tcsrchr(pSrc, delimit))) {
                    pTmp = _tcsrchr(pSrc, NULLC);
                }
                while ((ResLen < ResBufLen) && pSrc < pTmp) {
                    if (ResLen < ResBufLen) {
                        *(pRes++) = *(pSrc++);
                        ResLen++;
                    } else
                        return(ERROR_BUFFER_OVERFLOW);
                }
                break;

            case QMARK:
                if ((*pSrc != DOT) && (*pSrc != NULLC)) {
                    if (ResLen < ResBufLen) {
                        *(pRes++) = *(pSrc++);
                        ResLen++;
                    } else
                        return(ERROR_BUFFER_OVERFLOW);
                }
                break;

            case DOT:
                while ((*pSrc != DOT) && (*pSrc != NULLC)) {
                    pSrc++;
                }
                *(pRes++) = DOT;        /* from EditMask, even if src doesn't */
                                        /* have one, so always put one.       */
                ResLen++;
                if (*pSrc)              /* point one past '.' */
                    pSrc++;
                break;

            default:
                if ((*pSrc != DOT) && (*pSrc != NULLC)) {
                    pSrc++;
                }
                if (ResLen < ResBufLen) {
                    *(pRes++) = *pEd;
                    ResLen++;
                } else
                    return(ERROR_BUFFER_OVERFLOW);
                break;
            }
            pEd++;
        } else {
            return(ERROR_BUFFER_OVERFLOW);
        }
    }

    if ((ResLen) < ResBufLen) {
        *pRes = NULLC;
        return(NO_ERROR);
    } else
        return(ERROR_BUFFER_OVERFLOW);
}


/***    MyWriteFile - write ansi/unicode to file
 *
 *  Purpose:
 *      Write buffer in requested mode (ansi/unicode) to destination.
 *
 *  Args:
 *      Same as WriteFileW
 *
 *  Returns:
 *      return value from WriteFileW
 *
 */
BOOL
MyWriteFile(
           CRTHANDLE fh,
           CONST VOID *rgb,
           DWORD cb,
           LPDWORD lpcb
           )
{
    DWORD       cbTotal = cb;
    HANDLE      dh = CRTTONT(fh);
    DWORD       cbT;

#ifdef UNICODE
    if (fOutputUnicode)
#endif // UNICODE
        return WriteFile(dh, rgb, cb, lpcb, NULL);
#ifdef UNICODE
    else {
        TCHAR *rgw = (TCHAR*)rgb;
    #ifdef FE_SB
// If dbcs string include, Unicode string len != MultiByte string len.
// MSKK NT RAID :#10855 by V-HIDEKK
        while (cb > LBUFLEN) {
            // - 1 for NULLC
            cbT = WideCharToMultiByte(CurrentCP, 0, (LPWSTR)rgw, LBUFLEN/(sizeof(TCHAR)),
                                      (LPSTR)AnsiBuf, LBUFLEN, NULL, NULL);
            rgw += LBUFLEN/(sizeof(TCHAR));
            cb -= LBUFLEN;
    #else
        while (cb > LBUFLEN*sizeof(TCHAR)) {
            // - 1 for NULLC
            cbT = WideCharToMultiByte(CurrentCP, 0, (LPWSTR)rgw, LBUFLEN,
                                      (LPSTR)AnsiBuf, LBUFLEN, NULL, NULL);
            rgw += LBUFLEN;
            cb -= LBUFLEN*sizeof(TCHAR);
    #endif
            if (!WriteFile(dh, AnsiBuf, cbT, lpcb, NULL) || *lpcb != cbT)
                return FALSE;
        }
        if (cb != 0) {
            // - 1 for NULLC
            cb = WideCharToMultiByte(CurrentCP, 0, (LPWSTR)rgw, -1,
                                     (LPSTR)AnsiBuf, LBUFLEN, NULL, NULL) - 1;
            if (!WriteFile(dh, AnsiBuf, cb, lpcb, NULL) || *lpcb != cb)
                return FALSE;
        }
        *lpcb = cbTotal;
        return TRUE;
    }
#endif // UNICODE
}

int DoVerify(
            CRTHANDLE      *pdestptr,
            TCHAR          *curr_dest,
            ULONG          bytes_read,
            CHAR           *buf_seg,
            CHAR           *buf_seg_dest
            )
{
    ULONG          bytes_read_dest;


    FlushFileBuffers ( CRTTONT(*pdestptr) );
    Cclose(*pdestptr);

    *pdestptr = Copen_Copy2(curr_dest, (ULONG)O_RDONLY);

    if (*pdestptr == BADHANDLE) {
// printf( "DoVerify: unable to open dest - %d\n", DosErr );
        PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
        return(FAILURE);
    }

    SetFilePointer( CRTTONT(*pdestptr), - (LONG) bytes_read, NULL, FILE_END);

    if (!ReadFile( CRTTONT(*pdestptr), buf_seg_dest, bytes_read, &bytes_read_dest, NULL) ) {
// printf( "DoVerify: unable to read dest - %d\n", GetLastError( ) );
        Cclose(*pdestptr);
        *pdestptr=BADHANDLE;
        PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
        return(FAILURE);
    }

    if (bytes_read_dest != bytes_read ) {
// printf( "DoVerify: Read different numbers of bytes\n" );
        Cclose(*pdestptr);
        *pdestptr=BADHANDLE;
        PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
        return(FAILURE);
    }

    if ( memcmp (buf_seg, buf_seg_dest, bytes_read) != 0 ) {
// printf( "DoVerify: buffers differ at offset %x\n", memcmp (buf_seg, buf_seg_dest, bytes_read) );
        Cclose(*pdestptr);
        *pdestptr=BADHANDLE;
        PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);
        return(FAILURE);
    }

    // last buffers compared OK, resuming writing.

    Cclose(*pdestptr);

    *pdestptr = Copen2((TCHAR *)curr_dest,
                       (unsigned int)O_WRONLY,
                       FALSE);

    if (*pdestptr == BADHANDLE) {
// printf( "DoVerify: Unable to open dest 2 - %d\n", DosErr );
        PutStdErr(MSG_VERIFY_FAIL, ONEARG, curr_dest);

        return(FAILURE);
    }

    SetFilePointer( CRTTONT(*pdestptr), 0, NULL, FILE_END);

    return(SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\ctable.h ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    ctable.c

Abstract:

    Command dispatch 

--*/

/***    Operator and Command Jump Table
 *
 *  This file is included by cmd.c and contains the operator and command jump
 *  table.  Every command and operator has an entry in the table.  The correct
 *  entry in the table can be found in two ways.  The first way is to loop
 *  through the table and search for the operator or command name you want.
 *  The second way is to use the xxxTYP variables which are defined in cmd.h.
 *  (xxx is an abbreviation of the name of the operator/command you want.)
 *  These variables can be used as indexes into the table.
 *
 */

/*  Each entry in the table is made up of one of the following structures.
 *  The fields are:
 *  name - the name of the operator/command
 *  func - the function which executes the operator/command or NULL if ignore
 *  flags - bit 0 == 1 if the drives of the arguments should be checked
 */

struct ocentry {
        TCHAR *name ;
        int (*func)(struct cmdnode *) ;
        TCHAR flags ;
        ULONG   msgno;      // # used in printing help message
        ULONG   extmsgno;   // # of additional help text when extensions enabled
        ULONG   noextramsg; //
} ;


/*  The follow functions are the functions that execute operators and commands.
 *  The letter "e" has been prepended to all of the function names to keep the
 *  names from conflicting with the names of library routines and keywords.
 */

/*  M000 - Removed declaration for eExport() from the collection below
 *  M002 - Removed declaration for eRem() from below
 */

int eBreak(struct cmdnode *n);
int eDirectory(), eRename(), eDelete(), eType(), eCopy(), ePause() ;
int eTime(), eVersion(), eVolume(), eChdir(), eMkdir(), eRmdir() ;
int eVerify(), eSet(), ePrompt(), ePath(), eExit(), eEcho() ;
int eGoto(), eShift(), eIf(), eFor(), eCls(), eComSep(), eOr(), eAnd() ;
int ePipe(), eParen(), eDate(), eErrorLevel(), eCmdExtVer(), eDefined() ;
int eExist(), eNot(), eStrCmp(), eSetlocal(), eEndlocal() ;     /* M000 */
int eCall() ;                                   /* M001 - Added this one   */
int eExtproc() ;                                /* M002 - Added this one   */
int eTitle();
int eStart() ;       /* START @@*/
int eAppend() ;     /* APPEND @@ */
int eKeys() ;       /* KEYS @@5 */
int eMove() ;       /* MOVE @@5 */
int eSpecialHelp();
int eColor(struct cmdnode *);


/*  The following external definitions are for the strings which contain the
 *  names of the commands.
 */

/* M000 - Removed definition for ExpStr (EXPORT command) from below
 */

#if 1
extern TCHAR BreakStr[];
#endif

extern TCHAR DirStr[], RenamStr[], RenStr[], EraStr[], DelStr[], TypStr[], RemStr[] ;
extern TCHAR CopyStr[], PausStr[], TimStr[], VerStr[], VolStr[], CdStr[], ChdirStr[] ;
extern TCHAR MdStr[], MkdirStr[], RdStr[], RmdirStr[], VeriStr[], SetStr[] ;
extern TCHAR CPromptStr[], CPathStr[], ExitStr[], EchoStr[], GotoStr[] ;
extern TCHAR ShiftStr[], IfStr[], ForStr[], ClsStr[], DatStr[] ;
extern TCHAR ErrStr[], ExsStr[], NotStr[], SetlocalStr[], EndlocalStr[] ;   /* M000 */
extern TCHAR CmdExtVerStr[], DefinedStr[] ;
extern TCHAR CallStr[] ;                            /* M001 - Added    */
extern TCHAR ExtprocStr[] ;                                 /* M002 - Added    */
// extern TCHAR ChcpStr[] ;    /* CHCP @@*/
extern TCHAR TitleStr[];
extern TCHAR StartStr[] ;    /* START @@*/
extern TCHAR AppendStr[] ;   /* APPEND @@ */
extern TCHAR KeysStr[] ;     /* KEYS @@5 */
extern TCHAR MovStr[] ;      /* MOVE @@5 */
extern TCHAR ColorStr[];

extern TCHAR PushDirStr[], PopDirStr[], AssocStr[], FTypeStr[];


/*  JumpTable - operator and command jump table
 *  There is an entry in it for every operator and command.  Those commands
 *  which have two names have two entries.
 *
 *  ***NOTE:  The order of the entries in this table corresponds to the defines
 *  mentioned earlier which are used to index into this table.  They MUST
 *  be kept in sync!!
 */

typedef int (*PCN)(struct cmdnode *);

struct ocentry JumpTable[] = {
{DirStr,        eDirectory,  NOFLAGS               , MSG_HELP_DIR, 0, 0},
{EraStr,        eDelete,     NOFLAGS               , MSG_HELP_DEL_ERASE, MSG_HELP_DEL_ERASE_X, 0},
{DelStr,        eDelete,     NOFLAGS               , MSG_HELP_DEL_ERASE, MSG_HELP_DEL_ERASE_X, 0},
{TypStr,        eType,       NOSWITCHES            , MSG_HELP_TYPE, 0, 0},
{CopyStr,       eCopy,       CHECKDRIVES           , MSG_HELP_COPY, 0, 0},
{CdStr,         eChdir,      CHECKDRIVES           , MSG_HELP_CHDIR, MSG_HELP_CHDIR_X, 0},
{ChdirStr,      eChdir,      CHECKDRIVES           , MSG_HELP_CHDIR, MSG_HELP_CHDIR_X, 0},
{RenamStr,      eRename,     CHECKDRIVES|NOSWITCHES, MSG_HELP_RENAME, 0, 0},
{RenStr,        eRename,     CHECKDRIVES|NOSWITCHES, MSG_HELP_RENAME, 0, 0},
{EchoStr,       eEcho,       NOFLAGS               , MSG_HELP_ECHO, 0, 0},
{SetStr,        eSet,        NOFLAGS               , MSG_HELP_SET, MSG_HELP_SET_X, 3},
{PausStr,       ePause,      NOFLAGS               , MSG_HELP_PAUSE, 0, 0},
{DatStr,        eDate,       NOFLAGS               , MSG_HELP_DATE, MSG_HELP_DATE_X, 0},
{TimStr,        eTime,       NOFLAGS               , MSG_HELP_TIME, MSG_HELP_TIME_X, 0},
{CPromptStr,    ePrompt,     NOFLAGS               , MSG_HELP_PROMPT, MSG_HELP_PROMPT_X, 0},
{MdStr,         eMkdir,      NOSWITCHES            , MSG_HELP_MKDIR, MSG_HELP_MKDIR_X, 0},
{MkdirStr,      eMkdir,      NOSWITCHES            , MSG_HELP_MKDIR, MSG_HELP_MKDIR_X, 0},
{RdStr,         eRmdir,      NOFLAGS               , MSG_HELP_RMDIR, 0, 0},
{RmdirStr,      eRmdir,      NOFLAGS               , MSG_HELP_RMDIR, 0, 0},
{CPathStr,      ePath,       NOFLAGS               , MSG_HELP_PATH, 0, 0},
{GotoStr,       eGoto,       NOFLAGS               , MSG_HELP_GOTO, MSG_HELP_GOTO_X, 0},
{ShiftStr,      eShift,      NOFLAGS               , MSG_HELP_SHIFT, MSG_HELP_SHIFT_X, 0},
{ClsStr,        eCls,        NOSWITCHES            , MSG_HELP_CLS, 0, 0},
{CallStr,       eCall,       NOFLAGS               , MSG_HELP_CALL, MSG_HELP_CALL_X, 1},
{VeriStr,       eVerify,     NOSWITCHES            , MSG_HELP_VERIFY, 0, 0},
{VerStr,        eVersion,    NOSWITCHES            , MSG_HELP_VER, 0, 0},
{VolStr,        eVolume,     NOSWITCHES            , MSG_HELP_VOL, 0, 0},
{ExitStr,       eExit,       NOFLAGS               , MSG_HELP_EXIT, 0, 0},
{SetlocalStr,   eSetlocal,   NOFLAGS               , MSG_HELP_SETLOCAL, MSG_HELP_SETLOCAL_X, 0},
{EndlocalStr,   eEndlocal,   NOFLAGS               , MSG_HELP_ENDLOCAL, MSG_HELP_ENDLOCAL_X, 0},
{TitleStr,      eTitle,      NOFLAGS               , MSG_HELP_TITLE, 0, 0},
{StartStr,      eStart,      NOFLAGS               , MSG_HELP_START, MSG_HELP_START_X, 0},
{AppendStr,     eAppend,     NOFLAGS               , MSG_HELP_APPEND, 0, 0},
{KeysStr,       eKeys,       NOSWITCHES            , MSG_HELP_KEYS, 0, 0},
{MovStr,        eMove,       CHECKDRIVES           , MSG_HELP_MOVE, 0, 0},
{PushDirStr,    ePushDir,    CHECKDRIVES|NOSWITCHES, MSG_HELP_PUSHDIR, MSG_HELP_PUSHDIR_X, 0},
{PopDirStr,     ePopDir,     CHECKDRIVES|NOSWITCHES, MSG_HELP_POPDIR, MSG_HELP_POPDIR_X, 0},
{AssocStr,      eAssoc,      EXTENSCMD             , 0, MSG_HELP_ASSOC, 0},
{FTypeStr,      eFType,      EXTENSCMD             , 0, MSG_HELP_FTYPE, 0},
{BreakStr,      eBreak,      NOFLAGS               , MSG_HELP_BREAK, MSG_HELP_BREAK_X, 0},
{ColorStr,      eColor,      EXTENSCMD             , 0, MSG_HELP_COLOR, 0},
{ForStr,        (PCN)eFor,   NOFLAGS               , MSG_HELP_FOR, MSG_HELP_FOR_X, 3},
{IfStr,         (PCN)eIf,    NOFLAGS               , MSG_HELP_IF, MSG_HELP_IF_X, 1},
{RemStr,        NULL,        NOFLAGS               , MSG_HELP_REM, 0, 0},
{NULL,          (PCN)eComSep,NOFLAGS               , 0, 0, 0},              // LFTYP
{NULL,          (PCN)eComSep,NOFLAGS               , 0, 0, 0},              // CSTYP
{NULL,          (PCN)eOr,    NOFLAGS               , 0, 0, 0},              // ORTYP
{NULL,          (PCN)eAnd,   NOFLAGS               , 0, 0, 0},              // ANDTYP
{NULL,          (PCN)ePipe,  NOFLAGS               , 0, 0, 0},              // PIPTYP
{NULL,          (PCN)eParen, NOFLAGS               , 0, 0, 0},              // PARTYP
{CmdExtVerStr,  eCmdExtVer,  EXTENSCMD             , 0, 0, 0},              // CMDVERTYP
{ErrStr,        eErrorLevel, NOFLAGS               , 0, 0, 0},              // ERRTYP
{DefinedStr,    eDefined,    EXTENSCMD             , 0, 0, 0},              // DEFTYP
{ExsStr,        eExist,      NOFLAGS               , 0, 0, 0},              // EXSTYP
{NotStr,        eNot,        NOFLAGS               , 0, 0, 0},              // NOTTYP
{NULL,          eStrCmp,     NOFLAGS               , 0, 0, 0},              // STRTYP
{NULL,          eGenCmp,     NOFLAGS               , 0, 0, 0},              // CMPTYP
{NULL,          (PCN)eParen, NOFLAGS               , 0, 0, 0},              // SILTYP
{NULL,          (PCN)eSpecialHelp, NOFLAGS         , 0, 0, 0}               // HELPTYP
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cparse.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cparse.c

Abstract:

    Command parsing

--*/

#include "cmd.h"

/*
                NT Command Interpreter

   This file contains all of the routines which make up Command's
   parser.  The main routines below have names like ParseXXX where
   XXX refers to the name of the production that routine is supposed
   to parse.

   None of the routines in this file, except Parser, will return if
   they detect a syntax error.  Instead, they will all call PSError() or
   PError().  These routines do a longjmp() back to Parser.

    Command Language Grammar:

    statement -> s0
              s0 -> s1 "&" s0 | s1
              s1 -> s2 "||" s1 | s2
              s2 -> s3 "&&" s2 | s3
              s3 -> s4 "|" s3 | s4
              s4 -> redir s5 | s5 redir | s5
              s5 -> "(" statement ")" |
                    "@" statement |
                    FOR var IN "(" arglist ")" DO s1 |
                    IF condition statement ELSE statement |
                    IF condition statement |
                    cmd arglist

             var -> "%"c | "%%"c
               c -> any-character
         arglist -> (arg)*
             arg -> any-string
       condition -> NOT cond | cond
            cond -> ERRORLEVEL n | arg == arg | EXIST fname
               n -> any-number
           fname -> any-file-name
             cmd -> internal-command | external-command

           redir -> in out | out in
              in -> "<" arg | epsilon
             out -> ( ">" | ">>" ) arg | epsilon


        Operator precedence from lowest to highest:
            &       Command Separator
            ||      Or Operator
            &&      And Operator
            |       Pipe Operator
            < > >>  I/O Redirectors
            ()      Command Grouper

        Examples:
            x & y | z   =>  x & (y | z)
     x | y & z   =>  (x | y) & z
     x || y | z  =>  x || (y | z)
     a & b || c && d | e || f    =>  a & ((b || (c && (d | e))) || f)

*/


extern jmp_buf CmdJBuf1 ;    /* Used by setjmp() and longjmp() */

extern TCHAR TmpBuf[] ;  /* The 1st 1/2 of this is used as the token buffer */
                                                                   /* M007 */

 TCHAR *TokBuf = TmpBuf ;  /* Current token buffer */  /* M007 */
 unsigned TokTyp ;        /*  "  "    " "  type   */
 unsigned TokLen ;        /*  "  "    " "  length */

extern unsigned DebGroup ;
extern unsigned DebLevel ;

extern TCHAR Delimiters[] ;                                      /* M022    */

/* Command strings */
extern TCHAR ForStr[], IfStr[], DetStr[], InStr[], DoStr[], ElseStr[], ErrStr[] ;
extern TCHAR ForHelpStr[], IfHelpStr[], RemHelpStr[];
extern TCHAR ForLoopStr[];
extern TCHAR ForDirTooStr[];
extern TCHAR ForParseStr[];
extern TCHAR ForRecurseStr[];
extern TCHAR ExsStr[], NotStr[] ;
extern TCHAR CmdExtVerStr[], DefinedStr[] ;
extern TCHAR RemStr[] ;                                          /* M002    */
extern TCHAR ExtprocStr[] ;                                      /* M023    */
extern TCHAR Fmt19[] ;                                           /* M018    */
extern TCHAR Fmt00[] ;   /* @@4 */

int NulNode = FALSE ;                                           /* M018    */
unsigned global_dfvalue; /* @@4 */


BOOLEAN fDumpTokens;
BOOLEAN fDumpParse;
void DuOp(TCHAR *op, struct node *n, int pad);
void DuRd(struct node *n);

/***    DumpParseTree - display a parse tree
 *
 *  Purpose:
 *      Display a parse tree in a reasonable format.
 *
 *  DumpParseTree(struct node *n, int pad)
 *
 *  Args:
 *      n - the root of the tree to be displayed
 *      pad - the number of spaces to indent the listing of the current node
 *
 *  Notes:
 *      This program is only compiled when DBG is defined.
 *
 */

void
DumpParseTree( struct node *n, int pad)
{
        struct cmdnode *c ;         /* All node ptrs are used to display that node type */
        struct fornode *f ;
        struct ifnode *i ;
        int j ;                     /* Used to pad output   */

        if (!n)
                return ;

        for (j = 0 ; j < pad ; j++)
                cmd_printf(Fmt19, SPACE) ;                      /* M018 */
        pad += 2 ;

        switch (n->type) {
                case LFTYP:
                        DuOp(TEXT("CRLF"), n, pad-2) ;
                        break ;

                case CSTYP:
                        DuOp(CSSTR, n, pad) ;
                        break ;

                case ORTYP:
                        DuOp(ORSTR, n, pad) ;
                        break ;

                case ANDTYP:
                        DuOp(ANDSTR, n, pad) ;
                        break ;

                case PIPTYP:
                        DuOp(PIPSTR, n, pad) ;
                        break ;

                case PARTYP:
                        DuOp(LEFTPSTR, n, pad) ;
                        break ;

/*  M015 - Added new type
 */
                case SILTYP:
                        DuOp(SILSTR, n, pad) ;
                        break ;

                case FORTYP:
                        f = (struct fornode *) n ;
                        cmd_printf(TEXT("%s (%s) %s\n"), f->cmdline, f->arglist, f->cmdline+DOPOS) ;      /* M010 */
                        DumpParseTree(f->body, pad) ;
                        break ;

                case IFTYP:
                        i = (struct ifnode *) n ;
                        cmd_printf(TEXT("%s\n"), i->cmdline) ;    /* M010 */
                        DumpParseTree((struct node *)i->cond, pad) ;
                        DumpParseTree(i->ifbody, pad) ;
                        if (i->elsebody) {
                        for (j = 0 ; j < pad-2 ; j++)
                                cmd_printf(Fmt19, SPACE) ;      /* M018 */
                        cmd_printf(TEXT("%s\n"), i->elseline) ;           /* M010 */
                        DumpParseTree(i->elsebody, pad) ;
                        } ;
                        break ;

                case NOTTYP:
                        c = (struct cmdnode *) n ;
                        cmd_printf(TEXT("%s\n"), c->cmdline) ;    /* M010 */
                        DumpParseTree((struct node *)c->argptr, pad) ;
                        break ;

                case REMTYP:            /* M002 - New REM type             */
                case CMDTYP:
                case ERRTYP:
                case EXSTYP:
                case STRTYP:
                case CMDVERTYP:
                case DEFTYP:
                        c = (struct cmdnode *) n ;
                        cmd_printf( TEXT("Cmd: %s  Type: %x "), c->cmdline, c->type) ;     /* M010 */
                        if (c->argptr)
                            cmd_printf( TEXT("Args: `%s' "), c->argptr) ;      /* M010 */
                        DuRd((struct node *)c) ;
                        break ;

                default:
                        cmd_printf(TEXT("*** Unknown type: %x\n"), n->type) ;     /* M010 */
        } ;
}

void
DuOp(TCHAR *op, struct node *n, int pad)
{
        cmd_printf( TEXT("%s "), op) ;     /* M010 */

        DuRd(n) ;

        DumpParseTree(n->lhs, pad) ;
        DumpParseTree(n->rhs, pad) ;
}

/*  M013 - The DuRd function has been extensively modified to conform
 *  to new data structures for redirection.
 *  M014 - Altered to handle input redirection for other than handle 0.
 */

void
DuRd(struct node *n)
{
    struct relem *tmp ;

    if (tmp = n->rio)
        CmdPutString( TEXT("Redir: ")) ;

    while (tmp) {

        cmd_printf(TEXT(" %x %c"), tmp->rdhndl, tmp->rdop) ;

        if (tmp->flag)
            CmdPutString( TEXT( ">" )) ;

        CmdPutString( tmp->fname );

        tmp = tmp->nxt ;
    } ;

    CmdPutString( CrLf );
}



/***    Parser - controls statement parsing
 *
 *  Purpose:
 *      Initialize the lexer, free memory previously used by the parser,  and
 *      call Parse to parse the next statement.
 *
 *  struct node *Parser(unsigned dfvalue, INT_PTR dpvalue, int fsarg)
 *
 *  Args:
 *      dfvalue - the value to be assigned to DataFlag by InitLex
 *      dpvalue - the value to be assigned to DataPtr by InitLex
 *      fsarg - passed to FreeStack, tells how many elements should be left on
 *          the data stack
 *
 *  Returns:
 *      The root of the parse tree of the statement just parsed or PARSERROR
 *      if an error was detected.
 *
 */

struct node *ParseStatement(int type) ;
#define MAX_STATEMENT_DEPTH 256
int StatementDepth;
BYTE StatementType[ MAX_STATEMENT_DEPTH ];
int PendingParens;

struct node *Parser(dfvalue, dpvalue, fsarg)
unsigned dfvalue ;
INT_PTR dpvalue ;
int fsarg ;
{
        struct node *n ;       /* Root of the parse tree */
        INT_PTR retcode ;      /* setjmp()'s return code */
        unsigned GeToken() ;

        DEBUG((PAGRP, PALVL, "PARSER: Entered.")) ;

        global_dfvalue = dfvalue; /* @@4 */

        FreeStack(fsarg) ;          /* Free unneeded memory             */
        InitLex(dfvalue, dpvalue) ; /* Initialize the lexer             */

        if ((retcode = setjmp(CmdJBuf1)) != 0)
                return((struct node *) retcode) ;   /* Return a parser error code */

        StatementDepth = 0;
        PendingParens = 0;
        n = ParseStatement(0) ;

/* Error if any data left in the buffer.  N is NULL then a blank line was
 * found.  In this case, it's alright that the buffer isn't empty.
 */

/*  M011 - Ref to IsData() was ref to Peek()
 *  M018 - Reorganized to save null/non-null state of last node.
 */
        if (n) {
                if(IsData() && GeToken(GT_NORMAL) != NLN && TokTyp != EOS)
                        PSError() ;
                NulNode = FALSE ;
        } else {
                NulNode = TRUE ;
        } ;

        if (fDumpParse)
            DumpParseTree(n, 0) ;

        DEBUG((PAGRP, PALVL, "PARSER: Exited.")) ;
        return(n) ;
}




/***    ParseStatement - parse the statement production
 *
 *  Purpose:
 *      Parse the statement production.
 *
 *  struct node *ParseStatement()
 *
 *  Returns:
 *      A pointer to the statement parsed or PARSERROR.
 *
 *  Note:
 *      Removed the tests for and calls to parse FOR, IF, DET and REM
 *      from ParseStatement to ParseS5 (M012).
 *
 */

extern int AtIsToken;  /* @@4 */
extern int ColonIsToken;

struct node *ParseStatement(int type)
{
        struct node *n;

#ifdef USE_STACKAVAIL
        if (stackavail() > MINSTACKNEED) { /* @WM1 Is there enough stack left? */
#endif
            StatementType[StatementDepth++] = (UCHAR)type;
            if (type == PARTYP)
                PendingParens += 1;

            AtIsToken = 1; /* @@4 */
            GeToken(GT_LPOP) ;              /* M000 - Was GT_NORMAL            */
            AtIsToken = 0; /* @@4 */
            DEBUG((PAGRP, PALVL, "PST: Entered, token = `%ws'", TokBuf)) ;

            if (TokTyp == EOS)
                    longjmp(CmdJBuf1, EOF) ;

            n = ParseS0() ;
            StatementDepth -= 1;
            if (type == PARTYP)
                PendingParens -= 1;
            return n;
#ifdef USE_STACKAVAIL
        } else {
            PutStdErr( MSG_TRAPC, ONEARG, Fmt00 ); /* @@4 */
            Abort();                      /* @@4 No, return error to user */
        }
#endif
}



/***    ParseFor - parse for loops
 *
 *  Purpose:
 *      Parse a FOR statement.
 *
 *  Returns:
 *      A pointer to a parsed FOR statement or PARSERROR.
 *
 *  struct node *ParseFor()
 *
 *  Notes:
 *      Microsoft's DOS manual says for loop vars can't be digits but the IBM
 *      documentation makes no such restriction.  Because my for/batch var
 *      substitution function will have no problem with it, I have taken out
 *      the check for that. - EKE
 *    - M022 * Changed FOR parser to treat all cases of FOR variable the
 *      same now that variable substitution is done in the lexer.  Note
 *      that all commands will now look the same whether in batch files or
 *      on the command line.
 *
 */

struct node *ParseFor()
{
        struct fornode *n ;    /* Holds ptr to the for node to be built and filled */
        struct cmdnode *LoadNodeTC() ;
        BOOL Help=FALSE;

        DEBUG((PAGRP, PALVL, "PFOR: Entered.")) ;

        // if "for/?", convert to "for /?"

        if (_tcsicmp(ForHelpStr, TokBuf) == 0) {
            TokBuf[_tcslen(ForStr)] = NULLC;
            Help=TRUE;
        }

        TokLen = FORLINLEN ;    /* NEEDED for LoadNodeTC call following    */
        n = (struct fornode *) LoadNodeTC(FORTYP) ;

        /* Get and verify the for loop variable */
        if (Help) {
            TokBuf[0] = SWITCHAR;
            TokBuf[1] = QMARK;
            TokBuf[2] = NULLC;
        } else {
            GeToken(GT_NORMAL) ;
        }

        if (TokBufCheckHelp( TokBuf, FORTYP ) )  {
            n->type = HELPTYP ;
            n->cmdline = NULL;
            return((struct node *) n) ;
            //Abort();
        }

        n->flag = 0;
        //
        // If extensions are enabled, check for additional forms of the FOR
        // statement, all identified by a switch character after the FOR
        // keyword.
        //
        if (fEnableExtensions) {
            while (TRUE) {
                //
                // FOR /L %i in (start,step,end) do
                //
                if (_tcsicmp(ForLoopStr, TokBuf) == 0) {
                    n->flag |= FOR_LOOP;
                    GeToken(GT_NORMAL) ;
                    continue;
                } else 
                
                //
                // FOR /D %i in (set) do
                //
                if (_tcsicmp(ForDirTooStr, TokBuf) == 0) {
                    n->flag |= FOR_MATCH_DIRONLY;
                    GeToken(GT_NORMAL) ;
                    continue;
                } else 
                
                //
                // FOR /F ["parse options"] %i in (set) do
                //
                if (_tcsicmp(ForParseStr, TokBuf) == 0) {
                    n->flag |= FOR_MATCH_PARSE;
                    GeToken(GT_NORMAL) ;
                    
                    //
                    // If next token does not begin with % then must be
                    // parse options
                    //
                    
                    if (*TokBuf != PERCENT && *TokBuf != SWITCHAR) {
                        if (n->parseOpts != NULL) {
                            PSError( );
                        }
                        n->parseOpts = gmkstr((TokLen+3)*sizeof(TCHAR)) ;
                        mystrcpy(n->parseOpts, TokBuf) ;
                        GeToken(GT_NORMAL) ;
                    }
                    continue;
                } else 
                
                //
                // FOR /R [directoryPath] %i in (set) do
                //
                if (_tcsicmp(ForRecurseStr, TokBuf) == 0) {
                    n->flag |= FOR_MATCH_RECURSE;
                    GeToken(GT_NORMAL) ;
                    //
                    // If next token does not begin with % then must be
                    // directory path to start recursive walk from
                    //
                    if (n->recurseDir != NULL) {
                        PSError( );
                    }
                    
                    if (*TokBuf != PERCENT && *TokBuf != SWITCHAR) {
                        n->recurseDir = gmkstr((TokLen+1)*sizeof(TCHAR)) ;
                        mystrcpy(n->recurseDir, TokBuf) ;
                        GeToken(GT_NORMAL) ;
                    }
                    continue;
                } else
                    break;
            }

            //
            //  Check for validity of switches:
            //      FOR_LOOP with no others
            //      FOR_MATCH_DIRONLY possibly with FOR_MATCH_RECURSE
            //      FOR_MATCH_PARSE with no others
            //      FOR_MATCH_RECURSE possibly with FOR_MATCH_DIRONLY
            //

            if (n->flag == FALSE
                || n->flag == FOR_LOOP
                || n->flag == FOR_MATCH_DIRONLY
                || n->flag == (FOR_MATCH_DIRONLY | FOR_MATCH_RECURSE)
                || n->flag == FOR_MATCH_PARSE
                || n->flag == FOR_MATCH_RECURSE
                ) {
            } else {
                PSError( );
            }

        }

        if (*TokBuf != PERCENT ||
            (_istspace(TokBuf[1]) || mystrchr(Delimiters, (TCHAR)(n->forvar = (unsigned)TokBuf[1]))) ||
             TokLen != 3) {
            PSError() ;
        } ;                

        DEBUG((PAGRP, PALVL, "PFOR: var = %c", n->forvar)) ;

        SpaceCat(n->cmdline, n->cmdline, TokBuf) ;      /* End of var verify */

        GetCheckStr(InStr) ;    /* M005 */
        SpaceCat(n->cmdline, n->cmdline, TokBuf) ;

        n->arglist = BuildArgList() ;

        GetCheckStr(DoStr) ;    /* M005 */
        mystrcpy(n->cmdline+DOPOS, TokBuf) ;

        if (!(n->body = ParseStatement(FORTYP)))
                PSError() ;

        DEBUG((PAGRP, PALVL, "PFOR: Exiting.")) ;
        return((struct node *) n) ;
}




/***    ParseIf - parse if statements
 *
 *  Purpose:
 *      Parse a IF statement.
 *
 *  struct node *ParseIf()
 *
 *  Returns:
 *      A pointer to a parsed IF statement or PARSERROR.
 *
 *                      *** W A R N I N G ! ***
 *      THIS ROUTINE WILL CAUSE AN ABORT IF MEMORY CANNOT BE ALLOCATED
 *              THIS ROUTINE MUST NOT BE CALLED DURING A SIGNAL
 *              CRITICAL SECTION OR DURING RECOVERY FROM AN ABORT
 *
 */

struct node *ParseIf()
{
        struct ifnode *n ; /* hold ptr to if node to be built and filled */
        BOOL Help=FALSE;
        int fIgnoreCase;

        DEBUG((PAGRP, PALVL, "PIF: Entered.")) ;

        // if "if/?", convert to "if /?"

        if (_tcsicmp(IfHelpStr, TokBuf) == 0) {
            TokBuf[_tcslen(IfStr)] = NULLC;
            Help=TRUE;
        }

        n = (struct ifnode *) LoadNodeTC(IFTYP) ;

        if (Help) {
            TokBuf[0] = SWITCHAR;
            TokBuf[1] = QMARK;
            TokBuf[2] = NULLC;
        } else {
            GeToken(GT_NORMAL) ;
        }

        //
        // Check for help flag
        //
        if (TokBufCheckHelp(TokBuf, IFTYP)) {
            n->type = HELPTYP ;
            n->cmdline = NULL;
            return((struct node *) n) ;
            // Abort();

        } else {
            fIgnoreCase = FALSE;
            //
            // If extensions are enabled, check for the /I switch which
            // specifies case insensitive comparison.
            //
            if (fEnableExtensions && !_tcsicmp(TokBuf, TEXT("/I"))) {
                fIgnoreCase = TRUE;
            } else
            //
            // if no help flag then put it all back and
            // have ParseCond refetch token
            //
            Lex(LX_UNGET,0) ;
        }
        n->cond = ParseCond(PC_NOTS) ;
        if (n->cond && fIgnoreCase)
            if (n->cond->type != NOTTYP)
                n->cond->flag = CMDNODE_FLAG_IF_IGNCASE;
            else
                ((struct cmdnode *)(n->cond->argptr))->flag = CMDNODE_FLAG_IF_IGNCASE;

        if (!(n->ifbody = ParseStatement(IFTYP)))
                PSError() ;

        if (IsData()) {                 /* M011 - Was Peek()               */
            GeToken(GT_NORMAL) ;
            if (_tcsicmp(ElseStr, TokBuf) == 0) {
                DEBUG((PAGRP, PALVL, "PIF: Found else.")) ;
                n->elseline = gmkstr(TokLen*sizeof(TCHAR)) ;  /*WARNING*/
                mystrcpy(n->elseline, TokBuf) ;
                if (!(n->elsebody = ParseStatement(IFTYP)))
                        PSError() ;

            } else
                Lex(LX_UNGET,0) ;
        } ;

        DEBUG((PAGRP, PALVL, "PIF: Entered.")) ;
        return((struct node *) n) ;
}




/***    ParseRem - parse REM statements (M002 - New function)
 *
 *  Purpose:
 *      Parse a REM statement.
 *
 *  struct node *ParseRem()
 *
 *  Returns:
 *      A pointer to a parsed REM statement.
 *      Returns FAILURE if not able to allocate memory
 *
 *
 *                      *** W A R N I N G ! ***
 *      THIS ROUTINE WILL CAUSE AN ABORT IF MEMORY CANNOT BE ALLOCATED
 *              THIS ROUTINE MUST NOT BE CALLED DURING A SIGNAL
 *              CRITICAL SECTION OR DURING RECOVERY FROM AN ABORT
 */

struct node *ParseRem()
{
        struct cmdnode *n ;    /* Ptr to REM node to build/fill    */
        BOOL Help=FALSE;

        DEBUG((PAGRP, PALVL, "PREM: Entered.")) ;

        // if rem/?, convert to rem /?

        if (_tcsicmp(RemHelpStr, TokBuf) == 0) {
            TokBuf[_tcslen(RemStr)] = NULLC;
            Help=TRUE;
        }

        n = LoadNodeTC(REMTYP) ;

        if (Help) {
            TokBuf[0] = SWITCHAR;
            TokBuf[1] = QMARK;
            TokBuf[2] = NULLC;
        } else {
            GeToken(GT_NORMAL) ;
        }

        //
        // Check for help flag
        //

        if (TokBufCheckHelp(TokBuf, REMTYP)) {
            n->type = HELPTYP ;
            n->cmdline = NULL;
            return((struct node *) n) ;

            //Abort();

        } else {
            //
            // if no help flag then put it all back and
            // have ParseCond refetch token
            //
            Lex(LX_UNGET,0) ;
        }

        if (IsData()) {   /* Read in args, if any (M011 - Was Peek())      */
                if (GeToken(GT_REM) == TEXTOKEN) {
                        n->argptr = gmkstr(TokLen*sizeof(TCHAR)) ;    /*WARNING*/
                        mystrcpy(n->argptr, TokBuf) ;
                        DEBUG((PAGRP, PALVL, "PREM: args = `%ws'", n->argptr)) ;

                } else
                        Lex(LX_UNGET,0) ;       /* M011 - Was UnGeToken()  */
        } ;

        DEBUG((PAGRP, PALVL, "PREM: Exited.")) ;
        return((struct node *) n) ;
}




/***    ParseS0 - parse production s0
 *
 *  Purpose:
 *      Parse the s0 production.
 *
 *  struct node *ParseS0()
 *
 *  Returns:
 *      A pointer to the production just parsed or PARSERROR.
 *
 *  Notes:
 *      If a parenthesised statement group is NOT being parsed, NLN
 *      is consider to be an empty side of a command separator so NULL is
 *      returned.
 *
 */

struct node *ParseS0()
{
        DEBUG((PAGRP, PALVL, "PS0: Entered.")) ;

        if (!ColonIsToken && TokTyp == TEXTOKEN && TokBuf[0] == COLON) {
            do {
                GeToken(GT_NORMAL) ;
            } while (TokBuf[0] != NULLC && TokBuf[0] != NLN);
            if (StatementType[StatementDepth-1] != PARTYP) {
                return(NULL) ;
            }
            GeToken(GT_NORMAL) ;
        }

        if (StatementType[StatementDepth-1] != PARTYP) {
            if (TokTyp == TEXTOKEN && !_tcsicmp(TokBuf, RPSTR)) {
                //
                // If a goto was done inside a parenthesized list of statements
                // we will eventually hit the terminating right paren.  Skip over
                // it so we dont declare an error
                //
                do {
                    GeToken(GT_NORMAL) ;
                } while (TokBuf[0] != NULLC && TokBuf[0] != NLN);
            }

            if (TokTyp == NLN) {
                DEBUG((PAGRP, PALVL, "PS0: Returning null statement.")) ;
                return(NULL) ;
            }
        }

        return(BinaryOperator(CSSTR, CSTYP, (PPARSE_ROUTINE)ParseS0, (PPARSE_ROUTINE)ParseS1)) ;
}




/***    ParseS1 - parse production s1
 *
 *  Purpose:
 *      Parse the s1 production.
 *
 *  struct node *ParseS1()
 *
 *  Returns:
 *      A pointer to the production just parsed or PARSERROR.
 *
 */

struct node *ParseS1()
{
        DEBUG((PAGRP, PALVL, "PS1: Entered.")) ;
        return(BinaryOperator(ORSTR, ORTYP, (PPARSE_ROUTINE)ParseS1, (PPARSE_ROUTINE)ParseS2)) ;
}




/***    ParseS2 - parse production s2
 *
 *  Purpose:
 *      Parse the s2 production.
 *
 *  struct node *ParseS2()
 *
 *  Returns:
 *      A pointer to the production just parsed or PARSERROR.
 *
 */

struct node *ParseS2()
{
        DEBUG((PAGRP, PALVL, "PS2: Entered.")) ;
        return(BinaryOperator(ANDSTR, ANDTYP, (PPARSE_ROUTINE)ParseS2, (PPARSE_ROUTINE)ParseS3)) ;
}




/***    ParseS3 - parse production s3
 *
 *  Purpose:
 *      Parse the s3 production.
 *
 *  struct node *ParseS3()
 *
 *  Returns:
 *      A pointer to the production just parsed or PARSERROR.
 *
 */

struct node *ParseS3()
{
        DEBUG((PAGRP, PALVL, "PS3: Entered.")) ;
        return(BinaryOperator(PIPSTR, PIPTYP, (PPARSE_ROUTINE)ParseS3, (PPARSE_ROUTINE)ParseS4)) ;
}




/***    ParseS4 - parse production s4
 *
 *  Purpose:
 *      Parse the s4 production.
 *
 *  struct node *ParseS4()
 *
 *  Returns:
 *      A pointer to the production just parsed or PARSERROR.
 *
 *  Notes:
 *      M013 - Almost the whole of this function was rewritten to
 *      conform to new structures and methods of redirection parsing.
 *      The primary data item is a linked list of structures which
 *      identify the individual redirection commands.
 */

struct node *ParseS4()
{
        struct node *n ;   /* Node ptr to add redir info to       */
        struct relem *io = NULL ;
        struct relem *tmpio ;
        int flg = 0;
        int i ;

        DEBUG((PAGRP, PALVL, "PS4: Entered.")) ;

/* Parse leading redirection receiving in return a list of redirection
 * structure elements pointed to by io.  Get a new token for ParseS5
 * if necessary (ParseRedir successful).
 */
        if (ParseRedir(&io)) {          /* M013 - Now use list of structs  */
                GeToken(GT_LPOP) ;      /* M011 - '(' Now operator         */

                DEBUG((PAGRP,PALVL,"PS4: List ptr io = %04x",io)) ;

        } ;

        DEBUG((PAGRP, PALVL, "PS4: Calling PS5.")) ;

        n = ParseS5() ;

        DEBUG((PAGRP,PALVL,"PS4: Post PS5 io= %04x, n->rio= %04x",io,n->rio)) ;

/* If more redirection was found beyond ParseS5 (in ParseCmd), n-rio in
 * the node will point to another list.  If two lists exist, integrate
 * them, giving priority to the later one by forcing them to be in
 * chronological order (io becomes n->rio and n->rio is appended).
 *
 * NOTE: FOR and IF nodes are explicitly barred from having leading
 * redirection (use will result in a Syntax Error).  This restriction may
 * later be removed by inserting code to walk the parse tree and insert
 * the leading redirection in the first non-IF/FOR/DET node.
 */
        if (io) {                       /* If leading redirection...       */

                DEBUG((PAGRP,PALVL,"PS4: Have leading redirection.")) ;

                if (n->type == FORTYP ||
                    n->type == IFTYP) {

                        DEBUG((PAGRP,PALVL,"PS4: n=IF/FOR !!ERROR!!")) ;

                        mystrcpy(TokBuf,((struct cmdnode *)n)->cmdline) ;
                        PSError() ;
                } ;

                tmpio = n->rio ;        /* ...save possible Cmd redir...   */
                n->rio = io ;           /* ...install leading redir...     */
                if (tmpio) {            /* ...and if Cmd redirection...    */

                        DEBUG((PAGRP,PALVL,"PS4: Have Cmd redirection.")) ;

                        while (io->nxt)         /* ...find list end...     */
                                io = io->nxt ;
                        io->nxt = tmpio ;       /* ...and install it       */
                } ;
        } ;

/* The nodes n->rio field points to the head of a single list (or NULL
 * if no redirection).  If further input remains in Lexer buffer, a
 * new list is created from that and appended to any existing one.
 */
        DEBUG((PAGRP,PALVL,"PS4: After fixup, n->rio = %04x",n->rio)) ;

        if (IsData()) {                 /* If data remains in buffer       */

                DEBUG((PAGRP, PALVL, "PS4: Doing 2nd ParseRedir call.")) ;

                GeToken(GT_NORMAL) ;    /* Get token for ParseRedir...     */
                io = NULL ;             /* ...zero the pointer & call      */
                if (ParseRedir(&io)) {  /* If redir, then...               */
                        if (tmpio = n->rio) {           /* ...fix list     */
                                while (tmpio->nxt)
                                        tmpio = tmpio->nxt ;
                                tmpio->nxt = io ;
                        } else
                                n->rio = io ;
                } else                          /* Else, if no redir...    */
                        Lex(LX_UNGET,0) ;       /* ...unget the token.     */
        } ;

#if DBG
        if (io = n->rio) {
                i = 0 ;
                while (io) {

                        DEBUG((PAGRP,PALVL,"PS4: RD#%d - io is at %04x",i,io)) ;
                        DEBUG((PAGRP,PALVL,"PS4: RD#%d - io->rdhndl = %04x",i,io->rdhndl)) ;
                        DEBUG((PAGRP,PALVL,"PS4: RD#%d - io->fname = %ws",i,io->fname)) ;
                        DEBUG((PAGRP,PALVL,"PS4: RD#%d - io->flag = %d",i,io->flag)) ;
                        DEBUG((PAGRP,PALVL,"PS4: RD#%d - io->rdop = %c",i,io->rdop)) ;
                        DEBUG((PAGRP,PALVL,"PS4: RD#%d - io->nxt = %04x",i,io->nxt)) ;
                        io = io->nxt ;
                        ++i ;
                } ;
        } ;
#endif

/* The pointer n->rio heads a single list of redirection structures with
 * possible duplicates for a single handle.  The code below eliminates
 * any duplicates giving priority to the later of the two.
 */
        if (tmpio = n->rio) {
                while (tmpio) {
                        i = 1 << tmpio->rdhndl ;
                        if (flg & i) {
                                i = tmpio->rdhndl ;
                                tmpio = n->rio ;
                                while (tmpio) {
                                        if (i == tmpio->rdhndl) {
                                                if (tmpio == n->rio)
                                                        n->rio = tmpio->nxt ;
                                                else
                                                        io->nxt = tmpio->nxt ;
                                                flg = 0 ;
                                                tmpio = n->rio ;
                                                break ;
                                        } ;
                                        io = tmpio ;
                                        tmpio = io->nxt ;
                                } ;
                                continue ;
                        } else
                                flg |= i ;
                        io = tmpio ;
                        tmpio = io->nxt ;
                } ;
        } ;

        DEBUG((PAGRP, PALVL, "PS4: Redir handles flag = %02x",flg)) ;
        DEBUG((PAGRP, PALVL, "PS4: Redir list = %04x",n->rio)) ;

        DEBUG((PAGRP, PALVL, "PS4: Exited")) ;
        return(n) ;
}




/***    ParseS5 - parse production s5
 *
 *  Purpose:
 *      Parse the s5 production.
 *
 *  struct node *ParseS5()
 *
 *  Returns:
 *      A pointer to the production just parsed or PARSERROR.
 *
 */

struct node *ParseS5()
{
        struct node *n ;   /* Ptr to paren group node to build and fill */

        DEBUG((PAGRP, PALVL, "PS5: Entered, TokTyp = %04x", TokTyp)) ;

/*  M012 - Moved functionality for parsing FOR, IF and REM to
 *         ParseS5 from ParseStatement to give these four commands a
 *         lower precedence than the operators.
 */
        if (TokTyp == TEXTOKEN) {
                if ((_tcsicmp(ForStr, TokBuf) == 0) ||
                    (_tcsicmp(ForHelpStr, TokBuf) == 0))
                        return(ParseFor()) ;

                else if ((_tcsicmp(IfStr, TokBuf) == 0) ||
                         (_tcsicmp(IfHelpStr, TokBuf) == 0))
                        return(ParseIf()) ;

/*  M002 - Treat REM as unique command
 */
                else if ((_tcsicmp(RemStr, TokBuf) == 0) ||
                         (_tcsicmp(RemHelpStr, TokBuf) == 0))
                        return(ParseRem()) ;            /* ...parse seperate */
/*  M002 ends   */

                else {
                        n = ParseCmd() ;
                        // if (_tcsicmp(ExtprocStr, ((struct cmdnode *)n)->cmdline) == 0) {
                        //        n->type = EXTTYP ;
                        //
                        //        DEBUG((PAGRP, PALVL, "PS5: Found EXTPROC type = %d", n->type)) ;
                        //} ;
                        return(n) ;
                } ;

/*  M015 - Added code to handle new SILTYP unary operator like left paren
 */
        } else if (*TokBuf == LPOP || *TokBuf == SILOP) {       /* M015    */

                n = mknode() ;

                if (n == NULL) {
                    Abort();
                }

                if (*TokBuf == LPOP) {                          /* M015    */
                        n->type = PARTYP ;
/*  M004 - Strip leading newlines from the current paren group
 */
                        do {
                                GeToken(GT_NORMAL|GT_RPOP) ;
                        } while (*TokBuf == NLN) ;
                        Lex(LX_UNGET,0) ;       /* M011 - Was UnGeToken    */
/*  M004 ends   */
                         n->lhs = ParseStatement(PARTYP) ;
                } else {                                        /* M015    */
                        n->type = SILTYP ;                      /* M015    */
                        DEBUG((PAGRP,PALVL,"PS5: Silent mode starts")) ;
                         n->lhs = ParseStatement(0) ;
                } ;


                DEBUG((PAGRP, PALVL, "PS5: ParseStatement has returned.")) ;

                if (n->type == SILTYP)                          /* M015    */
                        return(n) ;                             /* M015    */
/*  M015 ends   */

                if (GeToken(GT_RPOP) == RPOP) { /* M000 - Was GT_NORMAL    */
                        return(n) ;
                } ;

        } ;

        DEBUG((PAGRP, PALVL, "PS5: Error, no right paren. Token = `%ws'", TokBuf)) ;
        PSError() ;
        return NULL;
}




/***    ParseCond - parse the condition production
 *
 *  Purpose:
 *      Parse a CONDITION production.
 *
 *  struct cmdnode *ParseCond(unsigned pcflag)
 *
 *  Args:
 *      pcflag - nonzero if "NOT"s are not allowed because one has been found
 *          already
 *
 *  Returns:
 *      A pointer to a parsed COND production or PARSERROR.
 *
 *  Notes:
 *      The token after "errorlevel" is checked to make sure it is a number.
 *      If it isn't, a syntax error is generated.
 *
 *      If a valid "NOT" is found, ParseCond() is called recursively to parse
 *      the rest of the condition.  A pointer to the node is put in the
 *      argptr field of the node.
 *
 *      M020 - "ERRORLEVEL=x" not being parsed correctly due to entire
 *      string being lexed as single token.  Now Lex first as GT_NORMAL
 *      and if not ERRORLEVEL, re-Lex as GT_EQOK.
 *
 */

struct cmdnode *ParseCond(pcflag)
unsigned pcflag ;
{
        struct cmdnode *n ;    /* Ptr to cond node to build and fill   */
        struct cmdnode *LoadNodeTC() ;

        DEBUG((PAGRP, PALVL, "PCOND: Entered.")) ;


        if (GeToken(GT_NORMAL) != TEXTOKEN)                     /* M020    */
                PSError() ;
        n = LoadNodeTC(0) ;

        if (_tcsicmp(ErrStr, TokBuf) == 0) {         /* ERRORLEVEL */
                n->type = ERRTYP ;
        } else
        if (_tcsicmp(ExsStr, TokBuf) == 0)           /* EXIST */
                n->type = EXSTYP ;
        else
        if (fEnableExtensions && _tcsicmp(CmdExtVerStr, TokBuf) == 0)   /* CMDEXTVERSION */
                n->type = CMDVERTYP ;
        else
        if (fEnableExtensions && _tcsicmp(DefinedStr, TokBuf) == 0)     /* DEFINED */
                n->type = DEFTYP ;
        else
        if (_tcsicmp(NotStr, TokBuf) == 0) { /* Not */
                if (pcflag)
                        PSError() ;
                n->type = NOTTYP ;
                n->argptr = (TCHAR *) ParseCond(PC_NONOTS) ;

                DEBUG((PAGRP, PALVL, "PCOND: Exited, type = 0x%02x", n->type)) ;
                return(n);

        } else {
                Lex(LX_UNGET,0);
                
                n->type = STRTYP ;                      /* String comparison */
                ParseArgEqArg(n) ;

                DEBUG((PAGRP, PALVL, "PCOND: Exited, type = 0x%02x", n->type)) ;
                return(n);
        } ;

        /* Errorlevel, Exist, CmdExtVersion or Defined */
        n->argptr = TokStr(GeTexTok(GT_NORMAL), NULL, TS_NOFLAGS) ;

        DEBUG((PAGRP, PALVL, "PCOND: Exited, type = 0x%02x", n->type)) ;

        return(n) ;
}




/***    ParseArgEqArg - parse IF statement string comparisons
 *
 *  Purpose:
 *      Parse an if statement string comparison conditional.
 *      The comparison can be in the following formats:
 *          s1==s2      s1== s2
 *          s1 ==s2     s1 == s2
 *
 *  ParseArgEqArg(struct cmdnode *n)
 *
 *  Args:
 *      n - ptr to the conditional structure
 *
 *                      *** W A R N I N G ! ***
 *      THIS ROUTINE WILL CAUSE AN ABORT IF MEMORY CANNOT BE ALLOCATED
 *              THIS ROUTINE MUST NOT BE CALLED DURING A SIGNAL
 *              CRITICAL SECTION OR DURING RECOVERY FROM AN ABORT
 *
 */

void ParseArgEqArg(n)
struct cmdnode *n ;
{

    //
    //  Get LHS of test
    //
    
    n->cmdline = GeTexTok( GT_NORMAL );

    //
    //  Get Operator
    //

    if (GeToken( GT_EQOK ) != TEXTOKEN) {
        PSError( );
    }
    
    //
    //  If it is a double equal, the arg ptr (RHS) is the next token
    //
        
    if (!_tcscmp( TokBuf, EQSTR)) {
        n->argptr = GeTexTok( GT_NORMAL );
        DEBUG((PAGRP, PALVL, "PARG: s1 == s2"));
    } 

    //
    //  if it begins with a double equal, skip it and make the remainder
    //  of the string the RHS of the test
    //
    
    else if (TokLen >= 4 && TokBuf[0] == EQ && TokBuf[1] == EQ) {
        n->argptr = gmkstr( (TokLen - 2) * sizeof( TCHAR ));
        mystrcpy( n->argptr, TokBuf + 2 );
        DEBUG((PAGRP, PALVL, "PARG: s1 ==s2"));
    } 
    
    //
    //  We have something other than the ==.  If extensions are enabled
    //  then we test for the extended comparisons
    //
    
    else if (fEnableExtensions) {
        if (!_tcsicmp( TokBuf, TEXT( "EQU" )))
            n->cmdarg = CMDNODE_ARG_IF_EQU;
        else
        if (!_tcsicmp( TokBuf, TEXT( "NEQ" )))
            n->cmdarg = CMDNODE_ARG_IF_NEQ;
        else
        if (!_tcsicmp( TokBuf, TEXT( "LSS" )))
            n->cmdarg = CMDNODE_ARG_IF_LSS;
        else
        if (!_tcsicmp( TokBuf, TEXT( "LEQ" )))
            n->cmdarg = CMDNODE_ARG_IF_LEQ;
        else
        if (!_tcsicmp( TokBuf, TEXT( "GTR" )))
            n->cmdarg = CMDNODE_ARG_IF_GTR;
        else
        if (!_tcsicmp( TokBuf, TEXT( "GEQ" )))
            n->cmdarg = CMDNODE_ARG_IF_GEQ;
        else
            PSError( );
        n->type = CMPTYP;
        n->argptr = GeTexTok( GT_NORMAL );

    } else {
        PSError( );
    }
        DEBUG((PAGRP, PALVL, "PARG: s1 = `%ws'  s2 = `%ws'", n->cmdline, n->argptr));
}




/***    ParseCmd - parse production cmd
 *
 *  Purpose:
 *      Parse a command
 *
 *  struct node *ParseCmd()
 *
 *  Returns:
 *      A pointer to the production just parsed or PARSERROR.
 *
 *  Notes:
 *      The code below has been completely rewritten to allow the parsing
 *      of redirection strings to occur anywhere within the command line.
 *      ParseS4() will catch redirection prior to the command name.
 *      Redirection between the name and argument or within the argument
 *      will be caught by the code below which checks for those operators
 *      during the building of the arguments.
 *      ParseS4() will then catch any occurring after the command argument.
 *
 *                      *** W A R N I N G ! ***
 *      THIS ROUTINE WILL CAUSE AN ABORT IF MEMORY CANNOT BE ALLOCATED
 *              THIS ROUTINE MUST NOT BE CALLED DURING A SIGNAL
 *              CRITICAL SECTION OR DURING RECOVERY FROM AN ABORT
 *
 *      M013 - The redirection portion of this routine has been rewritten
 *      to conform to the new methods of parsing redirection.
 *
 */

struct node *ParseCmd()
{
        struct cmdnode *n ;    /* Ptr to node to build/fill       */
        TCHAR *tptr ;           /* M003 - Pointer temp             */
        struct relem *io = NULL ;       /* M013 - Redir list pointer       */
        struct relem **tmpio = &io ;    /* M013 - ptr to ptr to redir list */

        DEBUG((PAGRP, PALVL, "PCMD: Entered.")) ;

        n = LoadNodeTC(CMDTYP) ;

/*  M003 - The following section has been completely rewritten
 */
        while (IsData()) {              /* M011 - Was Peek()               */
                if (GeToken(GT_ARGSTR) == TEXTOKEN) {
/*WARNING*/             tptr = gmkstr((mystrlen(n->argptr)+TokLen)*sizeof(TCHAR)) ;
                        mystrcpy(tptr, n->argptr) ;
                        mystrcat(tptr, TokBuf) ;
                        n->argptr = tptr ;
                        DEBUG((PAGRP, PALVL, "PCMD: args = `%ws'", n->argptr)) ;

/*  M013 - If not text, the current token must be tested as possible
 *         redirection.  Note that tmpio is a pointer to a pointer to a
 *         structure.  It first points to the head-of-list pointer, but
 *         after each successful call to ParseRedir, it is advanced to
 *         point to the 'nxt' pointer field in the last list element.
 */
                } else if (ParseRedir(tmpio)) {

                        DEBUG((PAGRP,PALVL,"PCMD: Found redir")) ;

                        do {
                                tmpio = &(*tmpio)->nxt ;
                        } while (*tmpio) ;
/*  M013 ends   */

/* If this is neither a text token (part of the argument) or a redirection
 * sequence, then this must be an operator and must be 'ungot' for the next
 * parsing sequence.
 */
                } else {
                        DEBUG((PAGRP,PALVL,"PCMD: Found `%ws'", TokBuf)) ;
                        Lex(LX_UNGET,0) ;       /* M011 - Was UnGeToken()  */
                        break ;
                }
        } ;

/*  M013 - Once the command is fully parsed and all mixed redirection
 *         identified, the list is placed in the node pointer to pass
 *         it back.
 */
        DEBUG((PAGRP,PALVL,"PCMD: Redirlist = %04x", io)) ;

        n->rio = io ;

/*  M003/M013 ends      */

        DEBUG((PAGRP, PALVL, "PCMD: Exited.")) ;
        return((struct node *) n) ;
}




/***    ParseRedir - controls I/O redirection parsing
 *
 *  Purpose:
 *      Parse the redir production.
 *
 *  int ParseRedir(struct relem **io)
 *
 *  Args:
 *      io - This is a pointer to the head-of-list pointer to the list
 *      of redirection elements being built.  On entry this MUST be NULL.
 *
 *  Returns:
 *      TRUE if redirection was found.
 *      FALSE if redirection wasn't found.
 *
 *  Notes:
 *      M013 - This routine has been completely rewritten to conform to
 *      new structures and methods of redirection parsing.  With these
 *      changes, redirection may now begin with ">", "<", "n>" or "n<"
 *      where n is a handle number.  This function now loops through
 *      lex'd input, parsing as many redirection instructions as exist
 *      in sequence, building a new structure for each one and linking
 *      it into a list of such structures.  Like XENIX we require the
 *      sequences 'n>' and 'n>&' to exist without separating whitespace
 *      although that sequence and any filename or trailing digit may be
 *      separated by the normal set of delimiters.  The XENIX << operator
 *      is lex'd correctly but currently restricted from use.
 *      M014 - Input redirection may now exist for handles other than 0.
 */

int ParseRedir(io)
struct relem **io ;            /* M013 - Ptr to ptr to redir elem */
{
        TCHAR rdop ;                     /* M013 - Type of operation        */
        int didflg = 0,                 /* M013 - Loop count               */
            getcnt = 0 ;                /* M013 - GeToken count            */
        TCHAR *i ;                       /* M013 - General ptr temp         */

        DEBUG((PAGRP, PALVL, "PREDIR: Entered, token = `%ws'", TokBuf)) ;

/*  M013 - If the 'while' conditional succeeds, rdop will equal the type of
 *  redirection being parsed.  A structure is malloc'd for *io and filled
 *  with the redirection information.  If more redirection is found, io
 *  becomes the address of the 'nxt' field in *io, and the cycle is repeated
 *  until the 1st non-redirection token is found.
 *  Error checking for "<<" and for handle substitution operators '&' without
 *  matching digits is done here, returning syntax errors when found.
 */
        while ((rdop = *TokBuf) == INOP || rdop == OUTOP ||
               (_istdigit(*TokBuf) &&
                ((rdop = *(TokBuf+1)) == INOP || rdop == OUTOP))) {

                if (!(*io = (struct relem *)mkstr(sizeof(struct relem)))) {

                        PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);       /* M021    */
                        PError() ;
                } ;

                DEBUG((PAGRP,PALVL,"PREDIR: List element made.")) ;

                ++didflg ;              /* Set == found at least one       */

                i = TokBuf ;

                (*io)->rdop = rdop ;    /* M014 - New field for type       */

                if (_istdigit(*i)) {
                        (*io)->rdhndl = *i - TEXT('0');
                        ++i ;

                        DEBUG((PAGRP,PALVL,"PREDIR: Specific-handle Redir.")) ;

                } else {
                        if (rdop == OUTOP)
                                (*io)->rdhndl = STDOUT;
                        else
                                (*io)->rdhndl = STDIN ;
                } ;

                DEBUG((PAGRP,PALVL,"PREDIR:Redir handle %d...",(*io)->rdhndl)) ;
                DEBUG((PAGRP,PALVL,(rdop == INOP)? "PREDIR:...for input" :
                                                   "PREDIR:...for output")) ;

                if (*i == *(i+1)) {
                        if (rdop == INOP)       /* M013 - Disallow '<<'    */
                                PSError() ;

                        (*io)->flag = 1 ;
                        ++i ;
                } ;

                ++i ;

                if (*i == CSOP) {
                        if (mystrlen(i) == 2 && _istdigit(*(i+1)) &&
                            ((*io)->fname = mkstr(3*sizeof(TCHAR))))
                                mystrcpy((*io)->fname, i) ;
                        else
                                PSError() ;
                } else
                        (*io)->fname = GeTexTok(GT_NORMAL) ;

                DEBUG((PAGRP,PALVL,"PREDIR: RD fname = `%ws'.",(*io)->fname)) ;

                if (IsData()) {
                        GeToken(GT_NORMAL) ;
                        io = &((*io)->nxt) ;
                        ++getcnt ;
                } else
                        break ;
        } ;

        DEBUG((PAGRP, PALVL, "PREDIR: Exited  current token = `%ws'", TokBuf)) ;

/* M013 - Note that this function is called with a valid token in the
 *        token buffer.  If the routine returns FALSE, that token must
 *        still be valid.  If it returns TRUE, there must not be a valid
 *        token in the buffer.  This is complicated by the fact that at
 *        return time, there will either be a valid non-redirection token
 *        in the buffer, or there will be no valid token because none were
 *        available.  To determine whether to do an unget, we keep counts
 *        of tokens read (minus the one passed at call time) and tokens
 *        used.  If they are equal, we unget the last one; if not, then
 *        no data was available.
 */

        if (didflg) {
                if (getcnt == didflg)
                        Lex(LX_UNGET,0) ;
                return(TRUE) ;
        } else
                return(FALSE) ;
}




/***    BinaryOperator - parse binary operators
 *
 *  Purpose:
 *      Parse a production which contains a binary operator.  Parse the left
 *      side of the operator.  If the next token is the operator we are looking
 *      for, build a node for it, call the operator's production parsing
 *      routine to parse the right side of the operator, put all the pieces
 *      together.
 *
 *  struct node *BinaryOperator(TCHAR *opstr, int optype,
 *              struct node *opprodfunc(), struct node *leftprodfunc())
 *
 *  Args:
 *      opstr - string representation of the operator to look for
 *      optype - type of operator
 *      opprodfunc - the function which parses this operator
 *      leftprodfunc - the function which parses the left side of the operator
 *
 *  Returns:
 *      If the node is found, a pointer to the node for the operator.
 *      Otherwise, a pointer to the "left side" of the oprator.
 *
 */

struct node *BinaryOperator(opstr, optype, opprodfunc, leftprodfunc)
TCHAR *opstr ;
int optype ;
PPARSE_ROUTINE opprodfunc ;
PPARSE_ROUTINE leftprodfunc ;
{
        struct node *n ;   /* Ptr to binop node to build and fill  */
        struct node *leftside ;    /* Ptr to the leftside of the binop */

        DEBUG((PAGRP, PALVL, "BINOP: op = %ws", opstr)) ;

        leftside = (*leftprodfunc)() ;

/* M011 - Ref to IsData() was ref to Peek()
 */
        if (IsData())    /* If data left, read token - else, return */
                GeToken(GT_NORMAL) ;
        else {
                DEBUG((PAGRP, PALVL, "BINOP: No more data, return lh side.")) ;
                return(leftside) ;
        } ;

/*  This conditional tests for two cases; a true occurance of the binary op
 *  being sought, or the occurance of a newline acting as a command seperator
 *  within a parenthetical statement.
 */
        if (_tcscmp(opstr, TokBuf) == 0 ||
            (StatementType[StatementDepth-1] == PARTYP &&
             _tcscmp(opstr, CSSTR) == 0 &&
             *TokBuf == NLN
            )
           ) {

/*  M004 - This functionality was moved here from ParseS0.  It handles the
 *         stripping of newlines that occur following the first production
 *         in a parenthetical operation.  And will eliminate the newline's
 *         acting as a command seperator when the right side production is
 *         only the terminating right paren.
 *  M010 - Added fix for problem of token after newline being eaten if
 *         inside a parenthetical statment.
 */
                if (*TokBuf == NLN) {           /* Only TRUE if inside ()  */
                        do {
                                GeToken(GT_NORMAL) ;
                        } while (*TokBuf == NLN) ;
                        Lex(LX_UNGET,0) ;       /* M011 - Was UnGeToken()  */
                        if (*TokBuf == RPOP) {
                                DEBUG((PAGRP, PALVL, "BINOP: Ungetting right paren.")) ;
                                return(leftside) ;      /* Return left only  */
                        }
                        optype = LFTYP;
                } ;
/*  M004/M010 ends      */

                DEBUG((PAGRP, PALVL, "BINOP: Found %ws", opstr)) ;
                n = mknode() ;

                if (n == NULL) {
                    Abort();
                }

                n->type = optype ;
                n->lhs = leftside ;
                AtIsToken = 1; /* @@4 */
                GeToken(GT_LPOP) ;              /* M000 - Was GT_NORMAL            */
                AtIsToken = 0; /* @@4 */
                n->rhs = (*opprodfunc)() ;
                DEBUG((PAGRP, PALVL, "BINOP: Exiting op = %ws", opstr)) ;
                return(n) ;

        } else {
                Lex(LX_UNGET,0) ;               /* M011 - Was UnGeToken()  */
                DEBUG((PAGRP, PALVL, "BINOP: Did NOT find %ws", opstr)) ;
        } ;

        DEBUG((PAGRP, PALVL, "BINOP: Exiting op = %ws", opstr)) ;
        return(leftside) ;
}




/***    BuildArgList - parse FOR statement argument list
 *
 *  Purpose:
 *      Build a FOR statement's argument list. Collapse it into the following
 *      form "a0 a1 a2 a3...".
 *
 *  TCHAR *BuildArgList()
 *
 *  Returns:
 *      A pointer to the argument list.
 */

TCHAR *BuildArgList()
{
        TCHAR *args = NULL ;    /* Ptr to squeezed FOR arg list     */
        int arglen = 0 ;       /* Length of current arg            */
        int done = 0 ;                  /* Flag, nonzero if done            */

        DEBUG((PAGRP, PALVL, "BARGL: Entered.")) ;
        if(GeToken(GT_LPOP) != LPOP)
                PSError() ;

        for ( ; !done ; ) {
                switch (GeToken(GT_RPOP)) {     /* M000 - Was GT_NORMAL    */
                        case TEXTOKEN:      /* Another arg was found, add it to the list */
                        arglen += TokLen ;
                        if (args) {
                                args = resize(args, arglen*sizeof(TCHAR)) ;
                                SpaceCat(args, args, TokBuf) ;
                        } else {
                                args = gmkstr(arglen*sizeof(TCHAR)) ; /*WARNING*/
                                mystrcpy(args, TokBuf) ;
                        } ;

                        DEBUG((PAGRP, PALVL, "BARGL: Current args = %ws", args)) ;
                        break ;

                        case NLN:           /* Skip newlines */
                        continue ;

                        default:            /* If anything else, we're done */
                        done = TRUE ;
                        break ;
                } ;
        } ;

        /* When the loop exits, the current token should be a right paren */
        if (TokTyp == RPOP) {
                DEBUG((PAGRP, PALVL, "BARGL: Exiting, args = %ws", args)) ;
                return(args) ;
        } ;

        PSError() ;
        return NULL;
}





/***    GetCheckStr - get and check a token
 *
 *  Purpose:
 *      Get a token and compare it against the string passed.  If they don't
 *      match, call PSError().
 *
 *  GetCheckStr(TCHAR *str)
 *
 *  Args:
 *      str - the string to compare with the token
 *
 */

void GetCheckStr(str)
TCHAR *str ;
{
        GeToken(GT_NORMAL) ;

        if (_tcsicmp(str, TokBuf) != 0)
                PSError() ;

        DEBUG((PAGRP, PALVL, "GETCS: Exiting.")) ;
}




/***    GeTexTok - get a text token
 *
 *  Purpose:
 *      Get the next text token, allocate a string for it and copy it into the
 *      string.
 *
 *  TCHAR *GeTexTok(unsigned gtflag)
 *
 *  Args:
 *      gtflag - flag to be passed to GeToken()
 *
 *  Returns:
 *      A pointer to the string.
 *
 *                      *** W A R N I N G ! ***
 *      THIS ROUTINE WILL CAUSE AN ABORT IF MEMORY CANNOT BE ALLOCATED
 *              THIS ROUTINE MUST NOT BE CALLED DURING A SIGNAL
 *              CRITICAL SECTION OR DURING RECOVERY FROM AN ABORT
 *
 */

TCHAR *GeTexTok(gtflag)
unsigned gtflag ;
{
        TCHAR *s ;  /* Ptr to the text token    */

        if (GeToken(gtflag) != TEXTOKEN)
                PSError() ;

        s = gmkstr(TokLen*sizeof(TCHAR)) ;    /*WARNING*/
        mystrcpy(s, TokBuf) ;

        DEBUG((PAGRP, PALVL, "GETT: Exiting.")) ;
        return(s) ;
}




/***    GeToken - get a token
 *
 *  Purpose:
 *      If there is a previous token, make it the current token.  Otherwise,
 *      call the lexer to get another token and make it the current token.
 *
 *  unsigned GeToken(unsigned flag)
 *
 *  Args:
 *      flag - passed to lexer to tell it to get an argstring or regular token
 *
 *  Returns:
 *      The type of the current token.
 *
 */

unsigned GeToken(flag)
unsigned flag ;
{
        unsigned Lex() ;

        if(PendingParens != 0)
                flag = flag | GT_RPOP ;
        if ((TokTyp = Lex((TCHAR *)TokBuf, (unsigned)flag)) == (unsigned )LEXERROR)
                PError() ;

        TokLen = mystrlen(TokBuf)+1 ;

        DEBUG((PAGRP, PALVL, "    GET: type = 0x%04x  token = `%ws'  toklen = %d", TokTyp, TokBuf, TokLen)) ;
        if (fDumpTokens)
            cmd_printf( TEXT("GeToken: (%x) '%s'\n"), TokTyp, TokBuf);
        return(TokTyp) ;
}




/***    LoadNodeTC - make and load a command node
 *
 *  Purpose:
 *      Make a command node and load its type field with the argument and
 *      its cmdline field with the current token.
 *
 *  struct cmdnode *LoadNodeTC(int type)
 *
 *  Args:
 *      type - the type of command
 *
 *  Returns:
 *      A pointer to the node that was made.
 *
 *                      *** W A R N I N G ! ***
 *      THIS ROUTINE WILL CAUSE AN ABORT IF MEMORY CANNOT BE ALLOCATED
 *              THIS ROUTINE MUST NOT BE CALLED DURING A SIGNAL
 *              CRITICAL SECTION OR DURING RECOVERY FROM AN ABORT
 *
 */

struct cmdnode *LoadNodeTC(type)
int type ;
{
        struct cmdnode *n ;    /* Ptr to the cmdnode to build and fill */

        n = (struct cmdnode *) mknode() ;

        if (n == NULL) {
            Abort();
        }

        n->type = type ;
        n->flag = 0 ;
        n->cmdline = gmkstr(TokLen*sizeof(TCHAR)) ;   /*WARNING*/
        mystrcpy(n->cmdline, TokBuf) ;

        DEBUG((PAGRP, PALVL, "LOAD: type = %04x", type)) ;
        return(n) ;
}




/***    PError - handle parser error
 *
 *  Purpose:
 *      Parser via longjmp().
 *
 *  PError()
 *
 *  Returns:
 *      PARSERROR
 *
 */

void PError()
{
    global_dfvalue = MSG_SYNERR_GENL;  /* @@J1 PSError, not jump in parser*/
    longjmp(CmdJBuf1, PARSERROR) ;
}




/***    PSError - print error message and handle parser error
 *
 *  Purpose:
 *      Print the parser syntax error message and return to Parser via
 *      longjmp().
 *
 *  PSError()
 *
 *  Returns:
 *      PARSERROR
 *
 *  Notes:
 *      M021 - Unfragmented Syntax error messages and revised function.
 *
 */

void PSError( )
{
/*@@4*/ unsigned do_jmp;

/*@@4*/ do_jmp = global_dfvalue != MSG_SYNERR_GENL;

/*@@4*/ if ( global_dfvalue == READFILE )
          {
/*@@4*/    global_dfvalue = MSG_SYNERR_GENL;
          }
        else
          {
           if (*TokBuf == NLN)
             {
              PutStdErr(MSG_BAD_SYNTAX, NOARGS) ;
             }
           else
             {
/*@@4*/           if (*TokBuf != NULLC)                    /* @@J1 if no data wrong then */
/*@@4*/         {                             /* @@J1 do not give message   */
                 PutStdErr(MSG_SYNERR_GENL, ONEARG, TokBuf );
/*@@4*/         }                             /* @@J1                       */
             }
          }
/*@@4*/ if ( do_jmp ) {
            longjmp(CmdJBuf1, PARSERROR) ;
/*@@4*/ }
}




/***    SpaceCat - concatenate 2 strings and delimit the strings with a space
 *
 *  Purpose:
 *      Copy src1 to dst. Then concatenate a space and src2 to the end of
 *      dst.
 *
 *  SpaceCat(TCHAR *dst, TCHAR *src1, TCHAR *src2)
 *
 *  Args:
 *      See above
 *
 */

void SpaceCat(dst, src1, src2)
TCHAR *dst,
        *src1,
        *src2 ;
{
        mystrcpy(dst, src1) ;
        mystrcat(dst, TEXT(" ")) ;
        mystrcat(dst, src2) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cother.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cother.c

Abstract:

    Miscellaneous commands

--*/

#include "cmd.h"

extern TCHAR Fmt19[] ;                                          /* M006    */
extern PTCHAR    pszTitleOrg;
extern WORD wDefaultColor;
extern TCHAR GotoStr[] ;
extern TCHAR GotoEofStr[] ;
extern int LastRetCode ;


/***    eCls - execute the Cls command
 *
 *  Purpose:
 *      Output to STDOUT, the ANSI escape sequences used to clear a screen.
 *
 *  int eCls(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the cls command
 *
 *  Returns:
 *      SUCCESS always.
 *
 *  Notes:
 *      M001 - Replaced old ANSI sequence with VIO interface.
 *      M006 - To insure we get correct background color, we print a space
 *             and then read the cell just printed using it to clear with.
 */

int
eCls(
    struct cmdnode *n
    )
{

    CONSOLE_SCREEN_BUFFER_INFO  ConsoleScreenInfo;
    HANDLE      handle;
#ifdef WIN95_CMD
    DWORD dwWritten;
    DWORD nCells;
#else
    COORD       ScrollTarget;
    CHAR_INFO   chinfo;
    SMALL_RECT  ScrollRect;
#endif

    UNREFERENCED_PARAMETER( n );

    //
    // for compatibility with DOS errorlevels, don't set LastRetCode for cls
    //

    if (!FileIsDevice(STDOUT)) {
        cmd_printf( TEXT("\014") );             // ^L
        return(SUCCESS) ;
    }

    handle = GetStdHandle(STD_OUTPUT_HANDLE);
    if (!GetConsoleScreenBufferInfo( handle,  &ConsoleScreenInfo)) {

        cmd_printf( TEXT("\014") );             // ^L
        return(SUCCESS) ;
    }

#ifndef WIN95_CMD

    ScrollTarget.Y = (SHORT)(0 - ConsoleScreenInfo.dwSize.Y);
    ScrollTarget.X = 0;

    ScrollRect.Top = 0;
    ScrollRect.Left = 0;
    ScrollRect.Bottom = ConsoleScreenInfo.dwSize.Y;
    ScrollRect.Right =  ConsoleScreenInfo.dwSize.X;
    chinfo.Char.UnicodeChar = TEXT(' ');
    chinfo.Attributes = ConsoleScreenInfo.wAttributes;
    ScrollConsoleScreenBuffer(handle, &ScrollRect, NULL, ScrollTarget, &chinfo);

    ConsoleScreenInfo.dwCursorPosition.X = 0;
    ConsoleScreenInfo.dwCursorPosition.Y = 0;

#else

    ConsoleScreenInfo.dwCursorPosition.X = 0;
    ConsoleScreenInfo.dwCursorPosition.Y = 0;

    nCells = ConsoleScreenInfo.dwSize.Y*ConsoleScreenInfo.dwSize.X;

    FillConsoleOutputCharacterA( handle, ' ', nCells, ConsoleScreenInfo.dwCursorPosition,  &dwWritten);

    FillConsoleOutputAttribute( handle, ConsoleScreenInfo.wAttributes, nCells, ConsoleScreenInfo.dwCursorPosition, &dwWritten );

#endif

    SetConsoleCursorPosition( GetStdHandle(STD_OUTPUT_HANDLE), ConsoleScreenInfo.dwCursorPosition );
    return(SUCCESS) ;
}


extern unsigned DosErr ;

/***    eExit - execute the Exit command
 *
 *  Purpose:
 *      Set the LastRetCode to SUCCESS because this command can never fail.
 *      Then call SigHand() and let it decide whether or not to exit.
 *
 *  eExit(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the exit command
 *
 */

int
eExit(
    struct cmdnode *n
    )
{
    TCHAR *tas;
    LONG exitCode;

    tas = n->argptr;

    //
    // Find first non-blank argument.
    //
    while (tas && *tas && *tas <= SPACE)
        tas += 1;

    //
    // If first argument is /B, then remember that in cmdnode
    //
    if (tas != NULL && !_tcsnicmp(tas, TEXT("/B"), 2)) {
        n->type = GOTYP;
        n->argptr = GotoEofStr;

        //
        // Skip over /B and trailing spaces
        //
        tas += 2;
        while (tas && *tas && *tas <= SPACE)
            tas += 1;
    }

    //
    // See numeric argument given.  If so, set LastRetCode
    // with it.
    //
    if (tas && _stscanf( tas, TEXT("%d"), &exitCode ) == 1) {
        LastRetCode = exitCode;
    }

    if (n->type == GOTYP && CurrentBatchFile != NULL)
        return eGoto(n);
    else {
        ResetConTitle(pszTitleOrg);
        CMDexit(LastRetCode);
    }

    return(SUCCESS) ;
}




/***    eVerify - execute the Verify command
 *
 *  Purpose:
 *      To set the verify mode or display the current verify mode.
 *
 *  int eVerify(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the verify command
 *
 *  Returns:
 *      SUCCESS if a valid argument was given.
 *      FAILURE if an invalid argument was given.
 *
 */

int
eVerify(
    struct cmdnode *n
    )
{
    return( LastRetCode = VerifyWork(n) );
}

int
VerifyWork(
    struct cmdnode *n
    )
{
        int oocret ;    /* The return code from OnOffCheck()    */

        DEBUG((OCGRP, VELVL, "eVERIFY: Entered.")) ;

        switch (oocret = OnOffCheck(n->argptr, OOC_ERROR)) {
                case OOC_EMPTY:

/* M005 */              PutStdOut(((GetSetVerMode(GSVM_GET)) ? MSG_VERIFY_ON : MSG_VERIFY_OFF), NOARGS);
                        break ;

                case OOC_OTHER:
                        return(FAILURE) ;

                default:
                        GetSetVerMode((BYTE)oocret) ;
        } ;

        return(SUCCESS) ;
}


BOOLEAN Verify=FALSE;

/***    GetSetVerMode - change the verify mode
 *
 *  Purpose:
 *      Get old verify mode and, optionally, set verify mode as specified.
 *
 *  TCHAR GetSetVerMode(TCHAR newmode)
 *
 *  Args:
 *      newmode - the new verify mode or GSVM_GET if mode isn't to be changed
 *
 *  Returns:
 *      The old verify mode.
 *
 */

BOOLEAN
GetSetVerMode(
    BYTE newmode
    )
{
    if (newmode != GSVM_GET) {
        Verify = (BOOLEAN)(newmode == GSVM_ON ? TRUE : FALSE);
    }
    return Verify;
}

// execute the COLOR internal command....
int
eColor(
    struct cmdnode *n
    )
{
    WORD    wColor = 0;
    int     ocRet, digit;
    TCHAR*  arg;

    ocRet = OnOffCheck( n->argptr, OOC_NOERROR );
    switch( ocRet )
    {
        case OOC_EMPTY:
            wColor = wDefaultColor; // reset to default
            break;
        case OOC_OTHER:
            arg = n->argptr;

            arg = SkipWhiteSpace( arg );

            for( ; *arg && _istxdigit(*arg) ; ++arg) {
                digit = (int) (*arg <= TEXT('9'))
                    ? (int)*arg - (int)'0'
                    : (int)_totlower(*arg)-(int)'W' ;
                wColor = (wColor << 4)+digit ;
            }

            arg = SkipWhiteSpace( arg );

            // make sure nothing left and value between 0 and 0xff...
            if ( !(*arg) && (wColor < 0x100) )
                break;
            // else fall through to display help....
        default:
            // display help string....
            BeginHelpPause();
            PutStdOut( MSG_HELP_COLOR, NOARGS );
            EndHelpPause();
            return SUCCESS;
    }

    return LastRetCode = SetColor(wColor);
}


// set the console to a given color -- if a console....
int
SetColor(
    WORD attr
    )
{
    CONSOLE_SCREEN_BUFFER_INFO  csbi;
    HANDLE  hStdOut;
    COORD   coord;
    DWORD   dwWritten;

    //
    // Fail if foreground and background color the same.
    //
    if ((attr & 0xF) == ((attr >> 4) & 0xF)) {
        return FAILURE;
        }

    // get the handle....
    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    // get the console info....
    if (GetConsoleScreenBufferInfo( hStdOut, &csbi)) {
        // fill the screen with the color attribute....
        coord.Y = 0;
        coord.X = 0;
        FillConsoleOutputAttribute( hStdOut, attr, csbi.dwSize.Y*csbi.dwSize.X, coord, &dwWritten );
        // make sure the color sticks....
        SetConsoleTextAttribute( hStdOut, attr );
        return SUCCESS;
    }

    return FAILURE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cpath.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cpath.c

Abstract:

    Path-related commands

--*/

#include "cmd.h"

extern TCHAR SwitChar, PathChar;

extern TCHAR Fmt17[] ;

extern TCHAR CurDrvDir[] ;

extern int LastRetCode ; /* @@ */
extern TCHAR TmpBuf[] ;


/**************** START OF SPECIFICATIONS ***********************/
/*                                                              */
/* SUBROUTINE NAME: eMkDir                                      */
/*                                                              */
/* DESCRIPTIVE NAME: Begin execution of the MKDIR command       */
/*                                                              */
/* FUNCTION: This routine will make any number of directories,  */
/*           and will continue if it encounters a bad argument. */
/*           eMkDir will be called if the user enters MD or     */
/*           MKDIR on the command line.                         */
/*                                                              */
/* NOTES:                                                       */
/*                                                              */
/* ENTRY POINT: eMkDir                                          */
/*     LINKAGE: Near                                            */
/*                                                              */
/* INPUT: n - parse tree node containing the MKDIR command      */
/*                                                              */
/* EXIT-NORMAL: returns SUCCESS if all directories were         */
/*              successfully created.                           */
/*                                                              */
/* EXIT-ERROR:  returns FAILURE otherwise                       */
/*                                                              */
/* EFFECTS: None.                                               */
/*                                                              */
/* INTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*      LoopThroughArgs - break up command line, call MdWork    */
/*                                                              */
/* EXTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*                                                              */
/**************** END OF SPECIFICATIONS *************************/


int eMkdir(n)
struct cmdnode *n ;
{

        DEBUG((PCGRP, MDLVL, "MKDIR: Entered.")) ;
        return(LastRetCode = LoopThroughArgs(n->argptr, MdWork, LTA_CONT)) ;
}



/**************** START OF SPECIFICATIONS ***********************/
/*                                                              */
/* SUBROUTINE NAME: MdWork                                      */
/*                                                              */
/* DESCRIPTIVE NAME: Make a directory                           */
/*                                                              */
/* FUNCTION: MdWork creates a new directory.                    */
/*                                                              */
/* NOTES:                                                       */
/*                                                              */
/* ENTRY POINT: MdWork                                          */
/*     LINKAGE: Near                                            */
/*                                                              */
/* INPUT: arg - a pointer to a NULL terminated string of the    */
/*              new directory to create.                        */
/*                                                              */
/* EXIT-NORMAL: returns SUCCESS if the directory is made        */
/*              successfully                                    */
/*                                                              */
/* EXIT-ERROR:      returns FAILURE otherwise                       */
/*                                                              */
/* EFFECTS: None.                                               */
/*                                                              */
/* INTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*      PutStdErr - Writes to standard error                    */
/*                                                              */
/* EXTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*      DOSMKDIR                                                */
/*                                                              */
/**************** END OF SPECIFICATIONS *************************/


int MdWork(arg)
TCHAR *arg ;
{
    ULONG Status;
    TCHAR *lpw;
    TCHAR TempBuffer[MAX_PATH];
    DWORD Length;

    /*  Check if drive is valid because Dosmkdir does not
        return invalid drive   @@5 */

    if ((arg[1] == COLON) && !IsValidDrv(*arg)) {

        PutStdErr(ERROR_INVALID_DRIVE, NOARGS);
        return(FAILURE) ;
    }

    
    Length = GetFullPathName(arg, MAX_PATH, TempBuffer, &lpw);
    if (Length == 0) {
        PutStdErr( GetLastError(), NOARGS);
        return FAILURE;
    }

    if (Length >= MAX_PATH) {
        PutStdErr( MSG_FULL_PATH_TOO_LONG, ONEARG, arg );
        return FAILURE;
    }

    if (CreateDirectory( arg, NULL )) {
        return SUCCESS;
    }

    Status = GetLastError();

    if (Status == ERROR_ALREADY_EXISTS) {

        PutStdErr( MSG_DIR_EXISTS, ONEARG, arg );
        return FAILURE;

    } else if (Status != ERROR_PATH_NOT_FOUND) {
        PutStdErr( Status, NOARGS);
        return FAILURE;
    }

    //
    //  If no extensions, then simply fail.
    //

    if (!fEnableExtensions) {
        PutStdErr(ERROR_CANNOT_MAKE, NOARGS);
        return FAILURE;
    }

    //
    //  loop over input path and create any needed intermediary directories.
    //
    //  Find the point in the string to begin the creation.  Note, for UNC
    //  names, we must skip the machine and the share
    //

    if (TempBuffer[1] == COLON) {

        //
        //  Skip D:\
        //

        lpw = TempBuffer+3;
    } else if (TempBuffer[0] == BSLASH && TempBuffer[1] == BSLASH) {

        //
        //  Skip \\server\share\
        //

        lpw = TempBuffer+2;
        while (*lpw && *lpw != BSLASH) {
            lpw++;
        }
        if (*lpw) {
            lpw++;
        }

        while (*lpw && *lpw != BSLASH) {
            lpw++;
        }
        if (*lpw) {
            lpw++;
        }
    } else {
        //
        //  For some reason, GetFullPath has given us something we can't understand
        //

        PutStdErr(ERROR_CANNOT_MAKE, NOARGS);
        return FAILURE;
    }

    //
    //  Walk through the components creating them
    //


    while (*lpw) {

        //
        //  Move forward until the next path separator
        //

        while (*lpw && *lpw != BSLASH) {
            lpw++;
        }

        //
        //  If we've encountered a path character, then attempt to
        //  make the given path.
        //

        if (*lpw == BSLASH) {
            *lpw = NULLC;
            if (!CreateDirectory( TempBuffer, NULL )) {
                Status = GetLastError();
                if (Status != ERROR_ALREADY_EXISTS) {
                    PutStdErr( ERROR_CANNOT_MAKE, NOARGS );
                    return FAILURE;
                }
            }
            *lpw++ = BSLASH;
        }
    }

    if (!CreateDirectory( TempBuffer, NULL )) {
        Status = GetLastError( );
        if (Status != ERROR_ALREADY_EXISTS) {
            PutStdErr( Status, NOARGS);
            return FAILURE;
        }
    }

    return(SUCCESS);

}




/***    eChdir - execute the Chdir command
 *
 *  Purpose:
 *      If the command is "cd", display the current directory of the current
 *      drive.
 *
 *      If the command is "cd d:", display the current directory of drive d.
 *
 *      If the command is "cd str", change the current directory to str.
 *
 *  int eChdir(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the chdir command
 *
 *  Returns:
 *      SUCCESS if the requested task was accomplished.
 *      FAILURE if it was not.
 *
 */

int eChdir(n)
struct cmdnode *n ;
{
    TCHAR *tas, *src, *dst; /* Tokenized arg string */
    TCHAR dirstr[MAX_PATH] ;/* Holds current dir of specified drive */

    //
    // If extensions are enabled, dont treat spaces as delimeters so it is
    // easier to CHDIR to directory names with embedded spaces without having
    // to quote the directory name
    //
    tas = TokStr(n->argptr, TEXT( "" ), fEnableExtensions ? TS_WSPACE|TS_SDTOKENS : TS_SDTOKENS) ;

    if (fEnableExtensions) {
        //
        // If extensions were enabled we could have some trailing spaces
        // that need to be nuked since there weren't treated as delimeters
        // by TokStr call above.
        //
        //  We compress the extra spaces out since we rely on the tokenized
        //  format later inside ChdirWork
        //

        src = tas;
        dst = tas;
        while (*src) {
            while (*dst = *src++)
                dst += 1;

            while (_istspace(dst[-1]))
                dst -= 1;
            *dst++ = NULLC;
        }

        *dst = NULLC;
    }

    DEBUG((PCGRP, CDLVL, "CHDIR: tas = `%ws'", tas)) ;

    mystrcpy( tas, StripQuotes( tas ) );

    //
    //  No arguments means display current drive and directory
    //
    
    if (*tas == NULLC) {
        GetDir(CurDrvDir, GD_DEFAULT) ;
        cmd_printf(Fmt17, CurDrvDir) ;
    } else 
        
        
    //
    //  single drive letter means display current dirctory on that drive
    //

    if (mystrlen(tas) == 2 && *(tas+1) == COLON && _istalpha(*tas)) {
        GetDir(dirstr, *tas) ;
        cmd_printf(Fmt17, dirstr) ;
    } else 
        
    //
    //  We need to change current directory (and possibly drive)
    //

    {
        return( LastRetCode = ChdirWork(tas) );
    }
    
    return( LastRetCode = SUCCESS );
}

int ChdirWork( TCHAR *tas )
{
    unsigned  i = MSG_BAD_SYNTAX;

    //
    //  If there's no leading "/D", just chdir
    //  to the input path
    //
    if (_tcsnicmp( tas, TEXT( "/D" ), 2)) {
        i = ChangeDir((TCHAR *)tas);
    } else {
        //
        //  Advance over the "/D" and intervening whitespace
        //

        tas = SkipWhiteSpace( tas + 2 );

        //
        //  if there's no other switch char, strip any quotes and do
        //  the chdir
        //
        
        if (*tas != SwitChar) {
            _tcscpy( tas, StripQuotes( tas ));
            i = ChangeDir2(tas, TRUE);
        }
    }
    
    if (i != SUCCESS) {
        PutStdErr( i, ONEARG, tas);
        return (FAILURE) ;
    }
    return (SUCCESS) ;
}

#define SIZEOFSTACK 25
typedef struct {
    PTCHAR SavedDirectory;
    TCHAR NetDriveCreated;
} *PSAVEDDIRECTORY;

PSAVEDDIRECTORY SavedDirectoryStack = NULL;

int StrStackDepth = 0;
int MaxStackDepth = 0;


int GetDirStackDepth(void)
{
    return StrStackDepth;
}

int
PushStr ( PTCHAR pszString )
{
    //
    //  If we're full, grow the stack by an increment
    //
    
    if (StrStackDepth == MaxStackDepth) {
        PSAVEDDIRECTORY Tmp = 
            realloc( SavedDirectoryStack, 
                     sizeof( *SavedDirectoryStack ) * (MaxStackDepth + SIZEOFSTACK));
        if (Tmp == NULL) {
            return FALSE;
        }
        SavedDirectoryStack = Tmp;
        MaxStackDepth += SIZEOFSTACK;
    }

    SavedDirectoryStack[ StrStackDepth ].SavedDirectory = pszString;
    SavedDirectoryStack[ StrStackDepth ].NetDriveCreated = NULLC;
    StrStackDepth += 1;
    return TRUE;
}

PTCHAR
PopStr ()
{

    PTCHAR pszString;

    if (StrStackDepth == 0) {
        return ( NULL );
    }
    StrStackDepth -= 1;
    pszString = SavedDirectoryStack[StrStackDepth].SavedDirectory;
    if (SavedDirectoryStack[StrStackDepth].NetDriveCreated != NULLC) {
        TCHAR szLocalName[4];

        szLocalName[0] = SavedDirectoryStack[StrStackDepth].NetDriveCreated;
        szLocalName[1] = COLON;
        szLocalName[2] = NULLC;
        SavedDirectoryStack[StrStackDepth].NetDriveCreated = NULLC;
        try {
            WNetCancelConnection2(szLocalName, 0, TRUE);
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }
    SavedDirectoryStack[StrStackDepth].SavedDirectory = NULL;

    //
    //  If we can eliminate an increment from the stack, go do so
    //
    
    if (StrStackDepth > 0 && StrStackDepth + 2 * SIZEOFSTACK <= MaxStackDepth) {
        PSAVEDDIRECTORY Tmp =
            realloc( SavedDirectoryStack,
                     sizeof( *SavedDirectoryStack ) * (StrStackDepth + SIZEOFSTACK));
        if (Tmp != NULL) {
            SavedDirectoryStack = Tmp;
            MaxStackDepth = StrStackDepth + SIZEOFSTACK;
        }
    }

    return ( pszString );
}

VOID
DumpStrStack() {

    int i;

    for (i=StrStackDepth-1; i>=0; i--) {
        cmd_printf( Fmt17, SavedDirectoryStack[i].SavedDirectory );
    }
    return;
}

BOOLEAN
PushCurDir()
{

    PTCHAR pszCurDir;

    GetDir( CurDrvDir, GD_DEFAULT ) ;
    if ((pszCurDir=HeapAlloc( GetProcessHeap( ), 0, (mystrlen( CurDrvDir )+1)*sizeof( TCHAR ))) != NULL) {
        mystrcpy( pszCurDir, CurDrvDir) ;
        if (PushStr( pszCurDir ))
            return ( TRUE );
        HeapFree( GetProcessHeap( ), 0, pszCurDir );
    }
    return ( FALSE );

}

int ePushDir(n)
struct cmdnode *n ;
{
    TCHAR *tas ;            /* Tokenized arg string */
    PTCHAR pszTmp, s;

    //
    // If extensions are enabled, dont treat spaces as delimeters so it is
    // easier to CHDIR to directory names with embedded spaces without having
    // to quote the directory name
    //
    tas = TokStr(n->argptr, NULL, fEnableExtensions ? TS_WSPACE|TS_NOFLAGS : TS_NOFLAGS) ;
    if (fEnableExtensions) {
        //
        // If extensions were enabled we could have some trailing spaces
        // that need to be nuked since there weren't treated as delimeters
        // by TokStr call above.
        //
        s = lastc(tas);
        while (s > tas) {
            if (_istspace(*s))
                *s-- = NULLC;
            else
                break;
        }
    }
    
    mystrcpy(tas, StripQuotes(tas) );

    LastRetCode = SUCCESS;
    if (*tas == NULLC) {
        
        //
        // Print out entire stack
        //
        DumpStrStack();

    } else if (PushCurDir()) {
        
        //
        //  If extensions are enabled and a UNC name was given, then do
        //  a temporary NET USE to define a drive letter that we can
        //  use to change drive/directory to.  The matching POPD will
        //  delete the temporary drive letter.
        //
        
        if (fEnableExtensions && tas[0] == BSLASH && tas[1] == BSLASH) {
            NETRESOURCE netResource;
            TCHAR szLocalName[4];
            PTCHAR s;

            //
            //  If there is a directory specified after the \\server\share
            //  then test to see if that directory exists before doing any
            //  network connections
            //
            
            if ((s = _tcschr(&tas[2], BSLASH)) != NULL
                && (s = _tcschr(s+1, BSLASH)) != NULL) {

                if (GetFileAttributes( tas ) == -1) {
                    LastRetCode = GetLastError( );
                    if (LastRetCode == ERROR_FILE_NOT_FOUND) {
                        LastRetCode = ERROR_PATH_NOT_FOUND;
                    }
                } else {
                    *s++ = NULLC;
                }
            }

            szLocalName[0] = TEXT('Z');
            szLocalName[1] = COLON;
            szLocalName[2] = NULLC;
            netResource.dwType = RESOURCETYPE_DISK;
            netResource.lpLocalName = szLocalName;
            netResource.lpRemoteName = tas;
            netResource.lpProvider = NULL;
            
            while (LastRetCode == NO_ERROR && szLocalName[0] != TEXT('A')) {
                
                try {
                    LastRetCode = WNetAddConnection2( &netResource, NULL, NULL, 0);
                } except (LastRetCode = GetExceptionCode( ), EXCEPTION_EXECUTE_HANDLER) {
                }
                
                switch (LastRetCode) {
                case NO_ERROR:
                    SavedDirectoryStack[StrStackDepth-1].NetDriveCreated = szLocalName[0];
                    tas[0] = szLocalName[0];
                    tas[1] = szLocalName[1];
                    tas[2] = BSLASH;
                    if (s != NULL)
                        _tcscpy(&tas[3], s);
                    else
                        tas[3] = NULLC;
                    goto godrive;
                case ERROR_ALREADY_ASSIGNED:
                case ERROR_DEVICE_ALREADY_REMEMBERED:
                    szLocalName[0] = (TCHAR)((UCHAR)szLocalName[0] - 1);
                    LastRetCode = NO_ERROR;
                    break;
                default:
                    break;
                }
            }
            godrive:        ;
        }

        //
        //  The NET USE succeeded, now attempt to change the directory
        //  as well.
        //

        if (LastRetCode == NO_ERROR 
            && (LastRetCode = ChangeDir2( tas, TRUE )) == SUCCESS) {
            if (tas[1] == ':') {
                GetDir(CurDrvDir,tas[0]);
            }
        }

        if (LastRetCode != SUCCESS) {
            pszTmp = PopStr();
            HeapFree(GetProcessHeap(), 0, pszTmp);
            PutStdErr( LastRetCode, NOARGS );
            LastRetCode = FAILURE;
        }
    } else {
        PutStdErr( MSG_ERROR_PUSHD_DEPTH_EXCEEDED, NOARGS );
        LastRetCode = FAILURE;
    }

    return ( LastRetCode );
}

int ePopDir(n)
struct cmdnode *n ;
{

        PTCHAR pszCurDir;

        UNREFERENCED_PARAMETER( n );
        if (pszCurDir = PopStr()) {
                if (ChangeDir2( pszCurDir,TRUE ) == SUCCESS) {
                        HeapFree(GetProcessHeap(), 0, pszCurDir);
                        return( SUCCESS );
                }
                HeapFree(GetProcessHeap(), 0, pszCurDir);
        }
        return( FAILURE );
}


/***    eRmdir - begin the execution of the Rmdir command
 *
 *  Purpose:
 *      To remove an arbitrary number of directories.
 *
 *  int eRmdir(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the rmdir command
 *
 *  Returns:
 *      SUCCESS if all directories were removed.
 *      FAILURE if they weren't.
 *
 */

int eRmdir(n)
struct cmdnode *n ;
{
    DEBUG((PCGRP, RDLVL, "RMDIR: Entered.")) ;
    return(RdWork(n->argptr));              // in del.c
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\ctools1.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    ctools1.c

Abstract:

    Low level utilities

--*/

#include "cmd.h"

extern unsigned tywild; /* type is wild flag */
extern TCHAR CurDrvDir[], *SaveDir, PathChar, Delimiters[] ;

extern TCHAR VolSrch[] ;

extern TCHAR BSlash ;

extern unsigned DosErr ;

extern BOOL CtrlCSeen;

static TCHAR szNull[] = TEXT("");


/***    TokStr - tokenize argument strings
 *
 *  Purpose:
 *      Tokenize a string.
 *      Allocate space for a new string and copy each token in src into the
 *      new string and null terminate it.  Tokens are whitespace delimited
 *      unless changed by specialdelims and/or tsflags.  The entire tokenized
 *      string ends with 2 null bytes.
 *
 *  TCHAR *TokStr(TCHAR *src, TCHAR *specialdelims, unsigned tsflags)
 *
 *  Args:
 *      src - the string to be tokenized
 *      specialdelims - a string of other characters which are to be comsidered
 *          as token delimiters
 *      tsflags - bit 0 nonzero if whitespace are NOT delimiters
 *            bit 1 nonzero if special delimiters are tokens themselves,
 *            eg "foo=bar" => "foo0=0bar00"
 *
 *  Returns:
 *      A pointer to the new string.
 *      A pointer to a null string if src is NULL
 *      NULL if unable to allocate memory.
 *
 *  Notes:
 *      The format of the tokenized string dictates the way code is written
 *      to process the tokens in that string.  For instance, the code
 *      "s += mystrlen(s)+1" is the way to update s to point to the next token
 *      in the string.
 *
 *      Command considers "=", ",", and ";" to be token delimiters just like
 *      whitespace.  The only time they are not treated like whitespace is
 *      when they are included in specialdelims.
 *
 *                      *** W A R N I N G ! ***
 *      THIS ROUTINE WILL CAUSE AN ABORT IF MEMORY CANNOT BE ALLOCATED
 *              THIS ROUTINE MUST NOT BE CALLED DURING A SIGNAL
 *              CRITICAL SECTION OR DURING RECOVERY FROM AN ABORT
 *
 */

TCHAR *TokStr(src, specialdelims, tsflags)
TCHAR *src ;
TCHAR *specialdelims ;
unsigned tsflags ;
{
    TCHAR *ts ;     /* Tokenized string pointer                */
    TCHAR *tscpy,                /* Copy of ts                           */
        delist[5],          /* List of non-whitespace delimiter/separators  */
        c;                  /* Work variable                                */

    int first,          /* Flag, true if first time through the loop    */
        lctdelim,           /* Flag, true if last byte was token delimiter  */
        i, j ;              /* Index/loop counter                           */

        DEBUG((CTGRP, TSLVL, "TOKSTR: Entered &src = %04x, src = %ws",src,src));
        DEBUG((CTGRP, TSLVL, "TOKSTR: Making copy str of len %d",(mystrlen(src)*2+2))) ;

    if (src == NULL) {
        return(szNull);   // This routine returns a doubly null terminated string
        } else {
        ts = tscpy = gmkstr((mystrlen(src)*2+2)*sizeof(TCHAR)) ;  /*WARNING*/

        DEBUG((CTGRP, TSLVL, "TOKSTR: &tscpy = %04x",tscpy)) ;

        for (i = j = 0 ; c = *(&Delimiters[i]) ; i++)
                if (!mystrchr(specialdelims, c))
                        delist[j++] = c ;
        delist[j] = NULLC ;

        DEBUG((CTGRP, TSLVL, "TOKSTR: Delimiter string built as `%ws'",delist)) ;

        for (first = TRUE, lctdelim = TRUE ; *src ; src++) {

            if (
               (*src != QUOTE) &&
               (_istspace(*src) || mystrchr(delist, *src)) &&
               (!(tsflags & TS_WSPACE) || first) &&
               (!(tsflags & TS_SDTOKENS) || !mystrchr(specialdelims, *src)) &&
               (!(tsflags & TS_NWSPACE) || !mystrchr(specialdelims, *src)) ) {

                while ( *src &&
                    (*src != QUOTE) &&
                    (_istspace(*src) || mystrchr(delist, *src)) &&
                    (!(tsflags & TS_SDTOKENS) || !mystrchr(specialdelims, *src)) &&
                    (!(tsflags & TS_NWSPACE) || !mystrchr(specialdelims, *src)) )
                   src++ ;

                if (!(*src))
                    break ;

                if (!first && !lctdelim)
                    ts++ ;

                lctdelim = TRUE ;
            } ;

            first = FALSE ;

            if (specialdelims && mystrchr(specialdelims, *src)) {
                    if (tsflags & TS_SDTOKENS) {
                            if (lctdelim)
                                    *ts = *src ;
                            else
                                    *++ts = *src ;
                            lctdelim = TRUE ;
                            ts++ ;
                    } else {
                            if ( tsflags & TS_NWSPACE )
                                    *ts = *src ;
                            lctdelim = FALSE ;
                    }

                    ts++ ;
                    continue ;
            } ;

           *ts++ = *src ;
            if ( *src == QUOTE ) {
               do {
                    *ts++ = *(++src);
               } while ( src[0] && src[0] != QUOTE && src[1] );
               if ( !src[0] ) {
                  src--;
               }
            }

            lctdelim = FALSE ;
        } ;

        DEBUG((CTGRP, TSLVL, "TOKSTR: String complete, resizing to %d",ts-tscpy+2)) ;

        return(resize(tscpy, ((UINT)(ts-tscpy)+2)*sizeof(TCHAR))) ;

        DEBUG((CTGRP, TSLVL, "TOKSTR: Resizing done, returning")) ;
    }
}



/******************************************************************************/
/*                                                                            */
/*      LoopThroughArgs - call a function on all args in a list               */
/*                                                                            */
/*  Purpose:                                                                  */
/*      This is function is called by many of the commands that take          */
/*      multiple arguments.  This function will parse the argument string,    */
/*      complain if no args were given, and call func on each of the ards     */
/*      in argstr.  Optionally, it will also expand any wildcards in the      */
/*      arguments.  Execution stops if func ever returns FAILURE.             */
/*                                                                            */
/*  int LoopThroughArgs(TCHAR *argstr, int (*func)(), int ltaflags)           */
/*                                                                            */
/*  Args:                                                                     */
/*      argstr - argument string                                              */
/*      func - the function to pass each element of argstr                    */
/*      ltaflags - bit 0 on if wildcards are to be expanded                   */
/*                 bit 1 on if it's ok for argstr to be empty (nothing but whitespace)    */
/*                 bit 2 on if file names should be passed through un changed */
/*                      when the wildcard expansion fails to find any matches.*/
/*                                                                            */
/*  Returns:                                                                  */
/*      The value returned by func the last time it is run.                   */
/*                                                                            */
/******************************************************************************/

int LoopThroughArgs(argstr, func, ltaflags)
TCHAR *argstr ;
PLOOP_THROUGH_ARGS_ROUTINE func ;
int ltaflags ;
           {
            TCHAR *tas ;                /* Tokenized argument string       */
            TCHAR fspec[MAX_PATH] ;     /* Holds filespec when expanding   */
            WIN32_FIND_DATA buf ;       /* Use for ffirst/fnext            */
            HANDLE hnFirst ;
            CPYINFO fsinfo ;
            int catspot ;      /* Fspec index where fname should be added  */
            unsigned final_code = SUCCESS;
            unsigned error_code = SUCCESS;
            int multargs = FALSE;
            unsigned attr;/* attribute for ffirst for because of TYPE wild */
            unsigned taslen;


            tywild = FALSE;              /* global type wild card flag ret */

            GetDir(CurDrvDir, GD_DEFAULT);

            if (*(tas = TokStr(argstr, NULL, TS_NOFLAGS)) == NULLC)
            {
               if (ltaflags & LTA_NULLOK)
               {
               /* return((*func)(tas)) ; */
                  return((*func)( StripQuotes(tas) )) ;
               }

               PutStdErr(MSG_BAD_SYNTAX, NOARGS);
               return(FAILURE) ;
            }

            if (*(tas + mystrlen(tas) + 1) )    /* Check for multiple args */
            {
               multargs = TRUE;
            }

            for ( ; *tas ; tas += taslen+1 )
            {
               if (CtrlCSeen) {
                   return(FAILURE);
               }
               taslen = mystrlen( tas );
               mystrcpy( tas, StripQuotes( tas ) );

               if (ltaflags & LTA_EXPAND)
               {
                  if (cmdfound == TYTYP)   /* if TYPE cmd then only files   */
                  {
                     attr = FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_ARCHIVE;
                  }
                  else                     /* else                          */
                  {
                     attr = A_ALL;         /* find all                      */
                  }
                  //
                  // this is used to detect an error other then can not
                  // find file. It is set in ffirst
                  //
                  DosErr = 0;
                  if (!ffirst(tas, attr, &buf, &hnFirst))
                  {
                     //
                     // Check that failure was not do to some system error such
                     // as an abort on access to floppy
                     //
                     if (DosErr) {

                       if ((DosErr != ERROR_FILE_NOT_FOUND) &&
                           (DosErr != ERROR_NO_MORE_FILES)) {

                           PutStdErr(DosErr, NOARGS);

                           return( FAILURE );

                       }
                     }

                     if (ltaflags & LTA_NOMATCH)
                     {
                        if ( error_code = ((*func)(tas)) )
                        {
                           final_code = FAILURE;
                           if (multargs)     /* if cmd  failed then  (TYPE)*/
                           {                 /* display arg failed msg too */
                              PutStdErr( MSG_ERR_PROC_ARG, ONEARG, tas );
                           }
                        }
                        if ( error_code && !(ltaflags & LTA_CONT))
                        {
                           return(FAILURE) ;
                        }
                        else
                        {
                           continue;
                        }
                     }
                     PutStdErr(((DosErr == ERROR_PATH_NOT_FOUND) ?
                                 MSG_REN_INVAL_PATH_FILENAME :
                                 ERROR_FILE_NOT_FOUND),
                                 NOARGS);
                     return(FAILURE) ;
                  }

                  if (buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                     PutStdErr(MSG_REN_INVAL_PATH_FILENAME, NOARGS);
                     return(FAILURE) ;
                  }

                  fsinfo.fspec = tas ;
                  ScanFSpec(&fsinfo) ;
                  catspot = (int)(fsinfo.fnptr-tas) ;
                  mystrcpy(fspec, tas) ;

                  do
                  {
                     fspec[catspot] = NULLC ;
                     tywild |= multargs;      /* if multiple args or wild then wild for TYPE */
                     if ( error_code = ((*func)(mystrcat(fspec, buf.cFileName))) )
                     {
                        final_code = FAILURE;
                     }
                     if ( error_code && !(ltaflags & LTA_CONT))
                     {
                        return(FAILURE) ;
                     }
                  } while(fnext(&buf, attr, hnFirst));

                          findclose(hnFirst) ;
               }
               else
               {
                  tywild |= multargs;         /* if multiple args or wild then wild for TYPE */
        /*        if ( error_code = ((*func)(mystrcpy(fspec,tas))) )   */
                  if ( error_code = ((*func)(tas)) )
                  {
                     final_code = FAILURE;
                  }
                  if ( error_code && !(ltaflags & LTA_CONT))
                  {
                     return(FAILURE) ;
                  }
               }

               if (error_code && multargs)   /* error this time through */
               {
                  PutStdErr(MSG_ERR_PROC_ARG, ONEARG, tas );
               }
            }
            return( final_code ) ;
         }



BOOLEAN
IsDriveNameOnly (
    IN  PTCHAR psz
    )
{

    //
    // If it does not have any path character, is 2 chars long and
    // has a ':' it must be a drive
    //
    if (!mystrrchr(psz,PathChar)) {
        if ((mystrlen(psz) == 2) && psz[1] == COLON) {
            return( TRUE );
        }
    }
    return( FALSE );
}


/***    ScanFSpec - parse a path string
 *
 *  Purpose:
 *      To scan the filespec in cis to find the information needed to set the
 *      pathend, fnptr, extptr, and flags field of the structure.  Pathend is
 *      a ptr to the end of the path and can be NULL.  Fnptr is a ptr to the
 *      filename and may point to a null character.  Extptr is a ptr to the
 *      extension (including ".") and may point to a null character.
 *
 *  ScanFSpec(PCPYINFO cis)
 *
 *  Arg:
 *      cis - the copy information structure to fill
 *
 *  Notes:
 *      This function needs to be rewritten and cleanup more than any other
 *      function in the entire program!!!
 *
 *                      *** W A R N I N G ! ***
 *      THIS ROUTINE WILL CAUSE AN ABORT IF MEMORY CANNOT BE ALLOCATED
 *              THIS ROUTINE MUST NOT BE CALLED DURING A SIGNAL
 *              CRITICAL SECTION OR DURING RECOVERY FROM AN ABORT
 *
 */

BOOL ScanFSpec(cis)
PCPYINFO cis ;
{
    unsigned att ;
    UINT OldErrorMode;

    TCHAR *sds = &VolSrch[2] ;      /* "\*.*" Added to dir's    */

    TCHAR *fspec ;          /* Work Vars - Holds filespec              */
    TCHAR *wptr ;           /*           - General string pointer      */
    TCHAR c ;               /*           - Temp byte holder            */
    TCHAR c2 = NULLC ;      /* Another if two are needed   */
    int cbPath,             /*           - Length of incoming fspec    */
    dirflag = FALSE ;       /*           - FSpec is directory flag     */
    CRTHANDLE hn;
    PWIN32_FIND_DATA pfdSave;

    DosErr = NO_ERROR;
    DEBUG((CTGRP, SFLVL, "SCANFSPEC: cis = %04x  fspec = %04x  `%ws'",
           cis, cis->fspec, cis->fspec)) ;

    cbPath = mystrlen(cis->fspec) ;  /* Get length of filespec          */

    if (*(wptr = lastc(cis->fspec)) == COLON && cbPath > 2) {
        *wptr-- = NULLC ;       /* Zap colon if device name      */

        OldErrorMode = SetErrorMode( 0 );
        hn = Copen(cis->fspec, O_RDONLY|O_BINARY );
        if ((hn == BADHANDLE) || (!FileIsDevice(hn) && !FileIsPipe(hn))) {
            *++wptr = COLON;
            if (cmdfound == CPYTYP) {
                if (cpydest == FALSE) {
                    PutStdErr( MSG_CMD_NOT_RECOGNIZED, ONEARG, cis->fspec);
                }
                cdevfail = TRUE;
            } else {
                PutStdErr( MSG_CMD_NOT_RECOGNIZED, ONEARG, cis->fspec);
            }
            if (hn != BADHANDLE) {
                Cclose( hn );
            }

        } else {
            if ( FileIsDevice(hn) || FileIsPipe(hn) ) {
                Cclose( hn );
            }
        }
        SetErrorMode( OldErrorMode );
    }

    cis->buf = (PWIN32_FIND_DATA)gmkstr(sizeof(WIN32_FIND_DATA)) ;        /*WARNING*/

/* First it must be determined if this is a file or directory and if directory
 * a "\*.*" appended.  Filespec's that are "." or "\" or those ending in "\",
 * ":.", ".." or "\." are assumed to be directories.  Note that ROOT will fit
 * one of these patterns if explicitly named.  If no such pattern is found,
 * a Get Attributes system call is performed as a final test.  Note that
 * wildcards are not tested for, since the DOS call will fail defaulting them
 * to filenames.  Success of any test assumes directory with the "\*.*" being
 * appended, while failure of all tests assumes filename.
 */

/* If the filespec ends in a '\' set dirflag. Otherwise find where the
 * actual filename begins (by looking for last PathChar if there is one).
 * If there is no pathchar, then check if a drive and colon has been
 * specified. Update the pointer to point to the actual file name spec.
 * If it is a "." or ".." then set dirflag.
 */
    c = *wptr;
    if ( c  == PathChar ) {
        dirflag = TRUE ;
    } else {
        wptr = mystrrchr(cis->fspec, PathChar);
        if (wptr == NULL) {
            wptr = cis->fspec ;
            if ((mystrlen(wptr) >= 2) && (wptr[1] == COLON)) {
                wptr = &wptr[2];
            }
        } else {
            wptr++ ;
        }
        if ((_tcsicmp(wptr, TEXT(".")) == 0) || (_tcsicmp(wptr, TEXT("..")) == 0)) {
            dirflag = TRUE ;
        }
    }

    if (!dirflag) {
        if (cmdfound == CPYTYP) {               /* bypass if COPY cmd */
            if (cpydflag == TRUE) {
                att = GetFileAttributes(cis->fspec);
                DosErr = (att != -1 ? NO_ERROR : GetLastError());
                if (att != -1 ) {
                    if (att & FILE_ATTRIBUTE_DIRECTORY) {
                        dirflag = TRUE;
                    }
                }
            } else {
                if (cpyfirst == TRUE) {              /* and !first time    */
                    cpyfirst = FALSE;               /* and !first time    */
                    att = GetFileAttributes(cis->fspec);
                    DosErr = (att != -1 ? NO_ERROR : GetLastError());
                    if (att != -1 ) {
                        if (att & FILE_ATTRIBUTE_DIRECTORY) {
                            dirflag = TRUE;
                        }
                    }
                }
            }
        } else {
            att = GetFileAttributes(cis->fspec);
            DosErr = (att != -1 ? NO_ERROR : GetLastError());
            if (att != -1 ) {
                if (att & FILE_ATTRIBUTE_DIRECTORY) {
                    dirflag = TRUE;
                }
            }
        }
    }

/* Note that in the following conditional, the directory attribute is set
 * in cis->buf->attributes.  Some functions calling ScanFSpec() require this
 * knowledge.
 */
    if (dirflag) {
        if (c == PathChar)              /* If ending in "\"...     */
        {
            sds = &VolSrch[3] ;          /* ...add only "*.*" */
        }

        //
        // If was a drive then don't put wild card stuff on end or
        // dir c: will be the same as dir c:\*
        // Otherwise append wild card spec.
        //
        if (!IsDriveNameOnly(cis->fspec)) {
            cis->fspec = mystrcpy(gmkstr((cbPath+5)*sizeof(TCHAR)), cis->fspec) ;
            mystrcat(cis->fspec, sds) ;
        }

        cis->buf->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY ;    /* Fixup attribute           */
        DEBUG((CTGRP, SFLVL, "SCANFSPEC: changed fspec to fspec = `%ws'",cis->fspec)) ;
    }


/* Get a pointer to the end of the path in fspec.  Everytime a PathChar or
 * a correctly placed COLON is found, the pointer is updated.  "." and ".."
 * are not looked for because they should be caught above.
 */

    for (cbPath=1,wptr=NULL,fspec=cis->fspec; c=*fspec; fspec++,cbPath++) {
        if (c == PathChar || (c == COLON && cbPath == 2)) {
            wptr = fspec ;
        }
    }

    cis->pathend = wptr ;

    if (wptr) {                       /* Load ptr to fspec's filename    */
        cis->fnptr = (*wptr) ? wptr+1 : wptr ;
    } else {
        wptr = cis->fnptr = cis->fspec ;
    }

    if (mystrchr(wptr, STAR) || mystrchr(wptr, QMARK)) { /* has wildcards*/
        cis->flags |= CI_NAMEWILD;
        tywild = TRUE;               /* global type wild */
    }
    cis->extptr = mystrchr(wptr, DOT);        /* look for extension */

    DEBUG((CTGRP, SFLVL,
           "SCANFSPEC: pathend = %04x  fnptr = %04x  extptr = %04x  flags = %04x",
           cis->pathend, cis->fnptr, cis->extptr, cis->flags)) ;

    return TRUE;
}




/***    SetFsSetSaveDir - save current directory and change to another one
 *
 *  Purpose:
 *      Parse fspec.
 *      Save the current directory and change to the new directory
 *      specified in fspec.
 *
 *  PCPYINFO SetFsSetSaveDir(TCHAR *fspec)
 *
 *  Args:
 *      fspec - the filespec to use
 *
 *  Returns:
 *      A ptr to the cpyinfo struct fsinfo.
 *      FAILURE otherwise.
 *      SaveDir will contain what default dir was when SetFsSetSaveDir was
 *         called.
 *      CurDrvDir will contain the directory to execute the command in.
 *
 *                      *** W A R N I N G ! ***
 *      THIS ROUTINE WILL CAUSE AN ABORT IF MEMORY CANNOT BE ALLOCATED
 *              THIS ROUTINE MUST NOT BE CALLED DURING A SIGNAL
 *              CRITICAL SECTION OR DURING RECOVERY FROM AN ABORT
 *
 */

PCPYINFO SetFsSetSaveDir(fspec)
TCHAR *fspec ;
{
        TCHAR *tmpptr;
        TCHAR *buftemp;
        TCHAR  buft[MAX_PATH];

        TCHAR *pathend ;        /* Ptr to the end of the path in fspec  */
        TCHAR c ;               /* Work variable                        */
        PCPYINFO fsinfo ;/* Filespec information struct  */
        unsigned attr;          /* work variable                */
        PWIN32_FIND_DATA pfdSave;


        fsinfo = (PCPYINFO)gmkstr(sizeof(CPYINFO)) ; /*WARNING*/

        fsinfo->fspec = fspec ;

        ScanFSpec(fsinfo) ;

        pfdSave = fsinfo->buf;          /* save original find buffer */
        fspec = fsinfo->fspec ;
        pathend = fsinfo->pathend ;
        DEBUG((CTGRP, SSLVL, "SFSSD: pathend = `%ws'  fnptr = `%ws'",
                                fsinfo->pathend, fsinfo->fnptr)) ;

        SaveDir = gmkstr(MAX_PATH*sizeof(TCHAR)) ;         /*WARNING*/
        GetDir(SaveDir, GD_DEFAULT);      /* SaveDir will be current default */
        DEBUG((CTGRP, SSLVL, "SFSSD: SaveDir = `%ws'", SaveDir)) ;

/*      Added new test to second conditional below to test for the byte
 *         preceeding pathend to also be a PathChar.  In this way, "\\"
 *         in the root position will case a ChangeDir() call on "\\" which
 *         will fail and cause an invalid directory error as do similar
 *         sequences in other positions in the filespec.
 */
        if (FullPath(buft,fspec,MAX_PATH))
          {
           return((PCPYINFO) FAILURE) ;
          }

        buftemp = mystrrchr(buft,PathChar) + 1;

        *buftemp = NULLC;

        mystrcpy(CurDrvDir,buft);

        if (pathend && *pathend != COLON) {
           if (*pathend == PathChar &&
              (pathend == fspec ||
              *(tmpptr = prevc(fspec, pathend)) == COLON ||
              *tmpptr == PathChar)) {
                 pathend++ ;
               }
           c = *pathend;
           *pathend = NULLC;
           DEBUG((CTGRP, SSLVL, "SFSSD: path = `%ws'", fspec)) ;
           attr = GetFileAttributes(fspec);
           DosErr = (attr != -1 ? NO_ERROR : GetLastError());
           *pathend = c;
           if (DosErr) {
              return((PCPYINFO) FAILURE) ;
           }
        }

        ScanFSpec(fsinfo) ;     /* re-scan in case quotes disappeared */
        fsinfo->buf = pfdSave;  /* reset original find buffer */
                                /* the original is not freed, because */
                                /* it will be freed by command cleanup */
        return(fsinfo) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cpparse.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cpparse.c

Abstract:

    Parsing for the copy command

--*/

#include "cmd.h"

/*  useful macro  */
#define Wild(spec)  ((spec)->flags & (CI_NAMEWILD))

/*  Globals from cpwork.c  */
extern int copy_mode;
extern unsigned DosErr ;
/*  Globals from command  */

extern TCHAR    SwitChar;
extern BOOLEAN  VerifyCurrent;    // cpwork.c


/*        parse_args
 *
 *   This is the key function which decides how copy will react to any
 * given invocation.  It parses the arguments, fills the source and
 * destination structures, and sets the copy_mode.
 *
 *                               ENTRY
 *
 *  args   - raw argument line entered by the user
 *
 *  source - pointer to an initialized cpyinfo struct.  This one isn't
 *           used; it's just a header to a linked list containing the
 *           actual source structures.
 *
 *  dest   - like source, but there will be at most one filled-in dest struct.
 *
 *                               EXIT
 *
 *  source - the caller's source pointer has not, of course, been changed.  It
 *           still points to the empty header (which might not be completely
 *           empty - see handle_switch for details).  It is the head of a
 *           linked list of structures, terminated by one with a NULL in its
 *           next field.  Each structure corresponds to a source spec.
 *
 *  dest   - if a destination was specified, the caller's dest pointer points
 *           to an empty header which points to the actual destination struct.
 *           If the destination is implicit, the fspec and next fields of the
 *           struct are still NULL, but the flag field has been filled in with
 *           the copy mode.  If the user specified a copy mode (ascii or
 *           binary) one or more times, the last switch applies to the
 *           destination.  If not, CI_NOTSET is used.
 *
 *  copy_mode - set to type of copy being done - COPY, COMBINE, CONCAT, or
 *           TOUCH.
 *
 */

void 
parse_args(
    PTCHAR args, 
    PCPYINFO source, 
    PCPYINFO dest)
{
    TCHAR *tas;                         /*  tokenized argument string     */
    TCHAR copydelims[4];                /*  copy token delimters          */
    int parse_state = SEEN_NO_FILES;    /*  state of the parser   */
    int all_sources_wildcards = TRUE,   /*  flag to help decide copy mode */
        number_of_sources = 0,          /*  number of specs seen so far   */
        current_copy_mode = CI_NOTSET,  /*  ascii, binary, or not set     */
        tlen;                           /*  offset to next token          */
    BOOL ShortNameSwitch=FALSE;
    BOOL RestartableSwitch=FALSE;
    BOOL PromptOnOverwrite;

    copydelims[0] = PLUS;               /*  delimiters for token parser   */
    copydelims[1] = COMMA;
    copydelims[2] = SwitChar;
    copydelims[3] = NULLC;

    //
    // Get default prompt okay flag from COPYCMD variable.  Allow
    // user to override with /Y or /-Y switch.  Always assume /Y
    // if command executed from inside batch script or via CMD.EXE
    // command line switch (/C or /K)
    //
    if (SingleBatchInvocation || SingleCommandInvocation || CurrentBatchFile != 0)
        PromptOnOverwrite = FALSE;      // Assume /Y
    else
        PromptOnOverwrite = TRUE;       // Assume /-Y
    GetPromptOkay(MyGetEnvVarPtr(TEXT("COPYCMD")), &PromptOnOverwrite);

    if (!*(tas = TokStr(args, copydelims, TS_SDTOKENS))) /* tokenize args */

        copy_error(MSG_BAD_SYNTAX,CE_NOPCOUNT);         /* M003    */

    for ( ; *tas ; tas += tlen+1 )        /*  cycle through tokens in args  */
      {
       tlen = mystrlen(tas);
       switch(*tas) {
            case PLUS:
                if (parse_state != JUST_SEEN_SOURCE_FILE)

/* M003 */          copy_error(MSG_BAD_SYNTAX,CE_NOPCOUNT);
                parse_state = SEEN_PLUS_EXPECTING_SOURCE_FILE;
                break;

            case COMMA:
                if (parse_state == SEEN_COMMA_EXPECTING_SECOND)
                    parse_state = SEEN_TWO_COMMAS;
                else if ((parse_state == SEEN_PLUS_EXPECTING_SOURCE_FILE) &&
                     (number_of_sources == 1))
                    parse_state = SEEN_COMMA_EXPECTING_SECOND;
                else if (parse_state != JUST_SEEN_SOURCE_FILE)

/* M003 */          copy_error(MSG_BAD_SYNTAX,CE_NOPCOUNT);
                break;

            default:                                     /*  file or switch  */
                if (*tas == SwitChar) {
                    handle_switch(tas,source,dest,parse_state,
                                  &current_copy_mode,
                                  &ShortNameSwitch,
                                  &RestartableSwitch,
                                  &PromptOnOverwrite
                                 );
                    tlen = 2 + _tcslen(&tas[2]);   /*  offset past switch    */
                }
                else
/*509*/         {               /*  must be device or file             */
/*509*/             mystrcpy(tas, StripQuotes(tas));
                    parse_state = found_file(tas,parse_state,&source,&dest,
                        &number_of_sources,&all_sources_wildcards,current_copy_mode);
/*509*/         }
                break;
            }
    }

    /*  set copy mode appropriately */
    set_mode(number_of_sources,parse_state,all_sources_wildcards,dest);


 if (ShortNameSwitch)
    source->flags |= CI_SHORTNAME;

 if (PromptOnOverwrite)
    dest->flags |= CI_PROMPTUSER;

 if (RestartableSwitch)
    //
    // If running on a platform that does not support CopyFileEx
    // display an error message if they try to use /Z option
    //
#ifndef WIN95_CMD
    if (lpCopyFileExW != NULL)
        source->flags |= CI_RESTARTABLE;
    else
#endif
        copy_error(MSG_NO_COPYFILEEX,CE_NOPCOUNT);



    /*  if no dest specified, put current copy mode in header */
 if (number_of_sources != 0)                        /*M005 if sources specd   */
   {                                                /*M005 then               */
    if (parse_state != SEEN_DEST)                   /*M005  if seen a destspec*/
      {                                             /*M005  then              */
       dest->flags = current_copy_mode;             /*M005    save cur mode   */
       if (PromptOnOverwrite)
         dest->flags |= CI_PROMPTUSER;
      }                                             /*M005  endif             */
   }                                                /*M005                    */
 else                                               /*M005                    */
   {                                                /*M005 else               */
    copy_error(MSG_BAD_SYNTAX,CE_NOPCOUNT); /*M005    disp inv#parms  */
   }                                                /*M005 endif              */
}

/*         handle_switch
 *
 *    There are four switches to handle: /A, /B, /F,
 *    /V
 *
 *  /B and /A set the copy mode to binary and ascii respectively.
 *  This change applies to the previous filespec and all succeeding ones.
 *  Figure out which was the last filespec read and set its flags; then set
 *  the current copy mode.
 *
 *    Note:  If there was no previous filespec, the source pointer is pointing
 *         at an unitialized header.  In this case, we set the flags in this
 *         struct to the current copy mode.  This doesn't accomplish
 *         anything, but the code is simpler if it doesn't bother to check.
 *
 *  /F indicates that the copy should fail if we can't copy the EAs.
 *
 *  /V enables the much slower verified copy mode.  This is very
 *  easy to handle; call a magic internal DOS routine.  All writes are then
 *  verified automagically without our interference.
 *
 *
 */

void handle_switch(
    TCHAR *tas, 
    PCPYINFO source, 
    PCPYINFO dest, 
    int parse_state, 
    int *current_copy_mode, 
    PBOOL ShortNameSwitch,
    PBOOL RestartableSwitch,
    PBOOL PromptOnOverwrite
    )
{
    TCHAR ch = (TCHAR) _totupper(tas[2]);
    TCHAR szTmp[16];

    if (_tcslen(&tas[2]) < 14) {
        _tcscpy(szTmp,tas);
        _tcscat(szTmp,&tas[2]);
        if (GetPromptOkay(szTmp, PromptOnOverwrite))
            return;
    }

    if (ch == TEXT( 'A' ) || ch == TEXT( 'B' )) {
        *current_copy_mode = (ch == TEXT( 'A' ) ? CI_ASCII : CI_BINARY);
        if (parse_state == SEEN_DEST) {       /*  then prev spec was dest  */
            dest->flags &= (~CI_ASCII) & (~CI_BINARY) & (~CI_NOTSET);
            dest->flags |= *current_copy_mode;
        }
        else {                                /*  set last source spec     */
            source->flags &= (~CI_ASCII) & (~CI_BINARY) & (~CI_NOTSET);
            source->flags |= *current_copy_mode;
        }
    }
    else if (ch == TEXT( 'V' )) {
        VerifyCurrent = 1;
    }
    else if (ch == TEXT( 'N' )) {
        *ShortNameSwitch = TRUE;
    }
    else if (ch == TEXT( 'Z' )) {
        *RestartableSwitch = TRUE;
    }
    else if (ch == TEXT( 'D' )) {
        *current_copy_mode |= CI_ALLOWDECRYPT;
        dest->flags |= CI_ALLOWDECRYPT;
    }
    else {
        copy_error(MSG_BAD_SYNTAX,CE_NOPCOUNT); /* M003    */
    }
}

/*  found_file
 *
 *  Token was a file or device.  Put it in the appropriate structure and
 * run ScanFSpec on it.  Figure out what the new parser state should be
 * and return it.  Note:  This function has one inelegant side-effect; if
 * it sees a destination file after a double-comma ("copy foo+,, bar"), it
 * sets the copy_mode to TOUCH.  Otherwise the copier wouldn't remember to
 * use the current date and time with the copied file.  Set_mode notices that
 * the mode is TOUCH and doesn't change it.  This works because the copy modes
 * CONCAT, COMBINE, COPY, and TOUCH are mutually exclusive in all but this one
 * case where we both copy and touch at once.
 *
 */

int
found_file(
    PTCHAR token,
    int parse_state,
    PCPYINFO *source,
    PCPYINFO *dest,
    int *num_sources,
    int *all_sources_wild,
    int mode)
{
    PCPYINFO add_filespec_to_struct();

    /*  if it's a source, add to the list of source structures  */
    if ((parse_state == SEEN_NO_FILES) ||
        (parse_state == SEEN_PLUS_EXPECTING_SOURCE_FILE)) {
        *source = add_filespec_to_struct(*source,token,mode);
        ScanFSpec(*source);
        //
        // Could have an abort from access to floppy etc. so get out
        // of copy. If it is just an invalid name then proceed since
        // it is a wild card. If is actually invalid we will catch
        // this later.
        if (DosErr != SUCCESS 
            && DosErr != ERROR_INVALID_NAME
#ifdef WIN95_CMD
            && (!Wild(*source) || DosErr != ERROR_FILE_NOT_FOUND)
#endif
            ) {
            copy_error(DosErr, CE_NOPCOUNT);
        }

        parse_state = JUST_SEEN_SOURCE_FILE;
        (*num_sources)++;
        if (!Wild(*source))
            *all_sources_wild = FALSE;
    }

    /*  if it's a dest, make it the dest structure  */
    else if ((parse_state == SEEN_TWO_COMMAS) ||
             (parse_state == JUST_SEEN_SOURCE_FILE)) {
        if (parse_state == SEEN_TWO_COMMAS)
            copy_mode = TOUCH;
        *dest = add_filespec_to_struct(*dest,token,mode);
        ScanFSpec(*dest);
        //
        // Could have an abort from access to floppy etc. so get out
        // of copy
        //
        if ((DosErr) && (DosErr != ERROR_INVALID_NAME)) {
            copy_error(DosErr, CE_NOPCOUNT);
        }
        parse_state = SEEN_DEST;
    }

    /*  if we have a dest or the syntax is messed up, complain  */
    else

        copy_error(MSG_BAD_SYNTAX,CE_NOPCOUNT);         /* M003    */
    return(parse_state);
}

/*        set_mode
 *
 *    Given all the current state information, determine which kind of copy
 *  is being done and set the copy_mode.  As explained in found_file, if
 *  the mode has been set to TOUCH, set_mode doesn't do anything.
 */

void set_mode(number_sources,parse_state,all_sources_wildcards,dest)
int number_sources,
    parse_state,
    all_sources_wildcards;
    PCPYINFO dest;
{
    if (copy_mode == TOUCH)                       /*  tacky special case  */
        return;

    /*  If there was one source, we are doing a touch, a concatenate,
     * or a copy.  It's a touch if there was one file and we saw a "+" or a
     * "+,,".  If the source was a wildcard and the destination is a file,
     * it's a concatenate.  Otherwise it's a copy.
     */

    if (number_sources == 1) {
        if ((parse_state == SEEN_TWO_COMMAS) ||
            (parse_state == SEEN_PLUS_EXPECTING_SOURCE_FILE))
            copy_mode = TOUCH;
        else if (all_sources_wildcards && dest->fspec && !Wild(dest) &&
                 !(*lastc(dest->fspec) == COLON))
            copy_mode = CONCAT;
    }

    /*  For more than one source, we are combining or concatenating.  It's
     * a combine if all sources were wildcards and the destination is either
     * a wildcard, a directory, or implicit.  Otherwise it's a concatenation.
     */

    else {
        if ((all_sources_wildcards) &&
            ((!dest->fspec) || Wild(dest) ||
             (*lastc(dest->fspec) == COLON)))
            copy_mode = COMBINE;
        else
            copy_mode = CONCAT;
    }
    DEBUG((FCGRP,COLVL,"Set flags: copy_mode = %d",copy_mode));
}


/*         add_filespec_to_struct
 *
 *                              ENTRY
 *
 *  spec - points to a filled structure with a NULL in its next field.
 *
 *  file_spec - filename to put in new structure
 *
 *  mode - copy mode
 *
 *                              EXIT
 *
 *   Return a pointer to a new cpyinfo struct with its fields filled in
 *  appropriately.  The old spec struct's next field points to this new
 *  structure.
 *
 */

PCPYINFO
add_filespec_to_struct(spec,file_spec,mode)
PCPYINFO spec;
TCHAR *file_spec;
int mode;
{
    spec->next = NewCpyInfo( );
    spec = spec->next;
    spec->fspec = file_spec;
    spec->flags |= mode;
    return(spec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\ctools3.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    ctools3.c

Abstract:

    Low level utilities

--*/

#include "cmd.h"

struct envdata CmdEnv ; /* Holds info need to manipulate Cmd's environment */

extern unsigned tywild; /* type is wild flag @@5@J1     */
extern TCHAR CurDrvDir[], PathChar, Delimiters[] ;

extern TCHAR VolSrch[] ;                /* M009 */

extern TCHAR BSlash ;

extern unsigned DosErr ;

/***    FullPath - build a full path name
 *
 *  Purpose:
 *      See below.
 *
 *  int FullPath(TCHAR * buf, TCHAR *fname)
 *
 *  Args:
 *      buf   - buffer to write full pathname into. (M017)
 *      fname - a file name and/or partial path
 *
 *  Returns: (M017)
 *      FAILURE if malformed pathname (erroneous '.' or '..')
 *      SUCCESS otherwise
 *
 *  Notes:
 *    - '.' and '..' are removed from the translated string (M017)
 *    - VERY BIG GOTCHA!  Note that the 509 change can cause
 *      this rountine to modify the input filename (fname), because
 *      it strips quotes and copies it over the input filename.
 *
 */

int FullPath(
    TCHAR *buf, 
    TCHAR *fname, 
    ULONG sizpath
    )
{
    unsigned rc = SUCCESS;         /* prime with good rc */
    unsigned buflen;               /* buffer length      */
    TCHAR *filepart;
    DWORD rv; 

    mystrcpy(fname, StripQuotes(fname) );

    if (*fname == NULLC) {
        GetDir(buf,GD_DEFAULT);
        buf += 2;                           /* Inc past drivespec      */
        buflen = mystrlen(buf);             /* Is curdir root only?    */
        if (buflen >= MAX_PATH-3) {   /* If too big then stop    */
            DosErr = ERROR_PATH_NOT_FOUND;
            rc = FAILURE;
        } else if (buflen != 1) {               /* if not root then append */
            *(buf+buflen++) = PathChar;      /* ...a pathchar and...   */
            *(buf+buflen) = NULLC ;          /* ...a null byte...       */
        }                                 /*                         */
    } else {
        if ((mystrlen(fname) == 2) && (*(fname + 1) == COLON)) {
            GetDir(buf,*fname);                 /* Get curdrvdir        */
            if ((buflen = mystrlen(buf)) > 3) {
                *(buf+buflen++) = PathChar;   /* ...a pathchar and...    */
                *(buf+buflen) = NULLC ;          /* ...a null byte...       */
            }
        } else {
            DWORD dwOldMode;

            dwOldMode = SetErrorMode(0);
            SetErrorMode(SEM_FAILCRITICALERRORS);
            rv = GetFullPathName( fname, sizpath, buf, &filepart );
            SetErrorMode(dwOldMode);
            if (!rv || rv > sizpath ) {
                DosErr = ERROR_FILENAME_EXCED_RANGE;
                rc = FAILURE;
            }
        }
    }
    return(rc);

}




/***    FileIsDevice - check a handle to see if it references a device
 *
 *  Purpose:
 *      Return a nonzero value if fh is the file handle for a device.
 *      Otherwise, return 0.
 *
 *  int FileIsDevice(int fh)
 *
 *  Args:
 *      fh - the file handle to check
 *
 *  Returns:
 *      See above.
 *
 */

unsigned int flgwd;

int FileIsDevice( CRTHANDLE fh )
{
    HANDLE hFile;
    DWORD dwMode;
    unsigned htype ;

    hFile = CRTTONT(fh);
    htype = GetFileType( hFile );
    htype &= ~FILE_TYPE_REMOTE;

    if (htype == FILE_TYPE_CHAR) {
        //
        // Simulate old behavior of this routine of setting the flgwd
        // global variable with either 0, 1 or 2 to indicate if the
        // passed handle is NOT a CON handle or is a CON input handle or
        // is a CON output handle.
        //
        switch ( fh ) {
        case STDIN:
            hFile = GetStdHandle(STD_INPUT_HANDLE);
            break;
        case STDOUT:
            hFile = GetStdHandle(STD_OUTPUT_HANDLE);
            break;
        case STDERR:
            hFile = GetStdHandle(STD_ERROR_HANDLE);
            break;
        }
        if (GetConsoleMode(hFile,&dwMode)) {
            if (dwMode & (ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT)) {
                flgwd = 1;
            } else if (dwMode & (ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT)) {
                flgwd = 2;
            }
        } else {
            flgwd = 0;
        }

        return TRUE;
    } else {
        flgwd = 0;
        return FALSE;
    }
}

int FileIsPipe( CRTHANDLE fh )
{
    unsigned htype ;

    htype = GetFileType( CRTTONT(fh) );
    htype &= ~FILE_TYPE_REMOTE;
    flgwd = 0;
    return( htype == FILE_TYPE_PIPE ) ; /* @@4 */
}

int FileIsRemote( LPTSTR FileName )
{
    LPTSTR p;
    TCHAR Drive[MAX_PATH*2];
    DWORD Length;

    Length = GetFullPathName( FileName, sizeof(Drive)/sizeof(TCHAR), Drive, &p );

    if (Length != 0 && Length < MAX_PATH * 2) {
        Drive[3] = 0;
        if (GetDriveType( Drive ) == DRIVE_REMOTE) {
            return TRUE;
        }
    }

    return FALSE;
}

int FileIsConsole(CRTHANDLE fh)
{
    unsigned htype ;
    DWORD    dwMode;
    HANDLE   hFile;

    hFile = CRTTONT(fh);
    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    htype = GetFileType( hFile );
    htype &= ~FILE_TYPE_REMOTE;

    if ( htype == FILE_TYPE_CHAR ) {

        switch ( fh ) {
        case STDIN:
            hFile = GetStdHandle(STD_INPUT_HANDLE);
            break;
        case STDOUT:
            hFile = GetStdHandle(STD_OUTPUT_HANDLE);
            break;
        case STDERR:
            hFile = GetStdHandle(STD_ERROR_HANDLE);
            break;
        }
        if (GetConsoleMode(hFile,&dwMode)) {
            return TRUE;
        }
    }

    return FALSE;
}


/***    GetDir - get a current directory string
 *
 *  Purpose:
 *      Get the current directory of the specified drive and put it in str.
 *
 *  int GetDir(TCHAR *str, TCHAR dlet)
 *
 *  Args:
 *      str - place to store the directory string
 *      dlet - the drive letter or 0 for the default drive
 *
 *  Returns:
 *      0 or 1 depending on the value of the carry flag after the CURRENTDIR
 *      system call/
 *
 *  Notes:
 *    - M024 - If dlet is invalid, we leave the buffer as simply the
 *      null terminated root directory string.
 *
 */

int GetDir(TCHAR *str, TCHAR dlet)
{
    TCHAR denvname[ 4 ];
    TCHAR *denvvalue;

    if (dlet == GD_DEFAULT) {
        GetCurrentDirectory(MAX_PATH, str);
        return( SUCCESS );
    }

    denvname[ 0 ] = EQ;
    denvname[ 1 ] = (TCHAR)_totupper(dlet);
    denvname[ 2 ] = COLON;
    denvname[ 3 ] = NULLC;

    denvvalue = GetEnvVar( denvname );
    if (!denvvalue) {
        *str++ = (TCHAR)_totupper(dlet);
        *str++ = COLON;
        *str++ = BSLASH;
        *str   = NULLC;
        return(FAILURE);
    } else {
        mystrcpy( str, denvvalue );
        return(SUCCESS);
    }
}


BOOL 
FixupPath(
         TCHAR *path,
         BOOL fShortNames
         )
{
    TCHAR c, *src, *dst, *s;
    int n, n1, length;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;

    length = _tcslen( path );
    if (length > MAX_PATH) {
        return FALSE;
    }

    src = path + 3; // Skip root directory.
    dst = path + 3;
    do {
        c = *src;
        if (!c || c == PathChar) {
            *src = NULLC;
            hFind = FindFirstFile( path, &FindFileData );
            *src = c;
            if (hFind != INVALID_HANDLE_VALUE) {
                FindClose( hFind );
                if (FindFileData.cAlternateFileName[0] &&
                    (fShortNames ||
                     (!_tcsnicmp( FindFileData.cAlternateFileName, dst, (UINT)(src - dst)) &&
                      _tcsicmp( FindFileData.cFileName, FindFileData.cAlternateFileName)
                     )
                    )
                   )
                    //
                    // Use short name if requested or
                    // if input is explicitly using it and short name differs from long name
                    //
                    s = FindFileData.cAlternateFileName;
                else
                    s = FindFileData.cFileName;
                n = _tcslen( s );
                n1 = n - (int)(src - dst);

                //
                //  Make sure we don't overflow name
                //

                if (length + n1 > MAX_PATH) {
                    return FALSE;
                } else {
                    length += n1;
                }

                if (n1 > 0) {
                    memmove( src+n1, src, _tcslen(src)*sizeof(TCHAR) );
                    src += n1;
                }

                _tcsncpy( dst, s, n );
                dst += n;
                _tcscpy( dst, src );
                dst += 1;
                src = dst;
            } else {
                src += 1;
                dst = src;
            }
        }

        src += 1;
    }
    while (c != NULLC);

    return TRUE;
}

/***    ChangeDirectory - change a current directory
 *
 *  Purpose:
 *      Change the current directory on a drive.  We do this either
 *      via changing the associated environment variable, or
 *      by changing the Win32 drive and directory.
 *
 *  Args:
 *      newdir - directory (optionally w/drive)
 *      op - what operation should be performed
 *          CD_SET_DRIVE_DIRECTORY - set the Win32 current directory and drive
 *          CD_SET_DIRECTORY - set the Win32 current directory if the same drive
 *          CD_SET_ENV - set the environment variables for the current directory
 *              on a drive that's not the default drive.
 *
 *  Returns:
 *      SUCCESS if the directory was changed.
 *      FAILURE otherwise.
 */

int ChangeDirectory(
                   TCHAR *newdir,
                   CHANGE_OP op
                   )
{
    TCHAR denvname[ 4 ];
    TCHAR newpath[ MAX_PATH + MAX_PATH ];
    TCHAR denvvalue[ MAX_PATH ];
    TCHAR c, *s;
    DWORD attr;
    DWORD newdirlength,length;

    //
    //  UNC paths are not allowed
    //

    if (newdir[0] == PathChar && newdir[1] == PathChar)
        return MSG_NO_UNC_CURDIR;


    //
    //  truncate trailing spaces on ..
    //

    if (newdir[0] == DOT && newdir[1] == DOT) {
        DWORD i, fNonBlank;
        fNonBlank = 0;
        newdirlength = mystrlen(newdir);

        for (i=2; i<newdirlength; i++) {
            if (newdir[i] != SPACE) {
                fNonBlank = 1;
                break;
            }
        }

        if ( ! fNonBlank) {
            newdir[2] = NULLC;
        }
    }

    //
    //  Get current drive and directory in order to
    //  set up for forming the environment variable
    //

    GetCurrentDirectory( MAX_PATH, denvvalue );
    c = (TCHAR)_totupper( denvvalue[ 0 ] );

    //
    //  Convention for environment form is:
    //      Name of variable    =d:
    //      value is full path including drive
    //

    denvname[ 0 ] = EQ;
    if (_istalpha(*newdir) && newdir[1] == COLON) {
        denvname[ 1 ] = (TCHAR)_totupper(*newdir);
        newdir += 2;
    } else {
        denvname[ 1 ] = c;
    }
    denvname[ 2 ] = COLON;
    denvname[ 3 ] = NULLC;

    newdirlength = mystrlen(newdir);
    if (*newdir == PathChar) {
        if ((newdirlength+2) > sizeof(newpath)/sizeof( TCHAR )) {
            return ERROR_FILENAME_EXCED_RANGE;
        }
        newpath[ 0 ] = denvname[ 1 ];   //  drive
        newpath[ 1 ] = denvname[ 2 ];   //  colon
        mystrcpy( &newpath[ 2 ], newdir );
    } else {
        if (s = GetEnvVar( denvname )) {
            mystrcpy( newpath, s );
        } else {
            newpath[ 0 ] = denvname[ 1 ];   //  drive
            newpath[ 1 ] = denvname[ 2 ];   //  colon
            newpath[ 2 ] = NULLC;
        }

        //
        //  Make sure there's exactly one backslash between newpath and newdir
        //
        
        s = lastc( newpath );

        //
        //  s points to the last character or point to NUL (if newpath was
        //  zero length to begin with).  A NULL means we drop in a path char
        //  over the NUL.  A non-path char means we append a path char.
        //
        
        if (*s == NULLC) {
            *s++ = PathChar;
        } else if (*s != PathChar) {
            s[1] = PathChar;
            s += 2;
        }

        if (newdirlength + (s - newpath) > sizeof( newpath ) / sizeof( TCHAR )) {
            return ERROR_FILENAME_EXCED_RANGE;
        }
        
        mystrcpy( s, newdir );
    }

    denvvalue[(sizeof( denvvalue )-1)/sizeof( TCHAR )] = NULLC;

    //
    //  form the full path name
    //

    if ((length = GetFullPathName( newpath, (sizeof( denvvalue )-1)/sizeof( TCHAR ), denvvalue, &s ))==0) {
        return( ERROR_ACCESS_DENIED );
    }


    //
    // Remove any trailing backslash
    //

    if (s == NULL) {
        s = denvvalue + _tcslen( denvvalue );
    }
    if (*s == NULLC && s > &denvvalue[ 3 ] && s[ -1 ] == PathChar) {
        *--s = NULLC;
    }

    //
    //  Verify that there won't be (initially) disk errors when we touch
    //  the directory
    //

    attr = GetFileAttributes( denvvalue );
    if (attr == -1) {
        attr = GetLastError( );
        if (attr != ERROR_FILE_NOT_FOUND &&
            attr != ERROR_PATH_NOT_FOUND &&
            attr != ERROR_INVALID_NAME) {
            return attr;
        }
    }

    //
    // If extensions are enabled, fixup the path to have the same case as
    // on disk
    //

    if (fEnableExtensions) {
        if (!FixupPath( denvvalue, FALSE )) {
            return ERROR_FILENAME_EXCED_RANGE;
        }
    }

    if (op != CD_SET_ENV) {
        attr = GetFileAttributes( denvvalue );

        if (attr == (DWORD)-1 ||
            !(attr & (FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_REPARSE_POINT))
           ) {
            if ( attr == -1 ) {
                attr = GetLastError();
                if ( attr == ERROR_FILE_NOT_FOUND ) {
                    attr = ERROR_PATH_NOT_FOUND;
                }
                return attr;
            }
            return( ERROR_DIRECTORY );
        }
    }

    //
    //  If we're always setting the directory or
    //  if we're setting the directory if the drives are the same and
    //      the drives ARE the same
    //

    if (op == CD_SET_DRIVE_DIRECTORY
        || (op == CD_SET_DIRECTORY 
            && c == denvname[ 1 ])) {

        if (!SetCurrentDirectory( denvvalue )) {
            return GetLastError();
        }

    }

    if (SetEnvVar(denvname,denvvalue,&CmdEnv)) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }
    GetDir(CurDrvDir, GD_DEFAULT) ;

    return SUCCESS;
}



/***    ChangeDir2 - change a current directory
 *
 *  Purpose:
 *      To change to the directory specified in newdir on the drive specified
 *      in newdir.  If no drive is given, the default drive is used.  If the
 *      directory of the current drive is changed, the global variable
 *      CurDrvDir is updated.
 *
 *      This routine is used by RestoreCurrentDirectories
 *
 *  int ChangeDir2(BYTE *newdir, BOOL )
 *
 *  Args:
 *      newdir - directory to change to
 *      BOOL - current drive
 *
 *  Returns:
 *      SUCCESS if the directory was changed.
 *      FAILURE otherwise.
 *
 */

int ChangeDir2(
              TCHAR *newdir,
              BOOL CurrentDrive
              )
{
    return ChangeDirectory( newdir, CurrentDrive ? CD_SET_DRIVE_DIRECTORY : CD_SET_ENV );    
}


/***    ChangeDir - change a current directory
 *
 *  Purpose:
 *      To change to the directory specified in newdir on the drive specified
 *      in newdir.  If no drive is given, the default drive is used.  If the
 *      directory of the current drive is changed, the global variable
 *      CurDrvDir is updated.
 *
 *  int ChangeDir(TCHAR *newdir)
 *
 *  Args:
 *      newdir - directory to change to
 *
 *  Returns:
 *      SUCCESS if the directory was changed.
 *      FAILURE otherwise.
 *
 */

int ChangeDir(
             TCHAR *newdir

             )
{
    return ChangeDirectory( newdir, CD_SET_DIRECTORY );
}




/***    exists - Determine if a given file exists
 *
 *  Purpose:
 *      To test the existence of a named file.
 *
 *  int exists(TCHAR *filename)
 *
 *  Args:
 *      filename - the filespec to test
 *
 *  Returns:
 *      TRUE if file exists
 *      FALSE if it does not.
 *
 *  Notes:
 *      M020 - Now uses ffirst to catch devices, directories and wildcards.
 */

exists(filename)
TCHAR *filename;
{
    WIN32_FIND_DATA buf ;         /* Use for ffirst/fnext            */
    HANDLE hn ;
    int i ;             /* tmp                 */
    TCHAR FullPath[ 2 * MAX_PATH ];
    TCHAR *p, *p1, SaveChar;

    p = StripQuotes(filename);
    i = GetFullPathName( p, 2 * MAX_PATH, FullPath, &p1 );
    if (i) {
        p = FullPath;
        if (!_tcsncmp( p, TEXT("\\\\.\\"), 4 )) {
            //
            // If they gave us a device name, then see if they put something
            // in front of it.
            //
            p += 4;
            p1 = p;
            if ((p1 = _tcsstr( filename, p )) && p1 > filename) {
                //
                // Something in front of the device name, so truncate the input
                // path at the device name and see if that exists.
                //
                SaveChar = *p1;
                *p1 = NULLC;
                i = (int)GetFileAttributes( filename );
                *p1 = SaveChar;
                if (i != 0xFFFFFFFF) {
                    return i;
                } else {
                    return 0;
                }
            } else {
                //
                // Just a device name given.  See if it is valid.
                //
                i = (int)GetFileAttributes( filename );
                if (i != 0xFFFFFFFF) {
                    return i;
                } else {
                    return 0;
                }
            }
        }

        if (p1 == NULL || *p1 == NULLC) {
            i = (int)(GetFileAttributes( p ) != 0xFFFFFFFF);
        } else {
            i = ffirst( p, A_ALL, &buf, &hn );
            findclose(hn);
            if ( i == 0 ) {
                //
                // ffirst handles files & directories, but not
                // root drives, so do special check for them.
                //
                if ( *(p+1) == (TCHAR)'\\' ||
                     (*(p+1) == (TCHAR)':'  &&
                      *(p+2) == (TCHAR)'\\' &&
                      *(p+3) == (TCHAR)0
                     )
                   ) {
                    UINT t;
                    t = GetDriveType( p );
                    if ( t > 1 ) {
                        i = 1;
                    }
                }
            }
        }
    }

    return i;
}



/***    exists_ex - Determine if a given executable file exists   @@4
 *
 *  Purpose:
 *      To test the existence of a named executable file.
 *
 *  int exists_ex(TCHAR *filename)
 *
 *  Args:
 *      filename - the filespec to test
 *      checkformeta - if TRUE, check for wildcard char
 *
 *  Returns:
 *      TRUE if file exists
 *      FALSE if it does not.
 *
 *  Notes:
 *      @@4 - Now uses ffirst to catch only files .
 */

exists_ex(filename,checkformeta)                                                /*@@4*/
TCHAR *filename;                                                /*@@4*/
BOOL checkformeta;
{                                                               /*@@4*/
    WIN32_FIND_DATA buf;       /* use for ffirst/fnext */
    HANDLE hn;
    int i;
    TCHAR *ptr;

    /* can not execute wild card files, so check for those first */

    if (checkformeta && (mystrchr( filename, STAR ) || mystrchr( filename, QMARK ))) {
        DosErr = 3;
        i = 0;
    } else {

        /* see if the file exists, do not include Directory, volume, or */
        /* hidden files */
        i = ((ffirst( filename , A_AEDV, &buf, &hn))) ;

        if ( i ) {
            findclose(hn) ;

            /* if the file exists then copy the file name, to get the case */
            ptr = mystrrchr( filename, BSLASH );
            if ( ptr == NULL ) {
                ptr = filename;
                if ( mystrlen( ptr ) > 2 && ptr[1] == COLON ) {
                    ptr = &filename[2];
                }
            } else {
                ptr++;
            }
            mystrcpy( ptr, buf.cFileName);
        } else if ( DosErr == 18 ) {
            DosErr = 2;
        }

    }

    return(i) ;                                               /*@@4*/
}                                                               /*@@4*/




/***    FixPChar - Fix up any leading path in a string
 *
 *  Purpose:
 *      To insure that paths match the current Swit/Pathchar setting
 *
 *  void FixPChar(TCHAR *str, TCHAR PChar)
 *
 *  Args:
 *     str - the string to fixup
 *     Pchar - character to replace
 *
 *  Returns:
 *      Nothing
 *
 */

void FixPChar(TCHAR *str, TCHAR PChar)
{
    TCHAR *sptr1,                   /* Index for string                     */
    *sptr2 ;                   /* Change marker                   */

    sptr1 = str ;                   /* Init to start of string         */

    while (sptr2 = mystrchr(sptr1,PChar)) {
        *sptr2++ = PathChar ;
        sptr1 = sptr2 ;
    } ;
}




/***    FlushKB - Remove extra unwanted input from Keyboard
 *
 *  Purpose:
 *      To perform a keyboard flush up to the next CR/LF.
 *
 *  FlushKB()
 *
 *  Args:
 *      None
 *
 *  Returns:
 *      Nothing
 *
 */

void FlushKB()
{
    DWORD cnt;
    TCHAR IgnoreBuffer[128];

    while (ReadBufFromInput( GetStdHandle(STD_INPUT_HANDLE), IgnoreBuffer, 128, &cnt )) {
        if (mystrchr( IgnoreBuffer, CR ))
            return ;
    }
}

/***    DriveIsFixed - Determine if drive is removeable media
 *
 *  Purpose:  @@4
 *      To determine if the input drive is a removeable media.
 *
 *  DriveIsFixed(TCHAR *drive_ptr )
 *
 *  Args:
 *      drive_ptr - pointer to a file name that contains a drive
 *                  specification.
 *
 *  Returns:
 *      1 - if error or non removeable media
 *      0 - if no error and removeable media
 */

int
DriveIsFixed( TCHAR *drive_ptr )
{
    unsigned rc = 0;
    TCHAR drive_spec[3];

    drive_spec[0] = *drive_ptr;
    drive_spec[1] = COLON;
    drive_spec[2] = NULLC;

    // FIX, FIX - use GetVolumeInfo, disabling hard errors?

    if ((*drive_ptr == TEXT('A')) || (*drive_ptr == TEXT('B'))) {
        rc = 0;
    } else {
        rc = 1;
    }

    return( rc );
}

int
CmdPutChars( 
    PTCHAR String,
    int Length
    )
{
    int rc = SUCCESS;                   /* return code             */
    int bytesread;                      /* bytes to write count    */
    int byteswrit;                      /* bytes written count     */
    BOOL    flag;

    if (Length > 0) {

        if (FileIsConsole(STDOUT)) {
            if (!(flag=WriteConsole(CRTTONT(STDOUT), String, Length, &byteswrit, NULL)))
                rc = GetLastError();
        } else {
            Length *= sizeof(TCHAR);
            flag = MyWriteFile( STDOUT, (CHAR *)String, Length, &byteswrit);
        }

        //
        //  If the write failed or unable to output all the data
        //
        
        if (flag == 0 || byteswrit != Length) {
            rc = GetLastError();
            
            //
            //  No error => DiskFull
            //
            
            if (rc == 0) {
                rc = ERROR_DISK_FULL;
            }
            
            if (FileIsDevice(STDOUT)) {
                //
                //  If the we were writing to a device then the error is a device
                //  write fault.
                //

                PutStdErr( ERROR_WRITE_FAULT, NOARGS );
            } else if (FileIsPipe(STDOUT)) {
                
                //
                //  If the we were writing to a pipe, then the error is an invalid
                //  pipe error.
                //

                PutStdErr(MSG_CMD_INVAL_PIPE, NOARGS);
                return(FAILURE);
            } else {
                //
                //  Just output the error we found
                //

                PrtErr(rc);
                return(FAILURE);
            }
        }
    }
    return(rc);
}


int
CmdPutString( 
    PTCHAR String
    )
{
    return CmdPutChars( String, _tcslen( String ));
}


int
cmd_printf(
          TCHAR *fmt,
          ...
          )
{
    int Length;
    va_list arg_ptr;

    va_start(arg_ptr,fmt);

    Length = _vsntprintf( MsgBuf, MAXCBMSGBUFFER, fmt, arg_ptr );

    va_end(arg_ptr);

    return CmdPutChars( MsgBuf, Length );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\dir.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    Directory command

--*/

#include "cmd.h"

/*

Usage:
------

DIR <filespec> /n /d /w /p /b /s /l /o<sortorder> /a<attriblist>

DIR /?


<filespec> may include any or none of:  drive; directory path;
           wildcarded filename.  If drive or directory path are
           omitted, the current defaults are used.  If the
           file name or extension is omitted, wildcards are
           assumed.

/n      Normal display form FAT drives is name followed by
        file information, for non-FAT drives it is file
        information followed by name. This switch will use
        the non-FAT format independent of the filesystem.

/w      Wide listing format.  Files are displayed in compressed
        'name.ext' format.  Subdirectory files are enclosed in
        brackets, '[dirname]'.

/d      Same as /w but display sort by columns instead of by
        rows.

/p      Paged, or prompted listing.  A screenful is displayed
        at a time.  The name of the directory being listed appears
        at the top of each page.

/b      Bare listing format.  Turns off /w or /p.  Files are
        listed in compressed 'name.ext' format, one per line,
        without additional information.  Good for making batch
        files or for piping.  When used with /s, complete
        pathnames are listed.

/s      Descend subdirectory tree.  Performs command on current
        or specified directory, then for each subdirectory below
        that directory.  Directory header and footer is displayed
        for each directory where matching files are found, unless
        used with /b.  /b suppresses headers and footers.

        Tree is explored depth first, alphabetically within the
        same level.

/l      Display file names, extensions and paths in lowercase.  ;M010

/o      Sort order.  /o alone sorts by default order (dirs-first, name,
        extension).  A sort order may be specified after /o.  Any of
        the following characters may be used: nedsg (name, extension,
        date/time, size, group-dirs-first).  Placing a '-' before any
        letter causes a downward sort on that field.  E.g., /oe-d
        means sort first by extension in alphabetical order, then
        within each extension sort by date and time in reverse chronological
        order.

/a      Attribute selection.  Without /a, hidden and system files
        are suppressed from the listing.  With /a alone, all files
        are listed.  An attribute list may follow /a, consisting of
        any of the following characters:  hsdar (hidden, system,
        directory, archive, read-only).  A '-' before any letter
        means 'not' that attribute.  E.g., /ar-d means files that
        are marked read-only and are not directory files.  Note
        that hidden or system files may be included in the listing.
        They are suppressed without /a but are treated like any other
        attribute with /a.

/t      Which time stamp to use.
        /t:a - last access
        /t:c - create
        /t:w - last write

/,      Show thousand separators in output display.

/4      Show 4 digit years

DIRCMD  An environment variable named DIRCMD is parsed before the
        DIR command line.  Any command line options may be specified
        in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
        A filespec may be specified in DIRCMD and will be used unless
        a filespec is specified on the command line.  Any switch
        specified in DIRCMD may be overridden on the command line.
        If the original DIR default action is desired for a particular
        switch, the switch letter may be preceded by a '-' on the
        command line.  E.g.,

          /-w   use long listing format
          /-p   don't page the listing
          /-b   don't use bare format
          /-s   don't descend subdirectory tree
          /-o   display files in disk order
          /-a   suppress hidden and system files


*/

extern   TCHAR SwitChar, PathChar;
extern   TCHAR CurDrvDir[] ;
extern   ULONG DCount ;
extern   DWORD DosErr ;
extern   BOOL  CtrlCSeen;


HANDLE   OpenConsole();
STATUS   PrintPatterns( PDRP );

PTCHAR   SetWildCards( PTCHAR, BOOLEAN );
BOOLEAN  GetDrive( PTCHAR , PTCHAR );
BOOLEAN  IsFATDrive( PTCHAR );
PTCHAR   GetNewDir(PTCHAR, PFF);

PTCHAR   BuildSearchPath( PTCHAR );
VOID     SortFileList( PFS, PSORTDESC, ULONG);
STATUS   SetSortDesc( PTCHAR, PDRP );

STATUS
NewDisplayFileListHeader(
    IN  PFS FileSpec,
    IN  PSCREEN pscr,
    IN  PVOID Data
    );

STATUS
NewDisplayFile(
    IN  PFS FileSpec,
    IN  PFF CurrentFF,
    IN  PSCREEN pscr,
    IN  PVOID Data
    );

STATUS
NewDisplayFileList(
    IN  PFS FileSpec,
    IN  PSCREEN pscr,
    IN  PVOID Data
    );

//
// This global is set in SortFileList and is used by the sort routine called
// within qsort. This array contains pointers to compare functions. Our sort
// does not just sort against 1 criteria but all of the criteria in the sort
// description array built from the command line.
PSORTDESC   prgsrtdsc;

//
// dwTimeType is also globally set in SortFileList and is used to control
// which time field is used for sorting.
//

ULONG       dwTimeType;

/*++

Routine Description:

    Prints out a catalog of a specified directory.

Arguments:

    pszCmdLine - Command line (see comment above)

Return Value:

    Return: SUCCESS - no completion.
            FAILURE - failed to complete entire catalog.

--*/

int
Dir (
    TCHAR *pszCmdLine
    ) {

    //
    // drp - structure holding current set of parameters. It is initialized
    //       in ParseDirParms function. It is also modified later when
    //       parameters are examined to determine if some turn others on.
    //
    DRP         drpCur = {0, 0, 0, 0,
                          {{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
                          0, 0, NULL, 0, 0, 0, 0} ;

    //
    // szEnvVar - pointer to value of the DIRCMD environmental variable.
    //            This should be a form of the command line that is
    //            used to alter DIR default behavior.
    TCHAR       szEnvVar[MAX_PATH + 2];

    //
    // szCurDrv - Hold current drive letter
    //
    TCHAR       szCurDrv[MAX_PATH + 2];

    //
    // OldDCount - Holds the level number of the heap. It is used to
    //             free entries off the stack that might not have been
    //             freed due to error processing (ctrl-c etc.)
    ULONG       OldDCount;

    STATUS  rc;

    OldDCount = DCount;

    //
    //  Setup defaults
    //
    //
    //  Display everything but system and hidden files
    //  rgfAttribs set the attribute bits to that are of interest and
    //  rgfAttribsOnOff says either the attributes should be present
    //  or not (i.e. On or Off)
    //

    drpCur.rgfAttribs = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN;
    drpCur.rgfAttribsOnOff = 0;
    drpCur.rgfSwitches = THOUSANDSEPSWITCH;

    //
    // Number of patterns present. A pattern is a string that may have
    // wild cards. It is used to match against files present in the directory
    // 0 patterns will show all files (i.e. mapped to *.*)
    //
    drpCur.cpatdsc = 0;

    DEBUG((ICGRP, DILVL, "DIR:\t arg = `%ws'", (UINT_PTR)pszCmdLine)) ;

    //
    // default time is LAST_WRITE_TIME.
    //
    drpCur.dwTimeType = LAST_WRITE_TIME;

    //
    // DIRCMD holds a copy of default parameters to Dir
    // parse these into drpCur (list of parameters to dir) and use as
    // default into parsing parameters on command line.
    //
    if (GetEnvironmentVariable(TEXT("DIRCMD"), szEnvVar, MAX_PATH + 2)) {

        DEBUG((ICGRP, DILVL, "DIR: DIRCMD `%ws'", (UINT_PTR)szEnvVar)) ;

        if (ParseDirParms(szEnvVar, &drpCur) == FAILURE) {

            //
            // Error in parsing environment variable
            //
            // DOS 5.0 continues with command even if the
            // environmental variable is wrong
            //
            PutStdErr(MSG_ERROR_IN_DIRCMD, NOARGS);

        }

    }

    //
    // Override environment variable with command line options
    //
    if (ParseDirParms(pszCmdLine, &drpCur) == FAILURE) {

        return( FAILURE );
    }


    //
    // If bare format then turn off the other formats
    // bare format will have no addition information on the line so
    // make sure that options set from the DIRCMD variable etc. to
    // not combine with the bare switch
    //
    if (drpCur.rgfSwitches & BAREFORMATSWITCH) {
        drpCur.rgfSwitches &= ~WIDEFORMATSWITCH;
        drpCur.rgfSwitches &= ~SORTDOWNFORMATSWITCH;
        drpCur.rgfSwitches &= ~SHORTFORMATSWITCH;
        drpCur.rgfSwitches &= ~THOUSANDSEPSWITCH;
        drpCur.rgfSwitches &= ~DISPLAYOWNER;
    }

    //
    // If short form (short file names) turn off others
    //

    if (drpCur.rgfSwitches & SHORTFORMATSWITCH) {
        drpCur.rgfSwitches &= ~WIDEFORMATSWITCH;
        drpCur.rgfSwitches &= ~SORTDOWNFORMATSWITCH;
        drpCur.rgfSwitches &= ~BAREFORMATSWITCH;
    }



    //
    // If no patterns on the command line use the default which
    // would be the current directory
    //

    GetDir((PTCHAR)szCurDrv, GD_DEFAULT);
    if (drpCur.cpatdsc == 0) {
        drpCur.cpatdsc++;
        drpCur.patdscFirst.pszPattern = gmkstr( mystrlen( szCurDrv ) * sizeof( TCHAR ) + sizeof( TCHAR ));
        mystrcpy( drpCur.patdscFirst.pszPattern, szCurDrv );
        drpCur.patdscFirst.fIsFat = TRUE;
        drpCur.patdscFirst.pszDir = NULL;
        drpCur.patdscFirst.ppatdscNext = NULL;

    }


    DEBUG((ICGRP, DILVL, "Dir: Parameters")) ;
    DEBUG((ICGRP, DILVL, "\t rgfSwitches %x", drpCur.rgfSwitches)) ;
    DEBUG((ICGRP, DILVL, "\t rgfAttribs %x", drpCur.rgfAttribs)) ;
    DEBUG((ICGRP, DILVL, "\t rgfAttribsOnOff %x", drpCur.rgfAttribsOnOff)) ;
    DEBUG((ICGRP, DILVL, "\t csrtdsc %d", drpCur.csrtdsc)) ;

    //
    // Print out this particular pattern. If the recursion switch
    // is set then this will desend down the tree.
    //

    rc = PrintPatterns(&drpCur);

    mystrcpy(CurDrvDir, szCurDrv);


    //
    // Free unneeded memory
    //
    FreeStack( OldDCount );

#ifdef _CRTHEAP_
    //
    // Force the crt to release heap we may have taken on recursion
    //
    if (drpCur.rgfSwitches & RECURSESWITCH) {
        _heapmin();
    }
#endif

    return( (int)rc );

}

STATUS
SetTimeType(
    IN  PTCHAR  pszTok,
    OUT PDRP    pdrp
    )
/*++

Routine Description:

    Parses the 'time' string

Arguments:

    pszTok -

Return Value:

    pdrp   - where to place the time type

    Return: TRUE - recognized all parameters
            FALSE - syntax error.

    An error is printed if incountered.

--*/

{

    ULONG   irgch;


    //
    // Move over optional ':'
    //
    if (*pszTok == COLON) {
        pszTok++;
    }

    for( irgch = 0; pszTok[irgch]; irgch++ ) {

        switch (_totupper(pszTok[irgch])) {

        case TEXT('C'):

            pdrp->dwTimeType = CREATE_TIME;
            break;

        case TEXT('A'):

            pdrp->dwTimeType = LAST_ACCESS_TIME;
            break;

        case TEXT('W'):

            pdrp->dwTimeType = LAST_WRITE_TIME;
            break;

        default:

            PutStdErr( MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG, pszTok + irgch );
            return( FAILURE );

        } // switch
    } // for

    return( SUCCESS );

}


STATUS
SetAttribs(
    IN  PTCHAR  pszTok,
    OUT PDRP    pdrp
    )
/*++

Routine Description:

    Parses the 'attribute' string

Arguments:

    pszTok - list of attributes

Return Value:

    pdrp   - where to place the attributes recognized.
             this is the parameter structure.

    Return: TRUE - recognized all parameters
            FALSE - syntax error.

    An error is printed if incountered.

--*/

{

    ULONG   irgch;
    BOOLEAN fOff;

    ULONG   rgfAttribs, rgfAttribsOnOff;

    // rgfAttributes hold 1 bit per recognized attribute. If the bit is
    // on then do something with this attribute. Either select the file
    // with this attribute or select the file without this attribute.
    //
    // rgfAttribsOnOff controls wither to select for the attribute or
    // select without the attribute.

    //
    // /a triggers selection of all files by default
    // so override the default
    //
    pdrp->rgfAttribs = rgfAttribs = 0;
    pdrp->rgfAttribsOnOff = rgfAttribsOnOff = 0;

    //
    // Move over optional ':'
    //
    if (*pszTok == COLON) {
        pszTok++;
    }

    //
    // rgfAttribs and rgfAttribsOnOff must be maintained in the
    // same bit order.
    //
    for( irgch = 0, fOff = FALSE; pszTok[irgch]; irgch++ ) {

        switch (_totupper(pszTok[irgch])) {

#define AddAttribute(a)                                     \
{                                                           \
    rgfAttribs |= (a);                                      \
    if (fOff) {                                             \
        rgfAttribsOnOff &= ~(a);                            \
        fOff = FALSE;                                       \
    } else {                                                \
        rgfAttribsOnOff |= (a);                             \
    }                                                       \
}

        case TEXT('L'): AddAttribute( FILE_ATTRIBUTE_REPARSE_POINT );   break;
        case TEXT('H'): AddAttribute( FILE_ATTRIBUTE_HIDDEN );      break;
        case TEXT('S'): AddAttribute( FILE_ATTRIBUTE_SYSTEM );      break;
        case TEXT('D'): AddAttribute( FILE_ATTRIBUTE_DIRECTORY );   break;
        case TEXT('A'): AddAttribute( FILE_ATTRIBUTE_ARCHIVE );     break;
        case TEXT('R'): AddAttribute( FILE_ATTRIBUTE_READONLY );    break;

        case MINUS:
            if (fOff) {
                PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG, pszTok + irgch );
                return( FAILURE );
            }

            fOff = TRUE;
            break;

        default:

            PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG, pszTok + irgch );
            return( FAILURE );

        } // switch
    } // for

    pdrp->rgfAttribs = rgfAttribs;
    pdrp->rgfAttribsOnOff = rgfAttribsOnOff;

    return( SUCCESS );

}

STATUS
SetSortDesc(
    IN  PTCHAR  pszTok,
    OUT PDRP    pdrp
    )
/*++

Routine Description:

    Parses the 'attribute' string

Arguments:

    pszTok - list of sort orders

Return Value:

    pdrp   - where to place the sort orderings recognized.
             this is the parameter structure.

    Return: TRUE - recognized all parameters
            FALSE - syntax error.

    An error is printed if incountered.

--*/

{

    ULONG   irgch, irgsrtdsc;

    DEBUG((ICGRP, DILVL, "SetSortDesc for `%ws'", pszTok));

    //
    // Move over optional ':'
    //
    if (*pszTok == COLON) {
        pszTok++;
    }

    //
    // Sorting order is based upon the order of entries in rgsrtdsc.
    // srtdsc contains a pointer to a compare function and a flag
    // wither to sort up or down.
    //
    for( irgch = 0, irgsrtdsc = pdrp->csrtdsc ;
         pszTok[irgch] && irgsrtdsc < MAXSORTDESC ;
         irgch++, irgsrtdsc++) {

        switch (_totupper(pszTok[irgch])) {

        case TEXT('N'):
            pdrp->rgsrtdsc[irgsrtdsc].fctCmp = CmpName;
            break;
        case TEXT('E'):
            pdrp->rgsrtdsc[irgsrtdsc].fctCmp = CmpExt;
            break;
        case TEXT('D'):
            pdrp->rgsrtdsc[irgsrtdsc].fctCmp = CmpTime;
            break;
        case TEXT('S'):
            pdrp->rgsrtdsc[irgsrtdsc].fctCmp = CmpSize;
            break;
        case TEXT('G'):
            pdrp->rgsrtdsc[irgsrtdsc].fctCmp = CmpType;
            break;
        case  MINUS:

            //
            // Check that there are not 2 -- in a row
            //
            if (pszTok[irgch+1] == MINUS) {

                PutStdErr( MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG, pszTok + irgch );
                return( FAILURE );

            }

            pdrp->rgsrtdsc[irgsrtdsc].Order = DESCENDING;
            irgsrtdsc--;
            break;

        default:

            PutStdErr( MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG, pszTok + irgch );
            return( FAILURE );

        } // switch

    }   // for

    //
    // Was there any specific sort order (something besides /O
    //
    if (irgsrtdsc == 0) {

        //
        // Setup default sorting
        //
        pdrp->rgsrtdsc[0].fctCmp = CmpType;
        pdrp->rgsrtdsc[1].fctCmp = CmpName;
        irgsrtdsc = 2;
    }


    DEBUG((ICGRP, DILVL, "SetSortDesc count %d", irgsrtdsc));
    pdrp->csrtdsc = irgsrtdsc;
    pdrp->rgsrtdsc[irgsrtdsc].fctCmp = NULL;
    return( SUCCESS );
}


STATUS
ParseDirParms (
        IN      PTCHAR  pszCmdLine,
        OUT     PDRP    pdrp
        )

/*++

Routine Description:

    Parse the command line translating the tokens into values
    placed in the parameter structure. The values are or'd into
    the parameter structure since this routine is called repeatedly
    to build up values (once for the environment variable DIRCMD
    and once for the actual command line).

Arguments:

    pszCmdLine - pointer to command line user typed


Return Value:

    pdrp - parameter data structure

    Return: TRUE  - if valid command line.
            FALSE - if not.

--*/
{

    PTCHAR   pszTok;

    TCHAR           szT[10] ;
    USHORT          irgchTok;
    BOOLEAN         fToggle;
    PPATDSC         ppatdscCur;

    DEBUG((ICGRP, DILVL, "DIR:ParseParms for `%ws'", pszCmdLine));

    //
    // Tokensize the command line (special delimeters are tokens)
    //
    szT[0] = SwitChar ;
    szT[1] = NULLC ;
    pszTok = TokStr(pszCmdLine, szT, TS_SDTOKENS) ;

    ppatdscCur = &(pdrp->patdscFirst);
    //
    // If there was a pattern put in place from the environment.
    // just add any new patterns on. So move to the end of the
    // current list.
    //
    if (pdrp->cpatdsc) {

        while (ppatdscCur->ppatdscNext) {

            ppatdscCur = ppatdscCur->ppatdscNext;

        }
    }

    pdrp->csrtdsc = 0;
    //
    // At this state pszTok will be a series of zero terminated strings.
    // "/o foo" wil be /0o0foo0
    //
    for ( irgchTok = 0; *pszTok ; pszTok += mystrlen(pszTok)+1, irgchTok = 0) {

        DEBUG((ICGRP, DILVL, "PRIVSW: pszTok = %ws", (UINT_PTR)pszTok)) ;

        //
        // fToggle control whether to turn off a switch that was set
        // in the DIRCMD environment variable.
        //
        fToggle = FALSE;
        if (pszTok[irgchTok] == (TCHAR)SwitChar) {

            if (pszTok[irgchTok + 2] == MINUS) {

                //
                // disable the previously enabled the switch
                //
                fToggle = TRUE;
                irgchTok++;
            }

            switch (_totupper(pszTok[irgchTok + 2])) {

            //
            // New Format is the os/2 default HPFS format. The main
            // difference is the filename is at the end of a long display
            // instead of at the beginning
            //
            case TEXT('N'):

                fToggle ? (pdrp->rgfSwitches |= OLDFORMATSWITCH) :  (pdrp->rgfSwitches |= NEWFORMATSWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case TEXT('W'):

                fToggle ? (pdrp->rgfSwitches ^= WIDEFORMATSWITCH) : (pdrp->rgfSwitches |= WIDEFORMATSWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case TEXT('D'):

                fToggle ? (pdrp->rgfSwitches ^= SORTDOWNFORMATSWITCH) : (pdrp->rgfSwitches |= SORTDOWNFORMATSWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case TEXT('P'):

                fToggle ? (pdrp->rgfSwitches ^= PAGEDOUTPUTSWITCH) : (pdrp->rgfSwitches |= PAGEDOUTPUTSWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case TEXT('4'):

                fToggle ? (pdrp->rgfSwitches ^= YEAR2000) : (pdrp->rgfSwitches |= YEAR2000);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case TEXT('B'):

                fToggle ? (pdrp->rgfSwitches ^= BAREFORMATSWITCH) :  (pdrp->rgfSwitches |= BAREFORMATSWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case TEXT('L'):

                fToggle ? (pdrp->rgfSwitches ^= LOWERCASEFORMATSWITCH) : (pdrp->rgfSwitches |= LOWERCASEFORMATSWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

#ifndef WIN95_CMD
            case TEXT('Q'):

                fToggle ? (pdrp->rgfSwitches ^= DISPLAYOWNER) : (pdrp->rgfSwitches |= DISPLAYOWNER);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;
#endif

            case TEXT('S'):

                fToggle ? (pdrp->rgfSwitches ^= RECURSESWITCH) :  (pdrp->rgfSwitches |= RECURSESWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case TEXT('C'):

                fToggle ? (pdrp->rgfSwitches ^= THOUSANDSEPSWITCH) :  (pdrp->rgfSwitches |= THOUSANDSEPSWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case TEXT('X'):

                pdrp->rgfSwitches |= SHORTFORMATSWITCH;
                pdrp->rgfSwitches |= NEWFORMATSWITCH;
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case MINUS:

                PutStdOut(MSG_HELP_DIR, NOARGS);
                return( FAILURE );
                break;

            case TEXT('O'):

                fToggle ? (pdrp->rgfSwitches ^= SORTSWITCH) :  (pdrp->rgfSwitches |= SORTSWITCH);
                if (fToggle) {
                    if ( _tcslen( &(pszTok[irgchTok + 2]) ) > 1) {
                        PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                                  (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                        return( FAILURE );
                    }
                    pdrp->csrtdsc = 0;
                    pdrp->rgsrtdsc[0].fctCmp = NULL;
                    break;
                }

                if (SetSortDesc( &(pszTok[irgchTok+3]), pdrp)) {
                    return( FAILURE );
                }
                break;

            case TEXT('A'):

                if (fToggle) {
                    if ( _tcslen( &(pszTok[irgchTok + 2]) ) > 1) {
                        PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                                  (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                        return( FAILURE );
                    }
                    pdrp->rgfAttribs = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN;
                    pdrp->rgfAttribsOnOff = 0;
                    break;
                }

                if (SetAttribs(&(pszTok[irgchTok + 3]), pdrp) ) {
                    return( FAILURE );
                }
                break;

            case TEXT('T'):

                if (fToggle) {

                    //
                    // revert to default
                    //
                    pdrp->dwTimeType = LAST_WRITE_TIME;
                    break;
                }
                if (SetTimeType(&(pszTok[irgchTok + 3]), pdrp) ) {
                    return( FAILURE );
                }
                break;

            default:

                szT[0] = SwitChar;
                szT[1] = pszTok[2];
                szT[2] = NULLC;
                PutStdErr(MSG_INVALID_SWITCH,
                          ONEARG,
                          (UINT_PTR)(&(pszTok[irgchTok + 2])) );

                return( FAILURE );

            } // switch

            //
            // TokStr parses /N as /0N0 so we need to move over the
            // switchar in or to move past the actual switch value
            // in for loop.
            //
            pszTok += 2;

        } else {

            //
            // If there already is a list the extend it else put info
            // directly into structure.
            //
            if (pdrp->cpatdsc) {

                ppatdscCur->ppatdscNext = (PPATDSC)gmkstr(sizeof(PATDSC));
                ppatdscCur = ppatdscCur->ppatdscNext;
                ppatdscCur->ppatdscNext = NULL;

            }

            pdrp->cpatdsc++;
            ppatdscCur->pszPattern = (PTCHAR)gmkstr(_tcslen(pszTok)*sizeof(TCHAR) + sizeof(TCHAR));
            mystrcpy(ppatdscCur->pszPattern, StripQuotes(pszTok) );
            ppatdscCur->fIsFat = TRUE;


        }


    } // for

    return( SUCCESS );
}

//
// return a pointer to the a new pattern with wild cards inserted.
// If no change has occured the passed in pattern is returned.
//
// NULL is returned if error.
//
/*++

Routine Description:

    This routine determines if any modification of to the current.
    NOTE that pszInPattern is freed!

Arguments:

Return Value:

    Return:

--*/
PTCHAR
SetWildCards (
    IN  PTCHAR      pszInPattern,
    IN  BOOLEAN     fFatDrive
    )

{

    PTCHAR  pszNewPattern = NULL;
    PTCHAR  pszT;
    USHORT  cb;
    DWORD l;

    DEBUG((ICGRP, DILVL, "DIR:SetWildCards"));
    DEBUG((ICGRP, DILVL, "\t fFatDrive = %x",fFatDrive));

    //
    // failure to allocate will not return but go through an
    // abort call in gmkstr
    //
    l = max(mystrlen(pszInPattern)+2, MAX_PATH+2) * sizeof(TCHAR);
    pszNewPattern = (PTCHAR)gmkstr(l);
    mystrcpy(pszNewPattern, pszInPattern);

    //
    // On FAT the default for .xxx is *.xxx while for HPFS .xxx is
    // just a file name.
    //
    // If .xxx or \xxx\.xxx then tranform into *.xxx or \xxx\*.xxx
    //
    // Likewise for no extension the default would be foo.*
    //

    if (fFatDrive) {

        pszT = mystrrchr(pszInPattern, PathChar);

        //
        // If there is no slash then check if pattern begining with
        //    a .xxx (making sure not to confuse it with just a . or .. at
        //    start of pattern)
        // If there a slash then check for \xxx\.xxx again making sure
        //    it is not \xxx\.. or \xxx\.
        //
        if ((!pszT && *pszInPattern == DOT &&
             *(pszInPattern + 1) != NULLC &&
             *(pszInPattern + 1) != DOT ) ||
            (pszT && *(pszT + 1) == DOT &&
             *(pszT + 2) != NULLC &&
             *(pszT + 2) != DOT ) ) {

            if (pszT) {
                cb = (USHORT)(pszT - pszInPattern + 1);
                _tcsncpy(pszNewPattern, pszInPattern, cb);
                *(pszNewPattern + cb) = NULLC;
            } else {
                *pszNewPattern = NULLC;
                cb = 0;
            }
            mystrcat(pszNewPattern, TEXT("*"));
            mystrcat(pszNewPattern, pszInPattern + cb);
            // FreeStr( pszInPattern );
            return( pszNewPattern );

        }
    }

    return( pszNewPattern );

}

/*++

Routine Description:

Arguments:

Return Value:

    Return:

--*/
BOOLEAN
IsFATDrive (
    IN PTCHAR   pszPath
    )
{

    DWORD   cbComponentMax;
    TCHAR   szFileSystemName[MAX_PATH + 2];
    TCHAR   szDrivePath[ MAX_PATH + 2 ];
    TCHAR   szDrive[MAX_PATH + 2];

    DosErr = 0;
    if (GetDrive(pszPath, (PTCHAR)szDrive)) {

        DEBUG((ICGRP, DILVL, "DIR:IsFatDrive `%ws'", szDrive));


        mystrcpy( szDrivePath, szDrive );
        mystrcat( szDrivePath, TEXT("\\") );

        //
        //  We return that the file system in question is a FAT file system
        //  if the component length is more than 12 bytes.
        //
        
        if (GetVolumeInformation( szDrivePath,
                                  NULL,
                                  0,
                                  NULL,
                                  &cbComponentMax,
                                  NULL,
                                  szFileSystemName,
                                  MAX_PATH + 2
                                )
           ) {
            if (!_tcsicmp(szFileSystemName, TEXT("FAT")) && cbComponentMax == 12) {
                return(TRUE);
            } else {
                return(FALSE);
            }
        } else {

            DosErr = GetLastError();

            // if GetVolumeInformation failed because we're a substed drive
            // or a down-level server, don't fail.

            if (DosErr == ERROR_DIR_NOT_ROOT) {
                DosErr = 0;
            }
            return(FALSE);
        }
    } else {

        //
        // If we could not get the drive then assume it is not FAT.
        // If it is not accessable etc. then that will be caught
        // later.
        //
        return( FALSE );
    }

}

/*++

Routine Description:

Arguments:

Return Value:

    Return:

--*/
BOOLEAN
GetDrive(
    IN PTCHAR pszPattern,
    OUT PTCHAR szDrive
    )
{
    TCHAR   szCurDrv[MAX_PATH + 2];
    PTCHAR   pszT;
    TCHAR   ch = NULLC;

    if (pszPattern == NULL) {

        return( FALSE );

    }

    //
    // assume we have the default case with no drive
    // letter specified
    //
    GetDir((PTCHAR)szCurDrv,GD_DEFAULT);
    szDrive[0] = szCurDrv[0];


    //
    // If we have a UNC name do not return a drive. No
    // drive operation would be allowed
    // For everything else a some drive operation would
    // be valid
    //

    // handle UNC names with drive letter (allowed in DOS)
    if ((pszPattern[1] == COLON)  && (pszPattern[2] == BSLASH) &&
        (pszPattern[3] == BSLASH)) {
        mystrcpy(&pszPattern[0],&pszPattern[2]);
    }

    if ((pszPattern[0] == BSLASH)  && (pszPattern[1] == BSLASH)) {

        pszT = mystrchr(&(pszPattern[2]), BSLASH);
        if (pszT == NULL) {

            //
            // badly formed unc name
            //
            return( FALSE );

        } else  {

            //
            // look for '\\foo\bar\xxx'
            //
            pszT = mystrchr(pszT + 1, BSLASH);
            //
            // pszPattern contains more then just share point
            //
            if (pszT != NULL) {

                ch = *pszT;
                *pszT = NULLC;
            }
            mystrcpy(szDrive, pszPattern);
            if (ch != NULLC) {

                *pszT = ch;

            }
            return ( TRUE );
        }
    }

    //
    // Must be a drive letter
    //

    if ((pszPattern[0]) && (pszPattern[1] == COLON)) {
        szDrive[0] = (TCHAR)_totupper(*pszPattern);
    }

    szDrive[1] = COLON;
    szDrive[2] = NULLC;
    return( TRUE );
}


/*++

Routine Description:

Arguments:

Return Value:

    Return:

--*/
STATUS
PrintPatterns (
    IN PDRP     pdpr
    )
{

    TCHAR               szDriveCur[MAX_PATH  + 2];
    TCHAR               szDrivePrev[MAX_PATH + 2];
    TCHAR               szDriveNext[MAX_PATH + 2];
    TCHAR               szPathForFreeSpace[MAX_PATH + 2];
    PPATDSC             ppatdscCur;
    PPATDSC             ppatdscX;
    PFS                 pfsFirst;
    PFS                 pfsCur;
    PFS                 pfsPrev;
    ULONG               i;
    STATUS              rc;
    PSCREEN             pscr;

    //
    //  Creating the console output is done early since error message
    //  should go through the console. If PrintPattern is called
    //  many times in the future this will be required since the
    //  error message should need to be under pause control
    //

    if (OpenScreen( &pscr) == FAILURE) {
        return( FAILURE );
    }

    //
    //  This will be NULL if for any reason we STDOUT is not a valid
    //  console handle, such as file redirection or redirection to a
    //  non-console device. In that case we turn off any paged output.
    //

    if (!(pscr->hndScreen)) {

        pdpr->rgfSwitches &= ~PAGEDOUTPUTSWITCH;

    }

    //
    //  Default will be the size of the screen - 1
    //  subtract 1 to account for the current line
    //

    if (pdpr->rgfSwitches & PAGEDOUTPUTSWITCH) {

        SetPause( pscr, pscr->crowMax - 1 );
    }

    //
    //  Sortdown => wide format but a different display order
    //

    if (pdpr->rgfSwitches & SORTDOWNFORMATSWITCH) {
        pdpr->rgfSwitches |= WIDEFORMATSWITCH;
    }

    //
    //  determine FAT drive from original pattern.
    //  Used in several places to control name format etc.
    //

    DosErr = 0;

    if (BuildFSFromPatterns(pdpr, TRUE, TRUE, &pfsFirst) == FAILURE) {

        return( FAILURE );

    }

    pfsPrev = NULL;

    mystrcpy( szPathForFreeSpace, TEXT("") );
    mystrcpy( szDriveCur, TEXT("") );

    for( pfsCur = pfsFirst; pfsCur; pfsCur = pfsCur->pfsNext) {

        mystrcpy( szPathForFreeSpace, pfsCur->pszDir );

        //
        //  Set up flags based on type of drive.  FAT drives get
        //  FAT format and are unable to display anything except
        //  LAST_WRITE_TIME
        //

        if (pfsCur->fIsFat) {
            pdpr->rgfSwitches |= FATFORMAT;
            if (pdpr->dwTimeType != LAST_WRITE_TIME) {
                PutStdErr(MSG_TIME_NOT_SUPPORTED, NOARGS);
                return( FAILURE );
            }

        } else {

            //
            // If it is  not fat then print out in new format that
            // puts names to the right to allow for extra long names
            //

            if (!(pdpr->rgfSwitches & OLDFORMATSWITCH)) {
                pdpr->rgfSwitches |= NEWFORMATSWITCH;
            }
        }

        //
        //  If we're not in bare mode, print out header if this
        //  is the first time or if the drive letter changes.
        //

        if ((pdpr->rgfSwitches & BAREFORMATSWITCH) == 0) {

            mystrcpy( szDrivePrev, szDriveCur );

            GetDrive(pfsCur->pszDir, szDriveCur);

            if (_tcsicmp( szDriveCur, szDrivePrev ) != 0) {

                if ((pfsPrev != NULL && WriteEol( pscr ) != SUCCESS) ||
                    DisplayVolInfo( pscr, pfsCur->pszDir ) != SUCCESS) {
                    return FAILURE;
                }
            }
        }

        //
        //  Walk down the tree printing each directory or just return
        //  after specificied directory.
        //

        pdpr->FileCount = pdpr->DirectoryCount = 0;
        pdpr->TotalBytes.QuadPart = 0i64;

        rc = WalkTree( pfsCur,
                       pscr,
                       pdpr->rgfAttribs,
                       pdpr->rgfAttribsOnOff,
                       pdpr->rgfSwitches & RECURSESWITCH,

                       pdpr,                                //  Data for display functions
                       NULL,                                //  Error
                       NewDisplayFileListHeader,            //  PreScan
                       (pdpr->rgfSwitches & (WIDEFORMATSWITCH | SORTSWITCH))
                           ? NULL : NewDisplayFile,         //  Scan
                       NewDisplayFileList                   //  PostScan
                       );

        //
        //  If we enumerated everything and we printed some files and the next
        //  file spec is on a different drive, display the free space
        //

        if (rc == SUCCESS && pdpr->FileCount + pdpr->DirectoryCount != 0) {

            if (!(pdpr->rgfSwitches & BAREFORMATSWITCH )) {

                mystrcpy( szDriveNext, TEXT("") );
                if (pfsCur->pfsNext) {
                    GetDrive( pfsCur->pfsNext->pszDir, szDriveNext );
                }

                if (_tcsicmp( szDriveNext, szDriveCur )) {
                    if ((pdpr->rgfSwitches & RECURSESWITCH) != 0) {
                        CHECKSTATUS ( WriteEol( pscr ));
                        CHECKSTATUS( DisplayTotals( pscr, pdpr->FileCount, &pdpr->TotalBytes, pdpr->rgfSwitches ));
                    }
                    CHECKSTATUS( DisplayDiskFreeSpace( pscr, szPathForFreeSpace, pdpr->rgfSwitches, pdpr->DirectoryCount ));
                }
            }
        } else if (!CtrlCSeen) {

            if (rc == ERROR_ACCESS_DENIED) {
                PutStdErr( rc, NOARGS );
            } else if (pdpr->FileCount + pdpr->DirectoryCount == 0) {
                WriteFlush( pscr );
                PutStdErr( MSG_FILE_NOT_FOUND, NOARGS );
                rc = 1;
            }
        }

        FreeStr(pfsCur->pszDir);
        for(i = 1, ppatdscCur = pfsCur->ppatdsc;
            i <= pfsCur->cpatdsc;
            i++, ppatdscCur = ppatdscX) {

            ppatdscX = ppatdscCur->ppatdscNext;
            FreeStr(ppatdscCur->pszPattern);
            FreeStr(ppatdscCur->pszDir);
            FreeStr((PTCHAR)ppatdscCur);
        }

        if (pfsPrev) {

            FreeStr((PTCHAR)pfsPrev);
        }

        pfsPrev = pfsCur;
    }

    WriteFlush( pscr );

    return(rc);
}

/*++

Routine Description:

Arguments:

Return Value:

    Return:

--*/
int
_cdecl
CmpName(
    const void *elem1,
    const void *elem2
    )
{
    int result;

    result = lstrcmpi( ((PFF)(* (PPFF)elem1))->data.cFileName, ((PFF)(* (PPFF)elem2))->data.cFileName);
    return result;
}

/*++

Routine Description:

Arguments:

Return Value:

    Return:

--*/
int
_cdecl
CmpExt(
    const void *pszElem1,
    const void *pszElem2
    )
{
    PTCHAR  pszElem1T, pszElem2T;
    int rc;


    //
    // Move pointer to name to make it all easier to read
    //
    pszElem1 = &(((PFF)(* (PPFF)pszElem1))->data.cFileName);
    pszElem2 = &(((PFF)(* (PPFF)pszElem2))->data.cFileName);

    //
    // Locate the extensions if any
    //
    if (((pszElem1T = mystrrchr( pszElem1, DOT)) == NULL ) ||

        (!_tcscmp(TEXT(".."),pszElem1) || !_tcscmp(TEXT("."),pszElem1)) ) {

        //
        // If no extension then point to end of string
        //
        pszElem1T = ((PTCHAR)pszElem1) + mystrlen(pszElem1 );
    }

    if (((pszElem2T = mystrrchr( pszElem2, DOT)) == NULL ) ||
        (!_tcscmp(TEXT(".."),pszElem2) || !_tcscmp(TEXT("."),pszElem2)) ) {

        //
        // If no extension then point to end of string
        //
        pszElem2T = ((PTCHAR)pszElem2) + mystrlen(pszElem2 );
    }
    rc = lstrcmpi( pszElem1T, pszElem2T );
    return rc;
}


/*++

Routine Description:

Arguments:

Return Value:

    Return:

--*/
int
_cdecl
CmpTime(
    const void *pszElem1,
    const void *pszElem2
    )
{

    LPFILETIME    pft1, pft2;


    switch (dwTimeType) {

    case LAST_ACCESS_TIME:

        pft1 = & ((* (PPFF)pszElem1)->data.ftLastAccessTime);
        pft2 = & ((* (PPFF)pszElem2)->data.ftLastAccessTime);
        break;

    case LAST_WRITE_TIME:

        pft1 = & ((* (PPFF)pszElem1)->data.ftLastWriteTime);
        pft2 = & ((* (PPFF)pszElem2)->data.ftLastWriteTime);
        break;

    case CREATE_TIME:

        pft1 = & ((* (PPFF)pszElem1)->data.ftCreationTime);
        pft2 = & ((* (PPFF)pszElem2)->data.ftCreationTime);
        break;

    }


    return(CompareFileTime( pft1, pft2 ) );

}

/*++

Routine Description:

Arguments:

Return Value:

    Return:

--*/
int
_cdecl
CmpSize(
    const void * pszElem1,
    const void * pszElem2
    )
{
    ULARGE_INTEGER ul1, ul2;

    ul1.HighPart = (* (PPFF)pszElem1)->data.nFileSizeHigh;
    ul2.HighPart = (* (PPFF)pszElem2)->data.nFileSizeHigh;
    ul1.LowPart = (* (PPFF)pszElem1)->data.nFileSizeLow;
    ul2.LowPart = (* (PPFF)pszElem2)->data.nFileSizeLow;

    if (ul1.QuadPart < ul2.QuadPart)
        return -1;
    else
    if (ul1.QuadPart > ul2.QuadPart)
        return 1;
    else
        return 0;

}

/*++

Routine Description:

Arguments:

Return Value:

    Return:

--*/
int
_cdecl
CmpType(
    const void *pszElem1,
    const void *pszElem2
    )
{

    //
    // This dependents upon FILE_ATTRIBUTE_DIRECTORY not being the high bit.
    //
    return( (( (* (PPFF)pszElem2)->data.dwFileAttributes) & FILE_ATTRIBUTE_DIRECTORY) -
            (( (* (PPFF)pszElem1)->data.dwFileAttributes) & FILE_ATTRIBUTE_DIRECTORY) );

}

/*++

Routine Description:

Arguments:

Return Value:

    Return:

--*/
int
_cdecl
SortCompare(
    IN  const void * elem1,
    IN  const void * elem2
    )
{

    ULONG   irgsrt;
    int     rc;

    //
    // prgsrtdsc is set in SortFileList
    //
    for (irgsrt = 0; prgsrtdsc[irgsrt].fctCmp; irgsrt++) {

        if (prgsrtdsc[irgsrt].Order == DESCENDING) {

            if (rc = prgsrtdsc[irgsrt].fctCmp(elem2, elem1)) {
                return( rc );
            }

        } else {

            if (rc = prgsrtdsc[irgsrt].fctCmp(elem1, elem2)) {
                return( rc );
            }

        }
    }
    return( 0 );

}

/*++

Routine Description:

Arguments:

Return Value:

    Return:

--*/
VOID
SortFileList(
    IN PFS       pfsFiles,
    IN PSORTDESC prgsrtdscLocal,
    IN ULONG     dwTimeTypeLocal
    )

{

    //
    // Set these globally to handle fixed parameters list for qsort
    //
    dwTimeType = dwTimeTypeLocal;
    prgsrtdsc = prgsrtdscLocal;

    //
    // Make sure there is something to sort
    //
    if (pfsFiles->cff) {
        if (prgsrtdsc[0].fctCmp) {
            qsort(pfsFiles->prgpff,
                  pfsFiles->cff,
                  sizeof(PTCHAR),
                  SortCompare);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\display.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    display.c

Abstract:

    Output routines for DIR

--*/

#include "cmd.h"

extern TCHAR ThousandSeparator[];

//         Entry is displayed.
//         If not /b,
//           Cursor is left at end of entry on screen.
//           FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
//         If /b,
//           Cursor is left at beginning of next line.
//           Cnt's and Siz's aren't updated.
//
// Create a manager for these totals

//
//  New format:
//      0123456789012345678901234567890123456789012345678901234567890123456789
//      02/23/2001  05:12p              14,611 build.log
//      02/23/2001  05:12p              14,611 ...                    build.log
//      02/26/2001  04:58p                  13 VERYLO~1        verylongfilename
//      02/26/2001  04:58p                  13 VERYLO~1        ...    verylongfilename
//
//      <date><space><space><time><space><space><18-char-size><space><15-char-short-name><space><22-char-ownername><space><longfilename>
//  Old format:
//      build    log             14,611 02/23/2001  05:12p
//      <8.3-name><space><18-char-size><space><date><space><space><time>
//  
//  Since the size of dates and times is *VARIABLE*, we presize these on each DIR call
//


ULONG WidthOfTimeDate = 19;
ULONG WidthOfFileSize = 17;
ULONG WidthOfShortName = 12;
ULONG WidthOfOwnerName = 22;

#define SPACES_AFTER_SIZE       1
#define SPACES_AFTERDATETIME    1
#define DIR_NEW_PAST_DATETIME           (WidthOfTimeDate + SPACES_AFTERDATETIME)
#define DIR_NEW_PAST_DATETIME_SPECIAL   (WidthOfTimeDate + SPACES_AFTERDATETIME + 3)
#define DIR_NEW_PAST_SIZE               (WidthOfTimeDate + SPACES_AFTERDATETIME + WidthOfFileSize + SPACES_AFTER_SIZE)
#define DIR_NEW_PAST_OWNER              (WidthOfTimeDate + SPACES_AFTERDATETIME + WidthOfFileSize + SPACES_AFTER_SIZE + WidthOfOwnerName + 1)
#define DIR_NEW_PAST_SHORTNAME          (WidthOfTimeDate + SPACES_AFTERDATETIME + WidthOfFileSize + SPACES_AFTER_SIZE + WidthOfShortName + 1)
#define DIR_NEW_PAST_SHORTNAME_OWNER    (WidthOfTimeDate + SPACES_AFTERDATETIME + WidthOfFileSize + SPACES_AFTER_SIZE + WidthOfShortName + 1 + WidthOfOwnerName + 1)

#define DIR_OLD_PAST_SHORTNAME          (WidthOfShortName + 2)
#define DIR_OLD_PAST_SIZE               (WidthOfShortName + 2 + WidthOfFileSize + SPACES_AFTER_SIZE)

extern TCHAR Fmt09[], Fmt26[] ;
extern BOOL CtrlCSeen;
extern ULONG YearWidth;
BOOLEAN  GetDrive( PTCHAR , PTCHAR );
VOID     SortFileList( PFS, PSORTDESC, ULONG);

STATUS
NewDisplayFileListHeader(
    IN  PFS FileSpec,
    IN  PSCREEN pscr,
    IN  PVOID Data
    )
/*++

Routine Description:

    Display the header for a complete file list. This will include
    the current directory.

Arguments:

    FileSpec - PFS for directory being enumerated

    pscr - screen handle

    data - PVOID to pdpr


Return Value:

    SUCCESS if everything was correctly displayed

--*/
{
    PDRP pdrp = (PDRP) Data;

    pdrp->rgfSwitches &= ~HEADERDISPLAYED;

    //
    //  We suppress the header:
    //
    //      For bare format
    //      Recursing (we display the header after we've actually found something)
    //

    if ((pdrp->rgfSwitches & (BAREFORMATSWITCH | RECURSESWITCH)) != 0) {
        return( SUCCESS );
    }

    CHECKSTATUS ( WriteEol( pscr ));

    return( WriteMsgString(pscr, MSG_DIR_OF, ONEARG, FileSpec->pszDir) );
}

STATUS
NewDisplayFile(
    IN  PFS FileSpec,
    IN  PFF CurrentFF,
    IN  PSCREEN pscr,
    IN  PVOID Data
    )
/*++

Routine Description:

    Displays a single file in 1 of several formats.

Arguments:

    FileSpec - PFS of directory being enumerated

    CurrentFF - PFF to current file

    pscr - screen handle for output

    Data - PVOID to pdpr with switches

Return Value:

    return SUCCESS
           FAILURE

--*/

{
    PDRP pdrp = (PDRP) Data;
    STATUS  rc = SUCCESS;
    PWIN32_FIND_DATA pdata;
    LARGE_INTEGER cbFile;

    pdata = &(CurrentFF->data);

    cbFile.LowPart = pdata->nFileSizeLow;
    cbFile.HighPart = pdata->nFileSizeHigh;
    FileSpec->cbFileTotal.QuadPart += cbFile.QuadPart;

    //
    //  If we're in a recursive display, there might not be a header
    //  displayed.  Check the state and print out one if needed.
    //

    if ((pdrp->rgfSwitches & RECURSESWITCH) != 0) {

        if ((pdrp->rgfSwitches & HEADERDISPLAYED) == 0) {
            pdrp->rgfSwitches &= ~RECURSESWITCH;
            rc = NewDisplayFileListHeader( FileSpec, pscr, Data );
            pdrp->rgfSwitches |= RECURSESWITCH;
            if (rc != SUCCESS) {
                return rc;
            }
            pdrp->rgfSwitches |= HEADERDISPLAYED;
        }
    }

    if ((pdrp->rgfSwitches & BAREFORMATSWITCH) != 0) {

        rc = DisplayBare( pscr, pdrp->rgfSwitches, FileSpec->pszDir, pdata);

    } else if ((pdrp->rgfSwitches & WIDEFORMATSWITCH) != 0) {

        rc = DisplayWide( pscr, pdrp->rgfSwitches, pdata );

    } else if ((pdrp->rgfSwitches & (NEWFORMATSWITCH | SHORTFORMATSWITCH)) != 0) {

        rc = DisplayNewRest(pscr, pdrp->dwTimeType, pdrp->rgfSwitches, pdata);

        if (rc == SUCCESS) {

            if ((pdrp->rgfSwitches & SHORTFORMATSWITCH) != 0) {

                if (CurrentFF->obAlternate != 0) {

                    FillToCol( pscr, DIR_NEW_PAST_SIZE );
                    rc = DisplayDotForm( pscr,
                                         pdrp->rgfSwitches,
                                         &(pdata->cFileName[CurrentFF->obAlternate]),
                                         pdata
                                         );

                }

                FillToCol( pscr, DIR_NEW_PAST_SHORTNAME );
            } else {
                FillToCol( pscr, DIR_NEW_PAST_SIZE );
            }

#ifndef WIN95_CMD
            if ((pdrp->rgfSwitches & DISPLAYOWNER) != 0) {
                TCHAR FullPath[MAX_PATH];
                BYTE SecurityDescriptor[ 65536 ];
                TCHAR Name[MAX_PATH];
                ULONG NameSize = sizeof( Name );
                TCHAR Domain[MAX_PATH];
                ULONG DomainSize = sizeof( Name );
                DWORD dwNeeded;
                PSID SID = NULL;
                BOOL OwnerDefaulted;
                SID_NAME_USE    snu;

                if (AppendPath( FullPath, MAX_PATH, FileSpec->pszDir, pdata->cFileName ) != SUCCESS) {
                    WriteString( pscr, TEXT( "..." ));
                } else if (!GetFileSecurity( FullPath,
                                             OWNER_SECURITY_INFORMATION,
                                             SecurityDescriptor,
                                             sizeof( SecurityDescriptor ),
                                             &dwNeeded )) {
                    WriteString( pscr, TEXT( "..." ));
                } else if (!GetSecurityDescriptorOwner( SecurityDescriptor,
                                                        &SID,
                                                        &OwnerDefaulted)) {
                    WriteString( pscr, TEXT( "..." ));
                } else if (!LookupAccountSid( NULL,
                                              SID,
                                              Name,
                                              &NameSize,
                                              Domain,
                                              &DomainSize,
                                              &snu)) {
                    WriteString( pscr, TEXT( "..." ));
                    SID = FreeSid( SID );
                } else {
                    WriteString( pscr, Domain );
                    WriteString( pscr, TEXT( "\\" ));
                    WriteString( pscr, Name );
                    SID = FreeSid( SID );
                }
                FillToCol( pscr, 
                           (pdrp->rgfSwitches & SHORTFORMATSWITCH) != 0 
                                ? DIR_NEW_PAST_SHORTNAME_OWNER 
                                : DIR_NEW_PAST_OWNER );
            }
#endif

            rc = DisplayDotForm( pscr, pdrp->rgfSwitches, pdata->cFileName, pdata );
        }

        CHECKSTATUS( WriteFlushAndEol( pscr ) );

    } else {
        rc = DisplaySpacedForm( pscr,
                                pdrp->rgfSwitches,
                                CurrentFF->obAlternate ?
                                   &(pdata->cFileName[CurrentFF->obAlternate]) :
                                   pdata->cFileName,
                                pdata
                                );
        if (rc == SUCCESS) {
            FillToCol( pscr, DIR_OLD_PAST_SHORTNAME );
            rc = DisplayOldRest( pscr, pdrp->dwTimeType, pdrp->rgfSwitches, pdata );
        }
        CHECKSTATUS( WriteFlushAndEol( pscr ) );
    }

    return( rc );
}


STATUS
NewDisplayFileList(
    IN  PFS FileSpec,
    IN  PSCREEN pscr,
    IN  PVOID Data
    )

/*++

Routine Description:

    Displays a list of files and directories in the specified format.  The files
    have been buffered in the PFS structure.

Arguments:

    FileSpec - PFS containing set of files to display

    pscr - PSCREEN for display

    Data - PVOID pointer to DRP

Return Value:

    return SUCCESS
           FAILURE

--*/

{
    ULONG   irgpff;
    ULONG   cffColMax;
    ULONG   crowMax;
    ULONG   crow, cffCol;

    STATUS  rc = SUCCESS;
    PDRP    pdrp = (PDRP) Data;
    BOOL    PrintedEarly = (pdrp->rgfSwitches & (WIDEFORMATSWITCH | SORTSWITCH)) == 0;
    ULONG   cff = FileSpec->cff;

    LARGE_INTEGER cbFile;

    pdrp->FileCount += FileSpec->FileCount;
    pdrp->DirectoryCount += FileSpec->DirectoryCount;
    pdrp->TotalBytes.QuadPart += FileSpec->cbFileTotal.QuadPart;

    if (!PrintedEarly && cff != 0) {

        //
        //  Sort the data if needed
        //

        if ((pdrp->rgfSwitches & SORTSWITCH) != 0) {
            SortFileList( FileSpec, pdrp->rgsrtdsc, pdrp->dwTimeType );
        }

        //
        //  Compute the tab spacing on the line from the size of the file names.
        //  add 3 spaces to seperate each field
        //
        //  If multiple files per line then base tabs on the max file/dir size
        //

        if ((pdrp->rgfSwitches & WIDEFORMATSWITCH) != 0) {
            SetTab( pscr, (USHORT)(GetMaxCbFileSize( FileSpec ) + 3) );
        } else {
            SetTab( pscr, 0 );
        }

        DEBUG((ICGRP, DISLVL, "\t count of files %d",cff));

        if ((pdrp->rgfSwitches & SORTDOWNFORMATSWITCH) != 0) {

            //
            //  no. of files on a line.
            //

            cffColMax = (pscr->ccolMax / pscr->ccolTab);

            //
            //  number of row required for entire list
            //

            if (cffColMax == 0)     // wider than a line
                goto abort_wide;    // abort wide format for this list
            else
                crowMax = (cff + cffColMax) / cffColMax;

            //
            //  move down each rown picking the elements cffCols aport down the list.
            //

            for (crow = 0; crow < crowMax; crow++) {
                for (cffCol = 0, irgpff = crow;
                    cffCol < cffColMax;
                    cffCol++, irgpff += crowMax) {

                    if (CtrlCSeen) {
                        return FAILURE;
                    }

                    if (irgpff < cff) {

                        cbFile.LowPart = FileSpec->prgpff[irgpff]->data.nFileSizeLow;
                        cbFile.HighPart = FileSpec->prgpff[irgpff]->data.nFileSizeHigh;
                        pdrp->TotalBytes.QuadPart += cbFile.QuadPart;

                        rc = NewDisplayFile( FileSpec,
                                             FileSpec->prgpff[irgpff],
                                             pscr,
                                             Data );

                        if (rc != SUCCESS) {
                            return rc;
                        }

                    } else {

                        //
                        // If we have run past the end of the file list terminate
                        // line and start over back inside the line
                        //
                        CHECKSTATUS( WriteEol(pscr) );
                        break;
                    }

                }
            }

        } else if (!PrintedEarly) {
    abort_wide:
            if (CtrlCSeen) {
                return FAILURE;
            }

            for (irgpff = 0; irgpff < cff; irgpff++) {

                if (CtrlCSeen) {
                    return FAILURE;
                }

                cbFile.LowPart = FileSpec->prgpff[irgpff]->data.nFileSizeLow;
                cbFile.HighPart = FileSpec->prgpff[irgpff]->data.nFileSizeHigh;
                pdrp->TotalBytes.QuadPart += cbFile.QuadPart;

                rc = NewDisplayFile( FileSpec,
                                     FileSpec->prgpff[irgpff],
                                     pscr,
                                     Data );
                if (rc != SUCCESS) {
                    return rc;
                }
            }
        }

        //
        //  Before writing the tailer make sure buffer is
        //  empty. (Could have something from doing WIDEFORMATSWITCH
        //

        CHECKSTATUS( WriteFlushAndEol( pscr ) );

    }

    if ((pdrp->rgfSwitches & BAREFORMATSWITCH) == 0) {
        if (FileSpec->FileCount + FileSpec->DirectoryCount != 0) {
            CHECKSTATUS( DisplayFileSizes( pscr, &FileSpec->cbFileTotal, FileSpec->FileCount, pdrp->rgfSwitches ));
        }
    }

    return SUCCESS;
}



STATUS
DisplayBare (

    IN  PSCREEN          pscr,
    IN  ULONG            rgfSwitches,
    IN  PTCHAR           pszDir,
    IN  PWIN32_FIND_DATA pdata
    )
/*++

Routine Description:

    Displays a single file in bare format. This is with no header, tail and
    no file information other then it's name. If it is a recursive catalog
    then the full file path is displayed. This mode is used to feed other
    utitilies such as grep.

Arguments:

    pscr - screen handle
    rgfSwitches - command line switch (controls formating)
    pszDir - current directory (used for full path information)
    pdata - data gotten back from FindNext API


Return Value:

    return SUCCESS
           FAILURE

--*/


{

    TCHAR   szDirString[MAX_PATH + 2];
    STATUS  rc;

    DEBUG((ICGRP, DISLVL, "DisplayBare `%ws'", pdata->cFileName));

    //
    // Do not display '.' and '..' in a bare listing
    //
    if ((_tcscmp(pdata->cFileName, TEXT(".")) == 0) || (_tcscmp(pdata->cFileName, TEXT("..")) == 0)) {

        return( SUCCESS );

    }

    //
    // If we are recursing down then display full name else just the
    // name in the find  buffer
    //

    if (rgfSwitches & RECURSESWITCH) {

        mystrcpy(szDirString, pszDir);
        if (rgfSwitches & LOWERCASEFORMATSWITCH) {

            _tcslwr(szDirString);
        }

        CHECKSTATUS( WriteString(pscr, szDirString) );

        if (*lastc(szDirString) != BSLASH) {
            CHECKSTATUS( WriteString(pscr, TEXT("\\")));
        }

    }

    if ((rc = DisplayDotForm(pscr, rgfSwitches, pdata->cFileName, pdata)) == SUCCESS) {

        return( WriteEol(pscr));

    } else {

        return( rc );

    }

}

VOID
SetDotForm (
    IN  PTCHAR  pszFileName,
    IN  ULONG   rgfSwitches
    )
/*++

Routine Description:

    If FATFORMAT and there is a '.' with a blank extension, the '.' is
    removed so it does not get displayed.  This is by convension and is very
    strange but that's life. Also a lower case mapping is done.

Arguments:

    pszFileName - file to remove '.' from.
    rgfSwitches - command line switches (tell wither in FATFORMAT or not)


Return Value:

    return SUCCESS
           FAILURE

--*/


{
    PTCHAR  pszT;

    if (rgfSwitches & FATFORMAT) {

        //
        // Under DOS if there is a . with a blank extension
        // then do not display '.'.
        //
        if (pszT = mystrrchr(pszFileName, DOT)) {
            //
            // FAT will not allow foo. ba as a valid name so
            // see of any blanks in extensions and if so then assume
            // the entire extension is blank
            //
            if (mystrchr(pszT, SPACE)) {
                *pszT = NULLC;
            }
        }

    }

}


STATUS
DisplayDotForm (

    IN  PSCREEN pscr,
    IN  ULONG   rgfSwitches,
    IN  PTCHAR   pszFileName,
    IN  PWIN32_FIND_DATA pdata
    )
/*++

Routine Description:

    Displays a single file in DOT form (see SetDotForm).

Arguments:

    pscr - screen handle
    rgfSwitches - command line switch (tell wither to lowercase or not)
    pdata - data gotten back from FindNext API


Return Value:

    return SUCCESS
           FAILURE

--*/

{

    TCHAR   szFileName[MAX_PATH + 2];

    mystrcpy(szFileName, pszFileName);
    SetDotForm(szFileName, rgfSwitches);
    if (rgfSwitches & LOWERCASEFORMATSWITCH) {
        _tcslwr(szFileName);
    }

    if (WriteString( pscr, szFileName ) )
        return FAILURE;

    return SUCCESS;
}

STATUS
DisplaySpacedForm(

    IN  PSCREEN          pscr,
    IN  ULONG            rgfSwitches,
    IN  PTCHAR           pszName,
    IN  PWIN32_FIND_DATA pdata
    )
/*++

Routine Description:

    Display name in expanded format. name <spaces> ext.
    This is ONLY called for a FAT partition. This is controled by the
    NEWFORMATSWITCH. This is set for any file system other then FAT. There
    is no OLDFORMATSWITCH so we can never be called on an HPFS or NTFS
    volume. If this is changed then the entire spacing of the display will
    be blown due to non-fixed max file names. (i.e. 8.3).

Arguments:

    pscr - screen handle
    rgfSwitches - command line switch (tell wither to lowercase or not)
    pszname - name string to use (short name format only)
    pdata - data gotten back from FindNext API


Return Value:

    return SUCCESS
           FAILURE

--*/

{

    TCHAR   szFileName[MAX_PATH + 2];
    PTCHAR  pszExt;
    USHORT  cbName;
    STATUS  rc;
#ifdef FE_SB
    int     i;
    int     l;
#endif

    mytcsnset(szFileName, SPACE, MAX_PATH + 2);

    cbName = 0;
    if ((_tcscmp(pszName, TEXT(".")) == 0) || (_tcscmp(pszName, TEXT("..")) == 0)) {

        //
        // If it is either of these then do not get it
        // confused with extensions
        //
        pszExt = NULL;

    } else {

        pszExt = mystrrchr(pszName, (int)DOT);
        cbName = (USHORT)(pszExt - pszName)*sizeof(WCHAR);
    }

    //
    // if no extension or name is extension only
    //
    if ((pszExt == NULL) || (cbName == 0)) {

        cbName = (USHORT)_tcslen(pszName)*sizeof(TCHAR);

    }

    memcpy(szFileName, pszName, cbName );

#if defined(FE_SB)
    //
    // If we had an extension then print it after
    // all the spaces
    //
    i = 9;
    if (IsDBCSCodePage())
    {
        for (l=0 ; l<8 ; l++) {
            if (IsFullWidth(szFileName[l]))
                i--;
        }
    }

    if (pszExt) {

        mystrcpy(szFileName + i, pszExt + 1);
    }

    //
    // terminate at max end for a FAT name
    //

    szFileName[i+3] = NULLC;
    if (pszExt &&
        IsDBCSCodePage()) {
        //
        // Only 1 of three can be full width, since 3/2=1.
        // If the first isn't, only the second could be.
        //
        if (IsFullWidth(*(pszExt+1)) || IsFullWidth(*(pszExt+2)))
            szFileName[i+2] = NULLC;
    }
#else
    if (pszExt) {

        //
        // move pszExt past dot. use 9 not 8 to pass
        // over 1 space between name and extension
        //
        mystrcpy(szFileName + 9, pszExt + 1);

    }

    //
    // terminate at max end for a FAT name
    //
    szFileName[12] = NULLC;
#endif

    if (rgfSwitches & LOWERCASEFORMATSWITCH) {
        _tcslwr(szFileName);
    }

    rc = WriteString( pscr, szFileName );
    return rc;
}

STATUS
DisplayOldRest(

    IN  PSCREEN          pscr,
    IN  ULONG            dwTimeType,
    IN  ULONG            rgfSwitches,
    IN  PWIN32_FIND_DATA pdata
    )
/*++

Routine Description:

    Used with DisplaySpacedForm to write out file information such as size
    and last write time.

Arguments:

    pscr - screen handle
    pdata - data gotten back from FindNext API


Return Value:

    return SUCCESS
           FAILURE

--*/

{
    TCHAR szSize [ MAX_PATH ];
    DWORD Length;
    LARGE_INTEGER FileSize;

    //
    // If directory put <DIR> after name instead of file size
    //
    if (pdata->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {


        CHECKSTATUS( WriteMsgString(pscr, MSG_DIR,0) );

    } else {

        FileSize.LowPart = pdata->nFileSizeLow;
        FileSize.HighPart = pdata->nFileSizeHigh;
        Length = FormatFileSize( rgfSwitches, &FileSize, 0, szSize );
        FillToCol(pscr, DIR_OLD_PAST_SIZE  - SPACES_AFTER_SIZE - Length);
        WriteFmtString(pscr, TEXT( "%s" ), (PVOID)szSize);

    }

    FillToCol(pscr, DIR_OLD_PAST_SIZE);
    return( DisplayTimeDate( pscr, dwTimeType, rgfSwitches, pdata) );

}

STATUS
DisplayTimeDate (

    IN  PSCREEN         pscr,
    IN  ULONG           dwTimeType,
    IN  ULONG           rgfSwitches,
    IN  PWIN32_FIND_DATA pdata
    )
/*++

Routine Description:

    Display time/data information for a file

Arguments:

    pscr - screen handle
    pdata - data gotten back from FindNext API


Return Value:

    return SUCCESS
           FAILURE

--*/

{

    struct tm   FileTime;
    TCHAR       szT[ MAX_PATH + 1];
    TCHAR       szD[ MAX_PATH + 1];
    FILETIME    ft;

    switch (dwTimeType) {

    case LAST_ACCESS_TIME:

        ft = pdata->ftLastAccessTime;
        break;

    case LAST_WRITE_TIME:

        ft = pdata->ftLastWriteTime;
        break;

    case CREATE_TIME:

        ft = pdata->ftCreationTime;
        break;

    }


    ConvertFILETIMETotm( &ft, &FileTime );
    
    //
    //  Display four digit year iff the year width is specified
    //  in the locale or if it was requested on the command line
    //

    PrintDate( &FileTime,
               (YearWidth == 4 || (rgfSwitches & YEAR2000) != 0)
                ? PD_DIR2000
                : PD_DIR,
               szD, MAX_PATH );
    CHECKSTATUS( WriteFmtString( pscr, TEXT("%s  "), szD ));
    PrintTime( &FileTime, PT_DIR, szT, MAX_PATH ) ;
    CHECKSTATUS( WriteFmtString(pscr, TEXT("%s"), szT) );

    WidthOfTimeDate = SizeOfHalfWidthString( szD ) + 2 + SizeOfHalfWidthString( szT );
    
    return( SUCCESS );
}

STATUS
DisplayNewRest(
    IN  PSCREEN          pscr,
    IN  ULONG            dwTimeType,
    IN  ULONG            rgfSwitches,
    IN  PWIN32_FIND_DATA pdata
    )

/*++

Routine Description:

    Display file information for new format (comes before file name).
    This is used with NEWFORMATSWITCH which is active on any non-FAT
    partition.

Arguments:

    pscr - screen handle
    pdata - data gotten back from FindNext API


Return Value:

    return SUCCESS
           FAILURE

--*/

{

    STATUS  rc;
    DWORD MsgNo;
    LARGE_INTEGER FileSize;

    rc = DisplayTimeDate( pscr, dwTimeType, rgfSwitches, pdata);

    if (rc == SUCCESS) {

        //
        // If reparse point, special formatting.
        //
        // If it's an NSS reparse tag, we want to end up in the
        //  normal file path below.
        if ((pdata->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
            (pdata->dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) == 0 &&
            IsReparseTagNameSurrogate( pdata->dwReserved0 )) {

            FillToCol( pscr, DIR_NEW_PAST_DATETIME_SPECIAL );
            MsgNo = MSG_DIR_MOUNT_POINT;
            rc = WriteMsgString(pscr, MsgNo, 0);

        } else

        //
        // If directory put <DIR> after name instead of file size
        //
        if (pdata->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            FillToCol( pscr, DIR_NEW_PAST_DATETIME_SPECIAL );
            rc = WriteMsgString(pscr, MSG_DIR, 0);

        } else {
            TCHAR szSize [ MAX_PATH ];
            DWORD Length;

            FillToCol(pscr, DIR_NEW_PAST_DATETIME);

            FileSize.LowPart = pdata->nFileSizeLow;
            FileSize.HighPart = pdata->nFileSizeHigh;
            Length = FormatFileSize( rgfSwitches, &FileSize, 0, szSize );

            //
            // Show file sizes of high latency reparse points in parens to
            // tell user it will be slow to retreive.
            //
            if ((pdata->dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) != 0) {
                Length += 2;
                FillToCol(pscr, DIR_NEW_PAST_SIZE - SPACES_AFTER_SIZE - Length);
                rc = WriteFmtString(pscr, TEXT("(%s)"), (PVOID)szSize);
            } else {
                FillToCol(pscr, DIR_NEW_PAST_SIZE - SPACES_AFTER_SIZE - Length);
                rc = WriteFmtString(pscr, TEXT( "%s" ), (PVOID)szSize);
            }
        }

    }

    return( rc );

}


STATUS
DisplayWide (

    IN  PSCREEN          pscr,
    IN  ULONG            rgfSwitches,
    IN  PWIN32_FIND_DATA pdata
    )
/*++

Routine Description:

    Displays a single file used in the /w or /d Switches. That is with a
    multiple file column display.

Arguments:

    pscr - screen handle
    rgfSwitches - command line Switches (controls formating)
    pdata - data gotten back from FindNext API


Return Value:

    return SUCCESS
           FAILURE

--*/

{

    TCHAR   szFileName[MAX_PATH + 2];
    PTCHAR  pszFmt;
    STATUS  rc;

    pszFmt = TEXT( "%s" ); // assume non-dir format

    //
    // Provides [] around directories
    //
    if (pdata->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        pszFmt = Fmt09;

    }

    mystrcpy(szFileName, pdata->cFileName);
    SetDotForm(szFileName, rgfSwitches);
    if (rgfSwitches & LOWERCASEFORMATSWITCH) {
        _tcslwr(szFileName);
    }
    rc =  WriteFmtString(pscr, pszFmt, szFileName);

    if (rc == SUCCESS) {

        rc = WriteTab(pscr);

    }
    return( rc );

}

USHORT
GetMaxCbFileSize(
    IN  PFS pfsFiles
    )

/*++

Routine Description:

    Determines the longest string size in a file list. Used in computing
    the number of possible columns in a catalog listing.

Arguments:

    pfsFiles - file list.

Return Value:

    return # of characters in largest file name

--*/

{


    ULONG  cff;
    ULONG  irgff;
    USHORT cb;
    PFF    pffCur;

    cb = 0;
    for(irgff = 0, cff = pfsFiles->cff, pffCur = pfsFiles->prgpff[irgff];
        irgff < cff;
        irgff++) {

#if defined(FE_SB)
        if (IsDBCSCodePage())
            cb = max(cb, (USHORT)SizeOfHalfWidthString(((pfsFiles->prgpff[irgff])->data).cFileName));
        else
            cb = max(cb, (USHORT)mystrlen( ((pfsFiles->prgpff[irgff])->data).cFileName ));
#else
        cb = max(cb, (USHORT)mystrlen( ((pfsFiles->prgpff[irgff])->data).cFileName ));
#endif

    }

    return( cb );




}

STATUS
DisplayFileSizes(
    IN  PSCREEN pscr,
    IN  PLARGE_INTEGER cbFileTotal,
    IN  ULONG   cffTotal,
    IN  ULONG rgfSwitches
    )

/*++

Routine Description:

    Does tailer display of # of files displayed and # of bytes
    in all files displayed.

Arguments:

    pscr - screen handle
    cbFileTotal - bytes in all files displayed
    cffTotal - number of files displayed.

Return Value:

    return SUCCESS
           FAILURE

--*/

{
    TCHAR szSize [ MAX_PATH];

    FillToCol(pscr, 6);

    FormatFileSize( rgfSwitches, cbFileTotal, 14, szSize );
    return( WriteMsgString(pscr, MSG_FILES_COUNT_FREE, TWOARGS,
                           (UINT_PTR)argstr1(TEXT("%5lu"), cffTotal ),
                           szSize ) );
}

STATUS
DisplayTotals(
    IN  PSCREEN pscr,
    IN  ULONG   cffTotal,
    IN  PLARGE_INTEGER cbFileTotal,
    IN  ULONG rgfSwitches
    )
/*++

Routine Description:

    Does tailer display of # of files displayed and # of bytes
    in all files displayed.

Arguments:

    pscr - screen handle
    cbFileTotal - bytes in all files displayed
    cffTotal - number of files displayed.

Return Value:

    return SUCCESS
           FAILURE

--*/


{

    STATUS  rc;

    if ((rc =  WriteMsgString(pscr, MSG_FILE_TOTAL, 0) ) == SUCCESS ) {

        if ((rc = DisplayFileSizes( pscr, cbFileTotal, cffTotal, rgfSwitches )) == SUCCESS) {

            rc =  WriteFlush(pscr) ;

        }

    }
    return ( rc );


}

STATUS
DisplayDiskFreeSpace(
    IN PSCREEN pscr,
    IN PTCHAR pszDrive,
    IN ULONG rgfSwitches,
    IN ULONG DirectoryCount
    )
/*++

Routine Description:

    Displays total free space on volume.

Arguments:

    pscr - screen handle
    pszDrive - volume drive letter

Return Value:

    return SUCCESS
           FAILURE

--*/
{
    TCHAR   szPath [ MAX_PATH + 2];
    ULARGE_INTEGER cbFree;

    CheckPause( pscr );

#ifdef WIN95_CMD
    if (!GetDrive( pszDrive, szPath )) {
        return SUCCESS;
    }
    mystrcat( szPath, TEXT( "\\" ));
#else
    mystrcpy( szPath, pszDrive );

    if (IsDrive( szPath )) {
        mystrcat( szPath, TEXT("\\") );
    }
#endif

    cbFree.LowPart = cbFree.HighPart = 0;

#ifdef WIN95_CMD
    {
        DWORD   dwSectorsPerCluster;
        DWORD   dwBytesPerSector;
        DWORD   dwNumberOfFreeClusters;
        DWORD   dwTotalNumberOfClusters;
        if (GetDiskFreeSpace( szPath,&dwSectorsPerCluster, &dwBytesPerSector,
                              &dwNumberOfFreeClusters, &dwTotalNumberOfClusters)) {

            cbFree.QuadPart = UInt32x32To64(dwSectorsPerCluster, dwNumberOfFreeClusters);
            cbFree.QuadPart = cbFree.QuadPart * dwBytesPerSector;
        }
    }
#else
    {
        ULARGE_INTEGER lpTotalNumberOfBytes;
        ULARGE_INTEGER lpTotalNumberOfFreeBytes;
        GetDiskFreeSpaceEx( szPath, &cbFree,
                                    &lpTotalNumberOfBytes,
                                    &lpTotalNumberOfFreeBytes);
    }

#endif

    FillToCol(pscr, 6);

    FormatFileSize( rgfSwitches, (PLARGE_INTEGER) &cbFree, 14, szPath );

    return( WriteMsgString(pscr,
                           MSG_FILES_TOTAL_FREE,
                           TWOARGS,
                           (UINT_PTR)argstr1(TEXT("%5lu"), DirectoryCount ),
                           szPath ));

}

STATUS
DisplayVolInfo(
    IN  PSCREEN pscr,
    IN  PTCHAR  pszDrive
    )

/*++

Routine Description:

    Displays the volume trailer information. Used before switching to
    a catalog of another drive (dir a:* b:*)

Arguments:

    pscr - screen handle
    pszDrive - volume drive letter

Return Value:

    return SUCCESS
           FAILURE

--*/

{

    DWORD   Vsn[2];
    TCHAR   szVolName[MAX_PATH + 2];
    TCHAR   szVolRoot[MAX_PATH + 2];
    TCHAR   szT[256];
    STATUS  rc = SUCCESS;

    if (!GetDrive(pszDrive, szVolRoot)) {
        return SUCCESS;
    }

    mystrcat(szVolRoot, TEXT("\\"));

    if (!GetVolumeInformation(szVolRoot,szVolName,MAX_PATH,Vsn,NULL,NULL,NULL,0)) {

        DEBUG((ICGRP, DISLVL, "DisplayVolInfo: GetVolumeInformation ret'd %d", GetLastError())) ;
        // don't fail if we're a substed drive
        if (GetLastError() == ERROR_DIR_NOT_ROOT) {
            return SUCCESS;
        }
        PutStdErr(GetLastError(), NOARGS);
        return( FAILURE ) ;

    } else {

        if (szVolRoot[0] == BSLASH) {
            *lastc(szVolRoot) = NULLC;
        } else {

            szVolRoot[1] = NULLC;
        }

        if (szVolName[0]) {

            rc = WriteMsgString(pscr,
                                MSG_DR_VOL_LABEL,
                                TWOARGS,
                                szVolRoot,
                                szVolName ) ;
        } else {

            rc = WriteMsgString(pscr,
                                MSG_HAS_NO_LABEL,
                                ONEARG,
                                szVolRoot ) ;

        }

        if ((rc == SUCCESS) && (Vsn)) {

            _sntprintf(szT,256,Fmt26,(Vsn[0] & 0xffff0000)>>16, (Vsn[0] & 0xffff) );
            rc = WriteMsgString(pscr, MSG_DR_VOL_SERIAL, ONEARG, szT);
        }
    }

    return( rc );
}


ULONG
FormatFileSize(
    IN DWORD rgfSwitches,
    IN PLARGE_INTEGER FileSize,
    IN DWORD Width,
    OUT PTCHAR FormattedSize
    )
{
    TCHAR Buffer[ 100 ];
    PTCHAR s, s1;
    ULONG DigitIndex;
    ULONGLONG Digit;
    ULONG nThousandSeparator;
    ULONGLONG Size;

    nThousandSeparator = _tcslen(ThousandSeparator);
    s = &Buffer[ 99 ];
    *s = TEXT('\0');
    DigitIndex = 0;
    Size = FileSize->QuadPart;
    while (Size != 0) {
        Digit = (Size % 10);
        Size = Size / 10;
        *--s = (TCHAR)(TEXT('0') + Digit);
        if ((++DigitIndex % 3) == 0 && (rgfSwitches & THOUSANDSEPSWITCH)) {
            // If non-null Thousand separator, insert it.
            if (nThousandSeparator) {
                s -= nThousandSeparator;
                _tcsncpy(s, ThousandSeparator, nThousandSeparator);
            }
        }
    }

    if (DigitIndex == 0) {
        *--s = TEXT('0');
    }
    else
    if ((rgfSwitches & THOUSANDSEPSWITCH) && !_tcsncmp(s, ThousandSeparator, nThousandSeparator)) {
        s += nThousandSeparator;
    }

    Size = _tcslen( s );
    if (Width != 0 && Size < Width) {
        s1 = FormattedSize;
        while (Width > Size) {
            Width -= 1;
            *s1++ = SPACE;
        }
        _tcscpy( s1, s );
    } else {
        _tcscpy( FormattedSize, s );
    }

    return _tcslen( FormattedSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\del.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    del.c

Abstract:

    Process the DEL/ERASE command

--*/

#include "cmd.h"

#define Wild(spec)  ((spec)->flags & (CI_NAMEWILD))

VOID    ResetCtrlC();

extern unsigned msglen;

extern TCHAR Fmt11[], Fmt19[], Fmt17[];
extern TCHAR CurDrvDir[] ;

extern TCHAR SwitChar;
extern unsigned DosErr ;
extern BOOL CtrlCSeen;
extern ULONG DCount ;


STATUS DelPatterns (PDRP );

PTCHAR GetWildPattern( ULONG, PPATDSC );

STATUS
ParseRmDirParms (
        IN      PTCHAR  pszCmdLine,
        OUT     PDRP    pdrp
        )

/*++

Routine Description:

    Parse the command line translating the tokens into values
    placed in the parameter structure. The values are or'd into
    the parameter structure since this routine is called repeatedly
    to build up values (once for the environment variable DIRCMD
    and once for the actual command line).

Arguments:

    pszCmdLine - pointer to command line user typed


Return Value:

    pdrp - parameter data structure

    Return: TRUE  - if valid command line.
            FALSE - if not.

--*/
{

    PTCHAR   pszTok;

    TCHAR           szT[10] ;
    USHORT          irgchTok;
    BOOLEAN         fToggle;
    PPATDSC         ppatdscCur;
    int tlen;

    //
    // Tokensize the command line (special delimeters are tokens)
    //
    szT[0] = SwitChar ;
    szT[1] = NULLC ;
    pszTok = TokStr(pszCmdLine, szT, TS_SDTOKENS) ;

    ppatdscCur = &(pdrp->patdscFirst);
    //
    // If there was a pattern put in place from the environment.
    // just add any new patterns on. So move to the end of the
    // current list.
    //
    if (pdrp->cpatdsc) {

        while (ppatdscCur->ppatdscNext) {

            ppatdscCur = ppatdscCur->ppatdscNext;

        }
    }

    //
    // At this state pszTok will be a series of zero terminated strings.
    // "/o foo" wil be /0o0foo0
    //
    for ( irgchTok = 0; *pszTok ; pszTok += tlen+1, irgchTok = 0) {
        tlen = mystrlen(pszTok);

        DEBUG((ICGRP, DILVL, "PRIVSW: pszTok = %ws", pszTok)) ;

        //
        // fToggle control wither to turn off a switch that was set
        // in the DIRCMD environment variable.
        //
        fToggle = FALSE;
        if (pszTok[irgchTok] == (TCHAR)SwitChar) {

            if (pszTok[irgchTok + 2] == MINUS) {

                //
                // disable the previously enabled the switch
                //
                fToggle = TRUE;
                irgchTok++;
            }

            switch (_totupper(pszTok[irgchTok + 2])) {
            case QUIETCH:

                fToggle ? (pdrp->rgfSwitches ^= QUIETSWITCH) :  (pdrp->rgfSwitches |= QUIETSWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case TEXT('S'):

                fToggle ? (pdrp->rgfSwitches ^= RECURSESWITCH) :  (pdrp->rgfSwitches |= RECURSESWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case QMARK:

                BeginHelpPause();
                PutStdOut(MSG_HELP_DIR, NOARGS);
                EndHelpPause();
                return( FAILURE );
                break;


            default:

                szT[0] = SwitChar;
                szT[1] = pszTok[2];
                szT[2] = NULLC;
                PutStdErr(MSG_INVALID_SWITCH,
                          ONEARG,
                          (UINT_PTR)(&(pszTok[irgchTok + 2])) );

                return( FAILURE );

            } // switch

            //
            // TokStr parses /N as /0N0 so we need to move over the
            // switchar in or to move past the actual switch value
            // in for loop.
            //
            pszTok += 2;

        } else {

            mystrcpy( pszTok, StripQuotes( pszTok ) );

            //
            // If there already is a list the extend it else put info
            // directly into structure.
            //
            if (pdrp->cpatdsc) {

                ppatdscCur->ppatdscNext = (PPATDSC)gmkstr(sizeof(PATDSC));
                ppatdscCur = ppatdscCur->ppatdscNext;
                ppatdscCur->ppatdscNext = NULL;

            }

            pdrp->cpatdsc++;
            ppatdscCur->pszPattern = (PTCHAR)gmkstr(_tcslen(pszTok)*sizeof(TCHAR) + sizeof(TCHAR));
            mystrcpy(ppatdscCur->pszPattern, pszTok);
            ppatdscCur->fIsFat = TRUE;


        }


    } // for

    return( SUCCESS );
}

STATUS
ParseDelParms (
        IN      PTCHAR  pszCmdLine,
        OUT     PDRP    pdrp
        )

/*++

Routine Description:

    Parse the command line translating the tokens into values
    placed in the parameter structure. The values are or'd into
    the parameter structure since this routine is called repeatedly
    to build up values (once for the environment variable DIRCMD
    and once for the actual command line).

Arguments:

    pszCmdLine - pointer to command line user typed


Return Value:

    pdrp - parameter data structure

    Return: TRUE  - if valid command line.
            FALSE - if not.

--*/
{

    PTCHAR   pszTok;

    TCHAR           szT[10] ;
    USHORT          irgchTok;
    BOOLEAN         fToggle;
    PPATDSC         ppatdscCur;

    //
    // Tokensize the command line (special delimeters are tokens)
    //
    szT[0] = SwitChar ;
    szT[1] = NULLC ;
    pszTok = TokStr(pszCmdLine, szT, TS_SDTOKENS) ;

    ppatdscCur = &(pdrp->patdscFirst);
    //
    // If there was a pattern put in place from the environment.
    // just add any new patterns on. So move to the end of the
    // current list.
    //
    if (pdrp->cpatdsc) {

        while (ppatdscCur->ppatdscNext) {

            ppatdscCur = ppatdscCur->ppatdscNext;

        }
    }

    //
    // At this state pszTok will be a series of zero terminated strings.
    // "/o foo" wil be /0o0foo0
    //
    for ( irgchTok = 0; *pszTok ; pszTok += mystrlen(pszTok)+1, irgchTok = 0) {

        DEBUG((ICGRP, DILVL, "PRIVSW: pszTok = %ws", (ULONG_PTR)pszTok)) ;

        //
        // fToggle control wither to turn off a switch that was set
        // in the DIRCMD environment variable.
        //
        fToggle = FALSE;
        if (pszTok[irgchTok] == (TCHAR)SwitChar) {

            if (pszTok[irgchTok + 2] == MINUS) {

                //
                // disable the previously enabled the switch
                //
                fToggle = TRUE;
                irgchTok++;
            }

            switch (_totupper(pszTok[irgchTok + 2])) {


            case TEXT('P'):

                fToggle ? (pdrp->rgfSwitches ^= PROMPTUSERSWITCH) : (pdrp->rgfSwitches |= PROMPTUSERSWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;


            case TEXT('S'):

                fToggle ? (pdrp->rgfSwitches ^= RECURSESWITCH) :  (pdrp->rgfSwitches |= RECURSESWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case TEXT('F'):

                fToggle ? (pdrp->rgfSwitches ^= FORCEDELSWITCH) :  (pdrp->rgfSwitches |= FORCEDELSWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;



            case QMARK:

                BeginHelpPause();
                PutStdOut(MSG_HELP_DEL_ERASE, NOARGS);
                EndHelpPause();
                return( FAILURE );
                break;

            case QUIETCH:

                fToggle ? (pdrp->rgfSwitches ^= QUIETSWITCH) :  (pdrp->rgfSwitches |= QUIETSWITCH);
                if (pszTok[irgchTok + 3]) {
                    PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                              (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                    return( FAILURE );
                }
                break;

            case TEXT('A'):

                if (fToggle) {
                    if ( _tcslen( &(pszTok[irgchTok + 2]) ) > 1) {
                        PutStdErr(MSG_PARAMETER_FORMAT_NOT_CORRECT, ONEARG,
                                  (UINT_PTR)(&(pszTok[irgchTok + 2])) );
                        return( FAILURE );
                    }
                    pdrp->rgfAttribs = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN;
                    pdrp->rgfAttribsOnOff = 0;
                    break;
                }

                if (SetAttribs(&(pszTok[irgchTok + 3]), pdrp) ) {
                    return( FAILURE );
                }

                if (pdrp->rgfAttribsOnOff & FILE_ATTRIBUTE_READONLY) {
                    pdrp->rgfSwitches |= FORCEDELSWITCH;
                }
                break;

            default:

                szT[0] = SwitChar;
                szT[1] = pszTok[2];
                szT[2] = NULLC;
                PutStdErr(MSG_INVALID_SWITCH,
                          ONEARG,
                          (UINT_PTR)(&(pszTok[irgchTok + 2])) );

                return( FAILURE );

            } // switch

            //
            // TokStr parses /N as /0N0 so we need to move over the
            // switchar in or to move past the actual switch value
            // in for loop.
            //
            pszTok += 2;

        } else {

            //
            // If there already is a list then extend it else put info
            // directly into structure.
            //
            if (pdrp->cpatdsc) {

                ppatdscCur->ppatdscNext = (PPATDSC)gmkstr(sizeof(PATDSC));
                ppatdscCur = ppatdscCur->ppatdscNext;
                ppatdscCur->ppatdscNext = NULL;

            }

            pdrp->cpatdsc++;
            ppatdscCur->pszPattern = (PTCHAR)gmkstr(_tcslen(pszTok)*sizeof(TCHAR) + sizeof(TCHAR));
            mystrcpy(ppatdscCur->pszPattern, StripQuotes(pszTok));
            ppatdscCur->fIsFat = TRUE;
        }


    } // for

    return( SUCCESS );
}

int
DelWork (
    TCHAR *pszCmdLine
    ) {

    //
    // drp - structure holding current set of parameters. It is initialized
    //       in ParseDelParms function. It is also modified later when
    //       parameters are examined to determine if some turn others on.
    //
    DRP         drpCur = {0, 0, 0, 0,
                          {{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
                          0, 0, NULL, 0, 0, 0, 0} ;

    //
    // szCurDrv - Hold current drive letter
    //
    TCHAR       szCurDrv[MAX_PATH + 2];

    //
    // OldDCount - Holds the level number of the heap. It is used to
    //             free entries off the stack that might not have been
    //             freed due to error processing (ctrl-c etc.)
    ULONG       OldDCount;

    STATUS  rc;

    OldDCount = DCount;

    //
    // Setup defaults
    //
    //
    // Display everything but system and hidden files
    // rgfAttribs set the attribute bits to that are of interest and
    // rgfAttribsOnOff says wither the attributs should be present
    // or not (i.e. On or Off)
    //
    drpCur.rgfAttribs = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN;
    drpCur.rgfAttribsOnOff = 0;

    //
    // Number of patterns present. A pattern is a string that may have
    // wild cards. It is used to match against files present in the directory
    // 0 patterns will show all files (i.e. mapped to *.*)
    //
    drpCur.cpatdsc = 0;

    //
    // default time is LAST_WRITE_TIME.
    //
    drpCur.dwTimeType = LAST_WRITE_TIME;

    //
    //
    //
    if (ParseDelParms(pszCmdLine, &drpCur) == FAILURE) {

        return( FAILURE );
    }

    //
    // Must have some pattern on command line
    //
    //

    GetDir((PTCHAR)szCurDrv, GD_DEFAULT);
    if (drpCur.cpatdsc == 0) {

        PutStdErr(MSG_BAD_SYNTAX, NOARGS);
        return(FAILURE);
    }


    //
    //  Print out this particular pattern. If the recursion switch
    //  is set then this will descend down the tree.
    //

    drpCur.rgfSwitches |= DELPROCESSEARLY;
    rc = DelPatterns( &drpCur );

    mystrcpy(CurDrvDir, szCurDrv);

    //
    // Free unneeded memory
    //

    FreeStack( OldDCount );

    return( (int)rc );

}

STATUS
NewEraseFile (
    IN  PFS CurrentFS,
    IN  PFF CurrentFF,
    IN  PSCREEN pscr,
    IN  PVOID Data
    )
{
    TCHAR               szFile[MAX_PATH + 2];
    STATUS              rc;
    PTCHAR              LastComponent;
    PTCHAR              pszPattern;
    TCHAR               szFilePrompt[MAX_PATH + 2];
    int                 incr;

    PDRP pdrp = (PDRP) Data;
    PWIN32_FIND_DATA pdata =  &CurrentFF->data;
    USHORT obAlternate = CurrentFF->obAlternate;
    BOOLEAN fPrompt = FALSE;
    BOOLEAN fQuiet = FALSE;

    if (pdrp->rgfSwitches & PROMPTUSERSWITCH) {
        fPrompt = TRUE;
    }

    if (pdrp->rgfSwitches & QUIETSWITCH) {
        fQuiet = TRUE;
    }

    //
    //  Global delete prompt
    //

    if (
        //  Not prompting on each file
        !fPrompt &&

        //  Global prompt not issued yet
        !CurrentFS->fDelPrompted &&

        //  not suppressing global prompt
        !fQuiet &&

        //  global pattern in delete
        (pszPattern = GetWildPattern( CurrentFS->cpatdsc, CurrentFS->ppatdsc ))) {

        //
        //  Form complete path for prompt
        //

        if (AppendPath( szFile, MAX_PATH + 2, CurrentFS->pszDir, pszPattern ) != SUCCESS) {
            PutStdErr(MSG_PATH_TOO_LONG, TWOARGS, CurrentFS->pszDir, pszPattern );
            return( FAILURE );
        }

        //
        //  Prompt the user and see if we can continue
        //

        CurrentFS->fDelPrompted = TRUE;
        if (PromptUser( szFile, MSG_ARE_YOU_SURE, MSG_NOYES_RESPONSE_DATA ) != 1) {
            return( FAILURE );
        }
    }

    //
    //  Directories succeed here
    //

    if ((pdata->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {
        return SUCCESS;
    }

    //
    //  Form a short name for the delete operation.  This gives us the best
    //  chance to delete a really long path.
    //

    if (AppendPath( szFile, MAX_PATH + 2, CurrentFS->pszDir, pdata->cFileName + obAlternate) != SUCCESS) {
        PutStdErr(MSG_PATH_TOO_LONG, TWOARGS, CurrentFS->pszDir, pdata->cFileName + obAlternate );
        return( FAILURE );
    }
    
    //
    //  Form a long name for the prompt.  If it's too long, then use the short name for prompt
    //

    if (AppendPath( szFilePrompt, MAX_PATH + 2, CurrentFS->pszDir, pdata->cFileName ) != SUCCESS) {
        _tcscpy( szFilePrompt, szFile );
    }
    
    
    //
    //  Prompt the user for this one file
    //

    if (fPrompt && PromptUser( szFilePrompt, MSG_CMD_DELETE, MSG_NOYES_RESPONSE_DATA ) != 1) {
        if (CtrlCSeen) {
            return( FAILURE );
        }
        return( SUCCESS );
    }

    //
    //  If we are forcibly deleteing everything and this is a read-only file
    //  then turn off R/O.
    //

    if ((pdrp->rgfSwitches & FORCEDELSWITCH) != 0 &&
        pdata->dwFileAttributes & FILE_ATTRIBUTE_READONLY) {

        if (!SetFileAttributes( szFile, pdata->dwFileAttributes & ~FILE_ATTRIBUTE_READONLY )) {
            PutStdErr( GetLastError(), NOARGS );
            return( FAILURE );

        }
    }

    //
    //  Delete the file.  Display error if we got a failure
    //

    if (!DeleteFile( szFile )) {
        rc = GetLastError( );
    } else {
        rc = SUCCESS;
    }

    if (rc != SUCCESS) {
        if (rc == ERROR_REQUEST_ABORTED) {
            return FAILURE;
        }

        cmd_printf( Fmt17, szFilePrompt );
        PutStdErr( rc, NOARGS );

    } else {

        pdrp->FileCount++;

        if (fEnableExtensions && (pdrp->rgfSwitches & RECURSESWITCH)) {
            PutStdOut(MSG_FILE_DELETED, ONEARG, szFilePrompt);
        }

    }

    return SUCCESS;
}


STATUS
DelPatterns (
    IN  PDRP    pdpr
    )
{

    PPATDSC             ppatdscCur;
    PPATDSC             ppatdscX;
    PFS                 pfsFirst;
    PFS                 pfsCur;
    ULONG               i;
    STATUS              rc;
    ULONG               cffTotal = 0;
    TCHAR               szSearchPath[MAX_PATH+2];

    DosErr = 0;
    if (BuildFSFromPatterns(pdpr, TRUE, FALSE, &pfsFirst ) == FAILURE) {

        return( FAILURE );

    }

    for( pfsCur = pfsFirst; pfsCur; pfsCur = pfsCur->pfsNext) {

        rc = WalkTree( pfsCur,
                       NULL,
                       pdpr->rgfAttribs,
                       pdpr->rgfAttribsOnOff,
                       (BOOLEAN)(pdpr->rgfSwitches & RECURSESWITCH),

                       pdpr,
                       NULL,            //  Error
                       NULL,            //  Pre
                       NewEraseFile,    //  Scan
                       NULL );          //  Post

        //
        //  If we had a general failure, just return
        //

        if (rc == FAILURE) {
            return rc;
        }

        //
        //  If we had a failure that we don't understand, print the error and
        //  exit
        //

        if (rc != SUCCESS && rc != ERROR_FILE_NOT_FOUND) {
            PutStdErr( rc, NOARGS );
            return rc;
        }

        //
        //  If we got FILE_NOT_FOUND then build the full name and
        //  display the file not-found message
        //

        if (rc == ERROR_FILE_NOT_FOUND) {
            rc = AppendPath( szSearchPath,
                             sizeof( szSearchPath ),
                             pfsCur->pszDir,
                             pfsCur->ppatdsc->pszPattern );
            if (rc == SUCCESS) {
                PutStdErr( MSG_NOT_FOUND, ONEARG, szSearchPath );
            }
            
            //
            //  We leave the status code alone here.  If we succeeded in
            //  generating the message, then the del command "succeeded"
            //  in that the named file is not there.
            //
        }

        //
        // Have walked down and back up the tree, but in the case of
        // deleting directories we have not deleted the top most directory
        // do so now.
        //

        FreeStr(pfsCur->pszDir);
        for(i = 1, ppatdscCur = pfsCur->ppatdsc;
            i <= pfsCur->cpatdsc;
            i++, ppatdscCur = ppatdscX) {

            ppatdscX = ppatdscCur->ppatdscNext;
            FreeStr(ppatdscCur->pszPattern);
            FreeStr(ppatdscCur->pszDir);
            FreeStr((PTCHAR)ppatdscCur);
        }
    }

    return(rc);
}

STATUS
RemoveDirectoryForce(
    PTCHAR  pszDirectory
    )
/*++

Routine Description:

    Removes a directory, even if it is read-only.

Arguments:

    pszDirectory        - Supplies the name of the directory to delete.

Return Value:

    SUCCESS - Success.
    other   - Windows error code.

--*/
{
    STATUS   Status = SUCCESS;
    BOOL     Ok;
    DWORD    Attr;
    TCHAR    szRootPath[ 4 ];
    TCHAR   *pFilePart;

    if (GetFullPathName(pszDirectory, 4, szRootPath, &pFilePart) == 3 &&
        szRootPath[1] == COLON &&
        szRootPath[2] == BSLASH
       ) {
        //
        // Don't waste time trying to delete the root directory.
        //
        return SUCCESS;
    }

    if ( !RemoveDirectory( pszDirectory ) ) {

        Status = (STATUS)GetLastError();

        if ( Status == ERROR_ACCESS_DENIED ) {

            Attr = GetFileAttributes( pszDirectory );

            if ( Attr != 0xFFFFFFFF &&
                 Attr & FILE_ATTRIBUTE_READONLY ) {

                Attr &= ~FILE_ATTRIBUTE_READONLY;

                if ( SetFileAttributes( pszDirectory, Attr ) ) {

                    if ( RemoveDirectory( pszDirectory ) ) {
                        Status = SUCCESS;
                    } else {
                        Status = GetLastError();
                    }
                }
            }
        }
    }

    return Status;
}


STATUS
RmDirSlashS(
    IN  PTCHAR  pszDirectory,
    OUT PBOOL   AllEntriesDeleted
    )
/*++

Routine Description:

    This routine deletes the given directory including all
    of its files and subdirectories.

Arguments:

    pszDirectory        - Supplies the name of the directory to delete.
    AllEntriesDeleted   - Returns whether or not all files were deleted.

Return Value:

    SUCCESS - Success.
    other   - Windows error code.

--*/
{
    HANDLE          find_handle;
    DWORD           attr;
    STATUS          s;
    BOOL            all_deleted;
    int             dir_len, new_len;
    TCHAR          *new_str;
    WIN32_FIND_DATA find_data;
    TCHAR           pszFileBuffer[MAX_PATH];

    *AllEntriesDeleted = TRUE;

    dir_len = _tcslen(pszDirectory);

    if (dir_len == 0) {
        return ERROR_BAD_PATHNAME;
    }

    //
    //  If this path is so long that we can't append \* to it then
    //  it can't have any subdirectories.
    //

    if (dir_len + 3 > MAX_PATH) {
        return RemoveDirectoryForce(pszDirectory);
    }


    // Compute the findfirst pattern for enumerating the files
    // in the given directory.

    _tcscpy(pszFileBuffer, pszDirectory);
    if (dir_len && pszDirectory[dir_len - 1] != COLON &&
        pszDirectory[dir_len - 1] != BSLASH) {

        _tcscat(pszFileBuffer, TEXT("\\"));
        dir_len++;
    }
    _tcscat(pszFileBuffer, TEXT("*"));


    // Initiate findfirst loop.

    find_handle = FindFirstFile(pszFileBuffer, &find_data);
    if (find_handle == INVALID_HANDLE_VALUE) {
        return RemoveDirectoryForce(pszDirectory);
    }

    do {

        // Check for control-C.

        if (CtrlCSeen) {
            break;
        }

        //
        // Replace previous file name with new one, checking against MAX_PATH
        // Using the short name where possible lets us go deeper before we hit
        // the MAX_PATH limit.
        //
        new_len = _tcslen(new_str = find_data.cAlternateFileName);
        if (!new_len)
            new_len = _tcslen(new_str = find_data.cFileName);

        if (dir_len + new_len >= MAX_PATH) {
            *AllEntriesDeleted = FALSE;
            PutStdErr(MSG_MAX_PATH_EXCEEDED, 1, pszFileBuffer);
            break;
        }
        _tcscpy(&pszFileBuffer[dir_len], new_str);

        attr = find_data.dwFileAttributes;

        //
        //  If the entry is a directory and not a reparse directory descend into it
        //

        if (IsDirectory( attr ) && !IsReparse( attr )) {

            if (!_tcscmp(find_data.cFileName, TEXT(".")) ||
                !_tcscmp(find_data.cFileName, TEXT(".."))) {
                continue;
            }

            s = RmDirSlashS(pszFileBuffer, &all_deleted);

            // Don't report error if control-C

            if (CtrlCSeen) {
                break;
            }

            if (s != ESUCCESS) {
                *AllEntriesDeleted = FALSE;
                if (s != ERROR_DIR_NOT_EMPTY || all_deleted) {
                    PutStdErr(MSG_FILE_NAME_PRECEEDING_ERROR, 1, pszFileBuffer);
                    PutStdErr(GetLastError(), NOARGS);
                }
            }
        } else {

            if (attr&FILE_ATTRIBUTE_READONLY) {
                SetFileAttributes(pszFileBuffer,
                                  attr&(~FILE_ATTRIBUTE_READONLY));
            }

            //
            //  Two ways of removal:
            //      if reparse and dir call RemoveDirectoryForce
            //      else call DeleteFile
            //
            //  If either call fails
            //


            if ( (IsDirectory( attr ) && IsReparse( attr ) && RemoveDirectoryForce( pszFileBuffer ) != SUCCESS) ||
                 (!IsDirectory( attr ) && !DeleteFile( pszFileBuffer ))) {

                s = GetLastError();
                if ( s == ERROR_REQUEST_ABORTED )
                    break;

                if (_tcslen(find_data.cAlternateFileName)) {
                    pszFileBuffer[dir_len] = 0;

                    if (dir_len + _tcslen(find_data.cFileName) >= MAX_PATH) {
                        _tcscat(pszFileBuffer, find_data.cAlternateFileName);
                        PutStdErr(MSG_FILE_NAME_PRECEEDING_ERROR, 1, pszFileBuffer);
                    }
                    else {
                        _tcscat(pszFileBuffer, find_data.cFileName);
                        PutStdErr(MSG_FILE_NAME_PRECEEDING_ERROR, 1, pszFileBuffer);
                        pszFileBuffer[dir_len] = 0;
                        _tcscat(pszFileBuffer, find_data.cAlternateFileName);
                    }
                } else {
                    PutStdErr(MSG_FILE_NAME_PRECEEDING_ERROR, 1, pszFileBuffer);
                }
                PutStdErr(GetLastError(), NOARGS);
                SetFileAttributes(pszFileBuffer, attr);
                *AllEntriesDeleted = FALSE;
            }
        }
    } while (FindNextFile( find_handle, &find_data ));

    FindClose(find_handle);

    // If control-C was hit then don't bother trying to remove the
    // directory.

    if (CtrlCSeen) {
        return SUCCESS;
    }

    return RemoveDirectoryForce(pszDirectory);
}


int
RdWork (
    TCHAR *pszCmdLine
    ) {

    //
    // drp - structure holding current set of parameters. It is initialized
    //       in ParseDelParms function. It is also modified later when
    //       parameters are examined to determine if some turn others on.
    //
    DRP         drpCur = {0, 0, 0, 0,
                          {{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
                          0, 0, NULL, 0, 0, 0, 0} ;

    //
    // szCurDrv - Hold current drive letter
    //
    TCHAR       szCurDrv[MAX_PATH + 2];

    //
    // OldDCount - Holds the level number of the heap. It is used to
    //             free entries off the stack that might not have been
    //             freed due to error processing (ctrl-c etc.)
    ULONG       OldDCount;

    PPATDSC     ppatdscCur;
    ULONG       cpatdsc;
    STATUS      rc, s;
    BOOL        all_deleted;

    rc = SUCCESS;
    OldDCount = DCount;

    //
    // Setup defaults
    //
    //
    // Display everything but system and hidden files
    // rgfAttribs set the attribute bits to that are of interest and
    // rgfAttribsOnOff says wither the attributs should be present
    // or not (i.e. On or Off)
    //
    
    drpCur.rgfAttribs = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN;
    drpCur.rgfAttribsOnOff = 0;

    //
    // Number of patterns present. A pattern is a string that may have
    // wild cards. It is used to match against files present in the directory
    // 0 patterns will show all files (i.e. mapped to *.*)
    //
    drpCur.cpatdsc = 0;

    //
    // default time is LAST_WRITE_TIME.
    //
    drpCur.dwTimeType = LAST_WRITE_TIME;

    //
    //
    //
    if (ParseRmDirParms(pszCmdLine, &drpCur) == FAILURE) {

        return( FAILURE );
    }

    GetDir((PTCHAR)szCurDrv, GD_DEFAULT);

    //
    // If no patterns on the command line then syntax error out
    //

    if (drpCur.cpatdsc == 0) {

        PutStdErr(MSG_BAD_SYNTAX, NOARGS);
        return( FAILURE );

    }

    for (ppatdscCur = &(drpCur.patdscFirst),cpatdsc = drpCur.cpatdsc;
        cpatdsc;
        ppatdscCur = ppatdscCur->ppatdscNext, cpatdsc--) {

        if (mystrlen( ppatdscCur->pszPattern ) == 0) {
            PutStdErr( MSG_BAD_SYNTAX, NOARGS );
            return rc = FAILURE;
        }
    }
    
    for (ppatdscCur = &(drpCur.patdscFirst),cpatdsc = drpCur.cpatdsc;
        cpatdsc;
        ppatdscCur = ppatdscCur->ppatdscNext, cpatdsc--) {

        if (drpCur.rgfSwitches & RECURSESWITCH) {
            if (!(drpCur.rgfSwitches & QUIETSWITCH) &&
                PromptUser(ppatdscCur->pszPattern, MSG_ARE_YOU_SURE, MSG_NOYES_RESPONSE_DATA) != 1
               ) {
                rc = FAILURE;
            } else {
                s = RmDirSlashS(ppatdscCur->pszPattern, &all_deleted);
                if (s != SUCCESS && (s != ERROR_DIR_NOT_EMPTY || all_deleted)) {
                    PutStdErr(rc = s, NOARGS);
                }
            }
        } else {
            if (!RemoveDirectory(ppatdscCur->pszPattern)) {
                PutStdErr(rc = GetLastError(), NOARGS);
            }
        }
    }
    mystrcpy(CurDrvDir, szCurDrv);

    //
    // Free unneeded memory
    //
    FreeStack( OldDCount );

#ifdef _CRTHEAP_
    //
    // Force the crt to release heap we may have taken on recursion
    //
    if (drpCur.rgfSwitches & RECURSESWITCH) {
        _heapmin();
    }
#endif

    return( (int)rc );

}

PTCHAR
GetWildPattern(

    IN  ULONG   cpatdsc,
    IN  PPATDSC ppatdsc
    )

/*

    return pointer to a pattern if it contains only a wild card

*/

{

    ULONG   i;
    PTCHAR  pszT;

    for(i = 1; i <= cpatdsc; i++, ppatdsc = ppatdsc->ppatdscNext) {

        pszT = ppatdsc->pszPattern;
        if (!_tcscmp(pszT, TEXT("*")) ||
            !_tcscmp(pszT, TEXT("*.*")) ||
            !_tcscmp(pszT, TEXT("????????.???")) ) {

                return( pszT );

        }

    }

    return( NULL );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\ffirst.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    ffirst.c

Abstract:

    Wrappers for file enumeration

--*/

#include "cmd.h"

PHANDLE FFhandles = NULL;
unsigned FFhndlsaved = 0;
extern unsigned DosErr ;

BOOLEAN FindFirstNt( PTCHAR, PWIN32_FIND_DATA, PHANDLE );
BOOLEAN FindNextNt ( PWIN32_FIND_DATA, HANDLE );

BOOLEAN FindFirst(
        BOOL(* fctAttribMatch) (PWIN32_FIND_DATA pffBuf, ULONG attr),
        PTCHAR           fspec,
        ULONG            attr,
        PWIN32_FIND_DATA pffBuf,
        PHANDLE          phandle );

BOOLEAN FindNext (
        BOOL(* fctAttribMatch) (PWIN32_FIND_DATA pffBuf, ULONG attr),
        PWIN32_FIND_DATA pffBuf,
        ULONG            attr,
        HANDLE           handle
        );

BOOL    IsDosAttribMatch( PWIN32_FIND_DATA, ULONG );
BOOL    IsNtAttribMatch( PWIN32_FIND_DATA, ULONG );
int     findclose( HANDLE );

//
//  Under OS/2, we always return entries that are normal, archived or
//  read-only (god knows why).
//
//  SRCHATTR contains those attribute bits that are used for matching.
//
#define SRCHATTR    (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY)

/***    IsDosAttribMatch - Simulates the attribute matching from OS/2
 *
 *  Purpose:
 *      This function determines if the passed in find file buffer has a
 *      match under the OS/2 find file rules.
 *
 *  Args:
 *              ffbuf:  Buffer returned from FileFirst or Findnext
 *              attr:   Attributes to qualify search
 *
 *  Returns:
 *              TRUE:   if buffer has a attribute match
 *              FALSE:  if not
 */

BOOL
IsDosAttribMatch(
    IN  PWIN32_FIND_DATA    pffBuf,
    IN  ULONG               attr
        ) {

    //
    //  We emulate the OS/2 behaviour of attribute matching. The semantics
    //  are evil, so I provide no explanation.
    //
    pffBuf->dwFileAttributes &= (0x000000FF & ~(FILE_ATTRIBUTE_NORMAL));

    if (! ((pffBuf->dwFileAttributes & SRCHATTR) & ~(attr))) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
IsNtAttribMatch(
        PWIN32_FIND_DATA    pffBuf,
        ULONG               attr
        ) {

    UNREFERENCED_PARAMETER( pffBuf );
    UNREFERENCED_PARAMETER( attr );
    //
    // for nt calls always return entry. selection should
    // should be based upon callers needs. This is primarily used
    // in DIR.
    return( TRUE );
}

/***    f_how_many - find how many files are there per fspec with given attr
 *
 *  Args:
 *              fspec:  String pointer to file specification.
 *              attr:   Attributes to qualify search
 *
 *  Returns:
 *              number of files found or -1 if a file is a directory.
 */

int
f_how_many(
        PTCHAR           fspec,
        ULONG            attr
    ) {

    WIN32_FIND_DATA    ffBuf;
    PWIN32_FIND_DATA   pffBuf;
    PHANDLE            phandle;
    HANDLE             hnFirst ;
    unsigned           rc;
    int                cnt=0;

    pffBuf = &ffBuf;


    if ( ! ffirst (fspec, attr, pffBuf, &hnFirst ))  {

       if ( ! ffirst (fspec, FILE_ATTRIBUTE_DIRECTORY, pffBuf, &hnFirst ))  {
           return (0);
       }
       else {
           findclose(hnFirst);
           return (f_RET_DIR);
       }
    }


    do  {
        cnt++;
    } while ( fnext (pffBuf, attr, hnFirst ));


    findclose(hnFirst) ;

    return (cnt);

}



/***    ffirst - find first file/directory and set up find handles
 *
 *  Purpose:
 *      This function opens a find first handle. I also returns the first
 *      qualified file/directory. It simulates the DosFindFirst behavior.
 *
 *  Args:
 *              fspec:  String pointer to file specification.
 *              attr:   Attributes to qualify search
 *              ffbuf:  Buffer to hold inforation on found file/directory
 *              handle: Find first handle
 *
 *  Returns:
 *              TRUE:   If match found
 *              FALSE:  if not
 *              DosErr: Contains return code if FALSE function return
 */

BOOLEAN
FindFirst(
    IN  BOOL(* fctAttribMatch) (PWIN32_FIND_DATA pffBuf, ULONG attr),
    IN  PTCHAR           fspec,
    IN  ULONG            attr,
    IN  PWIN32_FIND_DATA pffBuf,
    OUT PHANDLE phandle
        ) {

    BOOLEAN rcode = FALSE;

    //
    // Loop through looking for a file that matching attributes
    //
    *phandle = FindFirstFile(fspec, pffBuf);
    while (*phandle != (HANDLE)     -1) {
        if (fctAttribMatch(pffBuf, attr)) {
            DosErr = 0;
            rcode = TRUE;
            break;
        }

        if (!FindNextFile( *phandle, pffBuf )) {
            FindClose( *phandle );
            *phandle = (HANDLE)-1;
            break;
        }
    }

    //
    // If we did find a file (have a handle to prove it) then
    // setup a table of saved open find first handles. If we have
    // to clean up then these handle can all be closed.
    //
    if (*phandle != (HANDLE)-1) {

        //
        // Check if we already created the table. If we have not
        // then allocate space for table.
        //
        if (FFhandles == NULL) {

            FFhandles = (PHANDLE)HeapAlloc(GetProcessHeap(), 0, 5 * sizeof(PHANDLE));

        } else {

            //
            // Check if we have space to hold new handle entry
            //
            if (((FFhndlsaved + 1)* sizeof(PHANDLE)) > HeapSize(GetProcessHeap(), 0, FFhandles)) {
                FFhandles = (PHANDLE)HeapReAlloc(GetProcessHeap(), 0, (void*)FFhandles, (FFhndlsaved+1)*sizeof(PHANDLE));
            }
         }
        if (FFhandles != NULL) {
            FFhandles[FFhndlsaved++] = *phandle;
        }

    rcode = TRUE;
    }

    if (!rcode) {
        DosErr = GetLastError();
    }
    return(rcode);
}


BOOLEAN
FindFirstNt(
    IN  PTCHAR           fspec,
    IN  PWIN32_FIND_DATA pffBuf,
    OUT PHANDLE phandle
        )
{

    return(FindFirst(IsNtAttribMatch, fspec, 0, pffBuf, phandle));

}
BOOLEAN
ffirst(
        PTCHAR           fspec,
        ULONG            attr,
        PWIN32_FIND_DATA pffBuf,
        PHANDLE phandle
        )
{

    return(FindFirst(IsDosAttribMatch, fspec, attr, pffBuf, phandle));

}


/***    fnext - find next file/directory
 *
 *  Purpose:
 *      This function search for the next qualified file or directory.
 *      ffirst should have been called first and the returned file handle
 *      should be passed into fnext.

 *  Args:
 *              handle: Find first handle
 *              attr:   Attributes to qualify search
 *              ffbuf:  Buffer to hold information on found file/directory
 *
 *  Returns:
 *              TRUE:   If match found
 *              FALSE:  if not
 *              DosErr: Contains return code if FALSE function return
 */

BOOLEAN
FindNextNt (
    IN  PWIN32_FIND_DATA pffBuf,
    IN  HANDLE           handle
        ) {

    //
    // attributes are ignored for this kind of call
    //
    return( FindNext( IsNtAttribMatch, pffBuf, 0, handle) );
}

BOOLEAN
fnext (
    IN  PWIN32_FIND_DATA pffBuf,
    IN  ULONG            attr,
    IN  HANDLE           handle
        ) {

    return( FindNext( IsDosAttribMatch, pffBuf, attr, handle) );
}

BOOLEAN
FindNext (
    IN  BOOL(* fctAttribMatch) (PWIN32_FIND_DATA pffBuf, ULONG attr),
    IN  PWIN32_FIND_DATA pffBuf,
    IN  ULONG            attr,
    IN  HANDLE           handle
        ) {

    //
    // Loop through looking for a file that matching attributes
    //
    while (FindNextFile( handle, pffBuf )) {
        if (fctAttribMatch( pffBuf, attr )) {
            DosErr = 0;
            return(TRUE);
            }
        }

    DosErr = GetLastError();
    return(FALSE);
}

int findclose(hn)
HANDLE hn;
{

    unsigned cnt;
    unsigned cnt2;

    DEBUG((CTGRP, COLVL, "findclose: handle %lx",hn)) ;
    // Locate handle in table
    //
    for (cnt = 0; (cnt < FFhndlsaved) && FFhandles[cnt] != hn ; cnt++ ) {
       ;
    }

    //
    // Remove handle from table
    //
    DEBUG((CTGRP, COLVL, "\t found handle in table at %d",cnt)) ;
    if (cnt < FFhndlsaved) {
        for (cnt2 = cnt; cnt2 < (FFhndlsaved - 1) ; cnt2++) {
            FFhandles[cnt2] = FFhandles[cnt2 + 1];
        }
        FFhndlsaved--;
        //
        // Shrink memory
        //
        
        if (HeapSize(GetProcessHeap(), 0, FFhandles) > 5*sizeof(PHANDLE)) {
            FFhandles = (PHANDLE)HeapReAlloc(GetProcessHeap(), 0, (void*)FFhandles,FFhndlsaved*sizeof(PHANDLE));
        }
    }

    //
    // Close even if we couldn't find it in table
    //
    DEBUG((CTGRP, COLVL, "\t closing handle %lx ",hn)) ;
    if (FindClose(hn))      /* Close even if we couldn't find it in table */
        return(0);
    else
        DEBUG((CTGRP, COLVL, "\t Error closing handle %lx ",hn)) ;
    return(GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\ctools2.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    ctools2.c

Abstract:

    Low level utilities

--*/

#include "cmd.h"
#pragma hdrstop

#include "ctable.h"

#define MSG_USE_DEFAULT -1                                      /* M031    */

struct envdata CmdEnv ; /* Holds info need to manipulate Cmd's environment */

extern TCHAR PathChar ;
extern TCHAR CurDrvDir[] ;

#define DAYLENGTH 3

extern TCHAR Delimiters[] ;
extern TCHAR SwitChar ;

extern int Ctrlc;
//
// flag if control-c was seen
//
extern BOOL CtrlCSeen;

extern int ExtCtrlc;    /* @@4 */
extern TCHAR Fmt19[];
extern unsigned flgwd ;
unsigned int DosErr = 0 ;

unsigned long OHTbl[3] = {0,0,0} ;
extern  BOOLEAN fPrintCtrlC;

unsigned int cbTitleCurPrefix;
extern BOOLEAN  fTitleChanged;

extern TCHAR ShortMondayName[];
extern TCHAR ShortTuesdayName[];
extern TCHAR ShortWednesdayName[];
extern TCHAR ShortThursdayName[];
extern TCHAR ShortFridayName[];
extern TCHAR ShortSaturdayName[];
extern TCHAR ShortSundayName[];


//
// Used to set and reset ctlcseen flag
//
VOID    SetCtrlC();
VOID    ResetCtrlC();

//
// console mode at program startup time. Used to reset mode
// after running another process.
//
extern  DWORD   dwCurInputConMode;
extern  DWORD   dwCurOutputConMode;

unsigned msglen;                /* @@@@@@@@@@@@@@ */

struct msentry {                                                /* M027    */
    unsigned errnum ;
    unsigned msnum ;
} ;

struct msentry mstabl[] = {
    {(unsigned)ERROR_INVALID_FUNCTION, (unsigned)MSG_USE_DEFAULT},             /* 1    */
    {ERROR_FILE_NOT_FOUND, ERROR_FILE_NOT_FOUND},          /* 2    */
    {ERROR_PATH_NOT_FOUND, ERROR_PATH_NOT_FOUND},          /* 3    */
    {ERROR_TOO_MANY_OPEN_FILES, ERROR_TOO_MANY_OPEN_FILES},        /* 4    */
    {ERROR_ACCESS_DENIED, ERROR_ACCESS_DENIED},            /* 5    */
    {ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE},          /* 6    */
    {ERROR_NOT_ENOUGH_MEMORY, ERROR_NOT_ENOUGH_MEMORY},            /* 8    */
    {(unsigned)ERROR_INVALID_ACCESS, (unsigned)MSG_USE_DEFAULT},               /* 12   */
    {ERROR_NO_MORE_FILES, ERROR_FILE_NOT_FOUND},           /* 18   */
    {ERROR_SECTOR_NOT_FOUND, ERROR_SECTOR_NOT_FOUND},      /* 27   */
    {ERROR_SHARING_VIOLATION, ERROR_SHARING_VIOLATION},    /* 32   */
    {ERROR_LOCK_VIOLATION, ERROR_LOCK_VIOLATION},          /* 33   */
    {ERROR_FILE_EXISTS, ERROR_FILE_EXISTS},                        /* 80   */
    {ERROR_CANNOT_MAKE, ERROR_CANNOT_MAKE},                        /* 82   */
    {(unsigned)ERROR_INVALID_PARAMETER, (unsigned)MSG_USE_DEFAULT},            /* 87   */
    {ERROR_OPEN_FAILED, ERROR_OPEN_FAILED},                /* 110  */
    {ERROR_DISK_FULL, ERROR_DISK_FULL},                    /* 112  */
    {0,0}                                   /* End of Table */
} ;

/***    OnOffCheck - check an argument string for "ON" or "OFF"
 *
 *  Purpose:
 *      To check str for the word "ON" or the word "OFF".  If flag is nonzero,
 *      an error message will be printed if str contains anything other than
 *      just "ON", "OFF", or an empty string.
 *
 *  int OnOffCheck(TCHAR *str, int flag)
 *
 *  Args:
 *      str - the string to check
 *      flag - nonzero if error checking is to be done
 *
 *  Returns:
 *      OOC_EMPTY if str was empty.
 *      OOC_ON if just "ON" was found.
 *      OOC_OFF if just "OFF" was found.
 *      OOC_OTHER if anything else was found.
 *
 */

int OnOffCheck( TCHAR *str, int flag )
{
    TCHAR *tas ;                /* Tokenized arg string */
    int retval = OOC_OTHER ;   /* Return value          */
    TCHAR SavedChar;

    if (str == NULL) {
        return OOC_EMPTY;
    }

    //
    // Ignore leading spaces
    //

    tas = str = SkipWhiteSpace( str );

    if (*tas == NULLC) {
        return OOC_EMPTY;
    }

    //
    // Find end of first non-blank token
    //

    while (*tas && !_istspace(*tas))
        tas += 1;


    //
    //  If there's another token beyond the first token
    //  then we can't have ON/OFF
    //

    if (*SkipWhiteSpace( tas ) != NULLC) {
        return retval;
    }

    SavedChar = *tas;
    *tas = NULLC;

    if (_tcsicmp( str, TEXT( "on" )) == 0)              /* M015 */
        retval = OOC_ON ;
    else if (_tcsicmp(str,TEXT( "off" )) == 0)        /* M015 */
        retval = OOC_OFF ;
    *tas = SavedChar;

    if (retval == OOC_OTHER && flag == OOC_ERROR)
        PutStdErr(MSG_BAD_PARM1, NOARGS);

    return(retval) ;
}




/***    ChangeDrive - change Command's current drive
 *
 *  Purpose:
 *      To change Command's default drive.
 *
 *  ChangeDrive(int drvnum)
 *
 *  Args:
 *      drvnum - the drive number to change to (M010 - 1 == A, etc.)
 *
 */

void ChangeDrive(drvnum)
int drvnum ;
{
    TCHAR    denvname[ 4 ];
    TCHAR    denvvalue[ MAX_PATH ];
    TCHAR    *s;
    BOOLEAN fSet;
    UINT    OldErrorMode;

    denvname[ 0 ] = EQ;
    denvname[ 1 ] = (TEXT('A') + (drvnum-1));
    denvname[ 2 ] = COLON;
    denvname[ 3 ] = NULLC;

    fSet = FALSE;
    s = NULL;
    if (s = GetEnvVar( denvname )) {

        fSet = (BOOLEAN)SetCurrentDirectory( s );

    }

    //
    // if the drive was not at current position then
    // reset. If it was a mapped drive then it may have
    // been disconnected and then reconnected and so
    // we should reset to root.
    //
    if (!fSet) {

        //
        // In the case where the drive letter was not in the environment
        // ans so did not do the first SetCurrentDirectory then do not
        // turn off error pop-up
        //
        if (s != NULL) {
            OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );
        }
        denvvalue[ 0 ] = denvname[ 1 ];
        denvvalue[ 1 ] = denvname[ 2 ];
        denvvalue[ 2 ] = PathChar;
        denvvalue[ 3 ] = NULLC;
        SetEnvVar(denvname,denvvalue,&CmdEnv);
        if (!SetCurrentDirectory( denvvalue )) {
            //
            // Could not set the drive at all give an error
            //

            PutStdErr( GetLastError( ), NOARGS );
        }
        if (s != NULL) {
            SetErrorMode( OldErrorMode );
        }
    }

    GetDir(CurDrvDir, GD_DEFAULT) ;
}



/***    PutStdOut - Print a message to STDOUT
 *
 *  Purpose:
 *      Calls PutMsg sending STDOUT as the handle to which the message
 *      will be written.
 *
 *  int PutStdOut(unsigned MsgNum, unsigned NumOfArgs, ...)
 *
 *  Args:
 *      MsgNum          - the number of the message to print
 *      NumOfArgs       - the number of total arguments
 *      ...             - the additional arguments for the message
 *
 *  Returns:
 *      Return value from PutMsg()              M026
 *
 */

PutStdOut(unsigned int MsgNum, unsigned int NumOfArgs, ...)
{
    int Result;

    va_list arglist;

    va_start(arglist, NumOfArgs);
    Result = PutMsg(MsgNum, STDOUT, NumOfArgs, &arglist);
    va_end(arglist);
    return Result;
}




/***    PutStdErr - Print a message to STDERR
 *
 *  Purpose:
 *      Calls PutMsg sending STDERR as the handle to which the message
 *      will be written.
 *
 *  int PutStdErr(unsigned MsgNum, unsigned NumOfArgs, ...)
 *
 *  Args:
 *      MsgNum          - the number of the message to print
 *      NumOfArgs       - the number of total arguments
 *      ...             - the additonal arguments for the message
 *
 *  Returns:
 *      Return value from PutMsg()                      M026
 *
 */

int
PutStdErr(unsigned int MsgNum, unsigned int NumOfArgs, ...)
{
    int Result;

    va_list arglist;

    va_start(arglist, NumOfArgs);
    Result = PutMsg(MsgNum, STDERR, NumOfArgs, &arglist);
    va_end(arglist);
    return Result;
}


int
FindMsg(unsigned MsgNum, PTCHAR NullArg, unsigned NumOfArgs, va_list *arglist)
{
    unsigned msglen;
    TCHAR *Inserts[ 2 ];
    CHAR numbuf[ 32 ];
#ifdef UNICODE
    TCHAR   wnumbuf[ 32 ];
#endif
#if DBG
    int error;
#endif

    //
    // find message without doing argument substitution
    //

    if (MsgNum == ERROR_MR_MID_NOT_FOUND) {
        msglen = 0;
    } else {
        msglen = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE 
                                | FORMAT_MESSAGE_FROM_SYSTEM 
                                | FORMAT_MESSAGE_IGNORE_INSERTS,
                                NULL,
                                MsgNum,
                                0,
                                MsgBuf,
                                sizeof(MsgBuf) / sizeof(TCHAR),
                                NULL
                               );
    }

    if (msglen == 0) {
#if DBG
        error = GetLastError();
        DEBUG((CTGRP, COLVL, "FindMsg: FormatMessage #2 error %d",error)) ;
#endif
        //
        // didn't find message
        //
        
        _ultoa( MsgNum, numbuf, 16 );
#ifdef UNICODE
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, numbuf, -1, wnumbuf, 32);
        Inserts[ 0 ]= wnumbuf;
#else
        Inserts[ 0 ]= numbuf;
#endif
        Inserts[ 1 ]= (MsgNum >= MSG_FIRST_CMD_MSG_ID ?
                       TEXT("Application") : TEXT("System"));
        MsgNum = ERROR_MR_MID_NOT_FOUND;
        msglen = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM 
                                | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                NULL,
                                MsgNum,
                                0,
                                MsgBuf,
                                sizeof(MsgBuf) / sizeof(TCHAR),
                                (va_list *)Inserts
                               );
#if DBG
        if (msglen == 0) {
            error = GetLastError();
            DEBUG((CTGRP, COLVL, "FindMsg: FormatMessage #3 error %d",error)) ;
        }
#endif
    } else {

        // see how many arguments are expected and make sure we have enough

        PTCHAR tmp;
        ULONG count;

        tmp=MsgBuf;
        count = 0;
        while (tmp = mystrchr(tmp, PERCENT)) {
            tmp++;
            if (*tmp >= TEXT('1') && *tmp <= TEXT('9')) {
                count += 1;
            } else if (*tmp == PERCENT) {
                tmp++;
            }
        }
        if (count > NumOfArgs) {
            PTCHAR *LocalArgList;
            ULONG i;

            LocalArgList = (PTCHAR*)HeapAlloc(GetProcessHeap(), 0, sizeof(PTCHAR) * count);
            if (LocalArgList == NULL) {
                return 0;
            }
            for (i=0; i<count; i++) {
                if (i < NumOfArgs) {
                    LocalArgList[i] = (PTCHAR)va_arg( *arglist, UINT_PTR );
                } else {
                    LocalArgList[i] = NullArg;
                }
            }
            msglen = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE 
                                    | FORMAT_MESSAGE_FROM_SYSTEM 
                                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                    NULL,
                                    MsgNum,
                                    0,
                                    MsgBuf,
                                    sizeof(MsgBuf) / sizeof(TCHAR),
                                    (va_list *)LocalArgList
                                   );
            HeapFree(GetProcessHeap(), 0, LocalArgList);
        } else {
            msglen = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE 
                                    | FORMAT_MESSAGE_FROM_SYSTEM ,
                                    NULL,
                                    MsgNum,
                                    0,
                                    MsgBuf,
                                    sizeof(MsgBuf) / sizeof(TCHAR),
                                    arglist
                                   );
        }
#if DBG
        if (msglen == 0) {
            error = GetLastError();
            DEBUG((CTGRP, COLVL, "FindMsg: FormatMessage error %d",error)) ;
        }
#endif
    }
    return msglen;
}


BOOLEAN fHelpPauseEnabled;
DWORD crowCur;
PTCHAR PauseMsg;
DWORD PauseMsgLen;


void
BeginHelpPause( void )
{
    fHelpPauseEnabled = TRUE;
    crowCur = 0;
    PauseMsgLen = FindMsg(MSG_STRIKE_ANY_KEY, TEXT(" "), NOARGS, NULL);
    PauseMsg = gmkstr((PauseMsgLen+2) * sizeof(TCHAR));
    _tcscpy(PauseMsg, MsgBuf);
    _tcscat(PauseMsg, TEXT("\r"));
    return;
}

void
EndHelpPause( void )
{
    fHelpPauseEnabled = FALSE;
    crowCur = 0;
    return;
}


/***    PutMsg - Print a message to a handle
 *
 *   Purpose:
 *      PutMsg is the work routine which interfaces command.com with the
 *      DOS message retriever.  This routine is called by PutStdOut and
 *      PutStdErr.
 *
 *  int PutMsg(unsigned MsgNum, unsigned Handle, unsigned NumOfArgs, ...)
 *
 *  Args:
 *      MsgNum          - the number of the message to print
 *      NumOfArgs       - the number of total arguments
 *      Handle          - the handle to print to
 *      Arg1 [Arg2...]  - the additonal arguments for the message
 *
 *  Returns:
 *      Return value from DOSPUTMESSAGE                 M026
 *
 *  Notes:
 *    - PutMsg builds an argument table which is passed to DOSGETMESSAGE;
 *      this table contains the variable information which the DOS routine
 *      inserts into the message.
 *    - If more than one Arg is sent into PutMsg, it (or they)  are taken
 *      from the stack in the first for loop.
 *    - M020 MsgBuf is a static array of 2K length.  It is temporary and
 *      will be replaced by a more efficient method when decided upon.
 *
 */

DWORD GetCursorDiff(CONSOLE_SCREEN_BUFFER_INFO* ConInfo, CONSOLE_SCREEN_BUFFER_INFO* ConCurrentInfo)
{
    return(DWORD)ConCurrentInfo->dwSize.X * ConCurrentInfo->dwCursorPosition.Y + ConCurrentInfo->dwCursorPosition.X -
    (DWORD)ConInfo->dwSize.X * ConInfo->dwCursorPosition.Y + ConInfo->dwCursorPosition.X;
}

int
PutMsg(unsigned int MsgNum, CRTHANDLE Handle, unsigned int NumOfArgs, va_list *arglist)
{
    unsigned msglen,writelen;
    unsigned rc;
    TCHAR c;
    PTCHAR   msgptr, s, sEnd;
    PTCHAR   NullArg = TEXT(" ");
    DWORD    cb;
    HANDLE   hConsole;
    CONSOLE_SCREEN_BUFFER_INFO ConInfo;
    DWORD crowMax, dwMode;

    if (FileIsConsole(Handle)) {
        hConsole = CRTTONT(Handle);
        if (!GetConsoleScreenBufferInfo(hConsole, &ConInfo)) {
            hConsole = NULL;
        } else {
            crowMax = ConInfo.srWindow.Bottom - ConInfo.srWindow.Top - 1;
        }
    } else {
        hConsole = NULL;
    }

    rc = 0;                                            /* live with */
    msglen = FindMsg(MsgNum,NullArg,NumOfArgs,arglist);

    msgptr   = MsgBuf;
    writelen = msglen;
    for (msgptr=MsgBuf ; msglen!=0 ; msgptr+=writelen,msglen-=writelen) {
        if (hConsole != NULL) {
            if (fHelpPauseEnabled) {
                if (crowCur >= crowMax) {
                    crowCur = 0;
                    if (GetConsoleScreenBufferInfo(hConsole, &ConInfo)) {
                        if (WriteConsole(hConsole, PauseMsg, PauseMsgLen, &rc, NULL)) {
                            CONSOLE_SCREEN_BUFFER_INFO ConCurrentInfo;

                            FlushConsoleInputBuffer( GetStdHandle(STD_INPUT_HANDLE) );
                            GetConsoleMode(hConsole, &dwMode);
                            SetConsoleMode(hConsole, 0);
                            c = (TCHAR)_getch();
                            SetConsoleMode(hConsole, dwMode);

                            GetConsoleScreenBufferInfo(hConsole, &ConCurrentInfo);
                            //
                            // Clear the pause message
                            //
                            FillConsoleOutputCharacter(hConsole,
                                                       TEXT(' '),
                                                       GetCursorDiff(&ConInfo, &ConCurrentInfo),
                                                       ConInfo.dwCursorPosition,
                                                       &rc
                                                      );
                            SetConsoleCursorPosition(hConsole, ConInfo.dwCursorPosition);
                            if (c == 0x3) {
                                SetCtrlC();
                                return NO_ERROR;
                            }
                        }
                    }
                }

                s = msgptr;
                sEnd = s + msglen;
                while (s < sEnd && crowCur < crowMax) {
                    if (*s++ == TEXT('\n'))
                        crowCur += 1;
                }

                writelen = (UINT)(s - msgptr);
            } else {
                //
                // write a maximum of MAXTOWRITE chars at a time so ctrl-s works
                //
                writelen = min(MAXTOWRITE,msglen);
            }

            if (!WriteConsole(hConsole, msgptr, writelen, &rc, NULL)) {
                rc = GetLastError();
            } else {
                rc = 0;
                continue;
            }
        } else
            if (MyWriteFile(Handle, msgptr, writelen*sizeof(TCHAR), &cb) == 0 ||
                cb != writelen*sizeof(TCHAR)
               ) {
            rc = GetLastError();
            break;
        } else {
            rc = 0;
        }
    }

    //
    //  If the writefile failed, we need to see what else is at work here.  If
    //  we're trying to write to stderr and we can't, we simply exit.  After all, 
    //  we can't even put out a message saying why we failed.
    //
    
    if ( rc && Handle == STDERR ) {
        CMDexit( FAILURE );
    }

    return rc;
}


/***    argstr1 - Create formatted message in memory
 *
 *  Purpose:
 *      Uses sprintf to create a formatted text string in memory to
 *      use in message output.
 *
 *  TCHAR *argstr1(TCHAR *format, UINT_PTR arg)
 *
 *  Args:
 *      Format  - the format string
 *      arg     - the arguments for the message
 *
 *  Returns:
 *      Pointer to the formatted message text
 *
 */

PTCHAR argstr1(format, arg)
TCHAR *format;
ULONG_PTR arg;
{
    static TCHAR ArgStr1Buffer[MAX_PATH];

    _sntprintf( ArgStr1Buffer, MAX_PATH, format, arg );
    return ArgStr1Buffer;
}


/***    Copen - CMD.EXE open function (M014)
 *
 *  Purpose:
 *      Opens a file or device and saves the handle for possible later
 *      signal cleanup.
 *
 *  int Copen(TCHAR *fn, int flags)
 *
 *  Args:
 *      fn = ASCIZ filename to open
 *      flags = Flags controlling type of open to make
 *      fShareMode  = Flags for callers sharing mode
 *
 *  Returns:
 *      Return value from C runtime open
 *
 *  Notes:
 *      Signal cleanup table does not include STDIN, STDOUT or STDERR.
 *      M017 - Extensively rewritten to use CreateFile rather than
 *      runtime open().
 *
 */

CRTHANDLE
Copen_Work(fn, flags, fShareMode)
TCHAR *fn ;
unsigned int flags, fShareMode;
{
    TCHAR c;
    DWORD fAccess;
    DWORD fCreate;
    HANDLE handle ;
    DWORD cb;
    LONG  high;
    CRTHANDLE fh;
    SECURITY_ATTRIBUTES sa;

    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);

/*  Note that O_RDONLY being a value of 0, cannot be tested for
 *  conflicts with any of the write type flags.
 */
    if (((flags & (O_WRONLY | O_RDWR)) > 2) ||      /* Flags invalid?  */
        ((flags & O_WRONLY) && (flags & O_APPEND))) {

        DEBUG((CTGRP, COLVL, "COPEN: Bad flags issued %04x",flags)) ;

        return(BADHANDLE) ;
    };

/*  M024 - Altered so that the only sharing restriction is to deny
 *  others write permission if this open is for writing.  Any other
 *  sharing is allowed.
 */
    if (flags & (O_WRONLY | O_RDWR)) {       /* If Writing, set...      */
        fAccess = GENERIC_WRITE;

        /*
         * deny write only if it is not console
         */

        if (_tcsicmp(fn, TEXT("con"))) {
            fShareMode = FILE_SHARE_READ;
        }

        fCreate = CREATE_ALWAYS;/* ...open if exists, else create  */
    } else {
        fAccess = GENERIC_READ;
        fCreate = OPEN_EXISTING;
    }
    if (flags == OP_APPEN) {

        //
        //  When opening for append to a device, we must specify OPEN_EXISTING 
        //  (according to MSDN docs).
        //
        //  If this fails, due to some error, attempt to open with OPEN_ALWAYS
        //  
        if ((handle = CreateFile(fn,     fAccess|GENERIC_READ, fShareMode, &sa, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
            if ((handle = CreateFile(fn, fAccess,              fShareMode, &sa, OPEN_ALWAYS,   FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
                DosErr = GetLastError();

                DEBUG((CTGRP,COLVL, "COPEN: CreateFile ret'd %d",DosErr)) ;

                if ( DosErr == ERROR_OPEN_FAILED ) {
                    DosErr = ERROR_FILE_NOT_FOUND;
                } /* endif */

                return(BADHANDLE) ;
            }
        }
    } else if ((handle = CreateFile(fn, fAccess, fShareMode, &sa, fCreate, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
        DosErr = GetLastError();

        DEBUG((CTGRP,COLVL, "COPEN: CreateFile ret'd %d",DosErr)) ;

        if ( DosErr == ERROR_OPEN_FAILED ) {
            DosErr = ERROR_FILE_NOT_FOUND;
        } /* endif */

        return(BADHANDLE) ;
    }

    fh = _open_osfhandle((LONG_PTR)handle, _O_APPEND);
    if ((flags & O_APPEND) &&
        !FileIsDevice(fh) &&
        GetFileSize(handle,NULL) != 0) {
        c = NULLC ;
        high = -1;
        fCreate = SetFilePointer(handle, -1L, &high, FILE_END) ;
        if (fCreate == 0xffffffff &&
            (DosErr = GetLastError()) != NO_ERROR) {
            DEBUG((CTGRP,COLVL,"COPEN: SetFilePointer error %d",DosErr)) ;

            // should close CRT handle, not OS handle
            if (fh != BADHANDLE) {
                _close(fh);
            }
            return BADHANDLE;
        }
        fCreate = ReadFile(handle, &c, 1, &cb, NULL) ;
        if (fCreate == 0) {
            high = 0;
            SetFilePointer(handle, 0L, &high, FILE_END) ; /* ...back up 1 */
            DEBUG((CTGRP,COLVL,"COPEN: ReadFile error %d",GetLastError())) ;
        }

        DEBUG((CTGRP,COLVL, "COPEN: Moving file ptr")) ;

        if (c == CTRLZ) {               /* If end=^Z...    */
            high = -1;
            SetFilePointer(handle, -1L, &high, FILE_END) ; /* ...back up 1 */
        }
    };

    SetList(fh) ;
    return(fh) ;
}

CRTHANDLE
Copen(fn, flags)
TCHAR *fn ;
unsigned int flags ;
{
    return( Copen_Work(fn, flags, FILE_SHARE_READ | FILE_SHARE_WRITE ) ); /* deny nothing */
}

/***    InSetList - Determine if handle is in signal cleanup table
 *
 *  Purpose:
 *      To determine if the input handle exsists in the cleanup table.
 *
 *  int InSetList(unsigned int fh)
 *
 *  Args:
 *          fh = File handle to check.
 *
 *  Returns:
 *      TRUE: if handle is in table.
 *      FALSE: if handle is not in table.
 *
 *  Notes:
 *    - Signal cleanup table does not include STDIN, STDOUT or STDERR.
 *
 */

unsigned long InSetList(
                       IN CRTHANDLE fh
                       )

{
    int cnt = 0 ;

    if (fh > STDERR && fh < 95) {
        while (fh > 31) {
            fh -= 32 ;
            ++cnt ;
        } ;

        return( (OHTbl[cnt]) & ((unsigned long)1 << fh) );
    };
    return( FALSE );
}




/***    Cdup - CMD.EXE dup function (M014)
 *
 *  Purpose:
 *      Duplicates the supplied handle and saves the new handle for
 *      possible signal cleanup.
 *
 *  int Cdup(unsigned int fh)
 *
 *  Args:
 *      fh = Handle to be duplicated
 *
 *  Returns:
 *      The handle returned by the C runtime dup function
 *
 *  Notes:
 *      Signal cleanup table does not include STDIN, STDOUT or STDERR.
 *
 */

CRTHANDLE
Cdup( CRTHANDLE fh )
{
    CRTHANDLE NewHandle ;

    if ((int)(NewHandle = _dup(fh)) != BADHANDLE)
        if ( InSetList( fh ) )
            SetList(NewHandle) ;

    return(NewHandle) ;
}




/***    Cdup2 - CMD.EXE dup2 function (M014)
 *
 *  Purpose:
 *      Duplicates the supplied handle and saves the new handle for
 *      possible signal cleanup.
 *
 *  HANDLE Cdup2(unsigned int fh1, unsigned int fh2)
 *
 *  Args:
 *      fh = Handle to be duplicated
 *
 *  Returns:
 *      The handle returned by the C runtime dup2 function
 *
 *  Notes:
 *      Signal cleanup table does not include STDIN, STDOUT or STDERR.
 *
 */

CRTHANDLE
Cdup2( CRTHANDLE fh1, CRTHANDLE fh2)
{

    unsigned int retcode ;
    int cnt = 0 ;
    unsigned int fuse ;

    if ((int)(retcode = (unsigned)_dup2(fh1,fh2)) != -1) {
        if ((fuse = fh2) > STDERR && fuse < 95) {
            while (fuse > 31) {
                fuse -= 32 ;
                ++cnt ;
            }

            OHTbl[cnt] &= ~((unsigned long)1 << fuse) ;
        }
        if ( InSetList( fh1 ) )
            SetList(fh2) ;
    }

    return(retcode) ;
}




/***    Cclose - CMD.EXE close handle function (M014)
 *
 *  Purpose:
 *      Closes an open file or device and removes the handle from the
 *      signal cleanup table.
 *
 *  int Cclose(unsigned int fh)
 *
 *  Args:
 *      fh = File handle to be closed.
 *
 *  Returns:
 *      return code from C runtime close
 *
 *  Notes:
 *    - Signal cleanup table does not include STDIN, STDOUT or STDERR.
 *    - M023 * Revised to use bit map instead of malloc'd space.
 *
 */


int
Cclose( CRTHANDLE fh )
{
    int cnt = 0 ;
    unsigned int fuse ;
    int ret_val;

    if (fh == BADHANDLE)
        return(0);

    if ((fuse = fh) > STDERR && fuse < 95) {
        while (fuse > 31) {
            fuse -= 32 ;
            ++cnt ;
        }

        OHTbl[cnt] &= ~((unsigned long)1 << fuse) ;
    }

    ret_val = _close(fh);         /* Delete file handle */

    return(ret_val);
}



/***    SetList - Place open handle in signal cleanup list (M014)
 *
 *  Purpose:
 *      Places a handle number in the signal cleanup table for use
 *      during signal's closing of files.
 *
 *  int SetList(unsigned int fh)
 *
 *  Args:
 *      fh = File handle to install.
 *
 *  Returns:
 *      nothing
 *
 *  Notes:
 *    - Signal cleanup table does not include STDIN, STDOUT or STDERR.
 *    - M023 * Revised to use bit map instead of malloc'd space.
 *
 */

void
SetList(
       IN CRTHANDLE fh
       )

{
    int cnt = 0 ;

    if (fh > STDERR && fh < 95) {
        while (fh > 31) {
            fh -= 32 ;
            ++cnt ;
        } ;


        OHTbl[cnt] |= ((unsigned long)1 << fh) ;
    };
}




/***    GetFuncPtr - return the i-th function pointer in JumpTable (M015)
 *
 *   int (*GetFuncPtr(int i))()
 *
 *   Args:
 *      i - the index of the JumpTable entry containing the function pointer
 *          to be returned
 *
 *   Returns:
 *      The i-th function pointer in JumpTable.
 *
 *   Notes:
 *      It is assumed that i is valid.
 *
 */
int
(*GetFuncPtr(i))(struct cmdnode *)
int i ;
{
    return(JumpTable[i].func) ;
}




/***    FindCmd - search JumpTable for a particular command (M015)
 *
 *   Purpose:
 *      Check the command name string pointers in each of the JumpTable
 *      entries for one which matches the name in the string supplied by
 *      the caller.
 *
 *   int FindCmd(int entries, TCHAR *sname, TCHAR *sflags)
 *
 *   Args:
 *      entries - M009 - This value is highest entry to be checked.  One
 *                must be added for this to become a count of entries to
 *                check.
 *      sname - pointer to the command name to search for
 *      sflags - if the command is found, store the command's flags here
 *
 *   Returns:
 *      If the entry is found, the entry's JumpTable index.
 *      Otherwise, -1.
 *
 */

int FindCmd(
           int entries, 
           const TCHAR *sname, 
           TCHAR *sflags)
{
    int i ;

    for (i=0 ; i <= entries ; i++) {                /* search through all entries */
        if (_tcsicmp(sname,JumpTable[i].name) == 0) { /* test for cmd in table @inx */
            /*                            */
            if (!(JumpTable[i].flags & EXTENSCMD) || fEnableExtensions) {
                *sflags = JumpTable[i].flags;          /* M017                       */
                cmdfound = i;                          /* @@5 save current cmd index */
                return(i);                             /* return not found index     */
            }
        }                                        /*                            */
    }                                           /*                            */
    cmdfound = -1;                                /* @@5 save not found index   */
    return(-1) ;                                  /* return not found index     */
}




/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: KillProc                                           */
/*                                                                     */
/* DESCRIPTIVE NAME: Kill process and wait for it to die               */
/*                                                                     */
/* FUNCTION: This routine kills a specified process during signal      */
/*           handling.                                                 */
/*                                                                     */
/* NOTES:    If the process is started by DosExecPgm, DosKillProcess   */
/*           is called to kill the process and all its child processes.*/
/*           WaitProc is also called to wait for the termination of    */
/*           the process and child processes.                          */
/*           If the process is started by DosStartSession,             */
/*           DosStopSession is called to stop the specified session and*/
/*           its child sessions.  WaitTermQProc is also called to wait */
/*           for the termination of the session.                       */
/*                                                                     */
/*      All of CMD's kills are done on the entire subtree and that     */
/*      is assumed by this function.  For single PID kills, use        */
/*      DOSKILLPROCESS direct.                                         */
/*                                                                     */
/*                                                                     */
/* ENTRY POINT: KillProc                                               */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT: Process ID / Session ID - to kill                            */
/*        Wait - indicates if we should wait here or not               */
/*                                                                     */
/* OUTPUT: None                                                        */
/*                                                                     */
/* EXIT-NORMAL: No error return code from WaitProc or WaitTermQProc    */
/*                                                                     */
/*                                                                     */
/* EXIT-ERROR:  Error return code from DosKillProcess or               */
/*              DosStopSession.  Or error code from WaitProc or        */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       WaitProc - wait for the termination of the specified process, */
/*                  its child process, and  related pipelined          */
/*                  processes.                                         */
/*                                                                     */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       DOSKILLPROCESS  - Kill the process and its child processes    */
/*       DOSSTOPSESSION  - Stop the session and its child sessions     */
/*       WINCHANGESWITCHENTRY -  Change switch list entry              */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

KillProc(pid, wait)
HANDLE pid ;
int wait;
{
    unsigned i = 0;

    DEBUG((CTGRP,COLVL, "KillProc: Entered PID = %d", pid)) ;

    if (!TerminateProcess((HANDLE)pid, 1)) {
        DosErr = GetLastError();
    }

    if (wait) {
        i = WaitProc(pid) ;                  /* wait for the related process to end */
    }

    return( i );
}



/***    WaitProc - Wait for a command subtree to terminate (M019)
 *
 *  Purpose:
 *      Provides a means of waiting for a process and all of its
 *      children to terminate.
 *
 *  int WaitProc(unsigned pid)
 *
 *  Args:
 *      pid - The process ID to be waited on
 *
 *  Returns:
 *      Retcode of the head process of the subtree
 *
 *  Notes:
 *      All of CMD's waits are done on the entire subtree and CMD
 *      will always wait until someone terminates.  That is assumed
 *      by this function.  For single PID waits, use DOSCWAIT direct.
 *
 */

WaitProc(pid)
HANDLE pid ;
{
    unsigned FinalRCode;    /* Return value from this function         */

    DEBUG((CTGRP,COLVL, "WaitProc: Entered PID = %d", pid)) ;

    //
    // Do  not allow printint of ctrl-c in ctrl-c thread while
    // waiting for another process. The main loop will handle
    // this if the process exits due to ctrl-c.
    //
    fPrintCtrlC = FALSE;
    WaitForSingleObject( (HANDLE)pid, INFINITE );
    GetExitCodeProcess( (HANDLE)pid, (LPDWORD)&FinalRCode );

    //if (CtrlCSeen & (FinalRCode == CONTROL_C_EXIT)) {
// how do we ever get here???
    if (FinalRCode == CONTROL_C_EXIT) {
        SetCtrlC();
        fprintf( stderr, "^C" );
        fflush( stderr );

    }
    fPrintCtrlC = TRUE;

    DEBUG((CTGRP, COLVL, "WaitProc: Returned handle %d, FinalRCode %d", pid, FinalRCode));
    CloseHandle( (HANDLE)pid );

    DEBUG((CTGRP,COLVL,"WaitProc:Complete and returning %d", FinalRCode)) ;


    return(FinalRCode) ;
}




/***    ParseLabel - Parse a batch file label statement (M020)
 *
 *  Purpose:
 *      Simulates the lexer's handling of labels in GOTO arguments.
 *
 *  int ParseLabel(TCHAR *lab, TCHAR buf[],unsigned flag)
 *
 *  Args:
 *      lab   - The batch file label to parse
 *      buf   - The buffer to hold the parsed label
 *      flag  - TRUE if this is a source label (already parsed once)
 *            - FALSE if this is a test target label.
 *
 *  Returns:
 *      Nothing useful
 *
 *  Notes:
 *      Note that source labels (those in the GOTO statement itself),
 *      have already been parsed by the normal method with ESCHAR's
 *      and other operator tokens presumably processed.  Such char's
 *      still in the label can be assumed to have been ESC'd already,
 *      and therefore, we ignore them.  Target labels, however, are
 *      raw strings and we must simulate the parser's actions.
 *
 */

void
ParseLabel(
          TCHAR    *lab,
          TCHAR    buf[],
          ULONG   cbBufMax,
          BOOLEAN flag
          )

{
    ULONG i ;
    TCHAR c ;


    lab = EatWS(lab,NULL) ;         /* Strip normal whitespace         */

    if ((c = *lab) == COLON || c == PLUS)   /* Eat first : or + ...    */
        ++lab ;                         /* ...only                 */

    if (!flag)                              /* If target strip...      */
        lab = EatWS(lab,NULL) ;         /* ... any add'l WS        */

    for (i = 0, c = *lab ; i < cbBufMax ; c = *(++lab)) {

        DEBUG((CTGRP,COLVL,"ParseLabel: Current Char = %04x", *lab)) ;

        if ((flag && mystrchr(Delimiters, c)) ||
            //mystrchr("+:\n\r\x20", c)) {
            mystrchr( TEXT("+:\n\r\t "), c)) { //change from \x20 to space bug
            // mips compiler

            DEBUG((CTGRP,COLVL,"ParseLabel: Found terminating delim.")) ;
            break ;
        };

        if (!flag) {

            if (mystrchr(TEXT("&<|>"), c)) {

                DEBUG((CTGRP,COLVL,
                       "ParseLabel: Found operator in target!")) ;
                break ;
            };

            if (c == ESCHAR) {

                DEBUG((CTGRP,COLVL,
                       "ParseLabel: Found '^' adding %04x",
                       *(lab+1))) ;
                buf[i++] = *(++lab) ;
                continue ;
            };
        };

        DEBUG((CTGRP,COLVL,"ParseLabel: Adding %02x",c)) ;

        buf[i++] = c ;
    } ;

    buf[i] = NULLC ;

    DEBUG((CTGRP,COLVL,"ParseLabel: Exitted with label %ws", buf)) ;
}




/***    EatWS - Strip leading whitespace and other special chars (M020)
 *
 *  Purpose:
 *      Remove leading whitespace and any special chars from the string.
 *
 *  TCHAR *EatWS(TCHAR *str, TCHAR *spec)
 *
 *  Args:
 *      str  - The string to eat from
 *      spec - Additional delimiters to eat
 *
 *  Returns:
 *      Updated character pointer
 *
 *  Notes:
 *
 */

PTCHAR
EatWS(
     TCHAR *str,
     TCHAR *spec )
{
    TCHAR c ;

    if (str != NULL) {

        while ((_istspace(c = *str) && c != NLN) ||
               (mystrchr(Delimiters, c) && c) ||
               (spec && mystrchr(spec,c) && c))
            ++str ;
    }

    return(str) ;
}




/***    IsValidDrv - Check drive validity
 *
 *  Purpose:
 *      Check validity of passed drive letter.
 *
 *  int IsValidDrv(TCHAR drv)
 *
 *  Args:
 *      drv - The letter of the drive to check
 *
 *  Returns:
 *      TRUE if drive is valid
 *      FALSE if not
 *
 *  Notes:
 *
 */

IsValidDrv(TCHAR drv)
{
    TCHAR    temp[4];

    temp[ 0 ] = drv;
    temp[ 1 ] = COLON;
    temp[ 2 ] = PathChar;
    temp[ 3 ] = NULLC;

    //
    // return of 0 or 1 mean can't determine or root
    // does not exists.
    //
    if (GetDriveType(temp) <= 1)
        return( FALSE );
    else {
        return( TRUE );
    }
}

/***    IsDriveLocked - Check For Drive Locked Condition
 *
 *  Purpose:
 *      The real purpose is to check for a drive locked, but since this
 *      could be the first time that the disk get hit we will just return
 *      the Dos Error Code
 *
 *  int IsDriveLocked(TCHAR drv)
 *
 *  Args:
 *      drv - The letter of the drive to check
 *
 *  Returns:
 *      0 if no errors
 *      Dos Error number if failure
 *
 *  Notes:
 *
 */

IsDriveLocked( TCHAR drv )
{
    DWORD   Vsn[2];
    TCHAR   szVolName[MAX_PATH];
    TCHAR   szVolRoot[5];
    DWORD   rc;

    szVolRoot[ 0 ] = drv;
    szVolRoot[ 1 ] = COLON;
    szVolRoot[ 2 ] = PathChar;
    szVolRoot[ 3 ] = NULLC;

    //
    // If floppy and locked will get this.
    //
    if ( (rc = GetDriveType(szVolRoot)) <= 1) {

        return( TRUE );

    }

    //
    // If removable check if access to vol. info allowed.
    // if not then assume it is locked.
    //
    if ((rc != DRIVE_REMOVABLE) && (rc != DRIVE_CDROM)) {
        if (!GetVolumeInformation(szVolRoot,
                                  szVolName,
                                  MAX_PATH,
                                  Vsn,
                                  NULL,
                                  NULL,
                                  NULL,
                                  0)) {

            if ( GetLastError() == ERROR_ACCESS_DENIED) {

                return( TRUE );

            }

        }
    }
    return( FALSE );


}

/***    PtrErr - Print Error resulting from last recorded system call
 *
 *  Purpose:
 *      Prints appropriate error message resulting from last system
 *      call whose return code is saved in DosErr variable.
 *
 *  int PtrErr(unsigned msgnum)
 *
 *  Args:
 *      msgnum = Default message to print if no match
 *
 *  Returns:
 *      Nothing
 *
 *  Notes:
 *      msgnum can be passed in as NULL if no msg is to be printed as a
 *      default.
 *
 */

void PrtErr(msgnum)
unsigned msgnum ;
{
    unsigned i,                             /* Temp counter            */
    tabmsg = (unsigned)MSG_USE_DEFAULT ;     /* Table message found     */

    for (i = 0 ; mstabl[i].errnum != 0 ; ++i) {
        if (DosErr == mstabl[i].errnum) {
            tabmsg = mstabl[i].msnum ;
            break ;
        }
    }

    if (tabmsg != (unsigned)MSG_USE_DEFAULT)
        msgnum = tabmsg ;

    if (msgnum)
        PutStdErr(msgnum, NOARGS) ; /* @@ */
}


/***    GetMsg - Get  a message  ***/

PTCHAR
GetMsg(unsigned MsgNum, ...)
{
    PTCHAR Buffer = NULL;
    
    va_list arglist;

    va_start( arglist, MsgNum );

    msglen = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE
                            | FORMAT_MESSAGE_FROM_SYSTEM
                            | FORMAT_MESSAGE_ALLOCATE_BUFFER ,
                            NULL,
                            MsgNum,
                            0,
                            (LPTSTR) &Buffer,
                            0,
                            &arglist
                            );
    va_end(arglist);

    return Buffer;
    
}


/**** dayptr - return pointer to day of the week
 *
 * Purpose:
 *      To return a pointer to the string representing the current day of
 *      the week.
 *
 * Args:
 *      dow - number representing the day of the week.
 *
 */

TCHAR *dayptr( dow )
unsigned dow;
{
    switch ( dow ) {
    case 0:  return ShortSundayName;
    case 1:  return ShortMondayName;
    case 2:  return ShortTuesdayName;
    case 3:  return ShortWednesdayName;
    case 4:  return ShortThursdayName;
    case 5:  return ShortFridayName;
    default: return ShortSaturdayName;
    }
}

/********************** START OF SPECIFICATIONS **********************/
/* SUBROUTINE NAME: Copen_Work2                                      */
/*                                                                   */
/* DESCRIPTIVE NAME: Worker routine to open a file.                  */
/*                                                                   */
/* FUNCTION: Opens a file or device and saves the handle for         */
/*           possible later signal cleanup.  Set the extended        */
/*           attribute information from the file being opened.       */
/*                                                                   */
/* NOTES: Signal cleanup table does not include STDIN, STDOUT or     */
/*        STDERR.  M017 - Extensively rewritten to use CreateFile    */
/*        rather than runtime open().                                */
/*                                                                   */
/* ENTRY POINT: Copen_Work2                                          */
/*    LINKAGE: Copen_Work2(fn, flags, fShareMode, eaop, FSwitch)        */
/*                                                                   */
/* INPUT: (PARAMETERS)                                               */
/*                                                                   */
/*      filename = ASCIZ filename to open                            */
/*      flags    = Flags controlling type of open to make            */
/*      fShareMode  = Flags for callers sharing mode                 */
/*      eaop     = Extended attribute buffer pointer.                */
/*      FSwitch  = Fail if EAs can't be copied                       */
/*                                                                   */
/* EXIT-NORMAL:                                                      */
/*              Return file handle value like C runtime open         */
/*                                                                   */
/* EXIT-ERROR:                                                       */
/*              Return -1 if open failed                             */
/*                                                                   */
/* EFFECTS: None.                                                    */
/*                                                                   */
/* INTERNAL REFERENCES:                                              */
/*    ROUTINES:                                                      */
/*      FileIsDevice    - test for file or device via DOSQHANDTYPE   */
/*      SetList         - add handle from open to cleanup list       */
/*      varb:DosErr     - global error return variable               */
/*                                                                   */
/* EXTERNAL REFERENCES:                                              */
/*    ROUTINES:                                                      */
/*      CreateFile  - open a file with ability for EA processing     */
/*                                                                   */
/*********************** END OF SPECIFICATIONS ***********************/

CRTHANDLE
Copen_Work2(fn, flags, fShareMode, FSwitch)
TCHAR *fn ;                     /* filename                        */
unsigned int flags, fShareMode, FSwitch ;  /* flags and special case flags    */
{
    HANDLE handl ;              /* Handle ret'd                    */
    CRTHANDLE rcode;            /* return code                     */
    DWORD fAccess;
    DWORD fCreate;
    SECURITY_ATTRIBUTES sa;

    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);


/***************************************************************************/
/*  Note that O_RDONLY being a value of 0, cannot be tested for            */
/*  conflicts with any of the write type flags.                            */
/***************************************************************************/

    DBG_UNREFERENCED_PARAMETER( FSwitch);
    if (((flags & (O_WRONLY | O_RDWR)) > 2) ||  /* Flags invalid?          */
        ((flags & O_WRONLY) &&                   /*                         */
         (flags & O_APPEND))) {                   /*                         */
        DEBUG((CTGRP, COLVL, "COPEN: Bad flags issued %04x",flags)) ;
        rcode = BADHANDLE;                      /* set bad handle                  */
    } else {

/***************************************************************************/
/*  M024 - Altered so that the only sharing restriction is to deny         */
/*  others write permission if this open is for writing.  Any other        */
/*  sharing is allowed.                                                    */
/***************************************************************************/

        if (flags & (O_WRONLY | O_RDWR)) {       /* If Writing, set...      */
            fAccess = GENERIC_WRITE;
            if (flags & O_RDWR)
                fAccess |= GENERIC_READ;

            /*
             * deny write only if it is not console
             */

            if (_tcsicmp(fn, TEXT("con"))) {
                fShareMode = FILE_SHARE_READ;
            }

            fCreate = CREATE_ALWAYS;/* ...open if exists, else create  */
        } else {
            fAccess = GENERIC_READ;
            fCreate = OPEN_EXISTING;
            if (!_tcsicmp(fn,TEXT("con"))) {
                fShareMode = FILE_SHARE_READ;
            }
        }

        fn = StripQuotes(fn);

        if (fCreate == CREATE_ALWAYS &&
            (handl=CreateFile(fn, fAccess, fShareMode, &sa, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL)) != INVALID_HANDLE_VALUE) {
            rcode = _open_osfhandle((LONG_PTR)handl, _O_APPEND);
        } else if ((handl = CreateFile(fn, fAccess, fShareMode, &sa, fCreate, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL)) == INVALID_HANDLE_VALUE) {
            DosErr = GetLastError();
            DEBUG((CTGRP,COLVL, "COPEN: CreateFile ret'd %d",DosErr)) ;
            if (DosErr==ERROR_OPEN_FAILED) {
                DosErr=ERROR_FILE_NOT_FOUND;   /* change to another error */
            }
            rcode = BADHANDLE;
        } else {
            rcode = _open_osfhandle((LONG_PTR)handl, _O_APPEND);
        }                       /*                                 */
    }                           /*                                 */
    return(rcode ) ;            /* return handle to caller         */
}

/********************** START OF SPECIFICATIONS **********************/
/* SUBROUTINE NAME: Copen2                                           */
/*                                                                   */
/* DESCRIPTIVE NAME: Open a destination file with extended attributes*/
/*                                                                   */
/* FUNCTION: Call a worker routine to open a destination file or     */
/*           device and set the extended attribute information       */
/*           from the source file if this is the first file          */
/*           and/or only file and there are extended attributes      */
/*           available.                                              */
/*                                                                   */
/* NOTES:                                                            */
/*                                                                   */
/* ENTRY POINT: Copen2                                               */
/*    LINKAGE: Copen2(fn, flags, FSwitch)                            */
/*                                                                   */
/* INPUT: (PARAMETERS)                                               */
/*                                                                   */
/*      fn       = ASCIZ filename to open                            */
/*      flags    = Flags controlling type of open to make            */
/*                                                                   */
/*                                                                   */
/* EXIT-NORMAL:                                                      */
/*              Return file handle value like C runtime open         */
/*                                                                   */
/* EXIT-ERROR:                                                       */
/*              Return -1 if open failed                             */
/*                                                                   */
/* EFFECTS: None.                                                    */
/*                                                                   */
/* INTERNAL REFERENCES:                                              */
/*    ROUTINES:                                                      */
/*      Copen_Work2     - worker routine for performing CreateFile   */
/*      varb: first_fflag-TRUE = first file FALSE = not first file   */
/*                                                                   */
/*                                                                   */
/*********************** END OF SPECIFICATIONS ***********************/

CRTHANDLE
Copen2(fn, flags, FSwitch)
TCHAR *fn ;                             /* file name       */
unsigned int flags ;                            /* open flags      */
unsigned FSwitch;
{
    return(Copen_Work2(fn, flags, FILE_SHARE_READ | FILE_SHARE_WRITE, FSwitch));
}


/********************** START OF SPECIFICATIONS **********************/
/* SUBROUTINE NAME: Copen_Copy2                                      */
/*                                                                   */
/* DESCRIPTIVE NAME: Open a source file with extended attributes.    */
/*                                                                   */
/* FUNCTION: Call a worker routine to open a source file or device   */
/*           and get the extended attribute information from the     */
/*           file if ffirst2 or fnext2 says this is a EA file.       */
/*                                                                   */
/* NOTES:                                                            */
/*                                                                   */
/* ENTRY POINT: Copen_Copy2                                          */
/*    LINKAGE: Copen2(fn, flags)                                     */
/*                                                                   */
/* INPUT: (PARAMETERS)                                               */
/*                                                                   */
/*      fn       = ASCIZ filename to open                            */
/*      flags    = Flags controlling type of open to make            */
/*                                                                   */
/* EXIT-NORMAL:                                                      */
/*              Return file handle value like C runtime open         */
/*                                                                   */
/* EXIT-ERROR:                                                       */
/*              Return -1 if open failed                             */
/*                                                                   */
/* EFFECTS: None.                                                    */
/*                                                                   */
/* INTERNAL REFERENCES:                                              */
/*    ROUTINES:                                                      */
/*      Copen_Work2     - worker routine for performing CreateFile   */
/*      Cclose          - close a handle file/device handle opened   */
/*                        and remove handle from handles to free     */
/*      varb: first_file- TRUE = first file FALSE = not first file   */
/*                                                                   */
/*                                                                   */
/*                                                                   */
/* EXTERNAL REFERENCES:                                              */
/*    ROUTINES:                                                      */
/*    DOSALLOCSEG       - request an amount of ram memory            */
/*    DOSFREESEG        - free a DOSALLOCSEG segment of ram memory   */
/*    DOSQFILEINFO      - request EA info for a file using level 2   */
/*                                                                   */
/*********************** END OF SPECIFICATIONS ***********************/


CRTHANDLE
Copen_Copy2(fn, flags)
TCHAR *fn;                      /* file name                       */
unsigned int flags ;                    /* open flags                      */
{
    return(Copen_Work2(fn, flags, FILE_SHARE_READ | FILE_SHARE_WRITE, TRUE));
}

CRTHANDLE
Copen_Copy3(fn)
TCHAR *fn;                      /* file name                       */
{
    HANDLE      handl ;         /* Handle ret'd                    */
    CRTHANDLE   rcode;          /* return code                     */
    SECURITY_ATTRIBUTES sa;

    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);

    fn = StripQuotes(fn);

    handl = CreateFile(fn, GENERIC_WRITE, 0, &sa, TRUNCATE_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (handl == INVALID_HANDLE_VALUE) {
        DosErr = GetLastError();
        DEBUG((CTGRP,COLVL, "COPEN: CreateFile ret'd %d",DosErr)) ;
        if (DosErr==ERROR_OPEN_FAILED) {
            DosErr=ERROR_FILE_NOT_FOUND;        /* change to another error */
        }
        rcode = BADHANDLE;
    } else {
        rcode = _open_osfhandle((LONG_PTR)handl, _O_APPEND);
    }                   /*                                 */
    return(rcode ) ;            /* return handle to caller         */
}


TCHAR *
StripQuotes( TCHAR *wrkstr )
{
    static TCHAR tempstr[MAXTOKLEN];
    int i,j,slen;

    if ( mystrchr(wrkstr,QUOTE) ) {
        mytcsnset(tempstr, NULLC, MAXTOKLEN);
        slen= mystrlen(wrkstr);
        j=0;
        for (i=0;i<slen;i++) {
            if ( wrkstr[i] != QUOTE )
                tempstr[j++] = wrkstr[i];

        }
        tempstr[j] = NULLC;
        return(tempstr);
    } else
        return(wrkstr);
}


TCHAR *
SkipWhiteSpace( TCHAR *String )
{
    while (*String && _istspace( *String )) {
        String++;
    }

    return String;
}


ULONG
PromptUser (
           IN  PTCHAR  szArg,
           IN  ULONG   msgId,
           IN  ULONG   responseDataId
           )

/*++

Routine Description:

    Prompts user for single letter answer to a question. The prompt can be
    a message plus an optional single argument.  Valid letters are defined
    by contents of message specified by responseDataId.  Case is not
    significant.

Arguments:

    pszTok - list of attributes

Return Value:

    Returns index into response data

Return: the user response

--*/

{

    BOOLEAN  fFirst;
    TCHAR    chT;
    TCHAR    chAnsw = NULLC;
    ULONG    dwOutputModeOld;
    ULONG    dwOutputModeCur;
    ULONG    dwInputModeOld;
    ULONG    dwInputModeCur;
    BOOLEAN  fOutputModeSet = FALSE;
    BOOLEAN  fInputModeSet = FALSE;
    HANDLE   hndStdOut = NULL;
    HANDLE   hndStdIn = NULL;
    TCHAR    responseChoices[16];
    TCHAR   *p;
    ULONG    iResponse;
    ULONG    iMaxResponse;
    DWORD    cb;
    PTCHAR   Message;

    if (msgId == MSG_MOVE_COPY_OVERWRITE) {
        CRTHANDLE srcptr;

        srcptr = Copen_Copy2(szArg, (unsigned int)O_RDONLY);
        if (srcptr != BADHANDLE) {
            if (FileIsDevice( srcptr )) {
                Cclose(srcptr);
                return 2;   // Return All response for devices
            }
            Cclose(srcptr);
        }
    }

    Message = GetMsg( responseDataId );
    if (Message != NULL  && _tcslen( Message ) < 16) {
        _tcscpy( responseChoices, Message );
        _tcsupr( responseChoices );
    } else {
        _tcscpy( responseChoices, TEXT("NY") );
    }
    iMaxResponse = _tcslen( responseChoices ) - 1;

    LocalFree( Message );

    hndStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (GetConsoleMode( hndStdOut, &dwOutputModeOld) ) {

        // make sure CRLF is processed correctly

        dwOutputModeCur = dwOutputModeOld | ENABLE_PROCESSED_OUTPUT;
        fOutputModeSet = TRUE;
        SetConsoleMode(hndStdOut,dwOutputModeCur);
        GetLastError();

    }

    hndStdIn = GetStdHandle(STD_INPUT_HANDLE);
    if (GetConsoleMode( hndStdIn, &dwInputModeOld) ) {

        // make sure input is processed correctly

        dwInputModeCur = dwInputModeOld | ENABLE_LINE_INPUT |
                         ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT;
        fInputModeSet = TRUE;
        SetConsoleMode(hndStdIn,dwInputModeCur);
        GetLastError();

#ifndef WIN95_CMD
        if (lpSetConsoleInputExeName != NULL)
            (*lpSetConsoleInputExeName)( TEXT("<noalias>") );
#endif
    }

    //
    // Loop till the user answer with a valid character
    //
    while (TRUE) {

        chT = NULLC;
        fFirst = TRUE ;
        if (szArg) {
            PutStdOut(msgId, ONEARG, szArg );
        } else {
            PutStdOut(msgId, NOARGS);
        }

        //
        // Flush keyboard before asking for response
        //
        if (FileIsDevice(STDIN)) {
            FlushConsoleInputBuffer( GetStdHandle(STD_INPUT_HANDLE) );
        }

        //
        // Read till EOL
        //
        while (chT != NLN) {

            if (ReadBufFromInput(
                                GetStdHandle(STD_INPUT_HANDLE),
                                (TCHAR*)&chT, 1, &cb) == 0 ||
                cb != 1) {

                chAnsw = responseChoices[0];
                cmd_printf(CrLf) ;
                break;
            }

            if (fFirst) {
                chAnsw = (TCHAR) _totupper(chT) ;
                fFirst = FALSE ;
            }

            if (!FileIsDevice(STDIN) || !(flgwd & 1)) {
                cmd_printf(Fmt19,chT) ;
            }
        }

        p = _tcschr(responseChoices, chAnsw);
        if (p != NULL) {
            iResponse = (UINT)(p - responseChoices);
            if (iResponse <= iMaxResponse) {
                break;
            }
        }
    }
    if (fOutputModeSet) {
        SetConsoleMode( hndStdOut, dwOutputModeOld );
    }
    if (fInputModeSet) {
        SetConsoleMode( hndStdIn, dwInputModeOld );

#ifndef WIN95_CMD
        if (lpSetConsoleInputExeName != NULL)
            (*lpSetConsoleInputExeName)( TEXT("CMD.EXE") );
#endif
    }

    return(iResponse);
}

ULONG   LastMsgNo;

int
eSpecialHelp(
            IN struct cmdnode *pcmdnode
            )
{
    TCHAR szHelpStr[] = TEXT("/\0?");

    if (LastMsgNo == MSG_HELP_FOR)
        CheckHelpSwitch(FORTYP, szHelpStr);
    else
        if (LastMsgNo == MSG_HELP_IF)
        CheckHelpSwitch(IFTYP, szHelpStr);
    else
        if (LastMsgNo == MSG_HELP_REM)
        CheckHelpSwitch(REMTYP, szHelpStr);
    else
        PutStdOut( LastMsgNo, NOARGS );

    return SUCCESS;
}

BOOLEAN
CheckHelp (
          IN  ULONG   jmptblidx,
          IN  PTCHAR  pszTok,
          IN  BOOL    fDisplay
          )

{
    ULONG msgno =    JumpTable[jmptblidx].msgno;
    ULONG extmsgno = JumpTable[jmptblidx].extmsgno;
    ULONG noextramsg =JumpTable[jmptblidx].noextramsg;

    if (!pszTok) {
        return( FALSE );
    }

    while (*pszTok) {
        if (*pszTok == SwitChar) {
            //
            // Check for /?.  Ignore /? if ? not followed by delimeter and IF command
            // This allows if ./?. == ..
            //

            if (*(pszTok + 2) == QMARK && (jmptblidx != IFTYP || *(pszTok + 3) == NULLC) ) {

                if (msgno == 0 && fEnableExtensions) {
                    msgno = extmsgno;
                    extmsgno = 0;
                }

                if (msgno == 0) {
                    msgno = MSG_SYNERR_GENL;
                    extmsgno = 0;
                    noextramsg = 0;
                }

                if ( fDisplay ) {
                    //
                    //  Display help now
                    //
                    BeginHelpPause();

#define CTRLCBREAK  if (CtrlCSeen) break
                    do {
                        CTRLCBREAK; PutStdOut(msgno, NOARGS);

                        if (!fEnableExtensions) break;

                        if (extmsgno != 0) {
                            CTRLCBREAK; PutStdOut(extmsgno, NOARGS);
                        }

                        while (!CtrlCSeen && noextramsg--)
                            PutStdOut(++extmsgno, NOARGS);

                    } while ( FALSE );
                    EndHelpPause();
                } else {
                    //
                    //  Remember the message, eSpecicalHelp will display it later.
                    //  extmsgno will always be zero here
                    //
                    LastMsgNo = msgno;
                }
                return( TRUE );

            }
            //
            // move over SwitChar, switch value and 2 0's
            //

            pszTok += mystrlen(pszTok) + 1;
            if (*pszTok) {
                pszTok += mystrlen(pszTok) + 1;
            }

        } else
            if (jmptblidx == ECHTYP) {
            //
            // ECHO only supports /? as first token.  Allows you echo a string
            // with /? in it (e.g. ECHO Update /?).
            //
            break;
        } else {

            //
            // move over param. and 1 0's
            //
            pszTok += mystrlen(pszTok) + 1;
        }
    }

    return( FALSE );

}


BOOLEAN
TokBufCheckHelp(
               IN PTCHAR pszTokBuf,
               IN ULONG  jmptblidx
               )

{

    TCHAR   szT[10];
    PTCHAR  pszTok;

    //
    // Tokensize the command line (special delimeters are tokens)
    //
    szT[0] = SwitChar ;
    szT[1] = NULLC ;

    pszTok = TokStr(pszTokBuf, szT, TS_SDTOKENS);
    return CheckHelp(jmptblidx, pszTok, FALSE);
}




BOOLEAN
CheckHelpSwitch (
                IN  ULONG   jmptblidx,
                IN  PTCHAR  pszTok
                )

{
    return CheckHelp( jmptblidx,
                      pszTok,
                      TRUE
                    ) ;
}

PTCHAR
GetTitle(
        IN struct cmdnode *pcmdnode
        )

{
    PTCHAR   tptr, argptr;
    /* Allocate string space for command line */
    /* Command_Head + Optional_Space + Command_Tail + Null + Null */

    if (!(argptr = mkstr(mystrlen(pcmdnode->cmdline)*sizeof(TCHAR)+mystrlen(pcmdnode->argptr)*sizeof(TCHAR)+3*sizeof(TCHAR))))
        return(NULL) ;

    /* The command line is the concatenation of the command head and tail */
    mystrcpy(argptr,pcmdnode->cmdline);
    tptr = argptr+mystrlen(argptr);
    if (mystrlen(pcmdnode->argptr)) {
        if (*pcmdnode->argptr != SPACE) {
            //DbgPrint("GetTitle: first arg char not space %s\n",pcmdnode->argptr);
            *tptr++ = SPACE;
        }
        mystrcpy(tptr,pcmdnode->argptr);
        tptr[mystrlen(tptr)+1] = NULLC;    /* Add extra null byte */
    }
    tptr = argptr;
    return( tptr );
}

VOID
SetConTitle(
           IN  PTCHAR   pszTitle
           )
{

    ULONG   cbNewTitle, cbTitle;
    PTCHAR  pszNewTitle, pTmp;

    if (pszTitle == NULL) {
        return;
    }

    if ((!CurrentBatchFile) && (!SingleCommandInvocation)) {
        if ((pszNewTitle = (PTCHAR)HeapAlloc(GetProcessHeap(), 0, (MAX_PATH+2)*sizeof(TCHAR))) == NULL) {
            return;
        }

        cbNewTitle = GetConsoleTitle( pszNewTitle, MAX_PATH );
        if (!cbNewTitle) {
            return;
        }

        cbTitle = mystrlen(pszTitle);

        pTmp = (PTCHAR)HeapReAlloc(GetProcessHeap(), 0, pszNewTitle, (cbNewTitle+cbTitle+cbTitleCurPrefix+10)*sizeof(TCHAR));
        if (pTmp == NULL) {
            HeapFree( GetProcessHeap( ), 0, pszNewTitle );
            return;
        }
        pszNewTitle = pTmp;

        if (fTitleChanged) {
            _tcscpy( pszNewTitle + cbTitleCurPrefix, pszTitle );
        } else {
            _tcscat( pszNewTitle, TEXT(" - ") );
            cbTitleCurPrefix = _tcslen( pszNewTitle );
            _tcscat( pszNewTitle, pszTitle );
            fTitleChanged = TRUE;
        }

        SetConsoleTitle(pszNewTitle);
        HeapFree(GetProcessHeap(), 0, pszNewTitle);
    }

}

VOID
ResetConTitle(

             IN  PTCHAR   pszTitle
             )

{

    if (pszTitle == NULL) {

        return;

    }

    if ((!CurrentBatchFile) && (fTitleChanged)) {

        SetConsoleTitle(pszTitle);
        cbTitleCurPrefix = 0;
        fTitleChanged = FALSE;

    }

}


/***
*void ResetConsoleMode( void ) - make sure correct mode bits are set
*
*Purpose:
*       Called after each external command or ^C in case they hosed out modes.
*
*Entry:

*Exit:
*
*Exceptions:
*
*******************************************************************************/

void
ResetConsoleMode( void )
{
    DWORD dwDesiredOutputMode = ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT;
    DWORD dwDesiredInputMode = ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT;

    SetConsoleMode(CRTTONT(STDOUT), dwCurOutputConMode);
    if (GetConsoleMode(CRTTONT(STDOUT), &dwCurOutputConMode)) {
        if ((dwCurOutputConMode & dwDesiredOutputMode) != dwDesiredOutputMode) {
            dwCurOutputConMode |= dwDesiredOutputMode;
            SetConsoleMode(CRTTONT(STDOUT), dwCurOutputConMode);
        }
    }

    if (GetConsoleMode(CRTTONT(STDIN),&dwCurInputConMode)) {
        if ((dwCurInputConMode & dwDesiredInputMode) != dwDesiredInputMode ||
            dwCurInputConMode & ENABLE_MOUSE_INPUT
           ) {
            dwCurInputConMode &= ~ENABLE_MOUSE_INPUT;
            dwCurInputConMode |= dwDesiredInputMode;
            SetConsoleMode(CRTTONT(STDIN), dwCurInputConMode);
        }

#ifndef WIN95_CMD
        if (lpSetConsoleInputExeName != NULL)
            (*lpSetConsoleInputExeName)( TEXT("CMD.EXE") );
#endif
    }
}



/***
*void mytcsnset(string, val, count) - set count characters to val
*
*Purpose:
*       Sets the first count characters of string the character value.
*
*Entry:
*       tchar_t *string - string to set characters in
*       tchar_t val - character to fill with
*       size_t count - count of characters to fill
*
*Exit:
*       returns string, now filled with count copies of val.
*
*Exceptions:
*
*******************************************************************************/

void mytcsnset (
               PTCHAR string,
               TCHAR val,
               int count
               )
{
    while (count--)
        *string++ = val;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\dir.h ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    dir.h

Abstract:

    Definitions for DIR command

--*/

/*

 The following are definitions of the debugging group and level bits
 for the code in this file.

*/

#define ICGRP	0x0040	/* Informational commands group */
#define DILVL	0x0001	/* Directory level		*/

#define FULLPATHSWITCH          0x00000001
#define NEWFORMATSWITCH         0x00000002
#define WIDEFORMATSWITCH        0x00000004
#define PAGEDOUTPUTSWITCH       0x00000008
#define RECURSESWITCH           0x00000010
#define HELPSWITCH              0x00000020
#define BAREFORMATSWITCH        0x00000040
#define LOWERCASEFORMATSWITCH   0x00000080
#define FATFORMAT               0x00000100
#define SORTDOWNFORMATSWITCH    0x00000200
#define SHORTFORMATSWITCH       0x00000400
#define PROMPTUSERSWITCH        0x00000800
#define FORCEDELSWITCH          0x00001000
#define QUIETSWITCH             0x00002000
#define SORTSWITCH              0x00004000
#define THOUSANDSEPSWITCH       0x00008000
#define DELPROCESSEARLY         0x00010000
#define OLDFORMATSWITCH         0x00020000
#define DISPLAYOWNER            0x00040000
#define YEAR2000                0x00080000

#define HEADERDISPLAYED         0x80000000


#define HIDDENATTRIB		1
#define SYSTEMATTRIB		2
#define DIRECTORYATTRIB		4
#define ARCHIVEATTRIB		8
#define READONLYATTRIB          16

#define LAST_WRITE_TIME         0
#define CREATE_TIME             1
#define LAST_ACCESS_TIME        2

//
// Each of these buffers are aligned on DWORD boundaries to allow
// for direct pointers into buffers where each of the entries will
// vary on a byte bases. So to make it simple an extra DWORD is put into
// each allocation increment to allow for max. that can be adjusted.
//
//
// 52 is based upon sizeof(FF) - MAX_PATH + 15 (average size of file name)
// + 1 to bring it up to a Quad word alignment for fun.
//

#define CBDIRINC                1024
#define CBFILEINC               2048

#define NAMESORT        TEXT('N')
#define EXTENSIONSORT   TEXT('E')
#define DATETIMESORT    TEXT('D')
#define SIZESORT        TEXT('S')
#define DIRFIRSTSORT    TEXT('G')

#define DESCENDING	1
//
// This must be 0 since 0 is the default initialization
//
#define ASCENDING	0
#define ESUCCESS 0

int _cdecl CmpName( const void *, const void *);
int _cdecl CmpExt ( const void *, const void *);
int _cdecl CmpTime( const void *, const void *);
int _cdecl CmpSize( const void *, const void *);
int _cdecl CmpType( const void *, const void *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\hstoi.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    hstoi.c

Abstract:

    Low level utility

--*/

#include "cmd.h"

/***	hstoi - convert a hex string to an integer
 *
 *  Conversion stops when the first non-hex character is found.  If the first
 *  character is not a hex character, 0 is returned.
 *
 *  Eric K. Evans, Microsoft
 */

hstoi( TCHAR *s )
{
    int result = 0 ;
    int digit ;

    if (s == NULL) {
        return 0;
    }
    
    s = SkipWhiteSpace( s );

    for ( ; *s && _istxdigit(*s) ; s++) {
        digit = (int) (*s <= TEXT('9')) ? (int)*s - (int)'0' : (int)_totlower(*s)-(int)'W' ;
        result = (result << 4)+digit ;
    } ;

    return (result) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM

INCLUDES=..;$(SHELL_INC_PATH);$(WINDOWS_INC_PATH);$(O)

W32_SB=1

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\cmd.rc \
        ..\cbatch.c \
        ..\cchcp.c \
        ..\cclock.c \
        ..\cdata.c \
        ..\cdebug.c \
        ..\cenv.c \
        ..\cext.c \
        ..\cfile.c \
        ..\cinfo.c \
        ..\cinit.c \
        ..\ckeys.c \
        ..\clex.c \
        ..\cmd.c \
        ..\cmem.c \
        ..\cop.c \
        ..\console.c \
        ..\cother.c \
        ..\cparse.c \
        ..\cpath.c \
        ..\cpparse.c \
        ..\cpwork.c \
        ..\csig.c \
        ..\ctools1.c \
        ..\ctools2.c \
        ..\ctools3.c \
        ..\del.c   \
        ..\dir.c \
        ..\display.c \
        ..\ffirst.c \
        ..\hstoi.c \
        ..\start.c \
        ..\string.c \
        ..\tree.c  \
        ..\uipriv.c \
        ..\readcon.c \
        ..\complete.c

DELAYLOAD=SHELL32.DLL;MPR.DLL;advapi32.dll

UMTYPE=console

COFFBASE=cmd

NTTARGETFILE0=$(O)\cmdmsg.h

PRECOMPILED_INCLUDE=..\cmd.h
PRECOMPILED_PCH=cmd.pch
PRECOMPILED_OBJ=cmdpch.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\readcon.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    readcon.c

Abstract:

    Emulate NT console on Win9x

--*/

///////////////////////////////////////////////////////////////
//
// ReadCon.cpp
//
//
//      ReadConsole implementation for Win95 that implements the command line editing
//      keys, since Win95 console implementation does not.
//

#include "cmd.h"

#ifdef WIN95_CMD

// adv declarations....
extern BOOLEAN	CtrlCSeen;
extern BOOL		bInsertDefault;
void ShowBuf( TCHAR* pBuf, int nFromPos );

// some state variables.....
static int      nConsoleWidth;          // num columns
static int      nConsoleHeight;         // num rows
static COORD	coordStart;		// coord of first cmd char....
static COORD	coordEnd;		// coord of last cmd char....
static int      nBufPos = 0;            // buffer cursor position
static int      nBufLen = 0;            // length of current command
static BOOL     bInsert;                // insert mode
static HANDLE	hOut;			// output buffer handle
static TCHAR*	pPrompt;		// allocated buffer to store prompt
static int      nPromptSize;            // num chars in prompt buffer
static WORD     wDefAttr;               // default character attribute
static int      nState = 0;             // input state

static TCHAR	history[50][2049];	// history list
static int      nFirstCmd = -1;         // index of first cmd
static int      nLastCmd = -1;          // index of last command entered
static int      nHistNdx = -1;          // index into history list....
static TCHAR*   pSearchStr = 0;         // search criteria buffer (allocated)

void
IncCoord(
    COORD* coord,
    int nDelta
    )
{
    coord->X += (SHORT)nDelta;
    if ( coord->X < 0 )
    {
        coord->Y += coord->X/nConsoleWidth - 1;
        coord->X = nConsoleWidth - (-coord->X)%nConsoleWidth;
    }
    else
    if ( coord->X >= nConsoleWidth )
    {
         coord->Y += coord->X / nConsoleWidth;
         coord->X %= nConsoleWidth;
    }
}

void
GetOffsetCoord(
    TCHAR* pBuf,
    int nOffset,
    COORD* coord
    )
{
    int ndx;

    // let's walk the buffer to find the correct coord....
    *coord = coordStart;
    for( ndx=0; ndx<nOffset; ++ndx )
    {
        if ( pBuf[ndx] == 9 )
        {
            int nTab;
            for ( nTab=1; (nTab+coord->X)%8 ; ++nTab );
            coord->X += nTab-1;
        }
        else
        if ( pBuf[ndx] < 32 )
            ++coord->X;
        IncCoord( coord, +1 );
    }
}

int
ScrollTo(
    TCHAR* pBuf,
    COORD* coord
    )
{
    int nLines = 0;
    SMALL_RECT rectFrom;
    COORD coordTo;
    CHAR_INFO cBlank;
    // get some data....
    cBlank.Char.AsciiChar = ' ';
    cBlank.Attributes = wDefAttr;

    coordTo.X = 0;
    rectFrom.Left = 0;
    rectFrom.Right = nConsoleWidth - 1;

    // scroll it....
    if ( coord->Y < 0 )
    {
        // scroll down....
        nLines = coord->Y;
        rectFrom.Top = 0;
        rectFrom.Bottom = nConsoleHeight + nLines - 1;
        coordTo.Y = -nLines;
        ScrollConsoleScreenBuffer( hOut, &rectFrom, NULL, coordTo, &cBlank );
    }
    else
    {
        // scroll up....
        nLines = coord->Y - nConsoleHeight + 1;
        rectFrom.Top = (SHORT)nLines;
        rectFrom.Bottom = nConsoleHeight - 1;
        coordTo.Y = 0;
        ScrollConsoleScreenBuffer( hOut, &rectFrom, NULL, coordTo, &cBlank );
    }

    // adjust start/end coords and orig coord to reflect new scroll....
    coordStart.Y -= (SHORT)nLines;
    coordEnd.Y -= (SHORT)nLines;
    coord->Y -= (SHORT)nLines;

    // redraw the whole command AND the prompt.....
    ShowBuf( pBuf, -1 );

    return nLines;
}

void
AdjCursor(
    TCHAR* pBuf
    )
{
    COORD coordCursor;
    GetOffsetCoord( pBuf, nBufPos, &coordCursor );
    if ( coordCursor.Y < 0 || coordCursor.Y >= nConsoleHeight )
    {
        // scroll it....
        ScrollTo( pBuf, &coordCursor );
    }
    SetConsoleCursorPosition( hOut, coordCursor );
}

void
AdjCursorSize( void )
{
    CONSOLE_CURSOR_INFO cci;
    cci.bVisible = TRUE;
    if ( bInsert == bInsertDefault )
        cci.dwSize = 13;
    else
        cci.dwSize = 40;
    SetConsoleCursorInfo( hOut, &cci );
}

void
AdvancePos(
    TCHAR* pBuf,
    int nDelta,
    DWORD dwKeyState
    )
{
    // see if control key down....
    if ( (dwKeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) != 0 )
    {
        if ( nDelta > 0 )
        { // skip to NEXT word....
            while ( nBufPos < nBufLen && !isspace(pBuf[nBufPos]) )
                ++nBufPos;
            while ( nBufPos < nBufLen && isspace(pBuf[nBufPos]) )
                ++nBufPos;
        }
        else
        {   // skip to PREVIOUS word....
            // if already at beginning of word, back up one....
            if ( nBufPos > 0 && isspace(pBuf[nBufPos-1]) )
                --nBufPos;
            // skip white space....
            while ( nBufPos > 0 && isspace(pBuf[nBufPos]) )
                --nBufPos;
            // skip non-ws....
            while ( nBufPos > 0 && !isspace(pBuf[nBufPos-1]) )
                --nBufPos;
        }
    }
    else
        nBufPos += nDelta;

    AdjCursor( pBuf );
}

void
ShowBuf(
    TCHAR* pBuf,
    int nFromPos
    )
{
	DWORD cPrint;
	COORD coord, cPrompt;
	TCHAR temp[8];
	int ndx;

	// see if we want the prompt, too....
	if ( nFromPos < 0 )
	{
		nFromPos = 0;
		GetOffsetCoord( pBuf, 0, &coord );
		cPrompt = coord;
		cPrompt.X -= (SHORT)nPromptSize;
		WriteConsoleOutputCharacter( hOut, pPrompt, nPromptSize, cPrompt, &cPrint );
	}
	else
		GetOffsetCoord( pBuf, nFromPos, &coord );

	// walk the rest of the buffer, displaying as we go....
	for( ndx=nFromPos;ndx < nBufLen; ++ndx )
	{
		if ( pBuf[ndx] == 9 )
		{
			int nTab;
                        temp[0] = TEXT(' ');
			for ( nTab=1; (nTab+coord.X)%8; ++nTab )
			{
                                temp[nTab] = TEXT(' ');
			}
			WriteConsoleOutputCharacter( hOut, temp, nTab, coord, &cPrint );
			coord.X += nTab-1;
		}
		else if ( pBuf[ndx] < 32 )
		{
			temp[0] = '^';
			temp[1] = pBuf[ndx] + 'A' - 1;
			WriteConsoleOutputCharacter( hOut, temp, 2, coord, &cPrint );
			++coord.X;
		}
		else
			WriteConsoleOutputCharacter( hOut, pBuf + ndx, 1, coord, &cPrint );
		// advance cursor.....
		IncCoord( &coord, +1 );
	}
	// now blank out the rest.....
        temp[0] = TEXT(' ');
	while ( coordEnd.Y > coord.Y || (coordEnd.Y == coord.Y && coordEnd.X >= coord.X) )
	{
		WriteConsoleOutputCharacter( hOut, temp, 1, coordEnd, &cPrint );
		IncCoord( &coordEnd, -1 );
	}
	// save the new ending....
	coordEnd = coord;
}

void
ShiftBuffer(
    TCHAR* pBuf,
    int cch,
    int nFrom,
    int nDelta
    )
{
	int ndx;
	// which direction?
	if ( nDelta > 0 )
	{
		// move all (including this character) out one place....
		for( ndx = nBufLen; ndx > nFrom; --ndx )
			pBuf[ndx] = pBuf[ndx-1];
		++nBufLen;
	}
	else if ( nDelta < 0 )
	{
		// move all characters in one place (over this character)...
		for( ndx = nFrom; ndx < nBufLen; ++ ndx )
			pBuf[ndx] = pBuf[ndx+1];
		--nBufLen;
	}
}

void
LoadHistory(
    TCHAR* pBuf,
    int cch,
    TCHAR* pHist
    )
{
	// first go to the front of the line....
	nBufPos = 0;
	AdjCursor( pBuf );
	// then blank-out the current buffer....
	if ( nBufLen )
	{
		nBufLen = 0;
		ShowBuf( pBuf, 0 );
	}
	// now copy in the new one (if there is one)....
	if ( pHist )
	{
		_tcsncpy( pBuf, pHist, cch );
		nBufLen = _tcslen( pHist );
		// move to the end of the line....
		nBufPos = nBufLen;
		AdjCursor( pBuf );
		// show the whole buffer from the start....
		ShowBuf( pBuf, 0 );
	}
}

void
SearchHist(
    TCHAR* pBuf,
    int cch
    )
{
    int ndx, nSearch, nStop;
    // if we're in input mode, set ndx to AFTER last command....
    if ( nState == 0 )
        ndx = (nLastCmd+1)%50;
    else
        ndx = nHistNdx;

    nStop = ndx; // don't search past here

    // if not already in search mode, get a copy of the target....
    if ( nState != 4 )
    {
        // if there already is a search string, get rid of it....
        if ( pSearchStr )
            free( pSearchStr );
        // pSearchStr and copy a new search string....
        pSearchStr = calloc( nBufLen+1, sizeof(TCHAR) );
        if (pSearchStr == NULL) {
            return;
        }
        _tcsncpy( pSearchStr, pBuf, nBufLen );
        pSearchStr[nBufLen] = 0;
    }
    nSearch = _tcslen( pSearchStr );
    // enter search mode....
    nState = 4;
    do
    {
        // back up one cmd....
        ndx = (ndx+49)%50;
        // check it....
        if ( _tcsncmp( history[ndx], pSearchStr, nSearch ) == 0 )
        {
            // found a match....
            nHistNdx = ndx;
            LoadHistory( pBuf, cch, history[ndx] );
            break;
        }

    } while ( ndx != nStop );
}

int touched = 1;

BOOL
ProcessKey(
    const KEY_EVENT_RECORD* keyEvent,
    TCHAR* pBuf,
    int cch,
    DWORD dwCtrlWakeupMask,
    PBOOL bWakeupKeyHit
    )
{
    BOOL bDone = FALSE;
    TCHAR ch;

    *bWakeupKeyHit = FALSE;
    ch = keyEvent->uChar.AsciiChar;
    if ( keyEvent->wVirtualKeyCode == VK_SPACE )
            ch = TEXT(' ');

    switch ( keyEvent->wVirtualKeyCode )
    {
        case VK_RETURN:
            bDone = TRUE;
            // move cursor to end of cmd, if not already there....
            if ( nBufPos != nBufLen )
            {
                nBufPos = nBufLen;
                AdjCursor( pBuf );
            }
            // add the NLN to end of cmd....
            pBuf[nBufLen] = _T('\n');
            ++nBufLen;
            touched = 1;
            break;

        case VK_BACK:
            if ( nBufPos > 0 )
            {
                // return to input state....
                nState = 0;
                // back up the cursor....
                AdvancePos( pBuf, -1, 0 );
                // shift over this character and print....
                ShiftBuffer( pBuf, cch, nBufPos, -1 );
                ShowBuf( pBuf, nBufPos );
                touched = 1;
            }
            break;

        case VK_END:
            if ( nBufPos != nBufLen )
            {
                // doesn't affect state....
                nBufPos = nBufLen;
                AdjCursor( pBuf );
            }
            break;

        case VK_HOME:
            if ( nBufPos )
            {
                // doesn't affect state....
                nBufPos = 0;
                AdjCursor( pBuf );
            }
                break;

        case VK_LEFT:
            // doesn't affect state....
            if ( nBufPos > 0 )
                AdvancePos( pBuf, -1, keyEvent->dwControlKeyState );
            break;

        case VK_RIGHT:
            // doesn't affect state....
            if ( nBufPos < nBufLen )
                AdvancePos( pBuf, +1, keyEvent->dwControlKeyState );
            break;

        case VK_INSERT:
            // doesn't affect state....
            bInsert = !bInsert;
            AdjCursorSize();
            break;

        case VK_DELETE:
            if ( nBufPos < nBufLen )
            {
                // fall back to input state....
                nState = 0;
                // shift over this character and print....
                ShiftBuffer( pBuf, cch, nBufPos, -1 );
                ShowBuf( pBuf, nBufPos );
                touched = 1;
            }
            break;

        case VK_F8:
            // if there's something to match....
            if ( nBufLen != 0 )
            {
                // if we're not already at the top of the list....
                //if ( nHistNdx != nFirstCmd )
                //{
                    // search backwards up the list....
                    SearchHist( pBuf, cch );
                //}
                touched = 1;
                break;
            }
            // fall through if there's nothing to match with....
            // same as pressing up arrow....

        case VK_UP:
            // if we're not already at the top of the list....
            if ( nState == 0 || nHistNdx != nFirstCmd )
            {
                if ( nState == 0 )
                    nHistNdx = nLastCmd;
                else
                    nHistNdx = (nHistNdx+49)%50;

                LoadHistory( pBuf, cch, history[nHistNdx] );
                // scrolling through history....
                nState = 2;
                touched = 1;
            }
            break;

        case VK_DOWN:
            if ( nState == 0 || nHistNdx == nLastCmd )
            {
                // blank out command buffer...
                LoadHistory( pBuf, cch, NULL );
                // return to input state....
                nState = 0;
            }
            else
            {
                // get the next one....
                nHistNdx = (nHistNdx+1)%50;
                LoadHistory( pBuf, cch, history[nHistNdx] );
                // scrolling through history....
                nState = 2;
            }
            touched = 1;
            break;

        case VK_ESCAPE:
            // blank-out the command buffer....
            LoadHistory( pBuf, cch, NULL );
            // return to input....
            nState = 0;
            touched = 1;
            break;

        default:
            // if printable character, let's add it in....
            if ( ch >= 1 && ch <= 255 )
            {
                touched = 1;
                // fall back to input state....
                nState = 0;
                // see if there's room....
                if ( nBufPos >= cch || (bInsert && nBufLen >= cch) )
                    MessageBeep( MB_ICONEXCLAMATION );
                else
                {
                    if ( bInsert )
                    {
                        // shift the buffer out for the insert....
                        ShiftBuffer( pBuf, cch, nBufPos, +1 );
                    }
                    else
                    if ( nBufPos >= nBufLen )
                        ++nBufLen;

                    // place the character in the buffer at the current pos....
                    pBuf[nBufPos] = ch;

                    if (ch < TEXT(' ') && (dwCtrlWakeupMask & (1 << ch))) {
                        *bWakeupKeyHit = TRUE;
                        AdjCursor(pBuf);
                        bDone = TRUE;
                    } else {
                        // show from this position on....
                        ShowBuf( pBuf, nBufPos );
                        // advance position/cursor....
                        AdvancePos( pBuf, +1, 0 );
                    }
                }
            }
    }

    return bDone;
}

static UINT nOldIndex =0;
static DWORD cRead = 0;
static INPUT_RECORD ir[32];
BOOL bInsertDefault = FALSE;

BOOL
Win95ReadConsoleA(
    HANDLE hIn,
    LPSTR pBuf,
    DWORD cch,
    LPDWORD pcch,
    LPVOID lpReserved
    )
{
    PCONSOLE_READCONSOLE_CONTROL pInputControl;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    const KEY_EVENT_RECORD* keyEvent;
    BOOL bOk = TRUE;                // return status value
    DWORD dwc, dwOldMode;
    DWORD dwCtrlWakeupMask;
    BOOL bWakeupKeyHit;

    // initialize the state variables....
    nState  = 0;    // input mode
    nBufPos = 0;    // buffer cursor position
    nBufLen = 0;    // length of current command
    bInsert = bInsertDefault;       // insert mode

    // set the appropriate console mode....
    if (!GetConsoleMode( hIn, &dwOldMode ))
        return FALSE;
    SetConsoleMode( hIn, ENABLE_PROCESSED_INPUT );

    // get the ouput buffer handle....
    hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if ( hOut == INVALID_HANDLE_VALUE )
    {
        DWORD dwErr = GetLastError();
        hOut = CRTTONT( STDOUT );
    }

    // get the output console info....
    if ( GetConsoleScreenBufferInfo( hOut, &csbi ) == FALSE )
        return FALSE;

    // save size and initial cursor pos and console width....
    coordStart = coordEnd = csbi.dwCursorPosition;
    nConsoleWidth = csbi.dwSize.X;
    nConsoleHeight = csbi.dwSize.Y;
    wDefAttr = csbi.wAttributes;
    // allocate a buffer to hold whatever is before command....
    nPromptSize = 0;
    if ( coordStart.X > 0 )
    {
        COORD cPrompt;
        DWORD dwRead;

        nPromptSize = coordStart.X;
        cPrompt = coordStart;
        cPrompt.X = 0;
        pPrompt = calloc( nPromptSize+1, sizeof(TCHAR) );
        if (pPrompt == NULL) {
            PutStdErr( MSG_NO_MEMORY, NOARGS );
            Abort( );
        }
        // now copy the data....
        ReadConsoleOutputCharacter( hOut, pPrompt, nPromptSize,
                cPrompt, &dwRead );
        // NULL-terminate it....
        pPrompt[dwRead] = 0;
    }
    AdjCursorSize();

    pInputControl = (PCONSOLE_READCONSOLE_CONTROL)lpReserved;
    if (pInputControl != NULL && pInputControl->nLength == sizeof(*pInputControl)) {
        dwCtrlWakeupMask = pInputControl->dwCtrlWakeupMask;
        nBufLen = pInputControl->nInitialChars;
        nBufPos = pInputControl->nInitialChars;
    } else {
        pInputControl = NULL;
        dwCtrlWakeupMask = 0;
    }
    while ( !CtrlCSeen )
    {
        // get the next input record....
        UINT ndx;
        if( nOldIndex == 0 )
            ReadConsoleInput( hIn, ir, sizeof(ir)/sizeof(INPUT_RECORD), &cRead );

        // process all the records we just received....
        for( ndx=nOldIndex; ndx < cRead; ++ndx )
        {
            // process only key down events....
            keyEvent = &(ir[ndx].Event.KeyEvent);
            if( ir[ndx].EventType == KEY_EVENT &&
                keyEvent->bKeyDown &&
                ProcessKey( keyEvent, pBuf, cch, dwCtrlWakeupMask, &bWakeupKeyHit )
              )
            {
                if (pInputControl != NULL)
                    pInputControl->dwControlKeyState = keyEvent->dwControlKeyState;
                goto donereading;
            }
        }
        if( cRead == ndx ) {
                nOldIndex = 0;
        } else {
                nOldIndex = ndx + 1;
        }
    }
donereading:
    // clean-up....
    if ( pPrompt ) {
        free( pPrompt );
        pPrompt = NULL;
    }
    if ( pSearchStr ) {
        free( pSearchStr );
        pSearchStr = NULL;
    }

    if (!bWakeupKeyHit) {
        // not okay if we Ctrl-C'ed out....
        if ( CtrlCSeen )
        {
            bOk = FALSE;
            nBufPos = nBufLen;
            AdjCursor( pBuf );
            *pcch = 0;
        }
        else
        {
            // save to history (less the NLN) if something entered....
            if ( nBufLen > 1 )
            {
                nLastCmd = (nLastCmd+1)%50;
                // adjust the first for wrap-around....
                if ( nLastCmd == nFirstCmd || nFirstCmd == -1 )
                        nFirstCmd = (nFirstCmd+1)%50;
                _tcsncpy( history[nLastCmd], pBuf, nBufLen-1 );
                // null-terminate....
                history[nLastCmd][nBufLen-1] = 0;
            }
            *pcch = nBufLen;
        }

        // go to next line....
        WriteConsole( hOut, _T("\n\r"), 2, &dwc, NULL );
        FlushConsoleInputBuffer( hIn );
    } else {
        *pcch = nBufLen;
    }

    // restore the console mode....
    SetConsoleMode( hIn, dwOldMode );

    return bOk;
}

#endif // ifdef WIN95_CMD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cmd\makefile.inc ===
!IF "$(RCCODEPAGE)"=="932"
..\cmd.rc: $(O)\cmdmsg.rc $(O)\msg00411.bin $(O)\msg00001.bin
!ELSE
..\cmd.rc: $(O)\cmdmsg.rc $(O)\msg00001.bin
!ENDIF

!IF "$(RCCODEPAGE)"=="932"
$(O)\cmdmsg.h $(O)\cmdmsg.rc $(O)\msg00411.bin $(O)\msg00001.bin: ..\cmdmsg.mc
!ELSE
$(O)\cmdmsg.h $(O)\cmdmsg.rc $(O)\msg00001.bin: ..\cmdmsg.mc
!ENDIF
    mc -v -h $(O) -r $(O) -m 3000 ..\cmdmsg.mc

..\ctools2.c: ..\ctable.h

..\cmd.h: ..\cmdproto.h ..\console.h ..\dir.h $(O)\cmdmsg.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\dos\dos.c ===
#include "cmd.h"
#include "cmdproto.h"

static BOOL bErrorMode = 0;

BOOL
APIENTRY
SetErrorMode(
    BOOL bMode
    )
{
    BOOL bOldMode;

    bOldMode = bErrorMode;
    bErrorMode = bMode;
    return bOldMode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\string.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    string.c

Abstract:

    String processing support

--*/

#include "cmd.h"

/***
 *
 * This file contains routines for finding the last character and the
 * penultimate (next to last) character of a string. And finally, a routine
 * (prevc) to return a pointer to the previous character given a pointer
 * to an entire string and a pointer to a character within the string.
 *
 *  John Tupper, Microsoft
 */

//
// DbcsLeadCharTable contains 256 BOOL entries. Each entry signifies
// whether the character used to look-up the table is a DBCS lead byte.
// This table needs to be updated whenever Cmd's codepage is changed.
// Dbcsleadchar is accessed by the is_dbcsleadchar macro defined in Cmd.h.
//

BOOLEAN DbcsLeadCharTable[ 256 ];

//
// AnyDbcsLeadChars is an optimization. It tells us of there are any DBCS
// lead chars currently defined in DbcsLeadCharTable. If it is FALSE, then
// we don't have to use DBCS aware string functions.
//

extern CPINFO CurrentCPInfo;
extern UINT CurrentCP;
BOOLEAN AnyDbcsLeadChars = FALSE;

VOID
InitializeDbcsLeadCharTable(
    )

{

    UINT  i, k;

    if (! GetCPInfo((CurrentCP=GetConsoleOutputCP()), &CurrentCPInfo )) {
        //
        // GetCPInfo failed. What should we do ?
        //
#ifdef FE_SB
	LCID lcid = GetThreadLocale();
        if (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE) {
            CurrentCPInfo.LeadByte[0] = 0x81;
            CurrentCPInfo.LeadByte[1] = 0x9f;
            CurrentCPInfo.LeadByte[2] = 0xe0;
            CurrentCPInfo.LeadByte[3] = 0xfc;
            CurrentCPInfo.LeadByte[4] = 0;
            CurrentCPInfo.LeadByte[5] = 0;
	}
	else if (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE) {
	    if (SUBLANGID(LANGIDFROMLCID(lcid)) == SUBLANG_CHINESE_SIMPLIFIED)
		CurrentCPInfo.LeadByte[0] = 0x81;  /* 0xa1 */
	    else
		CurrentCPInfo.LeadByte[0] = 0x81;
	    CurrentCPInfo.LeadByte[1] = 0xfe;
	    CurrentCPInfo.LeadByte[2] = 0;
	    CurrentCPInfo.LeadByte[3] = 0;
	}
	else if (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN) {
	    CurrentCPInfo.LeadByte[0] = 0x81;
	    CurrentCPInfo.LeadByte[1] = 0xfe;
	    CurrentCPInfo.LeadByte[2] = 0;
	    CurrentCPInfo.LeadByte[3] = 0;
	}
	else {
	    CurrentCPInfo.LeadByte[0] = 0;
	    CurrentCPInfo.LeadByte[1] = 0;
	}
#else
        CurrentCPInfo.LeadByte[0] = 0;
        CurrentCPInfo.LeadByte[1] = 0;
#endif
    }

    memset( DbcsLeadCharTable, 0, 256 * sizeof (BOOLEAN)  );
    for (k=0 ; CurrentCPInfo.LeadByte[k] && CurrentCPInfo.LeadByte[k+1]; k+=2) {
        for (i=CurrentCPInfo.LeadByte[k] ; i<=CurrentCPInfo.LeadByte[k+1] ; i++)
            DbcsLeadCharTable[i] = TRUE;
    }
    if ( CurrentCPInfo.LeadByte[0] && CurrentCPInfo.LeadByte[1] )
        AnyDbcsLeadChars = TRUE;
    else
        AnyDbcsLeadChars = FALSE;

}

 /***
 * mystrchr(string, c) - search a string for a character
 *
 * mystrchr will search through string and return a pointer to the first
 * occurance of the character c. This version of mystrchr knows about
 * double byte characters. Note that c must be a single byte character.
 *
 */

TCHAR *
mystrchr(TCHAR const *string, TCHAR c)
{
    /* handle null seperatly to make main loop easier to code */
    if (string == NULL)
        return(NULL);

    return _tcschr( string, c );
}


/***
 * mystrrchr(string, c) - search a string for a character
 *
 * mystrchr will search through string and return a pointer to the last
 * occurance of the character c. This version of mystrrchr knows about
 * double byte characters. Note that c must be a single byte character.
 *
 */

TCHAR *
mystrrchr(TCHAR const *string, TCHAR c)
{
    /* handle null seperatly to make main loop easier to code */
    if ((TCHAR *)string == NULL)
        return(NULL);

    return _tcsrchr( string, c );
}



/***
 * mystrcspn (str1, str2) will find the first character of str1 that is also
 * in str2.
 * Return value:
 *      if a match is found return the position in str1 where the matching
 *              character was found (the first position is 0).
 *      If nomatch is found, return the position of the trailing null.
 */

size_t
mystrcspn(str1, str2)
TCHAR const *str1;
TCHAR const *str2;
{
    TCHAR c;
    int position = 0;

    if ((str1 == NULL) || (str2 == NULL))
        return (0);

    /* Since str2 may not contain any double byte characters,
       when we see a double byte character in str1, we just skip it.
       Otherwise, use mystrchr to see if we have a match */
    while (c = *str1++) {
        if (mystrchr(str2, c))
                break;
        position++;
    }

    return(position);
}


/***
 * lastc - return a pointer to the last character of the argument string
 * not including the trailing null. If a pointer to a zero length string
 * is passed, a pointer to the original string is returned.
 */
TCHAR *lastc(str)
TCHAR *str;
{
    TCHAR *last = str;

    while(*str)
        last = str++;

    return(last);
}



/***
 *
 * penulc returns a pointer to the penultimate (next to last) character
 * of the argument string not including the trailing null.
 * If a pointer to a zero or one length string is passed, a pointer to
 * the orignial string is returned.
 */
TCHAR *penulc(str)
TCHAR *str;
{
    TCHAR *last = str;
    TCHAR *penul = str;

    while(*str) {
        penul = last;
        last = str;
        str++;
    }
    return(penul);
}



/***
 *
 * prevc(str1, str2) assumes that str2 points to a character within
 * str1. prevc will return a pointer to the previous character (right
 * before str2). If str2 points outside of str1, NULL is returned.
 */

TCHAR *prevc(str1, str2)
TCHAR *str1, *str2;
{
    TCHAR *prev = str1;

    while (str1 != str2) {
        if (!*str1)
            return(NULL);
        prev = str1;
        str1++;
    }

    return(prev);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\tree.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    tree.c

Abstract:

    Tree walking

--*/

#include "cmd.h"

extern   TCHAR CurDrvDir[] ;
extern   TCHAR *SaveDir ;
extern   DWORD DosErr ;
extern   BOOL CtrlCSeen;

PTCHAR   SetWildCards( PTCHAR, BOOLEAN );
BOOLEAN  IsFATDrive( PTCHAR );
VOID     SortFileList( PFS, PSORTDESC, ULONG);
BOOLEAN  FindFirstNt( PTCHAR, PWIN32_FIND_DATA, PHANDLE );
BOOLEAN  FindNextNt ( PWIN32_FIND_DATA, HANDLE );

STATUS
BuildFSFromPatterns (
    IN  PDRP     pdpr,
    IN  BOOLEAN  fPrintErrors,
    IN  BOOLEAN  fAddWild,
    OUT PFS *    ppfs
    )
{

    PCPYINFO    pcisFile;
    TCHAR               szCurDir[MAX_PATH + 2];
    TCHAR               szFilePattern[MAX_PATH + 2];
    PTCHAR              pszPatternCur;
    PPATDSC             ppatdscCur;
    PFS                 pfsFirst;
    PFS                 pfsCur;
    ULONG               cbPath;
    BOOLEAN             fFatDrive;
    ULONG               i;
    PTCHAR              pszT;

    //
    // determine FAT drive from original pattern.
    // Used in several places to control name format etc.
    //
    DosErr = 0;

    //
    // Run through each pattern making all sorts of FAT etc. specific
    // changes to it and creating the directory list for it. Then
    // combine groups of patterns into common directories and recurse
    // for each directory group.
    //

    *ppfs = pfsFirst = (PFS)gmkstr(sizeof(FS));
    pfsFirst->pfsNext = NULL;
    pfsFirst->pszDir = NULL;
    pfsCur = pfsFirst;
    pfsCur->cpatdsc = 1;

    for(i = 1, ppatdscCur = &(pdpr->patdscFirst);
        i <= pdpr->cpatdsc;
        i++, ppatdscCur = ppatdscCur->ppatdscNext) {

        pszPatternCur = ppatdscCur->pszPattern;

        if (!(fFatDrive = IsFATDrive(pszPatternCur)) && DosErr) {

            //
            // Error in determining file system type so get out.
            //
            if (fPrintErrors) PutStdErr(DosErr, NOARGS);
            return( FAILURE );

        }
        ppatdscCur->fIsFat = fFatDrive;

        //
        // Do any alterations that require wild cards for searching
        // such as change .xxx to *.xxx for FAT file system requests
        //
        // Note that if the return values is a different buffer then
        // the input the input will be freed when we are done with the
        // Dir command.
        //
        //
        // Note that though SetWildCards will allocate heap for the
        // modified pattern this will get freed when FreeStack is
        // called at the end of the Dir call.
        //
        // An out of memory is the only reason to fail and we would not
        // return from that but go through the abort call in gmstr
        //

        if (fAddWild) {

            pszT = SetWildCards(pszPatternCur, fFatDrive);
            FreeStr(pszPatternCur);
            pszPatternCur = pszT;

        }

        //
        // Convert the current pattern into a path and file part
        //
        // Save the current directory in SaveDir, change to new directory
        // and parse pattern into a copy information structure. This also
        // converts pszPatternCur into the current directory which also produces
        // a fully qualified name.
        //

        DosErr = 0;

        DEBUG((ICGRP, DILVL, "PrintPattern pattern `%ws'", pszPatternCur));
        if ((pcisFile = SetFsSetSaveDir(pszPatternCur)) == (PCPYINFO) FAILURE) {

            //
            // DosErr is set in SetFs.. from GetLastError
            //
            if (fPrintErrors) 
                PutStdErr(DosErr, NOARGS);
            return( FAILURE );
        }

        DEBUG((ICGRP, DILVL, "PrintPattern fullname `%ws'", pcisFile->fnptr));

        //
        // CurDrvDir ends in '\' (old code also and a DOT but I do not
        // understand where this would come from I will leave it in for now.
        // Remove the final '\' from a copy of the current directory and
        // print that version out.
        //

        mystrcpy(szCurDir,CurDrvDir);

        //
        // SetFsSetSaveDir changes directories as a side effect. Since all
        // work will be in fully qualified paths we do not need this. Also
        // since we will change directories for each pattern that is examined
        // we will force the directory back to the original each time.
        //
        // This can not be done until after all use of the current directory
        // is made.
        //
        RestoreSavedDirectory( );

        DEBUG((ICGRP, DILVL, "PrintPattern Current Drive `%ws'", szCurDir));

        cbPath = mystrlen(szCurDir);
        
        if (cbPath > 3) {
            if (fFatDrive && *penulc(szCurDir) == DOT) {
                szCurDir[cbPath-2] = NULLC;
            } else {
                szCurDir[cbPath-1] = NULLC;
            }
        }

        //
        // If no room for filename then return
        //
        if (cbPath >= MAX_PATH -1) {

            if (fPrintErrors) PutStdErr( ERROR_FILE_NOT_FOUND, NOARGS );
            return(FAILURE);

        }

        //
        // Add filename and possibly ext to szSearchPath
        // if no filename or ext, use "*"
        //
        // If pattern was just extension the SetWildCard had already
        // added * to front of extension.
        //
        if (*(pcisFile->fnptr) == NULLC) {

            mystrcpy(szFilePattern, TEXT("*"));

        } else {

            mystrcpy(szFilePattern, pcisFile->fnptr);

        }

        DEBUG((ICGRP, DILVL, "DIR:PrintPattern  Pattern to search for `%ws'", szFilePattern));

        //
        // Is name too long
        //
        if ((cbPath + mystrlen(szFilePattern) + 1) > MAX_PATH ) {

            if (fPrintErrors) PutStdErr(ERROR_BUFFER_OVERFLOW, NOARGS);
            return( FAILURE );

        } else {

            //
            // If this is a FAT drive and there was a filename with
            // no extension then add '.*' (and there is room)
            //
            if (*pcisFile->fnptr && (!pcisFile->extptr || !*pcisFile->extptr) &&
                ((mystrlen(szFilePattern) + 2) < MAX_PATH) && fFatDrive && fAddWild) {
                mystrcat(szFilePattern, TEXT(".*")) ;
            }
        }

        //
        // ppatdscCur->pszPattern will be freed at end of command when everything
        // else is freed.
        //
        ppatdscCur->pszPattern = (PTCHAR)gmkstr(_tcslen(szFilePattern)*sizeof(TCHAR) + sizeof(TCHAR));
        mystrcpy(ppatdscCur->pszPattern, szFilePattern);
        ppatdscCur->pszDir = (PTCHAR)gmkstr(_tcslen(szCurDir)*sizeof(TCHAR) + sizeof(TCHAR));
        mystrcpy(ppatdscCur->pszDir, szCurDir);

        if (pfsCur->pszDir) {

            //
            // changing directories so change directory grouping.
            //
            if (_tcsicmp(pfsCur->pszDir, ppatdscCur->pszDir)) {

                pfsCur->pfsNext = (PFS)gmkstr(sizeof(FS));
                pfsCur = pfsCur->pfsNext;
                pfsCur->pszDir = (PTCHAR)gmkstr(_tcslen(ppatdscCur->pszDir)*sizeof(TCHAR) + sizeof(TCHAR));
                mystrcpy(pfsCur->pszDir, ppatdscCur->pszDir);
                pfsCur->pfsNext = NULL;
                pfsCur->fIsFat = ppatdscCur->fIsFat;
                pfsCur->ppatdsc = ppatdscCur;
                pfsCur->cpatdsc = 1;

            } else {

                pfsCur->cpatdsc++;

            }

        } else {

            //
            // Have not filled in current fs descriptor yet.
            //
            pfsCur->pszDir = (PTCHAR)gmkstr(_tcslen(ppatdscCur->pszDir)*sizeof(TCHAR) + 2*sizeof(TCHAR));
            mystrcpy(pfsCur->pszDir, ppatdscCur->pszDir);
            pfsCur->fIsFat = ppatdscCur->fIsFat;
            pfsCur->ppatdsc = ppatdscCur;

        }

    } // while for running through pattern list

    return( SUCCESS );

}

STATUS
AppendPath(
    OUT PTCHAR Buffer,
    IN ULONG BufferCount,
    IN PTCHAR Prefix,
    IN PTCHAR Suffix
    )
{
    if (mystrlen( Prefix ) + 1 + mystrlen( Suffix ) + 1 > BufferCount) {
        return(ERROR_BUFFER_OVERFLOW);
    }

    mystrcpy( Buffer, Prefix );

    //
    //  Append a \ if there isn't one already at the end of the prefix
    //

    if (*lastc( Buffer ) != TEXT('\\')) {
        mystrcat( Buffer, TEXT( "\\" ));
    }

    mystrcat( Buffer, Suffix );

    return( SUCCESS );
}


STATUS
ExpandAndApplyToFS(
    IN  PFS     FileSpec,
    IN  PSCREEN pscr,
    IN  ULONG   AttribMask,
    IN  ULONG   AttribValues,

    IN  PVOID   Data OPTIONAL,
    IN  VOID    (*ErrorFunction) (STATUS, PTCHAR, PVOID) OPTIONAL,
    IN  STATUS  (*PreScanFunction) (PFS, PSCREEN, PVOID) OPTIONAL,
    IN  STATUS  (*ScanFunction) (PFS, PFF, PSCREEN, PVOID) OPTIONAL,
    IN  STATUS  (*PostScanFunction) (PFS, PSCREEN, PVOID) OPTIONAL
    )
/*++

Routine Description:
    Expand a given FS and apply the dispatch functions to it.  The pff field is
    set to point to the packed set of Win32 find records and the array of pointers
    is set up as well.

Arguments:

    FileSpec - FS pointer to expand.

    AttribMask - mask for attributes we care about when matching

    AttribValues - attributes that must match to satisfy the enumeration

    Data - pointer to caller data passed to functions

    ErrorFunction - routine to call on pattern matching errors

    PreScanFunction - routine to call before enumeration begins

    ScanFunction - routine to call during enumeration

    PostScanFunction - routine to call after enumeration is complete

Return Value:

    If any of the applied functions returns a non-SUCCESS status, we return that.

    If no matching file is ever found then ERROR_FILE_NOT_FOUND.

    Otherwise SUCCESS.

--*/
{
    PFF     CurrentFF;                          //  Pointer to FF begin built
    HANDLE  FindHandle;                         //  Find handle
    ULONG   MaxFFSize = CBFILEINC;              //  Current max size of FF buffer
    ULONG   CurrentFFSize = 0;                  //  Bytes in use in FF
    PPATDSC CurrentPattern;                     //  Current pattern being expanded
#define SEARCHBUFFERLENGTH  (MAX_PATH + 2)
    TCHAR   szSearchPath[SEARCHBUFFERLENGTH];
    ULONG   i;                                  //  loop count for patterns
    PTCHAR  p;
    STATUS Status;
    BOOL    FoundAnyFile = FALSE;

    DosErr = SUCCESS;

    //
    //  Initialize the FS structure:
    //      Allocate default size FF array
    //      Indicate no files stored
    //

    FileSpec->pff = CurrentFF = (PFF)gmkstr( MaxFFSize );
    FileSpec->cff = 0;
    FileSpec->FileCount = 0;
    FileSpec->DirectoryCount = 0;
    FileSpec->cbFileTotal.QuadPart = 0;

    for(i = 1, CurrentPattern = FileSpec->ppatdsc;
        i <= FileSpec->cpatdsc;
        i++, CurrentPattern = CurrentPattern->ppatdscNext ) {

        //
        //  Check immediately if a control-c was hit before
        //  doing file I/O (which may take a long time on a slow link)
        //

        if (CtrlCSeen) {
            return FAILURE;
        }

        //
        //  Build enumeration path.  Handle buffer overflow.
        //

        if (AppendPath( szSearchPath, SEARCHBUFFERLENGTH,
                        FileSpec->pszDir, CurrentPattern->pszPattern) != SUCCESS) {
            return ERROR_BUFFER_OVERFLOW;
        }

        if (PreScanFunction != 0) {
            Status = PreScanFunction( FileSpec, pscr, Data );
            if (Status != SUCCESS) {
                return Status;
            }
        }

        //
        //  Fetch all files since we may looking for a file with a attribute that
        //  is not set (a non-directory etc.
        //

        if (!FindFirstNt(szSearchPath, &(CurrentFF->data), &FindHandle)) {

            if (DosErr) {

                //
                //  Map NO_MORE_FILES/ACCESS_DENIED into FILE_NOT_FOUND
                //

                if (DosErr == ERROR_NO_MORE_FILES
                    || DosErr == ERROR_ACCESS_DENIED) {

                    DosErr = ERROR_FILE_NOT_FOUND;

                }

                if (DosErr == ERROR_FILE_NOT_FOUND || DosErr == ERROR_PATH_NOT_FOUND) {

                    if (ErrorFunction != NULL) {
                        ErrorFunction( DosErr, szSearchPath, Data );
                    }

                }

            }

        } else {


            do {

                //
                // Check immediately if a control-c was hit before
                // doing file I/O (which may take a long time on a slow link)
                //

                if (CtrlCSeen) {
                    findclose( FindHandle );
                    return(FAILURE);
                }

                //
                //  Before allowing this entry to be put in the list check it
                //  for the proper attribs
                //
                //  AttribMask is a bit mask of attribs we care to look at
                //  AttribValues is the state these selected bits must be in
                //  for them to be selected.
                //
                // IMPORTANT: both of these must be in the same bit order
                //

                DEBUG((ICGRP, DILVL, " found %ws", CurrentFF->data.cFileName)) ;
                DEBUG((ICGRP, DILVL, " attribs %x", CurrentFF->data.dwFileAttributes)) ;

                if ((CurrentFF->data.dwFileAttributes & AttribMask) !=
                    (AttribValues & AttribMask) ) {
                    continue;
                }

                //
                //  We have an entry that matches.  Set up FF
                //
                //  Compute the true size of the ff entry and don't forget the zero
                //  and the DWORD alignment factor.
                //  Note that CurrentFF->cb is a USHORT to save space. The
                //  assumption is that MAX_PATH is quite a bit less then 32k
                //
                //  To compute remove the size of the filename field since it is at MAX_PATH.
                //  also take out the size of the alternative name field
                //  then add back in the actual size of the field plus 1 byte termination
                //

                FoundAnyFile = TRUE;

                p = (PTCHAR)CurrentFF->data.cFileName;
                p += mystrlen( p ) + 1;

                mystrcpy( p, CurrentFF->data.cAlternateFileName );
                if (*p == TEXT('\0')) {
                    CurrentFF->obAlternate = 0;
                } else {
                    CurrentFF->obAlternate = (USHORT)(p - CurrentFF->data.cFileName);
                }

                p += mystrlen( p ) + 1;

                CurrentFF->cb = (USHORT)((PBYTE)p - (PBYTE)CurrentFF);

                //
                // Adjust count to align on DWORD boundaries for mips and risc
                // machines
                //

                CurrentFF->cb = (CurrentFF->cb + sizeof( DWORD ) - 1) & (-(int)sizeof( DWORD ));

                if ((CurrentFF->data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
                    FileSpec->FileCount++;
                } else {
                    FileSpec->DirectoryCount++;
                }

                //
                //  The FF is built.  Call the enumeration function
                //

                if (ScanFunction != NULL) {
                    Status = ScanFunction( FileSpec, CurrentFF, pscr, Data );
                    if (Status != SUCCESS) {
                        findclose( FindHandle );
                        return Status;
                    }
                }

                //
                //  If there's no scanning function, save the results
                //

                if (ScanFunction == NULL) {

                    FileSpec->cff ++;

                    //
                    // Update the accounting information for file buffer info.
                    //

                    CurrentFFSize += CurrentFF->cb;
                    CurrentFF = (PFF) ((PBYTE)CurrentFF + CurrentFF->cb);

                    //
                    //  Make sure we can handle a max sized entry.  If not, resize the buffer.
                    //

                    if (CurrentFFSize + sizeof( FF ) >= MaxFFSize ) {

                        MaxFFSize += 64 * 1024;

                        DEBUG((ICGRP, DILVL, "\t size of new pff %d", MaxFFSize ));

                        FileSpec->pff = (PFF)resize( FileSpec->pff, MaxFFSize );
                        if (FileSpec->pff == NULL) {
                            DEBUG((ICGRP, DILVL, "\t Could not resize pff" ));
                            return MSG_NO_MEMORY;
                        }

                        CurrentFF = (PFF)((PBYTE)FileSpec->pff + CurrentFFSize);
                        DEBUG((ICGRP, DILVL, "\t resized CurrentFF new value %lx", CurrentFF)) ;

                    }
                }

            } while (FindNextNt(&CurrentFF->data, FindHandle));

            findclose( FindHandle );
        }

        //
        //  We have an error left over from the FindNext.  If it is NO_MORE_FILES then we
        //  continue only if we have more than one directory.
        //

        if (DosErr != SUCCESS && DosErr != ERROR_NO_MORE_FILES) {

            //
            // If not doing multiple file list then error
            // If multiple have failed but still have files from previous pattern
            //
            if (FileSpec->cpatdsc <= 1) {

                return DosErr ;
            }

        }
    
    }

    //
    //  If we did no scan processing, then we must create the pointers since
    //  SOMEONE is interested in this data.
    //
    if (ScanFunction == NULL && FileSpec->cff != 0) {
        FileSpec->prgpff = (PPFF)gmkstr( sizeof(PFF) * FileSpec->cff );

        CurrentFF = FileSpec->pff;

        for (i = 0; i < FileSpec->cff; i++) {
            FileSpec->prgpff[i] = CurrentFF;
            CurrentFF = (PFF) ((PBYTE)CurrentFF + CurrentFF->cb);
        }
    }

    //
    //  Perform post processing
    //

    Status = SUCCESS;

    if (PostScanFunction != NULL) {
        Status = PostScanFunction( FileSpec, pscr, Data );
    }

    if (Status == SUCCESS && !FoundAnyFile) {
        return ERROR_FILE_NOT_FOUND;
    } else {
        return Status;
    }
}


STATUS
WalkTree(
    IN  PFS     FileSpec,
    IN  PSCREEN pscr,
    IN  ULONG   AttribMask,
    IN  ULONG   AttribValues,
    IN  BOOL    Recurse,

    IN  PVOID   Data OPTIONAL,
    IN  VOID    (*ErrorFunction) (STATUS, PTCHAR, PVOID) OPTIONAL,
    IN  STATUS  (*PreScanFunction) (PFS, PSCREEN, PVOID) OPTIONAL,
    IN  STATUS  (*ScanFunction) (PFS, PFF, PSCREEN, PVOID) OPTIONAL,
    IN  STATUS  (*PostScanFunction) (PFS, PSCREEN, PVOID) OPTIONAL
)

/*++

Routine Description:
    Expand a given FS and apply the dispatch functions to it.  The pff field is
    set to point to the packed set of Win32 find records and the array of pointers
    is set up as well.  Recurse if necessary.

Arguments:

    FileSpec - FS pointer to expand.

    pscr - screen for output

    AttribMask - mask for attributes we care about when matching

    AttribValues - attributes that must match to satisfy the enumeration

    Recurse - TRUE => perform the operation in a directory and then descend to
        children

    Data - pointer to caller data passed to functions

    ErrorFunction - routine to call on pattern matching errors

    PreScanFunction - routine to call before enumeration begins

    ScanFunction - routine to call during enumeration

    PostScanFunction - routine to call after enumeration is complete

Return Value:

    If any of the applied functions returns a non-SUCCESS status, we return that.

    If no matching file is ever found then ERROR_FILE_NOT_FOUND.

    Otherwise SUCCESS.

--*/
{
    STATUS Status;
    FS DirectorySpec;
    FS ChildFileSpec;
    ULONG i;
    BOOL FoundAnyFile = FALSE;

    //
    //  Check for ^C often
    //

    if (CtrlCSeen) {
        return FAILURE;
    }

    Status = ExpandAndApplyToFS( FileSpec,
                                 pscr,
                                 AttribMask,
                                 AttribValues,
                                 Data,
                                 ErrorFunction,
                                 PreScanFunction,
                                 ScanFunction,
                                 PostScanFunction );

    //
    //  If we succeeded, remember that we did some work
    //

    if (Status == SUCCESS) {

        FoundAnyFile = TRUE;

    //
    //  If we got an unknown error, or we got FILE_NOT_FOUND and we're not
    //  recursing, return that error
    //

    } else if ((Status != ERROR_FILE_NOT_FOUND && Status != ERROR_PATH_NOT_FOUND) 
               || !Recurse) {

        return Status;
    }

    //
    //  Free up buffer holding files since we no longer need these.
    //  Move on to determine if we needed to go to another directory
    //

    FreeStr((PTCHAR)(FileSpec->pff));
    FileSpec->pff = NULL;

    if (CtrlCSeen) {
        return FAILURE;
    }

    if (!Recurse)
        return SUCCESS;

    //
    //  Build up a copy of the FileSpec and build a list of all
    //  immediate child directories
    //

    DirectorySpec.pszDir = (PTCHAR)gmkstr( (_tcslen( FileSpec->pszDir ) + 1 ) * sizeof( TCHAR ));
    mystrcpy( DirectorySpec.pszDir, FileSpec->pszDir );
    DirectorySpec.ppatdsc = (PPATDSC)gmkstr( sizeof( PATDSC ) );
    DirectorySpec.cpatdsc = 1;
    DirectorySpec.fIsFat = FileSpec->fIsFat;
    DirectorySpec.pfsNext = NULL;

    if (FileSpec->fIsFat) {
        DirectorySpec.ppatdsc->pszPattern = TEXT("*.*");
    } else {
        DirectorySpec.ppatdsc->pszPattern = TEXT("*");
    }

    DirectorySpec.ppatdsc->pszDir = (PTCHAR)gmkstr( (_tcslen( FileSpec->pszDir ) + 1) * sizeof(TCHAR));
    mystrcpy( DirectorySpec.ppatdsc->pszDir, DirectorySpec.pszDir );
    DirectorySpec.ppatdsc->ppatdscNext = NULL;

    Status = ExpandAndApplyToFS( &DirectorySpec,
                             pscr,
                             FILE_ATTRIBUTE_DIRECTORY,
                             FILE_ATTRIBUTE_DIRECTORY,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL );

    //
    //  If we got an error enumerating the directories, pretend that
    //  we just didn't find any at all.
    //

    if (Status != SUCCESS) {
        DirectorySpec.cff = 0;
        Status = SUCCESS;
    }


    //
    // Check for CtrlC again after calling GetFS because
    // GetFS may have returned failure because CtrlC was hit
    // inside the GetFS function call
    //

    if (CtrlCSeen) {
        return( FAILURE );
    }

    //
    //  Walk the list of found directories, processing each one
    //

    for (i = 0; i < DirectorySpec.cff; i++) {

        PTCHAR DirectoryName;
        ULONG NameLength;

        //
        //  Skip recursing on . and ..
        //

        DirectoryName = DirectorySpec.prgpff[i]->data.cFileName;

        if (!_tcscmp( DirectoryName, TEXT(".") )
            || !_tcscmp( DirectoryName, TEXT("..") )) {
            continue;
        }

        //
        //  Form the new name we will descend into
        //

        NameLength = _tcslen( FileSpec->pszDir ) + 1 +
                     _tcslen( DirectoryName ) + 1;

        if (NameLength > MAX_PATH) {
            PutStdErr( MSG_DIR_TOO_LONG, TWOARGS, FileSpec->pszDir, DirectoryName );
            return ERROR_BUFFER_OVERFLOW;
        }

        memset( &ChildFileSpec, 0, sizeof( ChildFileSpec ));
        ChildFileSpec.pszDir = (PTCHAR)gmkstr( NameLength * sizeof( TCHAR ));

        AppendPath( ChildFileSpec.pszDir, NameLength, FileSpec->pszDir, DirectoryName );

        ChildFileSpec.ppatdsc = FileSpec->ppatdsc;
        ChildFileSpec.cpatdsc = FileSpec->cpatdsc;
        ChildFileSpec.fIsFat = FileSpec->fIsFat;

        Status = WalkTree( &ChildFileSpec,
                            pscr,
                            AttribMask,
                            AttribValues,
                            Recurse,
                            Data,
                            ErrorFunction,
                            PreScanFunction,
                            ScanFunction,
                            PostScanFunction );

        FreeStr( (PTCHAR) ChildFileSpec.pff );
        ChildFileSpec.pff = NULL;
        FreeStr( (PTCHAR) ChildFileSpec.prgpff );
        ChildFileSpec.prgpff = NULL;
        FreeStr( ChildFileSpec.pszDir );
        ChildFileSpec.pszDir = NULL;

        //
        //  If we succeeded, then remember that we actually did something
        //

        if (Status == SUCCESS) {
            FoundAnyFile = TRUE;

        //
        //  If we just couldn't find what we wanted, keep on working
        //

        } else if (Status == ERROR_BUFFER_OVERFLOW 
                   || Status == ERROR_FILE_NOT_FOUND 
                   || Status == ERROR_PATH_NOT_FOUND) {
            Status = SUCCESS;

        } else if ((DirectorySpec.prgpff[i]->data.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) != 0) {
            Status = SUCCESS;
        } else {
            break;
        }

    }

    //
    // At bottom of directory tree, free buffer holding
    // list of directories.
    //
    FreeStr( (PTCHAR)DirectorySpec.pszDir );
    FreeStr( (PTCHAR)DirectorySpec.pff );
    FreeStr( (PTCHAR)DirectorySpec.prgpff );

    if (Status == SUCCESS && !FoundAnyFile) {
        return ERROR_FILE_NOT_FOUND;
    } else {
        return Status;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\start.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    start.c

Abstract:

    Start command support

--*/

#include "cmd.h"

extern UINT CurrentCP;
extern unsigned DosErr;
extern TCHAR CurDrvDir[] ;
extern TCHAR SwitChar, PathChar;
extern TCHAR ComExt[], ComSpecStr[];
extern struct envdata * penvOrig;
extern int   LastRetCode;

WORD
GetProcessSubsystemType(
    HANDLE hProcess
    );

STATUS
getparam(
    IN BOOL LeadingSwitChar,
    IN OUT TCHAR **chptr,
    OUT TCHAR *param,
    IN int maxlen )

/*++

Routine Description:

    Copy the token starting at the current position to an output buffer.
    Terminate the copy on end-of-quotes, unquoted whitespace, unquoted
    switch character, or end-of-line

Arguments:

    LeadingSwitChar - TRUE => we should terminate on unquoted switch character

    chptr - address of pointer to token.  This is advanced over the parsed
        token

    param - destination of copy.  String is NUL terminated

    maxlen - size of destination buffer

Return Value:

    Return: STATUS of copy.  Only failure is buffer exceeded.

--*/


{

    TCHAR *ch2;
    int count = 0;

    BOOL QuoteFound = FALSE;

    ch2 = param;

    //
    //  get characters until a space, tab, slash, or end of line
    //

    while (TRUE) {

        //
        //  If we're at the end of string, then there's no more token
        //

        if (**chptr == NULLC) {
            break;
        }

        //
        //  If we're not quoting and we're at a whitespace or switch char
        //  then there's no more token
        //

        if (!QuoteFound &&
            (_istspace( **chptr ) || (LeadingSwitChar && **chptr == SwitChar))) {
            break;
        }

        //
        //  If there's still room in the buffer, copy in the character and note
        //  if it's a quote or not
        //

        if (count < maxlen) {
            *ch2++ = (**chptr);
            if (**chptr == QUOTE) {
                QuoteFound = !QuoteFound;
            }
        }

        //
        //  Advance over this character
        //

        (*chptr)++;
        count++;
    }

    //
    //  If we've exceeded the buffer, display the error and return failure
    //

    if (count > maxlen) {
        **chptr = NULLC;
        *chptr = *chptr - count - 1;
        PutStdErr(MSG_START_INVALID_PARAMETER, ONEARG, *chptr);
        return(FAILURE);
    } else {
        *ch2 = NULLC;
        return(SUCCESS);
    }
}

/*

 Start /MIN /MAX "title" /P:x,y /S:dx,dy /D:directory /I cmd args

*/



int
Start(
    IN  PTCHAR  pszCmdLine
    )
{


    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ChildProcessInfo;

#ifndef UNICODE
    WCHAR   TitleW[MAXTOKLEN];
    CCHAR   TitleA[MAXTOKLEN];
#endif
    TCHAR   szTitle[MAXTOKLEN];
    TCHAR   szDirCur[MAX_PATH];

    TCHAR   szT[MAXTOKLEN];

    TCHAR   szPgmArgs[MAXTOKLEN];
    TCHAR   szParam[MAXTOKLEN];
    TCHAR   szPgm[MAXTOKLEN];
    TCHAR   szPgmSave[MAXTOKLEN];
    TCHAR   szTemp[MAXTOKLEN];
    TCHAR   szPgmQuoted[MAXTOKLEN];

    HDESK   hdesk;
    HWINSTA hwinsta;
    LPTSTR  p;
    LPTSTR  lpDesktop;
    DWORD   cbDesktop = 0;
    DWORD   cbWinsta = 0;

    TCHAR   flags;
    BOOLEAN fNeedCmd;
    BOOLEAN fNeedExpl;
    BOOLEAN fKSwitch = FALSE;
    BOOLEAN fCSwitch = FALSE;

    PTCHAR  pszCmdCur   = NULL;
    PTCHAR  pszDirCur   = NULL;
    PTCHAR  pszPgmArgs  = NULL;
    PTCHAR  pszEnv      = NULL;
    TCHAR   pszFakePgm[]  = TEXT("cmd.exe");
    ULONG   status;
    struct  cmdnode cmdnd;
    DWORD CreationFlags;
    BOOL SafeFromControlC = FALSE;
    BOOL WaitForProcess = FALSE;
    BOOL b;
    DWORD uPgmLength;
    int      retc;

    szPgm[0] = NULLC;
    szPgmArgs[0] = NULLC;

    pszDirCur = NULL;
    CreationFlags = CREATE_NEW_CONSOLE;


    StartupInfo.cb          = sizeof( StartupInfo );
    StartupInfo.lpReserved  = NULL;
    StartupInfo.lpDesktop   = NULL;
    StartupInfo.lpTitle     = NULL;
    StartupInfo.dwX         = 0;
    StartupInfo.dwY         = 0;
    StartupInfo.dwXSize     = 0;
    StartupInfo.dwYSize     = 0;
    StartupInfo.dwFlags     = 0;
    StartupInfo.wShowWindow = SW_SHOWNORMAL;
    StartupInfo.cbReserved2 = 0;
    StartupInfo.lpReserved2 = NULL;
    StartupInfo.hStdInput   = GetStdHandle( STD_INPUT_HANDLE );
    StartupInfo.hStdOutput  = GetStdHandle( STD_OUTPUT_HANDLE );
    StartupInfo.hStdError   = GetStdHandle( STD_ERROR_HANDLE );

    pszCmdCur = pszCmdLine;

    //
    // If there isn't a command line then make
    // up the default
    //

    if (pszCmdCur == NULL) {

        pszCmdCur = pszFakePgm;

    }

    while( *pszCmdCur != NULLC) {

        pszCmdCur = EatWS( pszCmdCur, NULL );

        if ((*pszCmdCur == QUOTE) && (StartupInfo.lpTitle == NULL)) {

            //
            //  "Title"  Parse off the quoted text, strip off quotes and set the
            //  title for the child window.
            //

            if (getparam( TRUE, &pszCmdCur, szTitle, sizeof( szTitle )) == FAILURE) {
                return FAILURE;
            }
            mystrcpy( szTitle, StripQuotes( szTitle ));
            StartupInfo.lpTitle =  szTitle;

        } else if (*pszCmdCur == SwitChar) {

            pszCmdCur++;

            if (getparam( TRUE, &pszCmdCur, szParam, MAXTOKLEN) == FAILURE) {
                return(FAILURE);
            }

            if (!_tcsicmp( szParam, TEXT("ABOVENORMAL"))) {
                CreationFlags |= ABOVE_NORMAL_PRIORITY_CLASS;
            } else
            if (!_tcsicmp( szParam, TEXT("BELOWNORMAL"))) {
                CreationFlags |= BELOW_NORMAL_PRIORITY_CLASS;
            } else 
            if (!_tcsicmp( szParam, TEXT("B"))) {
                    WaitForProcess = FALSE;
                    SafeFromControlC = TRUE;
                    CreationFlags &= ~CREATE_NEW_CONSOLE;
                    CreationFlags |= CREATE_NEW_PROCESS_GROUP;
            } else 
            if (_totupper(szParam[0]) == TEXT('D')) {
                
                //
                //  /Dpath or /D"path" or /D path or /D "path"
                //

                if (mystrlen( szParam + 1 ) > 0) {

                    //
                    //  /Dpath or /D"path"
                    //

                    pszDirCur = szParam + 1;
                } else {

                    //
                    //  /D path or /D "path"
                    //

                    pszCmdCur = EatWS( pszCmdCur, NULL );
                    if (getparam( TRUE, &pszCmdCur, szParam, MAXTOKLEN) == FAILURE) {
                        return FAILURE;
                    }

                    pszDirCur = szParam;
                }

                //
                //  remove quotes if necessary
                //

                mystrcpy( szDirCur, StripQuotes( pszDirCur ));
                pszDirCur = szDirCur;

                if (mystrlen( pszDirCur ) > MAX_PATH) {
                    PutStdErr( MSG_START_INVALID_PARAMETER, ONEARG, pszDirCur);
                    return FAILURE;
                }
            } else
            if (_tcsicmp(szParam, TEXT("HIGH")) == 0) {
                CreationFlags |= HIGH_PRIORITY_CLASS;
            } else 
            if (_totupper(szParam[0]) == TEXT('I')) {

                //
                // penvOrig was save at init time after path
                // and compsec were setup.
                // If penvOrig did not get allocated then
                // use the default.
                //
                if (penvOrig) {
                    pszEnv = penvOrig->handle;
                }
            } else
            if (_totupper(szParam[0]) == QMARK) {

                BeginHelpPause();
                PutStdOut(MSG_HELP_START, NOARGS);
                if (fEnableExtensions)
                    PutStdOut(MSG_HELP_START_X, NOARGS);
                EndHelpPause();

                return( FAILURE );
            } else
            if (_tcsicmp(szParam, TEXT("LOW")) == 0) {
                CreationFlags |= IDLE_PRIORITY_CLASS;
            } else 
            if (_tcsicmp(szParam, TEXT("MIN")) == 0) {

                StartupInfo.dwFlags |= STARTF_USESHOWWINDOW;
                StartupInfo.wShowWindow &= ~SW_SHOWNORMAL;
                StartupInfo.wShowWindow |= SW_SHOWMINNOACTIVE;

            } else 
            if (_tcsicmp(szParam, TEXT("MAX")) == 0) {

                StartupInfo.dwFlags |= STARTF_USESHOWWINDOW;
                StartupInfo.wShowWindow &= ~SW_SHOWNORMAL;
                StartupInfo.wShowWindow |= SW_SHOWMAXIMIZED;

            } else 
            if (_tcsicmp(szParam, TEXT("NORMAL")) == 0) {
                CreationFlags |= NORMAL_PRIORITY_CLASS;
            } else
            if (_tcsicmp(szParam, TEXT("REALTIME")) == 0) {
                CreationFlags |= REALTIME_PRIORITY_CLASS;
            } else 
            if (_tcsicmp(szParam, TEXT("SEPARATE")) == 0) {
#ifndef WIN95_CMD
                CreationFlags |= CREATE_SEPARATE_WOW_VDM;
#endif // WIN95_CMD
            } else
            if (_tcsicmp(szParam, TEXT("SHARED")) == 0) {
#ifndef WIN95_CMD
                CreationFlags |= CREATE_SHARED_WOW_VDM;
#endif // WIN95_CMD
            } else 
            if ( _tcsicmp(szParam, TEXT("WAIT")) == 0  ||
                 _tcsicmp(szParam, TEXT("W"))    == 0 ) {
                WaitForProcess = TRUE;
            } else {
#ifdef FE_SB // KKBUGFIX
                        mystrcpy(szT, TEXT("/"));
#else
                        mystrcpy(szT, TEXT("\\"));
#endif
                        mystrcat(szT, szParam );
                        PutStdErr(MSG_INVALID_SWITCH, ONEARG, szT);
                        return( FAILURE );
            }
        } else {

            if ((getparam(FALSE,&pszCmdCur,szPgm,MAXTOKLEN))  == FAILURE) {
                return( FAILURE );
            }

            //
            // if there are argument get them.
            //
            if (*pszCmdCur) {

                mystrcpy(szPgmArgs, pszCmdCur);
                pszPgmArgs = szPgmArgs;

            }

            //
            // there rest was args to pgm so move to eol
            //
            pszCmdCur = mystrchr(pszCmdCur, NULLC);

        }

    } // while


    //
    // If a program was not picked up do so now.
    //
    if (*szPgm == NULLC) {
        mystrcpy(szPgm, pszFakePgm);
    }

    //
    //  Need both quoted and unquoted versions of program name
    //

    if (szPgm[0] != QUOTE && _tcschr(szPgm, SPACE)) {
        szPgmQuoted[0] = QUOTE;
        mystrcpy(&szPgmQuoted[1], StripQuotes(szPgm));
        mystrcat(szPgmQuoted, TEXT("\""));
        }
    else {
        mystrcpy(szPgmQuoted, szPgm);
        mystrcpy(szPgm, StripQuotes(szPgm));
        }

#ifndef UNICODE
#ifndef WIN95_CMD
    // convert the title from OEM to ANSI

    if (StartupInfo.lpTitle) {
        MultiByteToWideChar(CP_OEMCP,
                            0,
                            StartupInfo.lpTitle,
                            _tcslen(StartupInfo.lpTitle)+1,
                            TitleW,
                            MAXTOKLEN);

        WideCharToMultiByte(CP_ACP,
                            0,
                            TitleW,
                            wcslen(TitleW)+1,
                            TitleA,
                            MAXTOKLEN,
                            NULL,
                            NULL);
        StartupInfo.lpTitle = TitleA;
    }
#endif // WIN95_CMD
#endif // UNICODE

    //
    // see of a cmd.exe is needed to run a batch or internal command
    //

    fNeedCmd = FALSE;
    fNeedExpl = FALSE;

    //
    // is it an internal command?
    //
    if (FindCmd(CMDMAX, szPgm, &flags) != -1) {
        fNeedCmd = TRUE;
    } else {
        // Save szPgm since SearchForExecutable may override it.
        mystrcpy(szPgmSave, szPgm);

        //
        // Try to find it as a batch or exe file
        //
        cmdnd.cmdline = szPgm;

        status = SearchForExecutable(&cmdnd, szPgm);
        if ( (status == SFE_NOTFND) || ( status == SFE_FAIL ) ) {
            //
            // If we can find it, let Explorer have a shot.
            //
            fNeedExpl = TRUE;
            mystrcpy(szPgm, szPgmSave);

        } else if (status == SFE_ISBAT || status == SFE_ISDIR) {

            if (status == SFE_ISBAT)
                fNeedCmd = TRUE;
            else
                fNeedExpl = TRUE;

        }
    }


    if (!fNeedExpl) {
        if (fNeedCmd) {
            TCHAR *Cmd = GetEnvVar( ComSpecStr );
            
            if (Cmd == NULL) {
                PutStdErr( MSG_INVALID_COMSPEC, NOARGS );
                return FAILURE;
            }
            
            //
            // if a cmd.exe is need then szPgm need to be inserted before
            // the start of szPgms along with a /K parameter.
            // szPgm has to recieve the full path name of cmd.exe from
            // the compsec environment variable.
            //

            mystrcpy(szT, TEXT(" /K "));
            mystrcat(szT, szPgmQuoted);

            //
            // Get the location of the cmd processor from the environment
            //
            
            mystrcpy( szPgm, Cmd );

            mystrcpy( szPgmQuoted, szPgm );

            //
            // is there a command parameter at all
            //

            if (_tcsicmp(szT, TEXT(" /K ")) != 0) {

                //
                // If we have any arguments to add do so
                //
                if (*szPgmArgs) {

                    if ((mystrlen(szPgmArgs) + mystrlen(szT)) < MAXTOKLEN) {

                        mystrcat(szT, TEXT(" "));
                        mystrcat(szT, szPgmArgs);

                    } else {

                        PutStdErr( MSG_CMD_FILE_NOT_FOUND, ONEARG, szPgmArgs);
                    }
                }
            }
            pszPgmArgs = szT;
        }

        // Prepare for CreateProcess :
        //         ImageName = <full path and command name ONLY>
        //         CmdLine   = <command name with NO FULL PATH> + <args as entered>

        mystrcpy(szTemp, szPgmQuoted);
        mystrcat(szTemp, TEXT(" "));
        mystrcat(szTemp, pszPgmArgs);
        pszPgmArgs = szTemp;
    }

    if (SafeFromControlC) {
        SetConsoleCtrlHandler(NULL,TRUE);
        }

    // Pass current Desktop to a new process.

    hwinsta = GetProcessWindowStation();
    GetUserObjectInformation( hwinsta, UOI_NAME, NULL, 0, &cbWinsta );

    hdesk = GetThreadDesktop ( GetCurrentThreadId() );
    GetUserObjectInformation (hdesk, UOI_NAME, NULL, 0, &cbDesktop);

    if ((lpDesktop = HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, cbDesktop + cbWinsta + 32) ) != NULL ) {
        p = lpDesktop;
        if ( GetUserObjectInformation (hwinsta, UOI_NAME, p, cbWinsta, &cbWinsta) ) {
            if (cbWinsta > 0) {
                p += ((cbWinsta/sizeof(TCHAR))-1);
                *p++ = L'\\';
            }
            if ( GetUserObjectInformation (hdesk, UOI_NAME, p, cbDesktop, &cbDesktop) ) {
                StartupInfo.lpDesktop = lpDesktop;
            }
        }
    }

    if (fNeedExpl) {
        b = FALSE;
    } else {
        b = CreateProcess( szPgm,                  // was NULL, wrong.
                           pszPgmArgs,
                           NULL,
                           (LPSECURITY_ATTRIBUTES) NULL,
                           TRUE,                   // bInherit
#ifdef UNICODE
                           CREATE_UNICODE_ENVIRONMENT |
#endif // UNICODE
                           CreationFlags,
                                                   // CreationFlags
                           pszEnv,                 // Environment
                           pszDirCur,              // Current directory
                           &StartupInfo,           // Startup Info Struct
                           &ChildProcessInfo       // ProcessInfo Struct
                           );
    }

    if (SafeFromControlC) {
        SetConsoleCtrlHandler(NULL,FALSE);
    }
    HeapFree (GetProcessHeap(), 0, lpDesktop);

    if (!b) {
            DosErr = GetLastError();

            if ( fNeedExpl ||
                 (fEnableExtensions && DosErr == ERROR_BAD_EXE_FORMAT)) {
                SHELLEXECUTEINFO sei;
                BOOL b;

                memset(&sei, 0, sizeof(sei));
                //
                // Use the DDEWAIT flag so apps can finish their DDE conversation
                // before ShellExecuteEx returns.  Otherwise, apps like Word will
                // complain when they try to exit, confusing the user.
                //
                sei.cbSize = sizeof(sei);
                sei.fMask = SEE_MASK_HASTITLE |
                            SEE_MASK_NO_CONSOLE |
                            SEE_MASK_FLAG_DDEWAIT |
                            SEE_MASK_NOCLOSEPROCESS;
                if (CreationFlags & CREATE_NEW_CONSOLE) {
                    sei.fMask &= ~SEE_MASK_NO_CONSOLE;
                }
                sei.lpFile = szPgm;
                sei.lpClass = StartupInfo.lpTitle;
                sei.lpParameters = szPgmArgs;
                sei.lpDirectory = pszDirCur;
                sei.nShow = StartupInfo.wShowWindow;

                try {
                    b = ShellExecuteEx( &sei );
                    if (b) {
                        leave;
                    }

                    if (!sei.hInstApp) {
                        DosErr = ERROR_NOT_ENOUGH_MEMORY;
                    } else if ((DWORD_PTR)sei.hInstApp == HINSTANCE_ERROR) {
                        DosErr = ERROR_FILE_NOT_FOUND;
                    } else {
                        DosErr = HandleToUlong(sei.hInstApp);
                    }

                } except (DosErr = GetExceptionCode( ), EXCEPTION_EXECUTE_HANDLER) {
                      b = FALSE;
                }
                
                if (b) {
                    //
                    // Successfully invoked correct application via
                    // file association.  Code below will check to see
                    // if application is a GUI app and if so turn it into
                    // an ASYNC exec.

                    ChildProcessInfo.hProcess = sei.hProcess;
                    goto shellexecsuccess;
                }
            }

            ExecError( szPgm ) ;
            return(FAILURE) ;
    }

    CloseHandle(ChildProcessInfo.hThread);
shellexecsuccess:
    if (ChildProcessInfo.hProcess != NULL) {
        if (WaitForProcess) {
            //
            //  Wait for process to terminate, otherwise things become very
            //  messy and confusing to the user (with 2 processes sharing
            //  the console).
            //
            LastRetCode = WaitProc((ChildProcessInfo.hProcess) );
        } else {
            CloseHandle( ChildProcessInfo.hProcess );
        }
    }

    return(SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\uipriv.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    uipriv.c

Abstract:

    Implements the priv command in cmd.exe.

Author:

    Robert Reichel (robertre)       6-8-92

Revision History:

--*/

#include "cmd.h"

extern TCHAR SwitChar;
extern BOOL CtrlCSeen;

extern unsigned LastRetCode;


//
// Maximum length of a Programmatic privilege name, in
// characters
//

#define MAX_PRIVILEGE_NAME  128


#define MAX_PRIVILEGE_COUNT 128


#define INITIAL_DISPLAY_NAME_LENGTH 128


BOOL
DisablePrivileges(
    USHORT PassedPrivilegeCount,
    PLUID PrivilegeValues,
    PTOKEN_PRIVILEGES CurrentTokenPrivileges,
    PBOOL PrivilegesDisabled,
    HANDLE TokenHandle
    );

BOOL
EnablePrivileges(
    USHORT PassedPrivilegeCount,
    PLUID PrivilegeValues,
    PTOKEN_PRIVILEGES CurrentTokenPrivileges
    );

BOOL
ResetPrivileges(
    USHORT PassedPrivilegeCount,
    PLUID PrivilegeValues,
    PTOKEN_PRIVILEGES CurrentTokenPrivileges
    );

int
Priv (
    TCHAR *pszCmdLine
    );

#define EqualLuid( Luid1, Luid2 )   (((Luid1).HighPart == (Luid2).HighPart) &&         \
                                    ((Luid1).LowPart == (Luid2).LowPart))


//
// temp hack until I put in actuall message
//
#define MSG_MISSING_PRIV_NAME MSG_BAD_SYNTAX

#ifndef SHIFT
#define SHIFT(c,v)      {c--; v++;}
#endif //SHIFT



//
// Function definitions...
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\dos\doscmd.h ===
/* doscmd.h */

#undef _cdecl
#undef  cdecl
#undef _near
#undef _stdcall
#undef _syscall
#undef pascal
#undef far


/* ntdef.h */
typedef char CCHAR;
//typedef short CSHORT;
typedef CCHAR BOOLEAN;
typedef BOOLEAN *PBOOLEAN;

#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\win95\makefile.inc ===
!include ..\cmd\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\dos\libc.c ===
#define BOOL unsigned long
#define HANDLE void *
#define LPDWORD unsigned long *
#define APIENTRY _pascal
#define DWORD unsigned long
#define PINPUT_RECORD void *
#define LPSTR char *
#define VOID void
#define LPSTARTUPINFO void *
#define PVOID void *

DWORD
APIENTRY
HeapSize32(
    HANDLE hHeap,
    LPSTR lpMem
    );

DWORD
APIENTRY
HeapSize(
    HANDLE hHeap,
    LPSTR lpMem
    )
{
    return HeapSize32(hHeap,lpMem);
}

BOOL
APIENTRY
HEAPDESTROY(
    HANDLE hHeap
    );

BOOL
HeapDestroy(
    HANDLE hHeap
    )
{
    return HEAPDESTROY(hHeap);
}

typedef  int  jmp_buf[6];

int _setjmp(jmp_buf);

int _cdecl setjmp(jmp_buf env)
{
    int (*fxp)() = _setjmp;

    _asm {
        mov eax,fxp
        mov esp,ebp
        pop ebp
        jmp eax
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\makefile.inc ===
PREOBJDIR = $(CPUDIR)\$(BLD_MODEL)_lib

# These are the prebuilt objects which are static link components in the
# MSVCR70[D].DLL implib

DLL_STAT_PREBLD = \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\ehprolg2.obj \
        $(OBJDIR)\ehprolog.obj \
        $(OBJDIR)\ftol2.obj \
!endif
        $(OBJDIR)\ehvccctr.obj \
        $(OBJDIR)\ehvcccvb.obj \
        $(OBJDIR)\ehvecctr.obj \
        $(OBJDIR)\ehveccvb.obj \
        $(OBJDIR)\ehvecdtr.obj

# Here is the target for building LIBC{,D} / LIBCMT{,D} / MSVCRT{,D}.LIB

all: \
        $(OBJDIR)\convert.lib  \
        $(OBJDIR)\direct.lib   \
!if "$(BLD_DLL)"=="1"
        $(OBJDIR)\dllstuff.lib \
!endif
        $(OBJDIR)\dos.lib      \
        $(OBJDIR)\eh.lib       \
        $(OBJDIR)\exec.lib     \
        $(OBJDIR)\heap.lib     \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\helper.lib   \
!endif
# ******** STRIPLIN=0 ******** 
!if "$(TARGET_CPU)"=="ALPHA" || "$(TARGET_CPU)"=="ALPHA64"
        $(OBJDIR)\helper.lib   \
!endif
# ******** STRIPLIN=1 ******** 
!if "$(BLD_DLL)"!="1"
        $(OBJDIR)\linkopts.lib \
!endif
        $(OBJDIR)\lowio.lib    \
        $(OBJDIR)\mbstring.lib \
        $(OBJDIR)\misc.lib     \
!if "$(RTC)"=="YES"
        $(OBJDIR)\rtc.lib      \
!endif
        $(OBJDIR)\startup.lib  \
        $(OBJDIR)\stdio.lib    \
        $(OBJDIR)\string.lib   \
        $(OBJDIR)\time.lib     \
        $(OBJDIR)\conv.lib     \
        $(OBJDIR)\tran.lib     \
!if "$(BLD_BSKU)"=="1"
        $(OBJDIR)\bsku.obj     \
!endif
        $(OBJDIR)\matherr.obj  \
!if "$(BLD_DLL)"=="1"
        $(DLL_STAT_PREBLD)
!endif


# Here is the target for building LIBCP{,D} / LIBCPMT{,D} / MSVCPRT{,D}.LIB

!if "$(BLD_SYSCRT)" != "1" || "$(LLP64)" != "1" # STRIPLIN!
STDCPP_SRC = stdcpp
!else # STRIPLIN=0
STDCPP_SRC = stdcpp64
!endif # STRIPLIN=1

_stdcpp_ : \
!if "$(BLD_DLL)"=="1"
        $(OBJDIR)\delop2_s.obj  \
        $(OBJDIR)\newop_s.obj   \
        $(OBJDIR)\newop2_s.obj  \
!if "$(LLP64)"!="1"
        $(OBJDIR)\delaop2_s.obj \
        $(OBJDIR)\newaop_s.obj  \
        $(OBJDIR)\newaop2_s.obj \
!endif
!endif
!if "$(BLD_BSKU)"=="1"
        $(OBJDIR)\bsku.obj     \
!endif
        $(OBJDIR)\$(STDCPP_SRC).lib


# Here is the target for building LIBCI{,D} / LIBCIMT{,D} / MSVCIRT{,D}.LIB

_iostream_ : \
!if "$(BLD_BSKU)"=="1"
        $(OBJDIR)\bsku.obj     \
!endif
        $(OBJDIR)\iostream.lib


CONVERT_OBJECTS = \
        $(OBJDIR)\_ctype.obj   \
        $(OBJDIR)\_fptostr.obj \
        $(OBJDIR)\_mbslen.obj  \
        $(OBJDIR)\_wctype.obj  \
        $(OBJDIR)\atof.obj     \
        $(OBJDIR)\atox.obj     \
        $(OBJDIR)\fcvt.obj     \
        $(OBJDIR)\gcvt.obj     \
        $(OBJDIR)\isctype.obj  \
        $(OBJDIR)\iswctype.obj \
        $(OBJDIR)\mblen.obj    \
        $(OBJDIR)\mbstowcs.obj \
        $(OBJDIR)\mbtowc.obj   \
        $(OBJDIR)\strtod.obj   \
        $(OBJDIR)\strtol.obj   \
        $(OBJDIR)\strtoq.obj   \
        $(OBJDIR)\swab.obj     \
        $(OBJDIR)\tolower.obj  \
        $(OBJDIR)\toupper.obj  \
        $(OBJDIR)\towlower.obj \
        $(OBJDIR)\towupper.obj \
        $(OBJDIR)\wchtodig.obj \
        $(OBJDIR)\wcstod.obj   \
        $(OBJDIR)\wcstol.obj   \
        $(OBJDIR)\wcstoq.obj   \
        $(OBJDIR)\wcstombs.obj \
        $(OBJDIR)\wctomb.obj   \
        $(OBJDIR)\wtof.obj     \
        $(OBJDIR)\wtox.obj     \
        $(OBJDIR)\xtoa.obj     \
        $(OBJDIR)\xtow.obj

DIRECT_OBJECTS = \
        $(OBJDIR)\drivemap.obj \
        $(OBJDIR)\drivfree.obj \
        $(OBJDIR)\findfile.obj \
        $(OBJDIR)\findf64.obj  \
        $(OBJDIR)\findfi64.obj \
        $(OBJDIR)\seterrm.obj  \
        $(OBJDIR)\slbeep.obj   \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\enable.obj   \
!endif
        $(OBJDIR)\wfindfil.obj \
        $(OBJDIR)\wfndf64.obj  \
        $(OBJDIR)\wfndfi64.obj

DLLSTUFF_OBJECTS = \
        $(OBJDIR)\atonexit.obj \
        $(OBJDIR)\crtlib.obj   \
        $(OBJDIR)\crtexe.obj   \
        $(OBJDIR)\crtexew.obj  \
        $(OBJDIR)\crtdll.obj   \
        $(OBJDIR)\cinitexe.obj \
        $(OBJDIR)\dllargv.obj  \
        $(OBJDIR)\dll_argv.obj \
        $(OBJDIR)\ios_dll.obj  \
        $(OBJDIR)\merr.obj     \
        $(OBJDIR)\oldexcpt.obj \
        $(OBJDIR)\ti_inst.obj  \
        $(OBJDIR)\wcrtexe.obj  \
        $(OBJDIR)\wcrtexew.obj \
        $(OBJDIR)\wdllargv.obj \
        $(OBJDIR)\wdll_av.obj  \
        $(OBJDIR)\wildcard.obj \
        $(OBJDIR)\xtxtmode.obj \
        $(OBJDIR)\xncommod.obj \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\dllsupp.obj  \
        $(OBJDIR)\adjustfd.obj \
!endif
!if "$(TARGET_CPU)"=="IA64"
        $(OBJDIR)\dllsupp.obj  \
!endif
# ******** STRIPLIN=0 ******** 
# These objects are needed when building the forwarder DLL
!IF "$(BLD_FWDR)"=="1"
        $(OBJDIR)\fwdr_dll.obj \
        $(OBJDIR)\imp_data.obj \
!ENDIF
# ******** STRIPLIN=1 ******** 

DOS_OBJECTS = \
        $(OBJDIR)\access.obj   \
        $(OBJDIR)\chmod.obj    \
        $(OBJDIR)\chdir.obj    \
        $(OBJDIR)\dosmap.obj   \
        $(OBJDIR)\drive.obj    \
        $(OBJDIR)\fullpath.obj \
        $(OBJDIR)\getcwd.obj   \
        $(OBJDIR)\getpid.obj   \
        $(OBJDIR)\mkdir.obj    \
        $(OBJDIR)\mterrno.obj  \
        $(OBJDIR)\rename.obj   \
        $(OBJDIR)\rmdir.obj    \
        $(OBJDIR)\stat.obj     \
        $(OBJDIR)\stat64.obj   \
        $(OBJDIR)\stati64.obj  \
        $(OBJDIR)\unlink.obj   \
        $(OBJDIR)\waccess.obj  \
        $(OBJDIR)\wchdir.obj   \
        $(OBJDIR)\wchmod.obj   \
        $(OBJDIR)\wfullpat.obj \
        $(OBJDIR)\wgetcwd.obj  \
        $(OBJDIR)\wmkdir.obj   \
        $(OBJDIR)\wrename.obj  \
        $(OBJDIR)\wrmdir.obj   \
        $(OBJDIR)\wstat.obj    \
        $(OBJDIR)\wstat64.obj  \
        $(OBJDIR)\wstati64.obj \
        $(OBJDIR)\wunlink.obj

EXEC_OBJECTS = \
        $(OBJDIR)\cenvarg.obj  \
        $(OBJDIR)\fileinfo.obj \
        $(OBJDIR)\dospawn.obj  \
        $(OBJDIR)\execl.obj    \
        $(OBJDIR)\execle.obj   \
        $(OBJDIR)\execlp.obj   \
        $(OBJDIR)\execlpe.obj  \
        $(OBJDIR)\execv.obj    \
        $(OBJDIR)\execve.obj   \
        $(OBJDIR)\execvp.obj   \
        $(OBJDIR)\execvpe.obj  \
        $(OBJDIR)\getproc.obj  \
        $(OBJDIR)\loaddll.obj  \
        $(OBJDIR)\spawnl.obj   \
        $(OBJDIR)\spawnle.obj  \
        $(OBJDIR)\spawnlp.obj  \
        $(OBJDIR)\spawnlpe.obj \
        $(OBJDIR)\spawnv.obj   \
        $(OBJDIR)\spawnve.obj  \
        $(OBJDIR)\spawnvp.obj  \
        $(OBJDIR)\spawnvpe.obj \
        $(OBJDIR)\system.obj   \
        $(OBJDIR)\wait.obj     \
        $(OBJDIR)\wcenvarg.obj \
        $(OBJDIR)\wdospawn.obj \
        $(OBJDIR)\wexecl.obj   \
        $(OBJDIR)\wexecle.obj  \
        $(OBJDIR)\wexeclp.obj  \
        $(OBJDIR)\wexeclpe.obj \
        $(OBJDIR)\wexecv.obj   \
        $(OBJDIR)\wexecve.obj  \
        $(OBJDIR)\wexecvp.obj  \
        $(OBJDIR)\wexecvpe.obj \
        $(OBJDIR)\wspawnl.obj  \
        $(OBJDIR)\wspawnle.obj \
        $(OBJDIR)\wspawnlp.obj \
        $(OBJDIR)\wspwnlpe.obj \
        $(OBJDIR)\wspawnv.obj  \
        $(OBJDIR)\wspawnve.obj \
        $(OBJDIR)\wspawnvp.obj \
        $(OBJDIR)\wspwnvpe.obj \
        $(OBJDIR)\wsystem.obj

HEAP_OBJECTS = \
        $(OBJDIR)\align.obj    \
        $(OBJDIR)\resetstk.obj  \
        $(OBJDIR)\calloc.obj   \
!IF "$(WINHEAP)" == "YES"
        $(OBJDIR)\expand.obj   \
!ELSE
        $(OBJDIR)\findaddr.obj \
!ENDIF
        $(OBJDIR)\free.obj     \
        $(OBJDIR)\heapadd.obj  \
        $(OBJDIR)\heapchk.obj  \
!IF "$(WINHEAP)" == "NO"
        $(OBJDIR)\heapgrow.obj \
!ENDIF
        $(OBJDIR)\heapinit.obj \
        $(OBJDIR)\heapmin.obj  \
!IF "$(WINHEAP)" == "NO"
        $(OBJDIR)\heapprm.obj  \
!ENDIF
!IF "$(WINHEAP)" == "NO"
        $(OBJDIR)\heapsrch.obj \
!ENDIF
        $(OBJDIR)\hpabort.obj  \
        $(OBJDIR)\heapused.obj \
        $(OBJDIR)\heapwalk.obj \
        $(OBJDIR)\malloc.obj   \
        $(OBJDIR)\msize.obj    \
        $(OBJDIR)\realloc.obj  \
!IF "$(WINHEAP)" == "YES"
        $(OBJDIR)\sbheap.obj   \
!ENDIF
        $(OBJDIR)\handler.obj  \
        $(OBJDIR)\setnewh.obj  \
        $(OBJDIR)\new_mode.obj \
        $(OBJDIR)\delete.obj   \
        $(OBJDIR)\delete2.obj  \
        $(OBJDIR)\_newmode.obj \
        $(OBJDIR)\new.obj      \
        $(OBJDIR)\new2.obj

HELPER_OBJECTS = \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\lldiv.obj    \
        $(OBJDIR)\lldvrm.obj   \
        $(OBJDIR)\llmul.obj    \
        $(OBJDIR)\llrem.obj    \
        $(OBJDIR)\llshl.obj    \
        $(OBJDIR)\llshr.obj    \
        $(OBJDIR)\ulldiv.obj   \
        $(OBJDIR)\ulldvrm.obj  \
        $(OBJDIR)\ullrem.obj   \
        $(OBJDIR)\ullshr.obj   \
!endif
# ******** STRIPLIN=0 ********
!if "$(TARGET_CPU)"=="ALPHA" || "$(TARGET_CPU)"=="ALPHA64"
        $(OBJDIR)\divdat.obj   \
        $(OBJDIR)\divide2.obj  \
        $(OBJDIR)\extv.obj     \
        $(OBJDIR)\extvvol.obj  \
        $(OBJDIR)\extzv.obj    \
        $(OBJDIR)\extzvvol.obj \
        $(OBJDIR)\insv.obj     \
        $(OBJDIR)\insvvol.obj  \
        $(OBJDIR)\memcmp_.obj  \
        $(OBJDIR)\otsdiv.obj   \
        $(OBJDIR)\scmpeql.obj  \
        $(OBJDIR)\scmpeqlp.obj \
        $(OBJDIR)\scmpleq.obj  \
        $(OBJDIR)\scmpleqp.obj \
        $(OBJDIR)\scmplss.obj  \
        $(OBJDIR)\scmplssp.obj \
        $(OBJDIR)\sfill.obj    \
        $(OBJDIR)\sfillx.obj   \
        $(OBJDIR)\sfwdcpy.obj  \
        $(OBJDIR)\sloc.obj     \
        $(OBJDIR)\smove.obj    \
        $(OBJDIR)\smovem.obj   \
        $(OBJDIR)\strans.obj   \
        $(OBJDIR)\strcmp_.obj  \
        $(OBJDIR)\strcpy_.obj  \
        $(OBJDIR)\strlen_.obj  \
        $(OBJDIR)\szero.obj    \
!endif
# ******** STRIPLIN=1 ********

IOSTREAM_OBJECTS = \
        $(OBJDIR)\_iostrea.obj \
        $(OBJDIR)\iostrini.obj \
        $(OBJDIR)\cerrinit.obj \
        $(OBJDIR)\cininit.obj  \
        $(OBJDIR)\cloginit.obj \
        $(OBJDIR)\filebuf.obj  \
        $(OBJDIR)\filebuf1.obj \
        $(OBJDIR)\fstream.obj  \
        $(OBJDIR)\ifstream.obj \
        $(OBJDIR)\_ios.obj     \
        $(OBJDIR)\istrchar.obj \
        $(OBJDIR)\istrdbl.obj  \
        $(OBJDIR)\istream.obj  \
        $(OBJDIR)\istream1.obj \
        $(OBJDIR)\istrflt.obj  \
        $(OBJDIR)\istrgdbl.obj \
        $(OBJDIR)\istrget.obj  \
        $(OBJDIR)\istrgetl.obj \
        $(OBJDIR)\istrgint.obj \
        $(OBJDIR)\istrint.obj  \
        $(OBJDIR)\istrldbl.obj \
        $(OBJDIR)\istrlong.obj \
        $(OBJDIR)\istrshrt.obj \
        $(OBJDIR)\istruint.obj \
        $(OBJDIR)\istrulng.obj \
        $(OBJDIR)\istrusht.obj \
        $(OBJDIR)\mtlock.obj   \
        $(OBJDIR)\ofstream.obj \
        $(OBJDIR)\ostrchar.obj \
        $(OBJDIR)\ostrdbl.obj  \
        $(OBJDIR)\ostream.obj  \
        $(OBJDIR)\ostream1.obj \
        $(OBJDIR)\ostrint.obj  \
        $(OBJDIR)\ostrldbl.obj \
        $(OBJDIR)\ostrlong.obj \
        $(OBJDIR)\ostrptr.obj  \
        $(OBJDIR)\ostrput.obj  \
        $(OBJDIR)\ostrshrt.obj \
        $(OBJDIR)\ostruint.obj \
        $(OBJDIR)\ostrulng.obj \
        $(OBJDIR)\ostrusht.obj \
        $(OBJDIR)\stdiostr.obj \
        $(OBJDIR)\streamb.obj  \
        $(OBJDIR)\streamb1.obj \
        $(OBJDIR)\strmbdbp.obj \
        $(OBJDIR)\_strstre.obj

LINKOPTS_OBJECTS = \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\fp10.obj     \
!endif
!if "$(TARGET_CPU)"=="IA64"
        $(OBJDIR)\fp10.obj     \
!endif
        $(OBJDIR)\binmode.obj  \
        $(OBJDIR)\newmode.obj  \
        $(OBJDIR)\setargv.obj  \
        $(OBJDIR)\wsetargv.obj \
        $(OBJDIR)\noarg.obj    \
        $(OBJDIR)\noenv.obj    \
        $(OBJDIR)\smalheap.obj \
        $(OBJDIR)\commode.obj

LOWIO_OBJECTS = \
        $(OBJDIR)\chsize.obj   \
        $(OBJDIR)\close.obj    \
        $(OBJDIR)\commit.obj   \
        $(OBJDIR)\creat.obj    \
        $(OBJDIR)\dup.obj      \
        $(OBJDIR)\dup2.obj     \
        $(OBJDIR)\eof.obj      \
        $(OBJDIR)\flength.obj  \
        $(OBJDIR)\fleni64.obj  \
        $(OBJDIR)\fstat.obj    \
        $(OBJDIR)\fstat64.obj  \
        $(OBJDIR)\fstati64.obj \
        $(OBJDIR)\initcon.obj  \
        $(OBJDIR)\ioinit.obj   \
        $(OBJDIR)\isatty.obj   \
        $(OBJDIR)\locking.obj  \
        $(OBJDIR)\lseek.obj    \
        $(OBJDIR)\lseeki64.obj \
        $(OBJDIR)\mktemp.obj   \
        $(OBJDIR)\open.obj     \
        $(OBJDIR)\osfinfo.obj  \
        $(OBJDIR)\pipe.obj     \
        $(OBJDIR)\read.obj     \
        $(OBJDIR)\setmode.obj  \
        $(OBJDIR)\tell.obj     \
        $(OBJDIR)\telli64.obj  \
        $(OBJDIR)\txtmode.obj  \
        $(OBJDIR)\write.obj    \
        $(OBJDIR)\cgets.obj    \
        $(OBJDIR)\cgetws.obj   \
        $(OBJDIR)\cputs.obj    \
        $(OBJDIR)\getch.obj    \
        $(OBJDIR)\getwch.obj   \
        $(OBJDIR)\putch.obj    \
        $(OBJDIR)\putwch.obj   \
        $(OBJDIR)\wcreat.obj   \
        $(OBJDIR)\wmktemp.obj  \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\inp.obj      \
        $(OBJDIR)\outp.obj     \
!endif
        $(OBJDIR)\wopen.obj

MBSTRING_OBJECTS = \
        $(OBJDIR)\ismbalnm.obj \
        $(OBJDIR)\ismbalph.obj \
        $(OBJDIR)\ismbbyte.obj \
        $(OBJDIR)\ismbdgt.obj  \
        $(OBJDIR)\ismbgrph.obj \
        $(OBJDIR)\ismbknj.obj  \
        $(OBJDIR)\ismblgl.obj  \
        $(OBJDIR)\ismblwr.obj  \
        $(OBJDIR)\ismbprn.obj  \
        $(OBJDIR)\ismbpunc.obj \
        $(OBJDIR)\ismbsle.obj  \
        $(OBJDIR)\ismbspc.obj  \
        $(OBJDIR)\ismbstr.obj  \
        $(OBJDIR)\ismbupr.obj  \
        $(OBJDIR)\mbbtype.obj  \
        $(OBJDIR)\mbccpy.obj   \
        $(OBJDIR)\mbclen.obj   \
        $(OBJDIR)\mbclevel.obj \
        $(OBJDIR)\mbctype.obj  \
        $(OBJDIR)\mbsbtype.obj \
        $(OBJDIR)\mbschr.obj   \
        $(OBJDIR)\mbscmp.obj   \
        $(OBJDIR)\mbscoll.obj  \
        $(OBJDIR)\mbscspn.obj  \
        $(OBJDIR)\mbsdec.obj   \
        $(OBJDIR)\mbsicmp.obj  \
        $(OBJDIR)\mbsicoll.obj \
        $(OBJDIR)\mbsinc.obj   \
        $(OBJDIR)\mbslen.obj   \
        $(OBJDIR)\mbslwr.obj   \
        $(OBJDIR)\mbsnbcat.obj \
        $(OBJDIR)\mbsnbcmp.obj \
        $(OBJDIR)\mbsnbcnt.obj \
        $(OBJDIR)\mbsnbcol.obj \
        $(OBJDIR)\mbsnbcpy.obj \
        $(OBJDIR)\mbsnbicm.obj \
        $(OBJDIR)\mbsnbico.obj \
        $(OBJDIR)\mbsnbset.obj \
        $(OBJDIR)\mbsncat.obj  \
        $(OBJDIR)\mbsnccnt.obj \
        $(OBJDIR)\mbsncmp.obj  \
        $(OBJDIR)\mbsncoll.obj \
        $(OBJDIR)\mbsncpy.obj  \
        $(OBJDIR)\mbsnextc.obj \
        $(OBJDIR)\mbsnicmp.obj \
        $(OBJDIR)\mbsnicol.obj \
        $(OBJDIR)\mbsninc.obj  \
        $(OBJDIR)\mbsnset.obj  \
        $(OBJDIR)\mbspbrk.obj  \
        $(OBJDIR)\mbsrchr.obj  \
        $(OBJDIR)\mbsrev.obj   \
        $(OBJDIR)\mbsset.obj   \
        $(OBJDIR)\mbsspn.obj   \
        $(OBJDIR)\mbsspnp.obj  \
        $(OBJDIR)\mbsstr.obj   \
        $(OBJDIR)\mbstok.obj   \
        $(OBJDIR)\mbsupr.obj   \
        $(OBJDIR)\mbtohira.obj \
        $(OBJDIR)\mbtokata.obj \
        $(OBJDIR)\mbtolwr.obj  \
        $(OBJDIR)\mbtoupr.obj  \
        $(OBJDIR)\tojisjms.obj \
        $(OBJDIR)\tombbmbc.obj

MISC_OBJECTS = \
# ******** STRIPLIN=0 ******** 
!if "$(TARGET_CPU)"=="ALPHA"
        $(OBJDIR)\chkesp.obj   \
        $(OBJDIR)\chandler.obj \
        $(OBJDIR)\ghandler.obj \
        $(OBJDIR)\jmpuwind.obj \
        $(OBJDIR)\longjmp.obj  \
        $(OBJDIR)\otsjmp.obj   \
        $(OBJDIR)\otsjmpex.obj \
        $(OBJDIR)\otsuwind.obj \
        $(OBJDIR)\setjmp.obj   \
        $(OBJDIR)\setjmpex.obj \
!endif
!if "$(TARGET_CPU)"=="ALPHA64"
        $(OBJDIR)\chkesp.obj   \
        $(OBJDIR)\ghandler.obj \
        $(OBJDIR)\jmpuwind.obj \
        $(OBJDIR)\longjmp.obj  \
        $(OBJDIR)\otsjmp.obj   \
        $(OBJDIR)\otsjmpex.obj \
        $(OBJDIR)\otsuwind.obj \
        $(OBJDIR)\setjmp.obj   \
        $(OBJDIR)\setjmpex.obj \
!endif
# ******** STRIPLIN=1 ******** 
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\chkesp.obj   \
        $(OBJDIR)\exsup.obj    \
        $(OBJDIR)\exsup2.obj   \
        $(OBJDIR)\exsup3.obj   \
        $(OBJDIR)\longjmp.obj  \
        $(OBJDIR)\seccinit.obj \
        $(OBJDIR)\seccook.obj  \
        $(OBJDIR)\secfail.obj  \
# ******** STRIPLIN=0 ********
!if "$(BLD_SYSCRT)" == "1"
        $(OBJDIR)\seclocf.obj  \
!endif
# ******** STRIPLIN=1 ********
        $(OBJDIR)\sehprolg.obj \
        $(OBJDIR)\sehsupp.obj  \
        $(OBJDIR)\setjmp.obj   \
        $(OBJDIR)\setjmp3.obj  \
        $(OBJDIR)\setjmpex.obj \
!endif
!if "$(TARGET_CPU)"=="IA64"
        $(OBJDIR)\chandler.obj \
        $(OBJDIR)\cinitone.obj \
        $(OBJDIR)\jmpuwind.obj \
        $(OBJDIR)\longjmp.obj  \
        $(OBJDIR)\miscs.obj    \
        $(OBJDIR)\setjmp.obj   \
        $(OBJDIR)\setjmpex.obj \
!endif
        $(OBJDIR)\a_cmp.obj    \
        $(OBJDIR)\a_env.obj    \
        $(OBJDIR)\a_loc.obj    \
        $(OBJDIR)\a_map.obj    \
        $(OBJDIR)\a_str.obj    \
        $(OBJDIR)\abort.obj    \
        $(OBJDIR)\abs.obj      \
        $(OBJDIR)\assert.obj   \
        $(OBJDIR)\aw_com.obj   \
        $(OBJDIR)\bsearch.obj  \
        $(OBJDIR)\bswap.obj    \
        $(OBJDIR)\charmax.obj  \
        $(OBJDIR)\cmiscdat.obj \
        $(OBJDIR)\crtmbox.obj  \
        $(OBJDIR)\ctype.obj    \
        $(OBJDIR)\div.obj      \
        $(OBJDIR)\dbgheap.obj  \
        $(OBJDIR)\dbghook.obj  \
        $(OBJDIR)\dbgdel.obj   \
        $(OBJDIR)\dbgnew.obj   \
        $(OBJDIR)\dbgrpt.obj   \
        $(OBJDIR)\errmode.obj  \
        $(OBJDIR)\getenv.obj   \
        $(OBJDIR)\getpath.obj  \
        $(OBJDIR)\getqloc.obj  \
        $(OBJDIR)\initcoll.obj \
        $(OBJDIR)\initcrit.obj \
        $(OBJDIR)\initctyp.obj \
        $(OBJDIR)\inithelp.obj \
        $(OBJDIR)\initmon.obj  \
        $(OBJDIR)\initnum.obj  \
        $(OBJDIR)\inittime.obj \
        $(OBJDIR)\labs.obj     \
        $(OBJDIR)\lcnvinit.obj \
        $(OBJDIR)\lconv.obj    \
        $(OBJDIR)\ldiv.obj     \
        $(OBJDIR)\lfind.obj    \
        $(OBJDIR)\lsearch.obj  \
        $(OBJDIR)\makepath.obj \
        $(OBJDIR)\mbtowenv.obj \
        $(OBJDIR)\onexit.obj   \
        $(OBJDIR)\nlsdata1.obj \
        $(OBJDIR)\nlsdata2.obj \
        $(OBJDIR)\nlsdata3.obj \
        $(OBJDIR)\perror.obj   \
        $(OBJDIR)\purevirt.obj \
        $(OBJDIR)\putenv.obj   \
        $(OBJDIR)\qsort.obj    \
        $(OBJDIR)\rand.obj     \
        $(OBJDIR)\rotl.obj     \
        $(OBJDIR)\rotr.obj     \
        $(OBJDIR)\searchen.obj \
        $(OBJDIR)\setenv.obj   \
        $(OBJDIR)\setlocal.obj \
        $(OBJDIR)\splitpat.obj \
        $(OBJDIR)\_strerr.obj  \
        $(OBJDIR)\strerror.obj \
        $(OBJDIR)\syserr.obj   \
        $(OBJDIR)\convrtcp.obj \
        $(OBJDIR)\umask.obj    \
        $(OBJDIR)\w_cmp.obj    \
        $(OBJDIR)\w_env.obj    \
        $(OBJDIR)\w_loc.obj    \
        $(OBJDIR)\w_map.obj    \
        $(OBJDIR)\w_str.obj    \
        $(OBJDIR)\wcserror.obj \
        $(OBJDIR)\_wcserr.obj  \
        $(OBJDIR)\winsig.obj   \
        $(OBJDIR)\winxfltr.obj \
        $(OBJDIR)\wgetenv.obj  \
        $(OBJDIR)\wgetpath.obj \
        $(OBJDIR)\wmakepat.obj \
        $(OBJDIR)\wperror.obj  \
        $(OBJDIR)\wputenv.obj  \
        $(OBJDIR)\wsearche.obj \
        $(OBJDIR)\wsetenv.obj  \
        $(OBJDIR)\wsetloca.obj \
        $(OBJDIR)\wsplitpa.obj \
        $(OBJDIR)\wrt2err.obj  \
        $(OBJDIR)\wtombenv.obj

STARTUP_OBJECTS = \
        $(OBJDIR)\_setargv.obj \
        $(OBJDIR)\_wstargv.obj \
        $(OBJDIR)\chkstk.obj   \
        $(OBJDIR)\crt0.obj     \
        $(OBJDIR)\crt0dat.obj  \
        $(OBJDIR)\crt0fp.obj   \
        $(OBJDIR)\crt0init.obj \
        $(OBJDIR)\crt0msg.obj  \
        $(OBJDIR)\dllcrt0.obj  \
        $(OBJDIR)\dllmain.obj  \
        $(OBJDIR)\mlock.obj    \
        $(OBJDIR)\stdargv.obj  \
        $(OBJDIR)\stdenvp.obj  \
        $(OBJDIR)\thread.obj   \
        $(OBJDIR)\threadex.obj \
        $(OBJDIR)\tidtable.obj \
        $(OBJDIR)\tlssup.obj   \
        $(OBJDIR)\wcrt0.obj    \
        $(OBJDIR)\wild.obj     \
        $(OBJDIR)\wincmdln.obj \
        $(OBJDIR)\wincrt0.obj  \
        $(OBJDIR)\wstdargv.obj \
        $(OBJDIR)\wstdenvp.obj \
        $(OBJDIR)\wwncmdln.obj \
        $(OBJDIR)\wwild.obj    \
        $(OBJDIR)\wwincrt0.obj \
!if "$(TARGET_CPU)" == "i386"
        $(OBJDIR)\atlssup.obj  \
        $(OBJDIR)\fp8.obj      \
!endif
!if "$(TARGET_CPU)" == "IA64"
        $(OBJDIR)\fp8.obj      \
!endif

!if "$(LLP64)"!="1" || "$(BLD_SYSCRT)"!="1" # STRIPLIN!

STDCPP_OBJECTS = \
        $(OBJDIR)\cerr.obj      \
        $(OBJDIR)\cin.obj       \
        $(OBJDIR)\clog.obj      \
        $(OBJDIR)\cout.obj      \
        $(OBJDIR)\delaop2.obj   \
        $(OBJDIR)\delop2.obj    \
        $(OBJDIR)\fiopen.obj    \
!if "$(BLD_DLL)"=="1"
        $(OBJDIR)\instances.obj \
!endif
        $(OBJDIR)\iomanip.obj   \
        $(OBJDIR)\ios.obj       \
        $(OBJDIR)\iosptrs.obj   \
        $(OBJDIR)\iostream.obj  \
        $(OBJDIR)\locale.obj    \
        $(OBJDIR)\locale0.obj   \
        $(OBJDIR)\newaop.obj    \
        $(OBJDIR)\newaop2.obj   \
        $(OBJDIR)\newop.obj     \
        $(OBJDIR)\newop2.obj    \
        $(OBJDIR)\nomemory.obj  \
        $(OBJDIR)\nothrow.obj   \
        $(OBJDIR)\raisehan.obj  \
        $(OBJDIR)\stdhndlr.obj  \
        $(OBJDIR)\stdthrow.obj  \
        $(OBJDIR)\string.obj    \
        $(OBJDIR)\strstrea.obj  \
        $(OBJDIR)\ushcerr.obj   \
        $(OBJDIR)\ushcout.obj   \
        $(OBJDIR)\ushcin.obj    \
        $(OBJDIR)\ushclog.obj   \
        $(OBJDIR)\ushiostr.obj  \
        $(OBJDIR)\uncaught.obj  \
        $(OBJDIR)\wcerr.obj     \
        $(OBJDIR)\wcin.obj      \
        $(OBJDIR)\wclog.obj     \
        $(OBJDIR)\wcout.obj     \
        $(OBJDIR)\wctrans.obj   \
        $(OBJDIR)\wctype.obj    \
        $(OBJDIR)\wiostrea.obj  \
        $(OBJDIR)\wlocale.obj   \
        $(OBJDIR)\xcosh.obj     \
        $(OBJDIR)\xdateord.obj  \
        $(OBJDIR)\xdebug.obj    \
        $(OBJDIR)\xdnorm.obj    \
        $(OBJDIR)\xdscale.obj   \
        $(OBJDIR)\xdtest.obj    \
        $(OBJDIR)\xexp.obj      \
        $(OBJDIR)\xfcosh.obj    \
        $(OBJDIR)\xfdnorm.obj   \
        $(OBJDIR)\xfdscale.obj  \
        $(OBJDIR)\xfdtest.obj   \
        $(OBJDIR)\xferaise.obj  \
        $(OBJDIR)\xfexp.obj     \
        $(OBJDIR)\xfsinh.obj    \
        $(OBJDIR)\xfvalues.obj  \
        $(OBJDIR)\xgetwctype.obj\
        $(OBJDIR)\xlcosh.obj    \
        $(OBJDIR)\xldnorm.obj   \
        $(OBJDIR)\xldscale.obj  \
        $(OBJDIR)\xldtest.obj   \
        $(OBJDIR)\xlexp.obj     \
        $(OBJDIR)\xlocale.obj   \
        $(OBJDIR)\xlock.obj     \
        $(OBJDIR)\xlpoly.obj    \
        $(OBJDIR)\xlsinh.obj    \
        $(OBJDIR)\xlvalues.obj  \
        $(OBJDIR)\xmbtowc.obj   \
        $(OBJDIR)\xmtx.obj      \
        $(OBJDIR)\xmutex.obj    \
        $(OBJDIR)\xpoly.obj     \
        $(OBJDIR)\xsinh.obj     \
        $(OBJDIR)\xstod.obj     \
        $(OBJDIR)\xstrcoll.obj  \
        $(OBJDIR)\xstrxfrm.obj  \
        $(OBJDIR)\xtowlower.obj \
        $(OBJDIR)\xtowupper.obj \
        $(OBJDIR)\xvalues.obj   \
        $(OBJDIR)\xwcscoll.obj  \
        $(OBJDIR)\xwcsxfrm.obj  \
        $(OBJDIR)\xwctomb.obj   \
        $(OBJDIR)\_tolower.obj  \
        $(OBJDIR)\_toupper.obj

# ******** STRIPLIN=0 ******** 
!else

STDCPP_OBJECTS = \
        $(OBJDIR)\delop2.obj    \
!if "$(BLD_DLL)"=="1"
        $(OBJDIR)\dlldef.obj    \
!endif
        $(OBJDIR)\fiopen.obj    \
        $(OBJDIR)\iomanip.obj   \
        $(OBJDIR)\ios.obj       \
        $(OBJDIR)\iostream.obj  \
        $(OBJDIR)\locale.obj    \
        $(OBJDIR)\locale0.obj   \
        $(OBJDIR)\newop.obj     \
        $(OBJDIR)\newop2.obj    \
        $(OBJDIR)\nomemory.obj  \
        $(OBJDIR)\string.obj    \
        $(OBJDIR)\strstrea.obj  \
        $(OBJDIR)\uncaught.obj  \
        $(OBJDIR)\wiostrea.obj  \
        $(OBJDIR)\wctrans.obj   \
        $(OBJDIR)\wctype.obj    \
        $(OBJDIR)\wlocale.obj   \
        $(OBJDIR)\xcosh.obj     \
        $(OBJDIR)\xdnorm.obj    \
        $(OBJDIR)\xdscale.obj   \
        $(OBJDIR)\xdtest.obj    \
        $(OBJDIR)\xexp.obj      \
        $(OBJDIR)\xfcosh.obj    \
        $(OBJDIR)\xfdnorm.obj   \
        $(OBJDIR)\xfdscale.obj  \
        $(OBJDIR)\xfdtest.obj   \
        $(OBJDIR)\xfexp.obj     \
        $(OBJDIR)\xfsinh.obj    \
        $(OBJDIR)\xfvalues.obj  \
        $(OBJDIR)\xlcosh.obj    \
        $(OBJDIR)\xldnorm.obj   \
        $(OBJDIR)\xldscale.obj  \
        $(OBJDIR)\xldtest.obj   \
        $(OBJDIR)\xlexp.obj     \
        $(OBJDIR)\xlocale.obj   \
        $(OBJDIR)\xlock.obj     \
        $(OBJDIR)\xlpoly.obj    \
        $(OBJDIR)\xlsinh.obj    \
        $(OBJDIR)\xlvalues.obj  \
        $(OBJDIR)\xmbtowc.obj   \
        $(OBJDIR)\xpoly.obj     \
        $(OBJDIR)\xsinh.obj     \
        $(OBJDIR)\xstod.obj     \
        $(OBJDIR)\xstrcoll.obj  \
        $(OBJDIR)\xstrxfrm.obj  \
        $(OBJDIR)\_tolower.obj  \
        $(OBJDIR)\_toupper.obj  \
        $(OBJDIR)\xvalues.obj   \
        $(OBJDIR)\xwcscoll.obj  \
        $(OBJDIR)\xwcsxfrm.obj  \
        $(OBJDIR)\xwctomb.obj

!endif
# ******** STRIPLIN=1 ******** 

STDIO_OBJECTS = \
        $(OBJDIR)\feoferr.obj  \
        $(OBJDIR)\fgetc.obj    \
        $(OBJDIR)\fgetchar.obj \
        $(OBJDIR)\fgets.obj    \
        $(OBJDIR)\fgetwc.obj   \
        $(OBJDIR)\fgetws.obj   \
        $(OBJDIR)\fgetwchr.obj \
        $(OBJDIR)\fileno.obj   \
        $(OBJDIR)\fputc.obj    \
        $(OBJDIR)\fputs.obj    \
        $(OBJDIR)\fputchar.obj \
        $(OBJDIR)\fputwc.obj   \
        $(OBJDIR)\fputws.obj   \
        $(OBJDIR)\fputwchr.obj \
        $(OBJDIR)\_filbuf.obj  \
        $(OBJDIR)\_filwbuf.obj \
        $(OBJDIR)\_file.obj    \
        $(OBJDIR)\_flsbuf.obj  \
        $(OBJDIR)\_flswbuf.obj \
        $(OBJDIR)\_freebuf.obj \
        $(OBJDIR)\_getbuf.obj  \
        $(OBJDIR)\_open.obj    \
        $(OBJDIR)\_sftbuf.obj  \
        $(OBJDIR)\clearerr.obj \
        $(OBJDIR)\closeall.obj \
        $(OBJDIR)\cprintf.obj  \
        $(OBJDIR)\cwprintf.obj  \
        $(OBJDIR)\cscanf.obj   \
        $(OBJDIR)\cwscanf.obj  \
        $(OBJDIR)\fclose.obj   \
        $(OBJDIR)\fdopen.obj   \
        $(OBJDIR)\fflush.obj   \
        $(OBJDIR)\fgetpos.obj  \
        $(OBJDIR)\fopen.obj    \
        $(OBJDIR)\fprintf.obj  \
        $(OBJDIR)\fread.obj    \
        $(OBJDIR)\freopen.obj  \
        $(OBJDIR)\fscanf.obj   \
        $(OBJDIR)\fseek.obj    \
        $(OBJDIR)\fseeki64.obj \
        $(OBJDIR)\fsetpos.obj  \
        $(OBJDIR)\ftell.obj    \
        $(OBJDIR)\ftelli64.obj \
        $(OBJDIR)\fwprintf.obj \
        $(OBJDIR)\fwrite.obj   \
        $(OBJDIR)\fwscanf.obj  \
        $(OBJDIR)\gets.obj     \
        $(OBJDIR)\getw.obj     \
        $(OBJDIR)\getws.obj    \
        $(OBJDIR)\input.obj    \
        $(OBJDIR)\output.obj   \
        $(OBJDIR)\popen.obj    \
        $(OBJDIR)\printf.obj   \
        $(OBJDIR)\puts.obj     \
        $(OBJDIR)\putw.obj     \
        $(OBJDIR)\putws.obj    \
        $(OBJDIR)\rewind.obj   \
        $(OBJDIR)\rmtmp.obj    \
        $(OBJDIR)\scanf.obj    \
        $(OBJDIR)\setmaxf.obj  \
        $(OBJDIR)\setbuf.obj   \
        $(OBJDIR)\setvbuf.obj  \
        $(OBJDIR)\snprintf.obj \
        $(OBJDIR)\snscanf.obj  \
        $(OBJDIR)\snwprint.obj \
        $(OBJDIR)\snwscanf.obj \
        $(OBJDIR)\sprintf.obj  \
        $(OBJDIR)\sscanf.obj   \
        $(OBJDIR)\stream.obj   \
        $(OBJDIR)\swprintf.obj \
        $(OBJDIR)\swscanf.obj  \
        $(OBJDIR)\tempnam.obj  \
        $(OBJDIR)\tmpfile.obj  \
        $(OBJDIR)\ungetc.obj   \
        $(OBJDIR)\ungetwc.obj  \
        $(OBJDIR)\vprintf.obj  \
        $(OBJDIR)\vfprintf.obj \
        $(OBJDIR)\vfwprint.obj \
        $(OBJDIR)\vsprintf.obj \
        $(OBJDIR)\vsnprint.obj \
        $(OBJDIR)\vsnwprnt.obj \
        $(OBJDIR)\vswprint.obj \
        $(OBJDIR)\vwprintf.obj \
        $(OBJDIR)\wfdopen.obj  \
        $(OBJDIR)\wfopen.obj   \
        $(OBJDIR)\wfreopen.obj \
        $(OBJDIR)\winput.obj   \
        $(OBJDIR)\_wopen.obj   \
        $(OBJDIR)\woutput.obj  \
        $(OBJDIR)\wpopen.obj   \
        $(OBJDIR)\wprintf.obj  \
        $(OBJDIR)\wscanf.obj   \
        $(OBJDIR)\wtempnam.obj \
        $(OBJDIR)\wtmpfile.obj \
        $(OBJDIR)\ncommode.obj

STRING_OBJECTS = \
# ******** STRIPLIN=0 ******** 
!if "$(TARGET_CPU)" == "ALPHA" || "$(TARGET_CPU)" == "ALPHA64"
        $(OBJDIR)\memccpy.obj  \
        $(OBJDIR)\memchr.obj   \
        $(OBJDIR)\memcmp.obj   \
        $(OBJDIR)\memcpy.obj   \
        $(OBJDIR)\memicmp.obj  \
        $(OBJDIR)\memmove.obj  \
        $(OBJDIR)\memset.obj   \
        $(OBJDIR)\strcat.obj   \
        $(OBJDIR)\strchr.obj   \
        $(OBJDIR)\strcmps.obj  \
        $(OBJDIR)\strcspn.obj  \
        $(OBJDIR)\strdup.obj   \
        $(OBJDIR)\stricmp.obj  \
        $(OBJDIR)\strlens.obj  \
        $(OBJDIR)\strncat.obj  \
        $(OBJDIR)\strncmp.obj  \
        $(OBJDIR)\strncpy.obj  \
        $(OBJDIR)\strcpys.obj  \
        $(OBJDIR)\strnicmp.obj \
        $(OBJDIR)\strnset.obj  \
        $(OBJDIR)\strpbrk.obj  \
        $(OBJDIR)\strrchr.obj  \
        $(OBJDIR)\strrev.obj   \
        $(OBJDIR)\strset.obj   \
        $(OBJDIR)\strspn.obj   \
        $(OBJDIR)\strstr.obj   \
!endif
# ******** STRIPLIN=1 ******** 
!if "$(TARGET_CPU)" == "IA64"
        $(OBJDIR)\memccpy.obj  \
        $(OBJDIR)\memchr.obj   \
        $(OBJDIR)\memcmp.obj   \
        $(OBJDIR)\memcpy.obj   \
        $(OBJDIR)\memicmp.obj  \
        $(OBJDIR)\memmove.obj  \
        $(OBJDIR)\memset.obj   \
        $(OBJDIR)\strcat.obj   \
        $(OBJDIR)\strchr.obj   \
        $(OBJDIR)\strcmp.obj   \
        $(OBJDIR)\strcpy.obj   \
        $(OBJDIR)\strcspn.obj  \
        $(OBJDIR)\strdup.obj   \
        $(OBJDIR)\stricmp.obj  \
        $(OBJDIR)\strlen.obj   \
        $(OBJDIR)\strncat.obj  \
        $(OBJDIR)\strncmp.obj  \
        $(OBJDIR)\strncpy.obj  \
        $(OBJDIR)\strnicmp.obj \
        $(OBJDIR)\strnset.obj  \
        $(OBJDIR)\strpbrk.obj  \
        $(OBJDIR)\strrchr.obj  \
        $(OBJDIR)\strrev.obj   \
        $(OBJDIR)\strset.obj   \
        $(OBJDIR)\strspn.obj   \
        $(OBJDIR)\strstr.obj   \
!endif
!if "$(TARGET_CPU)" == "i386"
        $(OBJDIR)\memcpy.obj   \
        $(OBJDIR)\memchr.obj   \
        $(OBJDIR)\memcmp.obj   \
        $(OBJDIR)\memccpy.obj  \
        $(OBJDIR)\_memicmp.obj \
        $(OBJDIR)\memicmp.obj  \
        $(OBJDIR)\memmove.obj  \
        $(OBJDIR)\memset.obj   \
        $(OBJDIR)\strcat.obj   \
        $(OBJDIR)\strchr.obj   \
        $(OBJDIR)\strcmp.obj   \
        $(OBJDIR)\strcspn.obj  \
        $(OBJDIR)\strdup.obj   \
        $(OBJDIR)\_stricmp.obj \
        $(OBJDIR)\stricmp.obj  \
        $(OBJDIR)\strlen.obj   \
        $(OBJDIR)\strncat.obj  \
        $(OBJDIR)\strncmp.obj  \
        $(OBJDIR)\strncpy.obj  \
        $(OBJDIR)\strnicmp.obj \
        $(OBJDIR)\_strnicm.obj \
        $(OBJDIR)\strnset.obj  \
        $(OBJDIR)\strpbrk.obj  \
        $(OBJDIR)\strrchr.obj  \
        $(OBJDIR)\strrev.obj   \
        $(OBJDIR)\strset.obj   \
        $(OBJDIR)\strspn.obj   \
        $(OBJDIR)\strstr.obj   \
!endif
        $(OBJDIR)\strcoll.obj  \
        $(OBJDIR)\stricoll.obj \
        $(OBJDIR)\strlwr.obj   \
        $(OBJDIR)\strncoll.obj \
        $(OBJDIR)\strnicol.obj \
        $(OBJDIR)\strtok.obj   \
        $(OBJDIR)\strupr.obj   \
        $(OBJDIR)\strxfrm.obj  \
        $(OBJDIR)\wcscat.obj   \
        $(OBJDIR)\wcschr.obj   \
        $(OBJDIR)\wcscmp.obj   \
        $(OBJDIR)\wcscoll.obj  \
        $(OBJDIR)\wcscspn.obj  \
        $(OBJDIR)\wcsdup.obj   \
        $(OBJDIR)\wcsicmp.obj  \
        $(OBJDIR)\wcsicoll.obj \
        $(OBJDIR)\wcslen.obj   \
        $(OBJDIR)\wcslwr.obj   \
        $(OBJDIR)\wcsncat.obj  \
        $(OBJDIR)\wcsncmp.obj  \
        $(OBJDIR)\wcsncoll.obj \
        $(OBJDIR)\wcsncpy.obj  \
        $(OBJDIR)\wcsnicmp.obj \
        $(OBJDIR)\wcsnicol.obj \
        $(OBJDIR)\wcsnset.obj  \
        $(OBJDIR)\wcspbrk.obj  \
        $(OBJDIR)\wcsrchr.obj  \
        $(OBJDIR)\wcsrev.obj   \
        $(OBJDIR)\wcsset.obj   \
        $(OBJDIR)\wcsspn.obj   \
        $(OBJDIR)\wcsstr.obj   \
        $(OBJDIR)\wcstok.obj   \
        $(OBJDIR)\wcsupr.obj   \
        $(OBJDIR)\wcsxfrm.obj

TIME_OBJECTS = \
        $(OBJDIR)\asctime.obj  \
        $(OBJDIR)\clock.obj    \
        $(OBJDIR)\ctime.obj    \
        $(OBJDIR)\days.obj     \
        $(OBJDIR)\difftime.obj \
        $(OBJDIR)\dtoxtime.obj \
        $(OBJDIR)\ftime.obj    \
        $(OBJDIR)\gmtime.obj   \
        $(OBJDIR)\localtim.obj \
        $(OBJDIR)\mktime.obj   \
        $(OBJDIR)\strftime.obj \
        $(OBJDIR)\strdate.obj  \
        $(OBJDIR)\strtime.obj  \
        $(OBJDIR)\time.obj     \
        $(OBJDIR)\timeset.obj  \
        $(OBJDIR)\tzset.obj    \
        $(OBJDIR)\utime.obj    \
        $(OBJDIR)\ctime64.obj  \
        $(OBJDIR)\dtoxtm64.obj \
        $(OBJDIR)\ftime64.obj  \
        $(OBJDIR)\gmtime64.obj \
        $(OBJDIR)\loctim64.obj \
        $(OBJDIR)\mktime64.obj \
        $(OBJDIR)\systime.obj  \
        $(OBJDIR)\time64.obj   \
        $(OBJDIR)\utime64.obj  \
        $(OBJDIR)\wcsftime.obj \
        $(OBJDIR)\wasctime.obj \
        $(OBJDIR)\wctime.obj   \
        $(OBJDIR)\wctime64.obj \
        $(OBJDIR)\wstrdate.obj \
        $(OBJDIR)\wstrtime.obj \
        $(OBJDIR)\wutime.obj   \
        $(OBJDIR)\wutime64.obj


$(OBJDIR)\convert.lib: $(CONVERT_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(CONVERT_OBJECTS: =^
)
<<keep


$(OBJDIR)\direct.lib: $(DIRECT_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(DIRECT_OBJECTS: =^
)
<<keep


$(OBJDIR)\dllstuff.lib: $(DLLSTUFF_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(DLLSTUFF_OBJECTS: =^
)
<<keep


$(OBJDIR)\dos.lib: $(DOS_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(DOS_OBJECTS: =^
)
<<keep


$(OBJDIR)\exec.lib: $(EXEC_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(EXEC_OBJECTS: =^
)
<<keep


$(OBJDIR)\heap.lib: $(HEAP_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(HEAP_OBJECTS: =^
)
<<keep


$(OBJDIR)\helper.lib: $(HELPER_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(HELPER_OBJECTS: =^
)
<<keep


$(OBJDIR)\iostream.lib: $(IOSTREAM_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(IOSTREAM_OBJECTS: =^
)
<<keep


$(OBJDIR)\linkopts.lib: $(LINKOPTS_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(LINKOPTS_OBJECTS: =^
)
<<keep


$(OBJDIR)\lowio.lib: $(LOWIO_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(LOWIO_OBJECTS: =^
)
<<keep


$(OBJDIR)\mbstring.lib: $(MBSTRING_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(MBSTRING_OBJECTS: =^
)
<<keep


$(OBJDIR)\misc.lib: $(MISC_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(MISC_OBJECTS: =^
)
<<keep


$(OBJDIR)\startup.lib: $(STARTUP_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(STARTUP_OBJECTS: =^
)
<<keep


$(OBJDIR)\$(STDCPP_SRC).lib: $(STDCPP_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(STDCPP_OBJECTS: =^
)
<<keep


$(OBJDIR)\stdio.lib: $(STDIO_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(STDIO_OBJECTS: =^
)
<<keep


$(OBJDIR)\string.lib: $(STRING_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(STRING_OBJECTS: =^
)
<<keep


$(OBJDIR)\time.lib: $(TIME_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(TIME_OBJECTS: =^
)
<<keep


$(OBJDIR)\eh.lib: $(PREOBJDIR)\eh.lib
        copy $(PREOBJDIR)\eh.lib $@

!if "$(RTC)"=="YES"
$(OBJDIR)\rtc.lib: $(PREOBJDIR)\rtc.lib
        copy $(PREOBJDIR)\rtc.lib $@
!endif

$(OBJDIR)\conv.lib: $(PREOBJDIR)\conv.lib
        copy $(PREOBJDIR)\conv.lib $@

$(OBJDIR)\tran.lib: $(PREOBJDIR)\tran.lib
        copy $(PREOBJDIR)\tran.lib $@

$(OBJDIR)\chkesp.obj: $(PREOBJDIR)\chkesp.obj
        copy $(PREOBJDIR)\chkesp.obj $@

$(OBJDIR)\ehvccctr.obj: $(PREOBJDIR)\ehvccctr.obj
        copy $(PREOBJDIR)\ehvccctr.obj $@

$(OBJDIR)\ehvcccvb.obj: $(PREOBJDIR)\ehvcccvb.obj
        copy $(PREOBJDIR)\ehvcccvb.obj $@

$(OBJDIR)\ehvecctr.obj: $(PREOBJDIR)\ehvecctr.obj
        copy $(PREOBJDIR)\ehvecctr.obj $@

$(OBJDIR)\ehveccvb.obj: $(PREOBJDIR)\ehveccvb.obj
        copy $(PREOBJDIR)\ehveccvb.obj $@

$(OBJDIR)\ehvecdtr.obj: $(PREOBJDIR)\ehvecdtr.obj
        copy $(PREOBJDIR)\ehvecdtr.obj $@

$(OBJDIR)\oldexcpt.obj: $(PREOBJDIR)\oldexcpt.obj
        copy $(PREOBJDIR)\oldexcpt.obj $@

$(OBJDIR)\sehprolg.obj: $(PREOBJDIR)\sehprolg.obj
        copy $(PREOBJDIR)\sehprolg.obj $@

$(OBJDIR)\sehsupp.obj: $(PREOBJDIR)\sehsupp.obj
        copy $(PREOBJDIR)\sehsupp.obj $@

$(OBJDIR)\setjmp.obj: $(PREOBJDIR)\setjmp.obj
        copy $(PREOBJDIR)\setjmp.obj $@

# ******** STRIPLIN=0 ******** 
!if "$(TARGET_CPU)" == "ALPHA" || "$(TARGET_CPU)" == "ALPHA64"

$(OBJDIR)\chandler.obj: $(PREOBJDIR)\chandler.obj
        copy $(PREOBJDIR)\chandler.obj $@

$(OBJDIR)\chkstk.obj: $(PREOBJDIR)\chkstk.obj
        copy $(PREOBJDIR)\chkstk.obj $@

$(OBJDIR)\divdat.obj: $(PREOBJDIR)\divdat.obj
        copy $(PREOBJDIR)\divdat.obj $@

$(OBJDIR)\divide2.obj: $(PREOBJDIR)\divide2.obj
        copy $(PREOBJDIR)\divide2.obj $@

$(OBJDIR)\extv.obj: $(PREOBJDIR)\extv.obj
        copy $(PREOBJDIR)\extv.obj $@

$(OBJDIR)\extvvol.obj: $(PREOBJDIR)\extvvol.obj
        copy $(PREOBJDIR)\extvvol.obj $@

$(OBJDIR)\extzv.obj: $(PREOBJDIR)\extzv.obj
        copy $(PREOBJDIR)\extzv.obj $@

$(OBJDIR)\extzvvol.obj: $(PREOBJDIR)\extzvvol.obj
        copy $(PREOBJDIR)\extzvvol.obj $@

$(OBJDIR)\ghandler.obj: $(PREOBJDIR)\ghandler.obj
        copy $(PREOBJDIR)\ghandler.obj $@

$(OBJDIR)\insv.obj: $(PREOBJDIR)\insv.obj
        copy $(PREOBJDIR)\insv.obj $@

$(OBJDIR)\insvvol.obj: $(PREOBJDIR)\insvvol.obj
        copy $(PREOBJDIR)\insvvol.obj $@

$(OBJDIR)\jmpuwind.obj: $(PREOBJDIR)\jmpuwind.obj
        copy $(PREOBJDIR)\jmpuwind.obj $@

$(OBJDIR)\longjmp.obj: $(PREOBJDIR)\longjmp.obj
        copy $(PREOBJDIR)\longjmp.obj $@

$(OBJDIR)\matherr.obj: $(PREOBJDIR)\matherr.obj
        copy $(PREOBJDIR)\matherr.obj $@

$(OBJDIR)\memcmp_.obj: $(PREOBJDIR)\memcmp_.obj
        copy $(PREOBJDIR)\memcmp_.obj $@

$(OBJDIR)\otsdiv.obj: $(PREOBJDIR)\otsdiv.obj
        copy $(PREOBJDIR)\otsdiv.obj $@

$(OBJDIR)\otsjmp.obj: $(PREOBJDIR)\otsjmp.obj
        copy $(PREOBJDIR)\otsjmp.obj $@

$(OBJDIR)\otsjmpex.obj: $(PREOBJDIR)\otsjmpex.obj
        copy $(PREOBJDIR)\otsjmpex.obj $@

$(OBJDIR)\otsuwind.obj: $(PREOBJDIR)\otsuwind.obj
        copy $(PREOBJDIR)\otsuwind.obj $@

$(OBJDIR)\scmpeql.obj: $(PREOBJDIR)\scmpeql.obj
        copy $(PREOBJDIR)\scmpeql.obj $@

$(OBJDIR)\scmpeqlp.obj: $(PREOBJDIR)\scmpeqlp.obj
        copy $(PREOBJDIR)\scmpeqlp.obj $@

$(OBJDIR)\scmpleq.obj: $(PREOBJDIR)\scmpleq.obj
        copy $(PREOBJDIR)\scmpleq.obj $@

$(OBJDIR)\scmpleqp.obj: $(PREOBJDIR)\scmpleqp.obj
        copy $(PREOBJDIR)\scmpleqp.obj $@

$(OBJDIR)\scmplss.obj: $(PREOBJDIR)\scmplss.obj
        copy $(PREOBJDIR)\scmplss.obj $@

$(OBJDIR)\scmplssp.obj: $(PREOBJDIR)\scmplssp.obj
        copy $(PREOBJDIR)\scmplssp.obj $@

$(OBJDIR)\setjmpex.obj: $(PREOBJDIR)\setjmpex.obj
        copy $(PREOBJDIR)\setjmpex.obj $@

$(OBJDIR)\sfill.obj: $(PREOBJDIR)\sfill.obj
        copy $(PREOBJDIR)\sfill.obj $@

$(OBJDIR)\sfillx.obj: $(PREOBJDIR)\sfillx.obj
        copy $(PREOBJDIR)\sfillx.obj $@

$(OBJDIR)\sfwdcpy.obj: $(PREOBJDIR)\sfwdcpy.obj
        copy $(PREOBJDIR)\sfwdcpy.obj $@

$(OBJDIR)\sloc.obj: $(PREOBJDIR)\sloc.obj
        copy $(PREOBJDIR)\sloc.obj $@

$(OBJDIR)\smove.obj: $(PREOBJDIR)\smove.obj
        copy $(PREOBJDIR)\smove.obj $@

$(OBJDIR)\smovem.obj: $(PREOBJDIR)\smovem.obj
        copy $(PREOBJDIR)\smovem.obj $@

$(OBJDIR)\strans.obj: $(PREOBJDIR)\strans.obj
        copy $(PREOBJDIR)\strans.obj $@

$(OBJDIR)\strcmp_.obj: $(PREOBJDIR)\strcmp_.obj
        copy $(PREOBJDIR)\strcmp_.obj $@

$(OBJDIR)\strcmps.obj: $(PREOBJDIR)\strcmps.obj
        copy $(PREOBJDIR)\strcmps.obj $@

$(OBJDIR)\strcpy_.obj: $(PREOBJDIR)\strcpy_.obj
        copy $(PREOBJDIR)\strcpy_.obj $@

$(OBJDIR)\strcpys.obj: $(PREOBJDIR)\strcpys.obj
        copy $(PREOBJDIR)\strcpys.obj $@

$(OBJDIR)\strlen_.obj: $(PREOBJDIR)\strlen_.obj
        copy $(PREOBJDIR)\strlen_.obj $@

$(OBJDIR)\strlens.obj: $(PREOBJDIR)\strlens.obj
        copy $(PREOBJDIR)\strlens.obj $@

$(OBJDIR)\szero.obj: $(PREOBJDIR)\szero.obj
        copy $(PREOBJDIR)\szero.obj $@

$(OBJDIR)\tlssup.obj: $(PREOBJDIR)\tlssup.obj
        copy $(PREOBJDIR)\tlssup.obj $@
!endif
# ******** STRIPLIN=1 ******** 

!if "$(TARGET_CPU)" == "i386"

$(OBJDIR)\atlssup.obj: $(PREOBJDIR)\atlssup.obj
        copy $(PREOBJDIR)\atlssup.obj $@

$(OBJDIR)\bsku.obj: $(PREOBJDIR)\bsku.obj
        copy $(PREOBJDIR)\bsku.obj $@

$(OBJDIR)\ehprolg2.obj: $(PREOBJDIR)\ehprolg2.obj
        copy $(PREOBJDIR)\ehprolg2.obj $@

$(OBJDIR)\ehprolog.obj: $(PREOBJDIR)\ehprolog.obj
        copy $(PREOBJDIR)\ehprolog.obj $@

$(OBJDIR)\exsup.obj: $(PREOBJDIR)\exsup.obj
        copy $(PREOBJDIR)\exsup.obj $@

$(OBJDIR)\exsup2.obj: $(PREOBJDIR)\exsup2.obj
        copy $(PREOBJDIR)\exsup2.obj $@

$(OBJDIR)\exsup3.obj: $(PREOBJDIR)\exsup3.obj
        copy $(PREOBJDIR)\exsup3.obj $@

$(OBJDIR)\ftol2.obj: $(PREOBJDIR)\ftol2.obj
        copy $(PREOBJDIR)\ftol2.obj $@

$(OBJDIR)\longjmp.obj: $(PREOBJDIR)\longjmp.obj
        copy $(PREOBJDIR)\longjmp.obj $@

$(OBJDIR)\matherr.obj: $(PREOBJDIR)\matherr.obj
        copy $(PREOBJDIR)\matherr.obj $@

$(OBJDIR)\setjmp3.obj: $(PREOBJDIR)\setjmp3.obj
        copy $(PREOBJDIR)\setjmp3.obj $@

$(OBJDIR)\setjmpex.obj: $(PREOBJDIR)\setjmpex.obj
        copy $(PREOBJDIR)\setjmpex.obj $@

$(OBJDIR)\tlssup.obj: $(PREOBJDIR)\tlssup.obj
        copy $(PREOBJDIR)\tlssup.obj $@

########
#
# These objects can be built from (assembler) source by editing
# makefile.sub so that the symbol BLD_ASM is set to the value 1.
# To assembler these objects, you must have MASM 6.11a or later.
#
########

!if "$(BLD_ASM)"=="0"

$(OBJDIR)\chkstk.obj: $(PREOBJDIR)\chkstk.obj
        copy $(PREOBJDIR)\chkstk.obj $@

$(OBJDIR)\dllsupp.obj: $(PREOBJDIR)\dllsupp.obj
        copy $(PREOBJDIR)\dllsupp.obj $@

$(OBJDIR)\enable.obj: $(PREOBJDIR)\enable.obj
        copy $(PREOBJDIR)\enable.obj $@

$(OBJDIR)\inp.obj: $(PREOBJDIR)\inp.obj
        copy $(PREOBJDIR)\inp.obj $@

$(OBJDIR)\lldiv.obj: $(PREOBJDIR)\lldiv.obj
        copy $(PREOBJDIR)\lldiv.obj $@

$(OBJDIR)\lldvrm.obj: $(PREOBJDIR)\lldvrm.obj
        copy $(PREOBJDIR)\lldvrm.obj $@

$(OBJDIR)\llmul.obj: $(PREOBJDIR)\llmul.obj
        copy $(PREOBJDIR)\llmul.obj $@

$(OBJDIR)\llrem.obj: $(PREOBJDIR)\llrem.obj
        copy $(PREOBJDIR)\llrem.obj $@

$(OBJDIR)\llshl.obj: $(PREOBJDIR)\llshl.obj
        copy $(PREOBJDIR)\llshl.obj $@

$(OBJDIR)\llshr.obj: $(PREOBJDIR)\llshr.obj
        copy $(PREOBJDIR)\llshr.obj $@

$(OBJDIR)\memccpy.obj: $(PREOBJDIR)\memccpy.obj
        copy $(PREOBJDIR)\memccpy.obj $@

$(OBJDIR)\memchr.obj: $(PREOBJDIR)\memchr.obj
        copy $(PREOBJDIR)\memchr.obj $@

$(OBJDIR)\memcmp.obj: $(PREOBJDIR)\memcmp.obj
        copy $(PREOBJDIR)\memcmp.obj $@

$(OBJDIR)\memcpy.obj: $(PREOBJDIR)\memcpy.obj
        copy $(PREOBJDIR)\memcpy.obj $@

$(OBJDIR)\_memicmp.obj: $(PREOBJDIR)\_memicmp.obj
        copy $(PREOBJDIR)\_memicmp.obj $@

$(OBJDIR)\memmove.obj: $(PREOBJDIR)\memmove.obj
        copy $(PREOBJDIR)\memmove.obj $@

$(OBJDIR)\memset.obj: $(PREOBJDIR)\memset.obj
        copy $(PREOBJDIR)\memset.obj $@

$(OBJDIR)\outp.obj: $(PREOBJDIR)\outp.obj
        copy $(PREOBJDIR)\outp.obj $@

$(OBJDIR)\strcat.obj: $(PREOBJDIR)\strcat.obj
        copy $(PREOBJDIR)\strcat.obj $@

$(OBJDIR)\strchr.obj: $(PREOBJDIR)\strchr.obj
        copy $(PREOBJDIR)\strchr.obj $@

$(OBJDIR)\strcmp.obj: $(PREOBJDIR)\strcmp.obj
        copy $(PREOBJDIR)\strcmp.obj $@

$(OBJDIR)\strcspn.obj: $(PREOBJDIR)\strcspn.obj
        copy $(PREOBJDIR)\strcspn.obj $@

$(OBJDIR)\strdup.obj: $(PREOBJDIR)\strdup.obj
        copy $(PREOBJDIR)\strdup.obj $@

$(OBJDIR)\_stricmp.obj: $(PREOBJDIR)\_stricmp.obj
        copy $(PREOBJDIR)\_stricmp.obj $@

$(OBJDIR)\strlen.obj: $(PREOBJDIR)\strlen.obj
        copy $(PREOBJDIR)\strlen.obj $@

$(OBJDIR)\strncat.obj: $(PREOBJDIR)\strncat.obj
        copy $(PREOBJDIR)\strncat.obj $@

$(OBJDIR)\strncmp.obj: $(PREOBJDIR)\strncmp.obj
        copy $(PREOBJDIR)\strncmp.obj $@

$(OBJDIR)\strncpy.obj: $(PREOBJDIR)\strncpy.obj
        copy $(PREOBJDIR)\strncpy.obj $@

$(OBJDIR)\_strnicm.obj: $(PREOBJDIR)\_strnicm.obj
        copy $(PREOBJDIR)\_strnicm.obj $@

$(OBJDIR)\strnset.obj: $(PREOBJDIR)\strnset.obj
        copy $(PREOBJDIR)\strnset.obj $@

$(OBJDIR)\strpbrk.obj: $(PREOBJDIR)\strpbrk.obj
        copy $(PREOBJDIR)\strpbrk.obj $@

$(OBJDIR)\strrchr.obj: $(PREOBJDIR)\strrchr.obj
        copy $(PREOBJDIR)\strrchr.obj $@

$(OBJDIR)\strrev.obj: $(PREOBJDIR)\strrev.obj
        copy $(PREOBJDIR)\strrev.obj $@

$(OBJDIR)\strset.obj: $(PREOBJDIR)\strset.obj
        copy $(PREOBJDIR)\strset.obj $@

$(OBJDIR)\strspn.obj: $(PREOBJDIR)\strspn.obj
        copy $(PREOBJDIR)\strspn.obj $@

$(OBJDIR)\strstr.obj: $(PREOBJDIR)\strstr.obj
        copy $(PREOBJDIR)\strstr.obj $@

$(OBJDIR)\ulldiv.obj: $(PREOBJDIR)\ulldiv.obj
        copy $(PREOBJDIR)\ulldiv.obj $@

$(OBJDIR)\ulldvrm.obj: $(PREOBJDIR)\ulldvrm.obj
        copy $(PREOBJDIR)\ulldvrm.obj $@

$(OBJDIR)\ullrem.obj: $(PREOBJDIR)\ullrem.obj
        copy $(PREOBJDIR)\ullrem.obj $@

$(OBJDIR)\ullshr.obj    : $(PREOBJDIR)\ullshr.obj
        copy $(PREOBJDIR)\ullshr.obj $@

!endif # BLD_ASM==0
!endif # TARGET_CPU == i386

!if "$(TARGET_CPU)" == "IA64"

$(OBJDIR)\chandler.obj: $(PREOBJDIR)\chandler.obj
        copy $(PREOBJDIR)\chandler.obj $@

$(OBJDIR)\cinitone.obj: $(PREOBJDIR)\cinitone.obj
        copy $(PREOBJDIR)\cinitone.obj $@

$(OBJDIR)\jmpuwind.obj: $(PREOBJDIR)\jmpuwind.obj
        copy $(PREOBJDIR)\jmpuwind.obj $@

$(OBJDIR)\longjmp.obj: $(PREOBJDIR)\longjmp.obj
        copy $(PREOBJDIR)\longjmp.obj $@

$(OBJDIR)\miscs.obj: $(PREOBJDIR)\miscs.obj
        copy $(PREOBJDIR)\miscs.obj $@

$(OBJDIR)\setjmpex.obj: $(PREOBJDIR)\setjmpex.obj
        copy $(PREOBJDIR)\setjmpex.obj $@

$(OBJDIR)\strcat.obj: $(PREOBJDIR)\strcat.obj
        copy $(PREOBJDIR)\strcat.obj $@

$(OBJDIR)\strcpy.obj: $(PREOBJDIR)\strcpy.obj
        copy $(PREOBJDIR)\strcpy.obj $@

$(OBJDIR)\strcmp.obj: $(PREOBJDIR)\strcmp.obj
        copy $(PREOBJDIR)\strcmp.obj $@

$(OBJDIR)\strlen.obj: $(PREOBJDIR)\strlen.obj
        copy $(PREOBJDIR)\strlen.obj $@

$(OBJDIR)\memcpy.obj: $(PREOBJDIR)\memcpy.obj
        copy $(PREOBJDIR)\memcpy.obj $@

$(OBJDIR)\memmove.obj: $(PREOBJDIR)\memmove.obj
        copy $(PREOBJDIR)\memmove.obj $@

$(OBJDIR)\memset.obj: $(PREOBJDIR)\memset.obj
        copy $(PREOBJDIR)\memset.obj $@

$(OBJDIR)\chkstk.obj: $(PREOBJDIR)\chkstk.obj
        copy $(PREOBJDIR)\chkstk.obj $@

$(OBJDIR)\tlssup.obj: $(PREOBJDIR)\tlssup.obj
        copy $(PREOBJDIR)\tlssup.obj $@

$(OBJDIR)\matherr.obj: $(PREOBJDIR)\matherr.obj
        copy $(PREOBJDIR)\matherr.obj $@

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\bsku\bsku.cpp ===
/***
*bsku.cpp 
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Nagware for book SKU.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from DanS)
*       03-27-01  PML   .CRT$XI routines must now return 0 or _RT_* fatal
*                       error code (vs7#231220)
*
****/

///
// Implement the annoying message for the book sku.
//

#include <windows.h>

//
// Include user32.lib
//
#pragma comment(lib, "user32.lib")


static int __cdecl
__runtimeBSKU() {
    ::MessageBox(
        NULL,
        "Note:  The terms of the End User License Agreement for Visual C++ Introductory Edition do not permit redistribution of executables you create with this Product.",
        "Microsoft (R) Visual C++",
        MB_OK|MB_ICONWARNING
        );

    return 0;
}

#pragma data_seg(".CRT$XIB")
extern "C"
int (__cdecl * __pfnBkCheck)() = __runtimeBSKU;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\atof.c ===
/***
*atof.c - convert char string to floating point number
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a character string into a floating point number.
*
*Revision History:
*       09-09-87  RKW   written
*       04-13-87  JCR   added const to declaration
*       11-09-87  BCM   different interface under ifdef MTHREAD
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-24-88  PHG   Merged DLL and normal versions
*       08-18-88  PHG   now calls isspace to process all kinds of whitespce
*       10-04-88  JCR   386: Removed 'far' keyword
*       11-20-89  JCR   atof() is always _cdecl in 386 (not pascal)
*       03-05-90  GJF   Fixed calling type, added #include <cruntime.h>,
*                       removed #include <register.h>, removed some redundant
*                       prototypes, removed some leftover 16-bit support and
*                       fixed the copyright. Also, cleaned up the formatting
*                       a bit.
*       07-20-90  SBM   Compiles cleanly with -W3 (added/removed appropriate
*                       #includes)
*       08-01-90  SBM   Renamed <struct.h> to <fltintrn.h>
*       09-27-90  GJF   New-style function declarator.
*       10-21-92  GJF   Made char-to-int conversion unsigned.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       12-15-98  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <cruntime.h>
#include <fltintrn.h>
#include <string.h>
#include <ctype.h>

/***
*double atof(nptr) - convert string to floating point number
*
*Purpose:
*       atof recognizes an optional string of whitespace, then
*       an optional sign, then a string of digits optionally
*       containing a decimal point, then an optional e or E followed
*       by an optionally signed integer, and converts all this to
*       to a floating point number.  The first unrecognized
*       character ends the string.
*
*Entry:
*       nptr - pointer to string to convert
*
*Exit:
*       returns floating point value of character representation
*
*Exceptions:
*
*******************************************************************************/

double __cdecl atof(
        REG1 const char *nptr
        )
{

#ifdef  _MT
        struct _flt fltstruct;      /* temporary structure */
#endif

        /* scan past leading space/tab characters */

        while ( isspace((int)(unsigned char)*nptr) )
                nptr++;

        /* let _fltin routine do the rest of the work */

#ifdef  _MT
        return( *(double *)&(_fltin2( &fltstruct, nptr, (int)strlen(nptr), 0, 0 )->
        dval) );
#else
        return( *(double *)&(_fltin( nptr, (int)strlen(nptr), 0, 0 )->dval) );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\fcvt.c ===
/***
*fcvt.c - convert floating point value to string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Converts a floating point value to a string.
*
*Revision History:
*	09-09-83  RKW	written
*	09-14-84  DFW	fixed problems with buffer overflow and
*			streamlined the code
*	11-09-87  BCM	different interface under ifdef MTHREAD
*	11-19-87  WAJ	fcvt now uses emulator data area for buffer
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-24-88  PHG	Merged DLL and normal versions
*	10-04-88  JCR	386: Removed 'far' keyword
*	10-20-88  JCR	Changed 'DOUBLE' to 'double' for 386
*	03-02-90  GJF	Added #include <cruntime.h>. Removed some (now) useless
*			preprocessor directives. Also, fixed copyright.
*	03-06-90  GJF	Fixed calling type, removed some leftover 16-bit
*			support.
*	03-23-90  GJF	Made _fpcvt() _CALLTYPE4 and removed prototype for
*			_fptostr() (now in struct.h).
*	08-01-90  SBM	Renamed <struct.h> to <fltintrn.h>
*	09-27-90  GJF	New-style function declarators.
*	01-21-91  GJF	ANSI naming.
*	10-03-91  JCR	Fixed mthread buffer allocation
*	02-16-93  GJF	Changed for new _getptd().
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*	08-05-94  JWM	Insure that _ecvt returns no more than ndigits.
*	09-06-94  CFW   Remove Cruiser support.
*	09-06-94  CFW	Replace MTHREAD with _MT.
*	01-10-95  CFW	Debug CRT allocs.
*	09-05-00  GB    Changed the defination of fltout functions. Use DOUBLE 
*	                instead of double
*
*******************************************************************************/

#include <cruntime.h>
#include <fltintrn.h>
#include <cvt.h>
#include <mtdll.h>
#include <stdlib.h>
#include <dbgint.h>

/*
 * The static character array buf[CVTBUFSIZE] is used by the _fpcvt routine
 * (the workhorse for _ecvt and _fcvt) for storage of its output.  The routine
 * gcvt expects the user to have set up their own storage.  CVTBUFSIZE is set
 * large enough to accomodate the largest double precision number plus 40
 * decimal places (even though you only have 16 digits of accuracy in a
 * double precision IEEE number, the user may ask for more to effect 0
 * padding; but there has to be a limit somewhere).
 */

/*
 * define a maximum size for the conversion buffer.  It should be at least
 * as long as the number of digits in the largest double precision value
 * (?.?e308 in IEEE arithmetic).  We will use the same size buffer as is
 * used in the printf support routine (_output)
 */

#ifdef	_MT
char * __cdecl _fpcvt(STRFLT, int, int *, int *);
#else
static char * __cdecl _fpcvt(STRFLT, int, int *, int *);
static char buf[CVTBUFSIZE];
#endif

/***
*char *_fcvt(value, ndec, decpr, sign) - convert floating point to char string
*
*Purpose:
*	_fcvt like _ecvt converts the value to a null terminated
*	string of ASCII digits, and returns a pointer to the
*	result.  The routine prepares data for Fortran F-format
*	output with the number of digits following the decimal
*	point specified by ndec.  The position of the decimal
*	point relative to the beginning of the string is returned
*	indirectly through decpt.  The correct digit for Fortran
*	F-format is rounded.
*	NOTE - to avoid the possibility of generating floating
*	point instructions in this code we fool the compiler
*	about the type of the 'value' parameter using a struct.
*	This is OK since all we do is pass it off as a
*	parameter.
*
*Entry:
*	double value - number to be converted
*	int ndec - number of digits after decimal point
*
*Exit:
*	returns pointer to the character string representation of value.
*	also, the output is written into the static char array buf.
*	int *decpt - pointer to int with pos. of dec. point
*	int *sign - pointer to int with sign (0 = pos, non-0 = neg)
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _fcvt (
	double value,
	int ndec,
	int *decpt,
	int *sign
	)
{
	REG1 STRFLT pflt;
    DOUBLE *pdvalue = (DOUBLE *)&value;

#ifdef	_MT
	struct _strflt strfltstruct;
	char resultstring[21];

	/* ok to take address of stack struct here; fltout2 knows to use ss */
	pflt = _fltout2( *pdvalue, &strfltstruct, resultstring );


#else
	pflt = _fltout( *pdvalue );
#endif

	return( _fpcvt( pflt, pflt->decpt + ndec, decpt, sign ) );
}


/***
*char *_ecvt( value, ndigit, decpt, sign ) - convert floating point to string
*
*Purpose:
*	_ecvt converts value to a null terminated string of
*	ASCII digits, and returns a pointer to the result.
*	The position of the decimal point relative to the
*	begining of the string is stored indirectly through
*	decpt, where negative means to the left of the returned
*	digits.  If the sign of the result is negative, the
*	word pointed to by sign is non zero, otherwise it is
*	zero.  The low order digit is rounded.
*
*Entry:
*	double value - number to be converted
*	int ndigit - number of digits after decimal point
*
*Exit:
*	returns pointer to the character representation of value.
*	also the output is written into the statuc char array buf.
*	int *decpt - pointer to int with position of decimal point
*	int *sign - pointer to int with sign in it (0 = pos, non-0 = neg)
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _ecvt (
	double value,
	int ndigit,
	int *decpt,
	int *sign
	)
{

	char *retbuf;
    DOUBLE *pdvalue = (DOUBLE *)&value;

#ifdef	_MT
	REG1 STRFLT pflt;

	struct _strflt strfltstruct;	    /* temporary buffers */
	char resultstring[21];

	/* ok to take address of stack struct here; fltout2 knows to use ss */
	pflt = _fltout2( *pdvalue, &strfltstruct, resultstring );

	retbuf = _fpcvt( pflt, ndigit, decpt, sign );

#else
	retbuf = _fpcvt( _fltout(*pdvalue), ndigit, decpt, sign );
#endif

	/* _fptostr() occasionally returns an extra character in the buffer ... */

	if (retbuf[ndigit])
		retbuf[ndigit] = '\0';
	return( retbuf );
}


/***
*char *_fpcvt() - gets final string and sets decpt and sign	[STATIC]
*
*Purpose:
*	This is a small common routine used by [ef]cvt.  It calls fptostr
*	to get the final string and sets the decpt and sign indicators.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef	_MT
char * __cdecl _fpcvt (
#else
static char * __cdecl _fpcvt (
#endif
	REG2 STRFLT pflt,
	REG3 int digits,
	int *decpt,
	int *sign
	)
{

#ifdef	_MT

	/* use a per-thread buffer */

	char *buf;

	_ptiddata ptd;

	ptd = _getptd();
	if ( ptd->_cvtbuf == NULL )
		if ( (ptd->_cvtbuf = _malloc_crt(CVTBUFSIZE)) == NULL )
			return(NULL);
	buf = ptd->_cvtbuf;

#endif	/* _MT */


	/* make sure we don't overflow the buffer size.  If the user asks for
	 * more digits than the buffer can handle, truncate it to the maximum
	 * size allowed in the buffer.	The maximum size is CVTBUFSIZE - 2
	 * since we useone character for overflow and one for the terminating
	 * null character.
	 */

	_fptostr(buf, (digits > CVTBUFSIZE - 2) ? CVTBUFSIZE - 2 : digits, pflt);

	/* set the sign flag and decimal point position */

	*sign = (pflt->sign == '-') ? 1 : 0;
	*decpt = pflt->decpt;
	return(buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\atox.c ===
/***
*atox.c - atoi and atol conversion
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a character string into an int or long.
*
*Revision History:
*       06-05-89  PHG   Module created, based on asm version
*       03-05-90  GJF   Fixed calling type, added #include <cruntime.h> and
*                       cleaned up the formatting a bit. Also, fixed the
*                       copyright.
*       09-27-90  GJF   New-style function declarators.
*       10-21-92  GJF   Fixed conversions of char to int.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       01-19-96  BWT   Add __int64 version.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-23-00  GB    Added Unicode function.
*       08-16-00  GB    Added multilingual support to unicode wtox fundtions.
*       11-01-00  PML   Fix _NTSUBSET_ build.
*       05-11-01  BWT   A NULL string returns 0, not AV.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <ctype.h>
#include <mtdll.h>
#ifdef _MBCS
#undef _MBCS
#endif
#include <tchar.h>

#ifndef _UNICODE
#define _tchartodigit(c)    ((c) >= '0' && (c) <= '9' ? (c) - '0' : -1)
#else
int _wchartodigit(wchar_t);
#define _tchartodigit(c)    _wchartodigit((wchar_t)(c))
#endif

/***
*long atol(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       Overflow is not detected.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       return long int value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

long __cdecl _tstol(
        const _TCHAR *nptr
        )
{
        int c;              /* current char */
        long total;         /* current total */
        int sign;           /* if '-', then negative, otherwise positive */
#if defined( _MT) && !defined(_UNICODE)
        pthreadlocinfo ptloci;
#endif

        if (!nptr)
            return 0;

#if defined( _MT) && !defined(_UNICODE)
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        /* skip whitespace */
        while ( __isspace_mt(ptloci, (int)(_TUCHAR)*nptr) )
#else
        while ( _istspace((int)(_TUCHAR)*nptr) )
#endif
            ++nptr;

        c = (int)(_TUCHAR)*nptr++;
        sign = c;           /* save sign indication */
        if (c == _T('-') || c == _T('+'))
            c = (int)(_TUCHAR)*nptr++;    /* skip sign */

        total = 0;

        while ( (c = _tchartodigit(c)) != -1 ) {
            total = 10 * total + c;     /* accumulate digit */
            c = (_TUCHAR)*nptr++;    /* get next char */
        }

        if (sign == '-')
            return -total;
        else
            return total;   /* return result, negated if necessary */
}


/***
*int atoi(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       Overflow is not detected.  Because of this, we can just use
*       atol().
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       return int value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

int __cdecl _tstoi(
        const _TCHAR *nptr
        )
{
        return (int)_tstol(nptr);
}

#ifndef _NO_INT64

__int64 __cdecl _tstoi64(
        const _TCHAR *nptr
        )
{
        int c;              /* current char */
        __int64 total;      /* current total */
        int sign;           /* if '-', then negative, otherwise positive */
#if  defined(_MT) && !defined(_UNICODE)
        pthreadlocinfo ptloci;
#endif
        if (!nptr)
            return 0i64;

#if  defined(_MT) && !defined(_UNICODE)
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        /* skip whitespace */
        while ( __isspace_mt(ptloci, (int)(_TUCHAR)*nptr) )
#else
        while ( _istspace((int)(_TUCHAR)*nptr) )
#endif
            ++nptr;

        c = (int)(_TUCHAR)*nptr++;
        sign = c;           /* save sign indication */
        if (c == _T('-') || c == _T('+'))
            c = (int)(_TUCHAR)*nptr++;    /* skip sign */

        total = 0;

        while ( (c = _tchartodigit(c)) != -1 ) {
            total = 10 * total + c;     /* accumulate digit */
            c = (_TUCHAR)*nptr++;    /* get next char */
        }

        if (sign == _T('-'))
            return -total;
        else
            return total;   /* return result, negated if necessary */
}

#endif /* _NO_INT64 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\gcvt.c ===
/***
*gcvt.c - convert floating point number to character string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Converts floating point number into character string representation.
*
*Revision History:
*	09-09-93  RKW	written
*	11-09-87  BCM	different interface under ifdef MTHREAD
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-24-88  PHG	Merged DLL and normal versions
*	10-20-88  JCR	Changed 'DOUBLE' to 'double' for 386
*	06-27-89  PHG	Changed "ndec" to "ndec-1" to correct significant
*			digits in exponential format (C6 bug #2124)
*	03-05-90  GJF	Fixed calling type, added #include <cruntime.h>,
*			removed #include <register.h>, removed redundant
*			prototypes, removed some leftover 16-bit support and
*			fixed the copyright. Also, cleaned up the formatting
*			a bit.
*	07-20-90  SBM	Compiles cleanly with -W3 (added/removed appropriate
*			#includes)
*	08-01-90  SBM	Renamed <struct.h> to <fltintrn.h>
*	09-27-90  GJF	New-style function declarators.
*	01-21-91  GJF	ANSI naming.
*	08-13-92  SKS	An old bug that was fixed in C 6.0 but that did not
*			make it into C 7.0, an off by 1 error when switching
*			from fixed point to scientific notation
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*	09-06-94  CFW	Replace MTHREAD with _MT.
*	12-21-95  JWM	Replaced '.' with *__decimal_point; includes nlsint.h.
*	09-05-00  GB    Changed the defination of fltout functions. Use DOUBLE 
*	                instead of double
*
*******************************************************************************/

#include <cruntime.h>
#include <fltintrn.h>
#include <internal.h>
#include <nlsint.h>

/***
*double _gcvt(value, ndec, buffer) - convert floating point value to char
*	string
*
*Purpose:
*	_gcvt converts the value to a null terminated ASCII string
*	buf.  It attempts to produce ndigit significant digits
*	in Fortran F format if possible, ortherwise E format,
*	ready for printing.  Trailing zeros may be suppressed.
*	No error checking or overflow protection is provided.
*	NOTE - to avoid the possibility of generating floating
*	point instructions in this code we fool the compiler
*	about the type of the 'value' parameter using a struct.
*	This is OK since all we do is pass it off as a
*	parameter.
*
*Entry:
*	value - double - number to be converted
*	ndec - int - number of significant digits
*	buf - char * - buffer to place result
*
*Exit:
*	result is written into buffer; it will be overwritten if it has
*	not been made big enough.
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _gcvt (
	double value,
	int ndec,
	char *buf
	)
{

#ifdef	_MT
	struct _strflt strfltstruct;	/* temporary buffers */
	char   resultstring[21];
#endif

	STRFLT string;
	int    magnitude;
	char   *rc;
    DOUBLE *pdvalue = (DOUBLE *)&value;

	REG1 char *str;
	REG2 char *stop;

	/* get the magnitude of the number */

#ifdef	_MT
	string = _fltout2( *pdvalue, &strfltstruct, resultstring );
#else
	string = _fltout( *pdvalue );
#endif

	magnitude = string->decpt - 1;

	/* output the result according to the Fortran G format as outlined in
	   Fortran language specification */

	if ( magnitude < -1  ||  magnitude > ndec-1 )
		/* then  Ew.d  d = ndec */
		rc = str = _cftoe( &value, buf, ndec-1, 0);
	else
		/* Fw.d  where d = ndec-string->decpt */
		rc = str = _cftof( &value, buf, ndec-string->decpt );

	while (*str && *str != *__decimal_point)
		str++;

	if (*str++) {
		while (*str && *str != 'e')
			str++;

		stop = str--;

		while (*str == '0')
			str--;

		while (*++str = *stop++)
			;
	}

	return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\isctype.c ===
/***
*isctype.c - support is* ctype functions/macros for two-byte multibyte chars
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _isctype.c - support is* ctype functions/macros for
*       two-byte multibyte chars.
*
*Revision History:
*       10-11-91  ETC   Created.
*       12-08-91  ETC   Updated api; added multhread lock; check char masks.
*       04-06-92  KRS   Fix logic error in return value.
*       08-07-92  GJF   _CALLTYPE4 (bogus usage) -> _CRTAPI1 (legit).
*       01-19-93  CFW   Change C1_* to new names, call new APIs.
*       03-04-93  CFW   Removed CTRL-Z.
*       04-01-93  CFW   Remove EOF test (handled by array), return masked.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-27-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Add code page for __crtxxx().
*       04-18-93  CFW   Pass lcid to _GetStringType.
*       09-06-94  CFW   Remove _INTL switch.
*       01-07-95  CFW   Mac merge cleanup.
*       04-01-96  BWT   POSIX work.
*       06-21-96  GJF   Replaced defined(_WIN32) with !defined(_MAC).
*       03-16-97  RDK   Added error flag to __crtGetStringTypeA.
*       07-20-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*       10-25-99  GB    VS7#5695 Added a _chvalidator for debug version
*       02-27-01  PML   Turn on _chvalidator in /ML builds (vs7#213380)
*
*******************************************************************************/

#include <stdio.h>
#include <cruntime.h>
#include <ctype.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>

#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

/*
 *  Use GetCharType() API so check that character type masks agree between
 *  ctype.h and winnls.h
 */
#if     _UPPER   != C1_UPPER || /*IFSTRIP=IGN*/ \
        _LOWER   != C1_LOWER || \
        _DIGIT   != C1_DIGIT || \
        _SPACE   != C1_SPACE || \
        _PUNCT   != C1_PUNCT || \
        _CONTROL != C1_CNTRL
#error Character type masks do not agree in ctype and winnls
#endif



/***
* __chvalidator
*
* Purpose:
*       This function is called by character testing functions in debug
*       versions. This function test for validation of c as character.
*       For improvement in performance, it is not used in non-debug 
*       version.  It is available in the static single-thread non-debug
*       build, though, just in case C code that includes ctype.h is compiled
*       /D_DEBUG /ML.
*       
*******************************************************************************/

#if !defined(_MT) || defined(_DEBUG)
int __cdecl _chvalidator(
        int c,
        int mask
        )
{
        _ASSERTE((unsigned)(c + 1) <= 256);
        return ( _pctype[c] & mask);
}
#endif  /* !_MT || _DEBUG */

#if defined(_MT) && defined(_DEBUG)
int __cdecl _chvalidator_mt(
        pthreadlocinfo p,
        int c,
        int mask
        )
{
        _ASSERTE((unsigned)(c + 1) <= 256);
        return (p->pctype[c] & mask);
}

#endif  /* _MT && _DEBUG */

/***
*_isctype - support is* ctype functions/macros for two-byte multibyte chars
*
*Purpose:
*       This function is called by the is* ctype functions/macros
*       (e.g. isalpha()) when their argument is a two-byte multibyte char.
*       Returns true or false depending on whether the argument satisfies
*       the character class property encoded by the mask.
*
*Entry:
*       int c - the multibyte character whose type is to be tested
*       unsigned int mask - the mask used by the is* functions/macros
*                  corresponding to each character class property
*
*       The leadbyte and the trailbyte should be packed into the int c as:
*
*       H.......|.......|.......|.......L
*           0       0   leadbyte trailbyte
*
*Exit:
*       Returns non-zero if c is of the character class.
*       Returns 0 if c is not of the character class.
*
*Exceptions:
*       Returns 0 on any error.
*
*******************************************************************************/

int __cdecl _isctype (
        int c,
        int mask
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isctype_mt(ptloci, c, mask);
}

int __cdecl __isctype_mt (
        pthreadlocinfo ptloci,
        int c,
        int mask
        )
{
#endif
        int size;
        unsigned short chartype;
        char buffer[3];

        /* c valid between -1 and 255 */
        if ( ((unsigned)(c + 1)) <= 256 )
#ifdef  _MT
            return ptloci->pctype[c] & mask;
#else
            return _pctype[c] & mask;
#endif

#ifdef  _MT
        if ( __isleadbyte_mt(ptloci, c >> 8 & 0xff) )
#else
        if ( isleadbyte(c >> 8 & 0xff) )
#endif
        {
            buffer[0] = (c >> 8 & 0xff); /* put lead-byte at start of str */
            buffer[1] = (char)c;
            buffer[2] = 0;
            size = 2;
        } else {
            buffer[0] = (char)c;
            buffer[1] = 0;
            size = 1;
        }

        if ( 0 == __crtGetStringTypeA( CT_CTYPE1,
                                       buffer,
                                       size,
                                       &chartype,
#ifdef  _MT
                                       ptloci->lc_codepage,
                                       ptloci->lc_handle[LC_CTYPE],
#else
                                       __lc_codepage,
                                       __lc_handle[LC_CTYPE],
#endif
                                       TRUE) )
        {
            return 0;
        }

        return (int)(chartype & mask);
}

#else   /* !_NTSUBSET_ && !_POSIX_ */

int __cdecl _isctype (
        int c,
        int mask
        )
{
        return 0;
}

#endif  /* !_NTSUBSET_ && !_POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\iswctype.c ===
/***
*iswctype.c - support isw* wctype functions/macros for wide characters
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines iswctype - support isw* wctype functions/macros for
*       wide characters (esp. > 255).
*
*Revision History:
*       10-11-91  ETC   Created.
*       12-08-91  ETC   Updated api; check type masks.
*       04-06-92  KRS   Change to match ISO proposal.  Fix logic error.
*       08-07-92  GJF   _CALLTYPE4 (bogus usage) -> _CRTAPI1 (legit).
*       08-20-92  KRS   Activated NLS support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       09-03-92  GJF   Merged last 4 changes.
*       01-15-93  CFW   Put #ifdef _INTL around wint_t d def to avoid warnings
*       02-12-93  CFW   Return d not c, remove CTRL-Z.
*       02-17-93  CFW   Include locale.h.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       05-05-93  CFW   Change name from is_wctype to iswctype as per ISO.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       06-26-93  CFW   Support is_wctype forever.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-27-93  GJF   Merged NT SDK and Cuda.
*       11-09-93  CFW   Add code page for __crtxxx().
*       12-01-93  GJF   Build is_wctype for Dolphin as well as NT.
*       02-07-94  CFW   POSIXify.
*       04-18-93  CFW   Pass lcid to _GetStringType.
*       04-01-96  BWT   POSIX work.
*       01-26-97  GJF   Deleted test which forced error for all wide chars >
*                       255 in the C locale.
*       08-24-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       09-06-00  GB    Always use pwctype for first 256 characters.
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stdio.h>
#include <locale.h>
#include <setlocal.h>
#include <awint.h>
#include <mtdll.h>

/*
 *  Use GetStringTypeW() API so check that character type masks agree between
 *  ctype.h and winnls.h
 */
#if !defined(_NTSUBSET_) && !defined(_POSIX_)
#if     _UPPER != C1_UPPER  || /*IFSTRIP=IGN*/ \
        _LOWER != C1_LOWER  || \
        _DIGIT != C1_DIGIT  || \
        _SPACE != C1_SPACE  || \
        _PUNCT != C1_PUNCT  || \
        _CONTROL != C1_CNTRL
#error Character type masks do not agree in ctype and winnls
#endif
#endif

/***
*iswctype - support isw* wctype functions/macros.
*
*Purpose:
*       This function is called by the isw* wctype functions/macros
*       (e.g. iswalpha()) when their argument is a wide character > 255.
*       It is also a standard ITSCJ (proposed) ISO routine and can be called
*       by the user, even for characters < 256.
*       Returns true or false depending on whether the argument satisfies
*       the character class property encoded by the mask.  Returns 0 if the
*       argument is WEOF.
*
*       NOTE: The isw* functions are neither locale nor codepage dependent.
*
*Entry:
*       wchar_t c    - the wide character whose type is to be tested
*       wchar_t mask - the mask used by the isw* functions/macros
*                       corresponding to each character class property
*
*Exit:
*       Returns non-zero if c is of the character class.
*       Returns 0 if c is not of the character class.
*
*Exceptions:
*       Returns 0 on any error.
*
*******************************************************************************/

int __cdecl iswctype (
        wchar_t c,
        wctype_t mask
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci;

        if (c < 256)
            return (int)(mask&_pwctype[c]);
        else if (c == WEOF)
            return 0;
        ptloci = _getptd()->ptlocinfo;
        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __iswctype_mt(ptloci, c, mask);
}

int __cdecl __iswctype_mt (
        pthreadlocinfo ptloci,
        wchar_t c,
        wctype_t mask
        )
{
#endif
        wint_t d;

        if ( c == WEOF )
            d = 0;
        else if ( c < 256 )
            d = _pwctype[c];
        else
        {
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)
            if ( __crtGetStringTypeW( CT_CTYPE1,
                                      &c,
                                      1,
                                      &d,
#ifdef  _MT
                                      ptloci->lc_codepage,
                                      ptloci->lc_handle[LC_CTYPE] ) == 0 )
#else
                                      __lc_codepage,
                                      __lc_handle[LC_CTYPE] ) == 0 )
#endif
#endif
                d = 0;
        }

        return (int)(d & mask);
}


/***
*is_wctype - support obsolete name
*
*Purpose:
*       Name changed from is_wctype to iswctype. is_wctype must be supported.
*
*Entry:
*       wchar_t c    - the wide character whose type is to be tested
*       wchar_t mask - the mask used by the isw* functions/macros
*                       corresponding to each character class property
*
*Exit:
*       Returns non-zero if c is of the character class.
*       Returns 0 if c is not of the character class.
*
*Exceptions:
*       Returns 0 on any error.
*
*******************************************************************************/
int __cdecl is_wctype (
        wchar_t c,
        wctype_t mask
        )
{
        return iswctype(c, mask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\mbstowcs.c ===
/***
*mbstowcs.c - Convert multibyte char string to wide char string.
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a multibyte char string into the equivalent wide char string.
*
*Revision History:
*       08-24-90  KRS   Module created.
*       03-20-91  KRS   Ported from 16-bit tree.
*       10-16-91  ETC   Locale support under _INTL switch.
*       12-09-91  ETC   Updated nlsapi; added multithread.
*       08-20-92  KRS   Activated NLSAPI support.
*       08-31-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       02-09-93  CFW   Always stuff WC 0 at end of output string of room (non _INTL).
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       05-03-93  CFW   Return pointer == NULL, return size, plus massive cleanup.
*       06-01-93  CFW   Minor optimization and beautify.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-21-93  CFW   Avoid cast bug.
*       09-27-93  GJF   Merged NT SDK and Cuda.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       02-03-94  GJF   Merged in Steve Wood's latest change (affects
*                       _NTSUBSET_ build only).
*       02-07-94  CFW   POSIXify.
*       08-03-94  CFW   Bug #15300; fix MBToWC workaround for small buffer.
*       09-06-94  CFW   Remove _INTL switch.
*       10-18-94  BWT   Fix build warning for call to RtlMultiByteToUnicodeN
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       01-07-95  CFW   Mac merge cleanup.
*       02-06-95  CFW   assert -> _ASSERTE.
*       04-19-95  CFW   Rearrange & fix non-Win32 version.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       05-26-96  BWT   Return the word count, not the byte count for 
*                       _NTSUBSET_/POSIX case.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       07-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       12-15-98  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <internal.h>
#include <locale.h>
#include <setlocal.h>
#include <errno.h>
#include <cruntime.h>
#include <stdlib.h>
#include <string.h>
#include <mtdll.h>
#include <dbgint.h>
#include <stdio.h>

/***
*size_t mbstowcs() - Convert multibyte char string to wide char string.
*
*Purpose:
*       Convert a multi-byte char string into the equivalent wide char string,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*Entry:
*       wchar_t *pwcs = pointer to destination wide character string buffer
*       const char *s = pointer to source multibyte character string
*       size_t      n = maximum number of wide characters to store
*
*Exit:
*       If s != NULL, returns:  number of words modified (<=n)
*               (size_t)-1 (if invalid mbcs)
*
*Exceptions:
*       Returns (size_t)-1 if s is NULL or invalid mbcs character encountered
*
*******************************************************************************/

size_t __cdecl mbstowcs
(
        wchar_t  *pwcs,
        const char *s,
        size_t n
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __mbstowcs_mt(ptloci, pwcs, s, n);
}

size_t __cdecl __mbstowcs_mt (
        pthreadlocinfo ptloci,
        wchar_t  *pwcs,
        const char *s,
        size_t n
        )
{
#endif
        size_t count = 0;

        if (pwcs && n == 0)
            /* dest string exists, but 0 bytes converted */
            return (size_t) 0;

        _ASSERTE(s != NULL);

#ifdef  _WIN64
        /* n must fit into an int for MultiByteToWideChar */
        if ( n > INT_MAX )
            return (size_t)-1;
#endif

#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

        /* if destination string exists, fill it in */
        if (pwcs)
        {
#ifdef  _MT
            if (ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE)
#else
            if (__lc_handle[LC_CTYPE] == _CLOCALEHANDLE)
#endif
            {
                /* C locale: easy and fast */
                while (count < n)
                {
                    *pwcs = (wchar_t) ((unsigned char)s[count]);
                    if (!s[count])
                        return count;
                    count++;
                    pwcs++;
                }
                return count;

            } else {
                int bytecnt, charcnt;
                unsigned char *p;

                /* Assume that the buffer is large enough */
#ifdef  _MT
                if ( (count = MultiByteToWideChar( ptloci->lc_codepage,
#else
                if ( (count = MultiByteToWideChar( __lc_codepage,
#endif
                                                   MB_PRECOMPOSED | 
                                                    MB_ERR_INVALID_CHARS,
                                                   s, 
                                                   -1, 
                                                   pwcs, 
                                                   (int)n )) != 0 )
                    return count - 1; /* don't count NUL */

                if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                {
                    errno = EILSEQ;
                    return (size_t)-1;
                }

                /* User-supplied buffer not large enough. */

                /* How many bytes are in n characters of the string? */
                charcnt = (int)n;
                for (p = (unsigned char *)s; (charcnt-- && *p); p++)
                {
#ifdef  _MT
                    if (__isleadbyte_mt(ptloci, *p))
#else
                    if (isleadbyte(*p))
#endif
                        p++;
                }
                bytecnt = ((int) ((char *)p - (char *)s));

#ifdef  _MT
                if ( (count = MultiByteToWideChar( ptloci->lc_codepage, 
#else
                if ( (count = MultiByteToWideChar( __lc_codepage, 
#endif
                                                   MB_PRECOMPOSED,
                                                   s, 
                                                   bytecnt, 
                                                   pwcs, 
                                                   (int)n )) == 0 )
                {
                    errno = EILSEQ;
                    return (size_t)-1;
                }

                return count; /* no NUL in string */
            }
        }
        else { /* pwcs == NULL, get size only, s must be NUL-terminated */
#ifdef  _MT
            if (ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE)
#else
            if (__lc_handle[LC_CTYPE] == _CLOCALEHANDLE)
#endif
                return strlen(s);

            else {
#ifdef  _MT
                if ( (count = MultiByteToWideChar( ptloci->lc_codepage, 
#else
                if ( (count = MultiByteToWideChar( __lc_codepage, 
#endif
                                                   MB_PRECOMPOSED | 
                                                    MB_ERR_INVALID_CHARS,
                                                   s, 
                                                   -1, 
                                                   NULL, 
                                                   0 )) == 0 )
                {
                    errno = EILSEQ;
                    return (size_t)-1;
                }

                return count - 1;
            }
        }

#else /* _NTSUBSET_/_POSIX_ */

        if (pwcs) {

            NTSTATUS Status;
            int size;

            size = _mbstrlen(s);
            Status = RtlMultiByteToUnicodeN(pwcs,
                                            (ULONG) ( n * sizeof( *pwcs ) ),
                                            (PULONG)&size,
                                            (char *)s,
                                            size+1 );
            if (!NT_SUCCESS(Status)) {
                errno = EILSEQ;
                size = -1;
            } else {
                size = size / sizeof(*pwcs);
                if (pwcs[size-1] == L'\0') {
                    size -= 1;
                }
            }
            return size;

        } else { /* pwcs == NULL, get size only, s must be NUL-terminated */
            return strlen(s);
        }

#endif  /* _NTSUBSET_/_POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\mblen.c ===
/***
*mblen.c - length of multibyte character
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Return the number of bytes contained in a multibyte character.
*
*Revision History:
*       03-19-90  KRS   Module created.
*       12-20-90  KRS   Include ctype.h.
*       03-20-91  KRS   Ported from 16-bit tree.
*       12-09-91  ETC   Updated comments; move __mb_cur_max to nlsdata1.c;
*                       add multithread.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-01-93  CFW   Re-write; verify valid MB char, proper error return,
*                       optimize, correct conversion bug.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-27-93  GJF   Merged NT SDK and Cuda versions.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       09-06-94  CFW   Remove _INTL switch.
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       01-07-95  CFW   Mac merge cleanup.
*       02-06-95  CFW   assert -> _ASSERTE.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also, 
*                       polished format a bit.
*       02-27-98  RKP   Added 64 bit support.
*       07-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <internal.h>
#include <locale.h>
#include <setlocal.h>
#include <cruntime.h>
#include <stdlib.h>
#include <ctype.h>
#include <mtdll.h>
#include <dbgint.h>

/***
*int mblen() - length of multibyte character
*
*Purpose:
*       Return the number of bytes contained in a multibyte character.
*       [ANSI].
*
*Entry:
*       const char *s = pointer to multibyte character
*       size_t      n = maximum length of multibyte character to consider
*
*Exit:
*       If s = NULL, returns 0, indicating we use (only) state-independent
*       character encodings.
*
*       If s != NULL, returns:   0  (if *s = null char),
*                               -1  (if the next n or fewer bytes not valid 
*                                   mbc),
*                               number of bytes contained in multibyte char
*
*Exceptions:
*
*******************************************************************************/

int __cdecl mblen
        (
        const char * s,
        size_t n
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        _ASSERTE (ptloci->mb_cur_max == 1 || ptloci->mb_cur_max == 2);
#else
        _ASSERTE (MB_CUR_MAX == 1 || MB_CUR_MAX == 2);
#endif

        if ( !s || !(*s) || (n == 0) )
            /* indicate do not have state-dependent encodings,
               empty string length is 0 */
            return 0;

#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

#ifdef  _MT
        if ( __isleadbyte_mt(ptloci, (unsigned char)*s) )
#else
        if ( isleadbyte((unsigned char)*s) )
#endif
        {
            /* multi-byte char */

            /* verify valid MB char */
#ifdef  _MT
            if ( ptloci->mb_cur_max <= 1 || 
                 (int)n < ptloci->mb_cur_max ||
                 MultiByteToWideChar( ptloci->lc_codepage,
                                      MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                      s,
                                      ptloci->mb_cur_max,
                                      NULL,
                                      0 ) == 0 )
#else
            if ( MB_CUR_MAX <= 1 || 
                 (int)n < MB_CUR_MAX ||
                 MultiByteToWideChar( __lc_codepage, 
                                      MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                      s, 
                                      MB_CUR_MAX, 
                                      NULL, 
                                      0 ) == 0 )
#endif
                /* bad MB char */
                return -1;
            else
#ifdef  _MT
                return ptloci->mb_cur_max;
#else
                return MB_CUR_MAX;
#endif
        }
        else {
            /* single byte char */

            /* verify valid SB char */
#ifdef  _MT
            if ( MultiByteToWideChar( __lc_codepage,
#else
            if ( MultiByteToWideChar( __lc_codepage,
#endif
                                      MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                      s, 
                                      1, 
                                      NULL, 
                                      0 ) == 0 )
                return -1;
            return sizeof(char);
        }

#else   /* _NTSUBSET_ */

        {
            char *s1 = (char *)s;

            RtlAnsiCharToUnicodeChar( &s1 );
            return (int)(s1 - s);
        }

#endif  /* _NTSUBSET_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\strtod.c ===
/***
*strtod.c - convert string to floating point number
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert character string to floating point number
*
*Revision History:
*       09-09-83  RKW   Module created
*       08-19-85  TDC   changed to strtod
*       04-13-87  JCR   Added "const" to declaration
*       04-20-87  BCM   Added checks for negative overflow and for underflow
*       11-09-87  BCM   different interface under ifdef MTHREAD
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-22-88  JCR   Added cast to nptr to get rid of cl const warning
*       05-24-88  PHG   Merged DLL and normal versions
*       08-24-88  PHG   No digits found => *endptr = nptr [ANSI]
*                       Revised test order so invalid detection works always
*       10-20-88  JCR   Changed 'DOUBLE' to 'double' for 386
*       11-20-89  JCR   atof() is always _cdecl in 386 (not pascal)
*       03-05-90  GJF   Fixed calling type, added #include <cruntime.h>,
*                       removed #include <register.h>, removed redundant
*                       prototypes, removed some leftover 16-bit support and
*                       fixed the copyright. Also, cleaned up the formatting
*                       a bit.
*       07-23-90  SBM   Compiles cleanly with -W3 (added/removed appropriate
*                       #includes)
*       08-01-90  SBM   Renamed <struct.h> to <fltintrn.h>
*       09-27-90  GJF   New-style function declarators.
*       10-21-92  GJF   Made char-to-int conversion unsigned.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       12-15-98  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <fltintrn.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <math.h>

/***
*double strtod(nptr, endptr) - convert string to double
*
*Purpose:
*       strtod recognizes an optional string of tabs and spaces,
*       then an optional sign, then a string of digits optionally
*       containing a decimal point, then an optional e or E followed
*       by an optionally signed integer, and converts all this to
*       to a floating point number.  The first unrecognized
*       character ends the string, and is pointed to by endptr.
*
*Entry:
*       nptr - pointer to string to convert
*
*Exit:
*       returns value of character string
*       char **endptr - if not NULL, points to character which stopped
*                       the scan
*
*Exceptions:
*
*******************************************************************************/

double __cdecl strtod (
        const char *nptr,
        REG2 char **endptr
        )
{

#ifdef  _MT
        struct _flt answerstruct;
#endif

        FLT      answer;
        double       tmp;
        unsigned int flags;
        REG1 char *ptr = (char *) nptr;

        /* scan past leading space/tab characters */

        while ( isspace((int)(unsigned char)*ptr) )
                ptr++;

        /* let _fltin routine do the rest of the work */

#ifdef  _MT
        /* ok to take address of stack variable here; fltin2 knows to use ss */
        answer = _fltin2( &answerstruct, ptr, (int)strlen(ptr), 0, 0);
#else
        answer = _fltin(ptr, (int)strlen(ptr), 0, 0);
#endif

        if ( endptr != NULL )
                *endptr = (char *) ptr + answer->nbytes;

        flags = answer->flags;
        if ( flags & (512 | 64)) {
                /* no digits found or invalid format:
                   ANSI says return 0.0, and *endptr = nptr */
                tmp = 0.0;
                if ( endptr != NULL )
                        *endptr = (char *) nptr;
        }
        else if ( flags & (128 | 1) ) {
                if ( *ptr == '-' )
                        tmp = -HUGE_VAL;        /* negative overflow */
                else
                        tmp = HUGE_VAL;         /* positive overflow */
                errno = ERANGE;
        }
        else if ( flags & 256 ) {
                tmp = 0.0;                      /* underflow */
                errno = ERANGE;
        }
        else
                tmp = answer->dval;

        return(tmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\strtol.c ===
/***
*strtol.c - Contains C runtimes strtol and strtoul
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       strtol - convert ascii string to long signed integer
*       strtoul - convert ascii string to long unsigned integer
*
*Revision History:
*       06-05-89  PHG   Module created, based on strtol.asm
*       03-06-90  GJF   Fixed calling type, added #include <cruntime.h>
*                       and fixed the copyright. Also, cleaned up the
*                       formatting a bit.
*       03-07-90  GJF   Fixed compiler warnings (added const qualifier to
*                       an arg type and local var type).
*       03-23-90  GJF   Made strtoxl() _CALLTYPE4.
*       08-13-90  SBM   Compiles cleanly with -W3
*       09-27-90  GJF   New-style function declarators.
*       10-24-91  GJF   Had to cast LONG_MAX to unsigned long in expr. to
*                       mollify MIPS compiler.
*       10-21-92  GJF   Made char-to-int conversions unsigned.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       04-21-93  GJF   Removed assumption that LONG_MIN == -LONG_MAX.
*       05-10-93  GJF   Fixed error check.
*       05-20-93  GJF   Nothing like taking ugly code and making prettier...
*                       and wrong. Fixed bug introduced on 5-10.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, replaced isdigit, isalpha and toupper
*                       macros with __ascii_isdigit, __ascii_isalpha and
*                       __ascii_towupper macros.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <mtdll.h>


/***
*strtol, strtoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 32-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*               (a) First char = '0', second char = 'x' or 'X',
*                   use base 16.
*               (b) First char = '0', use base 8
*               (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then strtol/strtoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               strtol -- LONG_MAX or LONG_MIN
*               strtoul -- ULONG_MAX
*               strtol/strtoul -- errno == ERANGE
*
*       No digits or bad base return:
*               0
*               endptr = nptr*
*
*Exceptions:
*       None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* strtoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


static unsigned long __cdecl strtoxl (
        const char *nptr,
        const char **endptr,
        int ibase,
        int flags
        )
{
        const char *p;
        char c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
#ifdef  _MT
        while ( __isspace_mt(ptloci, (int)(unsigned char)c) )
#else
        while ( isspace((int)(unsigned char)c) )
#endif
                c = *p++;               /* skip whitespace */

        if (c == '-') {
                flags |= FL_NEG;        /* remember minus sign */
                c = *p++;
        }
        else if (c == '+')
                c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
                /* bad base! */
                if (endptr)
                        /* store beginning of string in endptr */
                        *endptr = nptr;
                return 0L;              /* return 0 */
        }
        else if (ibase == 0) {
                /* determine base free-lance, based on first two chars of
                   string */
                if (c != '0')
                        ibase = 10;
                else if (*p == 'x' || *p == 'X')
                        ibase = 16;
                else
                        ibase = 8;
        }

        if (ibase == 16) {
                /* we might have 0x in front of number; remove if there */
                if (c == '0' && (*p == 'x' || *p == 'X')) {
                        ++p;
                        c = *p++;       /* advance past prefix */
                }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {      /* exit in middle of loop */
                /* convert c to value */
                if ( __ascii_isdigit((int)(unsigned char)c) )
                        digval = c - '0';
                else if ( __ascii_isalpha((int)(unsigned char)c) )
                        digval = __ascii_toupper(c) - 'A' + 10;
                else
                        break;
                if (digval >= (unsigned)ibase)
                        break;          /* exit loop if bad digit found */

                /* record the fact we have read one digit */
                flags |= FL_READDIGIT;

                /* we now need to compute number = number * base + digval,
                   but we need to know if overflow occured.  This requires
                   a tricky pre-check. */

                if (number < maxval || (number == maxval &&
                (unsigned long)digval <= ULONG_MAX % ibase)) {
                        /* we won't overflow, go ahead and multiply */
                        number = number * ibase + digval;
                }
                else {
                        /* we would have overflowed -- set the overflow flag */
                        flags |= FL_OVERFLOW;
                }

                c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
                /* no number there; return 0 and point to beginning of
                   string */
                if (endptr)
                        /* store beginning of string in endptr later on */
                        p = nptr;
                number = 0L;            /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
                /* overflow or signed overflow occurred */
                errno = ERANGE;
                if ( flags & FL_UNSIGNED )
                        number = ULONG_MAX;
                else if ( flags & FL_NEG )
                        number = (unsigned long)(-LONG_MIN);
                else
                        number = LONG_MAX;
        }

        if (endptr != NULL)
                /* store pointer to char that stopped the scan */
                *endptr = p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned long)(-(long)number);

        return number;                  /* done. */
}

long __cdecl strtol (
        const char *nptr,
        char **endptr,
        int ibase
        )
{
        return (long) strtoxl(nptr, endptr, ibase, 0);
}

unsigned long __cdecl strtoul (
        const char *nptr,
        char **endptr,
        int ibase
        )
{
        return strtoxl(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\swab.c ===
/***
*swab.c - block copy, while swapping even/odd bytes
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module contains the routine _swab() which swaps the odd/even
*	bytes of words during a block copy.
*
*Revision History:
*	06-02-89  PHG	module created, based on asm version
*	03-06-90  GJF	Fixed calling type, added #include <cruntime.h> and
*			fixed copyright. Also, cleaned up the formatting a
*			bit.
*	09-27-90  GJF	New-style function declarators.
*	01-21-91  GJF	ANSI naming.
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

/***
*void _swab(srcptr, dstptr, nbytes) - swap ODD/EVEN bytes during word move
*
*Purpose:
*	This routine copys a block of words and swaps the odd and even
*	bytes.	nbytes must be > 0, otherwise nothing is copied.  If
*	nbytes is odd, then only (nbytes-1) bytes are copied.
*
*Entry:
*	srcptr = pointer to the source block
*	dstptr = pointer to the destination block
*	nbytes = number of bytes to swap
*
*Returns:
*	None.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _swab (
	char *src,
	char *dest,
	int nbytes
	)
{
	char b1, b2;

	while (nbytes > 1) {
		b1 = *src++;
		b2 = *src++;
		*dest++ = b2;
		*dest++ = b1;
		nbytes -= 2;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\mbtowc.c ===
/***
*mbtowc.c - Convert multibyte char to wide char.
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a multibyte character into the equivalent wide character.
*
*Revision History:
*       03-19-90  KRS   Module created.
*       12-20-90  KRS   Put some intl stuff here for now...
*       03-18-91  KRS   Fixed bogus cast involving wchar_t.  Fix copyright.
*       03-20-91  KRS   Ported from 16-bit tree.
*       07-22-91  KRS   C700 3525: Check for s==0 before calling mblen.
*       07-23-91  KRS   Hard-coded for "C" locale to avoid bogus interim #'s.
*       10-15-91  ETC   Locale support under _INTL (finally!).
*       12-09-91  ETC   Updated nlsapi; added multithread.
*       08-20-92  KRS   Activated NLSAPI support.
*       08-31-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       04-26-93  CFW   Remove unused variable.
*       05-04-93  CFW   Kinder, gentler error handling.
*       06-01-93  CFW   Re-write; verify valid MB char, proper error return,
*                       optimize, fix bugs.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-28-93  GJF   Merged NT SDK and Cuda versions. Also, replace MTHREAD
*                       with _MT.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       02-03-94  GJF   Merged in Steve Wood's latest change (affects
*                       _NTSUBSET_ build only).
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-18-94  BWT   Fix build warning for call to RtlMultiByteToUnicodeN
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       01-07-95  CFW   Mac merge cleanup.
*       02-06-95  CFW   assert -> _ASSERTE.
*       04-19-95  CFW   Rearrange & fix non-Win32 version.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       07-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       04-07-99  GJF   Replace MT with _MT.
*       05-17-99  PML   Remove all Macintosh support.
*       03-19-01  BWT   Fix NTSUBSET to use RtlAnsiCharToUnicodeChar.  MultiByteToUnicodeN 
*                       isn't tolerant of bogus buffers.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <dbgint.h>
#include <ctype.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
*int mbtowc() - Convert multibyte char to wide character.
*
*Purpose:
*       Convert a multi-byte character into the equivalent wide character,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       wchar_t  *pwc = pointer to destination wide character
*       const char *s = pointer to multibyte character
*       size_t      n = maximum length of multibyte character to consider
*
*Exit:
*       If s = NULL, returns 0, indicating we only use state-independent
*       character encodings.
*       If s != NULL, returns:  0 (if *s = null char)
*                               -1 (if the next n or fewer bytes not valid mbc)
*                               number of bytes comprising converted mbc
*
*Exceptions:
*
*******************************************************************************/

int __cdecl mbtowc(
        wchar_t  *pwc,
        const char *s,
        size_t n
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __mbtowc_mt(ptloci, pwc, s, n);
}

int __cdecl __mbtowc_mt (
        pthreadlocinfo ptloci,
        wchar_t  *pwc,
        const char *s,
        size_t n
        )
{
        _ASSERTE (ptloci->mb_cur_max == 1 || ptloci->mb_cur_max == 2);
#else
        _ASSERTE (MB_CUR_MAX == 1 || MB_CUR_MAX == 2);
#endif
        if ( !s || n == 0 )
            /* indicate do not have state-dependent encodings,
               handle zero length string */
            return 0;

        if ( !*s )
        {
            /* handle NULL char */
            if (pwc)
                *pwc = 0;
            return 0;
        }

#if     !defined(_NTSUBSET_) && !defined (_POSIX_)

#ifdef  _MT
        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
        {
            if (pwc)
                *pwc = (wchar_t)(unsigned char)*s;
            return sizeof(char);
        }

#ifdef  _MT
        if ( __isleadbyte_mt(ptloci, (unsigned char)*s) )
        {
            /* multi-byte char */

            if ( (ptloci->mb_cur_max <= 1) || ((int)n < ptloci->mb_cur_max) ||
                 (MultiByteToWideChar( ptloci->lc_codepage, 
                                       MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                       s, 
                                       ptloci->mb_cur_max, 
                                       pwc, 
                                       (pwc) ? 1 : 0 ) == 0) )
            {
                /* validate high byte of mbcs char */
                if ( (n < (size_t)ptloci->mb_cur_max) || (!*(s + 1)) )
                {
                    errno = EILSEQ;
                    return -1;
                }
            }
            return ptloci->mb_cur_max;
        }
#else
        if ( isleadbyte((unsigned char)*s) )
        {
            /* multi-byte char */

            if ( (MB_CUR_MAX <= 1) || ((int)n < MB_CUR_MAX) ||
                 (MultiByteToWideChar( __lc_codepage, 
                                      MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                      s, 
                                      MB_CUR_MAX, 
                                      pwc, 
                                      (pwc) ? 1 : 0 ) == 0) )
            {
                /* validate high byte of mbcs char */
                if ( (n < (size_t)MB_CUR_MAX) || (!*(s + 1)) )
                {
                    errno = EILSEQ;
                    return -1;
                }
            }
            return MB_CUR_MAX;
        }
#endif
        else {
            /* single byte char */

#ifdef  _MT
            if ( MultiByteToWideChar( ptloci->lc_codepage, 
#else
            if ( MultiByteToWideChar( __lc_codepage, 
#endif
                                      MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                      s, 
                                      1, 
                                      pwc, 
                                      (pwc) ? 1 : 0 ) == 0 )
            {
                errno = EILSEQ;
                return -1;
            }
            return sizeof(char);
        }

#else   /* _NTSUBSET_ */

        {
            char *s1 = (char *)s;
            *pwc = RtlAnsiCharToUnicodeChar(&s1);
            return((int)(s1-s));
        }

#endif  /* _NTSUBSET_/_POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\strtoq.c ===
/***
*strtoq.c - Contains C runtimes strtoq and strtouq
*
*   Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*   Copyright (c) 1992, Digital Equipment Corporation.
*
*Purpose:
*       strtoi64 - convert ascii string to __int64 (signed) integer
*       strtoui64 - convert ascii string to __int64 (unsigned) integer
*
*Revision History:
*   06-05-89  PHG   Module created, based on strtol.asm
*   03-06-90  GJF   Fixed calling type, added #include <cruntime.h>
*                   and fixed the copyright. Also, cleaned up the
*                   formatting a bit.
*   03-07-90  GJF   Fixed compiler warnings (added const qualifier to
*                   an arg type and local var type).
*   03-23-90  GJF   Made strtoxl() _CALLTYPE4.
*   08-13-90  SBM   Compiles cleanly with -W3
*   09-27-90  GJF   New-style function declarators.
*   10-24-91  GJF   Had to cast LONG_MAX to unsigned long in expr. to
*                   mollify MIPS compiler.
*   10-21-92  GJF   Made char-to-int conversions unsigned.
*   08-28-93  TVB   Created strtoq.c directly from strtol.c.
*   10-25-93  GJF   Copied from NT SDK tree (\\orville\razzle\src\crt32).
*                   Replaced _CRTAPI* with __cdecl. Build only for NT
*                   SDK. Function names violate ANSI. Types and function-
*                   ality will be superceded by __int64 support.
*   02-11-00  GB    Added _strtoi64 and _strtoui64 (__int64 versions for
*                   strtol and strtoul)
*   06-02-00  GB    Fixed the bug for IA64_MIN value.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <mtdll.h>

/***
*strtoi64, strtoui64(nptr,endptr,ibase) - Convert ascii string to __int64 un/signed
*    int.
*
*Purpose:
*    Convert an ascii string to a 64-bit __int64 value.  The base
*    used for the caculations is supplied by the caller.  The base
*    must be in the range 0, 2-36.  If a base of 0 is supplied, the
*    ascii string must be examined to determine the base of the
*    number:
*        (a) First char = '0', second char = 'x' or 'X',
*            use base 16.
*        (b) First char = '0', use base 8
*        (c) First char in range '1' - '9', use base 10.
*
*    If the 'endptr' value is non-NULL, then strtoq/strtouq places
*    a pointer to the terminating character in this value.
*    See ANSI standard for details
*
*Entry:
*    nptr == NEAR/FAR pointer to the start of string.
*    endptr == NEAR/FAR pointer to the end of the string.
*    ibase == integer base to use for the calculations.
*
*    string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*    Good return:
*        result
*
*    Overflow return:
*        strtoi64 -- _I64_MAX or _I64_MIN
*        strtoui64 -- _UI64_MAX
*        strtoi64/strtoui64 -- errno == ERANGE
*
*    No digits or bad base return:
*        0
*        endptr = nptr*
*
*Exceptions:
*    None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* strtouq called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

static unsigned __int64 __cdecl strtoxq (
    const char *nptr,
    const char **endptr,
    int ibase,
    int flags
    )
{
    const char *p;
    char c;
    unsigned __int64 number;
    unsigned digval;
    unsigned __int64 maxval;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

    p = nptr;            /* p is our scanning pointer */
    number = 0;            /* start with zero */

    c = *p++;            /* read char */
#ifdef  _MT
    while ( __isspace_mt(ptloci, (int)(unsigned char)c) )
#else
    while ( isspace((int)(unsigned char)c) )
#endif
        c = *p++;        /* skip whitespace */

    if (c == '-') {
        flags |= FL_NEG;    /* remember minus sign */
        c = *p++;
    }
    else if (c == '+')
        c = *p++;        /* skip sign */

    if (ibase < 0 || ibase == 1 || ibase > 36) {
        /* bad base! */
        if (endptr)
            /* store beginning of string in endptr */
            *endptr = nptr;
        return 0L;        /* return 0 */
    }
    else if (ibase == 0) {
        /* determine base free-lance, based on first two chars of
           string */
        if (c != '0')
            ibase = 10;
        else if (*p == 'x' || *p == 'X')
            ibase = 16;
        else
            ibase = 8;
    }

    if (ibase == 16) {
        /* we might have 0x in front of number; remove if there */
        if (c == '0' && (*p == 'x' || *p == 'X')) {
            ++p;
            c = *p++;    /* advance past prefix */
        }
    }

    /* if our number exceeds this, we will overflow on multiply */
    maxval = _UI64_MAX / ibase;


    for (;;) {    /* exit in middle of loop */
        /* convert c to value */
        if ( isdigit((int)(unsigned char)c) )
            digval = c - '0';
        else if ( isalpha((int)(unsigned char)c) )
            digval = toupper(c) - 'A' + 10;
        else
            break;
        if (digval >= (unsigned)ibase)
            break;        /* exit loop if bad digit found */

        /* record the fact we have read one digit */
        flags |= FL_READDIGIT;

        /* we now need to compute number = number * base + digval,
           but we need to know if overflow occured.  This requires
           a tricky pre-check. */

        if (number < maxval || (number == maxval &&
        (unsigned __int64)digval <= _UI64_MAX % ibase)) {
            /* we won't overflow, go ahead and multiply */
            number = number * ibase + digval;
        }
        else {
            /* we would have overflowed -- set the overflow flag */
            flags |= FL_OVERFLOW;
        }

        c = *p++;        /* read next digit */
    }

    --p;                /* point to place that stopped scan */

    if (!(flags & FL_READDIGIT)) {
        /* no number there; return 0 and point to beginning of
           string */
        if (endptr)
            /* store beginning of string in endptr later on */
            p = nptr;
        number = 0L;        /* return 0 */
    }
    else if ( (flags & FL_OVERFLOW) ||
              ( !(flags & FL_UNSIGNED) &&
                ( ( (flags & FL_NEG) && (number > -_I64_MIN) ) ||
                  ( !(flags & FL_NEG) && (number > _I64_MAX) ) ) ) )
    {
        /* overflow or signed overflow occurred */
        errno = ERANGE;
        if ( flags & FL_UNSIGNED )
            number = _UI64_MAX;
        else if ( flags & FL_NEG )
            number = _I64_MIN;
        else
            number = _I64_MAX;
    }
    if (endptr != NULL)
        /* store pointer to char that stopped the scan */
        *endptr = p;

    if (flags & FL_NEG)
        /* negate result if there was a neg sign */
        number = (unsigned __int64)(-(__int64)number);

    return number;            /* done. */
}

__int64 _CRTIMP __cdecl _strtoi64(
    const char *nptr,
    char **endptr,
    int ibase
    )
{
    return (__int64) strtoxq(nptr, endptr, ibase, 0);
}
unsigned __int64 _CRTIMP __cdecl _strtoui64 (
    const char *nptr,
    char **endptr,
    int ibase
    )
{
    return strtoxq(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\testconv.c ===
/* incomplete test suite for convert functions

   Current functions tested:
	all isxxxxx functions
	toupper
	tolower
	atoi
	atol
	strtol
	strtoul
	swab
	itoa
	ltoa
	ultoa
*/

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <errno.h>

fail(int n)
{
    printf("Test #%d failed.\n", n);
}

main()
{
    char s[512];
    char t[512];
    char *p;

    /* test isxxxx functions */
    if (!iscntrl(0x7))	fail(1);
    if (iscntrl('c'))	fail(2);
    if (!isdigit('0'))	fail(3);
    if (isdigit('A'))	fail(4);
    if (!isgraph(';'))	fail(5);
    if (isgraph(' '))	fail(6);
    if (!islower('f'))	fail(7);
    if (islower('F'))	fail(8);
    if (!isprint('S'))	fail(9);
    if (isprint('\v'))	fail(10);
    if (!ispunct('.'))	fail(11);
    if (ispunct('A'))	fail(12);
    if (!isspace('\v')) fail(13);
    if (isspace('D'))	fail(14);
    if (!isupper('D'))	fail(15);
    if (isupper('z'))	fail(16);
    if (!isxdigit('D')) fail(17);
    if (isxdigit('G'))	fail(18);
    if (!isalnum('7'))	fail(19);
    if (isalnum(';'))	fail(20);
    if (!isalpha('j'))	fail(21);
    if (isalpha('$'))	fail(22);
    if (!isascii(0x3))	fail(23);
    if (isascii(234))	fail(24);
    if (!iscsym('d'))	fail(25);
    if (iscsym('$'))	fail(26);
    if (!iscsymf('A'))	fail(27);
    if (iscsymf('5'))	fail(28);


    /* test toupper and tolower */
    if (tolower('C') != 'c')	fail(29);
    if (tolower('d') != 'd')	fail(30);
    if (tolower('$') != '$')	fail(31);
    if (toupper('q') != 'Q')	fail(32);
    if (toupper('A') != 'A')	fail(33);
    if (toupper(';') != ';')	fail(34);


    /* test atol/atoi */
    if (atol("-123") != -123)	  fail(35);
    if (atoi("32767") != 32767)   fail(36);
    if (atoi("-32767") != -32767) fail(36);
    if (atol("0") != 0) 	  fail(37);
    if (atol("2147483647") != 2147483647)     fail(38);
    if (atol("-2147483647") != -2147483647)   fail(39);
    if (atol("123456") != 123456) fail(40);
    if (atol("-123456") != -123456) fail(41);

    /* test strtol */
    if (strtol("-123", NULL, 10) != -123)   fail(42);
    if (strtol(" 2147483646", NULL, 10) != 2147483646)	 fail(43);
    if (strtol("-2147483646$$", NULL, 10) != -2147483646)   fail(44);
    if (strtol("  2147483648x", NULL, 10) != LONG_MAX) fail(45);
    if (strtol(" -2147483648", NULL, 10) != LONG_MIN) fail(46);
    if (strtol("0", NULL, 10) != 0) fail(47);
    if (strtol("981235b", NULL, 10) != 981235) fail(48);
    if (strtol(" -1234567a", NULL, 10) != -1234567) fail(49);
    if (strtol("FFDE", NULL, 16) != 0xFFDE) fail(50);
    if (strtol("7FFFFFFE", NULL, 16) != 0x7FFFFFFE) fail(51);
    if (strtol("-0x45", NULL, 16) != -0x45) fail(52);
    if (strtol("23478", NULL, 8) != 02347) fail(53);
    if (strtol("  -0x123D", NULL, 0) != -0x123d) fail(54);
    if (strtol(" 01238", NULL, 0) != 0123) fail(55);
    if (strtol(" -678899", NULL, 0) != -678899) fail(56);

    errno = 0;
    strtol("2147483647", NULL, 10);
    if (errno != 0)	fail(57);
    errno = 0;
    strtol("2147483648", NULL, 10);
    if (errno != ERANGE)    fail(58);
    errno = 0;
    strtol("63234283743", NULL, 10);
    if (errno != ERANGE)    fail(59);
    strcpy(s, "   8983");
    strtol(s, &p, 8);
    if (s != p)     fail(60);
    strcpy(s, "12345678901234567890XX");
    strtol(s, &p, 0);
    if (p != s+20)  fail(61);
    strcpy(s, "  111");
    strtol(s, &p, 1);
    if (p != s)     fail(62);

    errno = 0;
    if (strtoul("4294967295", NULL, 10) != ULONG_MAX)	fail(63);
    if (errno != 0)	fail(64);
    errno = 0;
    strtoul("4294967296", NULL, 10);
    if (errno != ERANGE)    fail(65);
    errno = 0;
    strtoul("63234283743", NULL, 10);
    if (errno != ERANGE)    fail(66);

    /* test swab */
    strcpy(s, "abcdefghijklmn");
    swab(s, t, 14);
    if (strcmp(t, "badcfehgjilknm") != 0)	fail(67);
    strcpy(t, s);
    swab(s, t, 7);
    if (strcmp(t, "badcfeghijklmn") != 0)	fail(68);
    strcpy(t, s);
    swab(s, t, -5);
    if (strcmp(s, t) != 0)			fail(69);

    /* test itoa/ltoa/ultoa */
    if (strcmp(itoa(345, s, 10), "345") != 0)	fail(70);
    if (strcmp(itoa(-345, s, 10), "-345") != 0) fail(71);
    if (strcmp(itoa(33, s, 36), "x") != 0)	fail(72);
    if (strcmp(itoa(65535U, s, 16), "ffff") != 0) fail(73);
    if (strcmp(ltoa(123457, s, 10), "123457") != 0) fail(74);
    if (strcmp(ltoa(-123457, s, 10), "-123457") != 0) fail(75);
    if (strcmp(ltoa(076512L, s, 8), "76512") != 0) fail(76);
    if (strcmp(ltoa(-1L, s, 10), "-1") != 0)	fail(77);
    if (strcmp(ltoa(-1L, s, 16), "ffffffff") != 0) fail(78);
    if (strcmp(ultoa(-1L, s, 10), "4294967295") != 0) fail(79);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\tolower.c ===
/***
*tolower.c - convert character to lower case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines function versions of _tolower() and tolower().
*
*Revision History:
*       11-09-84  DFW   created
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-23-89  GJF   Added function version of _tolower and cleaned up.
*       03-26-89  GJF   Migrated to 386 tree
*       03-06-90  GJF   Fixed calling type, added #include <cruntime.h> and
*                       fixed copyright.
*       09-27-90  GJF   New-style function declarators.
*       10-11-91  ETC   Locale support for tolower under _INTL switch.
*       12-10-91  ETC   Updated nlsapi; added multithread.
*       12-17-92  KRS   Updated and optimized for latest NLSAPI.  Bug-fixes.
*       01-19-93  CFW   Fixed typo.
*       03-25-93  CFW   _tolower now defined when _INTL.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-01-93  CFW   Simplify "C" locale test.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Change buffer to unsigned char to fix nasty cast bug.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-28-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Add code page for __crtxxx().
*       09-06-94  CFW   Remove _INTL switch.
*       10-17-94  GJF   Sped up for C locale. Also, added _tolower_lk.
*       01-07-95  CFW   Mac merge cleanup.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*       09-03-00  GB    Modified for increased performance.
*       04-03-01  PML   Reverse lead/trail bytes in composed char (vs7#232853)
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>

/* remove macro defintions of _tolower() and tolower()
 */
#undef  _tolower
#undef  tolower

/* define function-like macro equivalent to _tolower()
 */
#define mklower(c)  ( (c)-'A'+'a' )

/***
*int _tolower(c) - convert character to lower case
*
*Purpose:
*       _tolower() is simply a function version of the macro of the same name.
*
*Entry:
*       c - int value of character to be converted
*
*Exit:
*       returns int value of lower case representation of c
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tolower (
        int c
        )
{
        return(mklower(c));
}

/***
*int tolower(c) - convert character to lower case
*
*Purpose:
*       tolower() is simply a function version of the macro of the same name.
*
*Entry:
*       c - int value of character to be converted
*
*Exit:
*       if c is an upper case letter, returns int value of lower case
*       representation of c. otherwise, it returns c.
*
*Exceptions:
*
*******************************************************************************/


int __cdecl tolower (
        int c
        )
{
#if     !defined (_NTSUBSET_) && !defined(_POSIX_)

#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __tolower_mt(ptloci, c);
}

/***
*int __tolower_mt(c) - convert character to lower case
*
*Purpose:
*       Multi-thread function only!
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __tolower_mt (
        pthreadlocinfo ptloci,
        int c
        )
{

#endif  /* _MT */

        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

#ifndef  _MT
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ||
             (__lc_clike && (unsigned) c <= 0x7f))
            return __ascii_tolower(c);
#else
        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ||
             (ptloci->lc_clike && (unsigned)c <= 0x7f) )
            return __ascii_tolower(c);
#endif

        /* if checking case of c does not require API call, do it */
        if ( (unsigned)c < 256 )
        {
#ifdef  _MT
            if ( !__isupper_mt(ptloci, c) )
#else
            if ( !isupper(c) )
#endif
            {
                return c;
            }
        }

        /* convert int c to multibyte string */
#ifdef  _MT
        if ( __isleadbyte_mt(ptloci, c >> 8 & 0xff) )
#else
        if ( isleadbyte(c >> 8 & 0xff) )
#endif
        {
            inbuffer[0] = (c >> 8 & 0xff); /* put lead-byte at start of str */
            inbuffer[1] = (unsigned char)c;
            inbuffer[2] = 0;
            size = 2;
        } else {
            inbuffer[0] = (unsigned char)c;
            inbuffer[1] = 0;
            size = 1;
        }

        /* convert to lowercase */
#ifdef  _MT
        if ( 0 == (size = __crtLCMapStringA( ptloci->lc_handle[LC_CTYPE],
#else
        if ( 0 == (size = __crtLCMapStringA( __lc_handle[LC_CTYPE],
#endif
                                             LCMAP_LOWERCASE,
                                             inbuffer, 
                                             size, 
                                             outbuffer, 
                                             3, 
#ifdef  _MT
                                             ptloci->lc_codepage,
#else
                                             __lc_codepage,
#endif
                                             TRUE)) )
        {
            return c;
        }

        /* construct integer return value */
        if (size == 1)
            return ((int)outbuffer[0]);
        else
            return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

#else

        return(isupper(c) ? mklower(c) : c);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\toupper.c ===
/***
*toupper.c - convert character to uppercase
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines function versions of _toupper() and toupper().
*
*Revision History:
*       11-09-84  DFW   created
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-23-89  GJF   Added function version of _toupper and cleaned up.
*       03-26-89  GJF   Migrated to 386 tree
*       03-06-90  GJF   Fixed calling type, added #include <cruntime.h> and
*                       fixed copyright.
*       09-27-90  GJF   New-style function declarators.
*       10-11-91  ETC   Locale support for toupper under _INTL switch.
*       12-10-91  ETC   Updated nlsapi; added multithread.
*       12-17-92  KRS   Updated and optimized for latest NLSAPI.  Bug-fixes.
*       01-19-93  CFW   Fixed typo.
*       03-25-93  CFW   _toupper now defined when _INTL.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-01-93  CFW   Simplify "C" locale test.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Change buffer to unsigned char to fix nasty cast bug.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-28-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Add code page for __crtxxx().
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       09-06-94  CFW   Remove _INTL switch.
*       10-18-94  BWT   Fix build warning in NTSUBSET section.
*       10-17-94  GJF   Sped up for C locale. Added _toupper_lk. Also,
*                       cleaned up pre-processor conditionals.
*       01-07-95  CFW   Mac merge cleanup.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*       09-03-00  GB    Modified for increased performance.
*       04-03-01  PML   Reverse lead/trail bytes in composed char (vs7#232853)
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>

/* remove macro definitions of _toupper() and toupper()
 */
#undef  _toupper
#undef  toupper

/* define function-like macro equivalent to _toupper()
 */
#define mkupper(c)  ( (c)-'a'+'A' )

/***
*int _toupper(c) - convert character to uppercase
*
*Purpose:
*       _toupper() is simply a function version of the macro of the same name.
*
*Entry:
*       c - int value of character to be converted
*
*Exit:
*       returns int value of uppercase representation of c
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _toupper (
        int c
        )
{
        return(mkupper(c));
}


/***
*int toupper(c) - convert character to uppercase
*
*Purpose:
*       toupper() is simply a function version of the macro of the same name.
*
*Entry:
*       c - int value of character to be converted
*
*Exit:
*       if c is a lower case letter, returns int value of uppercase
*       representation of c. otherwise, it returns c.
*
*Exceptions:
*
*******************************************************************************/


int __cdecl toupper (
    int c
    )
{
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __toupper_mt(ptloci, c);
}


/***
*int __toupper_mt(ptloci, c) - convert character to uppercase
*
*Purpose:
*       Multi-thread function! Non-locking version of toupper.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/


int __cdecl __toupper_mt (
        pthreadlocinfo ptloci,
        int c
        )
{

#endif  /* _MT */

        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

#ifndef _MT
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ||
             (__lc_clike && (unsigned)c <= 0x7f))
            return __ascii_toupper(c);
#else
        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ||
             (ptloci->lc_clike && (unsigned)c <= 0x7f))
            return __ascii_toupper(c);
#endif

        /* if checking case of c does not require API call, do it */
        if ( (unsigned)c < 256 ) {
#ifdef  _MT
            if ( !__islower_mt(ptloci, c) )
#else
            if ( !islower(c) )
#endif
            {
                return c;
            }
        }

        /* convert int c to multibyte string */
#ifdef  _MT
        if ( __isleadbyte_mt(ptloci, c >> 8 & 0xff) ) {
#else
        if ( isleadbyte(c >> 8 & 0xff) ) {
#endif
            inbuffer[0] = (c >> 8 & 0xff); /* put lead-byte at start of str */
            inbuffer[1] = (unsigned char)c;
            inbuffer[2] = 0;
            size = 2;
        } else {
            inbuffer[0] = (unsigned char)c;
            inbuffer[1] = 0;
            size = 1;
        }

        /* convert wide char to lowercase */
#ifdef  _MT
        if ( 0 == (size = __crtLCMapStringA( ptloci->lc_handle[LC_CTYPE], 
#else
        if ( 0 == (size = __crtLCMapStringA( __lc_handle[LC_CTYPE], 
#endif
                                             LCMAP_UPPERCASE,
                                             inbuffer, 
                                             size, 
                                             outbuffer, 
                                             3, 
#ifdef  _MT
                                             ptloci->lc_codepage,
#else
                                             __lc_codepage,
#endif
                                             TRUE)) ) 
        {
            return c;
        }

        /* construct integer return value */
        if (size == 1)
            return ((int)outbuffer[0]);
        else
            return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

#else   /* def(_NTSUBSET_) || def(_POSIX_) */

        {
            NTSTATUS Status;
            char *s = (char *) &c;
            WCHAR Unicode;
            ULONG UnicodeSize;
            ULONG MultiSize;
            UCHAR MultiByte[2];

            Unicode = RtlAnsiCharToUnicodeChar( &s );
            Status = RtlUpcaseUnicodeToMultiByteN( MultiByte,
                                                   sizeof( MultiByte ),
                                                   &MultiSize,
                                                   &Unicode,
                                                   sizeof( Unicode )
                                                 );
            if (!NT_SUCCESS( Status ))
                return c;
            else
            if (MultiSize == 1)
                return ((int)MultiByte[0]);
            else
                return ((int)MultiByte[1] | ((int)MultiByte[0] << 8));

        }

#endif  /* def(_NTSUBSET_) || def(_POSIX_) */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\towlower.c ===
/***
*towlower.c - convert wide character to lower case
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines towlower().
*
*Revision History:
*       10-11-91  ETC   Created.
*       12-10-91  ETC   Updated nlsapi; added multithread.
*       04-06-92  KRS   Make work without _INTL also.
*       01-19-93  CFW   Changed LCMapString to LCMapStringW.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       06-11-93  CFW   Fix error handling bug.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Add code page for __crtxxx().
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up for C locale. Also, added _towlower_lk.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S and cleaned up the format a
*                       wee bit.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stdio.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>

/***
*wchar_t towlower(c) - convert wide character to lower case
*
*Purpose:
*       towlower() returns the lowercase equivalent of its argument
*
*Entry:
*       c - wchar_t value of character to be converted
*
*Exit:
*       if c is an upper case letter, returns wchar_t value of lower case
*       representation of c. otherwise, it returns c.
*
*Exceptions:
*
*******************************************************************************/

wchar_t __cdecl towlower (
        wchar_t c
        )
{
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

#ifdef  _MT

        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( c == WEOF )
            return c;

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
            return __ascii_towlower(c);

        return __towlower_mt(ptloci, c);
}

/***
*wchar_t __towlower_mt(ptloci, c) - convert wide character to lower case
*
*Purpose:
*       Multi-thread function only! Non-locking version of towlower.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

wchar_t __cdecl __towlower_mt (
        pthreadlocinfo ptloci,
        wchar_t c
        )
{

#endif  /* _MT */

        wchar_t widechar;

        if (c == WEOF)
            return c;

#ifndef _MT
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
            return __ascii_towlower(c);
#endif

        /* if checking case of c does not require API call, do it */
        if ( c < 256 ) {
#ifdef  _MT
            if ( !__iswupper_mt(ptloci, c) ) {
#else
            if ( !iswupper(c) ) {
#endif
                return c;
            }
        }

        /* convert wide char to lowercase */
#ifdef  _MT
        if ( 0 == __crtLCMapStringW( ptloci->lc_handle[LC_CTYPE], 
#else
        if ( 0 == __crtLCMapStringW( __lc_handle[LC_CTYPE], 
#endif
                                     LCMAP_LOWERCASE,
                                     (LPCWSTR)&c, 
                                     1, 
                                     (LPWSTR)&widechar, 
                                     1, 
#ifdef  _MT
                                     ptloci->lc_codepage ) )
#else
                                     __lc_codepage ) )
#endif
        {
            return c;
        }

        return widechar;

#else   /* _NTSUBSET_/_POSIX_ */

        return (iswupper(c) ? (c + (wchar_t)(L'a' - L'A')) : c);

#endif  /* _NTSUBSET_/_POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\wchtodig.c ===
/***
*wchtodig.c - Contains _wchartodigit function
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       _wchartodigit - convert wchar_t character to digit
*
*Revision History:
*       08-01-00  GB    Module Created
*
*******************************************************************************/

#include <wchar.h>

/***
*_wchartodigit(wchar_t) converts unicode character to it's corrosponding digit
*
*Purpose:
*   Convert unicode character to it's corrosponding digit
*
*Entry:
*   ch char to convert
*
*Exit:
*   good result: int 0-9
*
*   bad result: -1
*
*Exceptions:
*
*******************************************************************************/

int _wchartodigit(wchar_t ch)
{
#define DIGIT_RANGE_TEST(zero)  \
    if (ch < zero)              \
        return -1;              \
    if (ch < zero + 10)         \
    {                           \
        return ch - zero;       \
    }

    DIGIT_RANGE_TEST(0x0030)        // 0030;DIGIT ZERO
    if (ch < 0xFF10)                // FF10;FULLWIDTH DIGIT ZERO
    {
        DIGIT_RANGE_TEST(0x0660)    // 0660;ARABIC-INDIC DIGIT ZERO
        DIGIT_RANGE_TEST(0x06F0)    // 06F0;EXTENDED ARABIC-INDIC DIGIT ZERO
        DIGIT_RANGE_TEST(0x0966)    // 0966;DEVANAGARI DIGIT ZERO
        DIGIT_RANGE_TEST(0x09E6)    // 09E6;BENGALI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0A66)    // 0A66;GURMUKHI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0AE6)    // 0AE6;GUJARATI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0B66)    // 0B66;ORIYA DIGIT ZERO
        DIGIT_RANGE_TEST(0x0C66)    // 0C66;TELUGU DIGIT ZERO
        DIGIT_RANGE_TEST(0x0CE6)    // 0CE6;KANNADA DIGIT ZERO
        DIGIT_RANGE_TEST(0x0D66)    // 0D66;MALAYALAM DIGIT ZERO
        DIGIT_RANGE_TEST(0x0E50)    // 0E50;THAI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0ED0)    // 0ED0;LAO DIGIT ZERO
        DIGIT_RANGE_TEST(0x0F20)    // 0F20;TIBETAN DIGIT ZERO
        DIGIT_RANGE_TEST(0x1040)    // 1040;MYANMAR DIGIT ZERO
        DIGIT_RANGE_TEST(0x17E0)    // 17E0;KHMER DIGIT ZERO
        DIGIT_RANGE_TEST(0x1810)    // 1810;MONGOLIAN DIGIT ZERO


        return -1;
    }
#undef DIGIT_RANGE_TEST

                                    // FF10;FULLWIDTH DIGIT ZERO
    if (ch < 0xFF10 + 10) 
    { 
        return ch - 0xFF10; 
    }
    return -1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\towupper.c ===
/***
*towupper.c - convert wide character to upper case
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines towupper().
*
*Revision History:
*       10-11-91  ETC   Created.
*       12-10-91  ETC   Updated nlsapi; added multithread.
*       04-06-92  KRS   Make work without _INTL also.
*       01-19-93  CFW   Changed LCMapString to LCMapStringW.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       06-11-93  CFW   Fix error handling bug.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Add code page for __crtxxx().
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up for C locale. Added _towupper_lk. Also,
*                       cleaned up pre-processor conditionals.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S and cleaned up the format a
*                       wee bit.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <cruntime.h>
#include <ctype.h>
#include <stdio.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>

/***
*wchar_t towupper(c) - convert wide character to upper case
*
*Purpose:
*       towupper() returns the uppercase equivalent of its argument
*
*Entry:
*       c - wchar_t value of character to be converted
*
*Exit:
*       if c is a lower case letter, returns wchar_t value of upper case
*       representation of c. otherwise, it returns c.
*
*Exceptions:
*
*******************************************************************************/

wchar_t __cdecl towupper (
        wchar_t c
        )
{
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

#ifdef  _MT

        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
            return __ascii_towupper(c);

        return __towupper_mt(ptloci, c);
}

/***
*wchar_t __towupper_mt(ptloci, c) - convert wide character to upper case
*
*Purpose:
*       Multi-thread function only! Non-locking version of towupper.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

wchar_t __cdecl __towupper_mt (
        pthreadlocinfo ptloci,
        wchar_t c
        )
{

#endif  /* _MT */

        wchar_t widechar;

        if (c == WEOF)
            return c;

#ifndef _MT
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
            return __ascii_towupper(c);
#endif

        /* if checking case of c does not require API call, do it */
        if ( c < 256 ) {
#ifdef  _MT
            if ( !__iswlower_mt(ptloci, c) ) {
#else
            if ( !iswlower(c) ) {
#endif
                return c;
            }
        }

        /* convert wide char to uppercase */
#ifdef  _MT
        if ( 0 == __crtLCMapStringW( ptloci->lc_handle[LC_CTYPE], 
#else
        if ( 0 == __crtLCMapStringW( __lc_handle[LC_CTYPE], 
#endif
                                     LCMAP_UPPERCASE,
                                     (LPCWSTR)&c, 
                                     1, 
                                     (LPWSTR)&widechar, 
                                     1, 
#ifdef  _MT
                                     ptloci->lc_codepage ) )
#else
                                     __lc_codepage ) )
#endif
        {
            return c;
        }

        return widechar;

#else   /* _NTSUBSET_/_POSIX_ */

        return RtlUpcaseUnicodeChar( c );

#endif  /* _NTSUBSET_/_POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\wcstod.c ===
/***
*wcstod.c - convert wide char string to floating point number
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert character string to floating point number
*
*Revision History:
*       06-15-92  KRS   Created from strtod.c.
*       11-06-92  KRS   Fix bugs in wctomb() loop.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       04-01-96  BWT   POSIX work.
*       02-19-01  GB    added _alloca and Check for return value of _malloc_crt
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <math.h>
#include <dbgint.h>
#include <stdlib.h>
#include <malloc.h>
#include <fltintrn.h>

/***
*double wcstod(nptr, endptr) - convert wide string to double
*
*Purpose:
*       wcstod recognizes an optional string of tabs and spaces,
*       then an optional sign, then a string of digits optionally
*       containing a decimal point, then an optional e or E followed
*       by an optionally signed integer, and converts all this to
*       to a floating point number.  The first unrecognized
*       character ends the string, and is pointed to by endptr.
*
*Entry:
*       nptr - pointer to wide string to convert
*
*Exit:
*       returns value of wide character string
*       wchar_t **endptr - if not NULL, points to character which stopped
*               the scan
*
*Exceptions:
*
*******************************************************************************/

double __cdecl wcstod (
        const wchar_t *nptr,
        REG2 wchar_t **endptr
        )
{

#ifdef  _MT
        struct _flt answerstruct;
#endif

        FLT  answer;
        double       tmp;
        unsigned int flags;
        REG1 wchar_t *ptr = (wchar_t *) nptr;
        char * cptr;
        int malloc_flag = 0;
        int retval, len;
        int clen = 0;

        /* scan past leading space/tab characters */

        while (iswspace(*ptr))
            ptr++;

        __try{
            cptr = (char *)_alloca((wcslen(ptr)+1) * sizeof(wchar_t));
        }
        __except(1){ //EXCEPTION_EXECUTE_HANDLER
            _resetstkoflw();
            if ((cptr = (char *)_malloc_crt((wcslen(ptr)+1) * sizeof(wchar_t))) == NULL)
            {
                errno = ENOMEM;
                return 0.0;
            }
            malloc_flag = 1;
        }
        // UNDONE: check for errors
        for (len = 0; ptr[len]; len++)
            {
            if ((retval = wctomb(cptr+len,ptr[len]))<=0)
            break;
            clen += retval;
            }
        cptr[clen++] = '\0';

        /* let _fltin routine do the rest of the work */

#ifdef  _MT
        /* ok to take address of stack variable here; fltin2 knows to use ss */
        answer = _fltin2( &answerstruct, cptr, clen, 0, 0);
#else
        answer = _fltin(cptr, clen, 0, 0);
#endif

        if (malloc_flag)
            _free_crt(cptr);


        if ( endptr != NULL )
            *endptr = (wchar_t *) ptr + answer->nbytes;
            /* UNDONE: assumes no multi-byte chars in string */

        flags = answer->flags;
        if ( flags & (512 | 64)) {
            /* no digits found or invalid format:
               ANSI says return 0.0, and *endptr = nptr */
            tmp = 0.0;
            if ( endptr != NULL )
                *endptr = (wchar_t *) nptr;
        }
        else if ( flags & (128 | 1) ) {
            if ( *ptr == '-' )
                tmp = -HUGE_VAL;    /* negative overflow */
            else
                tmp = HUGE_VAL;     /* positive overflow */
            errno = ERANGE;
        }
        else if ( flags & 256 ) {
            tmp = 0.0;          /* underflow */
            errno = ERANGE;
        }
        else
            tmp = answer->dval;

        return(tmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\wcstol.c ===
/***
*wcstol.c - Contains C runtimes wcstol and wcstoul
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       wcstol - convert wchar_t string to long signed integer
*       wcstoul - convert wchar_t string to long unsigned integer
*
*Revision History:
*       06-15-92  KRS   Module created, based on strtol.c
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       04-21-93  GJF   Removed assumption that LONG_MIN == -LONG_MAX.
*       05-10-93  GJF   Fixed error check.
*       05-20-93  GJF   Nothing like taking ugly code and making prettier...
*                       and wrong. Fixed bug introduced on 5-10.
*       02-07-94  CFW   POSIXify.
*       04-01-96  BWT   POSIX work.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, replaced iswdigit, iswalpha and towupper
*                       macros with __ascii_iswdigit, __ascii_iswalpha and
*                       __ascii_towupper macros.
*       02-03-99  GJF   Added range check to make sure args to __ascii_isw*
*                       macros are not too big.
*       08-01-00  GB    Added multilangual support
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <mtdll.h>

int _wchartodigit(wchar_t);

/***
*wcstol, wcstoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 32-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*           (a) First char = '0', second char = 'x' or 'X',
*               use base 16.
*           (b) First char = '0', use base 8
*           (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then wcstol/wcstoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*           result
*
*       Overflow return:
*           wcstol -- LONG_MAX or LONG_MIN
*           wcstoul -- ULONG_MAX
*           wcstol/wcstoul -- errno == ERANGE
*
*       No digits or bad base return:
*           0
*           endptr = nptr*
*
*Exceptions:
*       None.
*
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


static unsigned long __cdecl wcstoxl (
        const wchar_t *nptr,
        const wchar_t **endptr,
        int ibase,
        int flags
        )
{
        const wchar_t *p;
        wchar_t c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        p = nptr;           /* p is our scanning pointer */
        number = 0;         /* start with zero */

        c = *p++;           /* read char */

#ifdef  _MT
        while ( __iswspace_mt(ptloci, c) )
#else
        while ( iswspace(c) )
#endif
            c = *p++;       /* skip whitespace */

        if (c == '-') {
            flags |= FL_NEG;    /* remember minus sign */
            c = *p++;
        }
        else if (c == '+')
            c = *p++;       /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
            /* bad base! */
            if (endptr)
                /* store beginning of string in endptr */
                *endptr = nptr;
            return 0L;      /* return 0 */
        }
        else if (ibase == 0) {
            /* determine base free-lance, based on first two chars of
               string */
            if (_wchartodigit(c) != 0)
                ibase = 10;
            else if (*p == L'x' || *p == L'X')
                ibase = 16;
            else
                ibase = 8;
        }

        if (ibase == 16) {
            /* we might have 0x in front of number; remove if there */
            if (_wchartodigit(c) == 0 && (*p == L'x' || *p == L'X')) {
                ++p;
                c = *p++;   /* advance past prefix */
            }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {  /* exit in middle of loop */

            /* convert c to value */
            if ( (digval = _wchartodigit(c)) != -1 )
                ;
            else if ( __ascii_iswalpha(c))
                digval = __ascii_towupper(c) - L'A' + 10;
            else
                break;

            if (digval >= (unsigned)ibase)
                break;      /* exit loop if bad digit found */

            /* record the fact we have read one digit */
            flags |= FL_READDIGIT;

            /* we now need to compute number = number * base + digval,
               but we need to know if overflow occured.  This requires
               a tricky pre-check. */

            if (number < maxval || (number == maxval &&
            (unsigned long)digval <= ULONG_MAX % ibase)) {
                /* we won't overflow, go ahead and multiply */
                number = number * ibase + digval;
            }
            else {
                /* we would have overflowed -- set the overflow flag */
                flags |= FL_OVERFLOW;
            }

            c = *p++;       /* read next digit */
        }

        --p;                /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
            /* no number there; return 0 and point to beginning of
               string */
            if (endptr)
                /* store beginning of string in endptr later on */
                p = nptr;
            number = 0L;        /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
              ( !(flags & FL_UNSIGNED) &&
                ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                  ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
            /* overflow or signed overflow occurred */
            errno = ERANGE;
            if ( flags & FL_UNSIGNED )
                number = ULONG_MAX;
            else if ( flags & FL_NEG )
                number = (unsigned long)(-LONG_MIN);
            else
                number = LONG_MAX;
        }

        if (endptr != NULL)
            /* store pointer to char that stopped the scan */
            *endptr = p;

        if (flags & FL_NEG)
            /* negate result if there was a neg sign */
            number = (unsigned long)(-(long)number);

        return number;          /* done. */
}

long __cdecl wcstol (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return (long) wcstoxl(nptr, endptr, ibase, 0);
}

unsigned long __cdecl wcstoul (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return wcstoxl(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\wcstombs.c ===
/***
*wcstombs.c - Convert wide char string to multibyte char string.
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a wide char string into the equivalent multibyte char string.
*
*Revision History:
*       08-24-90  KRS   Module created.
*       01-14-91  KRS   Added _WINSTATIC for Windows DLL.  Fix wctomb() call.
*       03-18-91  KRS   Fix check for NUL.
*       03-20-91  KRS   Ported from 16-bit tree.
*       10-16-91  ETC   Locale support under _INTL switch.
*       12-09-91  ETC   Updated nlsapi; added multithread.
*       08-20-92  KRS   Activated NLSAPI support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       01-06-93  CFW   Added (count < n) to outer loop - avoid bad wctomb calls
*       01-07-93  KRS   Major code cleanup.  Fix error return, comments.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       05-03-93  CFW   Return pointer == NULL, return size, plus massive cleanup.
*       06-01-93  CFW   Minor optimization and beautify.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-28-93  GJF   Merged NT SDK and Cuda versions.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       02-07-94  CFW   POSIXify.
*       08-03-94  CFW   Optimize for SBCS.
*       09-06-94  CFW   Remove _INTL switch.
*       11-22-94  CFW   WideCharToMultiByte will compare past NULL.
*       01-07-95  CFW   Mac merge cleanup.
*       02-06-95  CFW   assert -> _ASSERTE.
*       03-13-95  CFW   Fix wcsncnt counting.
*       04-19-95  CFW   Rearrange & fix non-Win32 version.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       12-07-95  SKS   Fix misspelling of _NTSUBSET_ (final _ was missing)
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       02-27-98  RKP   Added 64 bit support.
*       06-23-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       08-27-98  GJF   Introduced __wcstombs_mt.
*       12-15-98  GJF   Changes for 64-bit size_t.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>
#include <errno.h>
#include <locale.h>
#include <setlocal.h>

/***
*int __cdecl wcsncnt - count wide characters in a string, up to n.
*
*Purpose:
*       Internal local support function. Counts characters in string including NULL.
*       If NULL not found in n chars, then return n.
*
*Entry:
*       const wchar_t *string   - start of string
*       size_t n                - character count
*
*Exit:
*       returns number of wide characters from start of string to
*       NULL (inclusive), up to n.
*
*Exceptions:
*
*******************************************************************************/

static size_t __cdecl wcsncnt (
        const wchar_t *string,
        size_t cnt
        )
{
        size_t n = cnt+1;
        wchar_t *cp = (wchar_t *)string;

        while (--n && *cp)
            cp++;

        if (n && !*cp)
            return cp - string + 1;
        return cnt;
}

/***
*size_t wcstombs() - Convert wide char string to multibyte char string.
*
*Purpose:
*       Convert a wide char string into the equivalent multibyte char string,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       char *s            = pointer to destination multibyte char string
*       const wchar_t *pwc = pointer to source wide character string
*       size_t           n = maximum number of bytes to store in s
*
*Exit:
*       If s != NULL, returns    (size_t)-1 (if a wchar cannot be converted)
*       Otherwise:       Number of bytes modified (<=n), not including
*                    the terminating NUL, if any.
*
*Exceptions:
*       Returns (size_t)-1 if s is NULL or invalid mb character encountered.
*
*******************************************************************************/

size_t __cdecl wcstombs (
        char * s,
        const wchar_t * pwcs,
        size_t n
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __wcstombs_mt(ptloci, s, pwcs, n);
}

size_t __cdecl __wcstombs_mt (
        pthreadlocinfo ptloci,
        char * s,
        const wchar_t * pwcs,
        size_t n
        )
{
#endif
        size_t count = 0;
        int i, retval;
        char buffer[MB_LEN_MAX];
        BOOL defused = 0;

        if (s && n == 0)
            /* dest string exists, but 0 bytes converted */
            return (size_t) 0;

        _ASSERTE(pwcs != NULL);

#ifdef  _WIN64
        /* n must fit into an int for WideCharToMultiByte */
        if ( n > INT_MAX )
            return (size_t)-1;
#endif

#if     !defined( _NTSUBSET_ ) && !defined(_POSIX_)

        /* if destination string exists, fill it in */
        if (s)
        {
#ifdef  _MT
            if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
            if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
            {
                /* C locale: easy and fast */
                while(count < n)
                {
                    if (*pwcs > 255)  /* validate high byte */
                    {
                        errno = EILSEQ;
                        return (size_t)-1;  /* error */
                    }
                    s[count] = (char) *pwcs;
                    if (*pwcs++ == L'\0')
                        return count;
                    count++;
                }
                return count;
            } else {

                if (1 == MB_CUR_MAX)
                {
                    /* If SBCS, one wchar_t maps to one char */

                    /* WideCharToMultiByte will compare past NULL - reset n */
                    if (n > 0)
                        n = wcsncnt(pwcs, n);

#ifdef  _MT
                    if ( ((count = WideCharToMultiByte( ptloci->lc_codepage,
#else
                    if ( ((count = WideCharToMultiByte( __lc_codepage,
#endif
                                                        0,
                                                        pwcs, 
                                                        (int)n, 
                                                        s,
                                                        (int)n, 
                                                        NULL, 
                                                        &defused )) != 0) &&
                         (!defused) )
                    {
                        if (*(s + count - 1) == '\0')
                            count--; /* don't count NUL */

                        return count;
                    }

                    errno = EILSEQ;
                    return (size_t)-1;
                }
                else {

                    /* If MBCS, wchar_t to char mapping unknown */

                    /* Assume that usually the buffer is large enough */
#ifdef  _MT
                    if ( ((count = WideCharToMultiByte( ptloci->lc_codepage,
#else
                    if ( ((count = WideCharToMultiByte( __lc_codepage,
#endif
                                                        0,
                                                        pwcs, 
                                                        -1,
                                                        s, 
                                                        (int)n, 
                                                        NULL, 
                                                        &defused )) != 0) &&
                         (!defused) )
                    {
                        return count - 1; /* don't count NUL */
                    }

                    if (defused || GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    {
                        errno = EILSEQ;
                        return (size_t)-1;
                    }

                    /* buffer not large enough, must do char by char */
                    while (count < n)
                    {
#ifdef  _MT
                        if ( ((retval = WideCharToMultiByte( ptloci->lc_codepage, 
#else
                        if ( ((retval = WideCharToMultiByte( __lc_codepage, 
#endif
                                                             0,
                                                             pwcs, 
                                                             1, 
                                                             buffer,
                                                             MB_CUR_MAX, 
                                                             NULL, 
                                                             &defused )) == 0)
                             || defused )
                        {
                            errno = EILSEQ;
                            return (size_t)-1;
                        }

                        if (count + retval > n)
                            return count;

                        for (i = 0; i < retval; i++, count++) /* store character */
                            if((s[count] = buffer[i])=='\0')
                                return count;

                        pwcs++;
                    }

                    return count;
                }
            }
        }
        else { /* s == NULL, get size only, pwcs must be NUL-terminated */
#ifdef  _MT
            if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
            if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
                return wcslen(pwcs);
            else {
#ifdef  _MT
                if ( ((count = WideCharToMultiByte( ptloci->lc_codepage,
#else
                if ( ((count = WideCharToMultiByte( __lc_codepage,
#endif
                                                    0,
                                                    pwcs,
                                                    -1,
                                                    NULL,
                                                    0,
                                                    NULL,
                                                    &defused )) == 0) ||
                     (defused) )
                {
                    errno = EILSEQ;
                    return (size_t)-1;
                }

                return count - 1;
            }
        }

#else /* _NTSUBSET_/_POSIX_ */

        /* if destination string exists, fill it in */
        if (s)
        {
            NTSTATUS Status;

            Status = RtlUnicodeToMultiByteN( s, 
                                             (ULONG) n, 
                                             (PULONG)&count, 
                                             (wchar_t *)pwcs, 
                                             (wcslen(pwcs) + 1) *
                                                sizeof(WCHAR) );

            if (NT_SUCCESS(Status))
            {
                return count - 1; /* don't count NUL */
            } else {
                errno = EILSEQ;
                count = (size_t)-1;
            }
        } else { /* s == NULL, get size only, pwcs must be NUL-terminated */
            NTSTATUS Status;

            Status = RtlUnicodeToMultiByteSize( (PULONG)&count, 
                                                (wchar_t *)pwcs, 
                                                (wcslen(pwcs) + 1) * 
                                                    sizeof(WCHAR) );

            if (NT_SUCCESS(Status))
            {
                return count - 1; /* don't count NUL */
            } else {
                errno = EILSEQ;
                count = (size_t)-1;
            }
        }
        return count;

#endif  /* _NTSUBSET_/_POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\wctomb.c ===
/***
*wctomb.c - Convert wide character to multibyte character.
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a wide character into the equivalent multibyte character.
*
*Revision History:
*       03-19-90  KRS   Module created.
*       12-20-90  KRS   Include ctype.h.
*       01-14-91  KRS   Fix argument error: wchar is pass-by-value.
*       03-20-91  KRS   Ported from 16-bit tree.
*       07-23-91  KRS   Hard-coded for "C" locale to avoid bogus interim #'s.
*       10-15-91  ETC   Locale support under _INTL (finally!).
*       12-09-91  ETC   Updated nlsapi; added multithread.
*       08-20-92  KRS   Activated NLSAPI support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       05-04-93  CFW   Kinder, gentler error handling.
*       06-01-93  CFW   Minor optimization and beautify.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-28-93  GJF   Merged NT SDK and Cuda versions.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       01-07-95  CFW   Mac merge cleanup.
*       04-19-95  CFW   Rearrange & fix non-Win32 version.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       12-07-95  SKS   Fix misspelling of _NTSUBSET_ (final _ was missing)
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       07-22-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <locale.h>
#include <setlocal.h>

/***
*int wctomb() - Convert wide character to multibyte character.
*
*Purpose:
*       Convert a wide character into the equivalent multi-byte character,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       char *s          = pointer to multibyte character
*       wchar_t wchar        = source wide character
*
*Exit:
*       If s = NULL, returns 0, indicating we only use state-independent
*       character encodings.
*       If s != NULL, returns:
*                   -1 (if error) or number of bytes comprising
*                   converted mbc
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wctomb (
        char *s,
        wchar_t wchar
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __wctomb_mt(ptloci, s, wchar);
}

int __cdecl __wctomb_mt (
        pthreadlocinfo ptloci,
        char *s,
        wchar_t wchar
        )
{
#endif
        if ( !s )
            /* indicate do not have state-dependent encodings */
            return 0;

#if     defined(_NTSUBSET_) || defined(_POSIX_)

        {
            NTSTATUS Status;
            int size;

            Status = RtlUnicodeToMultiByteN( s, 
                                             MB_CUR_MAX, 
                                             (PULONG)&size, 
                                             &wchar, 
                                             sizeof( wchar )
                                             );

            if (!NT_SUCCESS(Status))
            {
                errno = EILSEQ;
                size = -1;
            }
            return size;
        }

#else   /* _NTSUBSET_/_POSIX_ */

#ifdef  _MT
        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
        {
            if ( wchar > 255 )  /* validate high byte */
            {
                errno = EILSEQ;
                return -1;
            }

            *s = (char) wchar;
            return sizeof(char);
        }
        else
        {
            int size;
            BOOL defused = 0;

#ifdef  _MT
            if ( ((size = WideCharToMultiByte( ptloci->lc_codepage,
#else
            if ( ((size = WideCharToMultiByte( __lc_codepage,
#endif
                                               0,
                                               &wchar,
                                               1,
                                               s,
#ifdef  _MT
                                               ptloci->mb_cur_max,
#else
                                               MB_CUR_MAX,
#endif
                                               NULL,
                                               &defused) ) == 0) || 
                 (defused) )
            {
                errno = EILSEQ;
                return -1;
            }

            return size;
        }

#endif  /* ! _NTSUBSET_/_POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\wcstoq.c ===
/***
*wcstoq.c - Contains C runtimes wcstoi64 and wcstoui64
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	wcstoi64 - convert ascii string to signed __int64 integer
*	wcstoui64- convert ascii string to unsigned __int64 integer
*
*Revision History:
*   02-11-00  GB    Module created, based on strtoq.c
*   06-02-00  GB    Fixed the bug for IA64_MIN value.
*   08-01-00  GB    Added multilangual support
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <mtdll.h>

int _wchartodigit(wchar_t ch);

/***
*wcstoq, wcstouq(nptr,endptr,ibase) - Convert ascii string to un/signed	__int64.
*
*Purpose:
*	Convert an ascii string to a 64-bit __int64 value.  The base
*	used for the caculations is supplied by the caller.  The base
*	must be in the range 0, 2-36.  If a base of 0 is supplied, the
*	ascii string must be examined to determine the base of the
*	number:
*		(a) First wchar_t = '0', second wchar_t = 'x' or 'X',
*		    use base 16.
*		(b) First wchar_t = '0', use base 8
*		(c) First wchar_t in range '1' - '9', use base 10.
*
*	If the 'endptr' value is non-NULL, then wcstoq/wcstouq places
*	a pointer to the terminating character in this value.
*	See ANSI standard for details
*
*Entry:
*	nptr == NEAR/FAR pointer to the start of string.
*	endptr == NEAR/FAR pointer to the end of the string.
*	ibase == integer base to use for the calculations.
*
*	string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*	Good return:
*		result
*
*	Overflow return:
*		wcstoq -- _I64_MAX or _I64_MIN
*		wcstouq -- _UI64_MAX
*		wcstoq/wcstouq -- errno == ERANGE
*
*	No digits or bad base return:
*		0
*		endptr = nptr*
*
*Exceptions:
*	None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstouq called */
#define FL_NEG	      2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

static unsigned __int64 __cdecl wcstoxq (
	const wchar_t *nptr,
	const wchar_t **endptr,
	int ibase,
	int flags
	)
{
	const wchar_t *p;
	wchar_t c;
	unsigned __int64 number;
	unsigned digval;
	unsigned __int64 maxval;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

	p = nptr;			/* p is our scanning pointer */
	number = 0;			/* start with zero */

	c = *p++;			/* read wchar_t */
#ifdef  _MT
    while ( __iswspace_mt(ptloci, c) )
#else
    while ( iswspace(c) )
#endif
		c = *p++;		/* skip whitespace */

	if (c == '-') {
		flags |= FL_NEG;	/* remember minus sign */
		c = *p++;
	}
	else if (c == '+')
		c = *p++;		/* skip sign */

	if (ibase < 0 || ibase == 1 || ibase > 36) {
		/* bad base! */
		if (endptr)
			/* store beginning of string in endptr */
			*endptr = nptr;
		return 0L;		/* return 0 */
	}
	else if (ibase == 0) {
		/* determine base free-lance, based on first two chars of
		   string */
		if (_wchartodigit(c) != 0)
			ibase = 10;
		else if (*p == 'x' || *p == 'X')
			ibase = 16;
		else
			ibase = 8;
	}

	if (ibase == 16) {
		/* we might have 0x in front of number; remove if there */
	if (_wchartodigit(c) == 0 && (*p == L'x' || *p == L'X')) {
			++p;
			c = *p++;	/* advance past prefix */
		}
	}

	/* if our number exceeds this, we will overflow on multiply */
	maxval = _UI64_MAX / ibase;


	for (;;) {	/* exit in middle of loop */
		/* convert c to value */
		if ( (digval = _wchartodigit(c)) != -1 )
 			;
		else if ( __ascii_iswalpha(c) )
			digval = toupper(c) - 'A' + 10;
		else
			break;
		if (digval >= (unsigned)ibase)
			break;		/* exit loop if bad digit found */

		/* record the fact we have read one digit */
		flags |= FL_READDIGIT;

		/* we now need to compute number = number * base + digval,
		   but we need to know if overflow occured.  This requires
		   a tricky pre-check. */

		if (number < maxval || (number == maxval &&
		(unsigned __int64)digval <= _UI64_MAX % ibase)) {
			/* we won't overflow, go ahead and multiply */
			number = number * ibase + digval;
		}
		else {
			/* we would have overflowed -- set the overflow flag */
			flags |= FL_OVERFLOW;
		}

		c = *p++;		/* read next digit */
	}

	--p;				/* point to place that stopped scan */

	if (!(flags & FL_READDIGIT)) {
		/* no number there; return 0 and point to beginning of
		   string */
		if (endptr)
			/* store beginning of string in endptr later on */
			p = nptr;
		number = 0L;		/* return 0 */
	}
    else if ( (flags & FL_OVERFLOW) ||
              ( !(flags & FL_UNSIGNED) &&
                ( ( (flags & FL_NEG) && (number > -_I64_MIN) ) ||
                  ( !(flags & FL_NEG) && (number > _I64_MAX) ) ) ) )
    {
        /* overflow or signed overflow occurred */
        errno = ERANGE;
        if ( flags & FL_UNSIGNED )
            number = _UI64_MAX;
        else if ( flags & FL_NEG )
            number = (_I64_MIN);
        else
            number = _I64_MAX;
    }

	if (endptr != NULL)
		/* store pointer to wchar_t that stopped the scan */
		*endptr = p;

	if (flags & FL_NEG)
		/* negate result if there was a neg sign */
		number = (unsigned __int64)(-(__int64)number);

	return number;			/* done. */
}


__int64 _CRTIMP __cdecl _wcstoi64(
    const wchar_t *nptr,
    wchar_t **endptr,
    int ibase
    )
{
    return (__int64) wcstoxq(nptr, endptr, ibase, 0);
}
unsigned __int64 _CRTIMP __cdecl _wcstoui64 (
	const wchar_t *nptr,
	wchar_t **endptr,
	int ibase
	)
{
	return wcstoxq(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\wtox.c ===
/***
*wtox.c - _wtoi and _wtol conversion
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a wide character string into an int or long.
*
*Revision History:
*       09-10-93  CFW   Module created, based on ASCII version.
*       10-07-93  CFW   Optimize WideCharToMultiByte, use NULL default char.
*       02-07-94  CFW   POSIXify.
*       03-13-95  CFW   Use -1 for length since NT compares past NULLS.
*       01-19-96  BWT   Add __int64 versions.
*       05-13-96  BWT   Fix _NTSUBSET_ version
*       11-03-76  JWM   Fix buffer-size bug in __int64 version.
*       05-23-00  GB    Using ascii version with tchar macros for UNICODE
*                       version.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE
#define _UNICODE
#endif

#include <wchar.h>
#include "atox.c"
#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\wtof.c ===
/***
*wtof.c - convert wchar_t string to floating point number
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a wide character string into a floating point number.
*
*Revision History:
*       05-18-00  GB    written.
*       08-29-00  GB    Fixed buffer overrun.
*       02-19-01  GB    added _alloca and Check for return value of _malloc_crt
*
*******************************************************************************/
#ifndef _POSIX_

#ifndef _UNICODE
#define _UNICODE
#endif

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <dbgint.h>
#include <errno.h>
#include <malloc.h>
/***
*double wtof(ptr) - convert wide char string to floating point number
*
*Purpose:
*       atof recognizes an optional string of whitespace, then
*       an optional sign, then a string of digits optionally
*       containing a decimal point, then an optional e or E followed
*       by an optionally signed integer, and converts all this to
*       to a floating point number.  The first unrecognized
*       character ends the string.
*
*Entry:
*       ptr - pointer to wide char string to convert
*
*Exit:
*       returns floating point value of wide character representation
*
*Exceptions:
*
*******************************************************************************/
double __cdecl _wtof(
        const wchar_t *ptr
        )
{
    char *cptr;
    int malloc_flag = 0;
    size_t len;
    double retval;
    while (iswspace(*ptr))
        ptr++;
    
    len = wcstombs(NULL, ptr, 0);
    __try{
        cptr = (char *)_alloca((len+1) * sizeof(wchar_t));
    }
    __except(1){    //EXCEPTION_EXECUTE_HANDLER
        _resetstkoflw();
        if ((cptr = (char *)_malloc_crt((len+1) * sizeof(wchar_t))) == NULL)
        {
            errno = ENOMEM;
            return 0.0;
        }
        malloc_flag = 1;
    }
    // UNDONE: check for errors
    // Add one to len so as to null terminate cptr.
    wcstombs(cptr, ptr, len+1);
    retval = atof(cptr);
    if (malloc_flag)
        _free_crt(cptr);

    return retval;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\xtoa.c ===
/***
*xtoa.c - convert integers/longs to ASCII string
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The module has code to convert integers/longs to ASCII strings.  See
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-06-90  GJF   Fixed calling type, added #include <cruntime.h> and
*                       fixed copyright.
*       03-23-90  GJF   Made xtoa() _CALLTYPE4.
*       09-27-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       01-19-96  BWT   Add __int64 versions.
*       09-22-97  GJF   Added negation handling to x64toa.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>

/***
*char *_itoa, *_ltoa, *_ultoa(val, buf, radix) - convert binary int to ASCII
*       string
*
*Purpose:
*       Converts an int to a character string.
*
*Entry:
*       val - number to be converted (int, long or unsigned long)
*       int radix - base to convert into
*       char *buf - ptr to buffer to place result
*
*Exit:
*       fills in space pointed to by buf with string result
*       returns a pointer to this buffer
*
*Exceptions:
*
*******************************************************************************/

/* helper routine that does the main job. */

static void __cdecl xtoa (
        unsigned long val,
        char *buf,
        unsigned radix,
        int is_neg
        )
{
        char *p;                /* pointer to traverse string */
        char *firstdig;         /* pointer to first digit */
        char temp;              /* temp char */
        unsigned digval;        /* value of digit */

        p = buf;

        if (is_neg) {
            /* negative, so output '-' and negate */
            *p++ = '-';
            val = (unsigned long)(-(long)val);
        }

        firstdig = p;           /* save pointer to first digit */

        do {
            digval = (unsigned) (val % radix);
            val /= radix;       /* get next digit */

            /* convert to ascii and store */
            if (digval > 9)
                *p++ = (char) (digval - 10 + 'a');  /* a letter */
            else
                *p++ = (char) (digval + '0');       /* a digit */
        } while (val > 0);

        /* We now have the digit of the number in the buffer, but in reverse
           order.  Thus we reverse them now. */

        *p-- = '\0';            /* terminate string; p points to last digit */

        do {
            temp = *p;
            *p = *firstdig;
            *firstdig = temp;   /* swap *p and *firstdig */
            --p;
            ++firstdig;         /* advance to next two digits */
        } while (firstdig < p); /* repeat until halfway */
}

/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

char * __cdecl _itoa (
        int val,
        char *buf,
        int radix
        )
{
        if (radix == 10 && val < 0)
            xtoa((unsigned long)val, buf, radix, 1);
        else
            xtoa((unsigned long)(unsigned int)val, buf, radix, 0);
        return buf;
}

char * __cdecl _ltoa (
        long val,
        char *buf,
        int radix
        )
{
        xtoa((unsigned long)val, buf, radix, (radix == 10 && val < 0));
        return buf;
}

char * __cdecl _ultoa (
        unsigned long val,
        char *buf,
        int radix
        )
{
        xtoa(val, buf, radix, 0);
        return buf;
}

#ifndef _NO_INT64

static void __stdcall x64toa (      /* stdcall is faster and smaller... Might as well use it for the helper. */
        unsigned __int64 val,
        char *buf,
        unsigned radix,
        int is_neg
        )
{
        char *p;                /* pointer to traverse string */
        char *firstdig;         /* pointer to first digit */
        char temp;              /* temp char */
        unsigned digval;        /* value of digit */

        p = buf;

        if ( is_neg )
        {
            *p++ = '-';         /* negative, so output '-' and negate */
            val = (unsigned __int64)(-(__int64)val);
        }

        firstdig = p;           /* save pointer to first digit */

        do {
            digval = (unsigned) (val % radix);
            val /= radix;       /* get next digit */

            /* convert to ascii and store */
            if (digval > 9)
                *p++ = (char) (digval - 10 + 'a');  /* a letter */
            else
                *p++ = (char) (digval + '0');       /* a digit */
        } while (val > 0);

        /* We now have the digit of the number in the buffer, but in reverse
           order.  Thus we reverse them now. */

        *p-- = '\0';            /* terminate string; p points to last digit */

        do {
            temp = *p;
            *p = *firstdig;
            *firstdig = temp;   /* swap *p and *firstdig */
            --p;
            ++firstdig;         /* advance to next two digits */
        } while (firstdig < p); /* repeat until halfway */
}

/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

char * __cdecl _i64toa (
        __int64 val,
        char *buf,
        int radix
        )
{
        x64toa((unsigned __int64)val, buf, radix, (radix == 10 && val < 0));
        return buf;
}

char * __cdecl _ui64toa (
        unsigned __int64 val,
        char *buf,
        int radix
        )
{
        x64toa(val, buf, radix, 0);
        return buf;
}

#endif /* _NO_INT64 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\xtow.c ===
/***
*xtow.c - convert integers/longs to wide char string
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The module has code to convert integers/longs to wide char strings.
*
*Revision History:
*       09-10-93  CFW   Module created, based on ASCII version.
*       02-07-94  CFW   POSIXify.
*       01-19-96  BWT   Add __int64 versions.
*       05-13-96  BWT   Fix _NTSUBSET_ version
*       08-21-98  GJF   Bryan's _NTSUBSET_ version is the correct
*                       implementation.
*
*******************************************************************************/

#ifndef _POSIX_

#include <windows.h>
#include <stdlib.h>

#define INT_SIZE_LENGTH   20
#define LONG_SIZE_LENGTH  40

#define I64_SIZE_LENGTH     80

/***
*wchar_t *_itow, *_ltow, *_ultow(val, buf, radix) - convert binary int to wide
*       char string
*
*Purpose:
*       Converts an int to a wide character string.
*
*Entry:
*       val - number to be converted (int, long or unsigned long)
*       int radix - base to convert into
*       wchar_t *buf - ptr to buffer to place result
*
*Exit:
*       calls ASCII version to convert, converts ASCII to wide char into buf
*       returns a pointer to this buffer
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _itow (
        int val,
        wchar_t *buf,
        int radix
        )
{
        char astring[INT_SIZE_LENGTH];

        _itoa (val, astring, radix);
        mbstowcs(buf, astring, INT_SIZE_LENGTH);
        return (buf);
}

wchar_t * __cdecl _ltow (
        long val,
        wchar_t *buf,
        int radix
        )
{
        char astring[LONG_SIZE_LENGTH];

        _ltoa (val, astring, radix);
        mbstowcs(buf, astring, LONG_SIZE_LENGTH);
        return (buf);
}

wchar_t * __cdecl _ultow (
        unsigned long val,
        wchar_t *buf,
        int radix
        )
{
        char astring[LONG_SIZE_LENGTH];

        _ultoa (val, astring, radix);
        mbstowcs(buf, astring, LONG_SIZE_LENGTH);
        return (buf);
}

#ifndef _NO_INT64

wchar_t * __cdecl _i64tow (
        __int64 val,
        wchar_t *buf,
        int radix
        )
{
        char astring[I64_SIZE_LENGTH];

        _i64toa (val, astring, radix);
        mbstowcs(buf, astring, I64_SIZE_LENGTH);
        return (buf);
}

wchar_t * __cdecl _ui64tow (
        unsigned __int64 val,
        wchar_t *buf,
        int radix
        )
{
        char astring[I64_SIZE_LENGTH];

        _ui64toa (val, astring, radix);
        mbstowcs(buf, astring, I64_SIZE_LENGTH);
        return (buf);
}

#endif /* _NO_INT64 */

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\_ctype.c ===
/***
*_ctype.c - function versions of ctype macros
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This files provides function versions of the character
*       classification and conversion macros in ctype.h.
*
*Revision History:
*       06-05-89  PHG   Module created
*       03-05-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       09-27-90  GJF   New-style function declarators.
*       01-16-91  GJF   ANSI naming.
*       02-03-92  GJF   Got rid of #undef/#include-s, the MIPS compiler didn't
*                       like 'em.
*       08-07-92  GJF   Fixed function calling type macros.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       07-16-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

/***
*ctype - Function versions of ctype macros
*
*Purpose:
*       Function versions of the macros in ctype.h.  In order to define
*       these, we use a trick -- we undefine the macro so we can use the
*       name in the function declaration, then re-include the file so
*       we can use the macro in the definition part.
*
*       Functions defined:
*           isalpha     isupper     islower
*           isdigit     isxdigit    isspace
*           ispunct     isalnum     isprint
*           isgraph     isctrl      __isascii
*           __toascii   __iscsym    __iscsymf
*
*Entry:
*       int c = character to be tested
*Exit:
*       returns non-zero = character is of the requested type
*                  0 = character is NOT of the requested type
*
*Exceptions:
*       None.
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <mtdll.h>

int (__cdecl isalpha) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isalpha_mt(ptloci, c);
#else
        return isalpha(c);
#endif
}

int (__cdecl isupper) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isupper_mt(ptloci, c);
#else
        return isupper(c);
#endif
}

int (__cdecl islower) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __islower_mt(ptloci, c);
#else
        return islower(c);
#endif
}

int (__cdecl isdigit) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isdigit_mt(ptloci, c);
#else
        return isdigit(c);
#endif
}

int (__cdecl isxdigit) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isxdigit_mt(ptloci, c);
#else
        return isxdigit(c);
#endif
}

int (__cdecl isspace) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isspace_mt(ptloci, c);
#else
        return isspace(c);
#endif
}

int (__cdecl ispunct) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __ispunct_mt(ptloci, c);
#else
        return ispunct(c);
#endif
}

int (__cdecl isalnum) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isalnum_mt(ptloci, c);
#else
        return isalnum(c);
#endif
}

int (__cdecl isprint) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isprint_mt(ptloci, c);
#else
        return isprint(c);
#endif
}

int (__cdecl isgraph) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isgraph_mt(ptloci, c);
#else
        return isgraph(c);
#endif
}

int (__cdecl iscntrl) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __iscntrl_mt(ptloci, c);
#else
        return iscntrl(c);
#endif
}

int (__cdecl __isascii) (
        int c
        )
{
        return __isascii(c);
}

int (__cdecl __toascii) (
        int c
        )
{
        return __toascii(c);
}

int (__cdecl __iscsymf) (
        int c
        )
{
        return __iscsymf(c);
}

int (__cdecl __iscsym) (
        int c
        )
{
        return __iscsym(c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\_fptostr.c ===
/***
*_fptostr.c - workhorse routine for converting floating point to string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Workhorse routine for fcvt, ecvt.
*
*Revision History:
*	09-17-84  DFW	created
*	03-05-90  GJF	Fixed calling type, added #include <cruntime.h>,
*			removed #include <register.h>, fixed copyright. Also,
*			cleaned up the formatting a bit.
*	07-20-90  SBM	Compiles cleanly with -W3 (added #include <string.h>)
*	08-01-90  SBM	Renamed <struct.h> to <fltintrn.h>
*	09-27-90  GJF	New-style function declarator.
*	06-11-92  GDP	Bug fix: Shorten string if leadig (overflow) digit is 1
*	10-09-92  GDP	Backed out last fix for ecvt (printf regressed)
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*	04-27-94  CFW	Replace modified GDP 06-11-92 fix.
*	08-05-94  JWM	Backed out CFW's fix for ecvt (printf regression!).
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <fltintrn.h>

/***
*void _fptostr(buf, digits, pflt) - workhorse floating point conversion
*
*Purpose:
*	This is the workhorse routine for fcvt, ecvt. Here is where
*	all the digits are put into a buffer and the rounding is
*	performed and indicators of the decimal point position are set. Note,
*	this must not change the mantissa field of pflt since routines which
*	use this routine rely on this being unchanged.
*
*Entry:
*	char *buf - the buffer in which the digits are to be put
*	int digits - the number of digits which are to go into the buffer
*	STRFLT pflt - a pointer to a structure containing information on the
*		floating point value, including a string containing the
*		non-zero significant digits of the mantissa.
*
*Exit:
*	Changes the contents of the buffer and also may increment the decpt
*	field of the structure pointer to by the 'pflt' parameter if overflow
*	occurs during rounding (e.g. 9.999999... gets rounded to 10.000...).
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _fptostr (
	char *buf,
	REG4 int digits,
	REG3 STRFLT pflt
	)
{
	REG1 char *pbuf = buf;
	REG2 char *mantissa = pflt->mantissa;

	/* initialize the first digit in the buffer to '0' (NOTE - NOT '\0')
	 * and set the pointer to the second digit of the buffer.  The first
	 * digit is used to handle overflow on rounding (e.g. 9.9999...
	 * becomes 10.000...) which requires a carry into the first digit.
	 */

	*pbuf++ = '0';

	/* Copy the digits of the value into the buffer (with 0 padding)
	 * and insert the terminating null character.
	 */

	while (digits > 0) {
		*pbuf++ = (*mantissa) ? *mantissa++ : (char)'0';
		digits--;
	}
        *pbuf = '\0';

	/* do any rounding which may be needed.  Note - if digits < 0 don't
	 * do any rounding since in this case, the rounding occurs in  a digit
	 * which will not be output beause of the precision requested
	 */

	if (digits >= 0 && *mantissa >= '5') {
		pbuf--;
		while (*pbuf == '9')
			*pbuf-- = '0';
		*pbuf += 1;
	}

	if (*buf == '1') {
		/* the rounding caused overflow into the leading digit (e.g.
		 * 9.999.. went to 10.000...), so increment the decpt position
		 * by 1
		 */
		pflt->decpt++;
	}
	else {
		/* move the entire string to the left one digit to remove the
		 * unused overflow digit.
		 */
		memmove(buf, buf+1, strlen(buf+1)+1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\_mbslen.c ===
/***
*_mbslen.c - Return number of multibyte characters in a multibyte string
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Return number of multibyte characters in a multibyte string
*       excluding the terminal null.  Locale-dependent.
*
*Revision History:
*       10-01-91  ETC   Created.
*       12-08-91  ETC   Add multithread lock.
*       12-18-92  CFW   Ported to Cuda tree, changed _CALLTYPE1 to _CRTAPI1.
*       04-29-93  CFW   Change to const char *s.
*       06-01-93  CFW   Test for bad MB chars.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       06-03-93  CFW   Change name to avoid conflict with mbstring function.
*                       Change return type to size_t.
*       08-19-93  CFW   Disallow skipping LB:NULL combos.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       09-06-94  CFW   Remove _INTL switch.
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       02-06-95  CFW   assert -> _ASSERTE.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-21-96  GJF   Purged DLL_FOR_WIN32S. Polished format a bit.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       02-27-98  RKP	Added 64 bit support.
*       07-22-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <ctype.h>
#include <mtdll.h>
#include <locale.h>
#include <setlocal.h>
#include <dbgint.h>

/***
*_mbstrlen - Return number of multibyte characters in a multibyte string
*
*Purpose:
*       Return number of multibyte characters in a multibyte string
*       excluding the terminal null.  Locale-dependent.
*
*Entry:
*       char *s = string
*
*Exit:
*       Returns the number of multibyte characters in the string, or
*       (size_t)-1 if the string contains an invalid multibyte character.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl _mbstrlen(
        const char *s
        )
{
        size_t n;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        _ASSERTE (MB_CUR_MAX == 1 || MB_CUR_MAX == 2);

#ifdef  _MT
        if ( ptloci->mb_cur_max == 1 )
#else
        if ( MB_CUR_MAX == 1 )
#endif
            /* handle single byte character sets */
            return (int)strlen(s);

#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

        /* verify all valid MB chars */
#ifdef  _MT
        if ( MultiByteToWideChar( ptloci->lc_codepage,
#else
        if ( MultiByteToWideChar( __lc_codepage,
#endif
                                  MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                  s, 
                                  -1, 
                                  NULL, 
                                  0 ) == 0 ) 
        {
            /* bad MB char */
            return (size_t)-1;
        }

        /* count MB chars */
        for (n = 0; *s; n++, s++) {
#ifdef  _MT
            if ( __isleadbyte_mt(ptloci, (unsigned char)*s) ) {
#else
            if ( isleadbyte((unsigned char)*s) ) {
#endif
                if (*++s == '\0')
                    break;
            }
        }

#else

        {
            char *s1 = (char *)s;


            while (RtlAnsiCharToUnicodeChar( &s1 ) != UNICODE_NULL)
                ;

            n = s1 - s;
        }

#endif

        return(n);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\direct\drivfree.c ===
/***
*drivfree.c - Get the size of a disk
*
*	Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file has _getdiskfree()
*
*Revision History:
*	08-21-91  PHG	Module created for Win32
*	10-24-91  GJF	Added LPDWORD casts to make MIPS compiler happy.
*			ASSUMES THAT sizeof(unsigned) == sizeof(DWORD).
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*	01-27-95  GJF	Removed explicit handling for case where the default
*			drive is specified and the current directory is a
*			UNC path Also, cleaned up a bit.
*	01-31-95  GJF	Further cleanup, as suggested by Richard Shupak.
*
*******************************************************************************/

#include <cruntime.h>
#include <direct.h>
#include <oscalls.h>

/***
*int _getdiskfree(drivenum, diskfree)  - get size of a specified disk
*
*Purpose:
*	Gets the size of the current or specified disk drive
*
*Entry:
*	int drivenum - 0 for current drive, or drive 1-26
*
*Exit:
*	returns 0 if succeeds
*	returns system error code on error.
*
*Exceptions:
*
*******************************************************************************/

#ifndef _WIN32
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif

unsigned __cdecl _getdiskfree (
	unsigned uDrive,
	struct _diskfree_t * pdf
	)
{
	char   Root[4];
	char * pRoot;

	if ( uDrive == 0 ) {
	    pRoot = NULL;
	}
	else if ( uDrive > 26 ) {
	    return ( ERROR_INVALID_PARAMETER );
	}
	else {
	    pRoot = &Root[0];
	    Root[0] = (char)uDrive + (char)('A' - 1);
	    Root[1] = ':';
	    Root[2] = '\\';
	    Root[3] = '\0';
	}


	if ( !GetDiskFreeSpace( pRoot,
				(LPDWORD)&(pdf->sectors_per_cluster),
				(LPDWORD)&(pdf->bytes_per_sector),
				(LPDWORD)&(pdf->avail_clusters),
				(LPDWORD)&(pdf->total_clusters)) )
	{
	    return ( (unsigned)GetLastError() );
	}
	return ( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\convert\_wctype.c ===
/***
*_wctype.c - function versions of wctype macros
*
*	Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file provides function versions of the wide character
*	classification and conversion macros in ctype.h.
*
*Revision History:
*	10-11-91  ETC	Created from _ctype.c
*	12-08-91  ETC	Surround with #ifdef _INTL
*	04-06-92  KRS	Remove _INTL rwitches again
*	10-26-92  GJF	Cleaned up a bit.
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

/***
*wctype - Function versions of wctype macros
*
*Purpose:
*	Function versions of the wide char macros in ctype.h,
*	including isleadbyte and iswascii.  In order to define
*	these, we use a trick -- we undefine the macro so we can use the
*	name in the function declaration, then re-include the file so
*	we can use the macro in the definition part.
*
*	Functions defined:
*	    iswalpha	iswupper     iswlower
*	    iswdigit	iswxdigit    iswspace
*	    iswpunct	iswalnum     iswprint
*	    iswgraph	iswctrl	     iswascii
*	    			     isleadbyte
*
*Entry:
*	wchar_t c = character to be tested
*Exit:
*	returns non-zero = character is of the requested type
*		   0 = character is NOT of the requested type
*
*Exceptions:
*	None.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <ctype.h>

int (__cdecl isleadbyte) (
	int c
	)
{
	return isleadbyte(c);
}

int (__cdecl iswalpha) (
	wchar_t c
	)
{
	return iswalpha(c);
}

int (__cdecl iswupper) (
	wchar_t c
	)
{
	return iswupper(c);
}

int (__cdecl iswlower) (
	wchar_t c
	)
{
	return iswlower(c);
}

int (__cdecl iswdigit) (
	wchar_t c
	)
{
	return iswdigit(c);
}

int (__cdecl iswxdigit) (
	wchar_t c
	)
{
	return iswxdigit(c);
}

int (__cdecl iswspace) (
	wchar_t c
	)
{
	return iswspace(c);
}

int (__cdecl iswpunct) (
	wchar_t c
	)
{
	return iswpunct(c);
}

int (__cdecl iswalnum) (
	wchar_t c
	)
{
	return iswalnum(c);
}

int (__cdecl iswprint) (
	wchar_t c
	)
{
	return iswprint(c);
}

int (__cdecl iswgraph) (
	wchar_t c
	)
{
	return iswgraph(c);
}

int (__cdecl iswcntrl) (
	wchar_t c
	)
{
	return iswcntrl(c);
}

int (__cdecl iswascii) (
	wchar_t c
	)
{
	return iswascii(c);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\direct\drivemap.c ===
/***
*drivemap.c - _getdrives
*
*	Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _getdrives()
*
*Revision History:
*	08-22-91  BWM	Wrote module.
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <direct.h>

#if !defined(_WIN32)
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif

/***
*void _getdrivemap(void) - Get bit map of all available drives
*
*Purpose:
*
*Entry:
*
*Exit:
*	drive map with drive A in bit 0, B in 1, etc.
*
*Exceptions:
*
*******************************************************************************/

unsigned long __cdecl _getdrives()
{
    return (GetLogicalDrives());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\direct\findf64.c ===
/***
*findf64.c - C find file functions
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _findfirst64(), _findnext64(), and _findclose64().
*
*Revision History:
*       05-28-98  GJF   Created
*       05-03-99  PML   Update for 64-bit merge - long -> intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <errno.h>
#include <io.h>
#include <time.h>
#include <ctime.h>
#include <string.h>
#include <internal.h>
#include <tchar.h>

#ifndef _WIN32
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif

__time64_t __cdecl __time64_t_from_ft(FILETIME * pft);

/***
*long _findfirst(wildspec, finddata) - Find first matching file
*
*Purpose:
*       Finds the first file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       char * wild - file spec optionally containing wild cards
*
*       struct _finddata64_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       Unique handle identifying the group of files matching the spec
*
*       Error return:
*       Returns -1 and errno is set to error value
*
*Exceptions:
*       None.
*
*******************************************************************************/

intptr_t __cdecl _tfindfirst64(
        const _TSCHAR * szWild,
        struct _tfinddata64_t * pfd
        )
{
        WIN32_FIND_DATA wfd;
        HANDLE          hFile;
        DWORD           err;

        if ((hFile = FindFirstFile(szWild, &wfd)) == INVALID_HANDLE_VALUE) {
            err = GetLastError();
            switch (err) {
                case ERROR_NO_MORE_FILES:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    errno = ENOENT;
                    break;

                case ERROR_NOT_ENOUGH_MEMORY:
                    errno = ENOMEM;
                    break;

                default:
                    errno = EINVAL;
                    break;
            }
            return (-1);
        }

        pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                            ? 0 : wfd.dwFileAttributes;
        pfd->time_create  = __time64_t_from_ft(&wfd.ftCreationTime);
        pfd->time_access  = __time64_t_from_ft(&wfd.ftLastAccessTime);
        pfd->time_write   = __time64_t_from_ft(&wfd.ftLastWriteTime);
        pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                            (__int64)(wfd.nFileSizeLow);

        _tcscpy(pfd->name, wfd.cFileName);

        return ((intptr_t)hFile);
}

/***
*int _findnext(hfind, finddata) - Find next matching file
*
*Purpose:
*       Finds the next file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       hfind - handle from _findfirst
*
*       struct _finddata64_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       0 if file found
*       -1 if error or file not found
*       errno set
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl _tfindnext64(intptr_t hFile, struct _tfinddata64_t * pfd)
{
        WIN32_FIND_DATA wfd;
        DWORD           err;

        if (!FindNextFile((HANDLE)hFile, &wfd)) {
            err = GetLastError();
            switch (err) {
                case ERROR_NO_MORE_FILES:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    errno = ENOENT;
                    break;

                case ERROR_NOT_ENOUGH_MEMORY:
                    errno = ENOMEM;
                    break;

                default:
                    errno = EINVAL;
                    break;
            }
            return (-1);
        }

        pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                            ? 0 : wfd.dwFileAttributes;
        pfd->time_create  = __time64_t_from_ft(&wfd.ftCreationTime);
        pfd->time_access  = __time64_t_from_ft(&wfd.ftLastAccessTime);
        pfd->time_write   = __time64_t_from_ft(&wfd.ftLastWriteTime);
        pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                            (__int64)(wfd.nFileSizeLow);

        _tcscpy(pfd->name, wfd.cFileName);

        return (0);
}

#if     !defined(_UNICODE) && !defined(_USE_INT64)

/***
*time64_t __time64_t_from_ft(ft) - convert Win32 file time to Xenix time
*
*Purpose:
*       converts a Win32 file time value to Xenix time_t
*
*       Note: We cannot directly use the ft value. In Win32, the file times
*       returned by the API are ambiguous. In Windows NT, they are UTC. In
*       Win32S, and probably also Win32C, they are local time values. Thus,
*       the value in ft must be converted to a local time value (by an API)
*       before we can use it.
*
*Entry:
*       int yr, mo, dy -        date
*       int hr, mn, sc -        time
*
*Exit:
*       returns Xenix time value
*
*Exceptions:
*
*******************************************************************************/

__time64_t __cdecl __time64_t_from_ft(FILETIME * pft)
{
        SYSTEMTIME st;
        FILETIME lft;

        /* 0 FILETIME returns a -1 time_t */

        if (!pft->dwLowDateTime && !pft->dwHighDateTime) {
            return ((__time64_t)-1);
        }

        /*
         * Convert to a broken down local time value
         */
        if ( !FileTimeToLocalFileTime(pft, &lft) ||
             !FileTimeToSystemTime(&lft, &st) )
        {
            return ((__time64_t)-1);
        }

        return ( __loctotime64_t(st.wYear,
                                 st.wMonth,
                                 st.wDay,
                                 st.wHour,
                                 st.wMinute,
                                 st.wSecond,
                                 -1) );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\direct\findfi64.c ===
/***
*findfi64.c - C find file functions
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _findfirsti64() and _findnexti64().
*
*Revision History:
*	12-28-94  GJF	Module created.
*
*******************************************************************************/

#define _USE_INT64  1

#include "findfile.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\direct\findfile.c ===
/***
*findfile.c - C find file functions
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _findfirst(), _findnext(), and _findclose().
*
*Revision History:
*       08-21-91  BWM   Wrote Win32 versions.
*       09-13-91  BWM   Changed handle type to long.
*       08-18-92  SKS   Add a call to FileTimeToLocalFileTime
*                       as a temporary fix until _dtoxtime takes UTC
*       08-26-92  SKS   creation and last access time should be same as the
*                       last write time if ctime/atime are not available.
*       01-08-93  SKS   Remove change I made 8-26-92.  Previous behavior
*                       was deemed "by design" and preferable.
*       03-30-93  GJF   Replaced reference to _dtoxtime with __gmtotime_t. Also
*                       made _timet_from_ft a static function.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       07-21-93  GJF   Repaced use of _gmtotime_t by __loctotime_t.
*       11-01-93  CFW   Enable Unicode variant.
*       12-28-94  GJF   Added _[w]findfirsti64, _[w]findnexti64.
*       09-25-95  GJF   __loctotime_t now takes a DST flag, pass -1 in this
*                       slot to indicate DST status is unknown.
*       10-06-95  SKS   Add "const" to "char *" in prototypes for *findfirst().
*                       Prepend missing underscores to func names in comments.
*       11-13-97  RKP   Change longs to INT_PTR for 64 bit support.
*       04-27-99  PML   Change INT_PTR to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <errno.h>
#include <io.h>
#include <time.h>
#include <ctime.h>
#include <string.h>
#include <internal.h>
#include <tchar.h>

#ifndef _WIN32
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif

time_t __cdecl __timet_from_ft(FILETIME * pft);

/***
*intptr_t _findfirst(wildspec, finddata) - Find first matching file
*
*Purpose:
*       Finds the first file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       char * wild - file spec optionally containing wild cards
*
*       struct _finddata_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       Unique handle identifying the group of files matching the spec
*
*       Error return:
*       Returns -1 and errno is set to error value
*
*Exceptions:
*       None.
*
*******************************************************************************/

#ifdef  _USE_INT64

intptr_t __cdecl _tfindfirsti64(
        const _TSCHAR * szWild,
        struct _tfinddatai64_t * pfd
        )

#else   /* ndef _USE_INT64 */

intptr_t __cdecl _tfindfirst(
        const _TSCHAR * szWild,
        struct _tfinddata_t * pfd
        )

#endif  /* _USE_INT64 */

{
    WIN32_FIND_DATA wfd;
    HANDLE          hFile;
    DWORD           err;

    if ((hFile = FindFirstFile(szWild, &wfd)) == INVALID_HANDLE_VALUE) {
        err = GetLastError();
        switch (err) {
            case ERROR_NO_MORE_FILES:
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                errno = ENOENT;
                break;

            case ERROR_NOT_ENOUGH_MEMORY:
                errno = ENOMEM;
                break;

            default:
                errno = EINVAL;
                break;
        }
        return (-1);
    }

    pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                      ? 0 : wfd.dwFileAttributes;
    pfd->time_create  = __timet_from_ft(&wfd.ftCreationTime);
    pfd->time_access  = __timet_from_ft(&wfd.ftLastAccessTime);
    pfd->time_write   = __timet_from_ft(&wfd.ftLastWriteTime);

#ifdef  _USE_INT64
    pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(wfd.nFileSizeLow);
#else   /* ndef _USE_INT64 */
    pfd->size         = wfd.nFileSizeLow;
#endif  /* ndef _USE_INT64 */

    _tcscpy(pfd->name, wfd.cFileName);

    return ((intptr_t)hFile);
}

/***
*int _findnext(hfind, finddata) - Find next matching file
*
*Purpose:
*       Finds the next file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       hfind - handle from _findfirst
*
*       struct _finddata_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       0 if file found
*       -1 if error or file not found
*       errno set
*
*Exceptions:
*       None.
*
*******************************************************************************/

#ifdef  _USE_INT64

int __cdecl _tfindnexti64(intptr_t hFile, struct _tfinddatai64_t * pfd)

#else   /* ndef _USE_INT64 */

int __cdecl _tfindnext(intptr_t hFile, struct _tfinddata_t * pfd)

#endif  /* _USE_INT64 */

{
    WIN32_FIND_DATA wfd;
    DWORD           err;

    if (!FindNextFile((HANDLE)hFile, &wfd)) {
        err = GetLastError();
        switch (err) {
            case ERROR_NO_MORE_FILES:
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                errno = ENOENT;
                break;

            case ERROR_NOT_ENOUGH_MEMORY:
                errno = ENOMEM;
                break;

            default:
                errno = EINVAL;
                break;
        }
        return (-1);
    }

    pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                      ? 0 : wfd.dwFileAttributes;
    pfd->time_create  = __timet_from_ft(&wfd.ftCreationTime);
    pfd->time_access  = __timet_from_ft(&wfd.ftLastAccessTime);
    pfd->time_write   = __timet_from_ft(&wfd.ftLastWriteTime);

#ifdef  _USE_INT64
    pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(wfd.nFileSizeLow);
#else   /* ndef _USE_INT64 */
    pfd->size         = wfd.nFileSizeLow;
#endif  /* ndef _USE_INT64 */

    _tcscpy(pfd->name, wfd.cFileName);

    return (0);
}

#if     !defined(_UNICODE) && !defined(_USE_INT64)

/***
*int _findclose(hfind) - Release resources of find
*
*Purpose:
*       Releases resources of a group of files found by _findfirst and
*       _findnext
*
*Entry:
*       hfind - handle from _findfirst
*
*Exit:
*       Good return:
*       0 if success
*       -1 if fail, errno set
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl _findclose(intptr_t hFile)
{
    if (!FindClose((HANDLE)hFile)) {
        errno = EINVAL;
        return (-1);
    }
    return (0);
}


/***
*time_t _fttotimet(ft) - convert Win32 file time to Xenix time
*
*Purpose:
*       converts a Win32 file time value to Xenix time_t
*
*       Note: We cannot directly use the ft value. In Win32, the file times
*       returned by the API are ambiguous. In Windows NT, they are UTC. In
*       Win32S, and probably also Win32C, they are local time values. Thus,
*       the value in ft must be converted to a local time value (by an API)
*       before we can use it.
*
*Entry:
*       int yr, mo, dy -        date
*       int hr, mn, sc -        time
*
*Exit:
*       returns Xenix time value
*
*Exceptions:
*
*******************************************************************************/

time_t __cdecl __timet_from_ft(FILETIME * pft)
{
    SYSTEMTIME st;
    FILETIME lft;

    /* 0 FILETIME returns a -1 time_t */

    if (!pft->dwLowDateTime && !pft->dwHighDateTime) {
        return (-1L);
    }

    /*
     * Convert to a broken down local time value
     */
    if ( !FileTimeToLocalFileTime(pft, &lft) ||
         !FileTimeToSystemTime(&lft, &st) )
    {
        return (-1L);
    }

    return ( __loctotime_t(st.wYear,
                           st.wMonth,
                           st.wDay,
                           st.wHour,
                           st.wMinute,
                           st.wSecond,
                           -1) );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\direct\seterrm.c ===
/***
*seterrm.c - Set mode for handling critical errors
*
*	Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines signal() and raise().
*
*Revision History:
*	08-21-92  BWM	Wrote for Win32.
*	09-29-93  GJF	Resurrected for compatibility with NT SDK (which had
*			the function). Replaced _CALLTYPE1 with __cdecl and
*			removed Cruiser support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>

/***
*void _seterrormode(mode) - set the critical error mode
*
*Purpose:
*
*Entry:
*   int mode - error mode:
*
*		0 means system displays a prompt asking user how to
*		respond to the error. Choices differ depending on the
*		error but may include Abort, Retry, Ignore, and Fail.
*
*		1 means the call system call causing the error will fail
*		and return an error indicating the cause.
*
*Exit:
*   none
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _seterrormode(int mode)
{
	SetErrorMode(mode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\direct\slbeep.c ===
/***
*slbeep.c - Sleep and beep
*
*	Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _sleep() and _beep()
*
*Revision History:
*	08-22-91  BWM	Wrote module.
*	09-29-93  GJF	Resurrected for compatibility with NT SDK (which had
*			the function). Replaced _CALLTYPE1 with __cdecl and
*			removed Cruiser support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <stdlib.h>

/***
*void _sleep(duration) - Length of sleep
*
*Purpose:
*
*Entry:
*	unsigned long duration - length of sleep in milliseconds or
*	one of the following special values:
*
*	    _SLEEP_MINIMUM - Sends a yield message without any delay
*	    _SLEEP_FOREVER - Never return
*
*Exit:
*	None
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _sleep(unsigned long dwDuration)
{

    if (dwDuration == 0) {
	dwDuration++;
    }
    Sleep(dwDuration);

}

/***
*void _beep(frequency, duration) - Length of sleep
*
*Purpose:
*
*Entry:
*	unsigned frequency - frequency in hertz
*	unsigned duration - length of beep in milliseconds
*
*Exit:
*	None
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _beep(unsigned dwFrequency, unsigned dwDuration)
{
    Beep(dwFrequency, dwDuration);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\direct\wfndfi64.c ===
/***
*wfndfi64.c - C find file functions (wchar_t version)
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _wfindfirsti64() and _wfindnexti64().
*
*Revision History:
*	12-28-94  GJF	Module created.
*
*******************************************************************************/

#define WPRFLAG     1

#ifndef _UNICODE    /* CRT flag */
#define _UNICODE    1
#endif

#ifndef UNICODE	    /* NT flag */
#define UNICODE     1
#endif

#undef _MBCS	    /* UNICODE not _MBCS */

#define _USE_INT64  1

#include "findfile.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\direct\wfndf64.c ===
/***
*wfndf64.c - C find file functions (wchar_t version)
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _wfindfirst64() and _wfindnext64().
*
*Revision History:
*       05-29-98  GJF   Created.
*
*******************************************************************************/

#define WPRFLAG     1

#ifndef _UNICODE    /* CRT flag */
#define _UNICODE    1
#endif

#ifndef UNICODE     /* NT flag */
#define UNICODE     1
#endif

#undef  _MBCS        /* UNICODE not _MBCS */

#define _USE_INT64  1

#include "findf64.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\direct\wfindfil.c ===
/***
*wfindfile.c - C find file functions (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _wfindfirst(), _wfindnext(), and _wfindclose().
*
*Revision History:
*	10-29-93  CFW	Module created.
*
*******************************************************************************/

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "findfile.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\direct\i386\enable.asm ===
page	,132
	title	enable - enable/disable interrupts
;***
;enable.asm - contains _enable() and _disable() routines
;
;	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;
;Revision History:
;	06-15-93  GJF	Module created.
;	10-25-93  GJF	Added ifndef to ensure this is not part of the NT
;			SDK build.
;
;*******************************************************************************

ifndef	_NTSDK

	.xlist
	include cruntime.inc
	.list

page
;***
;void _enable(void)  - enables interrupts
;void _disable(void) - disables interrupts
;
;Purpose:
;	The _enable() functions executes a "sti" instruction. The _disable()
;	function executes a "cli" instruction.
;
;Entry:
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


	CODESEG

	public	_enable, _disable

_enable	proc

	sti
	ret

_enable	endp

	align	4

_disable proc

	cli
	ret

_disable endp

endif	; _NTSDK

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\crtexew.c ===
/***
*crtexew.c - Initialization for Windows EXE using CRT DLL
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for Windows apps.  It calls the
*       user's main routine WinMain() after performing C Run-Time Library
*       initialization.
*
*Revision History:
*       ??-??-??  ???   Module created.
*       09-01-94  SKS   Module commented.
*
*******************************************************************************/

#ifdef  CRTDLL

#define _WINMAIN_
#include "crtexe.c"

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\adjustfd.c ===
/***
*adjustfd.c - define the compiler-helper variable _adjust_fdiv
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The compiler generates references to this variable.  It must be
*	defined in the local module (EXE or DLL) and is actually imported
*	from MSVCRT*.DLL when this module starts up.
*
*Revision History:
*	12-12-94  SKS	Initial version
*	12-15-94  SKS	Fix spelling of _adjust_fdiv
*   04-30-01  BWT   Remove _NTSDK
*
*******************************************************************************/

#if !defined(_POSIX_) && defined(CRTDLL)

int _adjust_fdiv;

#endif /* !_NTSDK && CRTDLL && !_POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\cinitexe.c ===
/***
*cinitexe.c - C Run-Time Startup Initialization
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Do C++ initialization segment declarations for the EXE in CRT DLL
*       model
*
*Notes:
*       The C++ initializers will exist in the user EXE's data segment
*       so the special segments to contain them must be in the user EXE.
*
*Revision History:
*       03-19-92  SKS   Module created (based on CRT0INIT.ASM)
*       08-06-92  SKS   Revised to use new section names and macros
*       04-12-93  CFW   Added xia..xiz initializers.
*       10-20-93  SKS   Add .DiRECTiVE section for MIPS, too!
*       10-28-93  GJF   Rewritten in C
*       10-28-94  SKS   Add user32.lib as a default library
*       02-27-95  CFW   Remove user32.lib as a default library
*       06-22-95  CFW   Add -disallowlib directives.
*       07-04-95  CFW   Fix PMac -disallowlib directives.
*       06-27-96  GJF   Replaced defined(_WIN32) with !defined(_MAC).
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <stdio.h>
#include <internal.h>
#include <sect_attribs.h>

#pragma data_seg(".CRT$XIA")
_CRTALLOC(".CRT$XIA") _PVFV __xi_a[] = { NULL };

#pragma data_seg(".CRT$XIZ")
_CRTALLOC(".CRT$XIZ") _PVFV __xi_z[] = { NULL };

#pragma data_seg(".CRT$XCA")
_CRTALLOC(".CRT$XCA") _PVFV __xc_a[] = { NULL };

#pragma data_seg(".CRT$XCZ")
_CRTALLOC(".CRT$XCZ") _PVFV __xc_z[] = { NULL };

#pragma data_seg()  /* reset */


#if defined(_M_IA64)
#pragma comment(linker, "/merge:.CRT=.rdata")
#else
#ifdef  NT_BUILD
#pragma comment(linker, "/merge:.CRT=.rdata")
#else
#pragma comment(linker, "/merge:.CRT=.data")
#endif
#endif

#pragma comment(linker, "/defaultlib:kernel32.lib")

#pragma comment(linker, "/disallowlib:libc.lib")
#pragma comment(linker, "/disallowlib:libcd.lib")
#pragma comment(linker, "/disallowlib:libcmt.lib")
#pragma comment(linker, "/disallowlib:libcmtd.lib")
#ifdef  _DEBUG
#pragma comment(linker, "/disallowlib:msvcrt.lib")
#else   /* _DEBUG */
#pragma comment(linker, "/disallowlib:msvcrtd.lib")
#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\crtexe.c ===
/***
*crtexe.c - Initialization for console EXE using CRT DLL
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for apps linking to the CRT DLL.
*       It calls the user's main routine [w]main() or [w]WinMain after
*       performing C Run-Time Library initialization.
*
*       With ifdefs, this source file also provides the source code for:
*       wcrtexe.c   the startup routine for console apps with wide chars
*       crtexew.c   the startup routine for Windows apps
*       wcrtexew.c  the startup routine for Windows apps with wide chars
*
*Revision History:
*       08-12-91  GJF   Module created.
*       01-05-92  GJF   Substantially revised
*       01-17-92  GJF   Restored Stevewo's scheme for unhandled exceptions.
*       01-29-92  GJF   Added support for linked-in options (equivalents of
*                       binmode.obj, commode.obj and setargv.obj).
*       04-17-92  SKS   Add call to _initterm() to do C++ constructors (I386)
*       08-01-92  SRW   winxcpt.h replaced bu excpt.h which is included by
*                       oscalls.h
*       09-16-92  SKS   Prepare for C8 C++ for MIPS by calling C++ constructors
*       04-02-93  SKS   Change try/except to __try/__except
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*                       Change __GetMainArgs to __getmainargs
*                       Change fmode/commode implementation to reflect the
*                       the change to _declspec(dllimport) for imported data.
*       04-12-93  CFW   Added xia..xiz initializers and initializer call.
*       04-26-93  GJF   Made lpszCommandLine (unsigned char *) to deal with
*                       chars > 127 in the command line.
*       04-27-93  GJF   Removed support for _RT_STACK, _RT_INTDIV,
*                       _RT_INVALDISP and _RT_NONCONT.
*       05-14-93  GJF   Added support for quoted program names.
*       05-24-93  SKS   Add support for special versions of _onexit/atexit
*                       which do one thing for EXE's and another for DLLs.
*       10-19-93  CFW   MIPS support for _imp__xxx.
*       10-21-93  GJF   Added support for NT's crtdll.dll.
*       11-08-93  GJF   Guard the initialization code with the __try -
*                       __except statement (esp., C++ constructors for static
*                       objects).
*       11-09-93  GJF   Replaced PF with _PVFV (defined in internal.h).
*       11-23-93  CFW   Wide char enable.
*       12-07-93  CFW   Change _TCHAR to _TSCHAR.
*       01-04-94  CFW   Pass copy of environment to main.
*       01-11-94  GJF   Call __GetMainArgs instead of __getmainargs for NT
*                       SDK build (same function, different name)
*       01-28-94  CFW   Move environment copying to setenv.c.
*       03-04-94  SKS   Remove __setargv from this module to avoid link-time
*                       problems compiling -MD and linking with setargv.obj.
*                       static _dowildcard becomes an extern.  Add another
*                       parameter to _*getmainargs (_newmode).
*                       NOTE: These channges do NOT apply to the _NTSDK.
*       03-28-94  SKS   Add call to _setdefaultprecision for X86 (not _NTSDK)
*       04-01-94  GJF   Moved declaration of __[w]initenv to internal.h.
*       04-06-94  GJF   _IMP___FMODE, _IMP___COMMODE now evaluate to
*                       dereferences of function returns for _M_IX86 (for
*                       compatability with Win32s version of msvcrt*.dll).
*       04-25-94  CFW   wWinMain has Unicode args.
*       05-16-94  SKS   Get StartupInfo to give correct nCmdShow parameter
*                       to (_w)WinMain() (was ALWAYS passing SW_SHOWDEFAULT).
*       08-04-94  GJF   Added support for user-supplied _matherr routine
*       09-06-94  GJF   Added code to set __app_type properly.
*       10-04-94  BWT   Fix _NTSDK build
*       02-22-95  JWM   Spliced in PMAC code.
*       05-24-95  CFW   Official ANSI C++ new handler added.
*       07-24-95  CFW   Change PMac onexit malloc to _malloc_crt.
*       06-27-96  GJF   Replaced defined(_WIN32) wint !defined(_MAC). Cleaned
*                       up the format a bit.
*       08-01-96  RDK   For PMac, set onexit table pointers to -1 to parallel
*                       x86 functionality.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-11-99  KBF   Wrap RTC support in #ifdef.
*       05-17-99  PML   Remove all Macintosh support.
*       11-13-99  PML   Create 4 new COM+ specific entrypoints which return
*                       instead of calling exit().
*       11-16-99  PML   ... and remove them - linker problems mean new
*                       entrypoints don't work.  Instead, look directly at the
*                       COM Descriptor Image Directory entry in the optional
*                       header to see if we are a COM+ app.
*       02-16-00  GB    Changed GetModuleHandle to GetModuleHandleA in
*                       check_complus_app.
*       08-04-00  PML   check_complus_app -> check_managed_app (VS7#117746).
*       08-22-00  GB    Changed GetModuleHandle to GetModuleHandleA in
*                       mainCRTStartup().
*       12-09-00  PML   Tighten up check_managed_app tests (VS7#167293).
*       03-27-01  PML   report _RT_SPACEARG on __[w]getmainargs error
*                       (VS7#231220).
*       04-30-01  BWT   Don't do this for SYSCRT. Need to run against old msvcrt.dll's
*                       that don't return error.
*                       Remove _NTSDK.
*
*******************************************************************************/

#ifdef  CRTDLL

/*
 * SPECIAL BUILD MACROS! Note that crtexe.c (and crtexew.c) is linked in with
 * the client's code. It does not go into crtdll.dll! Therefore, it must be
 * built under the _DLL switch (like user code) and CRTDLL must be undefined.
 * The symbol SPECIAL_CRTEXE is turned on to suppress the normal CRT DLL
 * definition of _fmode and _commode using __declspec(dllexport).  Otherwise
 * this module would not be able to refer to both the local and DLL versions
 * of these two variables.
 */

#undef  CRTDLL
#undef _DLL
#define _DLL

#define SPECIAL_CRTEXE

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <process.h>
#include <math.h>
#include <rterr.h>
#include <stdlib.h>
#include <tchar.h>
#include <rtcapi.h>
#include <sect_attribs.h>


/*
 * wWinMain is not yet defined in winbase.h. When it is, this should be
 * removed.
 */

int
WINAPI
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR lpCmdLine,
    int nShowCmd
    );

#define SPACECHAR   _T(' ')
#define DQUOTECHAR  _T('\"')

#ifdef  _M_IX86

/*
 * The local copy of the Pentium FDIV adjustment flag
 * and the address of the flag in MSVCRT*.DLL.
 */

extern int _adjust_fdiv;

extern int * _imp___adjust_fdiv;

#endif


/* default floating point precision - X86 only! */

#ifdef  _M_IX86
extern void _setdefaultprecision();
#endif


/*
 * Declare function used to install a user-supplied _matherr routine.
 */
_CRTIMP void __setusermatherr( int (__cdecl *)(struct _exception *) );


/*
 * Declare the names of the exports corresponding to _fmode and _commode
 */
#ifdef _M_IX86

#define _IMP___FMODE    (__p__fmode())
#define _IMP___COMMODE  (__p__commode())

#else   /* ndef _M_IX86 */

/* assumed to be MIPS or Alpha */

#define _IMP___FMODE    __imp__fmode
#define _IMP___COMMODE  __imp__commode

#endif  /* _M_IX86 */

#if     !defined(_M_IX86)
extern int * _IMP___FMODE;      /* exported from the CRT DLL */
extern int * _IMP___COMMODE;    /* these names are implementation-specific */
#endif

extern int _fmode;          /* must match the definition in <stdlib.h> */
extern int _commode;        /* must match the definition in <internal.h> */
extern int _dowildcard;     /* passed to __getmainargs() */

/*
 * Declare/define communal that serves as indicator the default matherr
 * routine is being used.
 */
int __defaultmatherr;

/*
 * routine in DLL to do initialization (in this case, C++ constructors)
 */
extern void __cdecl _initterm(_PVFV *, _PVFV *);

/*
 * routine to check if this is a managed application
 */
static int __cdecl check_managed_app(void);

/*
 * pointers to initialization sections
 */
extern _CRTALLOC(".CRT$XIA") _PVFV __xi_a[];
extern _CRTALLOC(".CRT$XIZ") _PVFV __xi_z[];    /* C initializers */
extern _CRTALLOC(".CRT$XCA") _PVFV __xc_a[];
extern _CRTALLOC(".CRT$XCZ") _PVFV __xc_z[];    /* C++ initializers */

/*
 * Pointers to beginning and end of the table of function pointers manipulated
 * by _onexit()/atexit().  The atexit/_onexit code is shared for both EXE's and
 * DLL's but different behavior is required.  These values are set to -1 to
 * mark this module as an EXE.
 */

extern _PVFV *__onexitbegin;
extern _PVFV *__onexitend;


/***
*mainCRTStartup(void)
*wmainCRTStartup(void)
*WinMainCRTStartup(void)
*wWinMainCRTStartup(void)
*
*Purpose:
*       These routines do the C runtime initialization, call the appropriate
*       user entry function, and handle termination cleanup.  For a managed
*       app, they then return the exit code back to the calling routine, which
*       is the managed startup code.  For an unmanaged app, they call exit and
*       never return.
*
*       Function:               User entry called:
*       mainCRTStartup          main
*       wmainCRTStartup         wmain
*       WinMainCRTStartup       WinMain
*       wWinMainCRTStartup      wWinMain
*
*Entry:
*
*Exit:
*       Managed app: return value from main() et al, or the exception code if
*                 execution was terminated by the __except guarding the call
*                 to main().
*       Unmanaged app: never return.
*
*******************************************************************************/

#ifdef  _WINMAIN_

#ifdef  WPRFLAG
int wWinMainCRTStartup(
#else
int WinMainCRTStartup(
#endif

#else   /* ndef _WINMAIN_ */

#ifdef  WPRFLAG
int wmainCRTStartup(
#else
int mainCRTStartup(
#endif

#endif  /* _WINMAIN_ */
        void
        )
{
        int argc;   /* three standard arguments to main */
        _TSCHAR **argv;
        _TSCHAR **envp;

        int argret;
        int mainret;
        int managedapp;

#ifdef  _WINMAIN_
        _TUCHAR *lpszCommandLine;
        STARTUPINFO StartupInfo;
#endif
        _startupinfo    startinfo;        

        /*
         * Determine if this is a managed application
         */
        managedapp = check_managed_app();

        /*
         * Guard the initialization code and the call to user's main, or
         * WinMain, function in a __try/__except statement.
         */

        __try {
            /*
             * Set __app_type properly
             */
#ifdef  _WINMAIN_
            __set_app_type(_GUI_APP);
#else
            __set_app_type(_CONSOLE_APP);
#endif

            /*
             * Mark this module as an EXE file so that atexit/_onexit
             * will do the right thing when called, including for C++
             * d-tors.
             */
            __onexitbegin = __onexitend = (_PVFV *)(-1);

            /*
             * Propogate the _fmode and _commode variables to the DLL
             */
            *_IMP___FMODE = _fmode;
            *_IMP___COMMODE = _commode;

#ifdef  _M_IX86
            /*
             * Set the local copy of the Pentium FDIV adjustment flag
             */

            _adjust_fdiv = * _imp___adjust_fdiv;
#endif

            /*
             * Run the RTC initialization code for this DLL
             */
#ifdef  _RTC
            _RTC_Initialize();
#endif

            /*
             * Call _setargv(), which will trigger a call to __setargv() if
             * SETARGV.OBJ is linked with the EXE.  If SETARGV.OBJ is not
             * linked with the EXE, a dummy _setargv() will be called.
             */
#ifdef  WPRFLAG
            _wsetargv();
#else
            _setargv();
#endif

            /*
             * If the user has supplied a _matherr routine then set
             * __pusermatherr to point to it.
             */
            if ( !__defaultmatherr )
                __setusermatherr(_matherr);

#ifdef  _M_IX86
            _setdefaultprecision();
#endif

            /*
             * Do runtime startup initializers.
             *
             * Note: the only possible entry we'll be executing here is for
             * __lconv_init, pulled in from charmax.obj only if the EXE was
             * compiled with -J.  All other .CRT$XI* initializers are only
             * run as part of the CRT itself, and so for the CRT DLL model
             * are not found in the EXE.  For that reason, we call _initterm,
             * not _initterm_e, because __lconv_init will never return failure,
             * and _initterm_e is not exported from the CRT DLL.
             *
             * Note further that, when using the CRT DLL, executing the
             * .CRT$XI* initializers is only done for an EXE, not for a DLL
             * using the CRT DLL.  That is to make sure the -J setting for
             * the EXE is not overriden by that of any DLL.
             */
            _initterm( __xi_a, __xi_z );

#ifdef  _RTC
            atexit(_RTC_Terminate);
#endif

            /*
             * Get the arguments for the call to main. Note this must be
             * done explicitly, rather than as part of the dll's
             * initialization, to implement optional expansion of wild
             * card chars in filename args
             */

            startinfo.newmode = _newmode;

#ifdef  ANSI_NEW_HANDLER
            startinfo.newh = _defnewh;
#endif  /* ANSI_NEW_HANDLER */

#ifdef  WPRFLAG
            argret = __wgetmainargs(&argc, &argv, &envp,
                                    _dowildcard, &startinfo);
#else
            argret = __getmainargs(&argc, &argv, &envp,
                                   _dowildcard, &startinfo);
#endif

#ifndef _SYSCRT
            if (argret < 0)
                _amsg_exit(_RT_SPACEARG);
#endif

            /*
             * do C++ constructors (initializers) specific to this EXE
             */
            _initterm( __xc_a, __xc_z );

#ifdef  _WINMAIN_
            /*
             * Skip past program name (first token in command line).
             * Check for and handle quoted program name.
             */
#ifdef  WPRFLAG
            /* OS may not support "W" flavors */
            if (_wcmdln == NULL)
                return 255;
            lpszCommandLine = (wchar_t *)_wcmdln;
#else
            lpszCommandLine = (unsigned char *)_acmdln;
#endif

            if ( *lpszCommandLine == DQUOTECHAR ) {
                /*
                 * Scan, and skip over, subsequent characters until
                 * another double-quote or a null is encountered.
                 */
                while ( *++lpszCommandLine && (*lpszCommandLine
                        != DQUOTECHAR) );
                /*
                 * If we stopped on a double-quote (usual case), skip
                 * over it.
                 */
                if ( *lpszCommandLine == DQUOTECHAR )
                    lpszCommandLine++;
            }
            else {
                while (*lpszCommandLine > SPACECHAR)
                    lpszCommandLine++;
            }

            /*
             * Skip past any white space preceeding the second token.
             */
            while (*lpszCommandLine && (*lpszCommandLine <= SPACECHAR)) {
                lpszCommandLine++;
            }

            StartupInfo.dwFlags = 0;
            GetStartupInfo( &StartupInfo );

#ifdef  WPRFLAG
            mainret = wWinMain(
#else
            mainret = WinMain(
#endif
                       GetModuleHandleA(NULL),
                       NULL,
                       lpszCommandLine,
                       StartupInfo.dwFlags & STARTF_USESHOWWINDOW
                        ? StartupInfo.wShowWindow
                        : SW_SHOWDEFAULT
                      );
#else   /* _WINMAIN_ */

#ifdef  WPRFLAG
            __winitenv = envp;
            mainret = wmain(argc, argv, envp);
#else
            __initenv = envp;
            mainret = main(argc, argv, envp);
#endif

#endif  /* _WINMAIN_ */

            if ( !managedapp )
                exit(mainret);

            _cexit();

        }
        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )
        {
            /*
             * Should never reach here
             */

            mainret = GetExceptionCode();

            if ( !managedapp )
                _exit(mainret);

            _c_exit();

        } /* end of try - except */

        return mainret;
}

/***
*check_managed_app() - Check for a managed executable
*
*Purpose:
*       Determine if the EXE the startup code is linked into is a managed app
*       by looking for the COM Runtime Descriptor in the Image Data Directory
*       of the PE or PE+ header.
*
*Entry:
*       None
*
*Exit:
*       1 if managed app, 0 if not.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl check_managed_app (
        void
        )
{
        PIMAGE_DOS_HEADER pDOSHeader;
        PIMAGE_NT_HEADERS pPEHeader;
        PIMAGE_OPTIONAL_HEADER32 pNTHeader32;
        PIMAGE_OPTIONAL_HEADER64 pNTHeader64;

        pDOSHeader = (PIMAGE_DOS_HEADER)GetModuleHandleA(NULL);
        if ( pDOSHeader->e_magic != IMAGE_DOS_SIGNATURE )
            return 0;

        pPEHeader = (PIMAGE_NT_HEADERS)((char *)pDOSHeader +
                                        pDOSHeader->e_lfanew);
        if ( pPEHeader->Signature != IMAGE_NT_SIGNATURE )
            return 0;

        pNTHeader32 = (PIMAGE_OPTIONAL_HEADER32)&pPEHeader->OptionalHeader;
        switch ( pNTHeader32->Magic ) {
        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
            /* PE header */
            if ( pNTHeader32->NumberOfRvaAndSizes <=
                    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR )
                return 0;
            return !! pNTHeader32 ->
                      DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR] .
                      VirtualAddress;
        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
            /* PE+ header */
            pNTHeader64 = (PIMAGE_OPTIONAL_HEADER64)pNTHeader32;
            if ( pNTHeader64->NumberOfRvaAndSizes <=
                    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR )
                return 0;
            return !! pNTHeader64 ->
                      DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR] .
                      VirtualAddress;
        }

        /* Not PE or PE+, so not managed */
        return 0;
}

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\atonexit.c ===
/***
*atonexit.c - _onexit/atexit for using the MSVCRT* model of C run-time
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       atexit and _onexit are handled differently for EXE's and DLL's linked
*       with MSVCRT.LIB to call MSVCRT*.DLL.  Specifically, the _onexit/atexit
*       list for DLL's must be maintained on a per-module basis and must be
*       processed at DLL process detach .  For EXE's the atexit/_onexit list
*       should be maintained by MSVCRT*.DLL and processed at process exit.
*
*Revision History:
*       05-24-93  SKS   Initial version
*       10-19-93  CFW   MIPS support for _imp__xxx.
*       10-26-93  GJF   Replaced PF with _PVFV (defined in internal.h).
*       04-12-94  GJF   Build with _DLL defined, not CRTDLL.
*       05-19-94  GJF   For Win32s serialize calls to __dllonexit by multiple
*                       client processes.
*       05-26-94  GJF   Replaced compile-time conditioning on DLL_FOR_WIN32S
*                       with a runtime test for Win32s.
*       06-06-94  GJF   In Win32s, onexitflag wasn't getting decremented.
*       12-13-94  GJF   Made Win32s support conditional on _M_IX86.
*       02-22-95  JWM   Spliced in PMAC code.
*       11-15-95  BWT   Win32s isn't interesting for the NT build
*       06-27-96  GJF   Purged Win32s support (removed __win32sflag). Replaced
*                       defined(_WIN32) with !defined(_MAC).
*       08-01-96  RDK   For PMAC, make _onexit parallel x86 functionality.
*       05-17-99  PML   Remove all Macintosh support.
*       03-27-01  PML   Remove unneeded proto for _initterm.
*
*******************************************************************************/

/*
 * SPECIAL BUILD MACRO! Note that atonexit.c is linked in with the client's
 * code. It does not go into crtdll.dll! Therefore, it must be built under
 * the _DLL switch (like user code) and CRTDLL must be undefined.
 */

#undef  CRTDLL
#ifndef _DLL
#define _DLL
#endif

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <stdlib.h>


/*
 * Pointers to beginning and end of the table of function pointers manipulated
 * by _onexit()/atexit().  If this module is an EXE, _onexitbegin will be -1.
 * Otherwise _onexitbegin will point to a block of malloc-ed memory used to
 * maintain the DLL module's private onexit list of terminator routines.
 */

_PVFV *__onexitbegin;
_PVFV *__onexitend;


/***
*_onexit, atexit - calls to _onexit & atexit in MSVCRT*.DLL
*
*Purpose:
*       A DLL linked with MSVCRT.LIB must not call the standard _onexit or
*       atexit exported from MSVCRT*.DLL, but an EXE linked with MSVCRT.LIB
*       will call the standard versions of those two routines.  The standard
*       names are not exported from MSVCRT*.DLL, but the _imp__* names are,
*       so this module can just invoke the standard versions if linked into
*       an EXE module (indicated by __onexitbegin == -1).  If this module is
*       linked into a DLL (indicated by __onexitbegin != -1), it will call a
*       helper routine in MSVCRT*.DLL called __dllonexit to manager the DLL's
*       private onexit list.
*
*Entry:
*       Same as the regular versions of _onexit, atexit.
*
*Exit:
*       Same as the regular versions of _onexit, atexit.
*
*Exceptions:
*
*******************************************************************************/

extern _onexit_t __dllonexit(_onexit_t, _PVFV**, _PVFV**);

#ifdef  _M_IX86
extern _onexit_t (__cdecl *_imp___onexit)(_onexit_t func);
#else
extern _onexit_t (__cdecl *__imp__onexit)(_onexit_t func);
#endif

_onexit_t __cdecl _onexit (
        _onexit_t func
        )
{
#ifdef  _M_IX86

        return( (__onexitbegin == (_PVFV *) -1)
             /* EXE */ ? (*_imp___onexit)(func)
             /* DLL */ : __dllonexit(func, &__onexitbegin, &__onexitend));

#else   /* _M_IX86 */

        return( (__onexitbegin == (_PVFV *) -1)
            /* EXE */ ? (*__imp__onexit)(func)
            /* DLL */ : __dllonexit(func, &__onexitbegin, &__onexitend) );

#endif  /* _M_IX86 */
}

int __cdecl atexit (
        _PVFV func
        )
{
        return (_onexit((_onexit_t)func) == NULL) ? -1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\crtdll.c ===
/***
*crtdll.c - CRT initialization for a DLL using the MSVCRT* model of C run-time
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains the initialization entry point for the C run-time
*       stub in this DLL.  All C run-time code is located in the C Run-Time
*       Library DLL "MSVCRT*.DLL", except for a little bit of start-up code in
*       the EXE, and this code in each DLL.  This code is necessary to invoke
*       the C++ constructors for the C++ code in this DLL.
*
*       This entry point should either be specified as the DLL initialization
*       entry point, or else it must be called by the DLL initialization entry
*       point of the DLL with the same arguments that the entry point receives.
*
*Revision History:
*       05-19-92  SKS   Initial version
*       08-01-92  SRW   winxcpt.h replaced bu excpt.h which is included by oscalls.h
*       09-16-92  SKS   Prepare for C8 C++ for MIPS by calling C++ constructors
*       09-29-92  SKS   _CRT_DLL must be a WINAPI function!
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       04-14-93  SKS   _DllMainCRTStartup replaces _CRT_INIT
*       04-20-93  SKS   Restore _CRT_INIT, must co-exist with DllMainCRTStartup
*       05-24-93  SKS   Add indirect definitions of _onexit/atexit.
*       06-08-93  GJF   Added __proc_attached flag.
*       06-08-93  SKS   Clean up failure handling in _CRT_INIT
*       10-26-93  GJF   Replaced PF with _PVFV (defined in internal.h).
*       05-02-94  GJF   Add _wDllMainCRTStartup thunk.
*       05-19-94  GJF   For Win32S version, only create the onexit-table and
*                       do the C++ constructors for the first process that
*                       attaches. Similarly, only execute the table entries
*                       when the last process detaches. Also, removed bogus
*                       incrementing and decrementing of __proc_attached flag
*                       in _DllMainCRTStartup.
*       05-27-94  GJF   Replaced conditional compilation on DLL_FOR_WIN32S
*                       with a runtime test for Win32s.
*       06-04-94  GJF   Fixed test for first process attach in Win32s.
*       06-06-94  GJF   Use GlobalAlloc for Win32s.
*       06-08-94  SKS   Add functn pointer _pRawDllMain, called around DllMain.
*       07-18-94  GJF   Must specify GMEM_SHARE in GlobalAlloc.
*       11-08-94  SKS   Free __onexitbegin (under !Win32s) to fix memory leak
*       12-13-94  GJF   Made Win32s support conditional on _M_IX86.
*       12-13-94  SKS   Import the value of "_adjust_fdiv" from the CRTL DLL
*       12-27-94  CFW   Remove unused _wDll support.
*       01-10-95  CFW   Debug CRT allocs.
*       02-22-95  JWM   Spliced in PMAC code.
*       05-24-95  CFW   Return value from DllInit.
*       07-24-95  CFW   Change PMac onexit malloc to _malloc_crt.
*       11-15-95  BWT   Win32s isn't interesting for NT.
*       05-14-96  GJF   Changed how failure during process attach is handled.
*       06-27-96  GJF   Purged Win32s support (removed __win32sflag). Replaced
*                       defined(_WIN32) with !defined(_MAC). Removed NT_BUILD.
*       02-01-99  GJF   Slight change to terminator execution loop to allow 
*                       terminators to register more terminators.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-11-99  KBF   Wrap RTC support in #ifdef.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifdef  CRTDLL

/*
 * SPECIAL BUILD MACRO! Note that crtexe.c (and crtexew.c) is linked in with
 * the client's code. It does not go into crtdll.dll! Therefore, it must be
 * built under the _DLL switch (like user code) and CRTDLL must be undefined.
 */
#undef  CRTDLL
#undef _DLL
#define _DLL

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <stdlib.h>
#define _DECL_DLLMAIN   /* enable prototypes for DllMain and _CRT_INIT */
#include <process.h>
#include <dbgint.h>
#include <rtcapi.h>
#include <sect_attribs.h>

#ifdef  _M_IX86

/*
 * The local copy of the Pentium FDIV adjustment flag
 *      and the address of the flag in MSVCRT*.DLL.
 */

extern int _adjust_fdiv;

extern int * _imp___adjust_fdiv;

#endif


/*
 * routine in DLL to do initialization (in this case, C++ constructors)
 */

extern void __cdecl _initterm(_PVFV *, _PVFV *);

/*
 * pointers to initialization sections
 */

extern _CRTALLOC(".CRT$XCA") _PVFV __xc_a[];
extern _CRTALLOC(".CRT$XCZ") _PVFV __xc_z[];    /* C++ initializers */

/*
 * flag set iff _CRTDLL_INIT was called with DLL_PROCESS_ATTACH
 */
static int __proc_attached = 0;


/*
 * Pointers to beginning and end of the table of function pointers manipulated
 * by _onexit()/atexit().  The atexit/_onexit code is shared for both EXE's and
 * DLL's but different behavior is required.  These values are initialized to
 * 0 by default and will be set to point to a malloc-ed memory block to mark
 * this module as an DLL.
 */

extern _PVFV *__onexitbegin;
extern _PVFV *__onexitend;


/*
 * User routine DllMain is called on all notifications
 */

extern BOOL WINAPI DllMain(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        ) ;

/* _pRawDllMain MUST be a common variable, not extern nor initialized! */

BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);


/***
*BOOL WINAPI _CRT_INIT(hDllHandle, dwReason, lpreserved) - C++ DLL 
*       initialization.
*BOOL WINAPI _DllMainCRTStartup(hDllHandle, dwReason, lpreserved) - C++ DLL 
*       initialization.
*
*Purpose:
*       This is the entry point for DLL's linked with the C/C++ run-time libs.
*       This routine does the C runtime initialization for a DLL linked with
*       MSVCRT.LIB (whose C run-time code is thus in MSVCRT*.DLL.)
*       It will call the user notification routine DllMain on all 4 types of
*       DLL notifications.  The return code from this routine is the return
*       code from the user notification routine.
*
*       On DLL_PROCESS_ATTACH, the C++ constructors for the DLL will be called.
*
*       On DLL_PROCESS_DETACH, the C++ destructors and _onexit/atexit routines
*       will be called.
*
*Entry:
*
*Exit:
*
*******************************************************************************/

BOOL WINAPI _CRT_INIT(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        /*
         * If this is a process detach notification, check that there has
         * been a prior (successful) process attachment.
         */
        if ( dwReason == DLL_PROCESS_DETACH ) {
            if ( __proc_attached > 0 )
                __proc_attached--;
            else
                /*
                 * no prior process attach. just return failure.
                 */
                return FALSE;
        }

#ifdef  _M_IX86

        /*
         * Set the local copy of the Pentium FDIV adjustment flag
         */

        _adjust_fdiv = * _imp___adjust_fdiv;

#endif

        /*
         * do C++ constructors (initializers) specific to this DLL
         */

        if ( dwReason == DLL_PROCESS_ATTACH ) {

            /*
             * create the onexit table.
             */
            if ( (__onexitbegin = (_PVFV *)_malloc_crt(32 * sizeof(_PVFV))) 
                 == NULL )
                /*
                 * cannot allocate minimal required
                 * size. generate failure to load DLL
                 */
                return FALSE;

            *(__onexitbegin) = (_PVFV) NULL;

            __onexitend = __onexitbegin;

            /*
             * Run the RTC initialization code for this DLL
             */
#ifdef  _RTC
            _RTC_Initialize();
            atexit(_RTC_Terminate);
#endif
            /*
             * Invoke C++ constructors
             */
            _initterm(__xc_a,__xc_z);

            /*
             * Increment the process attached flag.
             */
            __proc_attached++;

        }
        else if ( dwReason == DLL_PROCESS_DETACH ) {

            /*
             * Any basic clean-up code that goes here must be
             * duplicated below in _DllMainCRTStartup for the
             * case where the user's DllMain() routine fails on a
             * Process Attach notification. This does not include
             * calling user C++ destructors, etc.
             */

            /*
             * do _onexit/atexit() terminators
             * (if there are any)
             *
             * These terminators MUST be executed in
             * reverse order (LIFO)!
             *
             * NOTE:
             *  This code assumes that __onexitbegin
             *  points to the first valid onexit()
             *  entry and that __onexitend points
             *  past the last valid entry. If
             *  __onexitbegin == __onexitend, the
             *  table is empty and there are no
             *  routines to call.
             */

            if (__onexitbegin) {
                while ( --__onexitend >= __onexitbegin )
                    /*
                     * if current table entry is not
                     * NULL, call thru it.
                     */
                    if ( *__onexitend != NULL )
                        (**__onexitend)();

                /*
                 * free the block holding onexit table to
                 * avoid memory leaks.  Also zero the ptr
                 * variable so that it is clearly cleaned up.
                 */

                _free_crt ( __onexitbegin ) ;

                __onexitbegin = NULL ;
            }
        }

        return TRUE;
}


BOOL WINAPI _DllMainCRTStartup(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        BOOL retcode = TRUE;

        /*
         * If this is a process detach notification, check that there has
         * been a prior process attach notification.
         */
        if ( (dwReason == DLL_PROCESS_DETACH) && (__proc_attached == 0) )
            return FALSE;

        if ( dwReason == DLL_PROCESS_ATTACH || dwReason == DLL_THREAD_ATTACH )
        {
            if ( _pRawDllMain )
                retcode = (*_pRawDllMain)(hDllHandle, dwReason, lpreserved);

            if ( retcode )
                retcode = _CRT_INIT(hDllHandle, dwReason, lpreserved);

            if ( !retcode )
                return FALSE;
        }

        retcode = DllMain(hDllHandle, dwReason, lpreserved);


        if ( (dwReason == DLL_PROCESS_ATTACH) && !retcode )
            /*
             * The user's DllMain routine returned failure, the C runtime
             * needs to be cleaned up. Do this by calling _CRT_INIT again, 
             * this time imitating DLL_PROCESS_DETACH. Note this will also
             * clear the __proc_attached flag so the cleanup will not be 
             * repeated upon receiving the real process detach notification.
             */
            _CRT_INIT(hDllHandle, DLL_PROCESS_DETACH, lpreserved);

        if ( (dwReason == DLL_PROCESS_DETACH) || 
             (dwReason == DLL_THREAD_DETACH) )
        {
            if ( _CRT_INIT(hDllHandle, dwReason, lpreserved) == FALSE )
                retcode = FALSE ;

            if ( retcode && _pRawDllMain )
                retcode = (*_pRawDllMain)(hDllHandle, dwReason, lpreserved);
        }

        return retcode ;
}

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\imp_data.c ===
/***
*imp_data.c - declares all exported data (variables) forwarded by MSVCRT40.DLL
*
*	Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file declares all data variables exported (forwarded) by the
*	CRTL DLL MSVCRT40.DLL so that the linker will correctly decorate
*	the names of those variables.
*
*Revision History:
*	05-14-96  SKS	Initial version
*	03-17-97  RDK	Added _mbcasemap.
*
*******************************************************************************/

void * _HUGE;
void * __argc;
void * __argv;
void * __badioinfo;
void * __initenv;
void * __mb_cur_max;
void * __pioinfo;
void * __wargv;
void * __winitenv;
void * _acmdln;
void * _aexit_rtn;
void * _crtAssertBusy;
void * _crtBreakAlloc;
void * _crtDbgFlag;
void * _daylight;
void * _dstbias;
void * _environ;
void * _fileinfo;
void * _mbctype;
void * _mbcasemap;
void * _osver;
void * _pctype;
void * _pgmptr;
void * _pwctype;
void * _sys_nerr;
void * _timezone;
void * _wcmdln;
void * _wenviron;
void * _winmajor;
void * _winminor;
void * _winver;
void * _wpgmptr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\fwdr_dll.c ===
/***
*Fwdr_DLL.c - CRTL Forwarder DLL initialization and termination routine (Win32)
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains initialization entry point for the CRTL forwarder DLL
*       in the Win32 environment.  This DLL doesn't do anything except forward its
*       imports to the newer CRTL DLL.
*
*Revision History:
*       05-13-96  SKS   Initial version.
*
*******************************************************************************/

#ifdef  CRTDLL

#include <windows.h>

/*
 * The following variable is exported just so that the forwarder DLL can import it.
 * The forwarder DLL needs to have at least one import from this DLL to ensure that
 * this DLL will be fully initialized.
 */

extern __declspec(dllimport) int __dummy_export;

extern __declspec(dllimport) int _osver;

int __dummy_import;


/***
*BOOL _FWDR_CRTDLL_INIT(hDllHandle, dwReason, lpreserved) - C DLL initialization.
*
*Purpose:
*       This routine does the C runtime initialization.  It disables Thread
*       Attach/Detach notifications for this DLL since they are not used.
*
*Entry:
*
*Exit:
*
*******************************************************************************/

BOOL WINAPI _FWDR_CRTDLL_INIT(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        if ( dwReason == DLL_PROCESS_ATTACH )
        {
                __dummy_import = __dummy_export + _osver;

                DisableThreadLibraryCalls(hDllHandle);
        }

        return TRUE ;
}

#endif /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\ios_dll.c ===
/***
*IOS_DLL.c - Old Iostreams CRTL DLL initialization and termination routine (Win32)
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains initialization entry point for the "old" Iostreams
*       C Run-Time Library DLL.
*
*Revision History:
*       05-13-96  SKS   Initial version.
*
*******************************************************************************/

#ifdef  CRTDLL

#include <windows.h>

/***
*BOOL DllMain(hDllHandle, dwReason, lpreserved) - C DLL initialization.
*
*Purpose:
*       This routine does the C runtime initialization.  It disables Thread
*       Attach/Detach notifications for this DLL since they are not used.
*
*Entry:
*
*Exit:
*
*******************************************************************************/


BOOL WINAPI DllMain(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        if ( dwReason == DLL_PROCESS_ATTACH )
                DisableThreadLibraryCalls(hDllHandle);

        return TRUE ;
}


/*
 * The following variable is exported just so that the forwarder DLL can import it.
 * The forwarder DLL needs to have at least one import from this DLL to ensure that
 * this DLL will be fully initialized.
 */

__declspec(dllexport) int __dummy_export = 0x420;

#endif /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\crtlib.c ===
/***
*crtlib.c - CRT DLL initialization and termination routine (Win32, Dosx32)
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains initialization entry point for the CRT DLL
*       in the Win32 environment. It also contains some of the supporting
*       initialization and termination code.
*
*Revision History:
*       08-12-91  GJF   Module created. Sort of.
*       01-17-92  GJF   Return exception code value for RTEs corresponding
*                       to exceptions.
*       01-29-92  GJF   Support for wildcard expansion in filenames on the
*                       command line.
*       02-14-92  GJF   Moved file inheritance stuff to ioinit.c. Call to
*                       inherit() is replace by call to _ioinit().
*       08-26-92  SKS   Add _osver, _winver, _winmajor, _winminor
*       09-04-92  GJF   Replaced _CALLTYPE3 with WINAPI.
*       09-30-92  SRW   Call _heap_init before _mtinit
*       10-19-92  SKS   Add "dowildcard" parameter to GetMainArgs()
*                       Prepend a second "_" to name since it is internal-only
*       03-20-93  SKS   Remove obsolete variables _osmode, _cpumode, etc.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Change __GetMainArgs to __getmainargs
*       04-13-93  SKS   Change call to _mtdeletelocks to new routine _mtterm
*       04-26-93  SKS   Change _CRTDLL_INIT to fail loading on failure to
*                       initialize/clean up, rather than calling _amsg_exit().
*       04-27-93  GJF   Removed support for _RT_STACK, _RT_INTDIV,
*                       _RT_INVALDISP and _RT_NONCONT.
*       05-06-93  SKS   Add call to _heap_term to free up all allocated memory
*                       *and* address space.  This must be the last thing done.
*       06-03-93  GJF   Added __proc_attached flag.
*       06-07-93  GJF   Incorporated SteveWo's code to call LoadLibrary, from
*                       crtdll.c.
*       11-05-93  CFW   Undefine GetEnviromentStrings.
*       11-09-93  GJF   Added call to __initmbctable (must happen before
*                       environment strings are processed).
*       11-09-93  GJF   Merged with NT SDK version (primarily the change of
*                       06-07-93 noted above). Also, replace MTHREAD with
*                       _MT.
*       11-23-93  CFW   GetEnviromentStrings undef moved to internal.h.
*       11-23-93  CFW   Wide char enable.
*       11-29-93  CFW   Wide environment.
*       12-02-93  CFW   Remove WPRFLAG dependencies since only one version.
*       12-13-93  SKS   Free up per-thread CRT data on DLL_THREAD_DETACH
*                       with a call to _freeptd() in _CRT_INIT()
*       01-11-94  GJF   Use __GetMainArgs name when building libs for NT SDK.
*       02-07-94  CFW   POSIXify.
*       03-04-94  SKS   Add _newmode parameter to _*getmainargs (except NTSDK)
*       03-31-94  CFW   Use __crtGetEnvironmentStrings.
*       04-08-93  CFW   Move __crtXXX calls past initialization.
*       04-28-94  GJF   Major changes for Win32S support! Added
*                       AllocPerProcessDataStuct() to allocate and initialize
*                       the per-process data structure needed in the Win32s
*                       version of msvcrt*.dll. Also, added a function to
*                       free and access functions for all read-write global
*                       variables which might be used by a Win32s app.
*       05-04-94  GJF   Made access functions conditional on _M_IX86, added
*                       some comments to function headers, and fixed a
*                       possible bug in AllocPerProcessDataStruct (the return
*                       value for success was NOT explicitly set to something
*                       nonzero).
*       05-10-94  GJF   Added version check so that Win32 version (Win32s)
*                       will not load on Win32s (resp., Win32).
*       09-06-94  CFW   Remove _INTL switch.
*       09-06-94  CFW   Remove _MBCS_OS switch.
*       09-06-94  GJF   Added __error_mode and __app_type.
*       09-15-94  SKS   Clean up comments to avoid source release problems
*       09-21-94  SKS   Fix typo: no leading _ on "DLL_FOR_WIN32S"
*       10-04-94  CFW   Removed #ifdef _KANJI
*       10-04-94  BWT   Fix _NTSDK build
*       11-22-94  CFW   Must create wide environment if none.
*       12-19-94  GJF   Changed "MSVCRT20" to "MSVCRT30". Also, put testing for
*                       Win32S under #ifdef _M_IX86. Both changes from Richard
*                       Shupak.
*       01-16-95  CFW   Set default debug output for console.
*       02-13-95  GJF   Added initialization for the new _ppd_tzstd and
*                       _ppd_tzdst fields, thereby fixing the definition of
*                       _ppd__tzname.
*       02-15-95  CFW   Make all CRT message boxes look alike.
*       02-24-95  CFW   Use __crtMessageBoxA.
*       02-27-95  CFW   Change __crtMessageBoxA params.
*       03-08-95  GJF   Added initialization for _ppd__nstream. Removed
*                       _ppd_lastiob.
*       02-24-95  CFW   Call _CrtDumpMemoryLeaks.
*       04-06-95  CFW   Use __crtGetEnvironmentStringsA.
*       04-17-95  SKS   Free TLS index ppdindex when it is no longer needed
*       04-26-95  GJF   Added support for winheap in DLL_FOR_WIN32S build.
*       05-02-95  GJF   No _ppd__heap_maxregsize, _ppd__heap_regionsize or
*                       _ppd__heap_resetsize for WINHEAP.
*       05-24-95  CFW   Official ANSI C++ new handler added.
*       06-13-95  CFW   De-install client dump hook as client EXE/DLL is gone.
*       06-14-95  GJF   Changes for new lowio scheme (__pioinof[]) - no more
*                       per-process data initialization needed (Win32s) and
*                       added a call to _ioterm().
*       07-04-95  GJF   Interface to __crtGetEnvironmentStrings and _setenvp
*                       changes slightly.
*       06-27-95  CFW   Add win32s support for debug libs.
*       07-03-95  CFW   Changed offset of _lc_handle[LC_CTYPE], added sanity
*                       check to crtlib.c to catch changes to win32s.h that
*                       modify offset.
*       07-07-95  CFW   Simplify default report mode scheme.
*       07-25-95  CFW   Add win32s support for user visible debug heap vars.
*       08-21-95  SKS   (_ppd_)_CrtDbgMode needs to be initialized for Win32s
*       08-31-95  GJF   Added _dstbias.
*       11-09-95  GJF   Changed "ISTNT" to "IsTNT".
*       03-18-96  SKS   Add _fileinfo to variables implemented as functions.
*       04-22-96  GJF   Check for failure of heap initialization.
*       05-14-96  GJF   Changed where __proc_attached is set so that it 
*                       denotes successful completion of initialization.
*       06-11-96  JWM   Changed string "MSVCRT40" to "MSVCRT" in _CRTDLL_INIT().
*       06-27-96  GJF   Purged Win32s support. Note, the access functions must
*                       be retained for backwards compatibility.
*       06-28-96  SKS   Remove obsolete local variable "hmod".
*       03-17-97  RDK   Add reference to _mbcasemap.
*       07-24-97  GJF   heap_init changed slightly to support option to use 
*                       heap running directly on Win32 API.
*       08-08-97  GJF   Rearranged #ifdef-s so ptd is only defined when it is
*                       used (under ANSI_NEW_HANDLER).
*       10-02-98  GJF   Use GetVersionEx instead of GetVersion and store OS ID
*                       in _osplatform.
*       04-30-99  GJF   Don't clean up system resources if the whole process
*                       if terminating.
*       09-02-99  PML   Put Win32s check in system CRT only.
*       02-02-00  GB    Added ATTACH_THREAD support for _CRT_INIT where we
*                       initialise per thread data so that in case where we
*                       are short of memory, we don't have to kill the whole
*                       process for inavailablity of space.
*       08-22-00  GB    Fixed potentia leak of ptd in CRT_INIT
*       09-06-00  GB    Changed the function definations of _pctype and 
*                       _pwctype to const
*       03-16-01  PML   _alloca the OSVERSIONINFO so /GS can work (vs7#224261)
*       03-19-01  BWT   Add test to preclude msvcrt.dll loading on anything other
*                       than the OS it ships with.
*       03-26-01  PML   Use GetVersionExA, not GetVersionEx (vs7#230286)
*       03-27-01  PML   Fail DLL load instead of calling _amsg_exit, and
*                       propogate error on EXE arg parsing up (vs7#231220).
*       03-28-01  PML   Protect against GetModuleFileName overflow (vs7#231284)
*       04-05-01  PML   Clean up on DLL unload due to FreeLibrary, or on
*                       termination by ExitProcess instead of exit (vs7#235781)
*       04-30-01  BWT   Remove _NTSDK and just return false if the OS doesn't match
*
*******************************************************************************/

#if defined(CRTDLL)

#include <cruntime.h>
#include <oscalls.h>
#include <dos.h>
#include <internal.h>
#include <malloc.h>
#include <mbctype.h>
#include <mtdll.h>
#include <process.h>
#include <rterr.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <awint.h>
#include <tchar.h>
#include <time.h>
#include <dbgint.h>
#ifdef _SYSCRT
#include <ntverp.h>
#endif

/*
 * flag set iff _CRTDLL_INIT was called with DLL_PROCESS_ATTACH
 */
static int proc_attached = 0;

/*
 * command line, environment, and a few other globals
 */
wchar_t *_wcmdln = NULL;           /* points to wide command line */
char *_acmdln = NULL;              /* points to command line */

char *_aenvptr = NULL;      /* points to environment block */
#ifndef _POSIX_
wchar_t *_wenvptr = NULL;   /* points to wide environment block */
#endif /* _POSIX_ */

void (__cdecl * _aexit_rtn)(int) = _exit;   /* RT message return procedure */

extern int _newmode;    /* declared in <internal.h> */

int __error_mode = _OUT_TO_DEFAULT;

int __app_type = _UNKNOWN_APP;

static void __cdecl inherit(void);  /* local function */

/***
*int __[w]getmainargs - get values for args to main()
*
*Purpose:
*       This function invokes the command line parsing and copies the args
*       to main back through the passsed pointers. The reason for doing
*       this here, rather than having _CRTDLL_INIT do the work and exporting
*       the __argc and __argv, is to support the linked-in option to have
*       wildcard characters in filename arguments expanded.
*
*Entry:
*       int *pargc              - pointer to argc
*       _TCHAR ***pargv         - pointer to argv
*       _TCHAR ***penvp         - pointer to envp
*       int dowildcard          - flag (true means expand wildcards in cmd line)
*       _startupinfo * startinfo- other info to be passed to CRT DLL
*
*Exit:
*       Returns 0 on success, negative if _*setargv returns an error. Values
*       for the arguments to main() are copied through the passed pointers.
*
*******************************************************************************/

#if     !defined(_POSIX_)

_CRTIMP int __cdecl __wgetmainargs (
        int *pargc,
        wchar_t ***pargv,
        wchar_t ***penvp,
        int dowildcard,
        _startupinfo * startinfo)
{
        int ret;

#ifdef  ANSI_NEW_HANDLER
#ifdef  _MT
        /* set per-thread new handler for main thread */
        _ptiddata ptd = _getptd();
        ptd->_newh = startinfo->newh;
#endif

        /* set global default per-thread new handler */
        _defnewh = startinfo->newh;
#endif  /* ANSI_NEW_HANDLER */

        /* set global new mode flag */
        _newmode = startinfo->newmode;

        if ( dowildcard )
            ret = __wsetargv(); /* do wildcard expansion after parsing args */
        else
            ret = _wsetargv();  /* NO wildcard expansion; just parse args */
        if (ret < 0)
            return ret;

        *pargc = __argc;
        *pargv = __wargv;

        /*
         * if wide environment does not already exist,
         * create it from multibyte environment
         */
        if (!_wenviron)
            __mbtow_environ();

        *penvp = _wenviron;

        return ret;
}

#endif /* !defined(_POSIX_) */


_CRTIMP int __cdecl __getmainargs (
        int *pargc,
        char ***pargv,
        char ***penvp,
        int dowildcard
        ,
        _startupinfo * startinfo
        )
{
        int ret;

#ifdef  ANSI_NEW_HANDLER
#ifdef  _MT
        /* set per-thread new handler for main thread */
        _ptiddata ptd = _getptd();
        ptd->_newh = startinfo->newh;
#endif

        /* set global default per-thread new handler */
        _defnewh = startinfo->newh;
#endif  /* ANSI_NEW_HANDLER */

        /* set global new mode flag */
        _newmode = startinfo->newmode;

        if ( dowildcard )
            ret = __setargv();  /* do wildcard expansion after parsing args */
        else
            ret = _setargv();   /* NO wildcard expansion; just parse args */
        if (ret < 0)
            return ret;

        *pargc = __argc;
        *pargv = __argv;
        *penvp = _environ;

        return ret;
}


/***
*BOOL _CRTDLL_INIT(hDllHandle, dwReason, lpreserved) - C DLL initialization.
*
*Purpose:
*       This routine does the C runtime initialization.
*
*Entry:
*
*Exit:
*
*******************************************************************************/

BOOL WINAPI _CRTDLL_INIT(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        if ( dwReason == DLL_PROCESS_ATTACH ) {
            OSVERSIONINFOA *posvi;
#if defined(_SYSCRT)
            void __declspec(dllimport) __stdcall RtlGetNtVersionNumbers(PDWORD, PDWORD, PDWORD);
            
            // The app may have set Win32VersionValue in the PE header to change
            // GetVersionEx.  Ask NTDLL for the real version and bail if we don't match.
            DWORD NtMajorVersion;
            DWORD NtMinorVersion;

            RtlGetNtVersionNumbers(&NtMajorVersion, &NtMinorVersion, NULL);
            if ((NtMajorVersion != VER_PRODUCTMAJORVERSION) || (NtMinorVersion != VER_PRODUCTMINORVERSION))
                return FALSE;
#endif  /* _SYSCRT */
            /*
             * Dynamically allocate the OSVERSIONINFOA buffer, so we avoid
             * triggering the /GS buffer overrun detection.  That can't be
             * used here, since the guard cookie isn't available until we
             * initialize it from here!
             */
            posvi = (OSVERSIONINFOA *)_alloca(sizeof(OSVERSIONINFOA));

            /*
             * Get the full Win32 version.
             */
            posvi->dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            if ( !GetVersionExA(posvi) )
                return FALSE;

            _osplatform = posvi->dwPlatformId;
            _winmajor = posvi->dwMajorVersion;
            _winminor = posvi->dwMinorVersion;

            /*
             * The somewhat bizarre calculations of _osver and _winver are 
             * required for backward compatibility (used to use GetVersion)
             */
            _osver = (posvi->dwBuildNumber) & 0x07fff;
            if ( _osplatform != VER_PLATFORM_WIN32_NT )
                _osver |= 0x08000;
            _winver = (_winmajor << 8) + _winminor;

#ifdef  _MT
            if ( !_heap_init(1) )   /* initialize heap */
#else
            if ( !_heap_init(0) )   /* initialize heap */
#endif
                /*
                 * The heap cannot be initialized, return failure to the 
                 * loader.
                 */
                return FALSE;

#ifdef  _MT
            if(!_mtinit())          /* initialize multi-thread */
            {
                /*
                 * If the DLL load is going to fail, we must clean up
                 * all resources that have already been allocated.
                 */
                _heap_term();       /* heap is now invalid! */

                return FALSE;       /* fail DLL load on failure */
            }
#endif  /* _MT */

            if (_ioinit() < 0) {    /* inherit file info */
                /* Clean up already-allocated resources */
#ifdef  _MT
                /* free TLS index, call _mtdeletelocks() */
                _mtterm();
#endif  /* _MT */

                _heap_term();       /* heap is now invalid! */

                return FALSE;       /* fail DLL load on failure */
            }

            _aenvptr = (char *)__crtGetEnvironmentStringsA();

            _acmdln = (char *)GetCommandLineA();
#ifndef _POSIX_
            _wcmdln = (wchar_t *)__crtGetCommandLineW();
#endif /* _POSIX_ */

#ifdef  _MBCS
            /*
             * Initialize multibyte ctype table. Always done since it is
             * needed for processing the environment strings.
             */
            __initmbctable();
#endif

            /*
             * For CRT DLL, since we don't know the type (wide or multibyte)
             * of the program, we create only the multibyte type since that
             * is by far the most likely case. Wide environment will be created
             * on demand as usual.
             */

            if (_setenvp() < 0 ||   /* get environ info */
                _cinit() != 0)      /* do C data initialize */
            {
                _ioterm();          /* shut down lowio */
#ifdef  _MT
                _mtterm();          /* free TLS index, call _mtdeletelocks() */
#endif  /* _MT */
                _heap_term();       /* heap is now invalid! */
                return FALSE;       /* fail DLL load on failure */
            }

            /*
             * Increment flag indicating process attach notification
             * has been received.
             */
            proc_attached++;

        }
        else if ( dwReason == DLL_PROCESS_DETACH ) {
            /*
             * if a client process is detaching, make sure minimal
             * runtime termination is performed and clean up our
             * 'locks' (i.e., delete critical sections).
             */
            if ( proc_attached > 0 ) {
                proc_attached--;

                /*
                 * Any basic clean-up done here may also need
                 * to be done below if Process Attach is partly
                 * processed and then a failure is encountered.
                 */

                if ( _C_Termination_Done == FALSE )
                    _cexit();

#ifdef  _DEBUG
                /* Dump all memory leaks */
                if (_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_LEAK_CHECK_DF)
                {
                    _CrtSetDumpClient(NULL);
                    _CrtDumpMemoryLeaks();
                }
#endif

                /*
                 * What remains is to clean up the system resources we have
                 * used (handles, critical sections, memory,...,etc.). This 
                 * needs to be done if the whole process is NOT terminating.
                 */
                if ( lpreserved == NULL )
                {
                    /*
                     * The process is NOT terminating so we must clean up...
                     */
                    _ioterm();
#ifdef  _MT
                    /* free TLS index, call _mtdeletelocks() */
                    _mtterm();
#endif  /* _MT */

                    /* This should be the last thing the C run-time does */
                    _heap_term();   /* heap is now invalid! */
                }

            }
            else
                /* no prior process attach, just return */
                return FALSE;

        }
#ifdef  _MT
        else if ( dwReason == DLL_THREAD_ATTACH )
        {
            _ptiddata ptd;
            if ( ((ptd = _calloc_crt(1, sizeof(struct _tiddata))) != NULL))
            {
                if (TlsSetValue(__tlsindex, (LPVOID)ptd) ) {
                    /*
                     * Initialize of per-thread data
                     */
                    _initptd(ptd);
                    
                    ptd->_tid = GetCurrentThreadId();
                    ptd->_thandle = (uintptr_t)(-1);
                } else
                {
                    _free_crt(ptd);
                    return FALSE;
                }
            } else
            {
                return FALSE;
            }
        }
        else if ( dwReason == DLL_THREAD_DETACH )
        {
            _freeptd(NULL);     /* free up per-thread CRT data */
        }
#endif  /* _MT */

        return TRUE;
}

/***
*_amsg_exit(rterrnum) - Fast exit fatal errors
*
*Purpose:
*       Exit the program with error code of 255 and appropriate error
*       message.
*
*Entry:
*       int rterrnum - error message number (amsg_exit only).
*
*Exit:
*       Calls exit() (for integer divide-by-0) or _exit() indirectly
*       through _aexit_rtn [amsg_exit].
*       For multi-thread: calls _exit() function
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _amsg_exit (
        int rterrnum
        )
{

        if ( (__error_mode == _OUT_TO_STDERR) || ((__error_mode ==
               _OUT_TO_DEFAULT) && (__app_type == _CONSOLE_APP)) )
            _FF_MSGBANNER();    /* write run-time error banner */

        _NMSG_WRITE(rterrnum);      /* write message */
        _aexit_rtn(255);        /* normally _exit(255) */
}


#if     defined(_M_IX86 )

/*
 * Functions to access user-visible, per-process variables
 */

/*
 * Macro to construct the name of the access function from the variable
 * name.
 */
#define AFNAME(var) __p_ ## var

/*
 * Macro to construct the access function's return value from the variable 
 * name.
 */
#define AFRET(var)  &var

/*
 ***
 ***  Template
 ***

_CRTIMP __cdecl
AFNAME() (void)
{
        return AFRET();
}

 ***
 ***
 ***
 */

#ifdef  _DEBUG

_CRTIMP long *
AFNAME(_crtAssertBusy) (void)
{
        return AFRET(_crtAssertBusy);
}

_CRTIMP long *
AFNAME(_crtBreakAlloc) (void)
{
        return AFRET(_crtBreakAlloc);
}

_CRTIMP int *
AFNAME(_crtDbgFlag) (void)
{
        return AFRET(_crtDbgFlag);
}

#endif  /* _DEBUG */

_CRTIMP char ** __cdecl
AFNAME(_acmdln) (void)
{
        return AFRET(_acmdln);
}

_CRTIMP wchar_t ** __cdecl
AFNAME(_wcmdln) (void)
{
        return AFRET(_wcmdln);
}

_CRTIMP unsigned int * __cdecl
AFNAME(_amblksiz) (void)
{
        return AFRET(_amblksiz);
}

_CRTIMP int * __cdecl
AFNAME(__argc) (void)
{
        return AFRET(__argc);
}

_CRTIMP char *** __cdecl
AFNAME(__argv) (void)
{
        return AFRET(__argv);
}

_CRTIMP wchar_t *** __cdecl
AFNAME(__wargv) (void)
{
        return AFRET(__wargv);
}

_CRTIMP int * __cdecl
AFNAME(_commode) (void)
{
        return AFRET(_commode);
}

_CRTIMP int * __cdecl
AFNAME(_daylight) (void)
{
        return AFRET(_daylight);
}

_CRTIMP long * __cdecl
AFNAME(_dstbias) (void)
{
        return AFRET(_dstbias);
}

_CRTIMP char *** __cdecl
AFNAME(_environ) (void)
{
        return AFRET(_environ);
}

_CRTIMP wchar_t *** __cdecl
AFNAME(_wenviron) (void)
{
        return AFRET(_wenviron);
}

_CRTIMP int * __cdecl
AFNAME(_fmode) (void)
{
        return AFRET(_fmode);
}

_CRTIMP int * __cdecl
AFNAME(_fileinfo) (void)
{
        return AFRET(_fileinfo);
}

_CRTIMP char *** __cdecl
AFNAME(__initenv) (void)
{
        return AFRET(__initenv);
}

_CRTIMP wchar_t *** __cdecl
AFNAME(__winitenv) (void)
{
        return AFRET(__winitenv);
}

_CRTIMP FILE *
AFNAME(_iob) (void)
{
        return &_iob[0];
}

_CRTIMP unsigned char * __cdecl
AFNAME(_mbctype) (void)
{
        return &_mbctype[0];
}

_CRTIMP unsigned char * __cdecl
AFNAME(_mbcasemap) (void)
{
        return &_mbcasemap[0];
}

_CRTIMP int * __cdecl
AFNAME(__mb_cur_max) (void)
{
        return AFRET(__mb_cur_max);
}


_CRTIMP unsigned int * __cdecl
AFNAME(_osver) (void)
{
        return AFRET(_osver);
}

_CRTIMP const unsigned short ** __cdecl
AFNAME(_pctype) (void)
{
        return AFRET(_pctype);
}

_CRTIMP const unsigned short ** __cdecl
AFNAME(_pwctype) (void)
{
        return AFRET(_pwctype);
}

_CRTIMP char **  __cdecl
AFNAME(_pgmptr) (void)
{
        return AFRET(_pgmptr);
}

_CRTIMP wchar_t ** __cdecl
AFNAME(_wpgmptr) (void)
{
        return AFRET(_wpgmptr);
}

_CRTIMP long * __cdecl
AFNAME(_timezone) (void)
{
        return AFRET(_timezone);
}

_CRTIMP char ** __cdecl
AFNAME(_tzname) (void)
{
        return &_tzname[0];
}

_CRTIMP unsigned int * __cdecl
AFNAME(_winmajor) (void)
{
        return AFRET(_winmajor);
}

_CRTIMP unsigned int * __cdecl
AFNAME(_winminor) (void)
{
        return AFRET(_winminor);
}

_CRTIMP unsigned int * __cdecl
AFNAME(_winver) (void)
{
        return AFRET(_winver);
}

#endif  /* _M_IX86 */

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\dllargv.c ===
/***
*dllargv.c - Dummy _setargv() routine for use with C Run-Time as a DLL (CRTDLL)
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This object goes into CRTDLL.LIB, which is linked with user programs
*       to use CRTDLL.DLL for C run-time library functions.  If the user
*       program links explicitly with SETARGV.OBJ, this object will not be
*       linked in, and the _setargv() that does get called with set the flag
*       that will enable wildcard expansion.  If SETARGV.OBJ is not linked
*       into the EXE, this object will get called by the CRT start-up stub
*       and the flag to enable wildcard expansion will not be set.
*
*Revision History:
*       10-19-92  SKS   Initial version
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       11-24-93  CFW   Wide argv.
*       03-27-01  PML   Now return an int (vs7#231220)
*
*******************************************************************************/

#ifndef _POSIX_

#ifdef  CRTDLL

#include <cruntime.h>
#include <internal.h>

/***
*_setargv - dummy version for CRTDLL.DLL model only
*
*Purpose:
*       This routine gets called by the C Run-Time start-up code in CRTEXE.C
*       which gets linked into an EXE file linked with CRTDLL.LIB.  It does
*       nothing, but if the user links the EXE with SETARGV.OBJ, this routine
*       will not get called but instead __setargv() will be called.  (In the
*       CRTDLL model, it will set the variable that is passed to _GetMainArgs
*       and enable wildcard expansion in the command line arguments.)
*
*Entry:
*
*Exit:
*       Always return 0 (full version in DLL code returns -1 on error)
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
int __cdecl _wsetargv ( void )
#else
int __cdecl _setargv ( void )
#endif
{
        return 0;
}

#endif  /* CRTDLL */

#endif  /* !_POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\dll_argv.c ===
/***
*dll_argv.c - __setargv() routine for use with C Run-Time as a DLL (CRTDLL)
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This object is part of the start-up code for EXE's linked with
*       CRTDLL.LIB/MSVCRT.LIB.  This object will be linked into the user
*       EXE if and only if the user explicitly links with SETARGV.OBJ.
*       The code in this object sets the flag that is passed to the
*       C Run-Time DLL to enable wildcard expansion of the argv[] vector.
*
*Revision History:
*       03-04-94  SKS   Initial version
*       03-27-01  PML   Now return an int (vs7#231220)
*
*******************************************************************************/

#ifndef _POSIX_

#ifdef  CRTDLL

#include <cruntime.h>
#include <internal.h>

/***
*__setargv - dummy version (for wildcard expansion) for CRTDLL.DLL model only
*
*Purpose:
*       If the EXE that is linked with CRTDLL.LIB is linked explicitly with
*       SETARGV.OBJ, the call to _setargv() in the C Run-Time start-up code
*       (above) will call this routine, instead of calling a dummy version of
*       _setargv() which will do nothing.  This will set to one the static
*       variable which is passed to __getmainargs(), thus enabling wildcard
*       expansion of the command line arguments.
*
*       In the statically-linked C Run-Time models, _setargv() and __setargv()
*       are the actual routines that do the work, but this code exists in
*       CRTDLL.DLL and so some tricks have to be played to make the same
*       SETARGV.OBJ work for EXE's linked with both LIBC.LIB and CRTDLL.LIB.
*
*Entry:
*       The static variable _dowildcard is zero (presumably).
*
*Exit:
*       The static variable _dowildcard is set to one, meaning that the
*       routine __getmainargs() in CRTDLL.DLL *will* do wildcard expansion on
*       the command line arguments.  (The default behavior is that it won't.)
*       Always return 0 (full version in DLL code returns -1 on error)
*
*Exceptions:
*
*******************************************************************************/

extern int _dowildcard; /* should be in <internal.h> */

#ifdef WPRFLAG
int __cdecl __wsetargv ( void )
#else
int __cdecl __setargv ( void )
#endif
{
        _dowildcard = 1;
        return 0;
}

#endif  /* CRTDLL */

#endif  /* !_POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\ti_inst.cpp ===
/***
*ti_inst.cxx - One instance of class typeinfo.
*
*	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module insures that an instance of class type_info
*	will be present in msvcrt.lib, providing access to type_info's
*	vftable when compiling MD.
*
*Revision History:
*
*	02/27/95  JWM   Module created
*
****/

#define _TICORE
#include <typeinfo.h>

type_info::type_info(const type_info& rhs)
{
}

type_info& type_info::operator=(const type_info& rhs)
{
	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\merr.c ===
/***
*merr.c - floating point exception handling
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*
*Revision History:
*	08-03-94  GJF	Created. Basically, this is a modified copy of the
*			old fpw32\tran\matherr.c.
*
*******************************************************************************/

#include <math.h>

/*
 * Define flag signifying the default _matherr routine is being used.
 */
int __defaultmatherr = 1;

/***
*int _matherr(struct _exception *pexcept) - handle math errors
*
*Purpose:
*   Permits the user customize fp error handling by redefining this function.
*
*   The default matherr does nothing and returns 0
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/
int _matherr(struct _exception *pexcept)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\wcrtexe.c ===
/***
*wcrtexe.c - Initialization for console EXE using CRT DLL, wchar_t version
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for console apps using wide
*       characters.  It calls the user's main routine wmain() after
*       performing C Run-Time Library initialization.
*
*Revision History:
*       11-23-93  CFW   Module created.
*       02-04-94  CFW   POSIX? NOT!
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE    /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "crtexe.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\wdll_av.c ===
/***
*wdll_av.c - __wsetargv() routine for use with C Run-Time as a DLL (CRTDLL)
*            (wchar_t version)
*
*	Copyright (c) 1999-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This object is part of the start-up code for EXE's linked with
*	CRTDLL.LIB/MSVCRT.LIB.  This object will be linked into the user
*	EXE if and only if the user explicitly links with WSETARGV.OBJ.
*	The code in this object sets the flag that is passed to the
*	C Run-Time DLL to enable wildcard expansion of the argv[] vector.
*
*Revision History:
*       08-27-99  PML   Module created.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "dll_argv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\wdllargv.c ===
/***
*wdllargv.c - Dummy _wsetargv() routine for use with C Run-Time as a DLL (CRTDLL)
*             (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This object goes into CRTDLL.LIB, which is linked with user programs
*	to use CRTDLL.DLL for C run-time library functions.  If the user
*	program links explicitly with WSETARGV.OBJ, this object will not be
*	linked in, and the _wsetargv() that does get called with set the flag
*	that will enable wildcard expansion.  If WSETARGV.OBJ is not linked
*	into the EXE, this object will get called by the CRT start-up stub
*	and the flag to enable wildcard expansion will not be set.
*
*Revision History:
*	11-24-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "dllargv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\wildcard.c ===
/***
*wildcard.c - define the CRT internal variable _dowildcard
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This variable is not public to users but is defined outside the
*	start-up code (CRTEXE.C) to reduce duplicate definitions.
*
*Revision History:
*	03-04-94  SKS	Initial version
*   04-30-01  BWT   Remove _NTSDK
*
*******************************************************************************/

#if !defined(_POSIX_) && defined(CRTDLL)

#include <internal.h>

int _dowildcard = 0;	/* should be in <internal.h> */

#endif /* !_NTSDK && CRTDLL && !_POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\wcrtexew.c ===
/***
*wcrtexew.c - Initialization for Windows EXE using CRT DLL, wchar_t version
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for Windows apps using wide
*       characters.  It calls the user's main routine wWinMain() after
*       performing C Run-Time Library initialization.
*
*Revision History:
*       ??-??-??  ???   Module created.
*       09-01-94  SKS   Module commented.
*
*******************************************************************************/

#ifdef  CRTDLL

#define _WINMAIN_
#include "wcrtexe.c"

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\xncommod.c ===
/***
*xncommode.c - set global file commit mode flag to nocommit
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global file commit mode flag to nocommit.  This is the default.
*
*       This is a special version for the DLL model.  This object goes into
*       MSVCRT.LIB (and therefore into the client EXE) and not into the
*       CRTL in a DLL (MSVCRTXX.DLL).  It is identical to ncommode.obj
*       except that the latter has a DLL export definition in the DLL model.
*
*Revision History:
*       07-11-90  SBM   Module created, based on asm version.
*       04-05-94  GJF   Added conditional so this definition doesn't make it
*                       into the msvcrt*.dll for Win32s.
*       05-16-95  SKS   This is a copy of ncommode.obj except for the
*                       DLL import semantics.
*       06-28-96  GJF   Removed DLL_FOR_WIN32S. Also, detab-ed.
*
*******************************************************************************/

#define SPECIAL_CRTEXE  /* turn off _CRTIMP for decl. of _commode */
#define _DLL            /* also necessary to turn off _CRTIMP */

#include <cruntime.h>
#include <internal.h>

/* set default file commit mode to nocommit */
int _commode = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\amd64\dllsupp.c ===
/***
*dllsupp.c - Definitions of public constants
*
*       Copyright (c) 1992-2000, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Provides definitions for public constants (absolutes) that are
*       'normally' defined in objects in the C library, but must be defined
*       here for clients of crtdll.dll & msvcrt*.dll.  These constants are:
*
*                           _fltused
*
*Revision History:
*       01-15-97  v-rogerl      Module created.
*
*******************************************************************************/

int _fltused = 0x9875;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\xtxtmode.c ===
/***
*xtxtmode.c - set global text mode flag
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global file mode to text.  This is the default.
*
*       This is a special version for the DLL model.  This object goes into
*       MSVCRT.LIB (and therefore into the client EXE) and not into the
*       CRTL in a DLL (MSVCRTXX.DLL).  It is identical to txtmode.obj
*       except that the latter has a DLL export definition in the DLL model.
*
*Revision History:
*       06-08-89  PHG   Module created, based on asm version.
*       04-04-90  GJF   Added #include <cruntime.h>. Also, fixed the copyright.
*       01-23-92  GJF   Added #include <stdlib.h> (contains decl of _fmode).
*       04-05-94  GJF   Added conditional so this definition doesn't make it
*                       into the msvcrt*.dll for Win32s.
*       05-15-95  SKS   This is a copy of txtmode.obj except for the
*                       DLL import semantics.
*       06-28-96  GJF   Removed DLL_FOR_WIN32S. Also, detab-ed.
*
*******************************************************************************/

#define SPECIAL_CRTEXE  /* turn off _CRTIMP for decl. of _fmode */

#include <cruntime.h>
#include <stdlib.h>

int _fmode = 0;                 /* set text mode */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\i386\dllsupp.asm ===
page	,132
	title	dllsupp - defines some public constants
;***
;dllsupp.asm - Definitions of public constants
;
;	Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Provides definitions for public constants (absolutes) that are
;	'normally' defined in objects in the C library, but must be defined
;	here for clients of crtdll.dll & msvcrt*.dll.  These constants are:
;
;			    _except_list
;			    _fltused
;			    _ldused
;
;Revision History:
;	01-23-92  GJF	Module created.
;
;*******************************************************************************

.xlist
include cruntime.inc
.list

; offset, with respect to FS, of pointer to currently active exception handler.
; referenced by compiler generated code for SEH and by _setjmp().

	public	_except_list
_except_list	equ	0

	public	_fltused
_fltused	equ	9876h

	public	_ldused
_ldused 	equ	9876h

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\dosmap.c ===
/***
*dosmap.c - Maps OS errors to errno values
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       _dosmaperr: Maps OS errors to errno values
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       06-16-89  PHG   Changed name to _dosmaperr
*       08-22-89  JCR   ERROR_INVALID_DRIVE (15) now maps to ENOENT not EXDEV
*       03-07-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed copyright. Also, cleaned up the
*                       formatting a bit.
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       04-26-91  SRW   Added ERROR_LOCK_VIOLATION translation to EACCES
*       08-15-91  GJF   Multi-thread support for Win32.
*       03-31-92  GJF   Added more error codes (Win32 only) and removed OS/2
*                       specific nomenclature.
*       07-29-92  GJF   Added ERROR_FILE_EXISTS to table for Win32. It gets
*                       mapped it to EEXIST.
*       09-14-92  SRW   Added ERROR_BAD_PATHNAME table for Win32. It gets
*                       mapped it to ENOENT.
*       10-02-92  GJF   Map ERROR_INVALID_PARAMETER to EINVAL (rather than
*                       EACCES). Added ERROR_NOT_LOCKED and mapped it to
*                       EACCES. Added ERROR_DIR_NOT_EMPTY and mapped it to
*                       ENOTEMPTY.
*       02-16-93  GJF   Changed for new _getptd().
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       01-06-94  GJF   Dumped obsolete Cruiser support, revised errentry
*                       struct definition and added mapping for infamous
*                       ERROR_NOT_ENOUGH_QUOTA (non-swappable memory pages)
*                       which might result from a CreateThread call.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       05-24-95  CFW   Map dupFNErr to EEXIST rather than EACCESS.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <errno.h>
#include <oscalls.h>
#include <stdlib.h>
#include <internal.h>
#include <mtdll.h>

/* This is the error table that defines the mapping between OS error
   codes and errno values */

struct errentry {
        unsigned long oscode;           /* OS return value */
        int errnocode;  /* System V error code */
};

static struct errentry errtable[] = {
        {  ERROR_INVALID_FUNCTION,       EINVAL    },  /* 1 */
        {  ERROR_FILE_NOT_FOUND,         ENOENT    },  /* 2 */
        {  ERROR_PATH_NOT_FOUND,         ENOENT    },  /* 3 */
        {  ERROR_TOO_MANY_OPEN_FILES,    EMFILE    },  /* 4 */
        {  ERROR_ACCESS_DENIED,          EACCES    },  /* 5 */
        {  ERROR_INVALID_HANDLE,         EBADF     },  /* 6 */
        {  ERROR_ARENA_TRASHED,          ENOMEM    },  /* 7 */
        {  ERROR_NOT_ENOUGH_MEMORY,      ENOMEM    },  /* 8 */
        {  ERROR_INVALID_BLOCK,          ENOMEM    },  /* 9 */
        {  ERROR_BAD_ENVIRONMENT,        E2BIG     },  /* 10 */
        {  ERROR_BAD_FORMAT,             ENOEXEC   },  /* 11 */
        {  ERROR_INVALID_ACCESS,         EINVAL    },  /* 12 */
        {  ERROR_INVALID_DATA,           EINVAL    },  /* 13 */
        {  ERROR_INVALID_DRIVE,          ENOENT    },  /* 15 */
        {  ERROR_CURRENT_DIRECTORY,      EACCES    },  /* 16 */
        {  ERROR_NOT_SAME_DEVICE,        EXDEV     },  /* 17 */
        {  ERROR_NO_MORE_FILES,          ENOENT    },  /* 18 */
        {  ERROR_LOCK_VIOLATION,         EACCES    },  /* 33 */
        {  ERROR_BAD_NETPATH,            ENOENT    },  /* 53 */
        {  ERROR_NETWORK_ACCESS_DENIED,  EACCES    },  /* 65 */
        {  ERROR_BAD_NET_NAME,           ENOENT    },  /* 67 */
        {  ERROR_FILE_EXISTS,            EEXIST    },  /* 80 */
        {  ERROR_CANNOT_MAKE,            EACCES    },  /* 82 */
        {  ERROR_FAIL_I24,               EACCES    },  /* 83 */
        {  ERROR_INVALID_PARAMETER,      EINVAL    },  /* 87 */
        {  ERROR_NO_PROC_SLOTS,          EAGAIN    },  /* 89 */
        {  ERROR_DRIVE_LOCKED,           EACCES    },  /* 108 */
        {  ERROR_BROKEN_PIPE,            EPIPE     },  /* 109 */
        {  ERROR_DISK_FULL,              ENOSPC    },  /* 112 */
        {  ERROR_INVALID_TARGET_HANDLE,  EBADF     },  /* 114 */
        {  ERROR_INVALID_HANDLE,         EINVAL    },  /* 124 */
        {  ERROR_WAIT_NO_CHILDREN,       ECHILD    },  /* 128 */
        {  ERROR_CHILD_NOT_COMPLETE,     ECHILD    },  /* 129 */
        {  ERROR_DIRECT_ACCESS_HANDLE,   EBADF     },  /* 130 */
        {  ERROR_NEGATIVE_SEEK,          EINVAL    },  /* 131 */
        {  ERROR_SEEK_ON_DEVICE,         EACCES    },  /* 132 */
        {  ERROR_DIR_NOT_EMPTY,          ENOTEMPTY },  /* 145 */
        {  ERROR_NOT_LOCKED,             EACCES    },  /* 158 */
        {  ERROR_BAD_PATHNAME,           ENOENT    },  /* 161 */
        {  ERROR_MAX_THRDS_REACHED,      EAGAIN    },  /* 164 */
        {  ERROR_LOCK_FAILED,            EACCES    },  /* 167 */
        {  ERROR_ALREADY_EXISTS,         EEXIST    },  /* 183 */
        {  ERROR_FILENAME_EXCED_RANGE,   ENOENT    },  /* 206 */
        {  ERROR_NESTING_NOT_ALLOWED,    EAGAIN    },  /* 215 */
        {  ERROR_NOT_ENOUGH_QUOTA,       ENOMEM    }    /* 1816 */
};

/* size of the table */
#define ERRTABLESIZE (sizeof(errtable)/sizeof(errtable[0]))

/* The following two constants must be the minimum and maximum
   values in the (contiguous) range of Exec Failure errors. */
#define MIN_EXEC_ERROR ERROR_INVALID_STARTING_CODESEG
#define MAX_EXEC_ERROR ERROR_INFLOOP_IN_RELOC_CHAIN

/* These are the low and high value in the range of errors that are
   access violations */
#define MIN_EACCES_RANGE ERROR_WRITE_PROTECT
#define MAX_EACCES_RANGE ERROR_SHARING_BUFFER_EXCEEDED


/***
*void _dosmaperr(oserrno) - Map function number
*
*Purpose:
*       This function takes an OS error number, and maps it to the
*       corresponding errno value (based on UNIX System V values). The
*       OS error number is stored in _doserrno (and the mapped value is
*       stored in errno)
*
*Entry:
*       ULONG oserrno = OS error value
*
*Exit:
*       sets _doserrno and errno.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _dosmaperr (
        unsigned long oserrno
        )
{
        int i;

        _doserrno = oserrno;        /* set _doserrno */

        /* check the table for the OS error code */
        for (i = 0; i < ERRTABLESIZE; ++i) {
                if (oserrno == errtable[i].oscode) {
                        errno = errtable[i].errnocode;
                        return;
                }
        }

        /* The error code wasn't in the table.  We check for a range of */
        /* EACCES errors or exec failure errors (ENOEXEC).  Otherwise   */
        /* EINVAL is returned.                                          */

        if (oserrno >= MIN_EACCES_RANGE && oserrno <= MAX_EACCES_RANGE)
                errno = EACCES;
        else if (oserrno >= MIN_EXEC_ERROR && oserrno <= MAX_EXEC_ERROR)
                errno = ENOEXEC;
        else
                errno = EINVAL;
}

#ifdef  _MT

/***
*int * _errno()                 - return pointer to thread's errno
*unsigned long * __doserrno()   - return pointer to thread's _doserrno
*
*Purpose:
*       _errno() returns a pointer to the _terrno field in the current
*       thread's _tiddata structure.
*       __doserrno returns a pointer to the _tdoserrno field in the current
*       thread's _tiddata structure
*
*Entry:
*       None.
*
*Exit:
*       See above.
*
*Exceptions:
*
*******************************************************************************/

int * __cdecl _errno(
        void
        )
{
        return ( &(_getptd()->_terrno) );
}

unsigned long * __cdecl __doserrno(
        void
        )
{
        return ( &(_getptd()->_tdoserrno) );
}

#endif  /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dllstuff\ia64\dllsupp.c ===
/***
*dllsupp.c - Definitions of public constants
*
*	Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Provides definitions for public constants (absolutes) that are
*	'normally' defined in objects in the C library, but must be defined
*	here for clients of crtdll.dll & msvcrt*.dll.  These constants are:
*
*			    _fltused
*
*Revision History:
*	01-15-97  v-rogerl	Module created.
*
*******************************************************************************/

int _fltused = 0x9875;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\drive.c ===
/***
*drive.c - get and change current drive
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has the _getdrive() and _chdrive() functions
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed copyright. Also, cleaned up
*                       the formatting a bit.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       05-10-91  GJF   Fixed off-by-1 error in Win32 version and updated the
*                       function descriptions a bit [_WIN32_].
*       05-19-92  GJF   Revised to use the 'current directory' environment
*                       variables of Win32/NT.
*       06-09-92  GJF   Use _putenv instead of Win32 API call. Also, defer
*                       adding env var until after the successful call to
*                       change the dir/drive.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-24-93  CFW   Rip out Cruiser.
*       11-24-93  CFW   No longer store current drive in CRT env strings.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       12-17-97  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <internal.h>
#include <msdos.h>
#include <errno.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>


/***
*int _getdrive() - get current drive (1=A:, 2=B:, etc.)
*
*Purpose:
*       Returns the current disk drive
*
*Entry:
*       No parameters.
*
*Exit:
*       returns 1 for A:, 2 for B:, 3 for C:, etc.
*       returns 0 if current drive cannot be determined.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getdrive (
        void
        )
{
        ULONG drivenum;
        UCHAR curdirstr[_MAX_PATH];

        drivenum = 0;
        if (GetCurrentDirectory(sizeof(curdirstr), curdirstr))
                if (curdirstr[1] == ':')
                        drivenum = toupper(curdirstr[0]) - 64;

        return drivenum;
}


/***
*int _chdrive(int drive) - set the current drive (1=A:, 2=B:, etc.)
*
*Purpose:
*       Allows the user to change the current disk drive
*
*Entry:
*       drive - the number of drive which should become the current drive
*
*Exit:
*       returns 0 if successful, else -1
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _chdrive (
        int drive
        )
{
        int retval;
        char  newdrive[3];

        if (drive < 1 || drive > 31) {
            errno = EACCES;
            _doserrno = ERROR_INVALID_DRIVE;
            return -1;
        }

#ifdef  _MT
        _mlock( _ENV_LOCK );
        __try {
#endif

        newdrive[0] = (char)('A' + (char)drive - (char)1);
        newdrive[1] = ':';
        newdrive[2] = '\0';

        /*
         * Set new drive. If current directory on new drive exists, it
         * will become the cwd. Otherwise defaults to root directory.
         */

        if ( SetCurrentDirectory((LPSTR)newdrive) )
            retval = 0;
        else {
            _dosmaperr(GetLastError());
            retval = -1;
        }

#ifdef  _MT
        }
        __finally {
            _munlock( _ENV_LOCK );
        }
#endif

        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\chdir.c ===
/***
*chdir.c - change directory
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has the _chdir() function - change current directory.
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed copyright and fixed compiler
*                       warnings. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       05-19-92  GJF   Revised to support the 'current directory' environment
*                       variables of Win32/NT.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-24-93  CFW   Rip out Cruiser.
*       11-24-93  CFW   No longer store current drive in CRT env strings.
*       12-01-93  CFW   Set OS drive letter variables.
*       12-07-93  CFW   Wide char enable.
*       01-25-95  GJF   New current directory can be a UNC path!
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <internal.h>
#include <direct.h>
#include <stdlib.h>
#include <tchar.h>

/***
*int _chdir(path) - change current directory
*
*Purpose:
*       Changes the current working directory to that given in path.
*
*Entry:
*       _TSCHAR *path - directory to change to
*
*Exit:
*       returns 0 if successful,
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tchdir (
        const _TSCHAR *path
        )
{
        _TSCHAR env_var[4];
        _TSCHAR abspath[MAX_PATH+1];

        if ( SetCurrentDirectory((LPTSTR)path) )
        {
            /*
             * If the new current directory path is NOT a UNC path, we must
             * update the OS environment variable specifying the current
             * directory for what is now current drive. To do this, get the
             * full current directory, build the environment variable string
             * and call SetEnvironmentVariable(). We need to do this because
             * SetCurrentDirectory does not (i.e., does not update the
             * current-directory-on-drive environment variables) and other
             * functions (fullpath, spawn, etc) need them to be set.
             *
             * If associated with a 'drive', the current directory should
             * have the form of the example below:
             *
             *  D:\nt\private\mytests
             *
             * so that the environment variable should be of the form:
             *
             *  =D:=D:\nt\private\mytests
             *
             */
            if ( GetCurrentDirectory(MAX_PATH+1, (LPTSTR)abspath) != 0 )
            {
                /*
                 * check if it is a UNC name, just return if is
                 */
                if ( ((abspath[0] == _T('\\')) || (abspath[0] == _T('/'))) &&
                     (abspath[0] == abspath[1]) )
                    return 0;

                env_var[0] = _T('=');
                env_var[1] = (_TSCHAR) _totupper((_TUCHAR)abspath[0]);
                env_var[2] = _T(':');
                env_var[3] = _T('\0');

                if ( SetEnvironmentVariable(env_var, abspath) )
                    return 0;
            }
        }

        _dosmaperr(GetLastError());
        return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\chmod.c ===
/***
*chmod.c - change file attributes
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _chmod() - change file attributes
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       11-10-89  JCR   Replaced DOS32QUERYFILEMODE with DOS32QUERYPATHINFO
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed copyright and fixed compiler
*                       warnings. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <tchar.h>

/***
*int _chmod(path, mode) - change file mode
*
*Purpose:
*       Changes file mode permission setting to that specified in
*       mode.  The only XENIX mode bit supported is user write.
*
*Entry:
*       _TSCHAR *path - file name
*       int mode - mode to change to
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if not successful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tchmod (
        const _TSCHAR *path,
        int mode
        )
{
        DWORD attr;

        attr = GetFileAttributes((LPTSTR)path);
        if (attr  == 0xffffffff) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return -1;
        }

        if (mode & _S_IWRITE) {
                /* clear read only bit */
                attr &= ~FILE_ATTRIBUTE_READONLY;
        }
        else {
                /* set read only bit */
                attr |= FILE_ATTRIBUTE_READONLY;
        }

        /* set new attribute */
        if (!SetFileAttributes((LPTSTR)path, attr)) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\access.c ===
/***
*access.c - access function
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has the _access() function which checks on file accessability.
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       11-10-89  JCR   Replaced DOS32QUERYFILEMODE with DOS32QUERYPATHINFO
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed copyright and fixed compiler
*                       warnings. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       04-09-91  PNT   Added _MAC_ conditional
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Rip out Cruiser, enable wide char.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <io.h>
#include <oscalls.h>
#include <stdlib.h>
#include <errno.h>
#include <msdos.h>
#include <internal.h>
#include <tchar.h>

/***
*int _access(path, amode) - check whether file can be accessed under mode
*
*Purpose:
*       Checks to see if the specified file exists and can be accessed
*       in the given mode.
*
*Entry:
*       _TSCHAR *path - pathname
*       int amode -     access mode
*                       (0 = exist only, 2 = write, 4 = read, 6 = read/write)
*
*Exit:
*       returns 0 if file has given mode
*       returns -1 and sets errno if file does not have given mode or
*       does not exist
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _taccess (
        const _TSCHAR *path,
        int amode
        )
{
        DWORD attr;

        attr = GetFileAttributes((LPTSTR)path);
        if (attr  == 0xffffffff) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return -1;
        }

        /* no error; see if returned premission settings OK */
        if ( (attr & FILE_ATTRIBUTE_READONLY) && (amode & 2) ) {
                /* no write permission on file, return error */
                errno = EACCES;
                _doserrno = E_access;
                return -1;
        }
        else
                /* file exists and has requested permission setting */
                return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\fullpath.c ===
/***
*fullpath.c -
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose: contains the function _fullpath which makes an absolute path out
*       of a relative path. i.e.  ..\pop\..\main.c => c:\src\main.c if the
*       current directory is c:\src\src
*
*Revision History:
*       12-21-87  WAJ   Initial version
*       01-08-88  WAJ   now treats / as an \
*       06-22-88  WAJ   now handles network paths  ie \\sl\users
*       01-31-89  SKS/JCR Renamed _canonic to _fullpath
*       04-03-89  WAJ   Now returns "d:\dir" for "."
*       05-09-89  SKS   Do not change the case of arguments
*       11-30-89  JCR   Preserve errno setting from _getdcwd() call on errors
*       03-07-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and fixed
*                       the copyright.
*       04-25-90  JCR   Fixed an incorrect errno setting
*       06-14-90  SBM   Fixed bugs in which case of user provided drive letter
*                       was not always preserved, and c:\foo\\bar did not
*                       generate an error
*       08-10-90  SBM   Compiles cleanly with -W3
*       08-28-90  SBM   Fixed bug in which UNC names were being rejected
*       09-27-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       11-30-92  KRS   Ported _MBCS code from 16-bit tree.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  SKS   Add check for drive validity
*       08-03-93  KRS   Change to use _ismbstrail instead of isdbcscode.
*       09-27-93  CFW   Avoid cast bug.
*       12-07-93  CFW   Wide char enable.
*       01-26-94  CFW   Remove unused isdbcscode function.
*       11-08-94  GJF   Revised to use GetFullPathName.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       03-28-96  GJF   Free malloc-ed buffer if GetFullPathName fails. 
*                       Detab-ed. Also, cleaned up the ill-formatted Mac
*                       version a bit and renamed isdbcscode to __isdbcscode.
*       07-01-96  GJF   Replaced defined(_WIN32) by !defined(_MAC).
*       12-15-98  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <direct.h>
#include <errno.h>
#include <stdlib.h>
#include <internal.h>
#include <tchar.h>
#include <windows.h>


/***
*_TSCHAR *_fullpath( _TSCHAR *buf, const _TSCHAR *path, maxlen );
*
*Purpose:
*
*       _fullpath - combines the current directory with path to form
*       an absolute path. i.e. _fullpath takes care of .\ and ..\
*       in the path.
*
*       The result is placed in buf. If the length of the result
*       is greater than maxlen NULL is returned, otherwise
*       the address of buf is returned.
*
*       If buf is NULL then a buffer is malloc'ed and maxlen is
*       ignored. If there are no errors then the address of this
*       buffer is returned.
*
*       If path specifies a drive, the curent directory of this
*       drive is combined with path. If the drive is not valid
*       and _fullpath needs the current directory of this drive
*       then NULL is returned.  If the current directory of this
*       non existant drive is not needed then a proper value is
*       returned.
*       For example:  path = "z:\\pop" does not need z:'s current
*       directory but path = "z:pop" does.
*
*
*
*Entry:
*       _TSCHAR *buf  - pointer to a buffer maintained by the user;
*       _TSCHAR *path - path to "add" to the current directory
*       int maxlen - length of the buffer pointed to by buf
*
*Exit:
*       Returns pointer to the buffer containing the absolute path
*       (same as buf if non-NULL; otherwise, malloc is
*       used to allocate a buffer)
*
*Exceptions:
*
*******************************************************************************/


_TSCHAR * __cdecl _tfullpath (
        _TSCHAR *UserBuf,
        const _TSCHAR *path,
        size_t maxlen
        )
{
        _TSCHAR *buf;
        _TSCHAR *pfname;
        unsigned long count;


        if ( !path || !*path )  /* no work to do */
            return( _tgetcwd( UserBuf, (int)maxlen ) );

        /* allocate buffer if necessary */

        if ( !UserBuf )
            if ( !(buf = malloc(_MAX_PATH * sizeof(_TSCHAR))) ) {
                errno = ENOMEM;
                return( NULL );
            }
            else
                maxlen = _MAX_PATH;
        else
            buf = UserBuf;

        count = GetFullPathName ( path,
                                  (int)maxlen,
                                  buf,
                                  &pfname );

        if ( count >= maxlen ) {
            if ( !UserBuf )
                free(buf);
            errno = ERANGE;
            return( NULL );
        }
        else if ( count == 0 ) {
            if ( !UserBuf )
                free(buf);
            _dosmaperr( GetLastError() );
            return( NULL );
        }

        return( buf );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\getcwd.c ===
/***
*getcwd.c - get current working directory
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*       contains functions _getcwd, _getdcwd and _getcdrv for getting the
*       current working directory.  getcwd gets the c.w.d. for the default disk
*       drive, whereas _getdcwd allows one to get the c.w.d. for whatever disk
*       drive is specified. _getcdrv gets the current drive.
*
*Revision History:
*       09-09-83  RKW   created
*       05-??-84  DCW   added conditional compilation to handle case of library
*                       where SS != DS (can't take address of a stack variable).
*       09-??-84  DCW   changed comparison of path length to maxlen to take the
*                       terminating null character into account.
*       11-28-84  DCW   changed to return errno values compatibly with the
*                       System 3 version.
*       05-19-86  SKS   adapted for OS/2
*       11-19-86  SKS   if pnbuf==NULL, maxlen is ignored;
*                       eliminated use of intermediate buffer "buf[]"; added
*                       entry point "_getdcwd()" which takes a drive number.
*       12-03-86  SKS   if pnbuf==NULL, maxlen is the minimum allocation size
*       02-05-87  BCM   fixed comparison in _getdcwd,
*                       (unsigned)(len+3) > (int)(maxlen), to handle maxlen < 0,
*                       since implicit cast to (unsigned) was occurring.
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       12-21-87  WAJ   Added _getcdrv()
*       06-22-88  WAJ   _getcdrv() is now made for all OS/2 libs
*       10-03-88  JCR   386: Change DOS calls to SYS calls
*       10-04-88  JCR   386: Removed 'far' keyword
*       10-10-88  GJF   Made API names match DOSCALLS.H
*       01-31-89  JCR   Remove _getcdrv(), which has been renamed _getdrive()
*       04-12-89  JCR   Use new OS/2 system calls
*       05-25-89  JCR   386 OS/2 calls use '_syscall' calling convention
*       11-27-89  JCR   Corrected ERRNO values
*       12-12-89  JCR   Fixed bogus syscall introduced in previous fix (oops)
*       03-07-90  GJF   Replaced _LOAD_DS by _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h>, removed
*                       some leftover 16-bit support and fixed the copyright.
*                       Also, cleaned up the formatting a bit.
*       07-24-90  SBM   Compiles cleanly with -W3 (removed unreferenced
*                       variable), removed redundant includes, removed
*                       '32' from API names
*       08-10-90  SBM   Compiles cleanly with -W3 with new build of compiler
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       08-21-91  JCR   Test DOSQUERYCURRENTDIR call for error return (bug fix)
*       04-23-92  GJF   Fixed initialization of DriveVar[].
*       04-28-92  GJF   Revised Win32 version.
*       12-09-92  PLM   Removed _getdcwd (Mac version only)
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*                       Change _ValidDrive to _validdrive
*       04-19-93  SKS   Move _validdrive to this module
*       04-26-93  SKS   Set _doserrno on invalid drive
*       05-26-93  SKS   Change _getdcwd to call GetFullPathName() instead of
*                       reading a current directory environment variable.
*       09-30-93  GJF   Removed #include <error.h> (thereby getting rid of a
*                       bunch of compiler warnings). Also, MTHREAD -> _MT.
*       11-01-93  CFW   Enable Unicode variant.
*       12-21-93  CFW   Fix API failure error handling.
*       01-04-94  CFW   Fix API failure error handling correctly.
*       08-11-94  GJF   Revised _validdrive() to use GetDriveType (suggestion
*                       from Richard Shupak).
*       08-18-94  GJF   Revised _validdrive() logic slightly per suggestion
*                       of Richard Shupak.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       12-17-97  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <mtdll.h>
#include <msdos.h>
#include <errno.h>
#include <malloc.h>
#include <oscalls.h>
#include <stdlib.h>
#include <internal.h>
#include <direct.h>
#include <tchar.h>


/***
*_TSCHAR *_getcwd(pnbuf, maxlen) - get current working directory of default drive
*
*Purpose:
*       _getcwd gets the current working directory for the user,
*       placing it in the buffer pointed to by pnbuf.  It returns
*       the length of the string put in the buffer.  If the length
*       of the string exceeds the length of the buffer, maxlen,
*       then NULL is returned.  If pnbuf = NULL, maxlen is ignored.
*       An entry point "_getdcwd()" is defined with takes the above
*       parameters, plus a drive number.  "_getcwd()" is implemented
*       as a call to "_getcwd()" with the default drive (0).
*
*       If pnbuf = NULL, maxlen is ignored, and a buffer is automatically
*       allocated using malloc() -- a pointer to which is returned by
*       _getcwd().
*
*       side effects: no global data is used or affected
*
*Entry:
*       _TSCHAR *pnbuf = pointer to a buffer maintained by the user;
*       int maxlen = length of the buffer pointed to by pnbuf;
*
*Exit:
*       Returns pointer to the buffer containing the c.w.d. name
*       (same as pnbuf if non-NULL; otherwise, malloc is
*       used to allocate a buffer)
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tgetcwd (
        _TSCHAR *pnbuf,
        int maxlen
        )
{
        _TSCHAR *retval;

#ifdef  _MT
        _mlock( _ENV_LOCK );
        __try {
#endif

#ifdef WPRFLAG
        retval = _wgetdcwd_lk(0, pnbuf, maxlen);
#else
        retval = _getdcwd_lk(0, pnbuf, maxlen);
#endif

#ifdef  _MT
        }
        __finally {
            _munlock( _ENV_LOCK );
        }
#endif

        return retval;
}


/***
*_TSCHAR *_getdcwd(drive, pnbuf, maxlen) - get c.w.d. for given drive
*
*Purpose:
*       _getdcwd gets the current working directory for the user,
*       placing it in the buffer pointed to by pnbuf.  It returns
*       the length of the string put in the buffer.  If the length
*       of the string exceeds the length of the buffer, maxlen,
*       then NULL is returned.  If pnbuf = NULL, maxlen is ignored,
*       and a buffer is automatically allocated using malloc() --
*       a pointer to which is returned by _getdcwd().
*
*       side effects: no global data is used or affected
*
*Entry:
*       int drive   - number of the drive being inquired about
*                     0 = default, 1 = 'a:', 2 = 'b:', etc.
*       _TSCHAR *pnbuf - pointer to a buffer maintained by the user;
*       int maxlen  - length of the buffer pointed to by pnbuf;
*
*Exit:
*       Returns pointer to the buffer containing the c.w.d. name
*       (same as pnbuf if non-NULL; otherwise, malloc is
*       used to allocate a buffer)
*
*Exceptions:
*
*******************************************************************************/


#ifdef  _MT

_TSCHAR * __cdecl _tgetdcwd (
        int drive,
        _TSCHAR *pnbuf,
        int maxlen
        )
{
        _TSCHAR *retval;

#ifdef  _MT
        _mlock( _ENV_LOCK );
        __try {
#endif

#ifdef  WPRFLAG
        retval = _wgetdcwd_lk(drive, pnbuf, maxlen);
#else
        retval = _getdcwd_lk(drive, pnbuf, maxlen);
#endif

#ifdef  _MT
        }
        _finally {
            _munlock( _ENV_LOCK );
        }
#endif

        return retval;
}

#ifdef  WPRFLAG
wchar_t * __cdecl _wgetdcwd_lk (
#else
char * __cdecl _getdcwd_lk (
#endif
        int drive,
        _TSCHAR *pnbuf,
        int maxlen
        )
#else

_TSCHAR * __cdecl _tgetdcwd (
        int drive,
        _TSCHAR *pnbuf,
        int maxlen
        )
#endif

{
        _TSCHAR *p;
        _TSCHAR dirbuf[_MAX_PATH];
        _TSCHAR drvstr[4];
        int len;
        _TSCHAR *pname; /* only used as argument to GetFullPathName */

        /*
         * GetCurrentDirectory only works for the default drive in Win32
         */
        if ( drive != 0 ) {
            /*
             * Not the default drive - make sure it's valid.
             */
            if ( !_validdrive(drive) ) {
                _doserrno = ERROR_INVALID_DRIVE;
                errno = EACCES;
                return NULL;
            }

            /*
             * Get the current directory string on that drive and its length
             */
            drvstr[0] = _T('A') - 1 + drive;
            drvstr[1] = _T(':');
            drvstr[2] = _T('.');
            drvstr[3] = _T('\0');
            len = GetFullPathName( drvstr, 
                                   sizeof(dirbuf) / sizeof(_TSCHAR), 
                                   dirbuf, 
                                   &pname );

        } else {

            /*
             * Get the current directory string and its length
             */
            len = GetCurrentDirectory( sizeof(dirbuf) / sizeof(_TSCHAR), 
                                       (LPTSTR)dirbuf );
        }

        /* API call failed, or buffer not large enough */
        if ( len == 0 || ++len > sizeof(dirbuf)/sizeof(_TSCHAR) )
            return NULL;

        /*
         * Set up the buffer.
         */
        if ( (p = pnbuf) == NULL ) {
            /*
             * Allocate a buffer for the user.
             */
            if ( (p = (_TSCHAR *)malloc(__max(len, maxlen) * sizeof(_TSCHAR)))
                 == NULL ) 
            {
                errno = ENOMEM;
                return NULL;
            }
        }
        else if ( len > maxlen ) {
            /*
             * Won't fit in the user-supplied buffer!
             */
            errno = ERANGE; /* Won't fit in user buffer */
            return NULL;
        }

        /*
         * Place the current directory string into the user buffer
         */

        return _tcscpy(p, dirbuf);
}

#ifndef WPRFLAG

/***
*int _validdrive( unsigned drive ) -
*
*Purpose: returns non zero if drive is a valid drive number.
*
*Entry: drive = 0 => default drive, 1 => a:, 2 => b: ...
*
*Exit:  0 => drive does not exist.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _validdrive (
    unsigned drive
    )
{
        unsigned retcode;
        char drvstr[4];

        if ( drive == 0 )
            return 1;

        drvstr[0] = 'A' + drive - 1;
        drvstr[1] = ':';
        drvstr[2] = '\\';
        drvstr[3] = '\0';

        if ( ((retcode = GetDriveType( drvstr )) == DRIVE_UNKNOWN) ||
             (retcode == DRIVE_NO_ROOT_DIR) )
            return 0;

        return 1;
}

#endif  /* WPRFLAG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\getpid.c ===
/***
*getpid.c - get current process id
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _getpid() - get current process id
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       10-27-89  JCR   Added new Dos32GetThreadInfo code (under DCR757 switch)
*       11-17-89  JCR   Enabled DOS32GETTHREADINFO code (DCR757)
*       03-07-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed copyright. Also, cleaned up the
*                       formatting a bit.
*       07-02-90  GJF   Removed pre-DCR757 stuff.
*       08-08-90  GJF   Changed API prefix from DOS32 to DOS
*       10-03-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-28-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Remove Cruiser support.
*       02-06-92  CFW   assert.h removed. (Mac version only)
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>

/***
*int _getpid() - get current process id
*
*Purpose:
*       Returns the current process id for the calling process.
*
*Entry:
*       None.
*
*Exit:
*       Returns the current process id.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getpid (
        void
        )
{
        return GetCurrentProcessId();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\mkdir.c ===
/***
*mkdir.c - make directory
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines function _mkdir() - make a directory
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed compiler warnings and fixed the
*                       copyright. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <direct.h>
#include <tchar.h>

/***
*int _mkdir(path) - make a directory
*
*Purpose:
*       creates a new directory with the specified name
*
*Entry:
*       _TSCHAR *path - name of new directory
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tmkdir (
        const _TSCHAR *path
        )
{
        ULONG dosretval;

        /* ask OS to create directory */

        if (!CreateDirectory((LPTSTR)path, (LPSECURITY_ATTRIBUTES)NULL))
            dosretval = GetLastError();
        else
            dosretval = 0;

        if (dosretval) {
            /* error occured -- map error code and return */
            _dosmaperr(dosretval);
            return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\rename.c ===
/***
*rename.c - rename file
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines rename() - rename a file
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed compiler warnings and fixed the
*                       copyright. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <io.h>
#include <tchar.h>

/***
*int rename(oldname, newname) - rename a file
*
*Purpose:
*       Renames a file to a new name -- no file with new name must
*       currently exist.
*
*Entry:
*       _TSCHAR *oldname -      name of file to rename
*       _TSCHAR *newname -      new name for file
*
*Exit:
*       returns 0 if successful
*       returns not 0 and sets errno if not successful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _trename (
        const _TSCHAR *oldname,
        const _TSCHAR *newname
        )
{
        ULONG dosretval;

        /* ask OS to move file */

        if (!MoveFile((LPTSTR)oldname, (LPTSTR)newname))
            dosretval = GetLastError();
        else
            dosretval = 0;

        if (dosretval) {
            /* error occured -- map error code and return */
            _dosmaperr(dosretval);
            return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\rmdir.c ===
/***
*rmdir.c - remove directory
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _rmdir() - remove a directory
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed compiler warnings and fixed the
*                       copyright. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <direct.h>
#include <tchar.h>

/***
*int _rmdir(path) - remove a directory
*
*Purpose:
*       deletes the directory speicifed by path.  The directory must
*       be empty, and it must not be the current working directory or
*       the root directory.
*
*Entry:
*       _TSCHAR *path - directory to remove
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _trmdir (
        const _TSCHAR *path
        )
{
        ULONG dosretval;

        /* ask OS to remove directory */

        if (!RemoveDirectory((LPTSTR)path))
            dosretval = GetLastError();
        else
            dosretval = 0;

        if (dosretval) {
            /* error occured -- map error code and return */
            _dosmaperr(dosretval);
            return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\mterrno.c ===
/***
*mterrno.c - provide function versions of errno & _doserrno for LIBC.LIB
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Sometimes users want to compile code (such as for use in a library)
*	for both single-thread and multi-thread applications.  Currently the
*	one major stumbling block to doing this is the fact that errno &
*	_doserrno are defined in different ways in LIBC.LIB and LIBCMT.LIB.
*	Code that should otherwise be usable with both LIBC.LIB and LIBCMT.LIB
*	but which accesses errno and/or _doserrno is not usable with both.
*	By providing the function versions of errno & _doserrno in LIBC.LIB,
*	users can compile their code for both LIBCMT.LIB and LIBC.LIB.
*	Note that this does not magically make single-thread code safe in a
*	multi-threaded environment, it merely makes it easier to use the
*	same code with LIBC.LIB and LIBCMT.LIB.
*
*Revision History:
*	03-26-94  SKS	Original version.
*
*******************************************************************************/

#ifndef _MT

/* Get the definitions of the function versions of errno/_doserrno */

#define _MT
#include <stdlib.h>
#undef _MT

/* undo the macros that convert the variable names to function calls */

#undef errno
#undef _doserrno

/* declare the variables - must match the definitions in <STDLIB.H> */

extern int errno;			/* XENIX style error number */
extern unsigned long _doserrno; 	/* OS system error value */


/***
*int * _errno() 		- return pointer to thread's errno
*unsigned long * __doserrno()	- return pointer to thread's _doserrno
*
*Purpose:
*	_errno() returns a pointer to the global variable errno
*	__doserrno returns a pointer to the global variable _doserrno
*
*Entry:
*	None.
*
*Exit:
*	See above.
*
*Exceptions:
*
*******************************************************************************/

int * __cdecl _errno(
	void
	)
{
	return & errno;
}

unsigned long * __cdecl __doserrno(
	void
	)
{
	return & _doserrno;
}

#endif	/* !_MT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\stat64.c ===
/***
*stat64.c - get file status
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _stat64() - get file status
*
*Revision History:
*       06-02-98  GJF   Created.
*       11-10-99  GB    Made changes so as to take care of DST.
*
*******************************************************************************/

#include <cruntime.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <ctype.h>
#include <msdos.h>
#include <oscalls.h>
#include <string.h>
#include <internal.h>
#include <stdlib.h>
#include <direct.h>
#include <mbstring.h>
#include <tchar.h>


#define ISSLASH(a)  ((a) == _T('\\') || (a) == _T('/'))


/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64


#ifdef  _UNICODE
#define __tdtoxmode __wdtoxmode
#else   /* ndef _UNICODE */
#define __tdtoxmode __dtoxmode
#endif  /* _UNICODE */


/*
 * Local routine which returns true if the argument is a UNC name
 * specifying the root name of a share, such as '\\server\share\'.
 */

static int IsRootUNCName(const _TSCHAR *path);

extern unsigned short __cdecl __tdtoxmode(int, const _TSCHAR *);


/***
*int _stat64(name, buf) - get file status info
*
*Purpose:
*       _stat64 obtains information about the file and stores it in the
*       structure pointed to by buf.
*
*       Note: Unlike _stat, _stat64 uses the UTC time values returned in
*       WIN32_FIND_DATA struct. This means the time values will always be
*       correct on NTFS, but may be wrong on FAT file systems for file times
*       whose DST state is different from the current DST state (this an NT
*       bug).
*
*Entry:
*       _TSCHAR *name -    pathname of given file
*       struct _stat *buffer - pointer to buffer to store info in
*
*Exit:
*       fills in structure pointed to by buffer
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tstat64 (
        REG1 const _TSCHAR *name,
        REG2 struct __stat64 *buf
        )
{
        _TSCHAR *  path;
        _TSCHAR    pathbuf[ _MAX_PATH ];
        int drive;          /* A: = 1, B: = 2, etc. */
        HANDLE findhandle;
        WIN32_FIND_DATA findbuf;

        /* Don't allow wildcards to be interpreted by system */

#ifdef  _UNICODE
        if (wcspbrk(name, L"?*")) {
#else
        if (_mbspbrk(name, "?*")) {
#endif
            errno = ENOENT;
            _doserrno = E_nofile;
            return(-1);
        }

        /* Try to get disk from name.  If none, get current disk.  */

        if (name[1] == _T(':')){
            if ( *name && !name[2] ){
                errno = ENOENT;             /* return an error if name is   */
                _doserrno = E_nofile;       /* just drive letter then colon */
                return( -1 );
            }
            drive = _totlower(*name) - _T('a') + 1;
        }
        else
            drive = _getdrive();

        /* Call Find Match File */
        findhandle = FindFirstFile((_TSCHAR *)name, &findbuf);
        if ( findhandle == INVALID_HANDLE_VALUE ) {
#ifdef  _UNICODE
            if ( !( wcspbrk(name, L"./\\") &&
#else
            if ( !( _mbspbrk(name, "./\\") &&
#endif
                 (path = _tfullpath( pathbuf, name, _MAX_PATH )) &&
                 /* root dir. ('C:\') or UNC root dir. ('\\server\share\') */
                 ((_tcslen( path ) == 3) || IsRootUNCName(path)) &&
                 (GetDriveType( path ) > 1) ) ) 
            {
                errno = ENOENT;
                _doserrno = E_nofile;
                return( -1 );
            }

            /*
             * Root directories (such as C:\ or \\server\share\ are fabricated.
             */

            findbuf.dwFileAttributes = A_D;
            findbuf.nFileSizeHigh = 0;
            findbuf.nFileSizeLow = 0;
            findbuf.cFileName[0] = _T('\0');

            buf->st_mtime = __loctotime64_t(1980,1,1,0,0,0, -1);
            buf->st_atime = buf->st_mtime;
            buf->st_ctime = buf->st_mtime;
        }
        else {
            SYSTEMTIME SystemTime;
            FILETIME LocalFTime;

            if ( !FileTimeToLocalFileTime( &findbuf.ftLastWriteTime, 
                                           &LocalFTime )            ||
                 !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
            {
                _dosmaperr( GetLastError() );
                FindClose( findhandle );
                return( -1 );
            }

            buf->st_mtime = __loctotime64_t( SystemTime.wYear,
                                           SystemTime.wMonth,
                                           SystemTime.wDay,
                                           SystemTime.wHour,
                                           SystemTime.wMinute,
                                           SystemTime.wSecond,
                                           -1 );

            if ( findbuf.ftLastAccessTime.dwLowDateTime ||
                 findbuf.ftLastAccessTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftLastAccessTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_atime = __loctotime64_t( SystemTime.wYear,
                                               SystemTime.wMonth,
                                               SystemTime.wDay,
                                               SystemTime.wHour,
                                               SystemTime.wMinute,
                                               SystemTime.wSecond,
                                               -1 );
            } else
                buf->st_atime = buf->st_mtime ;

            if ( findbuf.ftCreationTime.dwLowDateTime ||
                 findbuf.ftCreationTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftCreationTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_ctime = __loctotime64_t( SystemTime.wYear,
                                               SystemTime.wMonth,
                                               SystemTime.wDay,
                                               SystemTime.wHour,
                                               SystemTime.wMinute,
                                               SystemTime.wSecond,
                                               -1 );
            } else
                buf->st_ctime = buf->st_mtime ;

            FindClose(findhandle);
        }

        /* Fill in buf */

        buf->st_mode = __tdtoxmode(findbuf.dwFileAttributes, name);
        buf->st_nlink = 1;
        buf->st_size = ((__int64)(findbuf.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(findbuf.nFileSizeLow);

        /* now set the common fields */

        buf->st_uid = buf->st_gid = buf->st_ino = 0;

        buf->st_rdev = buf->st_dev = (_dev_t)(drive - 1); /* A=0, B=1, etc. */

        return(0);
}


/*
 * IsRootUNCName - returns TRUE if the argument is a UNC name specifying
 *      a root share.  That is, if it is of the form \\server\share\.
 *      This routine will also return true if the argument is of the
 *      form \\server\share (no trailing slash) but Win32 currently
 *      does not like that form.
 *
 *      Forward slashes ('/') may be used instead of backslashes ('\').
 */

static int IsRootUNCName(const _TSCHAR *path)
{
        /*
         * If a root UNC name, path will start with 2 (but not 3) slashes
         */

        if ( ( _tcslen ( path ) >= 5 ) /* minimum string is "//x/y" */
             && ISSLASH(path[0]) && ISSLASH(path[1]))
        {
            const _TSCHAR * p = path + 2 ;

            /*
             * find the slash between the server name and share name
             */
            while ( * ++ p )
                if ( ISSLASH(*p) )
                    break ;

            if ( *p && p[1] )
            {
                /*
                 * is there a further slash?
                 */
                while ( * ++ p )
                    if ( ISSLASH(*p) )
                        break ;

                /*
                 * just final slash (or no final slash)
                 */
                if ( !*p || !p[1])
                    return 1;
            }
        }

        return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\stati64.c ===
/***
*stati64.c - get file status
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _stati64() - get file status
*
*Revision History:
*	12-28-94  GJF	Module created.
*
*******************************************************************************/

#define _USE_INT64  1

#include "stat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\stat.c ===
/***
*stat.c - get file status
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _stat() - get file status
*
*Revision History:
*       03-??-84  RLB   Module created
*       05-??-84  DCW   Some cleanup and addition of register variables
*       05-17-86  SKS   Ported to OS/2
*       11-19-86  SKS   Better check for root directory; KANJI support
*       05-22-87  SKS   Cleaned up declarations and include files
*       11-18-87  SKS   Make _dtoxmode a static near procedure
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       12-21-87  WAJ   stat no longer uses chdir to figure out if it has been
*                       passed a root directory in the MTHREAD case.
*       01-05-88  WAJ   now uses _MAX_PATH (defined in stdlib.h)
*       06-22-88  SKS   find Hidden and System files, not just normal ones
*       06-22-88  SKS   Always use better algorithm to detect root dirs
*       06-29-88  WAJ   When looking for root dir makes sure it exists
*       09-28-88  JCR   Use new 386 dostypes.h structures
*       10-03-88  JCR   386: Change DOS calls to SYS calls
*       10-04-88  JCR   386: Removed 'far' keyword
*       10-10-88  GJF   Made API names match DOSCALLS.H
*       11-24-88  GJF   ".cmd" should be considered executable, not ".bat"
*       01-31-89  JCR   _canonic() is now _fullpath() and args reversed
*       04-12-89  JCR   New syscall interace
*       05-25-89  JCR   386 OS/2 calls use '_syscall' calling convention
*       03-07-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and
*                       removed some leftover 16-bit support. Also, fixed
*                       the copyright.
*       04-02-90  GJF   Made _ValidDrive() and _dtoxmode() _CALLTYPE1. Removed
*                       #include <dos.h>.
*       07-23-90  SBM   Compiles cleanly with -W3 (added/removed appropriate
*                       includes), removed '32' from API names
*       08-10-90  SBM   Compiles cleanly with -W3 with new build of compiler
*       09-03-90  SBM   Removed EXT macro
*       09-27-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       12-28-90  SRW   Added cast of void * to char * for Mips C Compiler
*       01-18-91  GJF   ANSI naming.
*       01-28-91  GJF   Fixed call to DOSFINDFIRST (removed last arg).
*       02-28-91  SRW   Fixed bug in _dtoxtime calls [_WIN32_]
*       03-05-91  MHL   Fixed stat to not use _ValidDrive for stat of root
*       05-19-92  SKS   .BAT is a valid "executable" extension for NT, as
*                       well as CMD.  Also, File Creation and File Last Access
*                       timestamps may be 0 on some file systems (e.g. FAT)
*                       in which case the File Last Write time should be used.
*       05-29-92  SKS   Files with SYSTEM bit set should NOT be marked
*                       READ-ONLY; these two attributes are independent.
*       08-18-92  SKS   Add a call to FileTimeToLocalFileTime
*                       as a temporary fix until _dtoxtime takes UTC
*       11-20-92  SKS   _doserrno must always be set whenever errno is.
*       11-30-92  KRS   Port _MBCS support from 16-bit tree.
*       03-29-93  GJF   Converted from using _dtoxtime() to __gmtotime_t().
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*                       Change _ValidDrive to _validdrive
*       04-07-93  GJF   Changed first arg type to const char *.
*       04-18-93  SKS   Move _validdrive to getcwd.c and make it static
*       07-21-93  GJF   Converted from using __gmtotime_t to __loctotime_t
*                       (amounts to reversing the change of 03-29-93).
*       12-16-93  CFW   Enable Unicode variant.
*       12-28-94  GJF   Added _stati64 and _wstati64.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       03-27-95  SKS   loctotime_t uses absolute years (not year-1900)!
*       09-25-95  GJF   __loctotime_t now takes a DST flag, pass -1 in this
*                       slot to indicate DST is undetermined.
*       11-29-95  SKS   Add support for calls such as stat("//server/share/")
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format.
*       05-17-99  PML   Remove all Macintosh support.
*       10-27-99  GB    Remove #inlcude <dostypes.h>
*
*******************************************************************************/

#include <cruntime.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <ctype.h>
#include <msdos.h>
#include <oscalls.h>
#include <string.h>
#include <internal.h>
#include <stdlib.h>
#include <direct.h>
#include <mbstring.h>
#include <tchar.h>


#define ISSLASH(a)  ((a) == _T('\\') || (a) == _T('/'))


#ifdef  _UNICODE
#define __tdtoxmode __wdtoxmode
#else   /* ndef _UNICODE */
#define __tdtoxmode __dtoxmode
#endif  /* _UNICODE */


/*
 * Local routine which returns true if the argument is a UNC name
 * specifying the root name of a share, such as '\\server\share\'.
 */

static int IsRootUNCName(const _TSCHAR *path);


/***
*unsigned __tdtoxmode(attr, name) -
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _USE_INT64

extern unsigned short __cdecl __tdtoxmode(int, const _TSCHAR *);

#else   /* ndef _USE_INT64 */

unsigned short __cdecl __tdtoxmode (
        int attr,
        const _TSCHAR *name
        )
{
        REG1 unsigned short uxmode;
        unsigned dosmode;
        REG2 const _TSCHAR *p;

        dosmode = attr & 0xff;
        if ((p = name)[1] == _T(':'))
            p += 2;

        /* check to see if this is a directory - note we must make a special
        * check for the root, which DOS thinks is not a directory
        */

        uxmode = (unsigned short)
                 (((ISSLASH(*p) && !p[1]) || (dosmode & A_D) || !*p)
                 ? _S_IFDIR|_S_IEXEC : _S_IFREG);

        /* If attribute byte does not have read-only bit, it is read-write */

        uxmode |= (dosmode & A_RO) ? _S_IREAD : (_S_IREAD|_S_IWRITE);

        /* see if file appears to be executable - check extension of name */

        if (p = _tcsrchr(name, _T('.'))) {
            if ( !_tcsicmp(p, _T(".exe")) ||
                 !_tcsicmp(p, _T(".cmd")) ||
                 !_tcsicmp(p, _T(".bat")) ||
                 !_tcsicmp(p, _T(".com")) )
                uxmode |= _S_IEXEC;
        }

        /* propagate user read/write/execute bits to group/other fields */

        uxmode |= (uxmode & 0700) >> 3;
        uxmode |= (uxmode & 0700) >> 6;

        return(uxmode);
}

#endif  /* _USE_INT64 */

/***
*int _stat(name, buf) - get file status info
*
*Purpose:
*       _stat obtains information about the file and stores it in the 
*       structure pointed to by buf.
*
*       Note: We cannot directly use the file time stamps returned in the
*       WIN32_FIND_DATA structure. The values are supposedly in system time
*       and system time is ambiguously defined (it is UTC for Windows NT, local
*       time for Win32S and probably local time for Win32C). Therefore, these
*       values must be converted to local time before than can be used.
*
*Entry:
*       _TSCHAR *name -    pathname of given file
*       struct _stat *buffer - pointer to buffer to store info in
*
*Exit:
*       fills in structure pointed to by buffer
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _USE_INT64

int __cdecl _tstati64 (
        REG1 const _TSCHAR *name,
        REG2 struct _stati64 *buf
        )

#else   /* ndef _USE_INT64 */

int __cdecl _tstat (
        REG1 const _TSCHAR *name,
        REG2 struct _stat *buf
        )

#endif  /* _USE_INT64 */

{
        _TSCHAR *  path;
        _TSCHAR    pathbuf[ _MAX_PATH ];
        int drive;          /* A: = 1, B: = 2, etc. */
        HANDLE findhandle;
        WIN32_FIND_DATA findbuf;

        /* Don't allow wildcards to be interpreted by system */

#ifdef  _UNICODE
        if (wcspbrk(name, L"?*")) {
#else
        if (_mbspbrk(name, "?*")) {
#endif
            errno = ENOENT;
            _doserrno = E_nofile;
            return(-1);
        }

        /* Try to get disk from name.  If none, get current disk.  */

        if (name[1] == _T(':')){
            if ( *name && !name[2] ){
                errno = ENOENT;             /* return an error if name is   */
                _doserrno = E_nofile;       /* just drive letter then colon */
                return( -1 );
            }
            drive = _totlower(*name) - _T('a') + 1;
        }
        else
            drive = _getdrive();

        /* Call Find Match File */
        findhandle = FindFirstFile((_TSCHAR *)name, &findbuf);
        if ( findhandle == INVALID_HANDLE_VALUE ) {
#ifdef  _UNICODE
            if ( !( wcspbrk(name, L"./\\") &&
#else
            if ( !( _mbspbrk(name, "./\\") &&
#endif
                 (path = _tfullpath( pathbuf, name, _MAX_PATH )) &&
                 /* root dir. ('C:\') or UNC root dir. ('\\server\share\') */
                 ((_tcslen( path ) == 3) || IsRootUNCName(path)) &&
                 (GetDriveType( path ) > 1) ) ) 
            {
                errno = ENOENT;
                _doserrno = E_nofile;
                return( -1 );
            }

            /*
             * Root directories (such as C:\ or \\server\share\ are fabricated.
             */

            findbuf.dwFileAttributes = A_D;
            findbuf.nFileSizeHigh = 0;
            findbuf.nFileSizeLow = 0;
            findbuf.cFileName[0] = _T('\0');

            buf->st_mtime = __loctotime_t(1980,1,1,0,0,0, -1);
            buf->st_atime = buf->st_mtime;
            buf->st_ctime = buf->st_mtime;
        }
        else {
            SYSTEMTIME SystemTime;
            FILETIME LocalFTime;

            if ( !FileTimeToLocalFileTime( &findbuf.ftLastWriteTime, 
                                           &LocalFTime )            ||
                 !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
            {
                _dosmaperr( GetLastError() );
                FindClose( findhandle );
                return( -1 );
            }

            buf->st_mtime = __loctotime_t( SystemTime.wYear,
                                           SystemTime.wMonth,
                                           SystemTime.wDay,
                                           SystemTime.wHour,
                                           SystemTime.wMinute,
                                           SystemTime.wSecond,
                                           -1 );

            if ( findbuf.ftLastAccessTime.dwLowDateTime ||
                 findbuf.ftLastAccessTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftLastAccessTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_atime = __loctotime_t( SystemTime.wYear,
                                               SystemTime.wMonth,
                                               SystemTime.wDay,
                                               SystemTime.wHour,
                                               SystemTime.wMinute,
                                               SystemTime.wSecond,
                                               -1 );
            } else
                buf->st_atime = buf->st_mtime ;

            if ( findbuf.ftCreationTime.dwLowDateTime ||
                 findbuf.ftCreationTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftCreationTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_ctime = __loctotime_t( SystemTime.wYear,
                                               SystemTime.wMonth,
                                               SystemTime.wDay,
                                               SystemTime.wHour,
                                               SystemTime.wMinute,
                                               SystemTime.wSecond,
                                               -1 );
            } else
                buf->st_ctime = buf->st_mtime ;

            FindClose(findhandle);
        }

        /* Fill in buf */

        buf->st_mode = __tdtoxmode(findbuf.dwFileAttributes, name);
        buf->st_nlink = 1;

#ifdef  _USE_INT64
        buf->st_size = ((__int64)(findbuf.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(findbuf.nFileSizeLow);
#else   /* ndef _USE_INT64 */
        buf->st_size = findbuf.nFileSizeLow;
#endif  /* _USE_INT64 */

        /* now set the common fields */

        buf->st_uid = buf->st_gid = buf->st_ino = 0;

        buf->st_rdev = buf->st_dev = (_dev_t)(drive - 1); /* A=0, B=1, etc. */

        return(0);
}


/*
 * IsRootUNCName - returns TRUE if the argument is a UNC name specifying
 *      a root share.  That is, if it is of the form \\server\share\.
 *      This routine will also return true if the argument is of the
 *      form \\server\share (no trailing slash) but Win32 currently
 *      does not like that form.
 *
 *      Forward slashes ('/') may be used instead of backslashes ('\').
 */

static int IsRootUNCName(const _TSCHAR *path)
{
        /*
         * If a root UNC name, path will start with 2 (but not 3) slashes
         */

        if ( ( _tcslen ( path ) >= 5 ) /* minimum string is "//x/y" */
             && ISSLASH(path[0]) && ISSLASH(path[1]))
        {
            const _TSCHAR * p = path + 2 ;

            /*
             * find the slash between the server name and share name
             */
            while ( * ++ p )
                if ( ISSLASH(*p) )
                    break ;

            if ( *p && p[1] )
            {
                /*
                 * is there a further slash?
                 */
                while ( * ++ p )
                    if ( ISSLASH(*p) )
                        break ;

                /*
                 * just final slash (or no final slash)
                 */
                if ( !*p || !p[1])
                    return 1;
            }
        }

        return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\wchdir.c ===
/***
*wchdir.c - change directory (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file has the _wchdir() function - change current directory.
*
*Revision History:
*	12-08-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "chdir.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\waccess.c ===
/***
*waccess.c - access function (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file has the _waccess() function which checks on file accessability.
*
*Revision History:
*	10-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "access.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\wchmod.c ===
/***
*wchmod.c - change file attributes (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _wchmod() - change file attributes
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "chmod.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\wgetcwd.c ===
/***
*wgetcwd.c - get current working directory (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*	contains functions _getcwd, _getdcwd and _getcdrv for getting the
*	current working directory.  getcwd gets the c.w.d. for the default disk
*	drive, whereas _getdcwd allows one to get the c.w.d. for whatever disk
*	drive is specified. _getcdrv gets the current drive.
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "getcwd.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\unlink.c ===
/***
*unlink.c - unlink a file
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines unlink() - unlink a file
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed compiler warnings and fixed the
*                       copyright. Also, cleaned up the formatting a bit.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       04-10-91  PNT   Added _MAC_ conditional
*       03-16-92  PLM   MAC verison ccreated from OS/2 version
*       04-10-91  PNT   Added _MAC_ conditional (Mac version only)
*       11-02-92  PLM   Added directory test and extracted code for remove() (Mac version only)
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <io.h>
#include <tchar.h>

/***
*int _unlink(path) - unlink(delete) the given file
*
*Purpose:
*       This version deletes the given file because there is no
*       distinction between a linked file and non-linked file.
*
*       NOTE: remove() is an alternative entry point to the _unlink()
*       routine* interface is identical.
*
*Entry:
*       _TSCHAR *path - file to unlink/delete
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tremove (
        const _TSCHAR *path
        )
{
        ULONG dosretval;

        if (!DeleteFile((LPTSTR)path))
            dosretval = GetLastError();
        else
            dosretval = 0;

        if (dosretval) {
            /* error occured -- map error code and return */
            _dosmaperr(dosretval);
            return -1;
        }

        return 0;
}

int __cdecl _tunlink (
        const _TSCHAR *path
        )
{
        /* remove is synonym for unlink */
        return _tremove(path);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\wmkdir.c ===
/***
*wmkdir.c - make directory (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines function _wmkdir() - make a directory
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "mkdir.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\wfullpat.c ===
/***
*wfullpath.c - (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose: contains the function _wfullpath which makes an absolute path out
*	of a relative path. i.e.  ..\pop\..\main.c => c:\src\main.c if the
*	current directory is c:\src\src
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "fullpath.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\wrmdir.c ===
/***
*wrmdir.c - remove directory (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wrmdir() - remove a directory
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "rmdir.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\wstat.c ===
/***
*wstat.c - get file status (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wstat() - get file status
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "stat.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\wrename.c ===
/***
*wrename.c - rename file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines wrename() - rename a file
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "rename.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\wstat64.c ===
/***
*wstat64.c - get file status (wchar_t version)
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wstat64() - get file status
*
*Revision History:
*       06-02-98  GJF   Created.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE    /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE     /* NT flag */
#define UNICODE 1
#endif

#undef  _MBCS       /* UNICODE not _MBCS */

#include "stat64.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\wstati64.c ===
/***
*wstati64.c - get file status (wchar_t version)
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wstati64() - get file status
*
*Revision History:
*	12-28-94  GJF	Module created.
*
*******************************************************************************/

#define WPRFLAG     1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE    1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE     1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#define _USE_INT64  1

#include "stat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\dos\wunlink.c ===
/***
*wunlink.c - unlink a file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wunlink() - unlink a file
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "unlink.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\csysex.cpp ===
/***
*csysex.cpp - Implementation CException class for NT kernel mode
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Implementation of kernel mode default exception
*
*       Entry points:
*           CException
*
*Revision History:
*       04-21-95  DAK   Module created
*
****/

#if defined(_NTSUBSET_)

#include <csysex.hxx>

class type_info {
    public: virtual ~type_info() { }
};

type_info Dummy;

//
//  Convert system exceptions to a C++ exception.
//
extern "C" void _cdecl SystemExceptionTranslator( unsigned int uiWhat,
                                       struct _EXCEPTION_POINTERS * pexcept )
{
    throw CException( uiWhat ) ;
}

#endif     // _NT_SUBSET_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\ehvcccvb.cpp ===
/***
*ehvcccvb.cpp - EH copy-ctor iterator helper function for class w/ virtual bases
*
*       Copyright (c) 2000-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*
*       Must be compiled using "-d1Binl" to be able to specify __thiscall
*       at the user level
*
*Revision History:
*       04-27-00  JJS   File created
*
****/

#include <cruntime.h>
#include <eh.h>

#if defined (_M_IX86)
#define CALLTYPE __thiscall
#else
#define CALLTYPE __stdcall
#endif

#ifdef _WIN32

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
);


void __stdcall __ehvec_copy_ctor_vb(
    void*       dst,                // Pointer to destination array
    void*       src,                // Pointer to source array
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCopyCtor)(void*,void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;      // Count of elements constructed
    int success = 0;

    __try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
#pragma warning(disable:4191)

            (*(void(CALLTYPE*)(void*,void*,int))pCopyCtor)( dst, src, 1 );

#pragma warning(default:4191)

            dst = (char*)dst + size;
            src = (char*)src + size;
        }
        success = 1;
    }
    __finally
    {
        if (!success)
            __ArrayUnwind(dst, size, i, pDtor);
    }
}

#else

void __stdcall __ehvec_copy_ctor_vb(
    void*       dst,                // Pointer to destination array
    void*       src,                // Pointer to source array
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCopyCtor)(void*, void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;  // Count of elements constructed

    try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*pCopyCtor)( dst, src );
            dst = (char*)dst + size;
            src = (char*)src + size;
        }
    }
    catch(...)
    {
        // If a constructor throws, unwind the portion of the array thus
        // far constructed.
        for( i--;  i >= 0;  i-- )
        {
            dst = (char*)dst - size;
            try {
#pragma warning(disable:4191)

            (*(void(CALLTYPE*)(void*,void*,int))pCopyCtor)( dst, src, 1 );

#pragma warning(default:4191)
            } 
            catch(...) {
                // If the destructor threw during the unwind, quit
                terminate();
            }
        }

        // Propagate the exception to surrounding frames
        throw;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\ehvccctr.cpp ===
/***
*ehvccctr.cpp - EH-aware version of copy constructor iterator helper function
*
*       Copyright (c) 2000-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*
*       Must be compiled using "-d1Binl" to be able to specify __thiscall
*       at the user level
*
*Revision History:
*       04-27-00  JJS   File created
*
****/

#include <cruntime.h>
#include <eh.h>

#if defined (_M_IX86)
#define CALLTYPE __thiscall
#else
#define CALLTYPE __stdcall
#endif

#ifdef _WIN32

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
);


void __stdcall __ehvec_copy_ctor(
    void*       dst,                // Pointer to destination array
    void*       src,                // Pointer to source array
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCopyCtor)(void*,void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;      // Count of elements constructed
    int success = 0;

    __try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*pCopyCtor)( dst, src );
            dst = (char*)dst + size;
            src = (char*)src + size;
        }
        success = 1;
    }
    __finally
    {
        if (!success)
            __ArrayUnwind(dst, size, i, pDtor);
    }
}

#else

void __stdcall __ehvec_copy_ctor(
    void*       dst,                // Pointer to destination array
    void*       src,                // Pointer to source array
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCopyCtor)(void*, void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;  // Count of elements constructed

    try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*pCopyCtor)( dst, src );
            dst = (char*)dst + size;
            src = (char*)src + size;
        }
    }
    catch(...)
    {
        // If a constructor throws, unwind the portion of the array thus
        // far constructed.
        for( i--;  i >= 0;  i-- )
        {
            dst = (char*)dst - size;
            try {
                (*pDtor)(dst);
            } 
            catch(...) {
                // If the destructor threw during the unwind, quit
                terminate();
            }
        }

        // Propagate the exception to surrounding frames
        throw;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\ehvecdtr.cpp ===
/***
*ehvecdtr.cxx - EH-aware version of destructor iterator helper function
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*       
*       Must be compiled using "-d1Binl" to be able to specify __thiscall
*       at the user level
*
*Revision History:
*       10-11-93  JDR   Module created
*       05-09-94  BES   Module adapted for CRT source conventions
*       05-13-94  SKS   Remove _CRTIMP modifier
*       10-10-94  CFW   Fix EH/SEH exception handling.
*       10-17-94  BWT   Disable code for PPC.
*       11-09-94  CFW   Back out 10-10-94 change.
*       02-08-95  JWM   Mac merge.
*       04-14-95  JWM   Re-fix EH/SEH exception handling.
*       04-17-95  JWM   Restore non-WIN32 behavior.
*       04-27-95  JWM   EH_ABORT_FRAME_UNWIND_PART now #ifdef ALLOW_UNWIND_ABORT.
*       05-17-99  PML   Remove all Macintosh support.
*       05-20-99  PML   Turn off __thiscall for IA64.
*       07-12-99  RDL   Image relative fixes under CC_P7_SOFT25.
*       03-15-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*
****/

#ifdef _WIN32
#if defined(_NTSUBSET_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>       // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
#include <ex.h>             // ExRaiseException
}
#endif
#endif

#include <cruntime.h>
#include <ehdata.h>
#include <eh.h>

#if defined (_M_IX86)
#define CALLTYPE __thiscall
#else
#define CALLTYPE __stdcall
#endif

#ifdef _WIN32

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
);


void __stdcall __ehvec_dtor(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
){
    int success = 0;

    // Advance pointer past end of array
    ptr = (char*)ptr + size*count;

    __try
    {
        // Destruct elements
        while ( --count >= 0 )
        {
            ptr = (char*)ptr - size;
            (*pDtor)(ptr);
        }
        success = 1;
    }
    __finally
    {
        if (!success)
            __ArrayUnwind(ptr, size, count, pDtor);
    }
}

static int ArrayUnwindFilter(EXCEPTION_POINTERS* pExPtrs)
{
    EHExceptionRecord *pExcept = (EHExceptionRecord*)pExPtrs->ExceptionRecord;

    switch(PER_CODE(pExcept))
    {
        case EH_EXCEPTION_NUMBER:
            terminate();
#ifdef ALLOW_UNWIND_ABORT
        case EH_ABORT_FRAME_UNWIND_PART:
            return EXCEPTION_EXECUTE_HANDLER;
#endif
        default:
            return EXCEPTION_CONTINUE_SEARCH;
    }
}

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
){
    // 'unwind' rest of array

    __try
    {
        while ( --count >= 0 )
        {
            ptr = (char*) ptr - size;
            (*pDtor)(ptr);
        }
    }
    __except( ArrayUnwindFilter(exception_info()) )
    {
    }
}

#else

void __stdcall __ehvec_dtor(
    void*       ptr,                // Pointer to array to destruct
    unsigned    size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
){
    // Advance pointer past end of array
    ptr = (char*)ptr + size*count;

    try
    {
        // Destruct elements
        while   ( --count >= 0 )
        {
            ptr = (char*)ptr - size;
            (*pDtor)(ptr);
        }
    }
    catch(...)
    {
        // If a destructor throws an exception, unwind the rest of this
        // array
        while ( --count >= 0 )
        {
            ptr = (char*) ptr - size;
            try {
                (*pDtor)(ptr);
            }
            catch(...)  {
                // If any destructor throws during unwind, terminate
                terminate();
            }
        }

        // After array is unwound, rethrow the exception so a user's handler
        // can handle it.
        throw;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\ehveccvb.cpp ===
/***
*ehveccvb.cpp - EH c-tor iterator helper function for class w/ virtual bases
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       EH-aware version of constructor iterator helper function for class
*       with virtual bases
*       
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*       
*       Must be compiled using "-d1Binl" to be able to specify __thiscall
*       at the user level
*
*Revision History:
*       10-11-93  JDR   Module created
*       05-09-94  BES   Module adapted for CRT source conventions
*       05-13-94  SKS   Remove _CRTIMP modifier
*       10-10-94  CFW   Fix EH/SEH exception handling.
*       10-17-94  BWT   Disable code for PPC.
*       11-09-94  CFW   Back out 10-10-94 change.
*       02-08-95  JWM   Mac merge.
*       04-14-95  JWM   Re-fix EH/SEH exception handling.
*       04-17-95  JWM   Restore non-WIN32 behavior.
*       06-22-95  JWM   Remove bogus throw from __ehvec_ctor_vb()..
*       05-17-99  PML   Remove all Macintosh support.
*       05-20-99  PML   Turn off __thiscall for IA64.
*       07-12-99  RDL   Image relative fixes under CC_P7_SOFT25.
*       03-15-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*
****/

#include <cruntime.h>
#include <eh.h>

#if defined (_M_IX86)
#define CALLTYPE __thiscall
#else
#define CALLTYPE __stdcall
#endif

#ifdef _WIN32

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
);


void __stdcall __ehvec_ctor_vb(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCtor)(void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;  // Count of elements constructed
    int success = 0;

    __try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {

#pragma warning(disable:4191)

            (*(void(CALLTYPE*)(void*,int))pCtor)( ptr, 1 );

#pragma warning(default:4191)

            ptr = (char*)ptr + size;
        }
        success = 1;
    }
    __finally
    {
        if (!success)
            __ArrayUnwind(ptr, size, i, pDtor);
    }
}

#else

void __stdcall __ehvec_ctor_vb(
    void*       ptr,                // Pointer to array to destruct
    unsigned    size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCtor)(void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;  // Count of elements constructed

    try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*(void(CALLTYPE*)(void*,int))pCtor)( ptr, 1 );
            ptr = (char*)ptr + size;
        }
    }
    catch(...)
    {
        // If a constructor throws, unwind the portion of the array thus
        // far constructed.
        for( i--;  i >= 0;  i-- )
        {
            ptr = (char*)ptr - size;
            try {
                (*pDtor)(ptr);
            } 
            catch(...) {
                // If the destructor threw during the unwind, quit
                terminate();
            }
        }

        // Propagate the exception to surrounding frames
        throw;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\framex.cpp ===
/***
*frame.cxx - The frame handler and everything associated with it.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The frame handler and everything associated with it.
*
*       Entry points:
*       _CxxFrameHandler   - the frame handler.
*
*       Open issues:
*         Handling re-throw from dynamicly nested scope.
*         Fault-tolerance (checking for data structure validity).
*
*Revision History:
*       05-20-93  BS    Module created
*       03-03-94  TL    Added Mips specific code
*       06-19-94  AD    Added Alpha specific code (Al Dosser)
*       10-17-94  BWT   Disable code for PPC.
*       11-23-94  JWM   Removed obsolete 'hash' check in TypeMatch().
*       11-29-94  JWM   AdjustPointer() now adds in pdisp, not vdisp.
*       01-13-95  JWM   Added _NLG_Destination struct; dwCode set for catch
*                       blocks & local destructors.
*       02-09-95  JWM   Mac merge.
*       02-10-95  JWM   UnhandledExceptionFilter() now called if exception
*                       raised during stack unwind.
*       03-22-95  PML   Add const for read-only compiler-gen'd structs
*       04-14-95  JWM   Re-fix EH/SEH exception handling.
*       04-17-95  JWM   FrameUnwindFilter() must be #ifdef _WIN32.
*       04-21-95  JWM   _NLG_Destination moved to exsup3.asm (_M_X86 only).
*       04-21-95  TGL   Added Mips fixes.
*       04-27-95  JWM   EH_ABORT_FRAME_UNWIND_PART now #ifdef 
*                       ALLOW_UNWIND_ABORT.
*       05-19-95  DAK   Don't initialize the kernel handler
*       06-07-95  JWM   Various NLG additions.
*       06-14-95  JWM   Unneeded LastError calls removed.
*       06-19-95  JWM   NLG no longer uses per-thread data (X86 only).
*       09-26-95  AMP   PowerMac avoids re-throws to same catch clause
*       08-06-95  JWM   Typo fixed (Orion #6509); Alpha-specific.
*       04-18-97  JWM   In __InternalCxxFrameHandler(), 'recursive' changed to
*                       BOOLEAN.
*       06-01-97  TGL   Added P7 specific code
*       08-22-97  TGL   More P7 fixes
*       11-14-98  JWM   Merge with P7 sources.
*       02-11-99  TGL   EH: correct catch in exe calling dll.
*       05-17-99  PML   Remove all Macintosh support.
*       07-12-99  RDL   Image relative fixes under CC_P7_SOFT25.
*       10-17-99  PML   Update EH state before each unwind action, instead of
*                       once at end (vs7#5419)
*       10-19-99  TGL   More P7/Win64 fixes
*       10-22-99  PML   Add EHTRACE support
*       12-10-99  GB    Add Uncaught exception Support by adding a new function
*                       __uncaught_exception();
*       02-15-99  PML   Can't put __try/__finally around call to
*                       _UnwindNestedFrames (vs7#79460)
*       03-03-00  GB    made __DestructExceptionObject export from dll.
*       03-21-00  KBF   Check for C++ exception in __CxxExceptionFilter
*       03-22-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*       03-28-00  GB    Check for no buildobj in __CxxExceptionFilter.
*       04-06-00  GB    Added more functions for com+ eh support.
*       04-19-00  GB    ComPlus EH bug fixes.
*       05-23-00  GB    Don't catch BreakPoint generated Exceptions.
*       05-30-00  GB    ComPlus EH bug fixes.
*       06-08-00  RDL   VS#111429: IA64 workaround for AV while handling throw.
*       06-21-00  GB    Fix the difference in order of destruction and
*                       construction depending on inlining.
*       07-26-00  GB    Fixed multiple destruction problem in COM+ eh.
*       08-23-00  GB    Fixed problem in BuildCatchObject when called from 
*                       __CxxExceptionFilter.
*       02-23-01  PML   Add __CxxCallUnwindDtor COM+ wrapper (vs7#217108)
*       04-09-01  GB    Add uncaught_exception support for COM+ C++ App.
*       04-13-01  GB    Fixed problems with Seh and catch(...). (vc7#236286)
*       04-26-01  GB    Fixed a problem with a rethrow without a throw
*                       and catch(...)
*       06-05-01  GB    AMD64 Eh support Added.
*
****/

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#if defined(_NTSUBSET_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>   // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
#include <ex.h>         // ExRaiseException
}
#endif // defined(_NTSUBSET_)

#include <windows.h>
#include <internal.h>
#include <mtdll.h>      // CRT internal header file
#include <ehassert.h>   // This project's versions of standard assert macros
#include <ehdata.h>     // Declarations of all types used for EH
#include <ehstate.h>    // Declarations of state management stuff
#include <eh.h>         // User-visible routines for eh
#include <ehhooks.h>    // Declarations of hook variables and callbacks
#include <trnsctrl.h>   // Routines to handle transfer of control (trnsctrl.asm)
#if defined(_M_IA64) /*IFSTRIP=IGN*/
#include <kxia64.h>
#include <ia64inst.h>
#include <cvconst.h>
#endif

#pragma hdrstop         // PCH is created from here

////////////////////////////////////////////////////////////////////////////////
//
// WIN64 specific definitions
//

#define __GetRangeOfTrysToCheck(a, b, c, d, e, f, g) \
                                _GetRangeOfTrysToCheck(a, b, c, d, e, f, g)
#define __CallSETranslator(a, b, c, d, e, f, g, h) \
                                _CallSETranslator(a, b, c, d, e, f, g)
#define __GetUnwindState(a, b, c) \
                                GetCurrentState(a, b, c)
#define __OffsetToAddress(a, b, c) \
                                OffsetToAddress(a, b)
#define __GetAddress(a, b) \
                                (void*)(a)
#define REAL_FP(a, b) \
                                (a)
#define __ResetException(a)
#ifdef _MT
#define pExitContext            (*((CONTEXT **)&(_getptd()->_pExitContext)))
#else
static CONTEXT                  *pExitContext = NULL;   // context to assist the return to the continuation point
#endif  // _MT

// The throw site
#undef CT_PTD
#define CT_PTD(ct)              (CT_PTD_IB(ct, _GetThrowImageBase()))
#undef CT_COPYFUNC
#define CT_COPYFUNC(ct)         ((ct).copyFunction? CT_COPYFUNC_IB(ct, _GetThrowImageBase()):NULL)

#undef THROW_FORWARDCOMPAT 
#define THROW_FORWARDCOMPAT(ti) ((ti).pForwardCompat? THROW_FORWARDCOMPAT_IB(ti, _GetThrowImageBase()):NULL) 
#undef THROW_COUNT
#define THROW_COUNT(ti)         THROW_COUNT_IB(ti, _GetThrowImageBase())
#undef THROW_CTLIST
#define THROW_CTLIST(ti)        THROW_CTLIST_IB(ti, _GetThrowImageBase())

// The catch site
#undef HT_HANDLER
#define HT_HANDLER(ht)          (HT_HANDLER_IB(ht, _GetImageBase()))
#undef UWE_ACTION
#define UWE_ACTION(uwe)         ((uwe).action? UWE_ACTION_IB(uwe, _GetImageBase()):NULL)

#undef FUNC_UNWIND
#define FUNC_UNWIND(fi,st)      (FUNC_PUNWINDMAP(fi,_GetImageBase())[st])
#undef TBME_CATCH
#define TBME_CATCH(hm,n)        (TBME_PLIST(hm,_GetImageBase())[n])
#undef TBME_PCATCH
#define TBME_PCATCH(hm,n)       (&(TBME_PLIST(hm,_GetImageBase())[n]))
#undef HT_PTD
#define HT_PTD(ht)              ((TypeDescriptor*)((ht).dispType? HT_PTD_IB(ht,_GetImageBase()):NULL))

#undef abnormal_termination
#define abnormal_termination()  FALSE

extern "C" {
typedef struct {
    unsigned long dwSig;
    unsigned long uoffDestination;
    unsigned long dwCode;
    unsigned long uoffFramePointer;
} _NLG_INFO;

extern _NLG_INFO _NLG_Destination;
}

////////////////////////////////////////////////////////////////////////////////
//
// Forward declaration of local functions:
//

// M00TODO: all these parameters should be declared const

// The local unwinder must be external (see __CxxLongjmpUnwind in trnsctrl.cpp)

extern "C" void __FrameUnwindToState(
    EHRegistrationNode *,
    DispatcherContext *,
    FuncInfo *,
    __ehstate_t
);

static void FindHandler(
    EHExceptionRecord *,
    EHRegistrationNode *,
    CONTEXT *,
    DispatcherContext *,
    FuncInfo *,
    BOOLEAN,
    int,
    EHRegistrationNode*
);

static void CatchIt(
    EHExceptionRecord *,
    EHRegistrationNode *,
    CONTEXT *,
    DispatcherContext *,
    FuncInfo *,
    HandlerType *,
    CatchableType *,
    TryBlockMapEntry *,
    int,
    EHRegistrationNode *,
    BOOLEAN
);

static void * CallCatchBlock(
    EHExceptionRecord *,
    EHRegistrationNode *,
    CONTEXT *,
    FuncInfo *,
    void *,
    int,
    unsigned long,
    FRAMEINFO *
);

static void BuildCatchObject(
    EHExceptionRecord *,
    void *,
    HandlerType *,
    CatchableType *
);

static __inline int TypeMatch(
    HandlerType *,
    CatchableType *,
    ThrowInfo *
);

static void * AdjustPointer(
    void *,
    const PMD&
);

static void FindHandlerForForeignException(
    EHExceptionRecord *,
    EHRegistrationNode *, CONTEXT *,
    DispatcherContext *,
    FuncInfo *,
    __ehstate_t,
    int,
    EHRegistrationNode *
);

static int FrameUnwindFilter(
    EXCEPTION_POINTERS *
);

static int ExFilterRethrow(
    EXCEPTION_POINTERS *
);

extern "C" void _CRTIMP __DestructExceptionObject(
    EHExceptionRecord *,
    BOOLEAN
);

//
// Make sure the terminate wrapper is dragged in:
//
static void *pMyUnhandledExceptionFilter =
#if defined(_NTSUBSET_)
        0;
#else
        &__CxxUnhandledExceptionFilter;
#endif

//
// This describes the most recently handled exception, in case of a rethrow:
//
#ifdef _MT
#define _pCurrentException      (*((EHExceptionRecord **)&(_getptd()->_curexception)))
#define _pCurrentExContext      (*((CONTEXT **)&(_getptd()->_curcontext)))
#define __ProcessingThrow       _getptd()->_ProcessingThrow
#else
EHExceptionRecord               *_pCurrentException = NULL;
CONTEXT                         *_pCurrentExContext = NULL;
int __ProcessingThrow = 0;
#endif


////////////////////////////////////////////////////////////////////////////////
//
// __InternalCxxFrameHandler - the frame handler for all functions with C++ EH
// information.
//
// If exception is handled, this doesn't return; otherwise, it returns
// ExceptionContinueSearch.
//
// Note that this is called three ways:
//     From __CxxFrameHandler: primary usage, called to inspect whole function.
//         CatchDepth == 0, pMarkerRN == NULL
//     From CatchGuardHandler: If an exception occurred within a catch, this is
//         called to check for try blocks within that catch only, and does not
//         handle unwinds.
//     From TranslatorGuardHandler: Called to handle the translation of a
//         non-C++ EH exception.  Context considered is that of parent.

extern "C" EXCEPTION_DISPOSITION __cdecl __InternalCxxFrameHandler(
    EHExceptionRecord  *pExcept,        // Information for this exception
    EHRegistrationNode *pRN,            // Dynamic information for this frame
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for this frame
    int CatchDepth,                     // How deeply nested are we?
    EHRegistrationNode *pMarkerRN,      // Marker node for when checking inside
                                        //  catch block
    BOOLEAN recursive                   // Are we handling a translation?
) {
    EHTRACE_ENTER_FMT2("%s, pRN = 0x%p",
                       IS_UNWINDING(PER_FLAGS(pExcept)) ? "Unwinding" : "Searching",
                       pRN);

    DASSERT(FUNC_MAGICNUM(*pFuncInfo) == EH_MAGIC_NUMBER1);

    if (IS_UNWINDING(PER_FLAGS(pExcept)))
    {
        // We're at the unwinding stage of things.  Don't care about the
        // exception itself.  (Check this first because it's easier)

        if (FUNC_MAXSTATE(*pFuncInfo) != 0 && CatchDepth == 0)
        {
            // Only unwind if there's something to unwind
            // AND we're being called through the primary RN.

            // If we are exiting to the continuation point, we don't want to
            // use the unwind map again. Unwinding continues until the
            // dispatcher finds the target frame, at which point the dispatcher
            // will jump to the continuation point
            //
            // Don't unwind the target frame if the unwind was initiated by
            // UnwindNestedFrames

            if (_GetUnwindContext() != NULL
              && IS_TARGET_UNWIND(PER_FLAGS(pExcept))) {

                // Save the target context to be used in 'CatchIt' to jump to
                // the continuation point.
                DASSERT(pExitContext != NULL);
                _MoveContext(pExitContext, pContext);

                // This is how we give control back to _UnwindNestedFrames
                _MoveContext(pContext, _GetUnwindContext());

                EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
                return ExceptionContinueSearch;
            }

            else if (IS_TARGET_UNWIND(PER_FLAGS(pExcept)) && PER_CODE(pExcept) == STATUS_LONGJUMP) {
#if defined(_M_IA64)
                    __ehstate_t target_state = _StateFromIp(pFuncInfo, pDC, pContext->StIIP);

#elif defined(_M_AMD64)
                    __ehstate_t target_state = _StateFromIp(pFuncInfo, pDC, pContext->Rip);
#else
#error "No Target Architecture"
#endif

                    DASSERT(target_state >= EH_EMPTY_STATE
                            && target_state < FUNC_MAXSTATE(*pFuncInfo));

                    __FrameUnwindToState(pRN, pDC, pFuncInfo, target_state);
                    EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
                    return ExceptionContinueSearch;
            }
            __FrameUnwindToEmptyState(pRN, pDC, pFuncInfo);
        }

        EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
        return ExceptionContinueSearch;     // I don't think this value matters

    } else if (FUNC_NTRYBLOCKS(*pFuncInfo) != 0) {

        // NT is looking for handlers.  We've got handlers.
        // Let's check this puppy out.  Do we recognize it?

        int (__cdecl *pfn)(...);
          

        if (PER_CODE(pExcept) == EH_EXCEPTION_NUMBER
          && PER_MAGICNUM(pExcept) > EH_MAGIC_NUMBER1
          && (pfn = THROW_FORWARDCOMPAT(*PER_PTHROW(pExcept))) != NULL) {

            // Forward compatibility:  The thrown object appears to have been
            // created by a newer version of our compiler.  Let that version's
            // frame handler do the work (if one was specified).

#if defined(DEBUG)
            if (_ValidateExecute((FARPROC)pfn)) {
#endif
                EXCEPTION_DISPOSITION result =
                    (EXCEPTION_DISPOSITION)pfn(pExcept, pRN, pContext, pDC,
                                               pFuncInfo, CatchDepth,
                                               pMarkerRN, recursive);
                EHTRACE_HANDLER_EXIT(result);
                return result;
#if defined(DEBUG)
            } else {
                _inconsistency(); // Does not return; TKB
            }
#endif

        } else {

            // Anything else: we'll handle it here.
            FindHandler(pExcept, pRN, pContext, pDC, pFuncInfo, recursive,
              CatchDepth, pMarkerRN);
        }

        // If it returned, we didn't have any matches.

        } // NT was looking for a handler

    // We had nothing to do with it or it was rethrown.  Keep searching.
    EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
    return ExceptionContinueSearch;

} // InternalCxxFrameHandler


////////////////////////////////////////////////////////////////////////////////
//
// FindHandler - find a matching handler on this frame, using all means
// available.
//
// Description:
//     If the exception thrown was an MSC++ EH, search handlers for match.
//     Otherwise, if we haven't already recursed, try to translate.
//     If we have recursed (ie we're handling the translator's exception), and
//         it isn't a typed exception, call _inconsistency.
//
// Returns:
//      Returns iff exception was not handled.
//
// Assumptions:
//      Only called if there are handlers in this function.

static void FindHandler(
    EHExceptionRecord *pExcept,         // Information for this (logical)
                                        //   exception
    EHRegistrationNode *pRN,            // Dynamic information for subject frame
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for subject frame
    BOOLEAN recursive,                  // TRUE if we're handling the
                                        //   translation
    int CatchDepth,                     // Level of nested catch that is being
                                        //   checked
    EHRegistrationNode *pMarkerRN       // Extra marker RN for nested catch 
                                        //   handling
)
{
    EHTRACE_ENTER;

    BOOLEAN IsRethrow = FALSE;

    // Get the current state (machine-dependent)
    __ehstate_t curState = _StateFromControlPc(pFuncInfo, pDC);
#if defined(_M_AMD64) // Will be used when unwinding.
    EHRegistrationNode EstablisherFrame;
    _GetEstablisherFrame(pRN, pDC, pFuncInfo, &EstablisherFrame);
    if (curState > GetUnwindTryBlock(pRN, pDC, pFuncInfo)) {
        SetState(&EstablisherFrame, pDC, pFuncInfo, curState);
    }
#endif
    DASSERT(curState >= EH_EMPTY_STATE && curState < FUNC_MAXSTATE(*pFuncInfo));

    // Check if it's a re-throw.  Use the exception we stashed away if it is.
    if (PER_IS_MSVC_EH(pExcept) && PER_PTHROW(pExcept) == NULL) {

        if (_pCurrentException == NULL) {
            // Oops!  User re-threw a non-existant exception!  Let it propogate.
            EHTRACE_EXIT;
            return;
        }

        pExcept = _pCurrentException;
        pContext = _pCurrentExContext;
        IsRethrow = TRUE;
        _SetThrowImageBase((unsigned __int64)pExcept->params.pThrowImageBase);

        DASSERT(_ValidateRead(pExcept));
        DASSERT(!PER_IS_MSVC_EH(pExcept) || PER_PTHROW(pExcept) != NULL);
    }

    if (PER_IS_MSVC_EH(pExcept)) {
        // Looks like it's ours.  Let's see if we have a match:
        //
        // First, determine range of try blocks to consider:
        // Only try blocks which are at the current catch depth are of interest.

        unsigned curTry;
        unsigned end;

        TryBlockMapEntry *pEntry = __GetRangeOfTrysToCheck(pRN, pFuncInfo,
          CatchDepth, curState, &curTry, &end, pDC);

        // Scan the try blocks in the function:
        for (; curTry < end; curTry++, pEntry++) {
            HandlerType *pCatch;
            __int32 const *ppCatchable;
            CatchableType *pCatchable;
            int catches;
            int catchables;

            if (TBME_LOW(*pEntry) > curState || curState > TBME_HIGH(*pEntry)) {
                continue;
            }

            // Try block was in scope for current state.  Scan catches for this
            // try:
            pCatch  = TBME_PCATCH(*pEntry, 0);
            for (catches = TBME_NCATCHES(*pEntry); catches > 0; catches--,
              pCatch++) {

                // Scan all types that thrown object can be converted to:
                ppCatchable = THROW_CTLIST(*PER_PTHROW(pExcept));
                for (catchables = THROW_COUNT(*PER_PTHROW(pExcept));
                  catchables > 0; catchables--, ppCatchable++) {

                    pCatchable = (CatchableType *)(_GetThrowImageBase() + *ppCatchable);
                    if (!TypeMatch(pCatch, pCatchable, PER_PTHROW(pExcept))) {
                        continue;
                    }

                    // OK.  We finally found a match.  Activate the catch.  If
                    // control gets back here, the catch did a re-throw, so
                    // keep searching.

                    SetUnwindTryBlock(pRN, pDC, pFuncInfo, /*curTry*/ curState);
                    CatchIt(pExcept, pRN, pContext, pDC, pFuncInfo, pCatch,
                      pCatchable, pEntry, CatchDepth, pMarkerRN, IsRethrow);
#if defined(_M_IA64) /*IFSTRIP=IGN*/
                    goto EndOfTryScan;
#else
                    goto NextTryBlock;
#endif

                } // Scan posible conversions
            } // Scan catch clauses
#if !defined(_M_IA64) /*IFSTRIP=IGN*/
NextTryBlock: ;
#endif
        } // Scan try blocks

#if defined(_M_IA64) /*IFSTRIP=IGN*/
EndOfTryScan:
#endif
        if (recursive) {
            // A translation was provided, but this frame didn't catch it.
            // Destruct the translated object before returning; if destruction
            // raises an exception, issue _inconsistency.
            __DestructExceptionObject(pExcept, TRUE);
        }

    } // It was a C++ EH exception
    else {
        // Not ours.  But maybe someone told us how to make it ours.
        if (!recursive) {
            FindHandlerForForeignException(pExcept, pRN, pContext, pDC,
              pFuncInfo, curState, CatchDepth, pMarkerRN);
        } else {
            // We're recursive, and the exception wasn't a C++ EH!
            // Translator threw something uninteligable.  We're outa here!

            // M00REVIEW: Two choices here actually: we could let the new
            // exception take over.

            terminate();
        }
    } // It wasn't our exception

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// FindHandlerForForeignException - We've got an exception which wasn't ours.
//     Try to translate it into C++ EH, and also check for match with ellipsis.
//
// Description:
//     If an SE-to-EH translator has been installed, call it.  The translator
//     must throw the appropriate typed exception or return.  If the translator
//     throws, we invoke FindHandler again as the exception filter.
//
// Returns:
//     Returns if exception was not fully handled.
//     No return value.
//
// Assumptions:
//     Only called if there are handlers in this function.

static void FindHandlerForForeignException(
    EHExceptionRecord *pExcept,         // Information for this (logical)
                                        //   exception
    EHRegistrationNode *pRN,            // Dynamic information for subject frame
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for subject frame
    __ehstate_t curState,               // Current state
    int CatchDepth,                     // Level of nested catch that is being
                                        //   checked
    EHRegistrationNode *pMarkerRN       // Extra marker RN for nested catch
                                        //   handling
)
{
    EHTRACE_ENTER;

    unsigned curTry;
    unsigned end;
    TryBlockMapEntry *pEntry;
    // We don't want to touch BreakPoint generated Exception.
    if (PER_CODE(pExcept) == STATUS_BREAKPOINT) {
        EHTRACE_EXIT;
        return;
    }

    if (__pSETranslator != NULL) {

        // Call the translator.  If the translator knows what to
        // make of it, it will throw an appropriate C++ exception.
        // We intercept it and use it (recursively) for this
        // frame.  Don't recurse more than once.

        if (__CallSETranslator(pExcept, pRN, pContext, pDC, pFuncInfo,
          CatchDepth, pMarkerRN, TDTransOffset)) {
            EHTRACE_EXIT;
            return;
        }
    }

    // Didn't have a translator, or the translator returned normally (i.e.
    // didn't translate it).  Still need to check for match with ellipsis:
    pEntry = __GetRangeOfTrysToCheck(pRN, pFuncInfo, CatchDepth, curState,
      &curTry, &end, pDC);

    // Scan the try blocks in the function:
    for (; curTry < end; curTry++, pEntry++) {

        // If the try-block was in scope *and* the last catch in that try is an
        // ellipsis (no other can be)
        if (curState < TBME_LOW(*pEntry) || curState > TBME_HIGH(*pEntry)
          || !HT_IS_TYPE_ELLIPSIS(TBME_CATCH(*pEntry, TBME_NCATCHES(*pEntry) - 1))) {
            continue;
        }

        // Found an ellipsis.  Handle exception.

       SetUnwindTryBlock(pRN, pDC, pFuncInfo, /*curTry*/ curState);
       CatchIt(pExcept, pRN, pContext, pDC, pFuncInfo,
          TBME_PCATCH(*pEntry, TBME_NCATCHES(*pEntry) - 1), NULL, pEntry,
          CatchDepth, pMarkerRN, TRUE);

        // If it returns, handler re-threw.  Keep searching.

    } // Search for try

    EHTRACE_EXIT;

    // If we got here, that means we didn't have anything to do with the
    // exception.  Continue search.
}


////////////////////////////////////////////////////////////////////////////////
//
// TypeMatch - Check if the catch type matches the given throw conversion.
//
// Returns:
//     TRUE if the catch can catch using this throw conversion, FALSE otherwise.

static __inline int TypeMatch(
    HandlerType *pCatch,                // Type of the 'catch' clause
    CatchableType *pCatchable,          // Type conversion under consideration
    ThrowInfo *pThrow                   // General information about the thrown
                                        //   type.
) {
    // First, check for match with ellipsis:
    if (HT_IS_TYPE_ELLIPSIS(*pCatch)) {
        return TRUE;
    }

    // Not ellipsis; the basic types match if it's the same record *or* the
    // names are identical.
    if (HT_PTD(*pCatch) != CT_PTD(*pCatchable)
      && strcmp(HT_NAME(*pCatch), CT_NAME(*pCatchable)) != 0) {
        return FALSE;
    }

    // Basic types match.  The actual conversion is valid if:
    //   caught by ref if ref required *and*
    //   the qualifiers are compatible *and*
    //   the alignments match *and*
    //   the volatility matches

    return (!CT_BYREFONLY(*pCatchable) || HT_ISREFERENCE(*pCatch))
      && (!THROW_ISCONST(*pThrow) || HT_ISCONST(*pCatch))
      && (!THROW_ISUNALIGNED(*pThrow) || HT_ISUNALIGNED(*pCatch))
      && (!THROW_ISVOLATILE(*pThrow) || HT_ISVOLATILE(*pCatch));
}


////////////////////////////////////////////////////////////////////////////////
//
// FrameUnwindFilter - Allows possibility of continuing through SEH during
//   unwind.
//

static int FrameUnwindFilter(
    EXCEPTION_POINTERS *pExPtrs
) {
    EHTRACE_ENTER;

    EHExceptionRecord *pExcept = (EHExceptionRecord *)pExPtrs->ExceptionRecord;

    switch (PER_CODE(pExcept)) {
    case EH_EXCEPTION_NUMBER:
        __ProcessingThrow = 0;
        terminate();

#ifdef ALLOW_UNWIND_ABORT
    case EH_ABORT_FRAME_UNWIND_PART:
        EHTRACE_EXIT;
        return EXCEPTION_EXECUTE_HANDLER;
#endif

    default:
        EHTRACE_EXIT;
        return EXCEPTION_CONTINUE_SEARCH;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// __FrameUnwindToState - Unwind this frame until specified state is reached.
//
// Returns:
//     No return value.
//
// Side Effects:
//     All objects on frame which go out of scope as a result of the unwind are
//       destructed.
//     Registration node is updated to reflect new state.
//
// Usage:
//      This function is called both to do full-frame unwind during the unwind
//      phase (targetState = -1), and to do partial unwinding when the current
//      frame has an appropriate catch.

extern "C" void __FrameUnwindToState (
    EHRegistrationNode *pRN,            // Registration node for subject
                                        //   function
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for subject
                                        //   function
    __ehstate_t targetState             // State to unwind to
) {
    EHTRACE_ENTER;

    __ehstate_t curState = __GetUnwindState(pRN, pDC, pFuncInfo);
    __ProcessingThrow++;
    __try {
    while (curState != EH_EMPTY_STATE && curState > targetState)
    {
        DASSERT((curState > EH_EMPTY_STATE)
          && (curState < FUNC_MAXSTATE(*pFuncInfo)));

        // Get state after next unwind action
        __ehstate_t nxtState = UWE_TOSTATE(FUNC_UNWIND(*pFuncInfo, curState));

        __try {
            // Call the unwind action (if one exists):

            if (UWE_ACTION(FUNC_UNWIND(*pFuncInfo, curState)) != NULL) {

                // Before calling unwind action, adjust state as if it were
                // already completed:
                SetState(pRN, pDC, pFuncInfo, nxtState);

                EHTRACE_FMT2("Unwind from state %d to state %d", curState, nxtState);
                _CallSettingFrame(__GetAddress(UWE_ACTION(FUNC_UNWIND(*pFuncInfo, curState)), pDC),
                  REAL_FP(pRN, pFuncInfo), 0x103);
            }

        } __except(EHTRACE_EXCEPT(FrameUnwindFilter(exception_info()))) {
        }

        curState = nxtState;
    }
    } __finally {
        if (__ProcessingThrow > 0) {
            __ProcessingThrow--;
        }
    }


    // Now that we're done, set the frame to reflect the final state.

    DASSERT(curState == EH_EMPTY_STATE || curState <= targetState);

    EHTRACE_FMT2("Move from state %d to state %d", __GetUnwindState(pRN, pDC, pFuncInfo), curState);
    SetState(pRN, pDC, pFuncInfo, curState);

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// CatchIt - A handler has been found for the thrown type.  Do the work to
//   transfer control.
//
// Description:
//     Builds the catch object
//     Unwinds the stack to the point of the try
//     Calls the address of the handler (funclet) with the frame set up for that
//       function but without resetting the stack.
//     Handler funclet returns address to continue execution, or NULL if the
//       handler re-threw ("throw;" lexically in handler)
//     If the handler throws an EH exception whose exception info is NULL, then
//       it's a re-throw from a dynamicly enclosed scope.
//
// M00REVIEW: It is still an open question whether the catch object is built
//          before or after the local unwind.
//
// Returns:
//     No return value.  Returns iff handler re-throws.
static void CatchIt(
    EHExceptionRecord *pExcept,         // The exception thrown
    EHRegistrationNode *pRN,            // Dynamic info of function with catch
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static info of function with catch
    HandlerType *pCatch,                // The catch clause selected
    CatchableType *pConv,               // The rules for making the conversion
    TryBlockMapEntry *pEntry,           // Description of the try block
    int CatchDepth,                     // How many catches are we nested in?
    EHRegistrationNode *pMarkerRN,      // Special node if nested in catch
    BOOLEAN IsRethrow                   // Is this a rethrow ?
) {
    EHTRACE_ENTER_FMT1("Catching object @ 0x%p", PER_PEXCEPTOBJ(pExcept));

    void *continuationAddress;
    EHRegistrationNode *pEstablisher = pRN;

    FRAMEINFO FrameInfo;
    FRAMEINFO *pFrameInfo;
    CONTEXT ExitContext;

    PVOID pExceptionObjectDestroyed = NULL;
    EHRegistrationNode EstablisherFramePointers;
    pEstablisher = _GetEstablisherFrame(pRN, pDC, pFuncInfo, &EstablisherFramePointers);

    // Copy the thrown object into a buffer in the handler's stack frame,
    // unless the catch was by elipsis (no conversion) OR the catch was by
    // type without an actual 'catch object'.

    if (pConv != NULL) {
        BuildCatchObject(pExcept, pEstablisher, pCatch, pConv);
    }

    // Unwind stack objects to the entry of the try that caught this exception.

    pExitContext = &ExitContext;
    _UnwindNestedFrames(pRN,
                        pExcept,
                        pContext
#ifdef _M_AMD64
                        , pDC
#endif
                        );
    if( _pCurrentException != NULL && _ExecutionInCatch(pDC, pFuncInfo) && ! IsRethrow) {
        __DestructExceptionObject(_pCurrentException, TRUE);
        pExceptionObjectDestroyed = PER_PEXCEPTOBJ(_pCurrentException);
    }

    // Create FrameInfo before we attempt to unwind with __FrameUnwindToState()
    // pExitContext must be setup in advance just in case a DTOR throws a new exception. VS7:#202440
    pFrameInfo = _CreateFrameInfo(&FrameInfo, pDC, pExitContext, -2, pExceptionObjectDestroyed, pExcept);
    __FrameUnwindToState(pEstablisher, pDC, pFuncInfo, TBME_LOW(*pEntry));

    // Call the catch.  Separated out because it introduces a new registration
    // node.

#if defined(_M_IA64) /*IFSTRIP=IGN*/
    UNWINDSTATE(pEstablisher->MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo)) = GetCurrentState(pEstablisher,pDC,pFuncInfo);
#endif
    if(IsRethrow) {
        pFrameInfo->isRethrow = TRUE;
    }
    else if( pExcept != NULL && pExceptionObjectDestroyed == NULL ) {
        pFrameInfo->pExceptionObjectToBeDestroyed = PER_PEXCEPTOBJ(pExcept);
    }

    continuationAddress = CallCatchBlock(pExcept, pEstablisher, pContext,
      pFuncInfo, __GetAddress(HT_HANDLER(*pCatch), pDC), CatchDepth, 0x100, pFrameInfo
      );

    // Transfer control to the continuation address.  If no continuation then
    // it's a re-throw, so return.

    if (continuationAddress != NULL) {

#if defined(_M_AMD64)
        UNWINDHELP(*pEstablisher, FUNC_DISPUNWINDHELP(*pFuncInfo)) = -2;
        FRAMEINFO * pContFrameInfo = _FindFrameInfo(continuationAddress, pFrameInfo);
        if( pContFrameInfo != NULL && !pContFrameInfo->isRethrow 
            && pContFrameInfo->pExceptionObjectToBeDestroyed
            && !_IsExceptionObjectDestroyed(pContFrameInfo->pExceptionObjectToBeDestroyed,pFrameInfo)
        ) {
            __DestructExceptionObject(pContFrameInfo->pExcept, TRUE);
            _MarkExceptionObjectDestroyed(pContFrameInfo->pExcept);
        }
#elif defined(_M_IA64) /*IFSTRIP=IGN*/
        UNWINDHELP(pEstablisher->MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo)) = -2;
        FRAMEINFO * pContFrameInfo = _FindFrameInfo(continuationAddress, pFrameInfo);
        if( pContFrameInfo != NULL && !pContFrameInfo->isRethrow 
            && pContFrameInfo->pExceptionObjectToBeDestroyed
            && !_IsExceptionObjectDestroyed(pContFrameInfo->pExceptionObjectToBeDestroyed,pFrameInfo)
        ) {
            __DestructExceptionObject(pContFrameInfo->pExcept, TRUE);
        }
        else if( pFrameInfo != NULL && pFrameInfo != pContFrameInfo 
            && !_IsExceptionObjectDestroyed(PER_PEXCEPTOBJ(pExcept),pFrameInfo)
        ) {
            __DestructExceptionObject(pExcept, TRUE);
        }
#else
#error "No Target Architecture:
#endif

        __ResetException(pExcept);
        pExitContext = NULL;
        _JumpToContinuation((unsigned __int64)continuationAddress,
            _FindAndUnlinkFrame(continuationAddress, pFrameInfo), pExcept
        );

    } else {
        _UnlinkFrame(pFrameInfo);
    }

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// CallCatchBlock - continuation of CatchIt.
//
// This is seperated from CatchIt because it needs to introduce an SEH/EH frame
//   in case the catch block throws.  This frame cannot be added until unwind of
//   nested frames has been completed (otherwise this frame would be the first
//   to go).

static void *CallCatchBlock(
    EHExceptionRecord *pExcept,         // The exception thrown
    EHRegistrationNode *pRN,            // Dynamic info of function with catch
    CONTEXT *pContext,                  // Context info
    FuncInfo *pFuncInfo,                // Static info of function with catch
    void *handlerAddress,               // Code address of handler
    int CatchDepth,                     // How deeply nested in catch blocks
                                        //   are we?
    unsigned long NLGCode,              // NLG destination code
    FRAMEINFO   *pFrameInfo
) {
    EHTRACE_ENTER;

    // Address where execution resumes after exception handling completed.
    // Initialized to non-NULL (value doesn't matter) to distinguish from
    // re-throw in __finally.
    void *continuationAddress = handlerAddress;

    BOOL ExceptionObjectDestroyed = FALSE;


    // Save the current exception in case of a rethrow.  Save the previous value
    // on the stack, to be restored when the catch exits.
    EHExceptionRecord *pSaveException = _pCurrentException;
    CONTEXT *pSaveExContext = _pCurrentExContext;

    _pCurrentException = pExcept;
    _pCurrentExContext = pContext;

    __try {
        __try {
            // Execute the handler as a funclet, whose return value is the
            // address to resume execution.

            continuationAddress = _CallSettingFrame(handlerAddress,
              REAL_FP(pRN, pFuncInfo), NLGCode);

        } __except(EHTRACE_EXCEPT(ExFilterRethrow(exception_info()))) {
            // If the handler threw a typed exception without exception info or
            // exception object, then it's a re-throw, so return.  Otherwise
            // it's a new exception, which takes precedence over this one.
            continuationAddress = NULL;
        }
    } __finally {
        EHTRACE_SAVE_LEVEL;
        EHTRACE_FMT1("Executing __finally, %snormal termination", _abnormal_termination() ? "ab" : "");

        // Restore the 'current exception' for a possibly enclosing catch
        _pCurrentException = pSaveException;
        _pCurrentExContext = pSaveExContext;

        // Destroy the original exception object if we're not exiting on a
        // re-throw and the object isn't also in use by a more deeply nested
        // catch.  Note that the catch handles destruction of its parameter.

        if (PER_IS_MSVC_EH(pExcept) && !ExceptionObjectDestroyed
          && continuationAddress != NULL
            && !_IsExceptionObjectDestroyed(PER_PEXCEPTOBJ(pExcept),pFrameInfo)
            && !pFrameInfo->isRethrow
            ) {
            pFrameInfo->dtorThrowFlag = TRUE;
            __DestructExceptionObject(pExcept, abnormal_termination());
        }

        EHTRACE_RESTORE_LEVEL(!!_abnormal_termination());
    }
    EHTRACE_EXIT;
    pFrameInfo->dtorThrowFlag = FALSE;
    return continuationAddress;
}


////////////////////////////////////////////////////////////////////////////////
//
// ExFilterRethrow - Exception filter for re-throw exceptions.
//
// Returns:
//     EXCEPTION_EXECUTE_HANDLER - exception was a re-throw
//     EXCEPTION_CONTINUE_SEARCH - anything else
//
// Side-effects: NONE.

static int ExFilterRethrow(
    EXCEPTION_POINTERS *pExPtrs
) {
    // Get the exception record thrown (don't care about other info)
    EHExceptionRecord *pExcept = (EHExceptionRecord *)pExPtrs->ExceptionRecord;
    
    // Check if it's ours and it's has no exception information.
    if (PER_IS_MSVC_EH(pExcept) && PER_PTHROW(pExcept) == NULL) {
        return EXCEPTION_EXECUTE_HANDLER;
    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// BuildCatchObject - Copy or construct the catch object from the object thrown.
//
// Returns:
//     nothing.
//
// Side-effects:
//     A buffer in the subject function's frame is initialized.
//
// Open issues:
//     What happens if the constructor throws?  (or faults?)

static void BuildCatchObject(
    EHExceptionRecord *pExcept,         // Original exception thrown
    void *pRN,                          // This is a pointer to the object
                                        // that we want to build while doing
                                        // COM+ eh. If we are in our own eh,
                                        // then this is a Registration node of
                                        // catching function
    HandlerType *pCatch,                // The catch clause that got it
    CatchableType *pConv                // The conversion to use
) {
    EHTRACE_ENTER;

    // If the catch is by ellipsis, then there is no object to construct.
    // If the catch is by type(No Catch Object), then leave too!
    if (HT_IS_TYPE_ELLIPSIS(*pCatch) ||
        (!HT_DISPCATCH(*pCatch) && !HT_ISCOMPLUSEH(*pCatch))) {
        EHTRACE_EXIT;
        return;
    }

    void **pCatchBuffer;
    if ( HT_ISCOMPLUSEH(*pCatch))
    {
        pCatchBuffer = (void **)pRN;
    }
    else
    {
#if defined(_M_IA64) /*IFSTRIP=IGN*/
        pCatchBuffer = (void **)__OffsetToAddress(
                                HT_DISPCATCH(*pCatch),
                                ((EHRegistrationNode *)pRN)->MemoryStackFp,
                                HT_FRAMENEST(*pCatch)
                                );
#elif defined(_M_AMD64)
        pCatchBuffer = (void **)__OffsetToAddress(
                                HT_DISPCATCH(*pCatch),
                                *((EHRegistrationNode *)pRN),
                                HT_FRAMENEST(*pCatch)
                                );
#else
#error "No Target Architecture"
#endif
    }
    __try {
        if (HT_ISREFERENCE(*pCatch)) {

            // The catch is of form 'reference to T'.  At the throw point we
            // treat both 'T' and 'reference to T' the same, i.e.
            // pExceptionObject is a (machine) pointer to T.  Adjust as
            // required.
            if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
              && _ValidateWrite(pCatchBuffer)) {
                *pCatchBuffer = PER_PEXCEPTOBJ(pExcept);
                *pCatchBuffer = AdjustPointer(*pCatchBuffer,
                  CT_THISDISP(*pConv));
            } else {
                _inconsistency(); // Does not return; TKB
            }
        } else if (CT_ISSIMPLETYPE(*pConv)) {

            // Object thrown is of simple type (this including pointers) copy
            // specified number of bytes.  Adjust the pointer as required.  If
            // the thing is not a pointer, then this should be safe since all
            // the entries in the THISDISP are 0.
            if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
              && _ValidateWrite(pCatchBuffer)) {
                memmove(pCatchBuffer, PER_PEXCEPTOBJ(pExcept), CT_SIZE(*pConv));

                if (CT_SIZE(*pConv) == sizeof(void*) && *pCatchBuffer != NULL) {
                    *pCatchBuffer = AdjustPointer(*pCatchBuffer,
                      CT_THISDISP(*pConv));
                }
            } else {
                _inconsistency(); // Does not return; TKB
            }
        } else {

            // Object thrown is UDT.
            if (CT_COPYFUNC(*pConv) == NULL) {

                // The UDT had a simple ctor.  Adjust in the thrown object,
                // then copy n bytes.
                if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
                  && _ValidateWrite(pCatchBuffer)) {
                    memmove(pCatchBuffer, AdjustPointer(PER_PEXCEPTOBJ(pExcept),
                      CT_THISDISP(*pConv)), CT_SIZE(*pConv));
                } else {
                    _inconsistency(); // Does not return; TKB
                }
            } else {

                // It's a UDT: make a copy using copy ctor

#pragma warning(disable:4191)

                if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
                  && _ValidateWrite(pCatchBuffer)
                  && _ValidateExecute((FARPROC)CT_COPYFUNC(*pConv))) {

#pragma warning(default:4191)

                    if (CT_HASVB(*pConv)) {
                        _CallMemberFunction2((char *)pCatchBuffer,
                          CT_COPYFUNC(*pConv),
                          AdjustPointer(PER_PEXCEPTOBJ(pExcept),
                          CT_THISDISP(*pConv)), 1);
                    } else {
                        _CallMemberFunction1((char *)pCatchBuffer,
                          CT_COPYFUNC(*pConv),
                          AdjustPointer(PER_PEXCEPTOBJ(pExcept),
                          CT_THISDISP(*pConv)));
                    }
                } else {
                    _inconsistency(); // Does not return; TKB
                }
            }
        }
    } __except(EHTRACE_EXCEPT(EXCEPTION_EXECUTE_HANDLER)) {
        // Something went wrong when building the catch object.
        terminate();
    }

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// __DestructExceptionObject - Call the destructor (if any) of the original
//   exception object.
//
// Returns: None.
//
// Side-effects:
//     Original exception object is destructed.
//
// Notes:
//     If destruction throws any exception, and we are destructing the exception
//       object as a result of a new exception, we give up.  If the destruction
//       throws otherwise, we let it be.

extern "C" void _CRTIMP __DestructExceptionObject(
    EHExceptionRecord *pExcept,         // The original exception record
    BOOLEAN fThrowNotAllowed            // TRUE if destructor not allowed to
                                        //   throw
) {
    EHTRACE_ENTER_FMT1("Destroying object @ 0x%p", PER_PEXCEPTOBJ(pExcept));

    if (pExcept != NULL && THROW_UNWINDFUNC(*PER_PTHROW(pExcept)) != NULL) {

        __try {

            // M00REVIEW: A destructor has additional hidden arguments, doesn't
            // it?

            _MarkExceptionObjectDestroyed(pExcept);
            _CallMemberFunction0(PER_PEXCEPTOBJ(pExcept),
              THROW_UNWINDFUNC_IB(*PER_PTHROW(pExcept),(unsigned __int64)PER_PTHROWIB(pExcept)));
            __ResetException(pExcept);

        } __except(EHTRACE_EXCEPT(fThrowNotAllowed
          ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)) {

            // Can't have new exceptions when we're unwinding due to another
            // exception.
            terminate();
        }
    }

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// AdjustPointer - Adjust the pointer to the exception object to a pointer to a
//   base instance.
//
// Output:
//     The address point of the base.
//
// Side-effects:
//     NONE.

static void *AdjustPointer(
    void *pThis,                        // Address point of exception object
    const PMD& pmd                      // Generalized pointer-to-member
                                        //   descriptor
) {
    char *pRet = (char *)pThis + pmd.mdisp;

    if (pmd.pdisp >= 0) {
        pRet += *(__int32 *)((char *)*(ptrdiff_t *)((char *)pThis + pmd.pdisp)
           + (unsigned _int64)pmd.vdisp);
        pRet += pmd.pdisp;
    }

    return pRet;
}

///////////////////////////////////////////////////////////////////////////////
// 
// __uncaught_exception() - Returns true after completing of a throw-expression
//                          untils completing initialization of the 
//                          exception-declaration in the matching handler.
//


bool __uncaught_exception()
{
    return (__ProcessingThrow != 0);
}


#if !defined(_M_IA64) && !defined(_M_AMD64) // Enable&fix for IA64 when COM+ C++ EH support available there

////////////////////////////////////////////////////////////////////////////////
// Model of C++ eh in COM+
//
// void func()
// {
//     try {
//         TryBody();
//     } catch (cpp_object o)
//     {
//         CatchOBody();
//     } catch (...)
//     {
//         CatchAllBody();
//     }
// }
//
// Turns into this:
//
//
// void func()
// {
//     int rethrow;
//     // One per try block
//     int isCxxException;
//     // One per catch(...)
//     __try {
//         TryBody();
//     }
//     __except(__CxxExceptionFilter(exception,
//                                   typeinfo(cpp_object),
//                                   flags,
//                                   &o))
//     // This is how it's done already
//     {
//     // Begin catch(object) prefix
//     char *storage = _alloca(__CxxQueryExceptionSize());
//     rethrow = false;
//     __CxxRegisterExceptionObject(exception,
//                                  storage);
//     __try {
//         __try {
//             // End catch(object) prefix
//             CatchOBody();
//             // Begin catch(object) suffix
//         } __except(rethrow = __CxxDetectRethrow(exception),
//                    EXCEPTION_CONTINUE_SEARCH)
//         {}
//     }
//     __finally
//     {
//         __CxxUnregisterExceptionObject(storage,
//                                        rethrow);
//     }
//     // End catch(object) suffix
//     }
//     __except(1)
//     {
//         // Begin catch(...) prefix
//         char *storage = _alloca(__CxxQueryExceptionSize());
//         rethrow = false;
//         isCxxException = __CxxRegisterExceptionObject(exception,
//                                                       storage);
//         __try
//         {
//             __try
//             {
//             // End catch(...) prefix 
//             CatchAllBody();
//             // Begin catch(...) suffix
//         } __except(rethrow = __CxxDetectRethrow(exception),
//                    EXCEPTION_CONTINUE_SEARCH)
//         {}
//     } __finally
//     {
//         if (isCxxException)
//         __CxxUnregisterExceptionObject(storage, rethrow);
//     }
//     // End catch(...) suffix
//     }
// }
//         
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// __CxxExceptionFilter() - Returns EXCEPTION_EXECUTE_HANDLER when the pType
//                          matches with the objects we can catch. Returns
//                          EXCEPTION_CONTINUE_SEARCH when pType is not one of
//                          the catchable type for the thrown object. This
//                          function is made for use with COM+ EH, where they
//                          attempt to do C++ EH as well.
//


extern "C" int __cdecl __CxxExceptionFilter(
    void *ppExcept,                     // Information for this (logical)
                                        // exception
    void *pType,                        // Info about the datatype. 
    int adjectives,                     // Extra Info about the datatype.
    void *pBuildObj                     // Pointer to datatype.
    )
{
    struct _s_HandlerType pCatch;
    __int32 const *ppCatchable;
    CatchableType *pCatchable;
    int catchables;
    EHExceptionRecord *pExcept;

    if (!ppExcept)
        return EXCEPTION_CONTINUE_SEARCH;
    pExcept = *(EHExceptionRecord **)ppExcept;
    // If catch all, always return EXCEPTION_EXECUTE_HANDLER
    if ( TD_IS_TYPE_ELLIPSIS((TypeDescriptor *)pType))
    {
        if (PER_IS_MSVC_EH(pExcept))
        {
            if ( PER_PTHROW(pExcept) == NULL)
            {
                if ( _pCurrentException != NULL)
                    *(EHExceptionRecord **)ppExcept = _pCurrentException;
                else
                    return EXCEPTION_CONTINUE_SEARCH;
            }
        }
        __ProcessingThrow++;
        return EXCEPTION_EXECUTE_HANDLER;
    }
    if (PER_IS_MSVC_EH(pExcept)) 
    {
        if ( PER_PTHROW(pExcept) == NULL) {
            if (_pCurrentException == NULL)
                return EXCEPTION_CONTINUE_SEARCH;
            pExcept =  _pCurrentException;
        }
        pCatch.pType = (TypeDescriptor *)pType;
        pCatch.adjectives = adjectives;
        SET_HT_ISCOMPLUSEH(pCatch);

        // Scan all types that thrown object can be converted to:
        ppCatchable = THROW_CTLIST(*PER_PTHROW(pExcept));
        for (catchables = THROW_COUNT(*PER_PTHROW(pExcept));
          catchables > 0; catchables--, ppCatchable++) {
 
            pCatchable = (CatchableType *)(_GetThrowImageBase() + *ppCatchable);

            if (TypeMatch(&pCatch, pCatchable, PER_PTHROW(pExcept))) {
                // SucessFull. Now build the object.
                __ProcessingThrow++;
                if (pBuildObj != NULL)
                    BuildCatchObject(pExcept, pBuildObj, &pCatch, pCatchable);
                // We set the current exception.
                if ( PER_PTHROW(*(EHExceptionRecord **)ppExcept) == NULL)
                    *(EHExceptionRecord **)ppExcept = _pCurrentException;
                return EXCEPTION_EXECUTE_HANDLER;
            }
        } // Scan posible conversions
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxRgisterExceptionObject() - Registers Exception Object and saves it to
//                                 This is same as first part of
//                                 CallCatchBlock.
//
extern "C" int __cdecl __CxxRegisterExceptionObject(
    void *ppExcept,
    void *pStorage
)
{
    // This function is only called for C++ EH.
    EHExceptionRecord *pExcept;
    FRAMEINFO *pFrameInfo = (FRAMEINFO *)pStorage;
    EHExceptionRecord **ppSaveException;
    CONTEXT **ppSaveExContext;
    ppSaveException = (EHExceptionRecord **)(&pFrameInfo[1]);
    ppSaveExContext = (CONTEXT **)(&ppSaveException[1]);
    pExcept = *(EHExceptionRecord **)ppExcept;
    pFrameInfo = _CreateFrameInfo(pFrameInfo, PER_PEXCEPTOBJ(pExcept));
    *ppSaveException = _pCurrentException;
    *ppSaveExContext = _pCurrentExContext;
    _pCurrentException = pExcept;
    __ProcessingThrow--;
    if ( __ProcessingThrow < 0)
        __ProcessingThrow = 0;
    return 1;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxDetectRethrow() - Looks at the Exception and returns true if rethrow,
//                        false if not a rethrow. This is then used for
//                        destructing the exception object in
//                        __CxxUnregisterExceptionObject().
//
extern "C" int __cdecl __CxxDetectRethrow(
    void *ppExcept
)
{
    EHExceptionRecord *pExcept;
    if (!ppExcept)
        return 0;
    pExcept = *(EHExceptionRecord **)ppExcept;
    if (PER_IS_MSVC_EH(pExcept) && PER_PTHROW(pExcept) == NULL) {
        *(EHExceptionRecord **)ppExcept = _pCurrentException;
        return 1;
    } else if (*(EHExceptionRecord **)ppExcept == _pCurrentException)
        return 1;
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxUnregisterExceptionObject - Destructs Exception Objects if rethrow ==
//                          true. Also set __pCurrentException and
//                          __pCurrentExContext() to current value.
//
extern "C" void __cdecl __CxxUnregisterExceptionObject(
    void *pStorage,
    int rethrow
)
{
    FRAMEINFO *pFrameInfo = (FRAMEINFO *)pStorage;
    EHExceptionRecord **ppSaveException;
    CONTEXT **ppSaveExContext;
    ppSaveException = (EHExceptionRecord **)(&pFrameInfo[1]);
    ppSaveExContext = (CONTEXT **)(&ppSaveException[1]);
    _FindAndUnlinkFrame(pFrameInfo);
    if ( !rethrow && PER_IS_MSVC_EH(_pCurrentException) && IsExceptionObjectToBeDestroyed(PER_PEXCEPTOBJ(_pCurrentException))) {
        __DestructExceptionObject(_pCurrentException, TRUE);
    }
    _pCurrentException = *ppSaveException;
    _pCurrentExContext = *ppSaveExContext;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxQueryExceptionSize - returns the value of Storage needed to save
//                          FrameInfo + two pointers.
//
extern "C" int __cdecl __CxxQueryExceptionSize(
    void
)
{
    return sizeof(FRAMEINFO) + sizeof(void *) + sizeof(void *);
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxCallUnwindDtor - Calls a destructor during unwind. For COM+, the dtor
//                       call needs to be wrapped inside a __try/__except to
//                       get correct terminate() behavior when an exception 
//                       occurs during the dtor call.
//
extern "C" void __cdecl __CxxCallUnwindDtor(
    void (__thiscall * pDtor)(void*),
    void *pThis
)
{
    __try
    {
        (*pDtor)(pThis);
    }
    __except(FrameUnwindFilter(exception_info()))
    {
    }
}

#endif  // !defined(_M_IA64) && !defined(_AMD64_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\frame.cpp ===
/***
*frame.cxx - The frame handler and everything associated with it.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The frame handler and everything associated with it.
*
*       Entry points:
*       _CxxFrameHandler   - the frame handler.
*
*       Open issues:
*         Handling re-throw from dynamicly nested scope.
*         Fault-tolerance (checking for data structure validity).
*
*Revision History:
*       05-20-93  BS    Module created
*       03-03-94  TL    Added Mips specific code
*       06-19-94  AD    Added Alpha specific code (Al Dosser)
*       10-17-94  BWT   Disable code for PPC.
*       11-23-94  JWM   Removed obsolete 'hash' check in TypeMatch().
*       11-29-94  JWM   AdjustPointer() now adds in pdisp, not vdisp.
*       01-13-95  JWM   Added _NLG_Destination struct; dwCode set for catch
*                       blocks & local destructors.
*       02-09-95  JWM   Mac merge.
*       02-10-95  JWM   UnhandledExceptionFilter() now called if exception
*                       raised during stack unwind.
*       03-22-95  PML   Add const for read-only compiler-gen'd structs
*       04-14-95  JWM   Re-fix EH/SEH exception handling.
*       04-17-95  JWM   FrameUnwindFilter() must be #ifdef _WIN32.
*       04-21-95  JWM   _NLG_Destination moved to exsup3.asm (_M_X86 only).
*       04-21-95  TGL   Added Mips fixes.
*       04-27-95  JWM   EH_ABORT_FRAME_UNWIND_PART now #ifdef 
*                       ALLOW_UNWIND_ABORT.
*       05-19-95  DAK   Don't initialize the kernel handler
*       06-07-95  JWM   Various NLG additions.
*       06-14-95  JWM   Unneeded LastError calls removed.
*       06-19-95  JWM   NLG no longer uses per-thread data (X86 only).
*       09-26-95  AMP   PowerMac avoids re-throws to same catch clause
*       08-06-95  JWM   Typo fixed (Orion #6509); Alpha-specific.
*       04-18-97  JWM   In __InternalCxxFrameHandler(), 'recursive' changed to
*                       BOOLEAN.
*       06-01-97  TGL   Added P7 specific code
*       08-22-97  TGL   More P7 fixes
*       11-14-98  JWM   Merge with P7 sources.
*       02-11-99  TGL   EH: correct catch in exe calling dll.
*       05-17-99  PML   Remove all Macintosh support.
*       07-12-99  RDL   Image relative fixes under CC_P7_SOFT25.
*       10-17-99  PML   Update EH state before each unwind action, instead of
*                       once at end (vs7#5419)
*       10-19-99  TGL   More P7/Win64 fixes
*       10-22-99  PML   Add EHTRACE support
*       12-10-99  GB    Add Uncaught exception Support by adding a new function
*                       __uncaught_exception();
*       02-15-99  PML   Can't put __try/__finally around call to
*                       _UnwindNestedFrames (vs7#79460)
*       03-03-00  GB    made __DestructExceptionObject export from dll.
*       03-21-00  KBF   Check for C++ exception in __CxxExceptionFilter
*       03-22-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*       03-28-00  GB    Check for no buildobj in __CxxExceptionFilter.
*       04-06-00  GB    Added more functions for com+ eh support.
*       04-19-00  GB    ComPlus EH bug fixes.
*       05-23-00  GB    Don't catch BreakPoint generated Exceptions.
*       05-30-00  GB    ComPlus EH bug fixes.
*       06-08-00  RDL   VS#111429: IA64 workaround for AV while handling throw.
*       06-21-00  GB    Fix the difference in order of destruction and
*                       construction depending on inlining.
*       07-26-00  GB    Fixed multiple destruction problem in COM+ eh.
*       08-23-00  GB    Fixed problem in BuildCatchObject when called from 
*                       __CxxExceptionFilter.
*       02-23-01  PML   Add __CxxCallUnwindDtor COM+ wrapper (vs7#217108)
*       04-09-01  GB    Add uncaught_exception support for COM+ C++ App.
*       04-13-01  GB    Fixed problems with Seh and catch(...). (vc7#236286)
*       04-26-01  GB    Fixed a problem with a rethrow without a throw
*                       and catch(...)
*       06-05-01  GB    AMD64 Eh support Added.
*
****/

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#if defined(_NTSUBSET_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>   // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
#include <ex.h>         // ExRaiseException
}
#endif // defined(_NTSUBSET_)

#include <windows.h>
#include <internal.h>
#include <mtdll.h>      // CRT internal header file
#include <ehassert.h>   // This project's versions of standard assert macros
#include <ehdata.h>     // Declarations of all types used for EH
#include <ehstate.h>    // Declarations of state management stuff
#include <eh.h>         // User-visible routines for eh
#include <ehhooks.h>    // Declarations of hook variables and callbacks
#include <trnsctrl.h>   // Routines to handle transfer of control (trnsctrl.asm)
#if defined(_M_IA64) /*IFSTRIP=IGN*/
#include <kxia64.h>
#include <ia64inst.h>
#include <cvconst.h>
#endif

#pragma hdrstop         // PCH is created from here

////////////////////////////////////////////////////////////////////////////////
//
// Intel x86-specific definitions
//
#if defined(_M_IX86)
#define __GetRangeOfTrysToCheck(a, b, c, d, e, f, g) \
                                _GetRangeOfTrysToCheck(b, c, d, e, f)
#define __FrameUnwindToEmptyState(a, b, c) \
                                __FrameUnwindToState(a, b, c, EH_EMPTY_STATE);
#define __CallSETranslator(a, b, c, d, e, f, g, h) \
                                _CallSETranslator(a, b, c, d, e, f, g)
#define __GetUnwindState(a, b, c) \
                                GetCurrentState(a, b, c)
#define __OffsetToAddress(a, b, c) \
                                OffsetToAddress(a, b)
#define __GetAddress(a, b) \
                                (a)
#define REAL_FP(a, b) \
                                (a)
#define __ResetException(a)

////////////////////////////////////////////////////////////////////////////////
//
// MIPS-specific definitions
//
#elif defined(_M_MRX000)
#define __GetRangeOfTrysToCheck(a, b, c, d, e, f, g) \
                                _GetRangeOfTrysToCheck(a, b, c, d, e, f)
#define __FrameUnwindToEmptyState(a, b, c) \
                                __FrameUnwindToState(a, b, c, EH_EMPTY_STATE);
#define __CallSETranslator(a, b, c, d, e, f, g, h) \
                                _CallSETranslator(a, b, c, d, e, f, g, h)
#define __GetUnwindState(a, b, c) \
                                GetCurrentState(a, b, c)
#define __OffsetToAddress(a, b, c) \
                                _OffsetToAddress(a, b, c)
#define __GetAddress(a, b) \
                                (a)
#define REAL_FP(a, b) \
                                (a)
#define SetState(a, b, c, d)
#define __ResetException(a)
#define VER41_C2(p)             (HT_ADJECTIVES(TBME_CATCH(FUNC_TRYBLOCK(*p, 0), 0)) & 0x20)

#ifdef _MT
#define pExitContext            (*((CONTEXT **)&(_getptd()->_pExitContext)))
#else
static CONTEXT                  *pExitContext = NULL;   // context to assist the return to the continuation point
#endif  // _MT

////////////////////////////////////////////////////////////////////////////////
//
// P7 specific definitions
//
#elif defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
#define __GetRangeOfTrysToCheck(a, b, c, d, e, f, g) \
                                _GetRangeOfTrysToCheck(a, b, c, d, e, f, g)
#define __CallSETranslator(a, b, c, d, e, f, g, h) \
                                _CallSETranslator(a, b, c, d, e, f, g)
#define __GetUnwindState(a, b, c) \
                                GetCurrentState(a, b, c)
#define __OffsetToAddress(a, b, c) \
                                OffsetToAddress(a, b)
#define __GetAddress(a, b) \
                                (void*)(a)
#define REAL_FP(a, b) \
                                (a)
#define __ResetException(a)
#ifdef _MT
#define pExitContext            (*((CONTEXT **)&(_getptd()->_pExitContext)))
#else
static CONTEXT                  *pExitContext = NULL;   // context to assist the return to the continuation point
#endif  // _MT

// The throw site
#undef CT_PTD
#define CT_PTD(ct)              (CT_PTD_IB(ct, _GetThrowImageBase()))
#undef CT_COPYFUNC
#define CT_COPYFUNC(ct)         ((ct).copyFunction? CT_COPYFUNC_IB(ct, _GetThrowImageBase()):NULL)

#undef THROW_FORWARDCOMPAT 
#define THROW_FORWARDCOMPAT(ti) ((ti).pForwardCompat? THROW_FORWARDCOMPAT_IB(ti, _GetThrowImageBase()):NULL) 
#undef THROW_COUNT
#define THROW_COUNT(ti)         THROW_COUNT_IB(ti, _GetThrowImageBase())
#undef THROW_CTLIST
#define THROW_CTLIST(ti)        THROW_CTLIST_IB(ti, _GetThrowImageBase())

// The catch site
#undef HT_HANDLER
#define HT_HANDLER(ht)          (HT_HANDLER_IB(ht, _GetImageBase()))
#undef UWE_ACTION
#define UWE_ACTION(uwe)         ((uwe).action? UWE_ACTION_IB(uwe, _GetImageBase()):NULL)

#undef FUNC_UNWIND
#define FUNC_UNWIND(fi,st)      (FUNC_PUNWINDMAP(fi,_GetImageBase())[st])
#undef TBME_CATCH
#define TBME_CATCH(hm,n)        (TBME_PLIST(hm,_GetImageBase())[n])
#undef TBME_PCATCH
#define TBME_PCATCH(hm,n)       (&(TBME_PLIST(hm,_GetImageBase())[n]))
#undef HT_PTD
#define HT_PTD(ht)              ((TypeDescriptor*)((ht).dispType? HT_PTD_IB(ht,_GetImageBase()):NULL))

#undef abnormal_termination
#define abnormal_termination()  FALSE

////////////////////////////////////////////////////////////////////////////////
//
// DEC Alpha-specific definitions
//
#elif defined(_M_ALPHA)
#define __GetRangeOfTrysToCheck(a, b, c, d, e, f, g) \
                                _GetRangeOfTrysToCheck(b, c, d, e, f)
#define __FrameUnwindToEmptyState(a, b, c) \
                                __FrameUnwindToState(a, b, c, EH_EMPTY_STATE);
#define __CallSETranslator(a, b, c, d, e, f, g, h) \
                                _CallSETranslator(a, b, c, d, e, f, g)
#define __GetUnwindState(a, b, c) \
                                GetCurrentState(a, b, c)
#define __OffsetToAddress(a, b, c) \
                                OffsetToAddress(a, b)
#define __GetAddress(a, b) \
                                (a)
#define __ResetException(a)

////////////////////////////////////////////////////////////////////////////////
//
// PowerPC for Windows/NT-specific definitions
//
#elif defined(_M_PPC)
#define _POWERPC
#define __GetRangeOfTrysToCheck(a, b, c, d, e, f, g) \
                                _GetRangeOfTrysToCheck(b, c, d, e, f)
#define _MoveContext(a, b)  \
                                RtlMoveMemory(a, b, sizeof(CONTEXT));
#define __CallSETranslator(a, b, c, d, e, f, g, h) \
                                _CallSETranslator(a, b, c, d, e, f, g)
#define __GetUnwindState(a, b, c) \
                                GetUnwindState(a, b, c)
#define __OffsetToAddress(a, b, c) \
                                OffsetToAddress(a, b)
#define __GetAddress(a, b) \
                                (a)
#define REAL_FP(a, b) \
                                (a)
#define __ResetException(a)
extern "C" CONTEXT *            _GetUnwindContext(VOID);
#ifdef _MT
#define pExitContext            (*((CONTEXT **)&(_getptd()->_pExitContext)))
#else
static CONTEXT                  *pExitContext = NULL;   // context to assist the return to the continuation point
#endif  // _MT

////////////////////////////////////////////////////////////////////////////////
//
// Unknown platform
//
#else
#error Unrecognized platform
#endif

extern "C" {
typedef struct {
    unsigned long dwSig;
    unsigned long uoffDestination;
    unsigned long dwCode;
    unsigned long uoffFramePointer;
} _NLG_INFO;

extern _NLG_INFO _NLG_Destination;
}

////////////////////////////////////////////////////////////////////////////////
//
// Forward declaration of local functions:
//

// M00TODO: all these parameters should be declared const

// The local unwinder must be external (see __CxxLongjmpUnwind in trnsctrl.cpp)

extern "C" void __FrameUnwindToState(
    EHRegistrationNode *,
    DispatcherContext *,
    FuncInfo *,
    __ehstate_t
);

static void FindHandler(
    EHExceptionRecord *,
    EHRegistrationNode *,
    CONTEXT *,
    DispatcherContext *,
    FuncInfo *,
    BOOLEAN,
    int,
    EHRegistrationNode*
);

static void CatchIt(
    EHExceptionRecord *,
    EHRegistrationNode *,
    CONTEXT *,
    DispatcherContext *,
    FuncInfo *,
    HandlerType *,
    CatchableType *,
    TryBlockMapEntry *,
    int,
    EHRegistrationNode *,
    BOOLEAN
);

static void * CallCatchBlock(
    EHExceptionRecord *,
    EHRegistrationNode *,
    CONTEXT *,
    FuncInfo *,
    void *,
    int,
    unsigned long
#if defined(_M_IA64) || defined(_M_AMD64)
    ,FRAMEINFO *
#endif
);

static void BuildCatchObject(
    EHExceptionRecord *,
    void *,
    HandlerType *,
    CatchableType *
);

static __inline int TypeMatch(
    HandlerType *,
    CatchableType *,
    ThrowInfo *
);

static void * AdjustPointer(
    void *,
    const PMD&
);

static void FindHandlerForForeignException(
    EHExceptionRecord *,
    EHRegistrationNode *, CONTEXT *,
    DispatcherContext *,
    FuncInfo *,
    __ehstate_t,
    int,
    EHRegistrationNode *
);

static int FrameUnwindFilter(
    EXCEPTION_POINTERS *
);

static int ExFilterRethrow(
    EXCEPTION_POINTERS *
);

extern "C" void _CRTIMP __DestructExceptionObject(
    EHExceptionRecord *,
    BOOLEAN
);


//
// Make sure the terminate wrapper is dragged in:
//
static void *pMyUnhandledExceptionFilter =
#if defined(_NTSUBSET_)
        0;
#else
        &__CxxUnhandledExceptionFilter;
#endif

//
// This describes the most recently handled exception, in case of a rethrow:
//
#ifdef _MT
#define _pCurrentException      (*((EHExceptionRecord **)&(_getptd()->_curexception)))
#define _pCurrentExContext      (*((CONTEXT **)&(_getptd()->_curcontext)))
#define __ProcessingThrow       _getptd()->_ProcessingThrow
#else
EHExceptionRecord               *_pCurrentException = NULL;
CONTEXT                         *_pCurrentExContext = NULL;
int __ProcessingThrow = 0;
#endif


////////////////////////////////////////////////////////////////////////////////
//
// __InternalCxxFrameHandler - the frame handler for all functions with C++ EH
// information.
//
// If exception is handled, this doesn't return; otherwise, it returns
// ExceptionContinueSearch.
//
// Note that this is called three ways:
//     From __CxxFrameHandler: primary usage, called to inspect whole function.
//         CatchDepth == 0, pMarkerRN == NULL
//     From CatchGuardHandler: If an exception occurred within a catch, this is
//         called to check for try blocks within that catch only, and does not
//         handle unwinds.
//     From TranslatorGuardHandler: Called to handle the translation of a
//         non-C++ EH exception.  Context considered is that of parent.

extern "C" EXCEPTION_DISPOSITION __cdecl __InternalCxxFrameHandler(
    EHExceptionRecord  *pExcept,        // Information for this exception
    EHRegistrationNode *pRN,            // Dynamic information for this frame
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for this frame
    int CatchDepth,                     // How deeply nested are we?
    EHRegistrationNode *pMarkerRN,      // Marker node for when checking inside
                                        //  catch block
    BOOLEAN recursive                   // Are we handling a translation?
) {
    EHTRACE_ENTER_FMT2("%s, pRN = 0x%p",
                       IS_UNWINDING(PER_FLAGS(pExcept)) ? "Unwinding" : "Searching",
                       pRN);

#if defined(_M_ALPHA)
    // On Alpha - these values synthesized from DispatcherContext

    pFuncInfo = (FuncInfo *)(pDC ->FunctionEntry->HandlerData);
    pRN = (EHRegistrationNode *)VIRTUAL_FP(pDC);
#endif // defined(_M_ALPHA)

    DASSERT(FUNC_MAGICNUM(*pFuncInfo) == EH_MAGIC_NUMBER1);

#if defined(_M_ALPHA)
    // A special case to support gotos out of nested catch handlers
    // and setjmp/longjmp.
    //
    // See __CxxEHGoto in alpha\trnsctrl.cxx for details.
    //
    if (IS_TARGET_UNWIND(PER_FLAGS(pExcept))) {
        if (PER_CODE(pExcept) == STATUS_UNWIND && PER_NPARAMS(pExcept) == 1) {
            __ehstate_t target_state =
              (__ehstate_t)((PEXCEPTION_RECORD)(pExcept))->ExceptionInformation[0];

            DASSERT(target_state >= EH_EMPTY_STATE
              && target_state < FUNC_MAXSTATE(*pFuncInfo));

            __FrameUnwindToState(pRN, pDC, pFuncInfo, target_state);
            EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
            return ExceptionContinueSearch;
        } else {
            EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
            return ExceptionContinueSearch;
        }
    }
#endif // defined(_M_ALPHA)

    if (IS_UNWINDING(PER_FLAGS(pExcept)))
    {
        // We're at the unwinding stage of things.  Don't care about the
        // exception itself.  (Check this first because it's easier)

#if defined(_POWERPC)
        if (FUNC_MAXSTATE(*pFuncInfo) != 0)
#else
        if (FUNC_MAXSTATE(*pFuncInfo) != 0 && CatchDepth == 0)
#endif
        {
            // Only unwind if there's something to unwind
            // AND we're being called through the primary RN.

#if defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
            // If we are exiting to the continuation point, we don't want to
            // use the unwind map again. Unwinding continues until the
            // dispatcher finds the target frame, at which point the dispatcher
            // will jump to the continuation point
            //
            // Don't unwind the target frame if the unwind was initiated by
            // UnwindNestedFrames

            if (_GetUnwindContext() != NULL
              && IS_TARGET_UNWIND(PER_FLAGS(pExcept))) {

#if defined (_POWERPC)
                // Virtually unwind the target frame to recover the value of r2.
                // We must take care to not unwind a glue sequence that may have
                // been used to reach the target frame.  This is done by giving
                // stack limit values that will regard any stack pointer as bad.

                CONTEXT TocContext;
                PRUNTIME_FUNCTION FunctionEntry;
                BOOLEAN InFunction;
                ULONG EstablisherFrame;

                _MoveContext(&TocContext, pContext);
                FunctionEntry = RtlLookupFunctionEntry(pDC->ControlPc);
                RtlVirtualUnwind(pDC->ControlPc, FunctionEntry, &TocContext,
                  &InFunction, &EstablisherFrame, NULL, 0xffffffff, 0);
                pContext->Gpr2 = TocContext.Gpr2;
#endif // defined (_POWERPC)

                // Save the target context to be used in 'CatchIt' to jump to
                // the continuation point.
                DASSERT(pExitContext != NULL);
                _MoveContext(pExitContext, pContext);

                // This is how we give control back to _UnwindNestedFrames
                _MoveContext(pContext, _GetUnwindContext());

                EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
                return ExceptionContinueSearch;
            }
#endif // defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64)

#if defined(_M_IA64)
            else if (IS_TARGET_UNWIND(PER_FLAGS(pExcept)) && PER_CODE(pExcept) == STATUS_LONGJUMP) {
                    __ehstate_t target_state = _StateFromIp(pFuncInfo, pDC, pContext->StIIP);

                    DASSERT(target_state >= EH_EMPTY_STATE
                            && target_state < FUNC_MAXSTATE(*pFuncInfo));

                    __FrameUnwindToState(pRN, pDC, pFuncInfo, target_state);
                    EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
                    return ExceptionContinueSearch;
            }
#elif defined(_M_AMD64)
            else if (IS_TARGET_UNWIND(PER_FLAGS(pExcept)) && PER_CODE(pExcept) == STATUS_LONGJUMP) {
                    __ehstate_t target_state = _StateFromIp(pFuncInfo, pDC, pContext->Rip);

                    DASSERT(target_state >= EH_EMPTY_STATE
                            && target_state < FUNC_MAXSTATE(*pFuncInfo));

                    __FrameUnwindToState(pRN, pDC, pFuncInfo, target_state);
                    EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
                    return ExceptionContinueSearch;
            }
#endif // defined(_M_IA64)
            __FrameUnwindToEmptyState(pRN, pDC, pFuncInfo);
        }

        EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
        return ExceptionContinueSearch;     // I don't think this value matters

    } else if (FUNC_NTRYBLOCKS(*pFuncInfo) != 0) {

        // NT is looking for handlers.  We've got handlers.
        // Let's check this puppy out.  Do we recognize it?

        int (__cdecl *pfn)(...);
          

        if (PER_CODE(pExcept) == EH_EXCEPTION_NUMBER
          && PER_MAGICNUM(pExcept) > EH_MAGIC_NUMBER1
          && (pfn = THROW_FORWARDCOMPAT(*PER_PTHROW(pExcept))) != NULL) {

            // Forward compatibility:  The thrown object appears to have been
            // created by a newer version of our compiler.  Let that version's
            // frame handler do the work (if one was specified).

#if defined(DEBUG)
            if (_ValidateExecute((FARPROC)pfn)) {
#endif
                EXCEPTION_DISPOSITION result =
                    (EXCEPTION_DISPOSITION)pfn(pExcept, pRN, pContext, pDC,
                                               pFuncInfo, CatchDepth,
                                               pMarkerRN, recursive);
                EHTRACE_HANDLER_EXIT(result);
                return result;
#if defined(DEBUG)
            } else {
                _inconsistency(); // Does not return; TKB
            }
#endif

        } else {

            // Anything else: we'll handle it here.
            FindHandler(pExcept, pRN, pContext, pDC, pFuncInfo, recursive,
              CatchDepth, pMarkerRN);
        }

        // If it returned, we didn't have any matches.

        } // NT was looking for a handler

    // We had nothing to do with it or it was rethrown.  Keep searching.
    EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
    return ExceptionContinueSearch;

} // InternalCxxFrameHandler


////////////////////////////////////////////////////////////////////////////////
//
// FindHandler - find a matching handler on this frame, using all means
// available.
//
// Description:
//     If the exception thrown was an MSC++ EH, search handlers for match.
//     Otherwise, if we haven't already recursed, try to translate.
//     If we have recursed (ie we're handling the translator's exception), and
//         it isn't a typed exception, call _inconsistency.
//
// Returns:
//      Returns iff exception was not handled.
//
// Assumptions:
//      Only called if there are handlers in this function.

static void FindHandler(
    EHExceptionRecord *pExcept,         // Information for this (logical)
                                        //   exception
    EHRegistrationNode *pRN,            // Dynamic information for subject frame
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for subject frame
    BOOLEAN recursive,                  // TRUE if we're handling the
                                        //   translation
    int CatchDepth,                     // Level of nested catch that is being
                                        //   checked
    EHRegistrationNode *pMarkerRN       // Extra marker RN for nested catch 
                                        //   handling
)
{
    EHTRACE_ENTER;

    BOOLEAN IsRethrow = FALSE;

    // Get the current state (machine-dependent)
#if defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
    __ehstate_t curState = _StateFromControlPc(pFuncInfo, pDC);
#if defined(_M_AMD64) // Will be used when unwinding.
    EHRegistrationNode EstablisherFrame;
    _GetEstablisherFrame(pRN, pDC, pFuncInfo, &EstablisherFrame);
    if (curState > GetUnwindTryBlock(pRN, pDC, pFuncInfo)) {
        SetState(&EstablisherFrame, pDC, pFuncInfo, curState);
    }
#endif
#else
    __ehstate_t curState = GetCurrentState(pRN, pDC, pFuncInfo);
#endif
    DASSERT(curState >= EH_EMPTY_STATE && curState < FUNC_MAXSTATE(*pFuncInfo));

    // Check if it's a re-throw.  Use the exception we stashed away if it is.
    if (PER_IS_MSVC_EH(pExcept) && PER_PTHROW(pExcept) == NULL) {

        if (_pCurrentException == NULL) {
            // Oops!  User re-threw a non-existant exception!  Let it propogate.
            EHTRACE_EXIT;
            return;
        }

        pExcept = _pCurrentException;
        pContext = _pCurrentExContext;
        IsRethrow = TRUE;
#if defined(_M_IA64) || defined(_M_AMD64)/*IFSTRIP=IGN*/
        _SetThrowImageBase((unsigned __int64)pExcept->params.pThrowImageBase);
#endif

        DASSERT(_ValidateRead(pExcept));
        DASSERT(!PER_IS_MSVC_EH(pExcept) || PER_PTHROW(pExcept) != NULL);
    }

    if (PER_IS_MSVC_EH(pExcept)) {
        // Looks like it's ours.  Let's see if we have a match:
        //
        // First, determine range of try blocks to consider:
        // Only try blocks which are at the current catch depth are of interest.

        unsigned curTry;
        unsigned end;

#if defined(_M_MRX000)
        DASSERT(VER41_C2(pFuncInfo));
#endif
        TryBlockMapEntry *pEntry = __GetRangeOfTrysToCheck(pRN, pFuncInfo,
          CatchDepth, curState, &curTry, &end, pDC);

        // Scan the try blocks in the function:
        for (; curTry < end; curTry++, pEntry++) {
            HandlerType *pCatch;
#if defined(_M_IA64) || defined(_M_AMD64)
            __int32 const *ppCatchable;
#elif defined(_WIN64)
            CatchableType * UNALIGNED const *ppCatchable;
#else
            CatchableType * const *ppCatchable;
#endif
            CatchableType *pCatchable;
            int catches;
            int catchables;

            if (TBME_LOW(*pEntry) > curState || curState > TBME_HIGH(*pEntry)) {
                continue;
            }

            // Try block was in scope for current state.  Scan catches for this
            // try:
            pCatch  = TBME_PCATCH(*pEntry, 0);
            for (catches = TBME_NCATCHES(*pEntry); catches > 0; catches--,
              pCatch++) {

                // Scan all types that thrown object can be converted to:
                ppCatchable = THROW_CTLIST(*PER_PTHROW(pExcept));
                for (catchables = THROW_COUNT(*PER_PTHROW(pExcept));
                  catchables > 0; catchables--, ppCatchable++) {

#if defined(_M_IA64) || defined(_M_AMD64)
                    pCatchable = (CatchableType *)(_GetThrowImageBase() + *ppCatchable);
#else
                    pCatchable = *ppCatchable;
#endif

                    if (!TypeMatch(pCatch, pCatchable, PER_PTHROW(pExcept))) {
                        continue;
                    }

                    // OK.  We finally found a match.  Activate the catch.  If
                    // control gets back here, the catch did a re-throw, so
                    // keep searching.

#if defined(_M_MRX000)
                    PVOID pRealFrame = _OffsetToAddress(0, pRN, FUNC_FRAMENEST(*pFuncInfo));
                    UNWINDHELP(pRealFrame, FUNC_DISPUNWINDHELP(*pFuncInfo),0) = curTry;
#elif defined(_M_IA64) || defined(_M_AMD64)/*IFSTRIP=IGN*/
                    SetUnwindTryBlock(pRN, pDC, pFuncInfo, /*curTry*/ curState);
#endif // defined(_M_MRX000)


                    CatchIt(pExcept, pRN, pContext, pDC, pFuncInfo, pCatch,
                      pCatchable, pEntry, CatchDepth, pMarkerRN, IsRethrow);
#if defined(_M_IA64) /*IFSTRIP=IGN*/
                    goto EndOfTryScan;
#else
                    goto NextTryBlock;
#endif

                } // Scan posible conversions
            } // Scan catch clauses
#if !defined(_M_IA64) /*IFSTRIP=IGN*/
NextTryBlock: ;
#endif
#if defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
//            if( GetUnwindTryBlock(pRN, pDC, pFuncInfo) >= 0 )
//                curTry = GetUnwindTryBlock(pRN, pDC, pFuncInfo);
#endif
        } // Scan try blocks

#if defined(_M_IA64) /*IFSTRIP=IGN*/
EndOfTryScan:
#endif
        if (recursive) {
            // A translation was provided, but this frame didn't catch it.
            // Destruct the translated object before returning; if destruction
            // raises an exception, issue _inconsistency.
            __DestructExceptionObject(pExcept, TRUE);
        }

    } // It was a C++ EH exception
    else {
        // Not ours.  But maybe someone told us how to make it ours.
        if (!recursive) {
            FindHandlerForForeignException(pExcept, pRN, pContext, pDC,
              pFuncInfo, curState, CatchDepth, pMarkerRN);
        } else {
            // We're recursive, and the exception wasn't a C++ EH!
            // Translator threw something uninteligable.  We're outa here!

            // M00REVIEW: Two choices here actually: we could let the new
            // exception take over.

            terminate();
        }
    } // It wasn't our exception

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// FindHandlerForForeignException - We've got an exception which wasn't ours.
//     Try to translate it into C++ EH, and also check for match with ellipsis.
//
// Description:
//     If an SE-to-EH translator has been installed, call it.  The translator
//     must throw the appropriate typed exception or return.  If the translator
//     throws, we invoke FindHandler again as the exception filter.
//
// Returns:
//     Returns if exception was not fully handled.
//     No return value.
//
// Assumptions:
//     Only called if there are handlers in this function.

static void FindHandlerForForeignException(
    EHExceptionRecord *pExcept,         // Information for this (logical)
                                        //   exception
    EHRegistrationNode *pRN,            // Dynamic information for subject frame
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for subject frame
    __ehstate_t curState,               // Current state
    int CatchDepth,                     // Level of nested catch that is being
                                        //   checked
    EHRegistrationNode *pMarkerRN       // Extra marker RN for nested catch
                                        //   handling
)
{
    EHTRACE_ENTER;

    unsigned curTry;
    unsigned end;
    TryBlockMapEntry *pEntry;
    // We don't want to touch BreakPoint generated Exception.
    if (PER_CODE(pExcept) == STATUS_BREAKPOINT) {
        EHTRACE_EXIT;
        return;
    }

    if (__pSETranslator != NULL) {

        // Call the translator.  If the translator knows what to
        // make of it, it will throw an appropriate C++ exception.
        // We intercept it and use it (recursively) for this
        // frame.  Don't recurse more than once.

#if defined(_M_MRX000)
        ULONG TDTransOffset = 0;

#ifdef _MT
        struct _tiddata DummyStruct;
        TDTransOffset = (char*)&DummyStruct._translator - (char*)&DummyStruct;
#endif
#endif // defined(_M_MRX000)

        if (__CallSETranslator(pExcept, pRN, pContext, pDC, pFuncInfo,
          CatchDepth, pMarkerRN, TDTransOffset)) {
            EHTRACE_EXIT;
            return;
        }
    }

    // Didn't have a translator, or the translator returned normally (i.e.
    // didn't translate it).  Still need to check for match with ellipsis:
    pEntry = __GetRangeOfTrysToCheck(pRN, pFuncInfo, CatchDepth, curState,
      &curTry, &end, pDC);

    // Scan the try blocks in the function:
    for (; curTry < end; curTry++, pEntry++) {

        // If the try-block was in scope *and* the last catch in that try is an
        // ellipsis (no other can be)
        if (curState < TBME_LOW(*pEntry) || curState > TBME_HIGH(*pEntry)
          || !HT_IS_TYPE_ELLIPSIS(TBME_CATCH(*pEntry, TBME_NCATCHES(*pEntry) - 1))) {
            continue;
        }

        // Found an ellipsis.  Handle exception.

#if defined(_M_MRX000)
       DASSERT(VER41_C2(pFuncInfo));
       PVOID pRealFrame = _OffsetToAddress(0, pRN, FUNC_FRAMENEST(*pFuncInfo));
       UNWINDHELP(pRealFrame, FUNC_DISPUNWINDHELP(*pFuncInfo), 0) = curTry;
#elif defined(_M_IA64) || defined(_M_AMD64)/*IFSTRIP=IGN*/
       SetUnwindTryBlock(pRN, pDC, pFuncInfo, /*curTry*/ curState);
#endif // defined(_M_MRX000)

        CatchIt(pExcept, pRN, pContext, pDC, pFuncInfo,
          TBME_PCATCH(*pEntry, TBME_NCATCHES(*pEntry) - 1), NULL, pEntry,
          CatchDepth, pMarkerRN, TRUE);

        // If it returns, handler re-threw.  Keep searching.

    } // Search for try

    EHTRACE_EXIT;

    // If we got here, that means we didn't have anything to do with the
    // exception.  Continue search.
}


////////////////////////////////////////////////////////////////////////////////
//
// TypeMatch - Check if the catch type matches the given throw conversion.
//
// Returns:
//     TRUE if the catch can catch using this throw conversion, FALSE otherwise.

static __inline int TypeMatch(
    HandlerType *pCatch,                // Type of the 'catch' clause
    CatchableType *pCatchable,          // Type conversion under consideration
    ThrowInfo *pThrow                   // General information about the thrown
                                        //   type.
) {
    // First, check for match with ellipsis:
    if (HT_IS_TYPE_ELLIPSIS(*pCatch)) {
        return TRUE;
    }

    // Not ellipsis; the basic types match if it's the same record *or* the
    // names are identical.
    if (HT_PTD(*pCatch) != CT_PTD(*pCatchable)
      && strcmp(HT_NAME(*pCatch), CT_NAME(*pCatchable)) != 0) {
        return FALSE;
    }

    // Basic types match.  The actual conversion is valid if:
    //   caught by ref if ref required *and*
    //   the qualifiers are compatible *and*
    //   the alignments match *and*
    //   the volatility matches

    return (!CT_BYREFONLY(*pCatchable) || HT_ISREFERENCE(*pCatch))
      && (!THROW_ISCONST(*pThrow) || HT_ISCONST(*pCatch))
#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
      && (!THROW_ISUNALIGNED(*pThrow) || HT_ISUNALIGNED(*pCatch))
#endif
      && (!THROW_ISVOLATILE(*pThrow) || HT_ISVOLATILE(*pCatch));
}


////////////////////////////////////////////////////////////////////////////////
//
// FrameUnwindFilter - Allows possibility of continuing through SEH during
//   unwind.
//

static int FrameUnwindFilter(
    EXCEPTION_POINTERS *pExPtrs
) {
    EHTRACE_ENTER;

    EHExceptionRecord *pExcept = (EHExceptionRecord *)pExPtrs->ExceptionRecord;

    switch (PER_CODE(pExcept)) {
    case EH_EXCEPTION_NUMBER:
        __ProcessingThrow = 0;
        terminate();

#ifdef ALLOW_UNWIND_ABORT
    case EH_ABORT_FRAME_UNWIND_PART:
        EHTRACE_EXIT;
        return EXCEPTION_EXECUTE_HANDLER;
#endif

    default:
        EHTRACE_EXIT;
        return EXCEPTION_CONTINUE_SEARCH;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// __FrameUnwindToState - Unwind this frame until specified state is reached.
//
// Returns:
//     No return value.
//
// Side Effects:
//     All objects on frame which go out of scope as a result of the unwind are
//       destructed.
//     Registration node is updated to reflect new state.
//
// Usage:
//      This function is called both to do full-frame unwind during the unwind
//      phase (targetState = -1), and to do partial unwinding when the current
//      frame has an appropriate catch.

extern "C" void __FrameUnwindToState (
    EHRegistrationNode *pRN,            // Registration node for subject
                                        //   function
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for subject
                                        //   function
    __ehstate_t targetState             // State to unwind to
) {
    EHTRACE_ENTER;

    __ehstate_t curState = __GetUnwindState(pRN, pDC, pFuncInfo);
    __ProcessingThrow++;
    __try {
#if defined(_M_MRX000)
    // The MIPS unwind-map may have a shortcut by using EH_EMPTY_STATE

    while (curState != EH_EMPTY_STATE && curState != targetState)
#elif defined(_M_IA64) || defined(_M_AMD64)
    while (curState != EH_EMPTY_STATE && curState > targetState)
#else
    while (curState != targetState)
#endif
    {
        DASSERT((curState > EH_EMPTY_STATE)
          && (curState < FUNC_MAXSTATE(*pFuncInfo)));

        // Get state after next unwind action
        __ehstate_t nxtState = UWE_TOSTATE(FUNC_UNWIND(*pFuncInfo, curState));

        __try {
            // Call the unwind action (if one exists):

#if defined(_M_MRX000)
            // If this is nested function (catch block), the real frame where
            // all locals are stored is the outermost function's frame.

            PVOID pRealFrame =
              _OffsetToAddress(0, pRN, FUNC_FRAMENEST(*pFuncInfo));

            if (UWE_ACTION(FUNC_UNWIND(*pFuncInfo, curState)) != NULL
              && !UNWINDHELP(pRealFrame, FUNC_DISPUNWINDHELP(*pFuncInfo),
              curState)) {
                UNWINDHELP(pRealFrame, FUNC_DISPUNWINDHELP(*pFuncInfo),
                  curState) = TRUE;
#else // !defined(_M_MRX000)
            if (UWE_ACTION(FUNC_UNWIND(*pFuncInfo, curState)) != NULL) {
#endif

                // Before calling unwind action, adjust state as if it were
                // already completed:
                SetState(pRN, pDC, pFuncInfo, nxtState);

                EHTRACE_FMT2("Unwind from state %d to state %d", curState, nxtState);
                _CallSettingFrame(__GetAddress(UWE_ACTION(FUNC_UNWIND(*pFuncInfo, curState)), pDC),
                  REAL_FP(pRN, pFuncInfo), 0x103);
            }

        } __except(EHTRACE_EXCEPT(FrameUnwindFilter(exception_info()))) {
        }

        curState = nxtState;
    }
    } __finally {
        if (__ProcessingThrow > 0) {
            __ProcessingThrow--;
        }
    }


    // Now that we're done, set the frame to reflect the final state.

#if defined(_M_MRX000)
    DASSERT(curState == EH_EMPTY_STATE || curState == targetState);
#elif defined(_M_IA64) || defined(_M_AMD64)
    DASSERT(curState == EH_EMPTY_STATE || curState <= targetState);
#else
    DASSERT(curState == targetState);
#endif

    EHTRACE_FMT2("Move from state %d to state %d", __GetUnwindState(pRN, pDC, pFuncInfo), curState);
    SetState(pRN, pDC, pFuncInfo, curState);

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// CatchIt - A handler has been found for the thrown type.  Do the work to
//   transfer control.
//
// Description:
//     Builds the catch object
//     Unwinds the stack to the point of the try
//     Calls the address of the handler (funclet) with the frame set up for that
//       function but without resetting the stack.
//     Handler funclet returns address to continue execution, or NULL if the
//       handler re-threw ("throw;" lexically in handler)
//     If the handler throws an EH exception whose exception info is NULL, then
//       it's a re-throw from a dynamicly enclosed scope.
//
// M00REVIEW: It is still an open question whether the catch object is built
//          before or after the local unwind.
//
// Returns:
//     No return value.  Returns iff handler re-throws.
static void CatchIt(
    EHExceptionRecord *pExcept,         // The exception thrown
    EHRegistrationNode *pRN,            // Dynamic info of function with catch
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static info of function with catch
    HandlerType *pCatch,                // The catch clause selected
    CatchableType *pConv,               // The rules for making the conversion
    TryBlockMapEntry *pEntry,           // Description of the try block
    int CatchDepth,                     // How many catches are we nested in?
    EHRegistrationNode *pMarkerRN,      // Special node if nested in catch
    BOOLEAN IsRethrow                   // Is this a rethrow ?
) {
    EHTRACE_ENTER_FMT1("Catching object @ 0x%p", PER_PEXCEPTOBJ(pExcept));

    void *continuationAddress;
    EHRegistrationNode *pEstablisher = pRN;

#if defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64) || defined(_M_AMD64)/*IFSTRIP=IGN*/
    FRAMEINFO FrameInfo;
    FRAMEINFO *pFrameInfo;
    CONTEXT ExitContext;
#endif // defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64) || defined(_M_AMD64)

#if defined(_POWERPC)
    int dummy;

    pEstablisher = _GetEstablisherFrame(pDC, &dummy);
#elif defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
    PVOID pExceptionObjectDestroyed = NULL;
    EHRegistrationNode EstablisherFramePointers;
    pEstablisher = _GetEstablisherFrame(pRN, pDC, pFuncInfo, &EstablisherFramePointers);
#endif // defined(_POWERPC)

    // Copy the thrown object into a buffer in the handler's stack frame,
    // unless the catch was by elipsis (no conversion) OR the catch was by
    // type without an actual 'catch object'.

    if (pConv != NULL) {
        BuildCatchObject(pExcept, pEstablisher, pCatch, pConv);
    }

    // Unwind stack objects to the entry of the try that caught this exception.

#if defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64) || defined(_M_AMD64)/*IFSTRIP=IGN*/
    pExitContext = &ExitContext;
    _UnwindNestedFrames(pRN,
                        pExcept,
                        pContext
#ifdef _M_AMD64
                        , pDC
#endif
                        );
#if defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
    if( _pCurrentException != NULL && _ExecutionInCatch(pDC, pFuncInfo) && ! IsRethrow) {
        __DestructExceptionObject(_pCurrentException, TRUE);
        pExceptionObjectDestroyed = PER_PEXCEPTOBJ(_pCurrentException);
    }
#endif
#elif defined(_M_ALPHA)
    // Alpha specific - this calls a special version of RtlUnwind which
    // walks the stack performing unwind actions but which does NOT
    // restore the context to the target frame's routine. Instead it
    // just returns.
    _UnwindNestedFrames(pRN, pExcept);

#else
    if (pMarkerRN == NULL) {
        _UnwindNestedFrames(pRN, pExcept);
    } else {
        _UnwindNestedFrames(pMarkerRN, pExcept);
    }
#endif

#if defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
    // Create FrameInfo before we attempt to unwind with __FrameUnwindToState()
    // pExitContext must be setup in advance just in case a DTOR throws a new exception. VS7:#202440
    pFrameInfo = _CreateFrameInfo(&FrameInfo, pDC, pExitContext, -2, pExceptionObjectDestroyed, pExcept);
#endif
    __FrameUnwindToState(pEstablisher, pDC, pFuncInfo, TBME_LOW(*pEntry));

    // Call the catch.  Separated out because it introduces a new registration
    // node.

#if defined(_M_MRX000)
    pFrameInfo = _CreateFrameInfo(&FrameInfo, pDC, pRN, pExitContext);
#elif defined(_M_IA64) /*IFSTRIP=IGN*/
    UNWINDSTATE(pEstablisher->MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo)) = GetCurrentState(pEstablisher,pDC,pFuncInfo);
    if(IsRethrow) {
        pFrameInfo->isRethrow = TRUE;
    }
    else if( pExcept != NULL && pExceptionObjectDestroyed == NULL ) {
        pFrameInfo->pExceptionObjectToBeDestroyed = PER_PEXCEPTOBJ(pExcept);
    }
#elif defined(_M_AMD64)
    if(IsRethrow) {
        pFrameInfo->isRethrow = TRUE;
    }
    else if( pExcept != NULL && pExceptionObjectDestroyed == NULL ) {
        pFrameInfo->pExceptionObjectToBeDestroyed = PER_PEXCEPTOBJ(pExcept);
    }
#elif defined(_POWERPC)
    pFrameInfo = _CreateFrameInfo(&FrameInfo, pDC, pEstablisher, pExitContext,
      (FUNC_UNWIND(*pFuncInfo, TBME_LOW(*pEntry))).toState);
#elif defined(_M_ALPHA)
    SetState(pRN, pDC, pFuncInfo,
      (FUNC_UNWIND(*pFuncInfo, TBME_LOW(*pEntry))).toState);
#else
    EHTRACE_FMT2("Move from state %d to state %d", __GetUnwindState(pRN, pDC, pFuncInfo), TBME_HIGH(*pEntry) + 1);
    SetState(pRN, pDC, pFuncInfo, TBME_HIGH(*pEntry) + 1);
#endif

    continuationAddress = CallCatchBlock(pExcept, pEstablisher, pContext,
      pFuncInfo, __GetAddress(HT_HANDLER(*pCatch), pDC), CatchDepth, 0x100
#if defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
      , pFrameInfo
#endif
      );

    // Transfer control to the continuation address.  If no continuation then
    // it's a re-throw, so return.

    if (continuationAddress != NULL) {

#if defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/

        // Exit gracefully to the continuation adddress.
        //
        // We are done, but we have to blow away the stack below the frame where
        // the try-block resides.  In addition, we have to resore a bunch of
        // other registers besides SP as well.  Leave that task up to
        // _JumpToContinuation.
        //
        // The code that is commented out below worked well until we hit the
        // scenario of:
        //
        //      void foo()
        //      {
        //              try {
        //                      bar();
        //              }
        //              catch(int) {
        //              }
        //      }
        //
        //      void bar()
        //      {
        //              __try {
        //                      throw 1;
        //              }
        //              __finally {
        //              }
        //      }
        //
        // In the above example, RtlUnwind would call the __finally's handler
        // twice.  Once for the original unwind through the call to
        // _UnwindNestedFrames, then here where all we want is to get to the
        // continuation point.
        //
        // ExitContext was saved during the original unwind when we detected the
        // target of the unwind in __InternalCxxFrameHandler.

#if defined(_M_MRX000)
        DASSERT(VER41_C2(pFuncInfo));
        PVOID pRealFrame = _OffsetToAddress(0, pRN, FUNC_FRAMENEST(*pFuncInfo));
        UNWINDHELP(pRealFrame, FUNC_DISPUNWINDHELP(*pFuncInfo), 0) = -1;
#elif defined(_M_AMD64)
        UNWINDHELP(*pEstablisher, FUNC_DISPUNWINDHELP(*pFuncInfo)) = -2;
        FRAMEINFO * pContFrameInfo = _FindFrameInfo(continuationAddress, pFrameInfo);
        if( pContFrameInfo != NULL && !pContFrameInfo->isRethrow 
            && pContFrameInfo->pExceptionObjectToBeDestroyed
            && !_IsExceptionObjectDestroyed(pContFrameInfo->pExceptionObjectToBeDestroyed,pFrameInfo)
        ) {
            __DestructExceptionObject(pContFrameInfo->pExcept, TRUE);
            _MarkExceptionObjectDestroyed(pContFrameInfo->pExcept);
        }
#elif defined(_M_IA64) /*IFSTRIP=IGN*/
        UNWINDHELP(pEstablisher->MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo)) = -2;
        FRAMEINFO * pContFrameInfo = _FindFrameInfo(continuationAddress, pFrameInfo);
        if( pContFrameInfo != NULL && !pContFrameInfo->isRethrow 
            && pContFrameInfo->pExceptionObjectToBeDestroyed
            && !_IsExceptionObjectDestroyed(pContFrameInfo->pExceptionObjectToBeDestroyed,pFrameInfo)
        ) {
            __DestructExceptionObject(pContFrameInfo->pExcept, TRUE);
        }
        else if( pFrameInfo != NULL && pFrameInfo != pContFrameInfo 
            && !_IsExceptionObjectDestroyed(PER_PEXCEPTOBJ(pExcept),pFrameInfo)
        ) {
            __DestructExceptionObject(pExcept, TRUE);
        }
#endif // defined(_M_MRX000)

        __ResetException(pExcept);
        pExitContext = NULL;
#if defined(_WIN64)
        _JumpToContinuation((unsigned __int64)continuationAddress,
#else
        _JumpToContinuation((ULONG)continuationAddress,
#endif
            _FindAndUnlinkFrame(continuationAddress, pFrameInfo)
#if defined(_M_IA64) || defined(_M_AMD64)
            ,pExcept
#endif
        );

#else // !(defined(_M_MRX000) || defined(_POWERPC)) || defined(_M_IA64) || defined(_M_AMD64)
        _JumpToContinuation(continuationAddress, pRN);
#endif
        // No return.

#if defined(_POWERPC)
    } else {
        _FindAndUnlinkFrame(NULL, pFrameInfo);
#elif defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
    } else {
        _UnlinkFrame(pFrameInfo);
#endif
    }

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// CallCatchBlock - continuation of CatchIt.
//
// This is seperated from CatchIt because it needs to introduce an SEH/EH frame
//   in case the catch block throws.  This frame cannot be added until unwind of
//   nested frames has been completed (otherwise this frame would be the first
//   to go).

static void *CallCatchBlock(
    EHExceptionRecord *pExcept,         // The exception thrown
    EHRegistrationNode *pRN,            // Dynamic info of function with catch
    CONTEXT *pContext,                  // Context info
    FuncInfo *pFuncInfo,                // Static info of function with catch
    void *handlerAddress,               // Code address of handler
    int CatchDepth,                     // How deeply nested in catch blocks
                                        //   are we?
    unsigned long NLGCode               // NLG destination code
#if defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
    ,
    FRAMEINFO   *pFrameInfo
#endif
) {
    EHTRACE_ENTER;

    // Address where execution resumes after exception handling completed.
    // Initialized to non-NULL (value doesn't matter) to distinguish from
    // re-throw in __finally.
    void *continuationAddress = handlerAddress;

    BOOL ExceptionObjectDestroyed = FALSE;

#if defined(_M_IX86)
    // The stack pointer at entry to the try must be saved, in case there is
    // another try inside this catch.  We'll restore it on our way out.
    void *saveESP = PRN_STACK(pRN);

    // Push this catch block's frame info on a linked list
    FRAMEINFO FrameInfo;
    FRAMEINFO *pFrameInfo = _CreateFrameInfo(&FrameInfo, PER_PEXCEPTOBJ(pExcept));
#endif

    // Save the current exception in case of a rethrow.  Save the previous value
    // on the stack, to be restored when the catch exits.
    EHExceptionRecord *pSaveException = _pCurrentException;
    CONTEXT *pSaveExContext = _pCurrentExContext;

    _pCurrentException = pExcept;
    _pCurrentExContext = pContext;

    __try {
        __try {
            // Execute the handler as a funclet, whose return value is the
            // address to resume execution.

#if defined(_M_IX86)
            continuationAddress = _CallCatchBlock2(pRN, pFuncInfo,
              handlerAddress, CatchDepth, NLGCode);
#else
            continuationAddress = _CallSettingFrame(handlerAddress,
              REAL_FP(pRN, pFuncInfo), NLGCode);
#endif

        } __except(EHTRACE_EXCEPT(ExFilterRethrow(exception_info()))) {
#if defined(_M_IX86)
            // Here we are exiting the catch block on rethrow out of this
            // catch block. To keep the order of destruction and construction
            // same when the the rethrow was from function or was inline, here
            // we unwind to the parent state for this catch.
            UnwindMapEntry *pUnwindMap = pFuncInfo->pUnwindMap;
            int cState = GetCurrentState(pRN, handlerAddress, pFuncInfo);
            TryBlockMapEntry *pTryBlockMap = pFuncInfo->pTryBlockMap;
            unsigned int i;
            for (i = 0; i < pFuncInfo->nTryBlocks; i++) {
                if (cState > pTryBlockMap[i].tryHigh && 
                    cState <= pTryBlockMap[i].catchHigh) {
                    cState = pTryBlockMap[i].tryHigh +1;
                    cState = pUnwindMap[cState].toState;
                    break;
                }
            }
            __FrameUnwindToState(pRN, NULL, pFuncInfo, cState);
#endif
            // If the handler threw a typed exception without exception info or
            // exception object, then it's a re-throw, so return.  Otherwise
            // it's a new exception, which takes precedence over this one.
            continuationAddress = NULL;
        }
    } __finally {
        EHTRACE_SAVE_LEVEL;
        EHTRACE_FMT1("Executing __finally, %snormal termination", _abnormal_termination() ? "ab" : "");

#if defined(_M_IX86)
        // Restore the saved stack pointer, so the stack can be reset when
        // we're done.
        PRN_STACK(pRN) = saveESP;

        // Pop this catch block's frame info
        _FindAndUnlinkFrame(pFrameInfo);
#endif

        // Restore the 'current exception' for a possibly enclosing catch
        _pCurrentException = pSaveException;
        _pCurrentExContext = pSaveExContext;

        // Destroy the original exception object if we're not exiting on a
        // re-throw and the object isn't also in use by a more deeply nested
        // catch.  Note that the catch handles destruction of its parameter.

        if (PER_IS_MSVC_EH(pExcept) && !ExceptionObjectDestroyed
          && continuationAddress != NULL
#if defined(_M_IA64) || defined(_M_AMD64)
            && !_IsExceptionObjectDestroyed(PER_PEXCEPTOBJ(pExcept),pFrameInfo)
            && !pFrameInfo->isRethrow
#elif defined(_M_IX86)
            && IsExceptionObjectToBeDestroyed(PER_PEXCEPTOBJ(pExcept))
#endif          
            ) {
#if defined(_M_IA64) || defined(_M_AMD64)
            pFrameInfo->dtorThrowFlag = TRUE;
#endif          
            __DestructExceptionObject(pExcept, abnormal_termination());
#if defined(_M_MRX000)
            ExceptionObjectDestroyed = TRUE;
#endif
        }

        EHTRACE_RESTORE_LEVEL(!!_abnormal_termination());
    }
    EHTRACE_EXIT;
#if defined(_M_IA64) || defined(_M_AMD64)
    pFrameInfo->dtorThrowFlag = FALSE;
#endif          
    return continuationAddress;
}


////////////////////////////////////////////////////////////////////////////////
//
// ExFilterRethrow - Exception filter for re-throw exceptions.
//
// Returns:
//     EXCEPTION_EXECUTE_HANDLER - exception was a re-throw
//     EXCEPTION_CONTINUE_SEARCH - anything else
//
// Side-effects: NONE.

static int ExFilterRethrow(
    EXCEPTION_POINTERS *pExPtrs
) {
    // Get the exception record thrown (don't care about other info)
    EHExceptionRecord *pExcept = (EHExceptionRecord *)pExPtrs->ExceptionRecord;
    
    // Check if it's ours and it's has no exception information.
    if (PER_IS_MSVC_EH(pExcept) && PER_PTHROW(pExcept) == NULL) {
        return EXCEPTION_EXECUTE_HANDLER;
    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// BuildCatchObject - Copy or construct the catch object from the object thrown.
//
// Returns:
//     nothing.
//
// Side-effects:
//     A buffer in the subject function's frame is initialized.
//
// Open issues:
//     What happens if the constructor throws?  (or faults?)

static void BuildCatchObject(
    EHExceptionRecord *pExcept,         // Original exception thrown
    void *pRN,                          // This is a pointer to the object
                                        // that we want to build while doing
                                        // COM+ eh. If we are in our own eh,
                                        // then this is a Registration node of
                                        // catching function
    HandlerType *pCatch,                // The catch clause that got it
    CatchableType *pConv                // The conversion to use
) {
    EHTRACE_ENTER;

    // If the catch is by ellipsis, then there is no object to construct.
    // If the catch is by type(No Catch Object), then leave too!
    if (HT_IS_TYPE_ELLIPSIS(*pCatch) ||
        (!HT_DISPCATCH(*pCatch) && !HT_ISCOMPLUSEH(*pCatch))) {
        EHTRACE_EXIT;
        return;
    }

    void **pCatchBuffer;
    if ( HT_ISCOMPLUSEH(*pCatch))
    {
        pCatchBuffer = (void **)pRN;
    }
    else
    {
#if defined(_M_IA64) /*IFSTRIP=IGN*/
        pCatchBuffer = (void **)__OffsetToAddress(
                                HT_DISPCATCH(*pCatch),
                                ((EHRegistrationNode *)pRN)->MemoryStackFp,
                                HT_FRAMENEST(*pCatch)
                                );
#elif defined(_M_AMD64)
        pCatchBuffer = (void **)__OffsetToAddress(
                                HT_DISPCATCH(*pCatch),
                                *((EHRegistrationNode *)pRN),
                                HT_FRAMENEST(*pCatch)
                                );
#else
        pCatchBuffer = (void **)__OffsetToAddress(
                                HT_DISPCATCH(*pCatch),
                                (EHRegistrationNode *)pRN,
                                HT_FRAMENEST(*pCatch)
                                );
#endif
    }
    __try {
        if (HT_ISREFERENCE(*pCatch)) {

            // The catch is of form 'reference to T'.  At the throw point we
            // treat both 'T' and 'reference to T' the same, i.e.
            // pExceptionObject is a (machine) pointer to T.  Adjust as
            // required.
            if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
              && _ValidateWrite(pCatchBuffer)) {
                *pCatchBuffer = PER_PEXCEPTOBJ(pExcept);
                *pCatchBuffer = AdjustPointer(*pCatchBuffer,
                  CT_THISDISP(*pConv));
            } else {
                _inconsistency(); // Does not return; TKB
            }
        } else if (CT_ISSIMPLETYPE(*pConv)) {

            // Object thrown is of simple type (this including pointers) copy
            // specified number of bytes.  Adjust the pointer as required.  If
            // the thing is not a pointer, then this should be safe since all
            // the entries in the THISDISP are 0.
            if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
              && _ValidateWrite(pCatchBuffer)) {
                memmove(pCatchBuffer, PER_PEXCEPTOBJ(pExcept), CT_SIZE(*pConv));

                if (CT_SIZE(*pConv) == sizeof(void*) && *pCatchBuffer != NULL) {
                    *pCatchBuffer = AdjustPointer(*pCatchBuffer,
                      CT_THISDISP(*pConv));
                }
            } else {
                _inconsistency(); // Does not return; TKB
            }
        } else {

            // Object thrown is UDT.
            if (CT_COPYFUNC(*pConv) == NULL) {

                // The UDT had a simple ctor.  Adjust in the thrown object,
                // then copy n bytes.
                if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
                  && _ValidateWrite(pCatchBuffer)) {
                    memmove(pCatchBuffer, AdjustPointer(PER_PEXCEPTOBJ(pExcept),
                      CT_THISDISP(*pConv)), CT_SIZE(*pConv));
                } else {
                    _inconsistency(); // Does not return; TKB
                }
            } else {

                // It's a UDT: make a copy using copy ctor

#pragma warning(disable:4191)

                if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
                  && _ValidateWrite(pCatchBuffer)
                  && _ValidateExecute((FARPROC)CT_COPYFUNC(*pConv))) {

#pragma warning(default:4191)

                    if (CT_HASVB(*pConv)) {
                        _CallMemberFunction2((char *)pCatchBuffer,
                          CT_COPYFUNC(*pConv),
                          AdjustPointer(PER_PEXCEPTOBJ(pExcept),
                          CT_THISDISP(*pConv)), 1);
                    } else {
                        _CallMemberFunction1((char *)pCatchBuffer,
                          CT_COPYFUNC(*pConv),
                          AdjustPointer(PER_PEXCEPTOBJ(pExcept),
                          CT_THISDISP(*pConv)));
                    }
                } else {
                    _inconsistency(); // Does not return; TKB
                }
            }
        }
    } __except(EHTRACE_EXCEPT(EXCEPTION_EXECUTE_HANDLER)) {
        // Something went wrong when building the catch object.
        terminate();
    }

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// __DestructExceptionObject - Call the destructor (if any) of the original
//   exception object.
//
// Returns: None.
//
// Side-effects:
//     Original exception object is destructed.
//
// Notes:
//     If destruction throws any exception, and we are destructing the exception
//       object as a result of a new exception, we give up.  If the destruction
//       throws otherwise, we let it be.

extern "C" void _CRTIMP __DestructExceptionObject(
    EHExceptionRecord *pExcept,         // The original exception record
    BOOLEAN fThrowNotAllowed            // TRUE if destructor not allowed to
                                        //   throw
) {
    EHTRACE_ENTER_FMT1("Destroying object @ 0x%p", PER_PEXCEPTOBJ(pExcept));

    if (pExcept != NULL && THROW_UNWINDFUNC(*PER_PTHROW(pExcept)) != NULL) {

        __try {

            // M00REVIEW: A destructor has additional hidden arguments, doesn't
            // it?

#if defined(_M_IA64) || defined(_M_AMD64) /*IFSTRIP=IGN*/
            _MarkExceptionObjectDestroyed(pExcept);
            _CallMemberFunction0(PER_PEXCEPTOBJ(pExcept),
              THROW_UNWINDFUNC_IB(*PER_PTHROW(pExcept),(unsigned __int64)PER_PTHROWIB(pExcept)));
#else
            _CallMemberFunction0(PER_PEXCEPTOBJ(pExcept),
              THROW_UNWINDFUNC(*PER_PTHROW(pExcept)));
#endif
            __ResetException(pExcept);

        } __except(EHTRACE_EXCEPT(fThrowNotAllowed
          ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)) {

            // Can't have new exceptions when we're unwinding due to another
            // exception.
            terminate();
        }
    }

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// AdjustPointer - Adjust the pointer to the exception object to a pointer to a
//   base instance.
//
// Output:
//     The address point of the base.
//
// Side-effects:
//     NONE.

static void *AdjustPointer(
    void *pThis,                        // Address point of exception object
    const PMD& pmd                      // Generalized pointer-to-member
                                        //   descriptor
) {
    char *pRet = (char *)pThis + pmd.mdisp;

    if (pmd.pdisp >= 0) {
        pRet += *(__int32 *)((char *)*(ptrdiff_t *)((char *)pThis + pmd.pdisp)
#if defined(_WIN64)
           + (unsigned _int64)pmd.vdisp);
#else
           + pmd.vdisp);
#endif
        pRet += pmd.pdisp;
    }

    return pRet;
}

///////////////////////////////////////////////////////////////////////////////
// 
// __uncaught_exception() - Returns true after completing of a throw-expression
//                          untils completing initialization of the 
//                          exception-declaration in the matching handler.
//


bool __uncaught_exception()
{
    return (__ProcessingThrow != 0);
}


#if !defined(_M_IA64) && !defined(_M_AMD64) // Enable&fix for IA64 when COM+ C++ EH support available there

////////////////////////////////////////////////////////////////////////////////
// Model of C++ eh in COM+
//
// void func()
// {
//     try {
//         TryBody();
//     } catch (cpp_object o)
//     {
//         CatchOBody();
//     } catch (...)
//     {
//         CatchAllBody();
//     }
// }
//
// Turns into this:
//
//
// void func()
// {
//     int rethrow;
//     // One per try block
//     int isCxxException;
//     // One per catch(...)
//     __try {
//         TryBody();
//     }
//     __except(__CxxExceptionFilter(exception,
//                                   typeinfo(cpp_object),
//                                   flags,
//                                   &o))
//     // This is how it's done already
//     {
//     // Begin catch(object) prefix
//     char *storage = _alloca(__CxxQueryExceptionSize());
//     rethrow = false;
//     __CxxRegisterExceptionObject(exception,
//                                  storage);
//     __try {
//         __try {
//             // End catch(object) prefix
//             CatchOBody();
//             // Begin catch(object) suffix
//         } __except(rethrow = __CxxDetectRethrow(exception),
//                    EXCEPTION_CONTINUE_SEARCH)
//         {}
//     }
//     __finally
//     {
//         __CxxUnregisterExceptionObject(storage,
//                                        rethrow);
//     }
//     // End catch(object) suffix
//     }
//     __except(1)
//     {
//         // Begin catch(...) prefix
//         char *storage = _alloca(__CxxQueryExceptionSize());
//         rethrow = false;
//         isCxxException = __CxxRegisterExceptionObject(exception,
//                                                       storage);
//         __try
//         {
//             __try
//             {
//             // End catch(...) prefix 
//             CatchAllBody();
//             // Begin catch(...) suffix
//         } __except(rethrow = __CxxDetectRethrow(exception),
//                    EXCEPTION_CONTINUE_SEARCH)
//         {}
//     } __finally
//     {
//         if (isCxxException)
//         __CxxUnregisterExceptionObject(storage, rethrow);
//     }
//     // End catch(...) suffix
//     }
// }
//         
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// __CxxExceptionFilter() - Returns EXCEPTION_EXECUTE_HANDLER when the pType
//                          matches with the objects we can catch. Returns
//                          EXCEPTION_CONTINUE_SEARCH when pType is not one of
//                          the catchable type for the thrown object. This
//                          function is made for use with COM+ EH, where they
//                          attempt to do C++ EH as well.
//


extern "C" int __cdecl __CxxExceptionFilter(
    void *ppExcept,                     // Information for this (logical)
                                        // exception
    void *pType,                        // Info about the datatype. 
    int adjectives,                     // Extra Info about the datatype.
    void *pBuildObj                     // Pointer to datatype.
    )
{
    struct _s_HandlerType pCatch;
#if defined(_M_IA64) || defined(_M_AMD64)
    __int32 const *ppCatchable;
#elif defined(_WIN64)
    CatchableType * UNALIGNED const *ppCatchable;
#else
    CatchableType * const *ppCatchable;
#endif
    CatchableType *pCatchable;
    int catchables;
    EHExceptionRecord *pExcept;

    if (!ppExcept)
        return EXCEPTION_CONTINUE_SEARCH;
    pExcept = *(EHExceptionRecord **)ppExcept;
    // If catch all, always return EXCEPTION_EXECUTE_HANDLER
    if ( TD_IS_TYPE_ELLIPSIS((TypeDescriptor *)pType))
    {
        if (PER_IS_MSVC_EH(pExcept))
        {
            if ( PER_PTHROW(pExcept) == NULL)
            {
                if ( _pCurrentException != NULL)
                    *(EHExceptionRecord **)ppExcept = _pCurrentException;
                else
                    return EXCEPTION_CONTINUE_SEARCH;
            }
        }
        __ProcessingThrow++;
        return EXCEPTION_EXECUTE_HANDLER;
    }
    if (PER_IS_MSVC_EH(pExcept)) 
    {
        if ( PER_PTHROW(pExcept) == NULL) {
            if (_pCurrentException == NULL)
                return EXCEPTION_CONTINUE_SEARCH;
            pExcept =  _pCurrentException;
        }
        pCatch.pType = (TypeDescriptor *)pType;
        pCatch.adjectives = adjectives;
        SET_HT_ISCOMPLUSEH(pCatch);

        // Scan all types that thrown object can be converted to:
        ppCatchable = THROW_CTLIST(*PER_PTHROW(pExcept));
        for (catchables = THROW_COUNT(*PER_PTHROW(pExcept));
          catchables > 0; catchables--, ppCatchable++) {
 
#if defined(_M_IA64) || defined(_M_AMD64)
            pCatchable = (CatchableType *)(_GetThrowImageBase() + *ppCatchable);
#else
            pCatchable = *ppCatchable;
#endif

            if (TypeMatch(&pCatch, pCatchable, PER_PTHROW(pExcept))) {
                // SucessFull. Now build the object.
                __ProcessingThrow++;
                if (pBuildObj != NULL)
                    BuildCatchObject(pExcept, pBuildObj, &pCatch, pCatchable);
                // We set the current exception.
                if ( PER_PTHROW(*(EHExceptionRecord **)ppExcept) == NULL)
                    *(EHExceptionRecord **)ppExcept = _pCurrentException;
                return EXCEPTION_EXECUTE_HANDLER;
            }
        } // Scan posible conversions
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxRgisterExceptionObject() - Registers Exception Object and saves it to
//                                 This is same as first part of
//                                 CallCatchBlock.
//
extern "C" int __cdecl __CxxRegisterExceptionObject(
    void *ppExcept,
    void *pStorage
)
{
    // This function is only called for C++ EH.
    EHExceptionRecord *pExcept;
    FRAMEINFO *pFrameInfo = (FRAMEINFO *)pStorage;
    EHExceptionRecord **ppSaveException;
    CONTEXT **ppSaveExContext;
    ppSaveException = (EHExceptionRecord **)(&pFrameInfo[1]);
    ppSaveExContext = (CONTEXT **)(&ppSaveException[1]);
    pExcept = *(EHExceptionRecord **)ppExcept;
    pFrameInfo = _CreateFrameInfo(pFrameInfo, PER_PEXCEPTOBJ(pExcept));
    *ppSaveException = _pCurrentException;
    *ppSaveExContext = _pCurrentExContext;
    _pCurrentException = pExcept;
    __ProcessingThrow--;
    if ( __ProcessingThrow < 0)
        __ProcessingThrow = 0;
    return 1;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxDetectRethrow() - Looks at the Exception and returns true if rethrow,
//                        false if not a rethrow. This is then used for
//                        destructing the exception object in
//                        __CxxUnregisterExceptionObject().
//
extern "C" int __cdecl __CxxDetectRethrow(
    void *ppExcept
)
{
    EHExceptionRecord *pExcept;
    if (!ppExcept)
        return 0;
    pExcept = *(EHExceptionRecord **)ppExcept;
    if (PER_IS_MSVC_EH(pExcept) && PER_PTHROW(pExcept) == NULL) {
        *(EHExceptionRecord **)ppExcept = _pCurrentException;
        return 1;
    } else if (*(EHExceptionRecord **)ppExcept == _pCurrentException)
        return 1;
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxUnregisterExceptionObject - Destructs Exception Objects if rethrow ==
//                          true. Also set __pCurrentException and
//                          __pCurrentExContext() to current value.
//
extern "C" void __cdecl __CxxUnregisterExceptionObject(
    void *pStorage,
    int rethrow
)
{
    FRAMEINFO *pFrameInfo = (FRAMEINFO *)pStorage;
    EHExceptionRecord **ppSaveException;
    CONTEXT **ppSaveExContext;
    ppSaveException = (EHExceptionRecord **)(&pFrameInfo[1]);
    ppSaveExContext = (CONTEXT **)(&ppSaveException[1]);
    _FindAndUnlinkFrame(pFrameInfo);
    if ( !rethrow && PER_IS_MSVC_EH(_pCurrentException) && IsExceptionObjectToBeDestroyed(PER_PEXCEPTOBJ(_pCurrentException))) {
        __DestructExceptionObject(_pCurrentException, TRUE);
    }
    _pCurrentException = *ppSaveException;
    _pCurrentExContext = *ppSaveExContext;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxQueryExceptionSize - returns the value of Storage needed to save
//                          FrameInfo + two pointers.
//
extern "C" int __cdecl __CxxQueryExceptionSize(
    void
)
{
    return sizeof(FRAMEINFO) + sizeof(void *) + sizeof(void *);
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxCallUnwindDtor - Calls a destructor during unwind. For COM+, the dtor
//                       call needs to be wrapped inside a __try/__except to
//                       get correct terminate() behavior when an exception 
//                       occurs during the dtor call.
//
extern "C" void __cdecl __CxxCallUnwindDtor(
    void (__thiscall * pDtor)(void*),
    void *pThis
)
{
    __try
    {
        (*pDtor)(pThis);
    }
    __except(FrameUnwindFilter(exception_info()))
    {
    }
}

#endif  // ndef _M_IA64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\ehvecctr.cpp ===
/***
*ehvecctr.cpp - EH-aware version of constructor iterator helper function
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*
*       Must be compiled using "-d1Binl" to be able to specify __thiscall
*       at the user level
*
*Revision History:
*       10-11-93  JDR   Module created
*       05-09-94  BES   Module adapted for CRT source conventions
*       05-13-94  SKS   Remove _CRTIMP modifier
*       10-10-94  CFW   Fix EH/SEH exception handling.
*       10-17-94  BWT   Disable code for PPC.
*       11-09-94  CFW   Back out 10-10-94 change.
*       02-08-95  JWM   Mac merge.
*       04-14-95  JWM   Re-fix EH/SEH exception handling.
*       04-17-95  JWM   Restore non-WIN32 behavior.
*       05-17-99  PML   Remove all Macintosh support.
*       05-20-99  PML   Turn off __thiscall for IA64.
*       07-12-99  RDL   Image relative fixes under CC_P7_SOFT25.
*       03-15-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*
****/

#include <cruntime.h>
#include <eh.h>

#if defined (_M_IX86)
#define CALLTYPE __thiscall
#else
#define CALLTYPE __stdcall
#endif

#ifdef _WIN32

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
);


void __stdcall __ehvec_ctor(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCtor)(void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;      // Count of elements constructed
    int success = 0;

    __try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*pCtor)( ptr );
            ptr = (char*)ptr + size;
        }
        success = 1;
    }
    __finally
    {
        if (!success)
            __ArrayUnwind(ptr, size, i, pDtor);
    }
}

#else

void __stdcall __ehvec_ctor(
    void*       ptr,                // Pointer to array to destruct
    unsigned    size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCtor)(void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;  // Count of elements constructed

    try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*pCtor)( ptr );
            ptr = (char*)ptr + size;
        }
    }
    catch(...)
    {
        // If a constructor throws, unwind the portion of the array thus
        // far constructed.
        for( i--;  i >= 0;  i-- )
        {
            ptr = (char*)ptr - size;
            try {
                (*pDtor)(ptr);
            } 
            catch(...) {
                // If the destructor threw during the unwind, quit
                terminate();
            }
        }

        // Propagate the exception to surrounding frames
        throw;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\hooks.cpp ===
/***
*hooks.cxx - global (per-thread) variables and functions for EH callbacks
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       global (per-thread) variables for assorted callbacks, and
*       the functions that do those callbacks.
*
*       Entry Points:
*
*       * terminate()
*       * unexpected()
*       * _inconsistency()
*
*       External Names: (only for single-threaded version)
*
*       * __pSETranslator
*       * __pTerminate
*       * __pUnexpected
*       * __pInconsistency
*
*Revision History:
*       05-25-93  BS    Module created
*       10-17-94  BWT   Disable code for PPC.
*       02-08-95  JWM   Mac merge.
*       04-13-95  DAK   Add Kernel EH support
*       05-17-99  PML   Remove all Macintosh support.
*       10-22-99  PML   Add EHTRACE support
*       06-20-00  PML   Get rid of unnecessary __try/__finallys.
*
****/

#include <stddef.h>
#include <stdlib.h>
#include <excpt.h>

# if defined(_NTSUBSET_)

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>       // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
}

# endif /* _NTSUBSET_ */

#include <windows.h>
#include <mtdll.h>
#include <eh.h>
#include <ehhooks.h>
#include <ehassert.h>

#pragma hdrstop

/////////////////////////////////////////////////////////////////////////////
//
// The global variables:
//

#ifndef _MT
_se_translator_function __pSETranslator = NULL;
terminate_function      __pTerminate    = NULL;
unexpected_function     __pUnexpected   = &terminate;
#endif // !_MT

_inconsistency_function __pInconsistency= &terminate;

/////////////////////////////////////////////////////////////////////////////
//
// terminate - call the terminate handler (presumably we went south).
//              THIS MUST NEVER RETURN!
//
// Open issues:
//      * How do we guarantee that the whole process has stopped, and not just
//        the current thread?
//

_CRTIMP void __cdecl terminate(void)
{
        EHTRACE_ENTER_MSG("No exit");

        //
        // Let the user wrap things up their way.
        //
        if ( __pTerminate ) {
            __try {
                __pTerminate();
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // Intercept ANY exception from the terminate handler
                //
            }
        }

        //
        // If the terminate handler returned, faulted, or otherwise failed to
        // halt the process/thread, we'll do it.
        //
# if defined(_NTSUBSET_)
        KeBugCheck( (ULONG) STATUS_UNHANDLED_EXCEPTION );
# else
        abort();
# endif
}

/////////////////////////////////////////////////////////////////////////////
//
// unexpected - call the unexpected handler (presumably we went south, or nearly).
//              THIS MUST NEVER RETURN!
//
// Open issues:
//      * How do we guarantee that the whole process has stopped, and not just
//        the current thread?
//

void __cdecl unexpected(void)
{
        EHTRACE_ENTER;

        //
        // Let the user wrap things up their way.
        //
        if ( __pUnexpected )
            __pUnexpected();

        //
        // If the unexpected handler returned, we'll give the terminate handler a chance.
        //
        terminate();
}

/////////////////////////////////////////////////////////////////////////////
//
// _inconsistency - call the inconsistency handler (Run-time processing error!)
//                THIS MUST NEVER RETURN!
//
// Open issues:
//      * How do we guarantee that the whole process has stopped, and not just
//        the current thread?
//

void __cdecl _inconsistency(void)
{
        EHTRACE_ENTER;

        //
        // Let the user wrap things up their way.
        //
        if ( __pInconsistency )
            __try {
                __pInconsistency();
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // Intercept ANY exception from the terminate handler
                //
            }

        //
        // If the inconsistency handler returned, faulted, or otherwise
        // failed to halt the process/thread, we'll do it.
        //
        terminate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\oldexcpt.h ===
/***
*oldexcpt.h - User include file for standard exception classes (old version)
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file presents an interface to the standard exception classes,
*       as specified by the ANSI X3J16/ISO SC22/WG21 Working Paper for
*       Draft C++, May 1994.
*
*       [Public]
*
*Revision History:
*       11-15-94  JWM   Made logic & exception classes _CRTIMP
*       11-21-94  JWM   xmsg typedef now #ifdef __RTTI_OLDNAMES
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers, protect with _INC_STDEXCPT.
*       02-14-95  CFW   Clean up Mac merge.
*       02-15-95  JWM   Minor cleanups related to Olympus bug 3716.
*       07-02-95  JWM   Now generally ANSI-compliant; excess baggage removed.
*       12-14-95  JWM   Add "#pragma once".
*       03-04-96  JWM   Replaced by C++ header "exception".
*       01-05-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_STDEXCPT
#define _INC_STDEXCPT

#if !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif /* _CRTBLD */

/**
 *      #ifdef __cplusplus
 *
 *      #include <exception>
 *
 *      #elif 0
**/

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif


//
// Standard exception class heirarchy (ref. 1/94 WP 17.3.2.1, as ammended 3/94).
//
// exception (formerly xmsg)
//   logic
//     domain
//   runtime
//     range
//     alloc
//       xalloc
//
// Updated as per May'94 Working Paper

typedef const char *__exString;

class _CRTIMP exception
{
public:
    exception();
    exception(const __exString&);
    exception(const exception&);
    exception& operator= (const exception&);
    virtual ~exception();
    virtual __exString what() const;
private:
    __exString _m_what;
    int _m_doFree;
};

#ifdef __RTTI_OLDNAMES
typedef exception xmsg;        // A synonym for folks using older standard
#endif

//
//  logic_error
//
class _CRTIMP logic_error: public exception 
{
public:
    logic_error (const __exString& _what_arg) : exception(_what_arg) {}
};

/**
 *      #endif  /-* ndef __cplusplus *-/
**/

#endif  /* _INC_STDEXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\rtti.cpp ===
/***
*rtti.cxx - C++ runtime type information
*
*       Copyright (c) 1994-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Implementation of C++ standard runtime type information
*
*Revision History:
*       10-17-94  JWM   File created.
*       10-17-94  BWT   Disable code for PPC.
*       11-11-94  JWM   Now includes windows.h
*       12-01-94  JWM   Added optimized cases for single & multiple inheritance
*       02-03-95  JWM   FindVITargetTypeInstance() now checks offsets to
*                       determine ambiguity, not pointer equality
*       02-09-95  JWM   Mac merge.
*       03-22-95  PML   Add const for read-only compiler-gen'd structs
*       05-03-95  JWM   Test visibility in FindSITargetTypeInstance().
*       08-28-95  JWM   dynamic-cast of NULL ptr now returns NULL (bug 502).
*       05-10-99  PML   Win64 fix: int -> ptrdiff_t
*       05-17-99  PML   Remove all Macintosh support.
*       10-19-99  TGL   Win64 fix: ptrdiff_t -> __int32 in PMDtoOffset.
*       03-15-00  PML   Remove CC_P7_SOFT25.
*       04-21-00  PML   Add exception specifications to extern "C" helpers.
*       08-23-00  PML   IA64 fix: _ImageBase can't be a static global, since
*                       that's not thread-safe (VS7#154575).
*       08-28-00  PML   IA64 fix: _ImageBase needs to be set from the address
*                       of the _RTTICompleteObjectLocator, not the return
*                       address (VS7#156255)
*       09-07-00  PML   Get rid of /lib:libcp directive in obj (vs7#159463)
*
****/

#define _USE_ANSI_CPP   /* Don't emit /lib:libcp directive */

#include <windows.h>
#include <rtti.h>
#include <typeinfo.h>

#if defined(_M_IA64)
static unsigned __int64 GetImageBase(PVOID);
#undef BCD_PTD
#undef CHD_PBCA
#undef CHD_PBCD
#undef COL_PTD
#undef COL_PCHD
#define BCD_PTD(bcd)    BCD_PTD_IB((bcd),_ImageBase)
#define CHD_PBCA(chd)   CHD_PBCA_IB((chd),_ImageBase)
#define CHD_PBCD(chd)   CHD_PBCD_IB((chd),_ImageBase)
#define COL_PTD(col)    COL_PTD_IB((col),_ImageBase) 
#define COL_PCHD(col)   COL_PCHD_IB((col),_ImageBase)
extern "C" PVOID RtlPcToFileHeader(PVOID, PVOID*);
#endif

static PVOID __cdecl FindCompleteObject(PVOID *);
static _RTTIBaseClassDescriptor * __cdecl
    FindSITargetTypeInstance(PVOID,
                             _RTTICompleteObjectLocator *,
                             _RTTITypeDescriptor *,
                             ptrdiff_t,
                             _RTTITypeDescriptor *
#if defined(_M_IA64)
                             , unsigned __int64
#endif
                             );
static _RTTIBaseClassDescriptor * __cdecl
    FindMITargetTypeInstance(PVOID,
                             _RTTICompleteObjectLocator *,
                             _RTTITypeDescriptor *,
                             ptrdiff_t,
                             _RTTITypeDescriptor *
#if defined(_M_IA64)
                             , unsigned __int64
#endif
                             );
static _RTTIBaseClassDescriptor * __cdecl
    FindVITargetTypeInstance(PVOID,
                             _RTTICompleteObjectLocator *,
                             _RTTITypeDescriptor *,
                             ptrdiff_t,
                             _RTTITypeDescriptor *
#if defined(_M_IA64)
                             , unsigned __int64
#endif
                             );
static ptrdiff_t __cdecl PMDtoOffset(PVOID, const PMD&);

/////////////////////////////////////////////////////////////////////////////
//
// __RTCastToVoid - Implements dynamic_cast<void*>
//
// Output: Pointer to complete object containing *inptr
//
// Side-effects: NONE.
//

extern "C" PVOID __cdecl __RTCastToVoid (
    PVOID inptr)            // Pointer to polymorphic object
    throw(...)
{
    if (inptr == NULL)
        return NULL;

    __try {
        return FindCompleteObject((PVOID *)inptr);
    }
    __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
              ? EXCEPTION_EXECUTE_HANDLER: EXCEPTION_CONTINUE_SEARCH)
    {
        throw __non_rtti_object ("Access violation - no RTTI data!");
        return NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// __RTtypeid - Implements typeid() operator
//
// Output: Pointer to type descriptor of complete object containing *inptr
//
// Side-effects: NONE.
//

extern "C" PVOID __cdecl __RTtypeid (
    PVOID inptr)            // Pointer to polymorphic object
    throw(...)
{
    if (!inptr) {
        throw bad_typeid ("Attempted a typeid of NULL pointer!");   // WP 5.2.7
        return NULL;
    }

    __try {
        // Ptr to CompleteObjectLocator should be stored at vfptr[-1]
        _RTTICompleteObjectLocator *pCompleteLocator =
            (_RTTICompleteObjectLocator *) ((*((void***)inptr))[-1]);
#if defined(_M_IA64)
        unsigned __int64 _ImageBase = GetImageBase((PVOID)pCompleteLocator);
#endif

        if (!IsBadReadPtr((const void *)COL_PTD(*pCompleteLocator),
                          sizeof(TypeDescriptor)))
        {
            return (PVOID) COL_PTD(*pCompleteLocator);
        }
        else {
            throw __non_rtti_object ("Bad read pointer - no RTTI data!");
            return NULL;
        }
    }
    __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
              ? EXCEPTION_EXECUTE_HANDLER: EXCEPTION_CONTINUE_SEARCH)
    {
        throw __non_rtti_object ("Access violation - no RTTI data!");
        return NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// __RTDynamicCast - Runtime implementation of dynamic_cast<> operator
//
// Output: Pointer to the appropriate sub-object, if possible; NULL otherwise
//
// Side-effects: Throws bad_cast() if cast fails & input of dynamic_cast<> is
// a reference
//

extern "C" PVOID __cdecl __RTDynamicCast (
    PVOID inptr,            // Pointer to polymorphic object
    LONG VfDelta,           // Offset of vfptr in object
    PVOID SrcType,          // Static type of object pointed to by inptr
    PVOID TargetType,       // Desired result of cast
    BOOL isReference)       // TRUE if input is reference, FALSE if input is ptr
    throw(...)
{
    PVOID pResult;
    _RTTIBaseClassDescriptor *pBaseClass;

    if (inptr == NULL)
            return NULL;

    __try {

        PVOID pCompleteObject = FindCompleteObject((PVOID *)inptr);
        _RTTICompleteObjectLocator *pCompleteLocator =
            (_RTTICompleteObjectLocator *) ((*((void***)inptr))[-1]);
#if defined(_M_IA64)
        unsigned __int64 _ImageBase = GetImageBase((PVOID)pCompleteLocator);
#endif

        // Adjust by vfptr displacement, if any
        inptr = (PVOID *) ((char *)inptr - VfDelta);

        // Calculate offset of source object in complete object
        ptrdiff_t inptr_delta = (char *)inptr - (char *)pCompleteObject;

        if (!(CHD_ATTRIBUTES(*COL_PCHD(*pCompleteLocator)) & CHD_MULTINH)) {
            // if not multiple inheritance
            pBaseClass = FindSITargetTypeInstance(
                            pCompleteObject,
                            pCompleteLocator,
                            (_RTTITypeDescriptor *) SrcType,
                            inptr_delta,
                            (_RTTITypeDescriptor *) TargetType
#if defined(_M_IA64)
                            , _ImageBase
#endif
                            );
        }
        else if (!(CHD_ATTRIBUTES(*COL_PCHD(*pCompleteLocator)) & CHD_VIRTINH)) {
            // if multiple, but not virtual, inheritance
            pBaseClass = FindMITargetTypeInstance(
                            pCompleteObject,
                            pCompleteLocator,
                            (_RTTITypeDescriptor *) SrcType,
                            inptr_delta,
                            (_RTTITypeDescriptor *) TargetType
#if defined(_M_IA64)
                            , _ImageBase
#endif
                            );
        }
        else {
            // if virtual inheritance
            pBaseClass = FindVITargetTypeInstance(
                            pCompleteObject,
                            pCompleteLocator,
                            (_RTTITypeDescriptor *) SrcType,
                            inptr_delta,
                            (_RTTITypeDescriptor *) TargetType
#if defined(_M_IA64)
                            , _ImageBase
#endif
                            );
        }

        if (pBaseClass != NULL) {
            // Calculate ptr to result base class from pBaseClass->where
            pResult = ((char *) pCompleteObject) +
                      PMDtoOffset(pCompleteObject, pBaseClass->where);
        }
        else {
            pResult = NULL;
            if (isReference)
                throw bad_cast("Bad dynamic_cast!");
        }

    }
    __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
              ? EXCEPTION_EXECUTE_HANDLER: EXCEPTION_CONTINUE_SEARCH)
    {
        pResult = NULL;
        throw __non_rtti_object ("Access violation - no RTTI data!");
    }

    return pResult;
}


/////////////////////////////////////////////////////////////////////////////
//
// FindCompleteObject - Calculate member offset from PMD & this
//
// Output: pointer to the complete object containing class *inptr
//
// Side-effects: NONE.
//

static PVOID __cdecl FindCompleteObject (
    PVOID *inptr)           // Pointer to polymorphic object
{
    // Ptr to CompleteObjectLocator should be stored at vfptr[-1]
    _RTTICompleteObjectLocator *pCompleteLocator =
        (_RTTICompleteObjectLocator *) ((*((void***)inptr))[-1]);
    char *pCompleteObject = (char *)inptr - pCompleteLocator->offset;

    // Adjust by construction displacement, if any
    if (pCompleteLocator->cdOffset)
        pCompleteObject += *(ptrdiff_t *)((char *)inptr - pCompleteLocator->cdOffset);
    return (PVOID) pCompleteObject;
}


/////////////////////////////////////////////////////////////////////////////
//
// FindSITargetTypeInstance - workhorse routine of __RTDynamicCast() in a
// Single-Inheritance hierarchy
//
// Output: pointer to the appropriate sub-object of targetted type; NULL if
// cast fails
//
// Side-effects: NONE.
//

static _RTTIBaseClassDescriptor * __cdecl FindSITargetTypeInstance (
    PVOID pCompleteObject,                  // pointer to complete object
    _RTTICompleteObjectLocator *pCOLocator, // pointer to Locator of complete object
    _RTTITypeDescriptor *pSrcTypeID,        // pointer to TypeDescriptor of source object
    ptrdiff_t SrcOffset,                    // offset of source object in complete object
    _RTTITypeDescriptor *pTargetTypeID      // pointer to TypeDescriptor of result of cast
#if defined(_M_IA64)
    , unsigned __int64 _ImageBase
#endif
    )
{
    _RTTIBaseClassDescriptor *pBase;
#if defined(_M_IA64)
    _RTTIBaseClassArray *pBaseClassArray;
#else
    _RTTIBaseClassDescriptor * const *pBasePtr;
#endif
    DWORD i;

#if defined(_M_IA64)
    for (i = 0, pBaseClassArray = CHD_PBCA(*COL_PCHD(*pCOLocator));
         i < CHD_NUMBASES(*COL_PCHD(*pCOLocator));
         i++)
    {
        pBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i]);

        // Test type of selected base class
        if (TYPEIDS_EQ(BCD_PTD(*pBase), pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE))
        {
                return pBase;
        }
    }
#else
    for (i = 0, pBasePtr = pCOLocator->pClassDescriptor->
                                       pBaseClassArray->
                                       arrayOfBaseClassDescriptors;
         i < pCOLocator->pClassDescriptor->numBaseClasses;
         i++, pBasePtr++)
    {
        pBase = *pBasePtr;

        // Test type of selected base class
        if (TYPEIDS_EQ(pBase->pTypeDescriptor, pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE))
        {
                return pBase;
        }
    }
#endif
    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// FindMITargetTypeInstance - workhorse routine of __RTDynamicCast() in a
// Multiple-Inheritance hierarchy
//
// Output: pointer to the appropriate sub-object of targetted type; NULL if
// cast fails
//
// Side-effects: NONE.
//

static _RTTIBaseClassDescriptor * __cdecl FindMITargetTypeInstance (
    PVOID pCompleteObject,                  // pointer to complete object
    _RTTICompleteObjectLocator *pCOLocator, // pointer to Locator of complete object
    _RTTITypeDescriptor *pSrcTypeID,        // pointer to TypeDescriptor of source object
    ptrdiff_t SrcOffset,                    // offset of source object in complete object
    _RTTITypeDescriptor *pTargetTypeID      // pointer to TypeDescriptor of result of cast
#if defined(_M_IA64)
    , unsigned __int64 _ImageBase
#endif
    )
{
    _RTTIBaseClassDescriptor *pBase, *pSubBase;
#if defined(_M_IA64)
    _RTTIBaseClassArray *pBaseClassArray;
#else
    _RTTIBaseClassDescriptor * const *pBasePtr, * const *pSubBasePtr;
#endif
    DWORD i, j;

#if defined(_M_IA64)
    // First, try down-casts
    for (i = 0, pBaseClassArray = CHD_PBCA(*COL_PCHD(*pCOLocator));
         i < CHD_NUMBASES(*COL_PCHD(*pCOLocator));
         i++)
    {
        pBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i]);

        // Test type of selected base class
        if (TYPEIDS_EQ(BCD_PTD(*pBase), pTargetTypeID)) {
            // If base class is proper type, see if it contains our instance
            // of source class
            for (j = 0;
                 j < pBase->numContainedBases;
                 j++)
            {
                pSubBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i+1+j]);
                if (TYPEIDS_EQ(BCD_PTD(*pSubBase), pSrcTypeID) &&
                    (PMDtoOffset(pCompleteObject, pSubBase->where) == SrcOffset))
                {
                    // Yes, this is the proper instance of source class
                    return pBase;
                }
            }
        }
    }

    // Down-cast failed, try cross-cast
    for (i = 0, pBaseClassArray = CHD_PBCA(*COL_PCHD(*pCOLocator));
         i < CHD_NUMBASES(*COL_PCHD(*pCOLocator));
         i++)
    {
        pBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i]);

        // Check if base class has proper type, is accessible & is unambiguous
        if (TYPEIDS_EQ(BCD_PTD(*pBase), pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_AMBIGUOUS))
        {
            return pBase;
        }
    }
#else
    // First, try down-casts
    for (i = 0, pBasePtr = pCOLocator->pClassDescriptor->
                                       pBaseClassArray->
                                       arrayOfBaseClassDescriptors;
         i < pCOLocator->pClassDescriptor->numBaseClasses;
         i++, pBasePtr++)
    {
        pBase = *pBasePtr;

        // Test type of selected base class
        if (TYPEIDS_EQ(pBase->pTypeDescriptor, pTargetTypeID)) {
            // If base class is proper type, see if it contains our instance
            // of source class
            for (j = 0, pSubBasePtr = pBasePtr+1;
                 j < pBase->numContainedBases;
                 j++, pSubBasePtr++)
            {
                pSubBase = *pSubBasePtr;
                if (TYPEIDS_EQ(pSubBase->pTypeDescriptor, pSrcTypeID) &&
                    (PMDtoOffset(pCompleteObject, pSubBase->where) == SrcOffset))
                {
                    // Yes, this is the proper instance of source class
                    return pBase;
                }
            }
        }
    }

    // Down-cast failed, try cross-cast
    for (i = 0, pBasePtr = pCOLocator->pClassDescriptor->
                                       pBaseClassArray->
                                       arrayOfBaseClassDescriptors;
         i < pCOLocator->pClassDescriptor->numBaseClasses;
         i++, pBasePtr++)
    {
        pBase = *pBasePtr;

        // Check if base class has proper type, is accessible & is unambiguous
        if (TYPEIDS_EQ(pBase->pTypeDescriptor, pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_AMBIGUOUS))
        {
            return pBase;
        }
    }
#endif

    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// FindVITargetTypeInstance - workhorse routine of __RTDynamicCast() in a
// Virtual-Inheritance hierarchy
//
// Output: pointer to the appropriate sub-object of targetted type; NULL if
// cast fails
//
// Side-effects: NONE.
//

static _RTTIBaseClassDescriptor * __cdecl FindVITargetTypeInstance (
    PVOID pCompleteObject,                  // pointer to complete object
    _RTTICompleteObjectLocator *pCOLocator, // pointer to Locator of complete object
    _RTTITypeDescriptor *pSrcTypeID,        // pointer to TypeDescriptor of source object
    ptrdiff_t SrcOffset,                    // offset of source object in complete object
    _RTTITypeDescriptor *pTargetTypeID      // pointer to TypeDescriptor of result of cast
#if defined(_M_IA64)
    , unsigned __int64 _ImageBase
#endif
    )
{
    _RTTIBaseClassDescriptor *pBase, *pSubBase;
#if defined(_M_IA64)
    _RTTIBaseClassArray *pBaseClassArray;
#else
    _RTTIBaseClassDescriptor * const *pBasePtr, * const *pSubBasePtr;
#endif
    _RTTIBaseClassDescriptor *pResult = NULL;
    DWORD i, j;

#if defined(_M_IA64)
    for (i = 0, pBaseClassArray = CHD_PBCA(*COL_PCHD(*pCOLocator));
         i < CHD_NUMBASES(*COL_PCHD(*pCOLocator));
         i++)
    {
        pBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i]);

        // Test type of selected base class
        if (TYPEIDS_EQ(BCD_PTD(*pBase), pTargetTypeID)) {
            // If base class is proper type, see if it contains our instance
            // of source class
            for (j = 0;
                 j < pBase->numContainedBases;
                 j++)
            {
                pSubBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i+1+j]);
                if (TYPEIDS_EQ(BCD_PTD(*pSubBase), pSrcTypeID) &&
                    (PMDtoOffset(pCompleteObject, pSubBase->where) == SrcOffset))
                {
                    // Yes, this is the proper instance of source class - make
                    // sure it is unambiguous.  Ambiguity now determined by
                    // inequality of offsets of source class within complete
                    // object, not pointer inequality
                    if ((pResult != NULL) &&
                        (PMDtoOffset(pCompleteObject, pResult->where) != 
                         PMDtoOffset(pCompleteObject, pBase->where)))
                    {
                        // We already found an earlier instance, hence
                        // ambiguity
                        return NULL;
                    }
                    else {
                        // Unambiguous
                        pResult = pBase;
                    }
                }
            }
        }
    }

    if (pResult != NULL)
        return pResult;

    // Down-cast failed, try cross-cast
    for (i = 0, pBaseClassArray = CHD_PBCA(*COL_PCHD(*pCOLocator));
         i < CHD_NUMBASES(*COL_PCHD(*pCOLocator));
         i++)
    {
        pBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i]);

        // Check if base class has proper type, is accessible & is unambiguous
        if (TYPEIDS_EQ(BCD_PTD(*pBase), pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_AMBIGUOUS))
        {
            return pBase;
        }
    }
#else
    // First, try down-casts
    for (i = 0, pBasePtr = pCOLocator->pClassDescriptor->
                                       pBaseClassArray->
                                       arrayOfBaseClassDescriptors;
         i < pCOLocator->pClassDescriptor->numBaseClasses;
         i++, pBasePtr++)
    {
        pBase = *pBasePtr;

        // Test type of selected base class
        if (TYPEIDS_EQ(pBase->pTypeDescriptor, pTargetTypeID)) {
            // If base class is proper type, see if it contains our instance
            // of source class
            for (j = 0, pSubBasePtr = pBasePtr+1;
                 j < pBase->numContainedBases;
                 j++, pSubBasePtr++)
            {
                pSubBase = *pSubBasePtr;
                if (TYPEIDS_EQ(pSubBase->pTypeDescriptor, pSrcTypeID) &&
                    (PMDtoOffset(pCompleteObject, pSubBase->where) == SrcOffset))
                {
                    // Yes, this is the proper instance of source class - make
                    // sure it is unambiguous.  Ambiguity now determined by
                    // inequality of offsets of source class within complete
                    // object, not pointer inequality
                    if ((pResult != NULL) &&
                        (PMDtoOffset(pCompleteObject, pResult->where) != 
                         PMDtoOffset(pCompleteObject, pBase->where)))
                    {
                        // We already found an earlier instance, hence
                        // ambiguity
                        return NULL;
                    }
                    else {
                        // Unambiguous
                        pResult = pBase;
                    }
                }
            }
        }
    }

    if (pResult != NULL)
        return pResult;

    // Down-cast failed, try cross-cast
    for (i = 0, pBasePtr = pCOLocator->pClassDescriptor->
                                       pBaseClassArray->
                                       arrayOfBaseClassDescriptors;
         i < pCOLocator->pClassDescriptor->numBaseClasses;
         i++, pBasePtr++)
    {
        pBase = *pBasePtr;

        // Check if base class has proper type, is accessible & is unambiguous
        if (TYPEIDS_EQ(pBase->pTypeDescriptor, pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_AMBIGUOUS))
        {
            return pBase;
        }
    }
#endif

    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// PMDtoOffset - Calculate member offset from PMD & this
//
// Output: The offset of the base within the complete object.
//
// Side-effects: NONE.
//

static ptrdiff_t __cdecl PMDtoOffset(
    PVOID pThis,            // ptr to complete object
    const PMD& pmd)         // pointer-to-member-data structure
{
    ptrdiff_t RetOff = 0;

    if (pmd.pdisp >= 0) {
        // if base is in the virtual part of class
        RetOff = pmd.pdisp;
        RetOff += *(__int32*)((char*)*(ptrdiff_t*)((char*)pThis + RetOff) +
                                pmd.vdisp);
    }

    RetOff += pmd.mdisp;

    return RetOff;
}

#if defined(_M_IA64)
static unsigned __int64 GetImageBase(PVOID pCallerPC)
{
    unsigned __int64 _ImageBase;
    _ImageBase = (unsigned __int64)RtlPcToFileHeader(
        pCallerPC,
        (PVOID*)&_ImageBase);
    return _ImageBase;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\stdnewh.cpp ===
/***
*stdnewh.cpp - A 'new_handler' that throws xalloc
*
*	Copyright (c) 1994-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Implementation of default 'new_handler', as specified in
*	[lib.set.new.handler] (section 17.3.3.2 of 1/25/94 WP).
*
*Revision History:
*	04-27-94  BES   Module created.
*	10-17-94  BWT	Disable code for PPC.
*
*******************************************************************************/

#include <eh.h>
#include <stdlib.h>
#include <stdexcpt.h>

int __cdecl _standard_new_handler ( size_t )
{
	static xalloc ex;

	ex.raise();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\oldexcpt.cpp ===
/***
*oldexcpt.cpp - defines C++ standard exception classes
*
*       Copyright (c) 1994-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Implementation of C++ standard exception classes, as specified in
*       [lib.header.exception] (section 17.3.2 of 5/27/94 WP):
*
*        exception (formerly xmsg)
*          logic
*            domain
*          runtime
*            range
*            alloc
*
*Revision History:
*       04-27-94  BES   Module created.
*       10-17-94  BWT   Disable code for PPC.
*       02-15-95  JWM   Minor cleanups related to Olympus bug 3716
*       07-02-95  JWM   Now generally ANSI-compliant; excess baggage removed.
*       01-05-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <eh.h>
#include "./oldexcpt.h"

////////////////////////////////////////////////////////////////////////////////
//
// Implementation of class "exception"
//

//
// Default constructor - initialize to blank
//
exception::exception ()
{
        _m_what = NULL;
        _m_doFree = 0;
}

//
// Standard constructor: initialize with copy of string
//
exception::exception ( const __exString& what )
{
        _m_what = new char[(unsigned int)strlen(what)+1];
        if ( _m_what != NULL )
            strcpy( (char*)_m_what, what );
        _m_doFree = 1;
}

//
// Copy constructor
//
exception::exception ( const exception & that )
{
        _m_doFree = that._m_doFree;
        if (_m_doFree)
        {
            _m_what = new char[(unsigned int)strlen(that._m_what) + 1];
            if (_m_what != NULL)
                strcpy( (char*)_m_what, that._m_what );
        }
        else
           _m_what = that._m_what;
}

//
// Assignment operator: destruct, then copy-construct
//
exception& exception::operator=( const exception& that )
{
        if (this != &that)
        {
            this->exception::~exception();
            this->exception::exception(that);
        }
        return *this;
}

//
// Destructor: free the storage used by the message string if it was
// dynamicly allocated
//
exception::~exception()
{
        if (_m_doFree)
            delete[] (char*)_m_what;
}


//
// exception::what
//  Returns the message string of the exception.
//  Default implementation of this method returns the stored string if there
//  is one, otherwise returns a standard string.
//
__exString exception::what() const
{
        if ( _m_what != NULL )
            return _m_what;
        else
            return "Unknown exception";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\stdexcpt.cpp ===
/***
*stdexcpt.cpp - defines C++ standard exception classes
*
*       Copyright (c) 1994-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Implementation of C++ standard exception classes which must live in
*       the main CRT, not the C++ CRT, because they are referenced by RTTI
*       support in the main CRT.
*
*        exception
*          bad_cast
*          bad_typeid
*            __non_rtti_object
*
*Revision History:
*       04-27-94  BES   Module created.
*       10-17-94  BWT   Disable code for PPC.
*       02-15-95  JWM   Minor cleanups related to Olympus bug 3716
*       07-02-95  JWM   Now generally ANSI-compliant; excess baggage removed.
*       06-01-99  PML   __exString disappeared as of 5/3/99 Plauger STL drop.
*       11-09-99  PML   Use malloc, not new, to avoid recursion (vs7#16826).
*       09-07-00  PML   Get rid of /lib:libcp directive in obj (vs7#159463)
*       03-21-01  PML   Move bad_cast, bad_typeid, __non_rtti_object function
*                       defs out of typeinfo.h so _STATIC_CPPLIB will work.
*
*******************************************************************************/

#define _USE_ANSI_CPP   /* Don't emit /lib:libcp directive */

#include <stdlib.h>
#include <string.h>
#include <eh.h>
#include <stdexcpt.h>
#include <typeinfo.h>

////////////////////////////////////////////////////////////////////////////////
//
// Implementation of class "exception"
//

//
// Default constructor - initialize to blank
//
exception::exception ()
{
        _m_what = NULL;
        _m_doFree = 0;
}

//
// Standard constructor: initialize with copy of string
//
exception::exception ( const char * const & what )
{
        _m_what = static_cast< char * >( malloc( strlen( what ) + 1 ) );
        if ( _m_what != NULL )
            strcpy( (char*)_m_what, what );
        _m_doFree = 1;
}

//
// Copy constructor
//
exception::exception ( const exception & that )
{
        _m_doFree = that._m_doFree;
        if (_m_doFree)
        {
            _m_what = static_cast< char * >( malloc( strlen( that._m_what ) + 1 ) );
            if (_m_what != NULL)
                strcpy( (char*)_m_what, that._m_what );
        }
        else
           _m_what = that._m_what;
}

//
// Assignment operator: destruct, then copy-construct
//
exception& exception::operator=( const exception& that )
{
        if (this != &that)
        {
            this->exception::~exception();
            this->exception::exception(that);
        }
        return *this;
}

//
// Destructor: free the storage used by the message string if it was
// dynamicly allocated
//
exception::~exception()
{
        if (_m_doFree)
            free( const_cast< char * >( _m_what ) );
}


//
// exception::what
//  Returns the message string of the exception.
//  Default implementation of this method returns the stored string if there
//  is one, otherwise returns a standard string.
//
const char * exception::what() const
{
        if ( _m_what != NULL )
            return _m_what;
        else
            return "Unknown exception";
}

////////////////////////////////////////////////////////////////////////////////
//
// Implementation of class "bad_cast"
//

bad_cast::bad_cast(const char * _Message)
    : exception(_Message)
{
}

bad_cast::bad_cast(const bad_cast & that)
    : exception(that)
{
}

bad_cast::~bad_cast()
{
}

#ifdef CRTDLL
//
// This is a dummy constructor.  Previously, the only bad_cast ctor was
// bad_cast(const char * const &).  To provide backwards compatibility
// for std::bad_cast, we want the main ctor to be bad_cast(const char *)
// instead.  Since you can't have both bad_cast(const char * const &) and
// bad_cast(const char *), we define this bad_cast(const char * const *),
// which will have the exact same codegen as bad_cast(const char * const &),
// and alias the old form with a .def entry.
//
bad_cast::bad_cast(const char * const * _PMessage)
    : exception(*_PMessage)
{
}
#endif

////////////////////////////////////////////////////////////////////////////////
//
// Implementation of class "bad_typeid"
//

bad_typeid::bad_typeid(const char * _Message)
    : exception(_Message)
{
}

bad_typeid::bad_typeid(const bad_typeid & that)
    : exception(that)
{
}

bad_typeid::~bad_typeid()
{
}

////////////////////////////////////////////////////////////////////////////////
//
// Implementation of class "__non_rtti_object"
//

__non_rtti_object::__non_rtti_object(const char * _Message)
    : bad_typeid(_Message)
{
}

__non_rtti_object::__non_rtti_object(const __non_rtti_object & that)
    : bad_typeid(that)
{
}

__non_rtti_object::~__non_rtti_object()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\throw.cpp ===
/***
*throw.cxx - Implementation of the 'throw' command.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Implementation of the exception handling 'throw' command.
*
*       Entry points:
*       * _CxxThrowException - does the throw.
*
*Revision History:
*       05-25-93  BS    Module created
*       09-29-94  GJF   Made (__)pMyUnhandledExceptionFilter global so the
*                       compiler (DEC Alpha) wouldn't optimize it away.
*       10-17-94  BWT   Disable code for PPC.
*       02-03-95  BWT   Remove Alpha export hack.
*       02-09-95  JWM   Mac merge.
*       04-13-95  DAK   Add NT Kernel EH support
*       04-25-95  DAK   More Kernel work
*       03-02-98  RKP   Add 64 bit support
*       05-17-99  PML   Remove all Macintosh support.
*       03-15-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*
****/

#include <stddef.h>

#if defined(_NTSUBSET_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>       // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
#include <ex.h>             // ExRaiseException
}
#endif

#include <windows.h>
#include <mtdll.h>
#include <ehdata.h>
#include <eh.h>
#include <ehhooks.h>
#include <ehassert.h>


#pragma hdrstop

//
// Make sure PULONG_PTR is available
//

#if defined(_X86_) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif

#if !defined(PULONG_PTR)
#if defined(_WIN64)
typedef unsigned __int64 *      PULONG_PTR;
#else
typedef _W64 unsigned long *    PULONG_PTR;
#endif
#endif

#if defined(_M_IA64) || defined(_M_AMD64)
extern "C" PVOID RtlPcToFileHeader(PVOID, PVOID*);
extern "C" PVOID _ReturnAddress(VOID);
#pragma intrinsic(_ReturnAddress)
#endif

//
// Make sure the terminate wrapper is dragged in:
//

#if defined(_NTSUBSET_)
void * __pMyUnhandledExceptionFilter = 0;
#else
void * __pMyUnhandledExceptionFilter = &__CxxUnhandledExceptionFilter;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// _CxxThrowException - implementation of 'throw'
//
// Description:
//      Builds the NT Exception record, and calls the NT runtime to initiate
//      exception processing.
//
//      Why is pThrowInfo defined as _ThrowInfo?  Because _ThrowInfo is secretly
//      snuck into the compiler, as is the prototype for _CxxThrowException, so
//      we have to use the same type to keep the compiler happy.
//
//      Another result of this is that _CRTIMP can't be used here.  Instead, we
//      synthesisze the -export directive below.
//
// Returns:
//      NEVER.  (until we implement resumable exceptions, that is)
//

extern "C" void __stdcall _CxxThrowException(
        void*           pExceptionObject,   // The object thrown
#if _MSC_VER >= 900 /*IFSTRIP=IGN*/
        _ThrowInfo*     pThrowInfo          // Everything we need to know about it
#else
        ThrowInfo*      pThrowInfo          // Everything we need to know about it
#endif
) {
        EHTRACE_ENTER_FMT1("Throwing object @ 0x%p", pExceptionObject);

        static const EHExceptionRecord ExceptionTemplate = { // A generic exception record
            EH_EXCEPTION_NUMBER,            // Exception number
            EXCEPTION_NONCONTINUABLE,       // Exception flags (we don't do resume)
            NULL,                           // Additional record (none)
            NULL,                           // Address of exception (OS fills in)
            EH_EXCEPTION_PARAMETERS,        // Number of parameters
            {   EH_MAGIC_NUMBER1,           // Our version control magic number
                NULL,                       // pExceptionObject
                NULL,
#if defined(_M_IA64) || defined (_M_AMD64)
                NULL                        // Image base of thrown object
#endif
            }                      // pThrowInfo
        };
        EHExceptionRecord ThisException = ExceptionTemplate;    // This exception

        //
        // Fill in the blanks:
        //
        ThisException.params.pExceptionObject = pExceptionObject;
        ThisException.params.pThrowInfo = (ThrowInfo*)pThrowInfo;
#if defined(_M_IA64) || defined(_M_AMD64)
        PVOID ThrowImageBase = RtlPcToFileHeader(_ReturnAddress(), &ThrowImageBase); 
        ThisException.params.pThrowImageBase = ThrowImageBase;
#endif

        //
        // Hand it off to the OS:
        //

        EHTRACE_EXIT;

#if defined(_M_AMD64)
        RtlRaiseException( (PEXCEPTION_RECORD) &ThisException );
#else
#if defined(_NTSUBSET_)
        ExRaiseException( (PEXCEPTION_RECORD) &ThisException );
#else
        RaiseException( ThisException.ExceptionCode,
                        ThisException.ExceptionFlags,
                        ThisException.NumberParameters,
                        (PULONG_PTR)&ThisException.params );
#endif
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\typinfo.cpp ===
/***
*typeinfo.cpp - Implementation of type_info for RTTI.
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module provides an implementation of the class type_info
*	for Run-Time Type Information (RTTI).
*
*Revision History:
*	10-04-94  SB	Module created
*	10-07-94  JWM	rewrote
*	10-17-94  BWT	Disable code for PPC.
*	11-23-94  JWM	Strip trailing spaces from type_info.name().
*	02/15/95  JWM   Class type_info no longer _CRTIMP, member functions are exported instead
*       06-02-95  JWM   unDName -> __unDName.
*       06-19-95  JWM   type_info.name() moved to typename.cpp for granularity.
*       07-02-95  JWM   return values from == & != cleaned up, locks added to destructor.
*       09-07-00  PML   Get rid of /lib:libcp directive in obj (vs7#159463)
*
****/

#define _USE_ANSI_CPP   /* Don't emit /lib:libcp directive */

#include <stdlib.h>
#include <typeinfo.h>
#include <mtdll.h>
#include <string.h>
#include <dbgint.h>
#include <undname.h>



_CRTIMP type_info::~type_info()
{
        

        _mlock(_TYPEINFO_LOCK);
        if (_m_data != NULL) {
#ifdef _DEBUG /* CRT debug lib build */
            _free_base (_m_data);
#else
            free (_m_data);
#endif
        }
        _munlock(_TYPEINFO_LOCK);

}

_CRTIMP int type_info::operator==(const type_info& rhs) const
{
	return (strcmp((rhs._m_d_name)+1, (_m_d_name)+1)?0:1);
}

_CRTIMP int type_info::operator!=(const type_info& rhs) const
{
	return (strcmp((rhs._m_d_name)+1, (_m_d_name)+1)?1:0);
}

_CRTIMP int type_info::before(const type_info& rhs) const
{
	return (strcmp((rhs._m_d_name)+1,(_m_d_name)+1) > 0);
}

_CRTIMP const char* type_info::raw_name() const
{
    return _m_d_name;
}

type_info::type_info(const type_info& rhs)
{
//	*TBD*
//	"Since the copy constructor and assignment operator for
//	type_info are private to the class, objects of this type
//	cannot be copied." - 18.5.1
//
//  _m_data = NULL;
//  _m_d_name = new char[strlen(rhs._m_d_name) + 1];
//  if (_m_d_name != NULL)
//      strcpy( (char*)_m_d_name, rhs._m_d_name );
}


type_info& type_info::operator=(const type_info& rhs)
{
//	*TBD*
//
//  if (this != &rhs) {
//      this->type_info::~type_info();
//      this->type_info::type_info(rhs);
//  }
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\unhandld.cpp ===
/***
*unhandld.cxx - Wrapper to call terminate() when an exception goes unhandled.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Wrapper to call terminate() when an exception goes unhandled.
*
*Description:
*       This module makes use of the Win32 API SetUnhandledExceptionFilter.
*       This assumes the call to main() is wrapped with
*       __try {  ... }
*       __except(UnhandledExceptionFilter(_exception_info())) {  ...  }
*
*Revision History:
*       10-04-93  BS    Module created
*       10-17-94  BWT   Disable code for PPC.
*       02-09-95  JWM   Mac merge.
*       02-16-95  JWM   Added __CxxRestoreUnhandledExceptionFilter().
*       11-19-96  GJF   Install handler during C initializers, remove it 
*                       during C termination. Also, reformatted the source a
*                       bit for readability.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-17-99  PML   Remove all Macintosh support.
*       03-27-01  PML   .CRT$XI routines must now return 0 or _RT_* fatal
*                       error code (vs7#231220)
*
****/

#include <windows.h>
#include <ehdata.h>
#include <eh.h>
#include <ehhooks.h>
#include <ehassert.h>
#include <internal.h>
#include <stdlib.h>

#pragma hdrstop

#include <sect_attribs.h>

int  __cdecl __CxxSetUnhandledExceptionFilter(void);
void __cdecl __CxxRestoreUnhandledExceptionFilter(void);

#pragma data_seg(".CRT$XIY")
_CRTALLOC(".CRT$XIY") static _PIFV pinit = &__CxxSetUnhandledExceptionFilter;

#pragma data_seg(".CRT$XTB")
_CRTALLOC(".CRT$XTB") static _PVFV pterm = &__CxxRestoreUnhandledExceptionFilter;

#pragma data_seg()

static LPTOP_LEVEL_EXCEPTION_FILTER pOldExceptFilter;


/////////////////////////////////////////////////////////////////////////////
//
// __CxxUnhandledExceptionFilter - if the exception is ours, call terminate();
//
// Returns:
//      If the exception was MSVC C++ EH, does not return.
//      If the previous filter was NULL, returns EXCEPTION_CONTINUE_SEARCH.
//      Otherwise returns value returned by previous filter.
//
LONG WINAPI __CxxUnhandledExceptionFilter(
        LPEXCEPTION_POINTERS pPtrs
        )
{
        if (PER_IS_MSVC_EH((EHExceptionRecord*)(pPtrs->ExceptionRecord))) {
                terminate();            // Does not return
                return EXCEPTION_EXECUTE_HANDLER;
        }
        else {

#pragma warning(disable:4191)

                if ( pOldExceptFilter != NULL && 
                     _ValidateExecute((FARPROC)pOldExceptFilter) ) 

#pragma warning(default:4191)

                {
                        return pOldExceptFilter(pPtrs);
                }
                else {
                        return EXCEPTION_CONTINUE_SEARCH;
                }
        }
}


/////////////////////////////////////////////////////////////////////////////
//
// __CxxSetUnhandledExceptionFilter - sets unhandled exception filter to be
// __CxxUnhandledExceptionFilter.
//
// Returns:
//      Returns 0 to indicate no error.
//

int __cdecl __CxxSetUnhandledExceptionFilter(void)
{
        pOldExceptFilter = SetUnhandledExceptionFilter(&__CxxUnhandledExceptionFilter);
        return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
// __CxxRestoreUnhandledExceptionFilter - on exit, restores OldExceptFilter
//
// Returns:
//      Nothing.
//

void __cdecl __CxxRestoreUnhandledExceptionFilter(void)
{
        SetUnhandledExceptionFilter(pOldExceptFilter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\typname.cpp ===
/***
*typename.cpp - Implementation of type_info.name() for RTTI.
*
*	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module provides an implementation of the class member function
*	type_info.name() for Run-Time Type Information (RTTI).
*
*Revision History:
*       06-19-95  JWM   broken out from typeinfo.cpp for granularity.
*       07-02-95  JWM   now locks around assignment to _m_data.
*       12-18-95  JWM   debug type_info::name() now calls _malloc_crt().
*       09-07-00  PML   Get rid of /lib:libcp directive in obj (vs7#159463)
*       02-19-01  GB    Added Check for return value of malloc
*
****/

#define _USE_ANSI_CPP   /* Don't emit /lib:libcp directive */

#include <stdlib.h>
#include <typeinfo.h>
#include <mtdll.h>
#include <string.h>
#include <dbgint.h>
#include <undname.h>

_CRTIMP const char* type_info::name() const //17.3.4.2.5
{
	void *pTmpUndName;


        if (this->_m_data == NULL) {
#ifdef _DEBUG /* CRT debug lib build */
#if _M_MRX000 >= 4000 /*IFSTRIP=IGN*/
            if ((pTmpUndName = __unDName(NULL, !strncmp(this->_m_d_name,"_TD",3)? (this->_m_d_name)+4 : (this->_m_d_name)+1, 0, &_malloc_base, &_free_base, UNDNAME_32_BIT_DECODE | UNDNAME_TYPE_ONLY)) == NULL)
                return NULL;
#else
            if ((pTmpUndName = __unDName(NULL, (this->_m_d_name)+1, 0, &_malloc_base, &_free_base, UNDNAME_32_BIT_DECODE | UNDNAME_TYPE_ONLY)) == NULL)
                return NULL;
#endif
#else
#if _M_MRX000 >= 4000 /*IFSTRIP=IGN*/
            if ((pTmpUndName = __unDName(NULL, !strncmp(this->_m_d_name,"_TD",3)? (this->_m_d_name)+4 : (this->_m_d_name)+1, 0, &malloc, &free, UNDNAME_32_BIT_DECODE | UNDNAME_TYPE_ONLY)) == NULL)
                return NULL;
#else
            if ((pTmpUndName = __unDName(NULL, (this->_m_d_name)+1, 0, &malloc, &free, UNDNAME_32_BIT_DECODE | UNDNAME_TYPE_ONLY)) == NULL)
                return NULL;
#endif
#endif
            for (int l=(int)strlen((char *)pTmpUndName)-1; ((char *)pTmpUndName)[l] == ' '; l--)
                ((char *)pTmpUndName)[l] = '\0';

            _mlock (_TYPEINFO_LOCK);
#ifdef _DEBUG /* CRT debug lib build */
            if ((((type_info *)this)->_m_data = _malloc_crt (strlen((char *)pTmpUndName) + 1)) != NULL)
                strcpy ((char *)((type_info *)this)->_m_data, (char *)pTmpUndName);
            _free_base (pTmpUndName);
#else
            if ((((type_info *)this)->_m_data = malloc (strlen((char *)pTmpUndName) + 1)) != NULL)
                strcpy ((char *)((type_info *)this)->_m_data, (char *)pTmpUndName);
            free (pTmpUndName);
#endif
            _munlock(_TYPEINFO_LOCK);


        }


        return (char *) this->_m_data;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\validate.cpp ===
/***
*validate.cpp - Routines to validate the data structures.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Routines to validate the Exception Handling data structures.
*
*       Entry points:
*
*       Error reporting:
*       * EHRuntimeError - reports the error with
*         a popup or print to stderr, then quits.
*
*       Pointer validation:
*       * _ValidateRead   - Confirms that a pointer is valid for reading
*       * _ValidateWrite   - Confirms that a pointer is valid for writing
*       * _ValidateExecute - Confirms that a pointer is valid to jump to
*
*       Data structure dumpers:
*       * DumpTypeDescriptor
*       * DumpFuncInfo
*       * DumpThrowInfo
*
*       Execution tracing (only in /DENABLE_EHTRACE builds):
*       * EHTraceOutput
*
*Revision History:
*       ??-??-93  BS    Module created
*       10-17-94  BWT   Disable code for PPC.
*       04-25-95  DAK   Add Kernel EH Support
*       05-17-99  PML   Remove all Macintosh support.
*       10-22-99  PML   Add EHTRACE support
*
****/

#if defined(_NTSUBSET_)
extern "C" {
        #include <nt.h>
        #include <ntrtl.h>
        #include <nturtl.h>
        #include <ntos.h>
}
#endif

#include <windows.h>
#include <eh.h>
#include <ehassert.h>

#pragma hdrstop

#if defined(DEBUG)

int __cdecl
dprintf( char *format, ... )
{
        static char buffer[512];

        int size = vsprintf( buffer, format, (char*)(&format+1) );
#if defined(_NTSUBSET_)
        DbgPrint( buffer );
#else
        OutputDebugString( buffer );
#endif

return size;
}

#endif

BOOL
_ValidateRead( const void *data, UINT size )
{
        BOOL bValid = TRUE;
#if defined(_NTSUBSET_)
//      bValid = MmIsSystemAddressAccessable( (PVOID) data );
#else
        if ( IsBadReadPtr( data, size ) ) {
            dprintf( "_ValidateRead( %p, %d ): Invalid Pointer!", data, size );
            //  terminate(); // terminate does not return.
            bValid = FALSE;
        }
#endif
        return bValid;
}

BOOL
_ValidateWrite( void *data, UINT size )
{
        BOOL bValid = TRUE;
#if defined(_NTSUBSET_)
//      bValid = MmIsSystemAddressAccessable( (PVOID) data );
#else
        if ( IsBadWritePtr( data, size ) ) {
            dprintf( "_ValidateWrite( %p, %d ): Invalid Pointer!", data, size );
//          terminate(); // terminate does not return.
            bValid = FALSE;
        }
#endif
        return bValid;
}

BOOL
_ValidateExecute( FARPROC code )
{
        BOOL    bValid = TRUE;
#if defined(_NTSUBSET_)
        bValid = _ValidateRead(code, sizeof(FARPROC) );
#else
        if ( IsBadCodePtr( code ) ) {
            dprintf( "_ValidateExecute( %p ): Invalid Function Address!", code );
//          terminate(); // terminate does not return
            bValid = FALSE;
        }
#endif
        return bValid;
}


#if defined(DEBUG) && defined(_M_IX86)
//
// dbRNListHead - returns current value of FS:0.
//
// For debugger use only, since debugger doesn't seem to be able to view the
// teb.
//
EHRegistrationNode *dbRNListHead(void)
{
        EHRegistrationNode *pRN;

        __asm {
            mov     eax, dword ptr FS:[0]
            mov     pRN, eax
            }

        return pRN;
}
#endif

#ifdef  ENABLE_EHTRACE

#include <stdio.h>
#include <stdarg.h>

//
// Current EH tracing depth, stack for saving levels during __finally block
// or __except filter.
//
int __ehtrace_level;
int __ehtrace_level_stack_depth;
int __ehtrace_level_stack[128];

//
// EHTraceOutput - Dump formatted string to OutputDebugString
//
void __cdecl EHTraceOutput(const char *format, ...)
{
    va_list arglist;
    char buf[1024];

    sprintf(buf, "%p ", &format);
    OutputDebugString(buf);

    va_start(arglist, format);
    _vsnprintf(buf, sizeof(buf), format, arglist);

    OutputDebugString(buf);
}

//
// EHTraceIndent - Return string for current EH tracing depth
//
const char*EHTraceIndent(int level)
{
    static char indentbuf[128 + 1];

    // Reset global level to recover from stack unwinds
    __ehtrace_level = level;

    int depth = max(0, level - 1);
    if (depth > (sizeof(indentbuf) - 1) / 2) {
        depth = (sizeof(indentbuf) - 1) / 2;
    }

    for (int i = 0; i < depth; ++i) {
        indentbuf[2 * i] = '|';
        indentbuf[2 * i + 1] = ' ';
    }
    indentbuf[2 * depth] = '\0';

    return indentbuf;
}

//
// EHTraceFunc - Chop down __FUNCTION__ to simple name
//
const char *EHTraceFunc(const char *func)
{
    static char namebuf[128];

    const char *p = func + strlen(func) - 1;

    if (*p != ')') {
        // Name already simple (no arg list found)
        return func;
    }

    // Skip backwards past the argument list
    int parendepth = 1;
    while (p > func && parendepth > 0) {
        switch (*--p) {
        case '(':
            --parendepth;
            break;
        case ')':
            ++parendepth;
            break;
        }
    }

    // Find beginning of name
    // TODO: Won't work for funcs which return func-ptrs
    const char *pEnd = p;
    while (p > func && p[-1] != ' ') {
        --p;
    }

    size_t len = min(pEnd - p, sizeof(namebuf) - 1);
    memcpy(namebuf, p, len);
    namebuf[len] = '\0';

    return namebuf;
}

//
// EHTracePushLevel - Push current trace depth on stack to allow temporary
// resetting of level with __finally block or __except filter.
//
void EHTracePushLevel(int new_level)
{
    if (__ehtrace_level_stack_depth < sizeof(__ehtrace_level_stack) / sizeof(__ehtrace_level_stack[0])) {
        __ehtrace_level_stack[__ehtrace_level_stack_depth] = __ehtrace_level;
    }
    ++__ehtrace_level_stack_depth;
    __ehtrace_level = new_level;
}

//
// EHTracePopLevel - Pop saved trace depth from stack on completion of
// __finally block or __except filter, and optionally restore global depth.
//

void EHTracePopLevel(bool restore)
{
    --__ehtrace_level_stack_depth;
    if (restore &&
        __ehtrace_level_stack_depth < sizeof(__ehtrace_level_stack) / sizeof(__ehtrace_level_stack[0]))
    {
        __ehtrace_level = __ehtrace_level_stack[__ehtrace_level_stack_depth];
    }
}

//
// EHTraceExceptFilter - Dump trace info for __except filter.  Trace level must
// have been pushed before entry with EHTracePushLevel, so any functions called
// for the 'expr' argument are dumped at the right level.
//
int EHTraceExceptFilter(const char *func, int expr)
{
    EHTraceOutput("In   : %s%s: __except filter returns %d (%s)\n",
                  EHTraceIndent(__ehtrace_level), EHTraceFunc(func), expr,
                  expr < 0 ? "EXCEPTION_CONTINUE_EXECUTION" :
                  expr > 0 ? "EXCEPTION_EXECUTE_HANDLER" :
                  "EXCEPTION_CONTINUE_SEARCH");

    EHTracePopLevel(expr <= 0);
    return expr;
}

//
// EHTraceHandlerReturn - Dump trace info for exception handler return
//
void EHTraceHandlerReturn(const char *func, int level, EXCEPTION_DISPOSITION result)
{
    EHTraceOutput( "Exit : %s%s: Handler returning %d (%s)\n", \
                   EHTraceIndent(level), EHTraceFunc(func), result,
                   result == ExceptionContinueExecution ? "ExceptionContinueExecution" :
                   result == ExceptionContinueSearch ? "ExceptionContinueSearch" :
                   result == ExceptionNestedException ? "ExceptionNestedException" :
                   result == ExceptionCollidedUnwind ? "ExceptionCollidedUnwind" :
                   "unknown" );
}

#endif  /* ENABLE_EHTRACE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\xundname.cpp ===
// Forwarder for use in the NT build
#include <undname.cxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\amd64\handlers.asm ===
;EXTRN   _NLG_Notify:NEAR
include ksamd64.inc


EXTRN   _GetImageBase:NEAR

;;++
;;
;;extern "C" void* _CallSettingFrame(
;;    void*               handler,
;;    EHRegistrationNode  *pEstablisher,
;;    ULONG               NLG_CODE)
;;
;;--


_GP$=16
_handler$=32
_pEstablisher$=40
_NLG_CODE$=48

    NESTED_ENTRY _CallSettingFrame, _TEXT$00

    sub rsp, 24
    .allocstack 24
    .endprolog
    mov     QWORD PTR _handler$[rsp],       rcx
    mov     QWORD PTR _pEstablisher$[rsp],  rdx
    mov     DWORD PTR _NLG_CODE$[rsp],      r8d

    mov     rdx,    QWORD PTR _pEstablisher$[rsp]
    mov     rdx,    QWORD PTR [rdx]         ;   *pEstablisher
    mov     rax,    QWORD PTR _handler$[rsp]
    call    rax                                 ;   Call handler

    mov     QWORD PTR _GP$[rsp],            rax 
    add     rsp,    24
    ret     0
    NESTED_END _CallSettingFrame, _TEXT$00


;;++
;;
;;extern "C"
;;VOID
;;_GetNextInstrOffset (
;;    PVOID* ppReturnPoint
;;    );
;;
;;Routine Description:
;;
;;    This function scans the scope tables associated with the specified
;;    procedure and calls exception and termination handlers as necessary.
;;
;;Arguments:
;;
;;    ppReturnPoint (r32) - store b0 in *pReturnPoint
;;
;;Return Value:
;;
;;  None
;;
;;--

PUBLIC _GetNextInstrOffset
_TEXT SEGMENT
_GetNextInstrOffset PROC NEAR

    mov rax, QWORD PTR[rsp]
    mov QWORD PTR [rcx], rax
    ret 0

_GetNextInstrOffset ENDP
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\amd64\ehstate.cpp ===
//
// Created by GautamB 06/01/01
// Based on IA64 ehstate.h
//

#if defined(_NTSUBSET_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>       // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
#include <ex.h>             // ExRaiseException
}
#endif

extern "C" {
#include "windows.h"
}
#include "ehassert.h"
#include "ehdata.h"     // Declarations of all types used for EH
#include "ehstate.h"
#include "eh.h"
#include "ehhooks.h"
#include "trnsctrl.h"
#pragma hdrstop

__ehstate_t _StateFromIp(
    FuncInfo            *pFuncInfo,
    DispatcherContext   *pDC,
    __int64             Ip
) {
    unsigned int    index;          //  loop control variable
    unsigned int    nIPMapEntry;    //  # of IpMapEntry; must be > 0

    DASSERT(pFuncInfo != NULL);
    nIPMapEntry = FUNC_NIPMAPENT(*pFuncInfo);

    DASSERT(FUNC_IPMAP(*pFuncInfo, pDC->ImageBase) != NULL);

    for (index = 0; index < nIPMapEntry; index++) {
        IptoStateMapEntry    *pIPtoStateMap = FUNC_PIPTOSTATE(*pFuncInfo, index, pDC->ImageBase);
        if( pDC->ControlPc < (pDC->ImageBase + pIPtoStateMap->Ip) ) {
            break;
        }
    }

    if (index == 0) {
        // We are at the first entry, could be an error

        return EH_EMPTY_STATE;
    }

    // We over-shot one iteration; return state from the previous slot

    return FUNC_IPTOSTATE(*pFuncInfo, index - 1, pDC->ImageBase).State;
}


__ehstate_t _StateFromControlPc(
    FuncInfo            *pFuncInfo,
    DispatcherContext   *pDC
    )
{
    return _StateFromIp(pFuncInfo, pDC, pDC->ControlPc);
}
//
// This routine is a replacement for the corresponding macro in 'ehdata.h'
//

__ehstate_t GetCurrentState(
    EHRegistrationNode  *pFrame,
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo
) {
    if( UNWINDSTATE(*pFrame, FUNC_DISPUNWINDHELP(*pFuncInfo)) == -2 ) {
        return _StateFromControlPc(pFuncInfo, pDC);
    }
    else {
        return UNWINDSTATE(*pFrame, FUNC_DISPUNWINDHELP(*pFuncInfo));
    }
}

VOID SetState(
    EHRegistrationNode  *pRN,
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo,
    __ehstate_t          newState
){
    UNWINDSTATE(*pRN, FUNC_DISPUNWINDHELP(*pFuncInfo)) = (short)newState;
}

VOID SetUnwindTryBlock(
    EHRegistrationNode  *pRN,
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo,
    INT                 curState
){
    EHRegistrationNode EstablisherFramePointers;
    EstablisherFramePointers = *_GetEstablisherFrame(pRN, pDC, pFuncInfo, &EstablisherFramePointers);
    if( curState > UNWINDTRYBLOCK(EstablisherFramePointers, FUNC_DISPUNWINDHELP(*pFuncInfo)) ) {
        UNWINDTRYBLOCK(EstablisherFramePointers, FUNC_DISPUNWINDHELP(*pFuncInfo)) = (short)curState;
    }
}

INT GetUnwindTryBlock(
    EHRegistrationNode  *pRN,
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo
){
    EHRegistrationNode EstablisherFramePointers;
    EstablisherFramePointers = *_GetEstablisherFrame(pRN, pDC, pFuncInfo, &EstablisherFramePointers);
    return UNWINDTRYBLOCK(EstablisherFramePointers, FUNC_DISPUNWINDHELP(*pFuncInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\amd64\trnsctrl.cpp ===
/***
*trnsctrl.cpp - 
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       06-01-97        Created by TiborL.
*       07-12-99  RDL   Image relative fixes under CC_P7_SOFT25.
*       10-07-99  SAH   utc_p7#1126: fix ipsr.ri reset.
*       10-19-99  TGL   Miscellaneous unwind fixes.
*       03-15-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*       03-30-00  SAH   New version of GetLanguageSpecificData from ntia64.h.
*       06-08-00  RDL   VS#111429: IA64 workaround for AV while handling throw.
*       06-05-01  GB    AMD64 Eh support Added.
*
****/

#if defined(_NTSUBSET_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>       // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
#include <ex.h>             // ExRaiseException
}
#endif

extern "C" {
#include <windows.h>
};
#include <winnt.h>
#include <mtdll.h>

#include <ehassert.h>
#include <ehdata.h>
#include <trnsctrl.h>
#include <ehstate.h>
#include <eh.h>
#include <ehhooks.h>
#pragma hdrstop

#ifdef _MT
#define pFrameInfoChain   (*((FRAMEINFO **)    &(_getptd()->_pFrameInfoChain)))
#define pUnwindContext    (*((CONTEXT **)      &(_getptd()->_pUnwindContext)))
#define _ImageBase        (_getptd()->_ImageBase)
#define _ThrowImageBase   (_getptd()->_ThrowImageBase)
#define _pCurrentException (*((EHExceptionRecord **)&(_getptd()->_curexception)))
#else
static FRAMEINFO          *pFrameInfoChain     = NULL;        // used to remember nested frames
static CONTEXT            *pUnwindContext      = NULL;        // context to assist the return to 'UnwindNestedFrames'
static unsigned __int64   _ImageBase           = 0;
static unsigned __int64   _ThrowImageBase      = 0;
extern EHExceptionRecord  *_pCurrentException;
#endif

// Should be used out of ntamd64.h, but can't figure out how to allow that with
// existing dependencies.
#define GetLanguageSpecificData(f, base)                                      \
    (((PUNWIND_INFO)(f->UnwindInfoAddress + base))->UnwindCode + ((((PUNWIND_INFO)(f->UnwindInfoAddress + base))->CountOfCodes + 1)&~1) +1)

extern "C" VOID RtlRestoreContext (PCONTEXT ContextRecord,PEXCEPTION_RECORD ExceptionRecord OPTIONAL);
extern "C" void RtlCaptureContext(CONTEXT*);
extern "C" void _GetNextInstrOffset(PVOID*);
extern "C" void __FrameUnwindToState(EHRegistrationNode *, DispatcherContext *, FuncInfo *, __ehstate_t);

//
// Returns the establisher frame pointers. For catch handlers it is the parent's frame pointer.
//
EHRegistrationNode *_GetEstablisherFrame(
    EHRegistrationNode  *pRN,
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo,
    EHRegistrationNode  *pEstablisher
) {
    TryBlockMapEntry *pEntry;
    HandlerType *pHandler;
    unsigned __int64 HandlerAdd, ImageBase;
    unsigned num_of_try_blocks = FUNC_NTRYBLOCKS(*pFuncInfo);
    unsigned index, i;
    __ehstate_t curState;

    curState = _StateFromControlPc(pFuncInfo, pDC);
    *pEstablisher = *pRN;
    for (index = num_of_try_blocks-1; (int)index >= 0; index--) {
        pEntry = FUNC_PTRYBLOCK(*pFuncInfo, (index), pDC->ImageBase);
        if (curState > TBME_HIGH(*pEntry) && curState <= TBME_CATCHHIGH(*pEntry)) {
            // Get catch handler address.
            HandlerAdd = (*RtlLookupFunctionEntry(pDC->ControlPc, &ImageBase, pDC->HistoryTable)).BeginAddress;
            pHandler = TBME_PLIST(*pEntry, ImageBase);
            for ( i = 0; 
                  i < (unsigned)TBME_NCATCHES(*pEntry) && 
                  pHandler[i].dispOfHandler != HandlerAdd
                  ; i++);
            if ( i < (unsigned)TBME_NCATCHES(*pEntry)) {
                *pEstablisher = *(EHRegistrationNode *)OffsetToAddress(pHandler[i].dispFrame, *pRN);
                break;
            }
        }
    }
    return pEstablisher;
}

extern "C" VOID _SaveUnwindContext(CONTEXT* pContext)
{
    pUnwindContext = pContext;
}

extern "C" CONTEXT* _GetUnwindContext()
{
    return pUnwindContext;
}

extern "C" unsigned __int64 _GetImageBase()
{
    return _ImageBase;
}

extern "C" unsigned __int64 _GetThrowImageBase()
{
    return _ThrowImageBase;
}

extern "C" VOID _SetThrowImageBase(unsigned __int64 NewThrowImageBase)
{
    _ThrowImageBase = NewThrowImageBase;
}

extern "C" VOID _MoveContext(CONTEXT* pTarget, CONTEXT* pSource)
{
    RtlMoveMemory(pTarget, pSource, sizeof(CONTEXT));
}

// This function returns the try block for the given state if the state is in a
// catch; otherwise, NULL is returned.

static __inline TryBlockMapEntry *_CatchTryBlock(
    FuncInfo            *pFuncInfo,
    __ehstate_t         curState
) {
    TryBlockMapEntry *pEntry;
    unsigned num_of_try_blocks = FUNC_NTRYBLOCKS(*pFuncInfo);
    unsigned index;

    for (index = 0; index < num_of_try_blocks; index++) {
        pEntry = FUNC_PTRYBLOCK(*pFuncInfo, index, _ImageBase);
        if (curState > TBME_HIGH(*pEntry) && curState <= TBME_CATCHHIGH(*pEntry)) {
            return pEntry;
        }
    }

    return NULL;
}

//
// This routine returns TRUE if we are executing from within a catch.  Otherwise, FALSE is returned.
//

BOOL _ExecutionInCatch(
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo
) {
    __ehstate_t curState =  _StateFromControlPc(pFuncInfo, pDC);
    return _CatchTryBlock(pFuncInfo, curState)? TRUE : FALSE;
}

// This function unwinds to the empty state.

VOID __FrameUnwindToEmptyState(
    EHRegistrationNode *pRN,
    DispatcherContext  *pDC,
    FuncInfo           *pFuncInfo
) {
    __ehstate_t         stateFromControlPC;
    TryBlockMapEntry    *pEntry;
    EHRegistrationNode  EstablisherFramePointers, *pEstablisher;

    pEstablisher = _GetEstablisherFrame(pRN, pDC, pFuncInfo, &EstablisherFramePointers);
    stateFromControlPC = _StateFromControlPc(pFuncInfo, pDC);
    pEntry = _CatchTryBlock(pFuncInfo, stateFromControlPC);

    __FrameUnwindToState(pEstablisher, pDC, pFuncInfo,
                         pEntry == NULL ? EH_EMPTY_STATE : TBME_HIGH(*pEntry));
}

BOOL _IsExceptionObjectDestroyed(PVOID pExceptionObject,FRAMEINFO *pFrameInfo)
{
    for (; pFrameInfo != NULL; pFrameInfo = pFrameInfo->pNext ) {
        if( pFrameInfo->pExceptionObjectDestroyed == pExceptionObject ) {
            return TRUE;
        }
    }
    return FALSE;
}

void _MarkExceptionObjectDestroyed(EHExceptionRecord *pExcept)
{
    for (FRAMEINFO *pFrameInfo = pFrameInfoChain; pFrameInfo != NULL; pFrameInfo = pFrameInfo->pNext ) {
        if( pFrameInfo->pExcept == pExcept ) {
            pFrameInfo->pExceptionObjectDestroyed = PER_PEXCEPTOBJ(pExcept);
        }
    }
}

void _UnlinkFrame(FRAMEINFO *pFrameInfo)
{
    FRAMEINFO *pPrevFrameInfo = pFrameInfoChain;

    if( pFrameInfoChain == pFrameInfo ) {
        pFrameInfoChain = pFrameInfoChain->pNext;
        return;
    }
    for (FRAMEINFO *pCurFrameInfo = pFrameInfoChain; pCurFrameInfo != NULL; pCurFrameInfo = pCurFrameInfo->pNext ) {
        if( pCurFrameInfo == pFrameInfo ) {
            pPrevFrameInfo->pNext = pCurFrameInfo->pNext;
            return;
        }
        pPrevFrameInfo = pCurFrameInfo;
    }
}

// Find the frame info structure corresponding to the given address.  Return
// NULL if the frame info structure does not exist.

FRAMEINFO *_FindFrameInfo(
    PVOID     pContinuation,
    FRAMEINFO *pFrameInfo
) {
    unsigned __int64 ImageBase;

    PRUNTIME_FUNCTION pContFunctionEntry = RtlLookupFunctionEntry((unsigned __int64)pContinuation, &ImageBase, NULL);
    PRUNTIME_FUNCTION pFrameFunctionEntry = pFrameInfo->pFunctionEntry;

    DASSERT(pFrameInfo != NULL);

    for (; pFrameInfo != NULL; pFrameInfo = pFrameInfo->pNext ) {
        if (pContFunctionEntry == pFrameInfo->pFunctionEntry &&
              (pContinuation > OffsetToAddress(pFrameInfo->pFunctionEntry->BeginAddress,ImageBase)) &&
              (pContinuation <= OffsetToAddress(pFrameInfo->pFunctionEntry->EndAddress,ImageBase))

        ){
            return pFrameInfo;
        }
    }

    return NULL;
}

BOOL __IsFramePdataMatch(
	PVOID pContinuation, 
	RUNTIME_FUNCTION* pFrameRfe)
{ 
    BOOL fRetVal = FALSE;
    unsigned __int64 ImageBase;
    PRUNTIME_FUNCTION pContRfe = RtlLookupFunctionEntry((unsigned __int64) pContinuation, &ImageBase, NULL);
    FuncInfo* pContFuncInfo = (FuncInfo*)(_ImageBase + *(PULONG)GetLanguageSpecificData(pContRfe,_ImageBase));
    FuncInfo* pFrameFuncInfo = (FuncInfo*)(ImageBase + *(PULONG)GetLanguageSpecificData(pFrameRfe,ImageBase));

    //
    // first see if there is a regular match, i.e. if the RFE registered with the frame 
    // matches the RFE for the continuation address
    //
    fRetVal = (pContRfe == pFrameRfe) &&
              (pContinuation > OffsetToAddress(pFrameRfe->BeginAddress,ImageBase)) &&
              (pContinuation <= OffsetToAddress(pFrameRfe->EndAddress,ImageBase));
    
    if (!fRetVal && (pContFuncInfo->bbtFlags == BBT_UNIQUE_FUNCINFO)) {
        fRetVal = (pContFuncInfo == pFrameFuncInfo);
    }
	
    return fRetVal;
}

//
// Given the address of a continuation point, return the corresponding context.
// Each frame info was saved just before a catch handler was called.
// The most recently encountered frame is at the head of the chain.
// The routine starts out with the frame given as the second argument, and scans the
// linked list for the frame that corresponds to the continuation point.
//
CONTEXT* _FindAndUnlinkFrame(PVOID pContinuation, FRAMEINFO *pFrameInfo)
{

    DASSERT(pFrameInfo != NULL);

	for( ; pFrameInfo != NULL; pFrameInfo = pFrameInfo->pNext ) {
        if(__IsFramePdataMatch(pContinuation, pFrameInfo->pFunctionEntry)) {
			//
			// We found the frame.
			// All frames preceeding and including this one are gone. so unlink them.
			//
            CONTEXT *pExitContext = pFrameInfo->pExitContext;
			pFrameInfoChain = pFrameInfo->pNext;
            //
            // If there are no more exceptions pending get rid of unneeded frame info records.
            //
            if (_pCurrentException == NULL) {
                while(pFrameInfoChain != NULL && pFrameInfoChain->pExceptionObjectDestroyed) {
                    pFrameInfoChain = pFrameInfoChain->pNext;
                }
            }
			return pExitContext;
		}
    }
    DASSERT(pFrameInfo != NULL);
    return NULL;
}

//
// Save the frame information for this scope. Put it at the head of the linked-list.
//
FRAMEINFO* _CreateFrameInfo(    
                        FRAMEINFO            *pFrameInfo,
                        DispatcherContext    *pDC,
                        CONTEXT              *pExitContext,
                        __ehstate_t          State,
                        PVOID                pExceptionObjectDestroyed,
                        EHExceptionRecord    *pExcept
) {
    pFrameInfo->pFunctionEntry       = pDC->FunctionEntry;
    pFrameInfo->pExitContext         = pExitContext;
    pFrameInfo->pExceptionObjectDestroyed = pExceptionObjectDestroyed;
    pFrameInfo->pExceptionObjectToBeDestroyed = NULL;
    pFrameInfo->pExcept              = pExcept;
    pFrameInfo->State                = State;
    pFrameInfo->dtorThrowFlag        = FALSE;
    pFrameInfo->isRethrow            = FALSE;
    if( pFrameInfoChain != NULL && pFrameInfoChain->dtorThrowFlag ) {
        pFrameInfoChain = pFrameInfoChain->pNext;
    }
    pFrameInfo->pNext                = (pFrameInfo < pFrameInfoChain)? pFrameInfoChain : NULL;
    pFrameInfoChain                  = pFrameInfo;
    return pFrameInfo;
}

//
// THIS ROUTINE IS USED    ONLY TO JUMP TO THE CONTINUATION POINT
//
// Sets SP and jumps to specified code address.
// Does not return.
//
void _JumpToContinuation(
    unsigned __int64    TargetAddress,   // The target address to call
    CONTEXT             *pContext,       // Context of target function
    EHExceptionRecord   *pExcept
) {
    pContext->Rip = TargetAddress;
    RtlRestoreContext(pContext, (PEXCEPTION_RECORD)pExcept);
}

//
// Prototype for the internal handler
//
extern "C" EXCEPTION_DISPOSITION __InternalCxxFrameHandler(
    EHExceptionRecord  *pExcept,        // Information for this exception
    EHRegistrationNode *pRN,            // Dynamic information for this frame
    CONTEXT            *pContext,       // Context info
    DispatcherContext  *pDC,            // More dynamic info for this frame
    FuncInfo           *pFuncInfo,      // Static information for this frame
    int                CatchDepth,      // How deeply nested are we?
    EHRegistrationNode *pMarkerRN,      // Marker node for when checking inside catch block
    BOOL                recursive);     // True if this is a translation exception

//
// __CxxFrameHandler - Real entry point to the runtime
//
extern "C" _CRTIMP EXCEPTION_DISPOSITION __CxxFrameHandler(
    EHExceptionRecord  *pExcept,         // Information for this exception
    EHRegistrationNode RN,               // Dynamic information for this frame
    CONTEXT            *pContext,        // Context info
    DispatcherContext  *pDC              // More dynamic info for this frame
) {
    FuncInfo                *pFuncInfo;
    EXCEPTION_DISPOSITION   result;
    EHRegistrationNode      EstablisherFrame = RN;

    _ImageBase = pDC->ImageBase;
    _ThrowImageBase = (unsigned __int64)pExcept->params.pThrowImageBase;
    pFuncInfo = (FuncInfo*)(_ImageBase +*(PULONG)pDC->HandlerData);
    result = __InternalCxxFrameHandler( pExcept, &EstablisherFrame, pContext, pDC, pFuncInfo, 0, NULL, FALSE );
    return result;
}

// Call the SEH to EH translator.

BOOL _CallSETranslator(
    EHExceptionRecord   *pExcept,    // The exception to be translated
    EHRegistrationNode  *pRN,        // Dynamic info of function with catch
    CONTEXT             *pContext,   // Context info
    DispatcherContext   *pDC,        // More dynamic info of function with catch (ignored)
    FuncInfo            *pFuncInfo,  // Static info of function with catch
    ULONG               CatchDepth,  // How deeply nested in catch blocks are we?
    EHRegistrationNode  *pMarkerRN   // Marker for parent context
) {
    pRN;
    pDC;
    pFuncInfo;
    CatchDepth;

    // Call the translator.

    _EXCEPTION_POINTERS excptr = { (PEXCEPTION_RECORD)pExcept, pContext };

    __pSETranslator(PER_CODE(pExcept), &excptr);

    // If we got back, then we were unable to translate it.

    return FALSE;
}

//
// This structure is the FuncInfo (HandlerData) for handler __TranslatorGuardHandler
//
struct TransGuardRec {
    FuncInfo            *pFuncInfo;     // Static info for subject function
    EHRegistrationNode  *pFrame;        // Dynamic info for subject function
    ULONG               CatchDepth;     // How deeply nested are we?
    EHRegistrationNode  *pMarkerFrame;  // Marker for parent context
    PVOID               pContinue;      // Continuation address within CallSEHTranslator
    PVOID               pSP;            // SP within CallSEHTranslator
    BOOL                DidUnwind;      // True if this frame was unwound
    };

#if 0
//
//    This routine is the handler for CallSETranslator which is defined in handlers.s
//
extern "C" _CRTIMP EXCEPTION_DISPOSITION __TranslatorGuardHandler(
    EHExceptionRecord    *pExcept,       // Information for this exception
    EHRegistrationNode   *pFrame,        // The translator guard frame
    CONTEXT              *pContext,      // Context info
    DispatcherContext    *pDC            // Dynamic info for this frame
) {
    //
    // The handler data is a pointer to an integer that is an offset to the TGRN structure
    // relative to the frame pointer.
    //
    TransGuardRec *pTransGuardData = (TransGuardRec*)((char*)pFrame->MemoryStackFp - *(int*)(pDC->FunctionEntry->HandlerData));
    if (IS_UNWINDING(PER_FLAGS(pExcept)))
    {
        pTransGuardData->DidUnwind = TRUE;
        return ExceptionContinueSearch;
    }
    else {
        //
        // Check for a handler:
        //
        __InternalCxxFrameHandler(  pExcept,
                                    pTransGuardData->pFrame,
                                    pContext,
                                    pDC,
                                    pTransGuardData->pFuncInfo,
                                    pTransGuardData->CatchDepth,
                                    pTransGuardData->pMarkerFrame,
                                    TRUE );
        // Unreached.
        return ExceptionContinueSearch;
        }
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
// _GetRangeOfTrysToCheck - determine which try blocks are of interest, given
//   the current catch block nesting depth.  We only check the trys at a single
//   depth.
//
// Returns:
//      Address of first try block of interest is returned
//      pStart and pEnd get the indices of the range in question
//
TryBlockMapEntry* _GetRangeOfTrysToCheck(
        EHRegistrationNode  *pRN,
        FuncInfo            *pFuncInfo,
        int                 CatchDepth,
        __ehstate_t         curState,
        unsigned            *pStart,
        unsigned            *pEnd,
        DispatcherContext   *pDC
) {
    TryBlockMapEntry *pEntry;
    unsigned num_of_try_blocks = FUNC_NTRYBLOCKS(*pFuncInfo);

    DASSERT( num_of_try_blocks > 0 );

    for( unsigned int index = 0; index < num_of_try_blocks; index++ ) {
       pEntry = FUNC_PTRYBLOCK(*pFuncInfo, index, pDC->ImageBase);
       if( curState >= TBME_LOW(*pEntry) && curState <= TBME_HIGH(*pEntry) ) {
            *pStart = index;

            *pEnd = FUNC_NTRYBLOCKS(*pFuncInfo);
            DASSERT( *pEnd <= num_of_try_blocks && *pStart < *pEnd );

            int SavedState = GetUnwindTryBlock(pRN, pDC, pFuncInfo);
            if( SavedState != -1 && SavedState >= curState )
                continue;
            return pEntry;
        }
    }

    *pStart = *pEnd = 0;
    return NULL;
}


#pragma optimize("",off)
extern "C" void _UnwindNestedFrames(
    EHRegistrationNode  *pFrame,            // Unwind up to (but not including) this frame
    EHExceptionRecord   *pExcept,           // The exception that initiated this unwind
    CONTEXT             *pContext,           // Context info for current exception
    DispatcherContext   *pDC
) {
    CONTEXT         LocalContext;           // Create context for this routine to return from RtlUnwind
    CONTEXT         ScratchContext;         // Context record to pass to RtlUnwind2 to be used as scratch
    volatile int      Unwound = FALSE;        // Flag that assist to return from RtlUnwind2
    PVOID           pReturnPoint = NULL;    // The address we want to return from RtlUnwind2

    RtlCaptureContext(&LocalContext);
    //
    // set up the return label
    //
    _GetNextInstrOffset(&pReturnPoint);
    if(Unwound)
        goto LAB_UNWOUND;

    LocalContext.Rip = (ULONGLONG)pReturnPoint;
    pUnwindContext = &LocalContext;
    Unwound = TRUE;
#ifdef _NT
    RtlUnwindEx((void *)*pFrame, (ULONG_PTR)pReturnPoint, (PEXCEPTION_RECORD)pExcept, NULL, &ScratchContext, pDC->HistoryTable);
#else
    RtlUnwindEx((void *)*pFrame, pReturnPoint, (PEXCEPTION_RECORD)pExcept, NULL, &ScratchContext, pDC->HistoryTable);
#endif

LAB_UNWOUND:
    PER_FLAGS(pExcept) &= ~EXCEPTION_UNWINDING;
    pUnwindContext = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\user.cpp ===
/***
*user.cxx - E.H. functions only called by the client programs
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Exception handling functions only called by the client programs,
*       not by the C/C++ runtime itself.
*
*       Entry Points:
*       * set_terminate
*       * set_unexpected
*       * _set_seh_translator
*       * _set_inconsistency
*
*Revision History:
*       ??-??-93  BS    Module created
*       10-17-94  BWT   Disable code for PPC.
*       02-06-95  CFW   Test only for debug build.
*       02-09-95  JWM   Mac merge.
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#include <stddef.h>
#include <windows.h>
#include <mtdll.h>
#include <ehassert.h>
#include <eh.h>
#include <ehhooks.h>

#pragma hdrstop

/////////////////////////////////////////////////////////////////////////////
//
// set_terminate - install a new terminate handler (ANSI Draft 17.1.2.1.3)
//

_CRTIMP terminate_function __cdecl
set_terminate( terminate_function pNew )
{
    terminate_function pOld = NULL;

#if defined(_DEBUG)

#pragma warning(disable:4191)

    if ( (pNew == NULL) || _ValidateExecute( (FARPROC) pNew ) )

#pragma warning(default:4191)

#endif
    {
        pOld = __pTerminate;
        __pTerminate = pNew;
    }

    return pOld;
}


/////////////////////////////////////////////////////////////////////////////
//
// set_unexpected - install a new unexpected handler (ANSI Draft 17.1.2.1.3)
//

_CRTIMP unexpected_function __cdecl
set_unexpected( unexpected_function pNew )
{
    unexpected_function pOld = NULL;

#if defined(_DEBUG)

#pragma warning(disable:4191)

    if ( (pNew == NULL) || _ValidateExecute( (FARPROC) pNew ) )

#pragma warning(default:4191)

#endif
    {
        pOld = __pUnexpected;
        __pUnexpected = pNew;
    }

    return pOld;
}


/////////////////////////////////////////////////////////////////////////////
//
// _set_se_translator - install a new SE to C++ EH translator.
//
// The 'new' seh translator may be NULL, because the default one is.
//

_CRTIMP _se_translator_function __cdecl
_set_se_translator( _se_translator_function pNew )
{
    _se_translator_function pOld = NULL;

#ifdef _DEBUG

#pragma warning(disable:4191)

    if ( (pNew == NULL) || _ValidateExecute( (FARPROC)pNew ) )

#pragma warning(default:4191)

#endif
    {
        pOld = __pSETranslator;
        __pSETranslator = pNew;
    }

    return pOld;
}

/////////////////////////////////////////////////////////////////////////////
//
// _set_inconsistency - install a new inconsistency handler(Internal Error)
//
// (This function is currently not documented for end-users.  At some point,
//  it might be advantageous to allow end-users to "catch" internal errors
//  from the EH CRT, but for now, they will terminate(). )

_inconsistency_function __cdecl
__set_inconsistency( _inconsistency_function pNew)
{
    _inconsistency_function pOld = NULL;

#if defined(_DEBUG)

#pragma warning(disable:4191)

    if ( (pNew == NULL) || _ValidateExecute( (FARPROC)pNew ) )

#pragma warning(default:4191)

#endif
    {
        pOld = __pInconsistency;
        __pInconsistency = pNew;
    }

    return pOld;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\i386\ehprolg2.c ===
/***
*ehprolg2.c - Defines _EH_prolog2 compiler helper
*
*       Copyright (c) 1999-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       EH prologue helper function for an aligned stack.
*
*Revision History:
*       11-14-99  JB    Module created
*
****/

/***
*void _EH_prolog2(alignment) - set up aligned stack with EH frame
*
*Purpose:
*       Sets up an aligned frame for a C++ EH function with unwinds, by
*       creating a link in the __except_list, setting EBX as the frame
*       parameter pointer, and EBP as the frame base pointer.
*
*Entry:
*       EAX = address of EH handler thunk
*       Incoming stack frame has:
*           [ESP + 8] = callee's return address
*           [ESP + 4] = stack alignment requirement
*           [ESP + 0] = _EH_prolog2's return address
*
*Exit:
*       EAX = destroyed
*       EBX = pointer to callee's parameters
*       EBP = aligned pointer to callee's locals
*       ESP = EBP - 12
*       FS:[0] = set to EBP-8 to create new link in EH chain
*       Stack frame has been set up as follows:
*           [EBX + 4]  = (entry [ESP+8]) callee's return address
*           [EBX + 0]  = saved EBX
*           padding to align stack (if needed)
*           [EBP + 4]  = callee's return address (from [EBX+4])
*           [EBP + 0]  = saved EBP
*           [EBP - 4]  = EH record state index, initialized to -1
*           [EBP - 8]  = address of EH handler thunk
*           [EBP - 12] = saved FS:[0]
*
*Exceptions:
*
*******************************************************************************/

#ifdef __cplusplus
extern "C"
#endif
void __declspec(naked) _EH_prolog2(void)
{
    /*
     * We want to generate a frame that is equivalent to
     * push ebx
     * ebx = esp
     * sub esp, 8
     * and esp, ~alignment
     * add esp, 4
     * push ebp
     * ebp = esp
     * mov [ebp+4], [ebx+4]
     * [EH record]
     */

    __asm {
        ; stack has:
        ; alignment
        ; ret addr   <== esp
    
        push        ecx           ; save ecx
                                  ; with ret addr == sub esp, 8

        ; stack has:
        ; alignment
        ; ret addr
        ; saved ecx  <== esp

        mov         ecx, [esp+8]  ; get alignment

        mov         [esp+8], ebx  ; save ebx over alignment
        lea         ebx, [esp+8]  ; set param pointer

        ; stack has:
        ; saved ebx  <== ebx
        ; ret addr
        ; saved ecx  <== esp

        neg         ecx           ; create alignment mask
        and         esp, ecx      ; align stack

        mov         ecx, [ebx-8]  ; restore ecx since it will be in the same
                                  ; location we want to store ebp if no
                                  ; padding is inserted (esp is aligned at and)
        
        mov         [esp], ebp    ; save ebp
        mov         ebp, esp      ; initialize ebp
        
        ; stack has
        ; saved ebx  <== ebx
        ; ret addr
        ; [padding]
        ; saved ebp  <== ebp, esp

        push        -1            ; create EH record
        push        eax
        mov         eax,fs:[00000000]
        push        eax
        mov         dword ptr fs:[0],esp

        push        ecx           ; we need this again

        mov         eax, [ebx-4]  ; get helper return address 

        mov         ecx, [ebx+4]  ; copy orig function caller return address
        mov         [ebp+4], ecx  ; (for ebp-based stack walks)

        pop         ecx           ; we are done

        push        eax           ; eax has return address

        ret
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\i386\ehprolog.asm ===
;***
;ehprolog.asm   - defines __EH_prolog
;
;	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       EH prolog helper function. Sets up the frame for a C++ EH function
;       with unwinds, by creating a link in the __except_list, and by setting
;       up EBP as frame base pointer.
;
;Revision History:
;	10-27-94  LL	Module created.
;	10-27-94  CFW	Comments added.
;	01-11-95  SKS	Remove MASM 5.X support
;
;*******************************************************************************
	title	ehprolog.asm
	.386P

.model FLAT

	ASSUME	FS: FLAT

PUBLIC	__EH_prolog

_TEXT	SEGMENT

__EH_prolog PROC NEAR
	push	-1			; State index
	push	eax			; Push address of handler thunk
	mov	eax, DWORD PTR fs:0
	push	eax			; List link
	mov	eax, DWORD PTR [esp+12]	; Load return address
	mov	DWORD PTR fs:0, esp
	mov	DWORD PTR [esp+12], ebp	; Save old ebp on the stack
	lea	ebp, DWORD PTR [esp+12]	; Set ebp to the base of the frame
	push	eax			; Push return addr on top of the stack
	ret	0			; JMP [eax] would be bad on P6
__EH_prolog ENDP

_TEXT	ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\i386\lowhelpr.asm ===
;***
;lowhelpr.asm
;
;	Copyright (C) 1995-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Contains _CallSettingFrame(), which must be in asm for NLG purposes.
;
;Notes:
;
;Revision History:
;	03-30-95  JWM	Module created.
;	06-09-95  JWM	NLG_CATCH_LEAVE now implemented.
;	08-21-95  JWM	Bug fix: Olympus 16585.
;	08-30-96  SKS	Save esi, edi around call to funclet
;	09-12-95  JWM	labvel _NLG_Return moved above new pops (Orion 9224).
;	03-09-01  PML   Add FPO directives for proper callstacks (vs7#221754)
;
;*******************************************************************************
	title	lowhelpr.asm

.xlist
	include cruntime.inc
	include exsup.inc
.list

EXTERN	_NLG_Notify:NEAR
EXTERN	_NLG_Notify1:NEAR
PUBLIC	_CallSettingFrame
PUBLIC	_NLG_Return
extern	_NLG_Destination:_NLG_INFO


CODESEG

;////////////////////////////////////////////////////////////////////////////
;/
;/ _CallSettingFrame - sets up EBP and calls the specified funclet.  Restores
;/					  EBP on return.  
;/
;/ Return value is return value of funclet (whatever is in EAX).
;/


	public _CallSettingFrame

_CallSettingFrame proc stdcall, funclet:IWORD, pRN:IWORD, dwInCode:DWORD
	; FPO = 0 dwords locals allocated in prolog
	;       3 dword parameters
	;       8 bytes in prolog
	;       4 registers saved (includes locals to work around debugger bug)
	;       1 EBP is used
	;       0 frame type = FPO
	.FPO    (0,3,8,4,1,0)

	sub	esp,4
	push	ebx
	push	ecx
	mov	eax,pRN
	add	eax,0Ch			; TODO - need sizeof(EHRegistrationNode), not 0Ch
	mov	dword ptr [ebp-4],eax
	mov	eax,funclet
	push	ebp			; Save our frame pointer
        push    dwInCode
	mov	ecx,dwInCode
	mov	ebp,dword ptr [ebp-4]	; Load target frame pointer
	call	_NLG_Notify1		; Notify debugger
	push	esi
	push	edi
	call	eax			; Call the funclet
_NLG_Return::
	pop	edi
	pop	esi
	mov	ebx,ebp
	pop	ebp
        mov     ecx,dwInCode
	push	ebp
	mov	ebp,ebx
	cmp	ecx, 0100h
	jne	_NLG_Continue
        mov     ecx, 02h
_NLG_Continue:
        push    ecx
	call	_NLG_Notify1		; Notify debugger yet again
	pop	ebp			; Restore our frame pointer
	pop	ecx
	pop	ebx
	ret	0Ch
_CallSettingFrame ENDP

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\ia64\handlerc.cpp ===
//
// Created by TiborL 06/01/97
//

#ifdef WIN32_LEAN_AND_MEAN
#undef WIN32_LEAN_AND_MEAN
#endif

#pragma warning(disable:4102 4700)

extern "C" {
#include <windows.h>
};

#include <mtdll.h>

#include <ehassert.h>
#include <ehdata.h>
#include <trnsctrl.h>
#include <eh.h>
#include <ehhooks.h>

#pragma hdrstop

extern "C" void RtlCaptureContext(CONTEXT*);

extern "C" void _UnwindNestedFrames(
	EHRegistrationNode	*pFrame,		// Unwind up to (but not including) this frame
	EHExceptionRecord	*pExcept,		// The exception that initiated this unwind
	CONTEXT				*pContext		// Context info for current exception
) {
    void *pReturnPoint;					// The address we want to return from RtlUnwind
    CONTEXT LocalContext;				// Create context for this routine to return from RtlUnwind
	CONTEXT OriginalContext;			// Restore pContext from this			
    CONTEXT ScratchContext;				// Context record to pass to RtlUnwind2 to be used as scratch

    //
	// set up the return label
	//
BASE:
/*
// **** manually added to handlers.s
 {   .mii	
	nop.m	0
	mov r2=ip					    
	adds	r2=$LABEL - $BASE, r2
 }
 {   .mmi	
	adds	r30=pReturnPoint$, sp
	st4		[r30]=r2
	nop.i	0
 }
// ****
*/
	_MoveContext(&OriginalContext,pContext);
	RtlCaptureContext(&LocalContext);
	LocalContext.StIIP = (ULONGLONG)pReturnPoint;
	_MoveContext(&ScratchContext,&LocalContext);
	_SaveUnwindContext(&LocalContext);
	RtlUnwind2(*pFrame, pReturnPoint, (PEXCEPTION_RECORD)pExcept, NULL, &ScratchContext);
LABEL:
	_MoveContext(pContext,&OriginalContext);
	_SaveUnwindContext(0);
	PER_FLAGS(pExcept) &= ~EXCEPTION_UNWINDING;
}

/*
//++
//
//extern "C"
//PVOID
//__Cxx_ExecuteHandler (
//    ULONGLONG MemoryStack,
//    ULONGLONG BackingStore,
//    ULONGLONG Handler,
//    ULONGLONG GlobalPointer
//    );
//
//Routine Description:
//
//    This function scans the scope tables associated with the specified
//    procedure and calls exception and termination handlers as necessary.
//
//Arguments:
//
//    MemoryStack (r32) - memory stack pointer of establisher frame
//
//    BackingStore (r33) - backing store pointer of establisher frame
//
//    Handler (r34) - Entry point of handler
//
//    GlobalPointer (r35) - GP of termination handler
//
//Return Value:
//
//  Returns the continuation point
//
//--

   .global __Cxx_ExecuteHandler#

	.proc	__Cxx_ExecuteHandler#
	.align 32
__Cxx_ExecuteHandler:
	alloc	r2=0, 0, 2, 0
    mov     gp = r35                     // set new GP
    mov     b6 = r34                     // handler address
    br      b6                           // branch to handler
    nop.b   0
    nop.b   0
	.endp	__Cxx_ExecuteHandler#
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\ia64\ehstate.cpp ===
//
// Created by TiborL 06/01/97
//

#if defined(_NTSUBSET_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>       // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
#include <ex.h>             // ExRaiseException
}
#endif

extern "C" {
#include "windows.h"
}
#include "ehassert.h"
#include "ehdata.h"     // Declarations of all types used for EH
#include "ehstate.h"
#include "eh.h"
#include "ehhooks.h"
#include "trnsctrl.h"
#pragma hdrstop

__ehstate_t _StateFromIp(
    FuncInfo            *pFuncInfo,
    DispatcherContext   *pDC,
    __int64             Ip
) {
    unsigned int    index;          //  loop control variable
    unsigned int    nIPMapEntry;    //  # of IpMapEntry; must be > 0

    DASSERT(pFuncInfo != NULL);
    nIPMapEntry = FUNC_NIPMAPENT(*pFuncInfo);

    DASSERT(FUNC_IPMAP(*pFuncInfo, pDC->ImageBase) != NULL);

    for (index = 0; index < nIPMapEntry; index++) {
        IptoStateMapEntry    *pIPtoStateMap = FUNC_PIPTOSTATE(*pFuncInfo, index, pDC->ImageBase);
        if( Ip < (pDC->ImageBase + pIPtoStateMap->Ip) ) {
            break;
        }
    }

    if (index == 0) {
        // We are at the first entry, could be an error

        return EH_EMPTY_STATE;
    }

    // We over-shot one iteration; return state from the previous slot

    return FUNC_IPTOSTATE(*pFuncInfo, index - 1, pDC->ImageBase).State;
}

__ehstate_t _StateFromControlPc(
    FuncInfo            *pFuncInfo,
    DispatcherContext   *pDC
) {
    return _StateFromIp(pFuncInfo, pDC, pDC->ControlPc);
}

#if 0
//
// Given a state, return the corresponding IP
//
ULONG _GetIpFromState(FuncInfo *pFuncInfo, __ehstate_t state)
{
    unsigned int    index;          //  loop control variable
    unsigned int    nIPMapEntry;    //  # of IpMapEntry; must be > 0

    DASSERT(pFuncInfo != NULL);
    nIPMapEntry = FUNC_NIPMAPENT(*pFuncInfo);
    DASSERT(FUNC_IPMAP(*pFuncInfo) != NULL);
    for (index = 0; index < nIPMapEntry; index++) {
        if (state == FUNC_IPTOSTATE(*pFuncInfo, index).State) {
            return FUNC_IPTOSTATE(*pFuncInfo, index).Ip;
        }
    }
    return EH_EMPTY_STATE;
}
#endif

//
// This routine is a replacement for the corresponding macro in 'ehdata.h'
//

__ehstate_t GetCurrentState(
    EHRegistrationNode  *pFrame,
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo
) {

    if( _ExecutionInCatch(pDC,pFuncInfo) ) {
        if( UNWINDSTATE(pDC->EstablisherFrame.MemoryStackFp, -16) == -2 )
            return _StateFromControlPc(pFuncInfo, pDC);
        else
            return UNWINDSTATE(pDC->EstablisherFrame.MemoryStackFp, -16);
    }
    else if( UNWINDSTATE(pFrame->MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo)) == -2 ) {
        return _StateFromControlPc(pFuncInfo, pDC);
    }
    else {
        return UNWINDSTATE(pFrame->MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo));
    }
}

VOID SetState(
    EHRegistrationNode  *pRN,
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo,
    __ehstate_t          newState
){
    if( _ExecutionInCatch(pDC,pFuncInfo) ) {
        UNWINDSTATE(pDC->EstablisherFrame.MemoryStackFp, -16) = newState;
    }
    else {
        UNWINDSTATE(pRN->MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo)) = newState;
    }
}

VOID SetUnwindTryBlock(
    EHRegistrationNode  *pRN,
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo,
    INT                 curState
){
    EHRegistrationNode EstablisherFramePointers;
    _GetEstablisherFrame(pRN, pDC, pFuncInfo, &EstablisherFramePointers);
    if( curState > UNWINDTRYBLOCK(EstablisherFramePointers.MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo)) ) {
        UNWINDTRYBLOCK(EstablisherFramePointers.MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo)) = curState;
    }
}

INT GetUnwindTryBlock(
    EHRegistrationNode  *pRN,
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo
){
    EHRegistrationNode EstablisherFramePointers;
    _GetEstablisherFrame(pRN, pDC, pFuncInfo, &EstablisherFramePointers);
    return UNWINDTRYBLOCK(EstablisherFramePointers.MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\cfinfo.c ===
/***
*cfinfo.c - clears C file info flag
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Clears the C file info flag.  By default, the openfile information
*	is NOT passed along to children on spawn/exec calls.  If the flag
*	is set, openfile information WILL get passed on to children on
*	spawn/exec calls.
*
*Revision History:
*	06-07-89   PHG	Module created, based on asm version
*	04-03-90   GJF	Added #include <cruntime.h>. Also, fixed the copyright.
*	01-23-92   GJF	Added #include <stdlib.h> (contains decl of _fileinfo).
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

int _fileinfo = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\cenvarg.c ===
/***
*cenvarg.c - set up environment, command line blocks
*
*       Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _cenvarg() - setup environment/command line blocks
*
*Revision History:
*       05-20-86  SKS   Module created
*       10-03-86  SKS   Wasn't clearing final null byte in environment block
*       10-13-86  SKS   Check for environment segment > 32 KB (esp. > 64 KB)
*       10-23-86  SKS   New format for C_FILE_INFO for Prot-Mode execution
*       12-17-86  SKS   Support for new command line format
*       01-21-87  BCM   Removed DCR475 switch, new command line format official
*       07-07-87  JCR   Corrected bug in ENV_MAX check
*       05-24-88  SJM   Removed support for ;C_FILE_INFO for Real-Mode execution
*       06-01-88  SJM   Added support for .cmd files via comname/cmdname
*       12-27-88  JCR   Added support for _fileinfo option
*       03-08-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and fixed
*                       the copyright. Also, cleaned up the formatting a bit.
*       04-02-90  GJF   Added const to arg types.
*       08-10-90  SBM   Compiles cleanly with -W3
*       09-27-90  GJF   New-style function declarator.
*       12-06-90  GJF   Added Win32 support. That is, support for encoding
*                       _osfinfo[] data into _C_FILE_INFO environment variable.
*       01-18-91  GJF   ANSI naming.
*       02-05-91  SRW   Removed usage of _C_FILE_INFO to pass binary data
*                       to child process.  [_WIN32_]
*       05-07-92  SKS   Remove code which stripped the extension from a batch
*                       file while building arguments to CMD.EXE.  This was
*                       done long ago (1988) for DOS 3.X, I think.
*       10-24-92  SKS   Remove special code for batch files - not needed on NT
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-15-93  SRW   Added _capture_argv function
*       08-31-93  GJF   Merged NT SDK and Cuda version. Also cleaned up the
*                       formating and removed (obsolete) Cruiser support.
*       12-07-93  CFW   Wide char enable.
*       12-08-94  CFW   Get wide environment if needed.
*       01-10-95  CFW   Debug CRT allocs.
*       03-13-96  JWM   Get all environments as needed; free buffers on exit.
*       08-15-96  JWM   Remove all 32K limitations on spawned processes.
*       12-15-98  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <errno.h>
#include <msdos.h>
#include <stdlib.h>
#include <stdarg.h>
#include <internal.h>
#include <string.h>
#include <awint.h>
#include <tchar.h>
#include <dbgint.h>

#define ENV_MAX 32767

/* local tchar */
#ifdef  WPRFLAG
#define _tenvptr    _wenvptr
#else
#define _tenvptr    _aenvptr
#endif

/***
*int _cenvarg(argv, envp, argblk, envblk, name) - set up cmd line/environ
*
*Purpose:
*       Set up the block forms of  the environment and the command line.
*       If "envp" is null, "_environ" is used instead.
*       File handle info is passed in the environment if _fileinfo is !0.
*
*Entry:
*       _TSCHAR **argv   - argument vector
*       _TSCHAR **envp   - environment vector
*       _TSCHAR **argblk - pointer to pointer set to malloc'ed space for args
*       _TSCHAR **envblk - pointer to pointer set to malloc'ed space for env
*       _TSCHAR *name    - name of program being invoked
*
*Exit:
*       returns 0 if ok, -1 if fails
*       stores through argblk and envblk
*       (calls malloc)
*
*Exceptions:
*
*******************************************************************************/

#ifdef  WPRFLAG
int __cdecl _wcenvarg (
#else
int __cdecl _cenvarg (
#endif
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envp,
        _TSCHAR **argblk,
        _TSCHAR **envblk,
        const _TSCHAR *name
        )
{
        REG1 const _TSCHAR * const *vp;
        REG2 unsigned tmp;
        REG3 _TSCHAR *cptr;
        unsigned arg_len;
        int cfi_len;            /* counts the number of file handles in CFI */

        /*
         * Null environment pointer "envp" means use global variable,
         * "_environ"
         */

        int cwd_start;
        int cwd_end;            /* length of "cwd" strings in environment */

        /*
         * Allocate space for command line string
         *  tmp counts the number of bytes in the command line string
         *      including spaces between arguments
         *  An empty string is special -- 2 bytes
         */

        for (vp = argv, tmp = 2; *vp; tmp += (unsigned int)_tcslen(*vp++) + 1) ;

        arg_len = tmp;

        /*
         * Allocate space for the command line plus 2 null bytes
         */

        if ( (*argblk = _malloc_crt(tmp * sizeof(_TSCHAR))) == NULL)
        {
                *envblk = NULL;
                errno = ENOMEM;
                _doserrno = E_nomem;
                return(-1);
        }

        /*
         * Allocate space for environment strings
         *  tmp counts the number of bytes in the environment strings
         *      including nulls between strings
         *  Also add "_C_FILE_INFO=" string
         */
        if (envp)
                for (vp = envp, tmp = 2; *vp; tmp += (unsigned int)_tcslen(*vp++) + 1) ;

        /*
         * The _osfile and _osfhnd arrays are passed as binary data in
         * dospawn.c
         */
        cfi_len = 0;    /* no _C_FILE_INFO */

        if (!envp)
                *envblk = NULL;
        else {
                /*
                 * Now that we've decided to pass our own environment block,
                 * compute the size of the "current directory" strings to
                 * propagate to the new environment.
                 */

#ifdef  WPRFLAG
            /*
             * Make sure wide environment exists.
             */
            if (!_wenvptr)
            {
                    if ((_wenvptr = (wchar_t *)__crtGetEnvironmentStringsW()) == NULL)
                    return -1;
            }
#else
            if (!_aenvptr)
            {
                    if ((_aenvptr = (char *)__crtGetEnvironmentStringsA()) == NULL)
                    return -1;
            }
#endif

            /*
                 * search for the first one
                 */
                for (cwd_start = 0;
                     _tenvptr[cwd_start] != _T('\0') &&
                       _tenvptr[cwd_start] != _T('=');
                     cwd_start += (int)_tcslen(&_tenvptr[cwd_start]) + 1)
                {
                }

                /* find the total size of all contiguous ones */
                cwd_end = cwd_start;
                while (_tenvptr[cwd_end+0] == _T('=') &&
                       _tenvptr[cwd_end+1] != _T('\0') &&
                       _tenvptr[cwd_end+2] == _T(':') &&
                       _tenvptr[cwd_end+3] == _T('='))
                {
                        cwd_end += 4 + (int)_tcslen(&_tenvptr[cwd_end+4]) + 1;
                }
                tmp += cwd_end - cwd_start;

                /*
                 * Allocate space for the environment strings plus extra null byte
                 */
                if( !(*envblk = _malloc_crt(tmp * sizeof(_TSCHAR))) )
            {
                        _free_crt(*argblk);
                        *argblk = NULL;
                        errno = ENOMEM;
                        _doserrno = E_nomem;
                        return(-1);
                }

        }

        /*
         * Build the command line by concatenating the argument strings
         * with spaces between, and two null bytes at the end.
         * NOTE: The argv[0] argument is followed by a null.
         */

        cptr = *argblk;
        vp = argv;

        if (!*vp)       /* Empty argument list ? */
                ++cptr; /* just two null bytes */
        else {          /* argv[0] must be followed by a null */
                _tcscpy(cptr, *vp);
                cptr += (int)_tcslen(*vp++) + 1;
        }

        while( *vp ) {
                _tcscpy(cptr, *vp);
                cptr += (int)_tcslen(*vp++);
                *cptr++ = ' ';
        }

        *cptr = cptr[ -1 ] = _T('\0'); /* remove extra blank, add double null */

        /*
         * Build the environment block by concatenating the environment
         * strings with nulls between and two null bytes at the end
         */

        cptr = *envblk;

        if (envp != NULL) {
                /*
                 * Copy the "cwd" strings to the new environment.
                 */
                memcpy(cptr, &_tenvptr[cwd_start], (cwd_end - cwd_start) * sizeof(_TSCHAR));
                cptr += cwd_end - cwd_start;

                /*
                 * Copy the environment strings from "envp".
                 */
                vp = envp;
                while( *vp ) {
                        _tcscpy(cptr, *vp);
                        cptr += 1 + (int)_tcslen(*vp++);
                }
        }

        if (cptr != NULL) {
                if (cptr == *envblk) {
                        /*
                         * Empty environment block ... this requires two
                         * nulls.
                         */
                        *cptr++ = _T('\0');
                }
                /*
                 * Extra null terminates the segment
                 */
                *cptr = _T('\0');
        }

#ifdef  WPRFLAG
        _free_crt(_wenvptr);
        _wenvptr = NULL;
#else
        _free_crt(_aenvptr);
        _aenvptr = NULL;
#endif
        return(0);
}


#ifndef _M_IX86

/***
*int _capture_argv(arglist, static_argv, max_static_entries) - set up argv array
*       for exec?? functions
*
*Purpose:
*       Set up the argv array for the exec?? functions by captures the
*       arguments from the passed va_list into the static_argv array.  If the
*       size of the static_argv array as specified by the max_static_entries
*       parameter is not large enough, then allocates a dynamic array to hold
*       the arguments. Return the address of the final argv array.  If NULL
*       then not enough memory to hold argument array.  If different from
*       static_argv parameter then call must free the return argv array when
*       done with it.
*
*       The scan of the arglist is terminated when a NULL argument is
*       reached. The terminating NULL parameter is stored in the resulting
*       argv array.
*
*Entry:
*       va_list *arglist          - pointer to variable length argument list.
*       _TSCHAR *firstarg            - first argument to store in array
*       _TSCHAR **static_argv        - pointer to static argv to use.
*       size_t max_static_entries - maximum number of entries that can be
*                                   placed in static_argv array.
*
*Exit:
*       returns NULL if no memory.
*       Otherwise returns pointer to argv array.
*       (sometimes calls malloc)
*
*Exceptions:
*
*******************************************************************************/

#ifdef  WPRFLAG
_TSCHAR ** __cdecl _wcapture_argv(
#else
_TSCHAR ** __cdecl _capture_argv(
#endif
        va_list *arglist,
        const _TSCHAR *firstarg,
        _TSCHAR **static_argv,
        size_t max_static_entries
        )
{
        _TSCHAR ** argv;
        _TSCHAR * nextarg;
        size_t i;
        size_t max_entries;

        nextarg = (_TSCHAR *)firstarg;
        argv = static_argv;
        max_entries = max_static_entries;
        i = 0;
        for (;;) {
            if (i >= max_entries) {
                if (argv == static_argv)
                    argv = _malloc_crt((max_entries * 2) * sizeof(_TSCHAR *));
                else
                    argv = _realloc_crt(argv, (max_entries * 2) * sizeof(_TSCHAR *));

                if (argv == NULL) break;
                max_entries += max_entries;
            }

            argv[ i++ ] = nextarg;
            if (nextarg == NULL) break;
            nextarg = va_arg(*arglist, _TSCHAR *);
        }

        return argv;
}

#endif  /* _M_IX86 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\i386\trnsctrl.cpp ===
/***
*trnsctrl.cxx -  Routines for doing control transfers
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Routines for doing control transfers; written using inline
*       assembly in naked functions.  Contains the public routine
*       _CxxFrameHandler, the entry point for the frame handler
*
*Revision History:
*       05-24-93  BES   Module created
*       01-13-95  JWM   NLG notifications now called from _CallSettingFrame().
*       04-10-95  JWM   _CallSettingFrame() moved to lowhelpr.asm
*       10-22-99  PML   Add EHTRACE support
*       11-30-99  PML   Compile /Wp64 clean.
*       01-31-00  PML   Disable new warning C4851
*       02-14-00  PML   C4851 in VC6PP is C4731 in VC7
*       03-02-00  PML   Preserve callee-save regs across RtlUnwind (VS7#83643).
*       03-03-00  PML   No more C4851, it's only C4731
*
****/

#include <windows.h>

#include <mtdll.h>

#include <ehdata.h>
#include <trnsctrl.h>
#include <eh.h>
#include <ehhooks.h>
#include <ehassert.h>

#pragma hdrstop

#include <setjmp.h>

#pragma warning(disable:4311 4312)      // x86 specific, ignore /Wp64 warnings
#pragma warning(disable:4731)           // ignore EBP mod in inline-asm warning

#ifdef _MT
#define pFrameInfoChain   (*((FRAMEINFO **)    &(_getptd()->_pFrameInfoChain)))
#else
static FRAMEINFO          *pFrameInfoChain     = NULL;        // used to remember nested frames
#endif

/////////////////////////////////////////////////////////////////////////////
//
// _JumpToContinuation - sets up EBP and jumps to specified code address.
//
// Does not return.
//
// NT leaves a marker registration node at the head of the list, under the
// assumption that RtlUnwind will remove it.  As it happens, we need to keep
// it in case of a rethrow (see below).  We only remove the current head
// (assuming it is NT's), because there may be other nodes that we still
// need.
//

void __stdcall _JumpToContinuation(
    void                *target,    // The funclet to call
    EHRegistrationNode  *pRN        // Registration node, represents location of frame
) {
    EHTRACE_ENTER_FMT1("Transfer to 0x%p", target);
    EHTRACE_RESET;

    register long targetEBP;

#if !CC_EXPLICITFRAME
    targetEBP = (long)pRN + FRAME_OFFSET;
#else
    targetEBP = pRN->frame;
#endif

    __asm {
        //
        // Unlink NT's marker node:
        //
        mov     ebx, FS:[0]
        mov     eax, [ebx]
        mov     FS:[0], eax

        //
        // Transfer control to the continuation point
        //
        mov     eax, target         // Load target address
        mov     ebx, pRN            // Restore target esp
        mov     esp, [ebx-4]
        mov     ebp, targetEBP      // Load target frame pointer
        jmp     eax                 // Call the funclet
        }
    }


/////////////////////////////////////////////////////////////////////////////
//
// _CallMemberFunction0 - call a parameterless member function using __thiscall
//                       calling convention, with 0 parameters.
//

__declspec(naked) void __stdcall _CallMemberFunction0(
    void *pthis,        // Value for 'this' pointer
    void *pmfn          // Pointer to the member function
) {
    __asm {
        pop     eax         // Save return address
        pop     ecx         // Get 'this'
        xchg    [esp],eax   // Get function address, stash return address
        jmp     eax         // jump to the function (function will return
                            // to caller of this func)
        }
    }


/////////////////////////////////////////////////////////////////////////////
//
// _CallMemberFunction1 - call a member function using __thiscall
//                       calling convention, with 1 parameter.
//

__declspec(naked) void __stdcall _CallMemberFunction1(
    void *pthis,        // Value for 'this' pointer
    void *pmfn,         // Pointer to the member function
    void *pthat         // Value of 1st parameter (type assumes copy ctor)
) {
    __asm {
        pop     eax         // Save return address
        pop     ecx         // Get 'this'
        xchg    [esp],eax   // Get function address, stash return address
        jmp     eax         // jump to the function (function will return
                            // to caller of this func)
        }
    }


/////////////////////////////////////////////////////////////////////////////
//
// _CallMemberFunction2 - call a member function using __thiscall
//                       calling convention, with 2 parameter.
//

__declspec(naked) void __stdcall _CallMemberFunction2(
    void *pthis,        // Value for 'this' pointer
    void *pmfn,         // Pointer to the member function
    void *pthat,        // Value of 1st parameter (type assumes copy ctor)
    int   val2          // Value of 2nd parameter (type assumes copy ctor w/vb)
) {
    __asm {
        pop     eax         // Save return address
        pop     ecx         // Get 'this'
        xchg    [esp],eax   // Get function address, stash return address
        jmp     eax         // jump to the function (function will return
                            // to caller of this func)
        }
    }


/////////////////////////////////////////////////////////////////////////////
//
// _UnwindNestedFrames - Call RtlUnwind, passing the address after the call
//                      as the continuation address.
//
//  Win32 assumes that after a frame has called RtlUnwind, it will never return
// to the dispatcher.
//
// Let me explain:  
//  When the dispatcher calls a frame handler while searching
// for the appropriate handler, it pushes an extra guard registration node
// onto the list.  When the handler returns to the dispatcher, the dispatcher
// assumes that its node is at the head of the list, restores esp from the
// address of the head node, and then unlinks that node from the chain.
//  However, if RtlUnwind removes ALL nodes below the specified node, including
// the dispatcher's node, so without intervention the result is that the 
// current subject node gets poped from the list, and the stack pointer gets
// reset to somewhere within the frame of that node, which is totally bogus
// (this last side effect is not a problem, because esp is then immediately
// restored from the ebp chain, which is still valid).
//
// So:
//  To get arround this, WE ASSUME that the registration node at the head of
// the list is the dispatcher's marker node (which it is in NT 1.0), and
// we keep a handle to it when we call RtlUnwind, and then link it back in
// after RtlUnwind has done its stuff.  That way, the dispatcher restores
// its stack exactly as it expected to, and leave our registration node alone.
//
// What happens if there is an exception during the unwind?
// We can't put a registration node here, because it will be removed 
// immediately.
//
// RtlUnwind:
//  RtlUnwind is evil.  It trashes all the registers except EBP and ESP.
// Because of that, EBX, ESI, and EDI must be preserved by this function,
// and the compiler may not assume that any callee-save register can be used
// across the call to RtlUnwind.  To accomplish the former, inline-asm code
// here uses EBX, ESI, and EDI, so they will be saved in the prologue.  For
// the latter, optimizations are disabled for the duration of this function.
//

#pragma optimize("g", off)      // WORKAROUND for DOLPH:3322

void __stdcall _UnwindNestedFrames(
    EHRegistrationNode *pRN,        // Unwind up to (but not including) this frame
    EHExceptionRecord   *pExcept    // The exception that initiated this unwind
) {
    EHTRACE_ENTER;

    void* pReturnPoint;
    EHRegistrationNode *pDispatcherRN;  // Magic!

    __asm {
        //
        // Save the dispatcher's marker node
        //
        // NOTE: RtlUnwind will trash the callee-save regs EBX, ESI, and EDI.
        // We explicitly use them here in the inline-asm so they get preserved
        // and restored by the function prologue/epilogue.
        //
        mov     esi, dword ptr FS:[0]   // use ESI
        mov     pDispatcherRN, esi
    }

    __asm mov pReturnPoint, offset ReturnPoint
    RtlUnwind(pRN, pReturnPoint, (PEXCEPTION_RECORD)pExcept, NULL);

ReturnPoint:

    PER_FLAGS(pExcept) &= ~EXCEPTION_UNWINDING; // Clear the 'Unwinding' flag
                                                // in case exception is rethrown
    __asm {
        //
        // Re-link the dispatcher's marker node
        //
        mov     edi, dword ptr FS:[0]   // Get the current head (use EDI)
        mov     ebx, pDispatcherRN      // Get the saved head (use EBX)
        mov     [ebx], edi              // Link saved head to current head
        mov     dword ptr FS:[0], ebx   // Make saved head current head
        }

    EHTRACE_EXIT;

    return;
    }

#pragma optimize("", on)

/////////////////////////////////////////////////////////////////////////////
//
// __CxxFrameHandler - Real entry point to the runtime; this thunk fixes up
//      the parameters, and then calls the workhorse.
//
extern "C" EXCEPTION_DISPOSITION __cdecl __InternalCxxFrameHandler(
    EHExceptionRecord  *pExcept,        // Information for this exception
    EHRegistrationNode *pRN,            // Dynamic information for this frame
    void               *pContext,       // Context info (we don't care what's in it)
    DispatcherContext  *pDC,            // More dynamic info for this frame (ignored on Intel)
    FuncInfo           *pFuncInfo,      // Static information for this frame
    int                 CatchDepth,     // How deeply nested are we?
    EHRegistrationNode *pMarkerRN,      // Marker node for when checking inside
                                        //  catch block
    BOOL                recursive);     // True if this is a translation exception

extern "C" _CRTIMP __declspec(naked) EXCEPTION_DISPOSITION __cdecl __CxxFrameHandler(
/*
    EAX=FuncInfo   *pFuncInfo,          // Static information for this frame
*/
    EHExceptionRecord  *pExcept,        // Information for this exception
    EHRegistrationNode *pRN,            // Dynamic information for this frame
    void               *pContext,       // Context info (we don't care what's in it)
    DispatcherContext  *pDC             // More dynamic info for this frame (ignored on Intel)
) {
    FuncInfo   *pFuncInfo;
    EXCEPTION_DISPOSITION result;

    __asm {
        //
        // Standard function prolog
        //
        push    ebp
        mov     ebp, esp
        sub     esp, __LOCAL_SIZE
        push    ebx
        push    esi
        push    edi
        cld             // A bit of paranoia -- Our code-gen assumes this

        //
        // Save the extra parameter
        //
        mov     pFuncInfo, eax
        }

    EHTRACE_ENTER_FMT1("pRN = 0x%p", pRN);

    result = __InternalCxxFrameHandler( pExcept, pRN, pContext, pDC, pFuncInfo, 0, NULL, FALSE );

    EHTRACE_HANDLER_EXIT(result);

    __asm {
        pop     edi
        pop     esi
        pop     ebx
        mov     eax, result
        mov     esp, ebp
        pop     ebp
        ret     0
        }
}

/////////////////////////////////////////////////////////////////////////////
//
// __CxxLongjmpUnwind - Entry point for local unwind required by longjmp
//      when setjmp used in same function as C++ EH.
//
extern "C" void __FrameUnwindToState(   // in frame.cpp
    EHRegistrationNode *pRN,            // Dynamic information for this frame
    DispatcherContext  *pDC,            // More dynamic info for this frame (ignored on Intel)
    FuncInfo           *pFuncInfo,      // Static information for this frame
    __ehstate_t         targetState);   // State to unwind to

extern "C" void __stdcall __CxxLongjmpUnwind(
    _JUMP_BUFFER       *jbuf
) {
    EHTRACE_ENTER;

    __FrameUnwindToState((EHRegistrationNode *)jbuf->Registration,
                         (DispatcherContext*)NULL,
                         (FuncInfo *)jbuf->UnwindData[0],
                         (__ehstate_t)jbuf->TryLevel);

    EHTRACE_EXIT;
}

/////////////////////////////////////////////////////////////////////////////
//
// _CallCatchBlock2 - The nitty-gritty details to get the catch called
//      correctly.
//
// We need to guard the call to the catch block with a special registration
// node, so that if there is an exception which should be handled by a try
// block within the catch, we handle it without unwinding the SEH node
// in CallCatchBlock.
//

struct CatchGuardRN {
    EHRegistrationNode *pNext;          // Frame link
    void               *pFrameHandler;  // Frame Handler
    FuncInfo           *pFuncInfo;      // Static info for subject function
    EHRegistrationNode *pRN;            // Dynamic info for subject function
    int                 CatchDepth;     // How deeply nested are we?
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
    int                 trace_level;    // Trace level to restore in handler
#endif
    };

static EXCEPTION_DISPOSITION __cdecl CatchGuardHandler( EHExceptionRecord*, CatchGuardRN *, void *, void * );

void *_CallCatchBlock2(
    EHRegistrationNode *pRN,            // Dynamic info of function with catch
    FuncInfo           *pFuncInfo,      // Static info of function with catch
    void               *handlerAddress, // Code address of handler
    int                CatchDepth,      // How deeply nested in catch blocks are we?
    unsigned long      NLGCode
) {
    EHTRACE_ENTER;

    //
    // First, create and link in our special guard node:
    //
    CatchGuardRN CGRN = { NULL,
                          (void*)CatchGuardHandler,
                          pFuncInfo,
                          pRN,
                          CatchDepth + 1
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
                          , __ehtrace_level
#endif
    };

    __asm {
        mov     eax, FS:[0]     // Fetch frame list head
        mov     CGRN.pNext, eax // Link this node in
        lea     eax, CGRN       // Put this node at the head
        mov     FS:[0], eax
        }

    //
    // Call the catch
    //
    void *continuationAddress = _CallSettingFrame( handlerAddress, pRN, NLGCode );

    //
    // Unlink our registration node
    //
    __asm {
        mov     eax, CGRN.pNext // Get parent node
        mov     FS:[0], eax     // Put it at the head
        }

    EHTRACE_EXIT;

    return continuationAddress;
    }


/////////////////////////////////////////////////////////////////////////////
//
// CatchGuardHandler - frame handler for the catch guard node.
//
// This function will attempt to find a handler for the exception within
// the current catch block (ie any nested try blocks).  If none is found,
// or the handler rethrows, returns ExceptionContinueSearch; otherwise does
// not return.
//
// Does nothing on an unwind.
//

static EXCEPTION_DISPOSITION __cdecl CatchGuardHandler( 
    EHExceptionRecord  *pExcept,        // Information for this exception
    CatchGuardRN       *pRN,            // The special marker frame
    void               *pContext,       // Context info (we don't care what's in it)
    void *                              // (ignored)
) {
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
    EHTracePushLevel(pRN->trace_level);
#endif
    EHTRACE_ENTER_FMT1("pRN = 0x%p", pRN);

    __asm cld;      // Our code-gen assumes this
        
    EXCEPTION_DISPOSITION result =
        __InternalCxxFrameHandler( pExcept,
                                   pRN->pRN,
                                   pContext,
                                   NULL,
                                   pRN->pFuncInfo,
                                   pRN->CatchDepth,
                                   (EHRegistrationNode*)pRN,
                                   FALSE );

    EHTRACE_HANDLER_EXIT(result);
    EHTRACE_RESTORE_LEVEL(true);
    return result;
    }


/////////////////////////////////////////////////////////////////////////////
//
// CallSEHTranslator - calls the SEH translator, and handles the translation
//      exception.
//
// Assumes that a valid translator exists.
//
// Method:
//  Sets up a special guard node, whose handler handles the translation 
// exception, and remembers NT's marker node (See _UnwindNestedFrames above).
// If the exception is not fully handled, the handler returns control to here,
// so that this function can return to resume the normal search for a handler
// for the original exception.
//
// Returns: TRUE if translator had a translation (handled or not)
//          FALSE if there was no translation
//          Does not return if translation was fully handled
//

struct TranslatorGuardRN /*: CatchGuardRN */ {
    EHRegistrationNode *pNext;          // Frame link
    void               *pFrameHandler;  // Frame Handler
    FuncInfo           *pFuncInfo;      // Static info for subject function
    EHRegistrationNode *pRN;            // Dynamic info for subject function
    int                 CatchDepth;     // How deeply nested are we?
    EHRegistrationNode *pMarkerRN;      // Marker for parent context
    void               *pContinue;      // Continuation address within CallSEHTranslator
    void               *ESP;            // ESP within CallSEHTranslator
    void               *EBP;            // EBP within CallSEHTranslator
    BOOL                DidUnwind;      // True if this frame was unwound
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
    int                 trace_level;    // Trace level to restore in handler
#endif
    };

static EXCEPTION_DISPOSITION __cdecl TranslatorGuardHandler( EHExceptionRecord*, TranslatorGuardRN *, void *, void * );

#pragma optimize("g", off)              // WORKAROUND for DOLPH:3322

BOOL _CallSETranslator(
    EHExceptionRecord  *pExcept,        // The exception to be translated
    EHRegistrationNode *pRN,            // Dynamic info of function with catch
    void               *pContext,       // Context info (we don't care what's in it)
    DispatcherContext  *pDC,            // More dynamic info of function with catch (ignored)
    FuncInfo           *pFuncInfo,      // Static info of function with catch
    int                 CatchDepth,     // How deeply nested in catch blocks are we?
    EHRegistrationNode *pMarkerRN       // Marker for parent context
) {
    EHTRACE_ENTER;

    //
    // Create and link in our special guard node:
    //
    TranslatorGuardRN TGRN = {  NULL,       // Frame link
                                (void*)TranslatorGuardHandler, 
                                pFuncInfo, 
                                pRN, 
                                CatchDepth,
                                pMarkerRN,
                                NULL,       // Continue
                                NULL,       // ESP
                                NULL,       // EBP
                                FALSE       // DidUnwind
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
                                , __ehtrace_level
#endif
    };

    __asm {
        //
        // Fill in the blanks:
        //
        mov     TGRN.pContinue, offset ExceptionContinuation
        mov     TGRN.ESP, esp
        mov     TGRN.EBP, ebp

        //
        // Link this node in:
        //
        mov     eax, FS:[0]             // Fetch frame list head
        mov     TGRN.pNext, eax         // Link this node in
        lea     eax, TGRN               // Put this node at the head
        mov     FS:[0], eax
        }

    //
    // Call the translator; assume it will give a translation.
    //
    BOOL DidTranslate = TRUE;
    _EXCEPTION_POINTERS pointers = {
        (PEXCEPTION_RECORD)pExcept,
        (PCONTEXT)pContext };

    __pSETranslator(PER_CODE(pExcept), &pointers);

    //
    // If translator returned normally, that means it didn't translate the
    // exception.
    //
    DidTranslate = FALSE;

    //
    // Here's where we pick up if the translator threw something.
    // Note that ESP and EBP were restored by our frame handler.
    //
ExceptionContinuation:
    
    if (TGRN.DidUnwind) {
        //
        // If the translated exception was partially handled (ie caught but
        // rethrown), then the frame list has the NT guard for the translation
        // exception context instead of the one for the original exception 
        // context.  Correct that sequencing problem.  Note that our guard
        // node was unlinked by RtlUnwind.
        //
        __asm {
            mov     ebx, FS:[0]     // Get the node below the (bad) NT marker
            mov     eax, [ebx]      //  (it was the target of the unwind)
            mov     ebx, TGRN.pNext // Get the node we saved (the 'good' marker)
            mov     [ebx], eax      // Link the good node to the unwind target
            mov     FS:[0], ebx     // Put the good node at the head of the list
            }
        }
    else {
        //
        // Translator returned normally or translation wasn't handled.
        // unlink our registration node and exit
        //
        __asm {
            mov     eax, TGRN.pNext // Get parent node
            mov     FS:[0], eax     // Put it at the head
            }
        }

    EHTRACE_EXIT;

    return DidTranslate;
    }

#pragma optimize("g", on)


/////////////////////////////////////////////////////////////////////////////
//
// TranslatorGuardHandler - frame handler for the translator guard node.
//
// On search:
//  This frame handler will check if there is a catch at the current level
//  for the translated exception.  If there is no handler or the handler
//  did a re-throw, control is transfered back into CallSEHTranslator, based
//  on the values saved in the registration node.
//
//  Does not return.
//
// On unwind:
//  Sets the DidUnwind flag in the registration node, and returns.
//
static EXCEPTION_DISPOSITION __cdecl TranslatorGuardHandler( 
    EHExceptionRecord  *pExcept,        // Information for this exception
    TranslatorGuardRN  *pRN,            // The translator guard frame
    void               *pContext,       // Context info (we don't care what's in it)
    void *                              // (ignored)
) {
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
    EHTracePushLevel(pRN->trace_level);
#endif
    EHTRACE_ENTER_FMT1("pRN = 0x%p", pRN);

    __asm cld;      // Our code-gen assumes this

    if (IS_UNWINDING(PER_FLAGS(pExcept))) 
        {
        pRN->DidUnwind = TRUE;

        EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
        EHTRACE_RESTORE_LEVEL(true);
        return ExceptionContinueSearch;
        }
    else {
        //
        // Check for a handler:
        //
        __InternalCxxFrameHandler( pExcept, pRN->pRN, pContext, NULL, pRN->pFuncInfo, pRN->CatchDepth, pRN->pMarkerRN, TRUE );

        if (!pRN->DidUnwind) {
            //
            // If no match was found, unwind the context of the translator
            //
            _UnwindNestedFrames( (EHRegistrationNode*)pRN, pExcept );
            }

        //
        // Transfer control back to establisher:
        //

        EHTRACE_FMT1("Transfer to establisher @ 0x%p", pRN->pContinue);
        EHTRACE_RESTORE_LEVEL(false);
        EHTRACE_EXIT;

        __asm {
            mov     ebx, pRN    // Get address of registration node
            mov     esp, [ebx]TranslatorGuardRN.ESP
            mov     ebp, [ebx]TranslatorGuardRN.EBP
            jmp     [ebx]TranslatorGuardRN.pContinue
            }

        // Unreached.
        return ExceptionContinueSearch;
        }
    }


/////////////////////////////////////////////////////////////////////////////
//
// _GetRangeOfTrysToCheck - determine which try blocks are of interest, given
//   the current catch block nesting depth.  We only check the trys at a single
//   depth.
//
// Returns:
//      Address of first try block of interest is returned
//      pStart and pEnd get the indices of the range in question
//

TryBlockMapEntry* _GetRangeOfTrysToCheck(
        FuncInfo   *pFuncInfo,
        int                     CatchDepth,
        __ehstate_t curState,
        unsigned   *pStart,
        unsigned   *pEnd
) {
        TryBlockMapEntry *pEntry = FUNC_PTRYBLOCK(*pFuncInfo, 0);
        unsigned start = FUNC_NTRYBLOCKS(*pFuncInfo);
        unsigned end = start;
        unsigned end1 = end;

        while (CatchDepth >= 0) {
                DASSERT(start != -1);
                start--;
                if ( TBME_HIGH(pEntry[start]) < curState && curState <= TBME_CATCHHIGH(pEntry[start])
                        || (start == -1)
                ) {
                        CatchDepth--;
                        end = end1;
                        end1 = start;
                        }
                }

        *pStart = ++start;              // We always overshoot by 1 (we may even wrap around)
        *pEnd = end;

        DASSERT( end <= FUNC_NTRYBLOCKS(*pFuncInfo) && start <= end );

        return &(pEntry[start]);
        }


/////////////////////////////////////////////////////////////////////////////
//
// _CreateFrameInfo - Save the frame information for this scope just before
//  calling the catch block.  Put it at the head of the linked list.  For
//  x86, all we need to save is the pointer to the exception object, so we
//  can determine when that object is no longer used by any nested catch
//  handler and can thus be destroyed on exiting from a catch.
//
// Returns:
//      Pointer to the frame info (the first input argument).
//
FRAMEINFO * _CreateFrameInfo(    
    FRAMEINFO * pFrameInfo,
    PVOID       pExceptionObject   
) {
    pFrameInfo->pExceptionObject = pExceptionObject;
    pFrameInfo->pNext            = (pFrameInfo < pFrameInfoChain)? pFrameInfoChain : NULL;
    pFrameInfoChain              = pFrameInfo;
    return pFrameInfo;
}

/////////////////////////////////////////////////////////////////////////////
//
// IsExceptionObjectToBeDestroyed - Determine if an exception object is still
//  in use by a more deeply nested catch frame, or if it unused and should be
//  destroyed on exiting from the current catch block.
//
// Returns:
//      TRUE if exception object not found and should be destroyed.
//
BOOL IsExceptionObjectToBeDestroyed(
    PVOID pExceptionObject
) {
    FRAMEINFO * pFrameInfo;

    for (pFrameInfo = pFrameInfoChain; pFrameInfo != NULL; pFrameInfo = pFrameInfo->pNext ) {
        if( pFrameInfo->pExceptionObject == pExceptionObject ) {
            return FALSE;
        }
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// _FindAndUnlinkFrame - Pop the frame information for this scope that was
//  pushed by _CreateFrameInfo.  This should be the first frame in the list,
//  but the code will look for a nested frame and pop all frames, just in
//  case.
//
void _FindAndUnlinkFrame(
    FRAMEINFO * pFrameInfo
) {
    DASSERT(pFrameInfo == pFrameInfoChain);

    for (FRAMEINFO *pCurFrameInfo = pFrameInfoChain;
         pCurFrameInfo != NULL;
         pCurFrameInfo = pCurFrameInfo->pNext)
    {
        if (pFrameInfo == pCurFrameInfo) {
            pFrameInfoChain = pCurFrameInfo->pNext;
            return;
        }
    }

    // Should never be reached.
    DASSERT(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\ia64\trnsctrl.cpp ===
/***
*trnsctrl.cpp - 
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       06-01-97        Created by TiborL.
*       07-12-99  RDL   Image relative fixes under CC_P7_SOFT25.
*       10-07-99  SAH   utc_p7#1126: fix ipsr.ri reset.
*       10-19-99  TGL   Miscellaneous unwind fixes.
*       03-15-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*       03-30-00  SAH   New version of GetLanguageSpecificData from ntia64.h.
*       06-08-00  RDL   VS#111429: IA64 workaround for AV while handling throw.
*
****/

#if defined(_NTSUBSET_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>       // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
#include <ex.h>             // ExRaiseException
}
#endif

extern "C" {
#include <windows.h>
};

#include <mtdll.h>

#include <ehassert.h>
#include <ehdata.h>
#include <trnsctrl.h>
#include <ehstate.h>
#include <eh.h>
#include <ehhooks.h>
#include <kxia64.h>
#include <ia64inst.h>
#include <cvconst.h>
#pragma hdrstop

#ifdef _MT
#define pFrameInfoChain     (*((FRAMEINFO **)    &(_getptd()->_pFrameInfoChain)))
#define pUnwindContext      (*((CONTEXT **)      &(_getptd()->_pUnwindContext)))
#define _ImageBase          (_getptd()->_ImageBase)
#define _TargetGp           (_getptd()->_TargetGp)
#define _ThrowImageBase     (_getptd()->_ThrowImageBase)
#define _pCurrentException  (*((EHExceptionRecord **)&(_getptd()->_curexception)))
#else
static FRAMEINFO          *pFrameInfoChain     = NULL;        // used to remember nested frames
static CONTEXT            *pUnwindContext      = NULL;        // context to assist the return to 'UnwindNestedFrames'
static unsigned __int64   _ImageBase           = 0;
static unsigned __int64   _ThrowImageBase      = 0;
static unsigned __int64   _TargetGp            = 0;
extern EHExceptionRecord  *_pCurrentException;                // defined in frame.cpp
#endif

// Should be used out of ntia64.h, but can't figure out how to allow that with
// existing dependencies.
// If GetLanguageSpecificData changes cause a redefinition error rather than
// using wrong version.
// Version 2 = soft2.3 conventions
// Version 3 = soft2.6 conventions
#define GetLanguageSpecificData(f, base)                                      \
    ((((PUNWIND_INFO)(base + f->UnwindInfoAddress))->Version <= 2)  ?          \
    (((PVOID)(base + f->UnwindInfoAddress + sizeof(UNWIND_INFO) +             \
        ((PUNWIND_INFO)(base+f->UnwindInfoAddress))->DataLength*sizeof(ULONGLONG) + sizeof(ULONGLONG)))) : \
    (((PVOID)(base + f->UnwindInfoAddress + sizeof(UNWIND_INFO) +             \
        ((PUNWIND_INFO)(base+f->UnwindInfoAddress))->DataLength*sizeof(ULONGLONG) + sizeof(ULONG)))))

extern "C" VOID RtlRestoreContext (PCONTEXT ContextRecord,PEXCEPTION_RECORD ExceptionRecord OPTIONAL);
extern "C" void RtlCaptureContext(CONTEXT*);
extern "C" void _GetNextInstrOffset(PVOID*);
extern "C" void __FrameUnwindToState(EHRegistrationNode *, DispatcherContext *, FuncInfo *, __ehstate_t);

//
// Returns the establisher frame pointers. For catch handlers it is the parent's frame pointer.
//
EHRegistrationNode *_GetEstablisherFrame(
    EHRegistrationNode  *pRN,
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo,
    EHRegistrationNode  *pEstablisher
) {
    TryBlockMapEntry *pEntry;
    unsigned num_of_try_blocks = FUNC_NTRYBLOCKS(*pFuncInfo);
    unsigned index;
    __ehstate_t curState;

    curState = _StateFromControlPc(pFuncInfo, pDC);
    pEstablisher->MemoryStackFp = pRN->MemoryStackFp;
    pEstablisher->BackingStoreFp = pRN->BackingStoreFp;
    for (index = 0; index < num_of_try_blocks; index++) {
        pEntry = FUNC_PTRYBLOCK(*pFuncInfo, index, pDC->ImageBase);
        if (curState > TBME_HIGH(*pEntry) && curState <= TBME_CATCHHIGH(*pEntry)) {
            pEstablisher->MemoryStackFp = *(__int64 *)OffsetToAddress(-8,pRN->MemoryStackFp);
            pEstablisher->BackingStoreFp = *(__int64 *)OffsetToAddress(-16,pRN->BackingStoreFp); 
            break;
        }
    }
    return pEstablisher;
}

#if 0 // v-vadimp new version with NLG support for the debugger is in handlers.s
//
// Temporary version until the asm version is written that supports NLG
//
extern "C" void* _CallSettingFrame(
    void*               handler,
    EHRegistrationNode  *pEstablisher,
    ULONG               NLG_CODE)
{
    void* retValue = __Cxx_ExecuteHandler(
                pEstablisher->MemoryStackFp,
                pEstablisher->BackingStoreFp,
                (__int64)handler,
                _TargetGp
                );
    return retValue? (void*)(_ImageBase + (__int32)retValue) : NULL;
}
#endif

extern "C" CONTEXT* _GetUnwindContext()
{
    return pUnwindContext;
}

extern "C" unsigned __int64 _GetImageBase()
{
    return _ImageBase;
}

extern "C" VOID _SetImageBase(unsigned __int64 ImageBaseToRestore)
{
    _ImageBase = ImageBaseToRestore;
}

extern "C" unsigned __int64 _GetThrowImageBase()
{
    return _ThrowImageBase;
}

extern "C" VOID _SetThrowImageBase(unsigned __int64 NewThrowImageBase)
{
    _ThrowImageBase = NewThrowImageBase;
}

extern "C" unsigned __int64 _GetTargetGP(unsigned __int64 TargetAddress)
{
    unsigned __int64   ImageBase;
    unsigned __int64   TargetGp;

    PRUNTIME_FUNCTION pContFunctionEntry = RtlLookupFunctionEntry(TargetAddress, &ImageBase, &TargetGp);
//    return _TargetGp;
    return TargetGp;
}

extern "C" VOID _MoveContext(CONTEXT* pTarget, CONTEXT* pSource)
{
    RtlMoveMemory(pTarget, pSource, sizeof(CONTEXT));
}

// This function returns the try block for the given state if the state is in a
// catch; otherwise, NULL is returned.

static __inline TryBlockMapEntry *_CatchTryBlock(
    FuncInfo            *pFuncInfo,
    __ehstate_t         curState
) {
    TryBlockMapEntry *pEntry;
    unsigned num_of_try_blocks = FUNC_NTRYBLOCKS(*pFuncInfo);
    unsigned index;

    for (index = 0; index < num_of_try_blocks; index++) {
        pEntry = FUNC_PTRYBLOCK(*pFuncInfo, index, _ImageBase);
        if (curState > TBME_HIGH(*pEntry) && curState <= TBME_CATCHHIGH(*pEntry)) {
            return pEntry;
        }
    }

    return NULL;
}

//
// This routine returns TRUE if we are executing from within a catch.  Otherwise, FALSE is returned.
//

BOOL _ExecutionInCatch(
    DispatcherContext   *pDC,
    FuncInfo            *pFuncInfo
) {
    __ehstate_t curState =  _StateFromControlPc(pFuncInfo, pDC);
    return _CatchTryBlock(pFuncInfo, curState)? TRUE : FALSE;
}

// This function unwinds to the empty state.

VOID __FrameUnwindToEmptyState(
    EHRegistrationNode *pRN,
    DispatcherContext  *pDC,
    FuncInfo           *pFuncInfo
) {
    __ehstate_t         stateFromControlPC;
    TryBlockMapEntry    *pEntry;
    EHRegistrationNode  EstablisherFramePointers, *pEstablisher;

    pEstablisher = _GetEstablisherFrame(pRN, pDC, pFuncInfo, &EstablisherFramePointers);
    stateFromControlPC = _StateFromControlPc(pFuncInfo, pDC);
    pEntry = _CatchTryBlock(pFuncInfo, stateFromControlPC);

    // Reuse pFrameInfoChain->State to propagate the previous catch block's final state.
    // This is used in case there is a nested catch inside this catch
    // who already dtored object's in our frame. This can happen if in our catch
    // there is a nested catch that throws and the catch executed is an outer catch.
    //
    //try{
    //  try{
    //      throw(1);
    //  }catch(int){
    //      B b4;
    //      try{
    //          throw 2;
    //      }catch(int){
    //          //this throw would dtor b4 by calling the outermost catch,
    //          //and also during unwinding the first catch would try to dtor as well.
    //          throw 3;
    //      }
    //  }
    //}catch(int){
    //  throw 4;
    //}
    //
    if( pEntry && pFrameInfoChain != NULL ) {
        __ehstate_t curState = GetCurrentState(pEstablisher, pDC, pFuncInfo);
        if( pFrameInfoChain->State != -2 && pFrameInfoChain->State < curState )
            SetState(pEstablisher, pDC, pFuncInfo, pFrameInfoChain->State);
        pFrameInfoChain->State = curState;
    }
    else if( pFrameInfoChain != NULL ) {
        __ehstate_t curState = GetCurrentState(pEstablisher, pDC, pFuncInfo);
        if( pEntry == NULL && stateFromControlPC < curState ) {
            SetState(pEstablisher, pDC, pFuncInfo, stateFromControlPC - 1);
        }
        pFrameInfoChain->State = -2;
    }
    __FrameUnwindToState(pEstablisher, pDC,
        pFuncInfo, pEntry == NULL ? EH_EMPTY_STATE : TBME_HIGH(*pEntry) /*+ 1*/);
}

BOOL _IsExceptionObjectDestroyed(PVOID pExceptionObject,FRAMEINFO *pFrameInfo)
{
    for (; pFrameInfo != NULL; pFrameInfo = pFrameInfo->pNext ) {
        if( pFrameInfo->pExceptionObjectDestroyed == pExceptionObject ) {
            return TRUE;
        }
    }
    return FALSE;
}

void _MarkExceptionObjectDestroyed(EHExceptionRecord *pExcept)
{
    for (FRAMEINFO *pFrameInfo = pFrameInfoChain; pFrameInfo != NULL; pFrameInfo = pFrameInfo->pNext ) {
        if( pFrameInfo->pExcept == pExcept ) {
            pFrameInfo->pExceptionObjectDestroyed = PER_PEXCEPTOBJ(pExcept);
        }
    }
}

void _UnlinkFrame(FRAMEINFO *pFrameInfo)
{
    FRAMEINFO *pPrevFrameInfo = pFrameInfoChain;

    if( pFrameInfoChain == pFrameInfo ) {
        pFrameInfoChain = pFrameInfoChain->pNext;
        return;
    }
    for (FRAMEINFO *pCurFrameInfo = pFrameInfoChain; pCurFrameInfo != NULL; pCurFrameInfo = pCurFrameInfo->pNext ) {
        if( pCurFrameInfo == pFrameInfo ) {
            pPrevFrameInfo->pNext = pCurFrameInfo->pNext;
            return;
        }
        pPrevFrameInfo = pCurFrameInfo;
    }
}

// Find the frame info structure corresponding to the given address.  Return
// NULL if the frame info structure does not exist.

FRAMEINFO *_FindFrameInfo(
    PVOID     pContinuation,
    FRAMEINFO *pFrameInfo
) {
    unsigned __int64 ImageBase;
    unsigned __int64 TargetGp;

    PRUNTIME_FUNCTION pContFunctionEntry = RtlLookupFunctionEntry((unsigned __int64)pContinuation, &ImageBase, &TargetGp);
    PRUNTIME_FUNCTION pFrameFunctionEntry = pFrameInfo->pFunctionEntry;

    DASSERT(pFrameInfo != NULL);

    for (; pFrameInfo != NULL; pFrameInfo = pFrameInfo->pNext ) {
        if (pContFunctionEntry == pFrameInfo->pFunctionEntry &&
              (pContinuation > OffsetToAddress(pFrameInfo->pFunctionEntry->BeginAddress,ImageBase)) &&
              (pContinuation <= OffsetToAddress(pFrameInfo->pFunctionEntry->EndAddress,ImageBase))

        ){
            return pFrameInfo;
        }
    }

    return NULL;
}

BOOL __IsFramePdataMatch(
    PVOID pContinuation, 
    RUNTIME_FUNCTION* pFrameRfe)
{ 
    BOOL fRetVal = FALSE;
    unsigned __int64 ImageBase, TargetGp;
    PRUNTIME_FUNCTION pContRfe = RtlLookupFunctionEntry((unsigned __int64) pContinuation, &ImageBase, &TargetGp);
    FuncInfo* pContFuncInfo = (FuncInfo*)(ImageBase + *(PULONG)GetLanguageSpecificData(pContRfe, ImageBase));
    FuncInfo* pFrameFuncInfo = (FuncInfo*)(ImageBase + *(PULONG)GetLanguageSpecificData(pFrameRfe, ImageBase));

    //
    // first see if there is a regular match, i.e. if the RFE registered with the frame 
    // matches the RFE for the continuation address
    //
    fRetVal = (pContRfe == pFrameRfe) &&
              (pContinuation > OffsetToAddress(pFrameRfe->BeginAddress,ImageBase)) &&
              (pContinuation <= OffsetToAddress(pFrameRfe->EndAddress,ImageBase));
    
    if (!fRetVal && (pContFuncInfo->bbtFlags == BBT_UNIQUE_FUNCINFO)) {
        fRetVal = (pContFuncInfo == pFrameFuncInfo);
    }
    
    return fRetVal;
}

//
// Given the address of a continuation point, return the corresponding context.
// Each frame info was saved just before a catch handler was called.
// The most recently encountered frame is at the head of the chain.
// The routine starts out with the frame given as the second argument, and scans the
// linked list for the frame that corresponds to the continuation point.
//
CONTEXT* _FindAndUnlinkFrame(PVOID pContinuation, FRAMEINFO *pFrameInfo)
{

    DASSERT(pFrameInfo != NULL);

    for( ; pFrameInfo != NULL; pFrameInfo = pFrameInfo->pNext ) {
        if(__IsFramePdataMatch(pContinuation, pFrameInfo->pFunctionEntry)) {
            //
            // We found the frame.
            // All frames preceeding and including this one are gone. so unlink them.
            //
            CONTEXT* pExitContext =  pFrameInfo->pExitContext;

            pFrameInfoChain = pFrameInfo->pNext;
            //
            // If there are no more exceptions are pending get rid of unneeded frame info records.
            //
            if( _pCurrentException == NULL ) {
                while( pFrameInfoChain != NULL && pFrameInfoChain->pExceptionObjectDestroyed ) {
                    pFrameInfoChain = pFrameInfoChain->pNext;
                }
            }
            return pExitContext;
        }
    }
    DASSERT(pFrameInfo != NULL);
    return NULL;
}

//
// Save the frame information for this scope. Put it at the head of the linked-list.
//
FRAMEINFO* _CreateFrameInfo(    
                        FRAMEINFO            *pFrameInfo,
                        DispatcherContext    *pDC,
                        CONTEXT              *pExitContext,
                        __ehstate_t          State,
                        PVOID                pExceptionObjectDestroyed,
                        EHExceptionRecord    *pExcept
) {
    pFrameInfo->pFunctionEntry       = pDC->FunctionEntry;
    pFrameInfo->pExitContext         = pExitContext;
    pFrameInfo->pExceptionObjectDestroyed = pExceptionObjectDestroyed;
    pFrameInfo->pExceptionObjectToBeDestroyed = NULL;
    pFrameInfo->pExcept              = pExcept;
    pFrameInfo->State                = State;
    pFrameInfo->dtorThrowFlag        = FALSE;
    pFrameInfo->isRethrow            = FALSE;
    if( pFrameInfoChain != NULL && pFrameInfoChain->dtorThrowFlag ) {
        pFrameInfoChain->dtorThrowFlag = FALSE;
        pFrameInfoChain = pFrameInfoChain->pNext;
    }
    pFrameInfo->pNext                = (pFrameInfo < pFrameInfoChain)? pFrameInfoChain : NULL;
    pFrameInfoChain                  = pFrameInfo;
    return pFrameInfo;
}

//
// THIS ROUTINE IS USED    ONLY TO JUMP TO THE CONTINUATION POINT
//
// Sets SP and jumps to specified code address.
// Does not return.
//
void _JumpToContinuation(
    unsigned __int64    TargetAddress,   // The target address to call
    CONTEXT             *pContext,       // Context of target function
    EHExceptionRecord   *pExcept
) {
    unsigned __int64   ImageBase;
    unsigned __int64   TargetGp;

    
    PRUNTIME_FUNCTION pFunctionEntry = RtlLookupFunctionEntry(TargetAddress, &ImageBase, &TargetGp);

    pContext->StIIP = TargetAddress;
    pContext->IntGp = TargetGp;
    pContext->StIPSR &=  ~IPSR_RI_MASK;
    RtlRestoreContext(pContext,(PEXCEPTION_RECORD)pExcept);
}

//
// Prototype for the internal handler
//
extern "C" EXCEPTION_DISPOSITION __InternalCxxFrameHandler(
    EHExceptionRecord  *pExcept,        // Information for this exception
    EHRegistrationNode *pRN,            // Dynamic information for this frame
    CONTEXT            *pContext,       // Context info
    DispatcherContext  *pDC,            // More dynamic info for this frame
    FuncInfo           *pFuncInfo,      // Static information for this frame
    int                CatchDepth,      // How deeply nested are we?
    EHRegistrationNode *pMarkerRN,      // Marker node for when checking inside catch block
    BOOL                recursive);     // True if this is a translation exception

//
// __CxxFrameHandler - Real entry point to the runtime
//
extern "C" _CRTIMP EXCEPTION_DISPOSITION __CxxFrameHandler(
    EHExceptionRecord  *pExcept,         // Information for this exception
    __int64            MemoryStackFp,    // SP of user program
    __int64            BackingStoreFp,   // BSP of user program
    CONTEXT            *pContext,        // Context info
    DispatcherContext  *pDC,             // More dynamic info for this frame
    __int64            TargetGp          // GP of user program
) {
    FuncInfo                *pFuncInfo;
    EXCEPTION_DISPOSITION   result;
    EHRegistrationNode      EstablisherFrame = { MemoryStackFp, BackingStoreFp };

    _ImageBase = pDC->ImageBase;
    _TargetGp = TargetGp;
    _ThrowImageBase = (unsigned __int64)pExcept->params.pThrowImageBase;
    pFuncInfo = (FuncInfo*)(_ImageBase + *(PULONG)GetLanguageSpecificData(pDC->FunctionEntry, _ImageBase));
    result = __InternalCxxFrameHandler( pExcept, &EstablisherFrame, pContext, pDC, pFuncInfo, 0, NULL, FALSE );
    return result;
}

// Call the SEH to EH translator.

BOOL _CallSETranslator(
    EHExceptionRecord   *pExcept,    // The exception to be translated
    EHRegistrationNode  *pRN,        // Dynamic info of function with catch
    CONTEXT             *pContext,   // Context info
    DispatcherContext   *pDC,        // More dynamic info of function with catch (ignored)
    FuncInfo            *pFuncInfo,  // Static info of function with catch
    ULONG               CatchDepth,  // How deeply nested in catch blocks are we?
    EHRegistrationNode  *pMarkerRN   // Marker for parent context
) {
    pRN;
    pDC;
    pFuncInfo;
    CatchDepth;

    // Call the translator.

    _EXCEPTION_POINTERS excptr = { (PEXCEPTION_RECORD)pExcept, pContext };

    __pSETranslator(PER_CODE(pExcept), &excptr);

    // If we got back, then we were unable to translate it.

    return FALSE;
}

//
// This structure is the FuncInfo (HandlerData) for handler __TranslatorGuardHandler
//
struct TransGuardRec {
    FuncInfo            *pFuncInfo;     // Static info for subject function
    EHRegistrationNode  *pFrame;        // Dynamic info for subject function
    ULONG               CatchDepth;     // How deeply nested are we?
    EHRegistrationNode  *pMarkerFrame;  // Marker for parent context
    PVOID               pContinue;      // Continuation address within CallSEHTranslator
    PVOID               pSP;            // SP within CallSEHTranslator
    BOOL                DidUnwind;      // True if this frame was unwound
    };

#if 0
//
//    This routine is the handler for CallSETranslator which is defined in handlers.s
//
extern "C" _CRTIMP EXCEPTION_DISPOSITION __TranslatorGuardHandler(
    EHExceptionRecord    *pExcept,       // Information for this exception
    EHRegistrationNode   *pFrame,        // The translator guard frame
    CONTEXT              *pContext,      // Context info
    DispatcherContext    *pDC            // Dynamic info for this frame
) {
    //
    // The handler data is a pointer to an integer that is an offset to the TGRN structure
    // relative to the frame pointer.
    //
    TransGuardRec *pTransGuardData = (TransGuardRec*)((char*)pFrame->MemoryStackFp - *(int*)(pDC->FunctionEntry->HandlerData));
    if (IS_UNWINDING(PER_FLAGS(pExcept)))
    {
        pTransGuardData->DidUnwind = TRUE;
        return ExceptionContinueSearch;
    }
    else {
        //
        // Check for a handler:
        //
        __InternalCxxFrameHandler(  pExcept,
                                    pTransGuardData->pFrame,
                                    pContext,
                                    pDC,
                                    pTransGuardData->pFuncInfo,
                                    pTransGuardData->CatchDepth,
                                    pTransGuardData->pMarkerFrame,
                                    TRUE );
        // Unreached.
        return ExceptionContinueSearch;
        }
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
// _GetRangeOfTrysToCheck - determine which try blocks are of interest, given
//   the current catch block nesting depth.  We only check the trys at a single
//   depth.
//
// Returns:
//      Address of first try block of interest is returned
//      pStart and pEnd get the indices of the range in question
//
TryBlockMapEntry* _GetRangeOfTrysToCheck(
        EHRegistrationNode  *pRN,
        FuncInfo            *pFuncInfo,
        int                 CatchDepth,
        __ehstate_t         curState,
        unsigned            *pStart,
        unsigned            *pEnd,
        DispatcherContext   *pDC
) {
    TryBlockMapEntry *pEntry;
    unsigned num_of_try_blocks = FUNC_NTRYBLOCKS(*pFuncInfo);

    DASSERT( num_of_try_blocks > 0 );

    for( unsigned int index = 0; index < num_of_try_blocks; index++ ) {
        pEntry = FUNC_PTRYBLOCK(*pFuncInfo, index, pDC->ImageBase);
       if( curState >= TBME_LOW(*pEntry) && curState <= TBME_HIGH(*pEntry) ) {
            *pStart = index;

            *pEnd = FUNC_NTRYBLOCKS(*pFuncInfo);
            DASSERT( *pEnd <= num_of_try_blocks && *pStart < *pEnd );

#if 1
            int SavedState = GetUnwindTryBlock(pRN, pDC, pFuncInfo);
            if( SavedState != -1 && SavedState >= curState )
                continue;
#else
            int SavedTryNdx = GetUnwindTryBlock(pRN, pDC, pFuncInfo);
            if( SavedTryNdx != -1 ) {
                *pStart = SavedTryNdx + 1;
                if( *pStart < *pEnd && pEntry != NULL ) {
                   pEntry = FUNC_PTRYBLOCK(*pFuncInfo, SavedTryNdx + 1, pDC->ImageBase);
                }
            }
#endif
            return pEntry;
        }
    }

    *pStart = *pEnd = 0;
    return NULL;
}


#pragma optimize("",off)
extern "C" unsigned __int64 __getReg(int);
extern "C" void __setReg(int, unsigned __int64);
#pragma intrinsic(__getReg)
#pragma intrinsic(__setReg)
extern "C" void _UnwindNestedFrames(
    EHRegistrationNode  *pFrame,            // Unwind up to (but not including) this frame
    EHExceptionRecord   *pExcept,           // The exception that initiated this unwind
    CONTEXT             *pContext           // Context info for current exception
) {
    CONTEXT         LocalContext;           // Create context for this routine to return from RtlUnwind
    CONTEXT         ScratchContext;         // Context record to pass to RtlUnwind2 to be used as scratch
    volatile int    Unwound = FALSE;        // Flag that assist to return from RtlUnwind2
    PVOID           pReturnPoint = NULL;    // The address we want to return from RtlUnwind2

    RtlCaptureContext(&LocalContext);
    //
    // set up the return label
    //
    _GetNextInstrOffset(&pReturnPoint);
    if(Unwound)
        goto LAB_UNWOUND;

    LocalContext.StIIP = (ULONGLONG)pReturnPoint;
    LocalContext.IntGp = __getReg(CV_IA64_IntR1);
    LocalContext.StIPSR &= ~IPSR_RI_MASK;
    pUnwindContext = &LocalContext;     // save address of LocalContext in global/TLS pUnwindContext
    Unwound = TRUE;
#ifdef _NT
    RtlUnwind2(*pFrame, (ULONG_PTR)pReturnPoint, (PEXCEPTION_RECORD)pExcept, NULL, &ScratchContext);
#else
    RtlUnwind2(*pFrame, pReturnPoint, (PEXCEPTION_RECORD)pExcept, NULL, &ScratchContext);
#endif

LAB_UNWOUND:
    __setReg(CV_IA64_IntR1,LocalContext.IntGp);
    pContext->StIPSR &= ~IPSR_RI_MASK;
    PER_FLAGS(pExcept) &= ~EXCEPTION_UNWINDING;
    // 
    // reset global/TLS pUnwindContext for future exceptions
    //
    pUnwindContext = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\eh\ia64\handlers.s ===
//++
//
//extern "C"
//VOID
//_GetNextInstrOffset (
//    PVOID* ppReturnPoint
//    );
//
//Routine Description:
//
//    This function scans the scope tables associated with the specified
//    procedure and calls exception and termination handlers as necessary.
//
//Arguments:
//
//    ppReturnPoint (r32) - store b0 in *pReturnPoint
//
//Return Value:
//
//  None
//
//--

        .global _GetNextInstrOffset#

        .proc   _GetNextInstrOffset#
        .align 32
_GetNextInstrOffset:
        alloc   r2=1, 0, 0, 0
        mov     r3 = b0;;
        st8     [r32]=r3
        br.ret.sptk.few b0
        .endp   _GetNextInstrOffset#


//++
//
//extern "C"
//PVOID
//__Cxx_ExecuteHandler (
//    ULONGLONG MemoryStack,
//    ULONGLONG BackingStore,
//    ULONGLONG Handler,
//    ULONGLONG GlobalPointer
//    );
//
//Routine Description:
//
//    This function scans the scope tables associated with the specified
//    procedure and calls exception and termination handlers as necessary.
//
//Arguments:
//
//    MemoryStack (r32) - memory stack pointer of establisher frame
//
//    BackingStore (r33) - backing store pointer of establisher frame
//
//    Handler (r34) - Entry point of handler
//
//    GlobalPointer (r35) - GP of termination handler
//
//Return Value:
//
//  Returns the continuation point
//
//--

        .global __Cxx_ExecuteHandler#

        .proc   __Cxx_ExecuteHandler#
        .align 32
__Cxx_ExecuteHandler:
        mov     gp = r35                     // set new GP
        mov     b6 = r34                     // handler address
        br      b6                           // branch to handler
        .endp   __Cxx_ExecuteHandler#


//++
//
//extern "C" void* _CallSettingFrame(
//    void*               handler,
//    EHRegistrationNode  *pEstablisher,
//    ULONG               NLG_CODE)
//
//--
.global _NLG_Notify
.type   _NLG_Notify, @function
.global _GetTargetGP
.type   _GetTargetGP, @function
.global _GetImageBase
.type   _GetImageBase, @function
.global _SetImageBase
.type   _SetImageBase, @function
.global _CallSettingFrame
.global __NLG_Return

.proc _CallSettingFrame
	.align 32
	.prologue
_CallSettingFrame:
	.save ar.pfs,r35
        alloc loc0 = ar.pfs, 3, 8, 4, 0
	.save rp,loc1
        mov loc1 = b0           // save important stuff
	.save pr,loc2
        mov loc2 = pr
        mov loc3 = gp
	.body
        ld8 loc5 = [in1],0x8    // pEstablisher->MemoryStackBP
        ;;
        ld8 loc6 = [in1]        // pEstablisher->BackingStoreBP
        mov out0 = in0          // pass the target address
        br.call.sptk b0 = _GetTargetGP // Get target's GP
        ;;
        mov loc4 = ret0
        br.call.sptk b0 = _GetImageBase //Get current image base
		;;
		mov loc7 = ret0			// save current image base
        mov out0 = in0          // handler address
        mov out1 = loc5         // pEstablisher->MemoryStackBP
        mov out2 = loc6         // pEstablisher->BackingStoreBP
        mov out3 = in2          // NLG_CODE
        br.call.sptk b0 = _NLG_Notify   // Notify debugger about transferring control to the handler
        ;;
        mov gp = loc4           // set hanlder's GP
        mov out0 = loc5         // pEstablisher->MemoryStackBP
        mov out1 = loc6         // pEstablisher->BackingStoreBP
        mov b6 = in0            // hanlder address
        br.call.sptk b0 = b6    // call the handler (pEstablisher->MemoryStackBP, pEstablisher->BackingStoreBP)
        ;;
__NLG_Return:
        mov gp = loc3           // restore gp
        cmp.eq p14,p5 = ret0, r0 // did the handler return a continuation address?
        ;;
(p14)   mov loc3 = 0            // if it didn'just return 0
(p5)    mov loc3 = ret0         // if it did then it was image base relative for 2.5, so fix it up
        mov out0 = loc7         // Restore image base in TLS, the handler could call an other dll with different image base
        br.call.sptk b0 = _SetImageBase
        ;;
(p5)    add loc3 = loc7, loc3   // ImageBase + handler's return for 2.5
        ;;
        mov loc4 = 0x100        // NLG_CATCH_ENTER
        ;;
        cmp.eq p14,p15 = loc4, in2  // if NLG_CODE == NLG_CATCH_ENTER notify debugger again about continuing mainstream
        ;;
        mov out3 = 0x2          // NLG_CATCH_LEAVE
        mov out1 = loc5         // pEstablisher->MemoryStackBP
        mov out2 = loc6         // pEstablisher->BackingStoreBP
        mov out0 = loc3         // handler continuation address
(p14)   br.call.sptk b0 = _NLG_Notify
        ;;
        mov ret0 = loc3
        mov b0 = loc1           // restore stuff
        mov pr = loc2
        mov ar.pfs = loc0
        br.ret.sptk b0
.endp _CallSettingFrame
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\execl.c ===
/***
*execl.c - execute a file with a list of arguments
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execl() - execute a file with a list of arguments
*
*Revision History:
*       10-14-83  RN    written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and arglist. #include-d PROCESS.H
*                       and added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execl(filename, arglist) - execute a file with arg list
*
*Purpose:
*       Transform the argument list so it is a vector, then pass its address
*       to execve.  Use a pointer to the default environment vector.
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - list of arguments
*       call as _execl(path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       destroys the calling process, hopefully
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecl (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        return(_texecve(filename,&arglist,NULL));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        va_end(vargs);

        result = _texecve(filename,argv,NULL);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\dospawn.c ===
/***
*dospawn.c - spawn a child process
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _dospawn - spawn a child process
*
*Revision History:
*       06-07-89  PHG   Module created, based on asm version
*       03-08-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       04-02-90  GJF   Now _CALLTYPE1. Added const to type of name arg.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       10-30-90  GJF   Added _p_overlay (temporary hack).
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  SRW   Fixed return value for dospawn [_WIN32_]
*       01-17-91  GJF   ANSI naming.
*       01-25-91  SRW   Changed CreateProcess parameters [_WIN32_]
*       01-29-91  SRW   Changed CreateProcess parameters again [_WIN32_]
*       02-05-91  SRW   Changed to pass _osfile and _osfhnd arrays as binary
*                       data to child process.  [_WIN32_]
*       02-18-91  SRW   Fixed code to return correct process handle and close
*                       handle for P_WAIT case. [_WIN32_]
*       04-05-91  SRW   Fixed code to free StartupInfo.lpReserved2 after
*                       CreateProcess call. [_WIN32_]
*       04-26-91  SRW   Removed level 3 warnings (_WIN32_)
*       12-02-91  SRW   Fixed command line setup code to not append an extra
*                       space [_WIN32_]
*       12-16-91  GJF   Return full 32-bit exit code from the child process
*                       [_WIN32_].
*       02-14-92  GJF   Replaced _nfile with _nhandle for Win32.
*       02-18-92  GJF   Merged in 12-16-91 change from \\vangogh version
*       11-20-92  SKS   errno/_doserrno must be 0 in case of success.  This
*                       will distinguish a child process return code of -1L
*                       (errno == 0) from an actual error (where errno != 0).
*       01-08-93  CFW   Added code to handle _P_DETACH case; add fdwCreate
*                       variable, nuke stdin, stdout, stderr entries of _osfile
*                       & _osfhnd tables, close process handle to completely
*                       detach process
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Rip out Cruiser.
*       12-07-93  CFW   Wide char enable, remove _p_overlay.
*       01-05-94  CFW   Unremove _p_overlay.
*       01-10-95  CFW   Debug CRT allocs.
*       06-12-95  GJF   Revised passing of C file handles to work from the
*                       ioinfo arrays.
*       07-10-95  GJF   Use UNALIGNED to avoid choking RISC platforms.
*       05-17-96  GJF   Don't pass info on handles marked FNOINHERIT (new 
*                       flag) to the child process.
*       02-05-98  GJF   Changes for Win64: return type changed to intptr_t.
*       01-09-00  PML   Sign-extend exit code for _P_WAIT on Win64.
*       07-07-01  BWT   Return -1 if unable to alloc file ptr table (lpReserved2).
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <msdos.h>
#include <process.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <tchar.h>
#include <dbgint.h>

#ifndef WPRFLAG
int _p_overlay = 2;
#endif

/***
*int _dospawn(mode, name, cmdblk, envblk) - spawn a child process
*
*Purpose:
*       Spawns a child process
*
*Entry:
*       int mode     - _P_WAIT, _P_NOWAIT, _P_NOWAITO, _P_OVERLAY, or _P_DETACH
*       _TSCHAR *name   - name of program to execute
*       _TSCHAR *cmdblk - parameter block
*       _TSCHAR *envblk - environment block
*
*Exit:
*       _P_OVERLAY: -1 = error, otherwise doesn't return
*       _P_WAIT:    termination code << 8 + result code
*       _P_DETACH: -1 = error, 0 = success
*       others:    PID of process
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
intptr_t __cdecl _wdospawn (
#else
intptr_t __cdecl _dospawn (
#endif
        int mode,
        const _TSCHAR *name,
        _TSCHAR *cmdblk,
        _TSCHAR *envblk
        )
{
        char syncexec, asyncresult, background;
        LPTSTR CommandLine;
        STARTUPINFO StartupInfo;
        PROCESS_INFORMATION ProcessInformation;
        BOOL CreateProcessStatus;
        ULONG dosretval;                /* OS return value */
        DWORD exitcode;
        intptr_t retval;
        DWORD fdwCreate = 0;            /* flags for CreateProcess */
        int i;
        ioinfo *pio;
        char *posfile;
        UNALIGNED intptr_t *posfhnd;
        int nh;                         /* number of file handles to be
                                           passed to the child */

        /* translate input mode value to individual flags */
        syncexec = asyncresult = background = 0;
        switch (mode) {
        case _P_WAIT:    syncexec=1;    break;  /* synchronous execution */
        case 2: /* _P_OVERLAY */
        case _P_NOWAITO: break;                 /* asynchronous execution */
        case _P_NOWAIT:  asyncresult=1; break;  /* asynch + remember result */
        case _P_DETACH:  background=1;  break;  /* detached in null scrn grp */
        default:
            /* invalid mode */
            errno = EINVAL;
            _doserrno = 0;              /* not a Dos error */
            return -1;
        }

        /*
         * Loop over null separate arguments, and replace null separators
         * with spaces to turn it back into a single null terminated
         * command line.
         */
        CommandLine = cmdblk;
        while (*cmdblk) {
            while (*cmdblk) {
                cmdblk++;
            }

            /*
             * If not last argument, turn null separator into a space.
             */
            if (cmdblk[1] != _T('\0')) {
                *cmdblk++ = _T(' ');
            }
        }

        memset(&StartupInfo,0,sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);

        for ( nh = _nhandle ;
              nh && !_osfile(nh - 1) ;
              nh-- ) ;

        StartupInfo.cbReserved2 = (WORD)(sizeof( int ) + (nh *
                                  (sizeof( char ) + 
                                  sizeof( intptr_t ))));

        StartupInfo.lpReserved2 = _calloc_crt( StartupInfo.cbReserved2, 1 );

        if (!StartupInfo.lpReserved2) {
            errno = ENOMEM;
            return -1;
        }

        *((UNALIGNED int *)(StartupInfo.lpReserved2)) = nh;

        for ( i = 0,
              posfile = (char *)(StartupInfo.lpReserved2 + sizeof( int )),
              posfhnd = (UNALIGNED intptr_t *)(StartupInfo.lpReserved2 + 
                        sizeof( int ) + (nh * sizeof( char ))) ;
              i < nh ;
              i++, posfile++, posfhnd++ )
        {
            pio = _pioinfo(i);
            if ( (pio->osfile & FNOINHERIT) == 0 ) {
                *posfile = pio->osfile;
                *posfhnd = pio->osfhnd;
            }
            else {
                *posfile = 0;
                *posfhnd = (intptr_t)INVALID_HANDLE_VALUE;
            }
        }

        /*
         * if the child process is detached, it cannot access the console, so
         * we must nuke the information passed for the first three handles.
         */
        if ( background ) {

            for ( i = 0,
                  posfile = (char *)(StartupInfo.lpReserved2 + sizeof( int )),
                  posfhnd = (UNALIGNED intptr_t *)(StartupInfo.lpReserved2 + sizeof( int )
                            + (nh * sizeof( char ))) ;
                  i < __min( nh, 3 ) ;
                  i++, posfile++, posfhnd++ )
            {
                *posfile = 0;
                *posfhnd = (intptr_t)INVALID_HANDLE_VALUE;
            }

            fdwCreate |= DETACHED_PROCESS;
        }

        /**
         * Set errno to 0 to distinguish a child process
         * which returns -1L from an error in the spawning
         * (which will set errno to something non-zero
        **/

        _doserrno = errno = 0 ;

#ifdef WPRFLAG
        /* indicate to CreateProcess that environment block is wide */
        fdwCreate |= CREATE_UNICODE_ENVIRONMENT;
#endif

        CreateProcessStatus = CreateProcess( (LPTSTR)name,
                                             CommandLine,
                                             NULL,
                                             NULL,
                                             TRUE,
                                             fdwCreate,
                                             envblk,
                                             NULL,
                                             &StartupInfo,
                                             &ProcessInformation
                                           );

        dosretval = GetLastError();
        _free_crt( StartupInfo.lpReserved2 );

        if (!CreateProcessStatus) {
            _dosmaperr(dosretval);
            return -1;
        }

        if (mode == 2 /* _P_OVERLAY */) {
            /* destroy ourselves */
            _exit(0);
        }
        else if (mode == _P_WAIT) {
            WaitForSingleObject(ProcessInformation.hProcess, (DWORD)(-1L));

            /* return termination code and exit code -- note we return
               the full exit code */
            GetExitCodeProcess(ProcessInformation.hProcess, &exitcode);

            retval = (intptr_t)(int)exitcode;

            CloseHandle(ProcessInformation.hProcess);
        }
        else if (mode == _P_DETACH) {
            /* like totally detached asynchronous spawn, dude,
               close process handle, return 0 for success */
            CloseHandle(ProcessInformation.hProcess);
            retval = (intptr_t)0;
        }
        else {
            /* asynchronous spawn -- return PID */
            retval = (intptr_t)ProcessInformation.hProcess;
        }

        CloseHandle(ProcessInformation.hThread);
        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\execve.c ===
/***
*execve.c - execute a file with a given environment
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _execve() - execute a file
*
*Revision History:
*	??-??-??  ???	Module created.
*	12-07-93  CFW	Module commented.
*
*******************************************************************************/

#define EXECVE

#include "spawnve.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\execlp.c ===
/***
*execlp.c - execute a file (search along PATH)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execlp() - execute a file and search along PATH
*
*Revision History:
*       10-17-83  RN    written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and arglist. #include-d PROCESS.H
*                       and added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execlp(filename, arglist) - execute a file, search along PATH
*
*Purpose:
*       Execute the given file with the given arguments; search along PATH
*       for the file. We pass the arguments to execvp where several paths
*       will be tried until one works.
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - argument list
*       call as _execlp(path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       destroys calling process (hopefully)
*       returns -1 if fails.
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texeclp (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        return(_texecvp(filename,&arglist));

#else   /* ndef_M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        va_end(vargs);

        result = _texecvp(filename,argbuf);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\execlpe.c ===
/***
*execlpe.c - execute a file with environ, search along path
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execlpe() - execute a file with environ and search along PATH
*
*Revision History:
*       10-17-83  RN    written
*       ??-??-??  TC    added execlpe
*       06-18-86  JMB   added environment pointer which was erroneously missing
*       06-11-87  PHG   removed unnecessary environment pointer (isn't this
*                       fun!)
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and arglist. #include-d PROCESS.H
*                       and added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execlpe(filename, arglist) - execute a file with environ
*
*Purpose:
*       Executes the given file with the parameters and the environment
*       which is passed after the parameters.  Searches along the PATH
*       for the file (done by execvp).
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - argument list (environment is at the end)
*       call as _execlpe(path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       destroys the calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texeclpe (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        REG1 const _TSCHAR **argp;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        argp = &arglist;
        while (*argp++)
                ;

        return(_texecvpe(filename,&arglist,(_TSCHAR **)*argp));

#else   /* ndef_M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _texecvpe(filename,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\execvp.c ===
/***
*execvp.c - execute a file and search along PATH
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execvp() - execute a file and search along PATH
*
*Revision History:
*       10-17-83  RN    written
*       10-29-85  TC    added execvpe capability
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and argvector.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>
*       05-21-90  GJF   Fixed stack checking pragma syntax.
*       08-24-90  SBM   Removed check_stack pragma since workhorse execve
*                       does stack checks
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>

/***
*int _execvp(filename, argvector) - execute file; search along PATH
*
*Purpose:
*       Execute the given file with given path and current environ.
*       try to execute the file. start with the name itself (directory '.'),
*       and if that doesn't work start prepending pathnames from the
*       environment until one works or we run out. if the file is a pathname,
*       don't go to the environment to get alternate paths. if errno comes
*       back ENOEXEC, try it as a shell command file with up to MAXARGS-2
*       arguments from the original vector. if a needed text file is busy,
*       wait a little while and try again before despairing completely
*       Actually calls _execvpe() to do all the work.
*
*Entry:
*       _TSCHAR *filename        - file to execute
*       _TSCHAR **argvector - vector of arguments
*
*Exit:
*       destroys the calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecvp (
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argvector
        )
{
        return _texecvpe( filename, argvector, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\execle.c ===
/***
*execle.c - execute a file with arg list and environment
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execle() - execute a file
*
*Revision History:
*       10-14-83  RN    written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and arglist. #include-d PROCESS.H
*                       and added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execle(filename, arglist) - execute a file
*
*Purpose:
*       Execute the given file (overlays the calling process).
*       We must dig the environment vector out of the stack and pass it
*       and address of argument vector to execve.
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - argument list followed by environment
*       should be called like _execle(path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       destroys calling process (hopefully)
*       if fails, returns -1.
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecle (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        REG1 const _TSCHAR **e_search = &arglist;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        while (*e_search++)
                ;

        return(_texecve(filename,&arglist,(_TSCHAR **)*e_search));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _texecve(filename,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\execv.c ===
/***
*execv.c - execute a file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execv() - execute a file
*
*Revision History:
*       10-14-83  RN    written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and argvector.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execv(filename, argvector) - execute a file
*
*Purpose:
*       Executes a file with given arguments.  Passes arguments to _execve and
*       uses pointer to the default environment.
*
*Entry:
*       _TSCHAR *filename        - file to execute
*       _TSCHAR **argvector - vector of arguments.
*
*Exit:
*       destroys calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecv (
        const _TSCHAR *filename,
        const _TSCHAR * const *argvector
        )
{
        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(argvector != NULL);
        _ASSERTE(*argvector != NULL);
        _ASSERTE(**argvector != _T('\0'));

        return(_texecve(filename,argvector,NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\execvpe.c ===
/***
*execvpe.c - execute a file with given environ; search along PATH
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execvpe() - execute a file with given environ
*
*Revision History:
*       10-17-83  RN    written
*       10-29-85  TC    added execvpe capability
*       11-19-86  SKS   handle both kinds of slashes
*       12-01-86  JMB   added Kanji file name support under conditional KANJI
*                       switches, corrected header info
*                       removed bogus check for env = b after call to strncpy().
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       09-05-88  SKS   Treat EACCES the same as ENOENT -- keep trying
*       10-18-88  GJF   Removed copy of PATH string to local array, changed
*                       bbuf to be a malloc-ed buffer. Removed bogus limits
*                       on the size of that PATH string.
*       10-26-88  GJF   Don't search PATH when relative pathname is given (per
*                       Stevesa). Also, if the name built from PATH component
*                       and filename is a UNC name, allow any error.
*       11-20-89  GJF   Fixed copyright. Added const attribute to types of
*                       filename, argvector and envptr. Also, added "#include
*                       <jstring.h>" under KANJI switch (same as 5-17-89 change
*                       to CRT version).
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       cleaned up the formatting a bit.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       11-30-92  KRS   Port _MBCS code from 16-bit tree.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <process.h>
#include <mbstring.h>
#include <tchar.h>
#include <dbgint.h>

#define SLASHCHAR _T('\\')
#define XSLASHCHAR _T('/')

#define SLASH _T("\\")
#define DELIMITER _T(";")

#ifdef _MBCS
/* note, the macro below assumes p is to pointer to a single-byte character
 * or the 1st byte of a double-byte character, in a string.
 */
#define ISPSLASH(p)     ( ((p) == _mbschr((p), SLASHCHAR)) || ((p) == \
_mbschr((p), XSLASHCHAR)) )
#else
#define ISSLASH(c)      ( ((c) == SLASHCHAR) || ((c) == XSLASHCHAR) )
#endif


/***
*int _execvpe(filename, argvector, envvector) - execute a file
*
*Purpose:
*       Executes a file with given arguments and environment.
*       try to execute the file. start with the name itself (directory '.'),
*       and if that doesn't work start prepending pathnames from the
*       environment until one works or we run out. if the file is a pathname,
*       don't go to the environment to get alternate paths. If a needed text
*       file is busy, wait a little while and try again before despairing
*       completely
*
*Entry:
*       _TSCHAR *filename        - file to execute
*       _TSCHAR **argvector - vector of arguments
*       _TSCHAR **envvector - vector of environment variables
*
*Exit:
*       destroys the calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecvpe (
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argvector,
        const _TSCHAR * const *envptr
        )
{
        REG1 _TSCHAR *env;
        _TSCHAR *bbuf = NULL;
        REG2 _TSCHAR *buf;
        _TSCHAR *pfin;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(argvector != NULL);
        _ASSERTE(*argvector != NULL);
        _ASSERTE(**argvector != _T('\0'));

        _texecve(filename,argvector,envptr);

        if ( (errno != ENOENT)
        || (_tcschr(filename, SLASHCHAR) != NULL)
        || (_tcschr(filename, XSLASHCHAR) != NULL)
        || *filename && *(filename+1) == _T(':')
        || !(env=_tgetenv(_T("PATH"))) )
                goto reterror;

        /* allocate a buffer to hold alternate pathnames for the executable
         */
        if ( (buf = bbuf = _malloc_crt(_MAX_PATH * sizeof(_TSCHAR))) == NULL )
            goto reterror;

        do {
                /* copy a component into bbuf[], taking care not to overflow it
                 */
                /* UNDONE: make sure ';' isn't 2nd byte of DBCS char */
                while ( (*env) && (*env != _T(';')) && (buf < bbuf+(_MAX_PATH-2)*sizeof(_TSCHAR)) )
                        *buf++ = *env++;

                *buf = _T('\0');
                pfin = --buf;
                buf = bbuf;

#ifdef _MBCS
                if (*pfin == SLASHCHAR) {
                        if (pfin != _mbsrchr(buf,SLASHCHAR))
                                /* *pfin is the second byte of a double-byte
                                 * character
                                 */
                                strcat( buf, SLASH );
                }
                else if (*pfin != XSLASHCHAR)
                        strcat(buf, SLASH);
#else
                if (*pfin != SLASHCHAR && *pfin != XSLASHCHAR)
                        _tcscat(buf, SLASH);
#endif

                /* check that the final path will be of legal size. if so,
                 * build it. otherwise, return to the caller (return value
                 * and errno rename set from initial call to _execve()).
                 */
                if ( (_tcslen(buf) + _tcslen(filename)) < _MAX_PATH )
                        _tcscat(buf, filename);
                else
                        break;

                _texecve(buf, argvector, envptr);

                if ( (errno != ENOENT)
#ifdef _MBCS
                && (!ISPSLASH(buf) || !ISPSLASH(buf+1)) )
#else
                && (!ISSLASH(*buf) || !ISSLASH(*(buf+1))) )
#endif
                        break;
        } while ( *env && env++ );

reterror:
        if (bbuf != NULL)
                _free_crt(bbuf);

        return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\fileinfo.c ===
/***
*fileinfo.c - sets C file info flag
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Sets the C file info flag.  By default, the openfile information
*	is NOT passed along to children on spawn/exec calls.  If the flag
*	is set, openfile information WILL get passed on to children on
*	spawn/exec calls.
*
*Revision History:
*	06-07-89   PHG	Module created, based on asm version
*	04-03-90   GJF	Added #include <cruntime.h>. Also, fixed the copyright.
*	01-23-92   GJF	Added #include <stdlib.h> (contains decl of _fileinfo).
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

int _fileinfo = -1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\getproc.c ===
/***
*getproc.c - Get the address of a procedure in a DLL.
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _getdllprocadd() - gets a procedure address by name or
*       ordinal
*
*Revision History:
*       08-21-91  BWM   Wrote module.
*       09-30-93  GJF   Resurrected for compatiblity with NT SDK.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*       02-10-98  GJF   Changes for Win64: changed 3rd arg type intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <process.h>

/***
*int (*)() _getdllprocaddr(handle, name, ordinal) - Get the address of a
*       DLL procedure specified by name or ordinal
*
*Purpose:
*
*Entry:
*       int handle - a DLL handle from _loaddll
*       char * name - Name of the procedure, or NULL to get by ordinal
*       int ordinal - Ordinal of the procedure, or -1 to get by name
*
*
*Exit:
*       returns a pointer to the procedure if found
*       returns NULL if not found
*
*Exceptions:
*
*******************************************************************************/

int (__cdecl * __cdecl _getdllprocaddr(
        intptr_t hMod,
        char * szProcName,
        intptr_t iOrdinal))()
{
        typedef int (__cdecl * PFN)();

        if (szProcName == NULL) {
            if (iOrdinal <= 65535) {
                return ((PFN)GetProcAddress((HANDLE)hMod, (LPSTR)iOrdinal));
            }
        }
        else {
            if (iOrdinal == (intptr_t)(-1)) {
                return ((PFN)GetProcAddress((HANDLE)hMod, szProcName));
            }
        }

        return (NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\loaddll.c ===
/***
*loaddll.c - load or free a Dynamic Link Library
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _loaddll() and _unloaddll() - load and unload DLL
*
*Revision History:
*       08-21-91  BWM   Wrote module.
*       09-30-93  GJF   Resurrected for compatibility with NT SDK.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <stdlib.h>
#include <process.h>

/***
*int _loaddll(filename) - Load a dll
*
*Purpose:
*       Load a DLL into memory
*
*Entry:
*       char *filename - file to load
*
*Exit:
*       returns a unique DLL (module) handle if succeeds
*       returns 0 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _loaddll(char * szName)
{
        return ((intptr_t)LoadLibrary(szName));
}

/***
*int _unloaddll(handle) - Unload a dll
*
*Purpose:
*       Unloads a DLL. The resources of the DLL will be freed if no other
*       processes are using it.
*
*Entry:
*       int handle - handle from _loaddll
*
*Exit:
*       returns 0 if succeeds
*       returns DOS error if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _unloaddll(intptr_t hMod)
{
        if (!FreeLibrary((HANDLE)hMod)) {
            return ((int)GetLastError());
        }
        return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\spawnl.c ===
/***
*spawnl.c - spawn a child process
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnl() - spawn a child process
*
*Revision History:
*       04-15-84  DFW   Re-do to correspond to similar exec call format
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for pathname and arglist. #include-d PROCESS.H and
*                       added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2 and added #include
*                       <cruntime.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _spawnl(modeflag, pathname, arglist) - spawn a child process
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls spawnve to do the actual work. The
*       new process will inherit the parent's environment. NOTE - at least
*       one argument must be present.  This argument is always, by convention,
*       the name of the file being spawned.
*
*Entry:
*       int modeflag   - defines which mode of spawn (WAIT, NOWAIT, or OVERLAY)
*                        only WAIT and OVERLAY are currently implemented
*       _TSCHAR *pathname - file to be spawned
*       _TSCHAR *arglist  - list of argument
*       call as _spawnl(modeflag, path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       returns exit code of child process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnl (
        int modeflag,
        const _TSCHAR *pathname,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        _ASSERTE(pathname != NULL);
        _ASSERTE(*pathname != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        return(_tspawnve(modeflag,pathname,&arglist,NULL));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        _ASSERTE(pathname != NULL);
        _ASSERTE(*pathname != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        va_end(vargs);

        result = _tspawnve(modeflag,pathname,argv,NULL);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\spawnlp.c ===
/***
*spawnlp.c - spawn a file; search along PATH
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnlp() - spawn a file with search along PATH
*
*Revision History:
*       04-15-84  DFW   written
*       10-29-85  TC    added spawnlpe
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for filename and arglist. #include-d PROCESS.H and
*                       added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2 and added #include
*                       <cruntime.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*_spawnlp(modeflag, filename, arglist) - spawn file and search along PATH
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls _spawnvp to do the work of searching
*       the PATH environment variable and calling _spawnve.  The NULL
*       environment pointer indicates that the new process will inherit the
*       parents process's environment.  NOTE - at least one argument must be
*       present.  This argument is always, by convention, the name of the file
*       being spawned.
*
*Entry:
*       int modeflag   - mode of spawn (WAIT, NOWAIT, OVERLAY)
*                        only WAIT, OVERLAY currently implemented
*       _TSCHAR *pathname - file to spawn
*       _TSCHAR *arglist  - argument list
*       call as _spawnlp(modeflag, path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       returns exit code of child process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnlp (
        int modeflag,
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        return(_tspawnvp(modeflag,filename,&arglist));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        va_end(vargs);

        result = _tspawnvp(modeflag,filename,argv);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\spawnlpe.c ===
/***
*spawnlpe.c - spawn a child process with environ and search along PATH
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnlpe() - spawn a child process with environ/PATH search
*
*Revision History:
*       04-15-84  DFW   written
*       10-29-85  TC    added spawnlpe
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for filename and arglist. #include-d PROCESS.H and
*                       added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _spawnlpe(modeflag, filename, arglist) - spawn a child process
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls _spawnvpe to do the work of searching
*       the PATH environment variable and calling _spawnve.  The NULL
*       environment pointer indicates that the new process will inherit the
*       parents process's environment.  NOTE - at least one argument must be
*       present.  This argument is always, by convention, the name of the file
*       being spawned.
*
*Entry:
*       int modeflag   - defines what mode of spawn (WAIT, NOWAIT, OVERLAY)
*                        only WAIT and OVERLAY currently supported
*       _TSCHAR *pathname - file to spawn
*       _TSCHAR *arglist  - list of arguments (environ at end)
*       call as _spawnlpe(modeflag, path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       returns exit code of spawned process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnlpe (
        int modeflag,
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        REG1 const _TSCHAR **argp;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        argp = &arglist;
        while (*argp++)
                ;

        return(_tspawnvpe(modeflag,filename,&arglist,(_TSCHAR **)*argp));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _tspawnvpe(modeflag,filename,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\spawnle.c ===
/***
*spawnle.c - spawn a child process with given environment
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnle() - spawn a child process with given environ
*
*Revision History:
*       04-15-84  DFW   written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for pathname and arglist. #include-d PROCESS.H and
*                       added ellipsis to match prototype
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _spawnle(modeflag, pathname, arglist) - spawn a child process with env.
*
*Purpose:
*       Spawns a child process with given parameters and environment.
*       formats the parameters and calls _spawnve to do the actual work.
*       NOTE - at least one argument must be present.  This argument is always,
*       by convention, the name of the file being spawned.
*
*Entry:
*       int modeflag   - mode of spawn (WAIT, NOWAIT, OVERLAY)
*                        only WAIT, and OVERLAY currently implemented
*       _TSCHAR *pathname - name of file to spawn
*       _TSCHAR *arglist  - argument list, environment is at the end
*       call as _spawnle(modeflag, path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       returns exit code of spawned process
*       if fails, return -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnle (
        int modeflag,
        const _TSCHAR *pathname,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        REG1 const _TSCHAR **argp;

        _ASSERTE(pathname != NULL);
        _ASSERTE(*pathname != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        /* walk the arglist until the terminating NULL pointer is found.  The
         * next location holds the environment table pointer.
         */

        argp = &arglist;
        while (*argp++)
                ;

        return(_tspawnve(modeflag,pathname,&arglist,(_TSCHAR **)*argp));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        _ASSERTE(pathname != NULL);
        _ASSERTE(*pathname != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _tspawnve(modeflag,pathname,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\spawnv.c ===
/***
*spawnv.c - spawn a child process
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnv() - spawn a child process
*
*Revision History:
*       04-15-84  DFW   written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for pathname and argv.
*       03-08-90  GJF   Replace _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _spawnv(modeflag, pathname, argv) - spawn a child process
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls _spawnve to do the actual work.  The
*       NULL environment pointer indicates that the new process will inherit
*       the parents process's environment.  NOTE - at least one argument must
*       be present.  This argument is always, by convention, the name of the
*       file being spawned.
*
*Entry:
*       int modeflag   - mode to spawn (WAIT, NOWAIT, or OVERLAY)
*                        only WAIT and OVERLAY currently implemented
*       _TSCHAR *pathname - file to spawn
*       _TSCHAR **argv    - vector of arguments
*
*Exit:
*       returns exit code of child process
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnv (
        int modeflag,
        const _TSCHAR *pathname,
        const _TSCHAR * const *argv
        )
{
        _ASSERTE(pathname != NULL);
        _ASSERTE(*pathname != _T('\0'));
        _ASSERTE(argv != NULL);
        _ASSERTE(*argv != NULL);
        _ASSERTE(**argv != _T('\0'));

        return(_tspawnve(modeflag,pathname,argv,NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\spawnve.c ===
/***
*spawnve.c - Low level routine eventually called by all _spawnXX routines
*       also contains all code for _execve, called by _execXX routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*       This is the low level routine which is eventually invoked by all the
*       _spawnXX routines.
*
*       This is also the low-level routine which is eventually invoked by
*       all of the _execXX routines.
*
*Revision History:
*       03-??-84  RLB   created
*       05-??-84  DCW   modified to fix bug in initialization of envblock
*                       pointer (used int 0 which would fail in long model) and
*                       changed (char *)0 to NULL.
*       03-31-86  SKS   modified for OS/2; no OVERLAY mode,
*                       new format for DOS Exec function
*                       also check for Xenix or DOS style slash characters
*       10-13-86  SKS   pass program name to _cenvarg()
*       11-19-86  SKS   handle both kinds of slashes, with support for Kanji
*       01-29-87  BCM   don't try ".com" extension in protected mode (OS/2)
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05/31/88  SJM   Re-written to allow spawn of .CMD files, increase
*                       speed. Added comexecmd routine.
*       06/01/88  SJM   added #ifdef statements for execve.obj compilation
*       10-30-88  GJF   Call _dospawn() for EXECVE, not _doexec().
*       07-21-89  GJF   Progagated fixes of 11-23-88 and 05-27-89 from CRT tree.
*       11-16-89  GJF   Added code to execve/spawnve to ensure a relative or
*                       or absolute pathname is always used for the executable,
*                       not just a filename (otherwise DOSEXECPGM will search
*                       the PATH!). Also, cleaned up some of the erratic
*                       formatting. Same as 9-15-89 change to CRT version
*       11-20-89  GJF   Added const attribute to types of appropriate args.
*       02-08-90  GJF   Fixed bug in comexecmd (must free(comname) if and only
*                       if comname points to a malloc-ed block). Propagated
*                       from 02-07-90 change in crt6 version.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       04-02-90  GJF   Made comexecmd() _CALLTYPE4. Added #include <io.h>
*                       and a prototype for comexecmd() to fix compiler
*                       warnings (-W3).
*       05-21-90  GJF   Fixed stack checking pragma syntax.
*       07-24-90  SBM   Removed redundant include, minor optimization
*       09-27-90  GJF   New-style function declarators.
*       12-28-90  SRW   Added _CRUISER_ conditional around check_stack pragma
*       01-17-91  GJF   ANSI naming.
*       08-21-91  JCR   Call access() in before comexecmd (bug fix)
*       01-24-92  JCR   upgraded for Win32
*       10-24-92  SKS   Remove special treatment for batch files -
*                       Windows NT will spawn %COMSPEC% automatically
*       11-30-92  KRS   Ported _MBCS support from 16-bit tree.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Rip out Cruiser.
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <io.h>
#include <process.h>
#include <errno.h>
#include <msdos.h>
#include <string.h>
#include <stdlib.h>
#include <internal.h>
#include <mbstring.h>
#include <tchar.h>
#include <dbgint.h>

#define SLASHCHAR   _T('\\')
#define XSLASHCHAR  _T('/')

#ifndef EXECVE
#ifdef WPRFLAG
static intptr_t __cdecl wcomexecmd(int mode, const wchar_t * name,
        const wchar_t * const * argv, const wchar_t * const * envp);
#else 
static intptr_t __cdecl comexecmd(int mode, const char * name,
        const char * const * argv, const char * const * envp);
#endif
#else /* EXECVE */
#ifdef WPRFLAG
static intptr_t __cdecl wcomexecmd(const wchar_t * name,
        const wchar_t * const * argv, const wchar_t * const * envp);
#else
static intptr_t __cdecl comexecmd(const char * name,
        const char * const * argv, const char * const * envp);
#endif
#endif /* EXECVE */

/***
*static int comexecmd(mode, name, argv, envp) - do the exec
*       or spawn after name fixup
*
*Purpose:
*       Spawns a child process with given parameters and environment.  Either
*       overlays current process or loads in free memory while parent process
*       waits.  If the named file is a .cmd file, modifies the calling sequence
*       and prepends the /c and filename arguments into the command string
*
*       Exec doesn't take a mode; instead, the parent process goes away as
*       the child process is brought in.
*
*Entry:
*       int mode - mode to spawn (WAIT, NOWAIT, or OVERLAY)
*                   only WAIT and OVERLAY currently supported
*
*           ****  mode is only used in the spawnve() version  ****
*
*       _TSCHAR *name - pathname of file to spawn.  Includes the extension
*       _TSCHAR **argv - vector of parameter strings
*       _TSCHAR **envp - vector of environment variables
*
*Exit:
*       returns exit code of child process
*       if fails, returns -1
*
*Exceptions:
*       Returns a value of (-1) to indicate an error in exec'ing the child
*       process.  errno may be set to:
*
*       E2BIG   = failed in argument/environment processing (_cenvarg)
*                 argument list or environment too big;
*       EACCESS = locking or sharing violation on file;
*       EMFILE  = too many files open;
*       ENOENT  = failed to find program name - no such file or directory;
*       ENOEXEC = failed in exec - bad executable format;
*       ENOMEM  = failed in memory allocation (during malloc, or in
*                 setting up memory for executing child process).
*
*******************************************************************************/

#ifdef WPRFLAG
static intptr_t __cdecl wcomexecmd (
#else
static intptr_t __cdecl comexecmd (
#endif

#ifndef EXECVE
        REG3 int mode,
#endif /* EXECVE */

        REG2 const _TSCHAR *name,
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envp
        )
{
        _TSCHAR *argblk;
        _TSCHAR *envblk;
        REG4 intptr_t rc;

#ifdef WPRFLAG
        if (_wcenvarg(argv, envp, &argblk, &envblk, name) == -1)
#else
        if (_cenvarg(argv, envp, &argblk, &envblk, name) == -1)
#endif
                return -1;

#ifndef EXECVE
#ifdef WPRFLAG
        rc = _wdospawn(mode, name, argblk, envblk);
#else
        rc = _dospawn(mode, name, argblk, envblk);
#endif
#else /* EXECVE */
#ifdef WPRFLAG
        rc = _wdospawn(_P_OVERLAY, name, argblk, envblk);
#else
        rc = _dospawn(_P_OVERLAY, name, argblk, envblk);
#endif
#endif /* EXECVE */
        /* free memory */

        _free_crt(argblk);
        _free_crt(envblk);

        return rc;
}

/***
*int _spawnve(mode, name, argv, envp) - low level _spawnXX library function
*int _execve(name, argv, envp) - low level _execXX library function
*
*Purpose:
*       spawns or execs a child process; takes a single pointer to an argument
*       list as well as a pointer to the environment; unlike _spawnvpe,
*       _spawnve does not search the PATH= list in processing the name
*       parameter; mode specifies the parent's execution mode.
*
*Entry:
*       int mode    - parent process's execution mode:
*                     must be one of _P_OVERLAY, _P_WAIT, _P_NOWAIT;
*                     not used for _execve
*       _TSCHAR *name  - path name of program to spawn;
*       _TSCHAR **argv - pointer to array of pointers to child's arguments;
*       _TSCHAR **envp - pointer to array of pointers to child's environment
*                     settings.
*
*Exit:
*       Returns : (int) a status value whose meaning is as follows:
*               0        = normal termination of child process;
*               positive = exit code of child upon error termination
*                          (abort or exit(nonzero));
*               -1       = child process was not spawned;
*                          errno indicates what kind of error:
*                          (E2BIG, EINVAL, ENOENT, ENOEXEC, ENOMEM).
*
*Exceptions:
*       Returns a value of (-1) to indicate an error in spawning the child
*       process.  errno may be set to:
*
*       E2BIG   = failed in argument/environment processing (_cenvarg) -
*                 argument list or environment too big;
*       EINVAL  = invalid mode argument;
*       ENOENT  = failed to find program name - no such file or directory;
*       ENOEXEC = failed in spawn - bad executable format;
*       ENOMEM  = failed in memory allocation (during malloc, or in
*                 setting up memory for spawning child process).
*
*******************************************************************************/

/* Extension array - ordered in search order from right to left.

   ext_strings  = array of extensions
*/

static _TSCHAR *ext_strings[] = { _T(".cmd"), _T(".bat"), _T(".exe"), _T(".com") };
enum {CMD, BAT, EXE, COM, EXTFIRST=CMD, EXTLAST=COM};

intptr_t __cdecl

#ifndef EXECVE

_tspawnve (
        REG3 int mode,

#else /* EXECVE */

_texecve (

#endif /* EXECVE */

        const _TSCHAR *name,
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envp
        )
{
        _TSCHAR *ext;   /* where the extension goes if we have to add one */
        REG1 _TSCHAR *p;
        _TSCHAR *q;
        REG2 _TSCHAR *pathname = (_TSCHAR *)name;
        REG4 intptr_t rc;
        REG5 int i;

        p = _tcsrchr(pathname, SLASHCHAR);
        q = _tcsrchr(pathname, XSLASHCHAR);

        /* ensure that pathname is an absolute or relative pathname. also,
         * position p to point at the filename portion of pathname (i.e., just
         * after the last occurence of a colon, slash or backslash character */

        if (!q) {
                if (!p)
                        if (!(p = _tcschr(pathname, _T(':')))) {

                                /* pathname is a filename only, force it to be
                                 * a relative pathname. note that an extra byte
                                 * is malloc-ed just in case pathname is NULL,
                                 * to keep the heap from being trashed by
                                 * strcpy */
                                if (!(pathname = _malloc_crt((_tcslen(pathname) + 3) * sizeof(_TSCHAR))))
                                        return(-1);

                                _tcscpy(pathname, _T(".\\"));
                                _tcscat(pathname, name);

                                /* set p to point to the start of the filename
                                 * (i.e., past the ".\\" prefix) */
                                p = pathname + 2;
                        }
                        /* else pathname has drive specifier prefix and p is
                         * is pointing to the ':' */
        }
        else if (!p || q > p)   /* p == NULL or q > p */
                p = q;


        rc = -1;        /* init to error value */

        if (ext = _tcsrchr(p, _T('.')))  {

                /* extension given; only do filename */

                if (_taccess(pathname, 0) != -1) {

#ifndef EXECVE

#ifdef WPRFLAG
                        rc = wcomexecmd(mode, pathname, argv, envp);
#else
                        rc = comexecmd(mode, pathname, argv, envp);
#endif

#else /* EXECVE */

#ifdef WPRFLAG
                        rc = wcomexecmd(pathname, argv, envp);
#else
                        rc = comexecmd(pathname, argv, envp);
#endif

#endif /* EXECVE */
                }

        }
        else    {

                /* no extension; try .cmd/.bat, then .com and .exe */

                if (!(p = _malloc_crt((_tcslen(pathname) + 5) * sizeof(_TSCHAR))))
                        return(-1);

                _tcscpy(p, pathname);
                ext = p + _tcslen(pathname);

                for (i = EXTLAST; i >= EXTFIRST; --i) {
                        _tcscpy(ext, ext_strings[i]);

                        if (_taccess(p, 0) != -1) {

#ifndef EXECVE
#ifdef WPRFLAG
                                rc = wcomexecmd(mode, p, argv, envp);
#else
                                rc = comexecmd(mode, p, argv, envp);
#endif
#else /* EXECVE */
#ifdef WPRFLAG
                                rc = wcomexecmd(p, argv, envp);
#else
                                rc = comexecmd(p, argv, envp);
#endif
#endif /* EXECVE */
                                break;
                        }
                }
                _free_crt(p);
        }

        if (pathname != name)
                _free_crt(pathname);

        return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\spawnvp.c ===
/***
*spawnvp.c - spawn a child process; search along PATH
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnvp() - spawn a child process; search along PATH
*
*Revision History:
*       04-15-84  DFW   written
*       10-29-85  TC    added spawnvpe capability
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for filename and argv.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>
*       05-21-90  GJF   Fixed stack checking pragma syntax.
*       08-24-90  SBM   Removed check_stack pragma since workhorse _spawnve
*                       does stack checks
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>

/***
*int _spawnvp(modeflag, filename, argv) - spawn a child process (search PATH)
*
*Purpose:
*       Spawns a child process, with search along PATH variable.
*       formats the parameters and calls _spawnve to do the actual work. The
*       NULL environment pointer indicates the new process will inherit the
*       parents process's environment.  NOTE - at least one argument must be
*       present.  This argument is always, by convention, the name of the file
*       being spawned.
*
*Entry:
*       int modeflag   - mode to spawn (WAIT, NOWAIT, or OVERLAY)
*                        only WAIT and OVERLAY currently supported
*       _TSCHAR *pathname - name of file to spawn
*       _TSCHAR **argv    - vector of arguments
*
*Exit:
*       returns exit code of child process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnvp (
        int modeflag,
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argv
        )
{
        return _tspawnvpe(modeflag, filename, argv, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wait.c ===
/***
*wait.c - wait for child process to terminate
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wait() - wait for child process to terminate
*
*Revision History:
*       06-08-89  PHG   Module created, based on asm version
*       03-08-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned up
*                       the formatting a bit.
*       04-02-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-17-91  GJF   ANSI naming
*       02-18-91  SRW   Fixed code to close process handle. [_WIN32_]
*       04-26-91  SRW   Removed level 3 warnings [_WIN32_]
*       12-17-91  GJF   Fixed _cwait for Win32. However, _wait is still
*                       broken [_WIN32_].
*       07-21-92  GJF   Removed _wait for Win32, not implemented and no good
*                       way to implement.
*       12-14-92  GJF   For Win32, map ERROR_INVALID_HANDLE to ECHILD.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Remove Cruiser support.
*       02-06-98  GJF   Changes for Win64: changed return and an arg type to 
*                       intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <process.h>
#include <errno.h>
#include <internal.h>
#include <stdlib.h>

/***
*int _cwait(stat_loc, process_id, action_code) - wait for specific child
*       process
*
*Purpose:
*       The function _cwait() suspends the calling-process until the specified
*       child-process terminates.  If the specifed child-process terminated
*       prior to the call to _cwait(), return is immediate.
*
*Entry:
*       int *stat_loc - pointer to where status is stored or NULL
*       process_id - specific process id to be interrogated (0 means any)
*       action_code - specific action to perform on process ID
*                   either _WAIT_CHILD or _WAIT_GRANDCHILD
*
*Exit:
*       process ID of terminated child or -1 on error
*
*       *stat_loc is updated to contain the following:
*       Normal termination: lo-byte = 0, hi-byte = child exit code
*       Abnormal termination: lo-byte = term status, hi-byte = 0
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _cwait (
        int *stat_loc,
        intptr_t process_id,
        int action_code
        )
{
        intptr_t retval;
        int retstatus;
        unsigned long oserror;

        DBG_UNREFERENCED_PARAMETER(action_code);

        /* Explicitly check for process_id being -1 or -2. In Windows NT,
         * -1 is a handle on the current process, -2 is a handle on the
         * current thread, and it is perfectly legal to to wait (forever)
         * on either */
        if ( (process_id == -1) || (process_id == -2) ) {
            errno = ECHILD;
            return -1;
        }

        /* wait for child process, then fetch its exit code */
        if ( (WaitForSingleObject((HANDLE)process_id, (DWORD)(-1L)) == 0) &&
          GetExitCodeProcess((HANDLE)process_id, (LPDWORD)&retstatus) ) {
            retval = process_id;
        }
        else {
            /* one of the API calls failed. map the error and set up to
               return failure. note the invalid handle error is mapped in-
               line to ECHILD */
            if ( (oserror = GetLastError()) == ERROR_INVALID_HANDLE ) {
                errno = ECHILD;
                _doserrno = oserror;
            }
            else
                _dosmaperr(GetLastError());

            retval = -1;
            retstatus = -1;
        }

        CloseHandle((HANDLE)process_id);

        if (stat_loc != NULL)
            *stat_loc = retstatus;

        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\spawnvpe.c ===
/***
*spawnvpe.c - spawn a child process with given environ (search PATH)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnvpe() - spawn a child process with given environ (search
*       PATH)
*
*Revision History:
*       04-15-84  DFW   written
*       10-29-85  TC    added spawnvpe capability
*       11-19-86  SKS   handle both kinds of slashes
*       12-01-86  JMB   added Kanji file name support under conditional KANJI
*                       switches.  Corrected header info.  Removed bogus check
*                       for env = b after call to strncpy
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       09-05-88  SKS   Treat EACCES the same as ENOENT -- keep trying
*       10-17-88  GJF   Removed copy of PATH string to local array, changed
*                       bbuf to be a malloc-ed buffer. Removed bogus limits
*                       on the size of that PATH string.
*       10-25-88  GJF   Don't search PATH when relative pathname is given (per
*                       Stevesa). Also, if the name built from PATH component
*                       and filename is a UNC name, allow any error.
*       05-17-89  MT    Added "include <jstring.h>" under KANJI switch
*       05-24-89  PHG   Reduce _amblksiz to use minimal memory (DOS only)
*       08-29-89  GJF   Use _getpath() to retrieve PATH components, fixing
*                       several problems in handling unusual or bizarre
*                       PATH's.
*       11-20-89  GJF   Added const attribute to types of filename, argv and
*                       envptr.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       09-25-91  JCR   Changed ifdef "OS2" to "_DOS_" (unused in 32-bit tree)
*       11-30-92  KRS   Port _MBCS code from 16-bit tree.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <internal.h>
#include <process.h>
#include <mbstring.h>
#include <tchar.h>
#include <dbgint.h>

#define SLASH _T("\\")
#define SLASHCHAR _T('\\')
#define XSLASHCHAR _T('/')
#define DELIMITER _T(";")

#ifdef _MBCS
/* note, the macro below assumes p is to pointer to a single-byte character
 * or the 1st byte of a double-byte character, in a string.
 */
#define ISPSLASH(p)     ( ((p) == _mbschr((p), SLASHCHAR)) || ((p) == \
_mbschr((p), XSLASHCHAR)) )
#else
#define ISSLASH(c)      ( ((c) == SLASHCHAR) || ((c) == XSLASHCHAR) )
#endif

/***
*_spawnvpe(modeflag, filename, argv, envptr) - spawn a child process
*
*Purpose:
*       Spawns a child process with the given arguments and environ,
*       searches along PATH for given file until found.
*       Formats the parameters and calls _spawnve to do the actual work. The
*       NULL environment pointer indicates that the new process will inherit
*       the parents process's environment.  NOTE - at least one argument must
*       be present.  This argument is always, by convention, the name of the
*       file being spawned.
*
*Entry:
*       int modeflag - defines mode of spawn (WAIT, NOWAIT, or OVERLAY)
*                       only WAIT and OVERLAY supported
*       _TSCHAR *filename - name of file to execute
*       _TSCHAR **argv - vector of parameters
*       _TSCHAR **envptr - vector of environment variables
*
*Exit:
*       returns exit code of spawned process
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnvpe (
        int modeflag,
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envptr
        )
{
        intptr_t i;
        REG1 _TSCHAR *env;
        REG2 _TSCHAR *buf = NULL;
        _TSCHAR *pfin;
#ifdef _DOS_
        int tempamblksiz;          /* old _amblksiz */
#endif
        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(argv != NULL);
        _ASSERTE(*argv != NULL);
        _ASSERTE(**argv != _T('\0'));

#ifdef _DOS_
        tempamblksiz = _amblksiz;
        _amblksiz = 0x10;           /* reduce _amblksiz for efficient mallocs */
#endif

        if (
        (i = _tspawnve(modeflag, filename, argv, envptr)) != -1
                /* everything worked just fine; return i */

        || (errno != ENOENT)
                /* couldn't spawn the process, return failure */

        || (_tcschr(filename, XSLASHCHAR) != NULL)
                /* filename contains a '/', return failure */

#ifdef _DOS_
        || (_tcschr(filename,SLASHCHAR) != NULL)
                /* filename contains a '\', return failure */

        || *filename && *(filename+1) == _T(':')
                /* drive specification, return failure */
#endif

        || !(env = _tgetenv(_T("PATH")))
                /* no PATH environment string name, return failure */

        || ( (buf = _malloc_crt(_MAX_PATH * sizeof(_TSCHAR))) == NULL )
                /* cannot allocate buffer to build alternate pathnames, return
                 * failure */
        ) {
#ifdef _DOS_
                _amblksiz = tempamblksiz;       /* restore old _amblksiz */
#endif
                goto done;
        }

#ifdef _DOS_
        _amblksiz = tempamblksiz;               /* restore old _amblksiz */
#endif


        /* could not find the file as specified, search PATH. try each
         * component of the PATH until we get either no error return, or the
         * error is not ENOENT and the component is not a UNC name, or we run
         * out of components to try.
         */

#ifdef WPRFLAG
        while ( (env = _wgetpath(env, buf, _MAX_PATH - 1)) && (*buf) ) {
#else
        while ( (env = _getpath(env, buf, _MAX_PATH - 1)) && (*buf) ) {
#endif            

                pfin = buf + _tcslen(buf) - 1;

                /* if necessary, append a '/'
                 */
#ifdef _MBCS
                if (*pfin == SLASHCHAR) {
                        if (pfin != _mbsrchr(buf,SLASHCHAR))
                        /* fin is the second byte of a double-byte char */
                                strcat(buf, SLASH );
                }
                else if (*pfin !=XSLASHCHAR)
                        strcat(buf, SLASH);
#else
                if (*pfin != SLASHCHAR && *pfin != XSLASHCHAR)
                        _tcscat(buf, SLASH);
#endif
                /* check that the final path will be of legal size. if so,
                 * build it. otherwise, return to the caller (return value
                 * and errno rename set from initial call to _spawnve()).
                 */
                if ( (_tcslen(buf) + _tcslen(filename)) < _MAX_PATH )
                        _tcscat(buf, filename);
                else
                        break;

                /* try spawning it. if successful, or if errno comes back with a
                 * value other than ENOENT and the pathname is not a UNC name,
                 * return to the caller.
                 */
                if ( (i = _tspawnve(modeflag, buf, argv, envptr)) != -1
                        || ((errno != ENOENT)
#ifdef _MBCS
                                && (!ISPSLASH(buf) || !ISPSLASH(buf+1))) )
#else
                                && (!ISSLASH(*buf) || !ISSLASH(*(buf+1)))) )
#endif
                        break;

        }

done:
        if (buf != NULL)
            _free_crt(buf);
        return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wcenvarg.c ===
/***
*wcenvarg.c - set up environment, command line blocks (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wcenvarg() - setup wide environment/command line blocks
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "cenvarg.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wdospawn.c ===
/***
*wdospawn.c - spawn a child process (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wdospawn - spawn a child process and pass wide environment
*
*Revision History:
*	11-19-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "dospawn.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\system.c ===
/***
*system.c - pass a command line to the shell
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines system() - passes a command to the shell
*
*Revision History:
*       12-01-83  RN    written
*       10-23-86  SKS   Fixed use of strtok(), added check for NULL rtn from getenv
*       12-18-86  SKS   PROTMODE symbol used for dual-modal version
*       02-23-86  JCR   Put in support for NULL command pointer (MSDOS only)
*       04-13-86  JCR   Added const to declaration
*       06-30-87  JCR   Re-wrote system to use spawnvpe, removed XENIX conditional
*                       code, lots of general cleaning up.
*       07-01-87  PHG   removed P->PROTMODE compile switch hack
*       09-22-87  SKS   remove extern variable declarations, add ";" to assert()'s
*       11-10-87  SKS   Removed IBMC20 switch, change PROTMODE to OS2
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-22-88  JCR   Added cast to get rid of cl const warning
*       09-05-88  SKS   Treat EACCES the same as ENOENT -- keep trying
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed some leftover DOS support and
*                       fixed the copyright. Also, cleaned up the formatting
*                       formatting a bit.
*       07-23-90  SBM   Compiles cleanly with -W3 (removed unreferenced
*                       variable), removed redundant includes, replaced
*                       <assertm.h> by <assert.h>, minor optimizations
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       02-23-93  SKS   Remove reference to _osmode and use of "command.com"
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       12-06-94  SKS   Assume command.com for Win95, but cmd.exe for Win. NT.
*       01-16-95  SKS   Avoid calling access(NULL) if command==NULL and
*                       %COMSPEC% is unset.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: added cast to int where necessary
*
*******************************************************************************/

#include <cruntime.h>
#include <process.h>
#include <io.h>
#include <stdlib.h>
#include <errno.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int system(command) - send the command line to a shell
*
*Purpose:
*       Executes a shell and passes the command line to it.
*       If command is NULL, determine if a command processor exists.
*       The command processor is described by the environment variable
*       COMSPEC.  If that environment variable does not exist, try the
*       name "cmd.exe" for Windows NT and "command.com" for Windows '95.
*
*Entry:
*       char *command - command to pass to the shell (if NULL, just determine
*                       if command processor exists)
*
*Exit:
*       if command != NULL  returns status of the shell
*       if command == NULL  returns non-zero if CP exists, zero if CP doesn't exist
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tsystem (
        const _TSCHAR *command
        )
{
        int catch;
        _TSCHAR *argv[4];

        argv[0] = _tgetenv(_T("COMSPEC"));

        /*
         * If command == NULL, return true IFF %COMSPEC%
         * is set AND the file it points to exists.
         */

        if (command == NULL) {
                return argv[0] == NULL ? 0 : (!_taccess(argv[0],0));
        }

        _ASSERTE(*command != _T('\0'));

        argv[1] = _T("/c");
        argv[2] = (_TSCHAR *) command;
        argv[3] = NULL;

        /* If there is a COMSPEC defined, try spawning the shell */

        if (argv[0])    /* Do not try to spawn the null string */
                if ((catch = (int)_tspawnve(_P_WAIT,argv[0],argv,NULL)) != -1
                || (errno != ENOENT && errno != EACCES))
                        return(catch);

        /* No COMSPEC so set argv[0] to what COMSPEC should be. */
        argv[0] = ( _osver & 0x8000 ) ? _T("command.com") : _T("cmd.exe");

        /* Let the _spawnvpe routine do the path search and spawn. */

        return((int)_tspawnvpe(_P_WAIT,argv[0],argv,NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wexecl.c ===
/***
*wexecl.c - execute a file with a list of arguments (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecl() - execute a file with a list of arguments
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execl.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wexecle.c ===
/***
*wexecle.c - execute a file with arg list and environment (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecle() - execute a file
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execle.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wexeclp.c ===
/***
*wexeclp.c - execute a file (search along PATH) (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexeclp() - execute a file and search along PATH
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execlp.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wspawnl.c ===
/***
*wspawnl.c - spawn a child process (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnl() - spawn a child process
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnl.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wexecvp.c ===
/***
*wexecvp.c - execute a file and search along PATH (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecvp() - execute a file and search along PATH
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execvp.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wexecv.c ===
/***
*wexecv.c - execute a file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecv() - execute a file
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wspawnle.c ===
/***
*wspawnle.c - spawn a child process with given environment (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnle() - spawn a child process with given environ
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnle.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wexeclpe.c ===
/***
*wexeclpe.c - execute a file (search along PATH) (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexeclpe() - execute a file and search along PATH
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execlpe.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wexecve.c ===
/***
*wexecve.c - execute a file with a given environment (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecve() - execute a file
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#define EXECVE
#include "spawnve.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wexecvpe.c ===
/***
*wexecvpe.c - execute a file with given environ; search along PATH (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecvpe() - execute a file with given environ
*
*Revision History:
*	11-19-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execvpe.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wspawnlp.c ===
/***
*wspawnlp.c - spawn a file; search along PATH (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnlp() - spawn a file with search along PATH
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnlp.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wspawnvp.c ===
/***
*wspawnvp.c - spawn a child process; search along PATH (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnvp() - spawn a child process; search along PATH
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnvp.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wspwnlpe.c ===
/***
*wspwnlpe.c - spawn a child process with environ and search along PATH (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnlpe() - spawn a child process with environ/PATH search
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnlpe.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wspawnve.c ===
/***
*wspawnve.c - Low level routine eventually called by all _wspawnXX routines
*	also contains all code for _wexecve, called by _wexecXX routines
*       (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*	This is the low level routine which is eventually invoked by all the
*	_wspawnXX routines.
*
*	This is also the low-level routine which is eventually invoked by
*	all of the _wexecXX routines.
*
*Revision History:
*	11-19-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnve.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wspawnv.c ===
/***
*wspawnv.c - spawn a child process (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnv() - spawn a child process
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wspwnvpe.c ===
/***
*wspwnvpe.c - spawn a child process with given environ (search PATH) (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnvpe() - spawn a child process with given environ (search
*	PATH)
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnvpe.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\exec\wsystem.c ===
/***
*wsystem.c - pass a command line to the shell (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wsystem() - passes a command to the shell
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "system.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
*Revision History:
*       12-18-87  JCR   Added _FAR_ to declarations
*       01-18-88  JCR   Added fflush(stderr) to go with new stderr buffering scheme
*       02-10-88  JCR   Cleaned up white space
*       05-19-88  JCR   Use routine _assert() to save space
*       07-14-88  JCR   Allow user's to enable/disable assert multiple times in
*                       a single module [ANSI]
*       10-19-88  JCR   Revised to also work for the 386 (small model only)
*       12-22-88  JCR   Assert() must be an expression (no 'if' statements)
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       07-27-89  GJF   Cleanup, now specific to the 386
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       02-27-90  GJF   Added #include <cruntime.h> stuff. Also, removed some
*                       (now) useless preprocessor directives.
*       03-21-90  GJF   Replaced _cdecl with _CALLTYPE1 in prototype.
*       07-31-90  SBM   added ((void)0) to NDEBUG definition, now ANSI
*       08-20-91  JCR   C++ and ANSI naming
*       08-26-92  GJF   Function calling type and variable type macros.
*       09-25-92  SRW   Don't use ? in assert macro to keep CFRONT happy.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       02-01-93  GJF   Replaced SteveWo's assert macro with an ANSI-conformant
*                       one. Also got rid of '//' comment characters.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       03-02-95  CFW   Removed _INC_ASSERT. According to ANSI, must be able
*                       to include this file more than once.
*       12-14-95  JWM   Add "#pragma once".
*       12-19-95  JWM   Removed "#pragma once" - ANSI restriction.
*       02-20-97  GJF   Cleaned out obsolete support for _CRTAPI* and _NTSDK.
*                       Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifndef _INTERNAL_IFSTRIP_
#ifndef _ASSERT_OK
#error assert.h not for CRT internal use, use dbgint.h
#endif  /* _ASSERT_OK */
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#undef  assert

#ifdef  NDEBUG

#define assert(exp)     ((void)0)

#else

#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif

#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\awint.h ===
/***
*awint.h - internal definitions for A&W Win32 wrapper routines.
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains internal definitions/declarations for A&W wrapper functions.
*       Not included in internal.h since windows.h is required for these.
*
*       [Internal]
*
*Revision History:
*       03-30-94  CFW   Module created.
*       04-18-94  CFW   Add lcid parameter.
*       02-14-95  CFW   Clean up Mac merge.
*       02-24-95  CFW   Add _crtMessageBox.
*       02-27-95  CFW   Change __crtMessageBoxA params.
*       03-29-95  CFW   Add error message to internal headers.
*       05-26-95  GJF   Changed prototype for __crtGetEnvironmentStringsA.
*       12-14-95  JWM   Add "#pragma once".
*       03-16-97  RDK   Added error flag to __crtGetStringTypeA.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       08-22-00  GB    Added __ansicp and __convertcp
*
****/

#if _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifdef _WIN32

#ifndef _INC_AWINC
#define _INC_AWINC

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>

/* internal A&W routines */

int __cdecl __crtCompareStringW(LCID, DWORD, LPCWSTR, int, LPCWSTR, int, int);
int __cdecl __crtCompareStringA(LCID, DWORD, LPCSTR, int, LPCSTR, int, int);

int __cdecl __crtGetLocaleInfoW(LCID, LCTYPE, LPWSTR, int, int);
int __cdecl __crtGetLocaleInfoA(LCID, LCTYPE, LPSTR, int, int);
 
int __cdecl __crtLCMapStringW(LCID, DWORD, LPCWSTR, int, LPWSTR, int, int);
int __cdecl __crtLCMapStringA(LCID, DWORD, LPCSTR, int, LPSTR, int, int, BOOL);

BOOL __cdecl __crtGetStringTypeW(DWORD, LPCWSTR, int, LPWORD, int, int);
BOOL __cdecl __crtGetStringTypeA(DWORD, LPCSTR, int, LPWORD, int, int, BOOL);

LPVOID __cdecl __crtGetEnvironmentStringsW(VOID);
LPVOID __cdecl __crtGetEnvironmentStringsA(VOID);

LPWSTR __cdecl __crtGetCommandLineW(VOID);

int __cdecl __crtMessageBoxA(LPCSTR, LPCSTR, UINT);

/* internal routines for supporting A&W routines */

int __cdecl __ansicp(int);
char * __cdecl __convertcp(int, int, const char *, int *, char *, int);

#ifdef __cplusplus
}
#endif

#endif /* _INC_AWINC */

#endif /* _WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\cruntime.h ===
/***
*cruntime.h - definitions specific to the target operating system and hardware
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header file contains widely used definitions specific to the
*       host operating system and hardware. It is included by every C source
*       and most every other header file.
*
*       [Internal]
*
*Revision History:
*       02-27-90  GJF   File created
*       03-06-90  GJF   Added register macros (REG1,...,etc.)
*       04-11-90  GJF   Set _CALLTYPE1 and _CALLTYPE4 to _stdcall.
*       10-30-90  GJF   Added macros defining variable args interface.
*       10-31-90  GJF   Added definition of _JBLEN (from setjmp.h).
*       11-13-90  GJF   Revised #ifdef-s, now use symbolic constants
*                       representing target OS and target processor, with
*                       #error directives for unsupported targets. Note the
*                       general grouping of only OS-dependent definitions
*                       followed by OS and processor dependent definitions.
*       02-25-91  SRW   Move _JBLEN definition back to setjmp.h [_WIN32_]
*       04-09-91  PNT   Added _MAC_ definitions
*       05-09-91  GJF   Restored _JBLEN definitions. Also fixed the macros
*                       defining the target processor so both Stevewo's stuff
*                       and mine would work.
*       05-13-91  GJF   Changed _CALLTYPE1 and _CALLTYPE4 to _cdecl for
*                       Cruiser (_CRUISER_).
*       08-28-91  JCR   ANSI keywords
*       11-01-91  GDP   _JBLEN back to setjmp.h, stdarg macros back to stdarg.h
*       03-30-92  DJM   POSIX support.
*       08-07-92  GJF   Revised various macros.
*       09-08-92  GJF   Restored definition of _MIPS_ (temporarily).
*       11-09-92  GJF   Revised preprocessing conditionals for MIPS.
*       01-09-93  SRW   Remove usage of MIPS and ALPHA to conform to ANSI
*                       Use _MIPS_ and _ALPHA_ instead.
*       02-01-93  GJF   Removed support for C6-386.
*       04-06-93  SKS   Remove support for OS/2, MAC, POSIX, MIPS, etc.
*       11-11-93  GJF   Merged in NT SDK version. Note that having
*                       definitions for the variable-argument access macros
*                       in this file is probably obsolete - this needs to be
*                       checked.
*       10-02-94  BWT   Add PPC support.
*       10-09-94  BWT   Unknown platform changes from John Morgan.
*       12-15-94  XY    merged with mac header
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*       10-07-97  RDL   Added IA64.
*       05-17-99  PML   Remove all Macintosh support.
*       11-03-99  PML   Remove _VA_LIST_T
*       03-18-01  PML   Define _USE_OLD_STDCPP when compiling with stdcpp64
*                       and stdhpp64, for the Win64 system CRTs.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CRUNTIME
#define _INC_CRUNTIME

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#if     defined(_SYSCRT) && defined(_WIN64)
#define _USE_OLD_STDCPP 1
#endif

#if     defined(_AMD64_) || defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif

#ifdef  _M_IX86
/*
 * 386/486
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#elif   ( defined(_M_AMD64) || defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) )
/*
 * MIPS, ALPHA, or PPC
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4    register
#define REG5    register
#define REG6    register
#define REG7    register
#define REG8    register
#define REG9    register

#else

#pragma message ("Machine register set not defined")

/*
 * Unknown machine
 */

#define REG1
#define REG2
#define REG3
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#endif

/*
 * Are the macro definitions below still needed in this file? Are they even
 * correct for MIPS (probably not).
 */
#if     defined(_POSIX_) && !defined(_M_ALPHA)

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define _VA_START(ap,v) ap = (va_list)&v + _INTSIZEOF(v)
#define _VA_ARG(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define _VA_END(ap) ap = (va_list)0

#endif

#endif  /* _INC_CRUNTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\cruntime.inc ===
;***
;cruntime.inc - multi-model assembly macros for interfacing to HLLs
;
;	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file defines the current memory model being used.
;
;Revision History:
;	08-04-88  SJM	Initial version to handle all four memory models
;			in 16-bit mode and small model in 32-bit mode
;	08-08-88  JCR	Added CPDIST, ?WIN, PCS, ISHIFT/LSHIFT, OS2,
;			DNPTR/DFPTR, DFLOAT/DDOUBLE/DLDOUBLE
;	08-16-88  PHG	Added FPES, LFPES, CBI, ZXAL, ZXBL, ZXCL, ZXDL
;	08-17-88  JCR	Added CAXDX, modified FPSIZE
;	08-20-88  PHG	Added diagnostic messages, removed 386 16-bit support
;			and 386 large code/data support, added mucho comments,
;			PSS now defined as es: only if SS_NEQ_GROUP defined
;	08-24-88  JCR	Added RBXSAVE and RBXONLY for use in 'proc uses'
;	08-25-88  JCR	Added savereg macro, removed rbxsave/rbxonly...
;	08-26-88  GJF	Added codeseg (text) macro
;	09-15-88  JCR	Corrected savelist/reglist macro to go with new MASM
;	09-21-88  WAJ	Added JS*, static*, global*, and label*, and lab macros
;	09-22-88  JCR	Change 'plm' to 'pascal' in label macro
;	09-26-88  WAJ	Added PUSH16 which will do a 16 bit push in a USE32 seg.
;	09-28-88  WAJ	Added CPWORD and DPWORD
;	09-29-88  WAJ	Added JMPFAR16 macro
;	10-12-88  JCR	Made PCS evaluate to 'cs:' for 16/32 stub testbed
;	04-24-89  JCR	Added 'assume seg:flat' for 386 to avoid masm/link bug
;	05-25-89  GJF	Added APIEXT, a macro that expands to the proper extrn
;			declaration for an API function
;	06-13-89  JCR	Added 'flat:' to DCPTR and DDPTR
;	09-15-89  JCR	Added DCPTR? and DDPTR?, always use "FLAT" not "flat"
;	10-27-92  SKS	Miscellaneous minor changes for MASM 6.10 compatibility
;	09-06-94  CFW	Replace MTHREAD with _MT.
;	01-11-95  SKS	Remove MASM 5.X support
;	05-04-95  GJF	Use .586 for Win32.
;
;*******************************************************************************

;==============================================================================
;
;Use the following defines to control processor/segment model
;
;   -DI86		8086/8088 processor
;   -DI286		80286 processor
;   -DI386		80386 processor with 32-bit code/data segment
;
;   -Dmem_S		Small memory model   (near code, near data)
;   -Dmem_M		Medium memory model  (far code, near data)
;   -Dmem_C		Compact memory model (near code, fat data)
;   -Dmem_L		Large memory model   (far code, far data)
;
;   -DSS_NEQ_DGROUP	SS and DS point to different segments
;
;   default is -DI86 -Dmem_S
;
;==============================================================================
;
;The following variables are defined by this file:
;   cpu 			86, 286, or 386
;   sizeC			code distance; 1 = far code, 0 = near code
;   sizeD			data distance; 1 = far data, 0 = near data
;   mmodel			english name of the memory model, i.e. "Medium"
;   ISIZE, LSIZE, NSIZE 	size of ints, longs, shorts
;   FLTSIZE, DBLSIZE, LDBLSIZE	size of float, double, long double
;   NPSIZE, FPSIZE		size of near/far pointers
;   CPSIZE, DPSIZE		size of code/data pointers
;   ISHIFT, LSHIFT		bits to shift to convert byte to int/long
;
;The following macros allow easy writing of combined 16/32 bit code:
;
; 16/32 bit registers:
;   rax, rbx, rcx, rdx, 	expand to native registers (rax = eax or ax)
;   rsi, rdi, rsp, rbp
; 16/32 bit register instructions:
;   JRCXZ			jump when rcx is zero
;   CBI 			convert byte to int (al to rax)
;   CAXDX			convert rax to rax:rdx
;   ZXAL, ZXBL, ZXCL, ZXDL	zero extend al,bl,cl,dl to rax,rbx,rcx,rdx
; Pointer instructions:
;   LPDS, LPES			load data pointer with ES or DS
;   PDS, PES			segment overrides when pointer loaded as above
;   PCS, PSS			segment override to get at code/stack segment
;   LFPDS, LFPES		load far pointer with ES or DS
;   FPDS, FPES			segment overrides when pointer loaded as above
;   CPTR			data type of code pointer
;   CPDIST			distance of code (near/far)
;   DNPTR, DFPTR		define near/far pointer
;   DCPTR, DDPTR		define code/data pointer
;   DCPTR?, DDPTR?		define uninitialized code/data pointer
;   CPWORD, DPWORD		data type of code or data pointer
; Numeric type instructions:
;   IWORD, LWORD, SWORD 	data type of int, long, short
;   DINT, DLONG, DSHORT 	define int, long, short
;   DFLOAT, DDOUBLE, DLDOUBLE	define float, double, long double
; Offsets:
;   codeoffset, dataoffset	offsets from code and data segments
; API calls:
;   APIDIST			distance of API calls (near/far)
;   APIEXT ApiName		extrn declaration for an API function
;
;The following utility macros are provided:
;   codeseg			define/declare code segment
;   error <msg> 		stop assembly with message
;   display <msg>		display a message, unless QUIET defined
;   savelist [<reg> ...]	init list of regs to be save by 'proc uses'
;   _if cond <instruction>	assemble instruction only if cond is TRUE
;   _ife cond <instruction>	assemble instruction only if cond is FALSE
;   _ifd symbol <instruction>	assemble instruction only if symbol defined
;   _ifnd symbol <instruction>	assemble instruction only if symbol not defined
;
;   lab  LabelName		assembles to "LabelName:" If DEBUG is defined
;				LabelName is made public
;
;   JS* (ex. JSE,JSZ,JSB ...)	assemble to "je short","jz short","jb short"
;
;   Cmacro look alikes
;   static* Name, InitialValue, Repeat	 defines a static variable of type *
;   global* Name, InitialValue, Repeat	 defines a global variable of type *
;   label*  Name, {PUBLIC,PASCAL,C}	 defines a label of type *
;
;   PUSH16  SegmentReg		pushes 16 bits in a use32 segment
;   JMPFAR16  label		will do a far 16:16 jmp from a use32 segment
;
;==============================================================================

; error <msg>	-    Output message and generate error

error	MACRO	msg
if2			;; only on pass 2 can we generate errors
	%out	**********************************************************
	%out	*** E r r o r  --  msg
	%out	**********************************************************
	.err
endif
        ENDM

; display msg	-    Output message unless QUIET defined

display MACRO	msg
ifndef QUIET		;; only when quiet flag not set
if1			;; and on pass 1, then display message
	%out msg
endif
endif
	ENDM

; One line conditionals:
;   here we create the capability of writing code lines like
;
; _if sizeD   <push ds>   as opposed to    if sizeD
;					       push  ds
;					   endif

_if	MACRO	cond,text
    if	cond
	text
    endif
	ENDM

_ife	MACRO	cond,text
    ife cond
	text
    endif
	ENDM

_ifd	MACRO	cond,text
    ifdef   cond
	text
    endif
	ENDM

_ifnd	MACRO	cond,text
    ifndef  cond
	text
    endif
	ENDM

; set windows flag to 0

	?WIN	equ	0	; disable windows-specific code

; check for _MT, requires 286 or greater processor

ifdef _MT
ifndef I386
ifndef I286
; _MT implies 286 processor
display <Multi-thread specified - assuming 80286 processor>
I286 equ <>
endif
endif
endif

; Process memory-model arguments

ifdef  mem_M
	; Medium model
	sizeC	equ	1
	sizeD	equ	0
	mmodel	equ	<Medium>
elseifdef  mem_C
	; Compact model
	sizeC	equ	0
	sizeD	equ	1
	mmodel	equ	<Compact>
elseifdef  mem_L
	; Large model
	sizeC	equ	1
	sizeD	equ	1
	mmodel	equ	<Large>
else
	; Small model - default
	sizeC	equ	0
	sizeD	equ	0
	mmodel	equ	<Small>
endif

; Process processor arguments

ifdef	_WIN32
	display <Processor:		486/586>
	cpu equ 586
	.586
elseifdef	_POSIX_
	display <Processor:		486/586>
	cpu equ 586
	.586
elseifdef   I286
	display <Processor:		80286>
	cpu equ 286
	.286
elseifdef   I386
	display <Processor:		80386>
	cpu equ 386
	.386
else
	display <Processor:		8086/8088>
	cpu equ 86
	.8086
endif

;  386 32-bit checking.  Currently we are only expecting small model
;  32 bit segments, so we make a few checks to be sure nothing is
;  incorrectly being defined.

ifdef I386
    if sizeC or sizeD
	error <Must use Small memory model for 386 version.>
    endif

    ifdef _LOAD_DGROUP
	error <No loading DGROUP in 386 version.>
    endif

    ifdef SS_NEQ_DGROUP
	error <SS always equals DGROUP in 386 version.>
    endif
endif

;  Set memory model

%	display <Memory model:		mmodel>
%	.model	mmodel, C

;
; *** Temporary Workaround ***
; Currently, MASM will not recognize the 'FLAT' keyword unless it previously
; appears in an 'assume' statement.  Presumably, when the '.model FLAT' feature
; is implemented, this will go away.  [Use 'gs:' since we never use that
; segment register.
;

ifdef	I386
	; ensure that MASM recognizes 'FLAT'
	assume	gs:FLAT
endif


; Define registers:
; Instead of using the "word" registers directly, we will use a set of
; text equates.  This will allow you to use the native word size instead of
; hard coded to 16 bit words.  We also have some instruction equates for
; instruction with the register type hard coded in.

ifdef I386

    rax equ <eax>
    rbx equ <ebx>
    rcx equ <ecx>
    rdx equ <edx>
    rdi equ <edi>
    rsi equ <esi>
    rbp equ <ebp>
    rsp equ <esp>

    JRCXZ equ <jecxz>
    CBI   equ <movsx eax, al>	 ; convert byte to int (al to rax)
    CAXDX equ <cdq>		 ; convert rax to rdx:rax
    ZXAL  equ <movzx eax, al>	 ; zero extend al
    ZXBL  equ <movzx ebx, bl>	 ; zero extend bl
    ZXCL  equ <movzx ecx, cl>	 ; zero extend cl
    ZXDL  equ <movzx edx, dl>	 ; zero extend dl

else

    rax equ <ax>
    rbx equ <bx>
    rcx equ <cx>
    rdx equ <dx>
    rdi equ <di>
    rsi equ <si>
    rbp equ <bp>
    rsp equ <sp>

    JRCXZ equ <jcxz>
    CBI   equ <cbw>		 ; convert byte to int (al to rax)
    CAXDX equ <cwd>		 ; convert rax to rdx:rax
    ZXAL  equ <xor ah, ah>	 ; zero extend al
    ZXBL  equ <xor bh, bh>	 ; zero extend bl
    ZXCL  equ <xor ch, ch>	 ; zero extend cl
    ZXDL  equ <xor dh, dh>	 ; zero extend dl

endif

; The following equates deal with the differences in near versus
; far data pointers, and segment overrides.
;
; Use LPES and PES when loading a default size pointer -- it loads
; a 16-bit pointer register in 286 Small/Medium model,
; a 16-bit pointer register and 16-bit segment register in 8086/286
; Compact/Large model, and a 32-bit pointer register in 386 mode.
;
; Use LFPES and FPES when loading an always far pointer -- it loads a
; 16-bit pointer register and 16-bit segment register in 8086/286,
; all models; a 32-bit pointer register in 386 mode.

if sizeD
    LPES equ <les>
    LPDS equ <lds>
    PDS  equ <ds:>
    PES  equ <es:>
else
    LPES equ <mov>
    LPDS equ <mov>
    PDS  equ <>
    PES  equ <>
endif

ifdef I386
    LFPES equ <mov>
    LFPDS equ <mov>
    FPES equ <>
    FPDS equ <>
else
    LFPES equ <les>
    LFPDS equ <lds>
    FPES equ <es:>
    FPDS equ <ds:>
endif

if sizeC or @WordSize eq 2
    PCS  equ <cs:>		; large code model or non-386
else
 IF 1	;*** TEMP 16/32 TESTBED ***
    PCS  equ <cs:>
 ELSE
    PCS  equ <> 		; 386 small code model
 ENDIF	;*** END TEMP CODE
endif

ifdef SS_NEQ_DGROUP
    PSS   equ <ss:>		; SS != DS
else
    PSS   equ <>		; SS == DS
endif

; Define offset macros:
;   The 32-bit segments will not have 'groups'

ifdef I386
    codeoffset	equ <offset FLAT:>
    dataoffset	equ <offset FLAT:>
else
    codeoffset	equ <offset @code:>
    dataoffset	equ <offset DGROUP:>
endif

; The next set of equates deals with the size of SHORTS, INTS, LONGS, and
; pointers in the 16 and 32 bit versions.

ifdef I386	 ;--- 32 bit segment ---

    ; parameters and locals
    IWORD   equ <dword>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dd>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc.
    ISIZE   equ 4
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 4
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 2		; byte-to-int shift count
    LSHIFT  equ 2		; byte-to-long shift count

    ; sizes dependent upon memory model.  dq -vs- df is not yet clear
    DNPTR equ <dd>		; near pointer
    DFPTR equ <dd>		; far pointer

    DCPTR   equ <dd offset FLAT:>; 32 bit offset only
    DCPTR?  equ <dd>		; No seg override for uninitialized values
    CPSIZE  equ 4
    CPDIST  equ <near>		; code pointers are near
    CPTR    equ <near ptr>

    DDPTR   equ <dd offset FLAT:>
    DDPTR?  equ <dd>
    DPSIZE  equ 4

    CPWORD  equ <dword> 	; code pointers are dwords
    DPWORD  equ <dword> 	; data pointers are dwords

    APIDIST equ <near>		; all API calls are NEAR in the 32 bit model

; macro to declare API functions
EXTAPI	macro	apiname
	extrn pascal apiname:near
endm

else	;--- 16-bit segment ---

    ; parameters and locals
    IWORD   equ <word>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dw>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc
    ISIZE   equ 2
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 2
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 1		; byte-to-int shift count
    LSHIFT  equ 2		; byte-to-long shift count

    ; sizes dependent upon memory model
    DNPTR equ <dw>		; near pointer
    DFPTR equ <dd>		; far pointer

    if sizeC
	DCPTR	equ <dd>       ; 16 bit segment and 16 bit offset
	DCPTR?	equ <dd>
	CPSIZE	equ 4
	CPDIST	equ <far>      ; code pointers are far
	CPTR	equ <far ptr>
	CPWORD	equ <dword>    ; code pointers are dwords
    else
	DCPTR	equ <dw>       ; 16 bit offset only
	DCPTR?	equ <dw>
	CPSIZE	equ 2
	CPDIST	equ <near>     ; code pointers are near
	CPTR	equ <near ptr>
	CPWORD	equ <word>     ; code pointers are words
    endif

    if sizeD
	DDPTR	equ <dd>
	DDPTR?	equ <dd>
	DPSIZE	equ 4
	DPWORD	equ <dword>    ; data pointers are dwords
    else
	DDPTR	equ <dw>
	DDPTR?	equ <dw>
	DPSIZE	equ 2
	DPWORD	equ <word>     ; data pointers are words
    endif

    APIDIST equ <far>		; API calls are FAR in 16 bit model

; macro to declare API functions
EXTAPI	macro	apiname
	extrn pascal apiname:far
endm

endif	; --- 16/32 segment ---

; Float/double definitions
; (currently the same for 16- and 32-bit segments)

FLTSIZE  equ	4	; float
DBLSIZE  equ	8	; double
LDBLSIZE equ	10	; long double

DFLOAT	 equ	<dd>
DDOUBLE  equ	<dq>
DLDOUBLE equ	<dt>

;
; savelist - Generate a list of regs to be saved by the proc 'uses' option.
;
; Input:
;	reg1, reg2, reg3, reg4 = registers to be saved across function
; Output:
;	reglist = text string of registers that can be passed to the 'uses'
;	option on the 'proc' command.
;

savelist  MACRO   reg1, reg2, reg3, reg4
	local	ws, listsize
	ws	catstr	< >		; whitespace char

	IFNDEF	I386
	 rbx equ <>			; 8086/286 don't save rbx
	ENDIF

	IFNB	    <reg4>
	 reglist     catstr  reg1, ws, reg2, ws, reg3, ws, reg4
	ELSEIFNB    <reg3>
	 reglist     catstr  reg1, ws, reg2, ws, reg3, ws
	ELSEIFNB    <reg2>
	 reglist     catstr  reg1, ws, reg2, ws,       ws
	ELSEIFNB    <reg1>
	 reglist     catstr  reg1, ws,	     ws,       ws
	ELSE
	 reglist     catstr  <>
	ENDIF

	listsize sizestr reglist	; size of register list

	IF	listsize LE 3		; if list is only the 3 ws chars...
	 reglist catstr  <>
	ENDIF

	IFNDEF	I386
	 rbx equ <bx>			; restore rbx
	ENDIF

	ENDM	; savelist

;
; codeseg - Define/declare the standard code segment. Maps to the proper
; form of the .code directive.
;
; Input:
;
; Output:
;	.code _TEXT	; for large code models
;	.code		; for small code models
;	assume	cs:FLAT ; for 386
;	assume	ds:FLAT ; for 386
;	assume	es:FLAT ; for 386
;	assume	ss:FLAT ; for 386
;

codeseg MACRO

if	sizeC
	.code _TEXT
else
	.code
endif

ifdef	I386
	assume	ds:FLAT
	assume	es:FLAT
	assume	ss:FLAT
endif

	ENDM

;*========
;*
;*  Debug lab macro
;*
;*========

lab	macro name
ifdef	DEBUG
    public  pascal name	    ;; define label public for Symdeb
endif
name:
	endm


;*========
;*
;*  Conditional jump short macros
;*
;*========


	irp	x,<Z,NZ,E,NE,S,NS,C,NC,P,NP,PE,PO,A,AE,B,BE,NB,G,GE,L,LE>
JS&x	equ   <j&x short>
	endm


;*========
;*
;*  Global data definition macros
;*
;*  Usage:
;*	globalI   Name, InitialValue, Repeat
;*
;*========


MakeGlobal  macro   suffix, DataType	    ;; makes all of the global* macros

global&suffix  macro   name, data, rep
public	name
ifb	<rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name	&DataType  _repeat dup( data )
	endm

	endm


    MakeGlobal	T, dt			; globalT
    MakeGlobal	Q, dq			; globalQ
    MakeGlobal	D, dd			; globalD
    MakeGlobal	W, dw			; globalW
    MakeGlobal	B, db			; globalB

%   MakeGlobal	I, <DINT>		; globalI

%   MakeGlobal	DP, <DDPTR>		; globalDP
%   MakeGlobal	CP, <DCPTR>		; globalCP
%   MakeGlobal	FP, <DFPTR>		; globalFP
%   MakeGlobal	NP, <DNPTR>		; globalNP



;*========
;*
;*  Static data definition macros
;*
;*  Usage:
;*	staticI   Name, InitialValue, Repeat
;*
;*========


MakeStatic  macro   suffix, DataType	    ;; makes all of the static* macros

static&suffix  macro   name, data, rep

ifdef  DEBUG
    public  pascal name			    ;; make statics public if DEBUG
endif

ifb	<rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name	&DataType  _repeat dup( data )
	endm

	endm


    MakeStatic	T, dt			; staticT
    MakeStatic	Q, dq			; staticQ
    MakeStatic	D, dd			; staticD
    MakeStatic	W, dw			; staticW
    MakeStatic	B, db			; staticB

%   MakeStatic	I, <DINT>		; staticI

%   MakeStatic	DP, <DDPTR>		; staticDP
%   MakeStatic	CP, <DCPTR>		; staticCP
%   MakeStatic	FP, <DFPTR>		; staticFP
%   MakeStatic	NP, <DNPTR>		; staticNP

;*========
;*
;*  Label definition macros
;*
;*========
;*
;*  Label definition macros
;*
;*  Usage:
;*	labelI	 Name, {PUBLIC, PASCAL, C}
;*
;*========

__MakePublic	macro	name, option	;; decides if a label should be
ifidni	<option>, <PUBLIC>		;; made public
    public  name
elseifidni  <option>, <PASCAL>
    public  pascal name
elseifidni  <option>, <C>
    public  C name
elseifb  <option>
    ifdef  DEBUG
	public	pascal name	;; make public if DEBUG
    endif
endif
		endm


MakeLabel   macro suffix, LabelType	;; makes all of the label* macros

%@CatStr(<label>,<suffix>)	macro	name, option
	__MakePublic	<name>,<option>
name	label	&LabelType
	endm

	endm


	MakeLabel   T, tbyte	; make labelT
	MakeLabel   Q, qword	; make labelQ
	MakeLabel   D, dword	; make labelD
	MakeLabel   W, word	; make labelW
	MakeLabel   B, byte	; make labelB

	MakeLabel   P, proc	; make labelP
	MakeLabel   FP, far	; make labelFP
	MakeLabel   NP, near	; make labelNP

%	MakeLabel   I, IWORD	; make labelI


labelDP macro	name, option		    ;; labelDP
	__MakePublic	<name>,<option>
ifdef  I386
    if sizeD
	name	label	fword
    else
	name	label	dword
    endif
else	;not I386
    if sizeD
	name	label	dword
    else
	name	label	word
    endif
endif	;not I386
	endm

labelCP macro	name, option		    ;; labelCP
	__MakePublic	<name>,<option>
ifdef  I386
    if sizeC
	name	label	fword
    else
	name	label	dword
    endif
else	;not I386
    if sizeC
	name	label	dword
    else
	name	label	word
    endif
endif	;not I386
	endm


;*
;*  PUSH16 SegReg   - pushes 16 bits in a use32 segment
;*

PUSH16	macro	SegReg

ifdef I386
	nop
	db	66h	    ; operand size over-ride
endif	; I386

	push	SegReg
	endm


;*
;*  JMPFAR16  label - jmps far from a use32 to a use16 segment
;*

JMPFAR16 macro	label

ifndef I386
	error  <JMPFAR16 can only be used in a use32 code segment>
endif	;I386

	nop
	db	66h	    ;; operand size over-ride
	db	0eah	    ;; jmp far immediate op code
	dw	offset label
	dw	seg label
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\cmacros.inc ===
comment $

	SCCSID = "@(#)cmacros.mas:1.12"

cmacros - assembly macros for interfacing to hhls

Copyright (C) 1984-2001, Microsoft Corporation. All rights reserved.

$

;; Revision History
;;
;;	1.00	05/03/84	Initial Release
;;
;;	1.01	05/06/84	Greg Whitten
;;				Added defgrp and changed cMerge to Microsoft C
;;				Added copyright message and changed to 1.01
;;				Changes should have no affect on working programs
;;
;;	1.02	07/10/84	Steve Wood
;;				Added labelx macros
;;
;;	1.03	07/14/84	Greg Whitten
;;				Added defines for ?pu, ?adj, ?lblpu
;;				  (removes undefined errors)
;;				Changes should have no affect on working programs
;;
;;	1.04	07/18/84	Greg Whitten
;;				Added local control from PL/M or C conventions
;;				  except for cCall macro
;;
;;	1.05	08/06/84	Steve Wood
;;				Made ?PLM and ?WIN be the defaults
;;
;;	1.06	01/02/85	Steve Wood
;;				Changed createSeg and defgrp to automatically
;;				  define the ln_assumes macro and the lnoffset
;;				  and lnbase equates for each logical segment
;;				  name.
;;
;;	1.07	02/19/85	Walt Moore
;;				Added farptr macro for defining a far pointer
;;				to be used in a cCall.	Folded regptr into
;;				farptr.  Space compaction in macros.  Changed
;;				?pp to be smaller.  Moved ?ia out of ?al1 into
;;				?aloc.	Merged cProc and ?pd into one macro.
;;				Changed some %outs to use the error macro so
;;				an error would be generated.  Added makeframe
;;				and parmR to cProc.  Changed error to also put
;;                              the error message in the listing.
;;				Deleted the smashes macro.
;;
;;	1.08	03/18/85	Steve Wood
;;				Added NODATA support.
;;
;;	1.09	03/27/85	Steve Wood
;;				Added ?definitions
;;
;;	2.00	04/01/85	Steve Wood
;;				April fools
;;
;;	2.01	06/17/85	Steve Wood
;;				Changed NODATA to always generate POP DS
;;				  for return address patching
;;
;;	2.02	02/11/86	Steve Wood
;;				Added ATOMIC keyword to cProc macro
;;				Changed far epilog to use LEA SP,BP-2
;;				Changed error macro to ??error to avoid
;;				  conflict
;;
;;	2.03	03/06/86	Steve Wood
;;				Fixed bug with ATOMIC and locals in far proc
;;				Added DOS5 switch to disable INC/DEC BP
;;				  instructions in special far prologs/epilogs
;;
;;	2.04	08/07/86	Scott Randell
;;				Fixed bug with ATOMIC and ?TF
;;				  (was doing unnecessary MOV SP,BP)
;;				Added pcode profile ?PROFILE
;;
;;	2.05	08/12/86	Walt Moore
;;				Changed _TEXT alignment to word.
;;				Added/corrected some comments.
;;				Removed redundant init of ?pc in cProc
;;				Made ATOMIC require NODATA
;;				Moved definition of non-underscored 'C' label
;;				  from the cProc to the cBegin macro
;;				Minor clean-up of code
;;
;;	2.06	09/11/86	Walt Moore
;;				Added private stack checking
;;				Put local control for PL/M or C into cCall
;;
;;
;;	2.07	09/19/86	Steve Wood
;;				Added ?SMALL, ?MEDIUM, etc.  symbols
;;				Added forceframe keyword to cProc macro.
;;				Interpret ?TF for all epilogs.
;;
;;	3.xx.a	02/26/87	Walt Moore
;;				Massive rework.  Documentation coming.
;;
;;	3.xx.b	04/08/87	NeilK
;;				Added parmH, which is like parmW except
;;				that it reserves 4 bytes on frame.
;;
;;	3.xx.c	05/11/87	Walt Moore
;;				Added <> to ?ap so that arg <DataOFFSET foo>
;;				can be used.
;;
;;	3.01	07/03/87	Walt Moore
;;				parm_bytes_&procname is now generated for
;;				all cProcs, and is the number of bytes of
;;				parameters to the cProc.
;;
;;				NO_BP added as a keyword to cProc which
;;				causes all equates to be generated without
;;				reference to BP for the procedure.  All type
;;				info is still generated, but the user must
;;				supply any segment and base register.
;;				?NO_BP, if defined, makes this the default.
;;
;;				USE_BP can be specified on the cProc line
;;				to force the generation of BP in equates.
;;
;;				Moved definition of xxxxBASE.  The equ was to
;;				a forward reference.
;;
;;				Don't generate a warning for a nogen if only
;;				parameters are present.
;;
;;				Keywords for cProc, cBegin, cEnd, and registers
;;				are now allowed to be either all upper case or
;;				all lower case.
;;
;;				Only generate warnings on pass 2.
;;
;;	3.02	07/06/87	Walt Moore
;;				Boy did I mess up <nogen>  If the text is
;;				recognized as nogen, then process it as such,
;;				else ignore it and generate frame as needed.
;;
;;	3.03	07/14/87	Walt Moore
;;				Added <partial> keyword to the cBegin macro
;;				to only allocate locals and save registers.
;;				Used in conjunction with dispatching in the
;;				Winthorn engine and drivers.
;;
;;				Added cleanframe macro which will take the
;;				frame down, but not generate the RET statement.
;;				Used in conjunction with dispatching in the
;;				Winthorn engine and drivers.
;;
;;	3.04	07/16/87	Walt Moore
;;				globalD was generating off and seg name
;;				without word ptr override, giving them a
;;				dword attribute
;;
;;	3.05	07/17/87	Walt Moore
;;				.xcref cleanframe
;;
;;	3.06    07/24/87	Hans Spiller
;;				32 bit small model (?SMALL32):
;;				  new entry exit sequences using pseudoregs
;;				  mach independant register names (IAX, etc)
;;				  parmI/localI (int size variables)
;;				  mpush/mpop uses mach independant names
;;				  IPUSHF, IPOPF, IPUSHA,IPOPA,IIRET
;;				  
;;				case sensitivity bugfix. the compiler
;;				  generates "CODE", not "Code"
;;
;;				32 bit issues as yet undone:  allocation
;;			        macros for dealing with 32 bit mode far
;;				pointers, globalI, staticI, parmR, saving
;;				si,di vs. esi,edi,ebx
;;
;;	3.06a   09/29/87	Mark Roberts
;;				32 bit small model (?SMALL32):
;;				  fix a few bugs and add staticI
;;
;;	3.06b	07/20/87	Scott Randell
;;				Fix up for ?COW compatibility, added ?NOATOMIC
;;				to 3.xx version.
;;
;;	3.06c	04/29/88	Jim Schaad
;;				Put in ?DFDATA to force data segments even if
;;				?NODATA is set.
;;
;;	3.06d	05/02/88	Andy Padawer
;;				Bug fixes for 3.06b (cEnd), 3.06c (general).
;;
;;	3.06e	08/31/88	Andy Padawer
;;				use "if memS32" not "ifdef ?SMALL32".
;;
;;	3.06f   05/12/89	Mark Roberts
;;			  	fix staticI, globalDP and add globalI
;;
;;	3.06g   12/07/89	Mark Roberts
;;			  	add externI
;;
;;	3.06h	01/25/90	Jan de Rie
;;				add ?DFCODE to allow suppressing code segments
;;
;; Assembly macros for interfacing to C
;;
;;      User settable conditional assembly flags used within the cmacros
;;
;;	Memory model flags.  Set only one of the following.  memS is the
;;	default.  The symbols with ? are for defining from the command line
;;      and the memx symbols are numeric symbols that can be set in your source
;;      file prior to including this file.
;;
;;	    ?SMALL   memS - small model
;;	    ?MEDIUM  memM - medium model
;;	    ?LARGE   memL - large model
;;	    ?COMPACT memC - compact model
;;	    ?HUGE    memH - huge model
;;	    ?SMALL32 memS32 - 32 bit small model
;;
;;	?DF	Define flag.  If this flag is 0, then defines default segment
;;		and group definitions based on the compiler flag.  If this
;;              flag is 1, then does not define any segments or groups.
;;
;;	?DFDATA Define Data Flag.  If this flag is 0, then defines default
;;		data segment and group definitions based on compiler flag.
;;		If this flag is 1, then does not define any data segments
;;		or groups.
;;
;;	?DFCODE Define Code Flag.  If this flag is 0, then defines default
;;		code segments based on the compiler flag.  If this flag is 1,
;;		then does not define the code segments.  Inactive if
;;		?DF is 1.
;;
;;	?TF	Tight flag.  If this flag is 0, then use longer epilog
;;		sequence that safely cleans up a stack frame.  If this flag is
;;              1, then use more efficient epilog that assumes the stack is
;;		valid (SP)
;;
;;	?WIN	Windows flag.  Enables generation of special prolog/epilog
;;		for far procedures.  Default value is 1 (Windows).
;;
;;	?COW	Character Windows flag.  To be used in conjunction with ?WIN,
;;		If defined will not save DS for ?NODATA far prolog/epilog
;;		(CW does not modify the DS on the stack).
;;
;;	DOS5	If defined, then special far prolog/epilog seqeuences will not
;;		include the INC/DEC BP instructions.
;;
;;	?PLM	Calling convention flag.  If this flag is 0, then the
;;		calling convention used is that of C.  If this flag
;;		is 1, then the PL/M calling convention is used.
;;		The default value is 1.  The PL/M calling convention
;;		is used by pascal, fortran, basic, and cobol.
;;
;;		In the C calling convention, arguments are passed
;;              in reverse order; arg0 is the last pushed, argn is the
;;              first pushed.  also, it is the callers responsibility
;;              to remove the arguments from the stack upon a return
;;              from a call.
;;
;;		In the PL/M calling comvention, arguments are passed
;;              as encountered; arg0 is the first pushed, argn is the
;;              last pushed.  also, it is the called procedure's
;;              responsibility to remove parameters from the stack
;;		before returning (using the RET n instruction)
;;
;;	?NODATA If defined, then no data segment or DGROUP is defined and
;;              the special prolog/epilog sequences will not contain the
;;		code needed to setup DS.
;;
;;	?CHKSTK If defined, then prolog sequences for cProcs with local
;;		parameters will call the CHKSTK procedure to allocate
;;              the stack space.
;;
;;	?CHKSTKPROC	If defined, then this macro will be invoked to
;;                      perform the stack checking, otherwise the
;;                      standard stack checking procedure will be
;;			performed.  ?CHKSTKPROC must be declared
;;                      before the cmacros are included in the source
;;			else the standard chkstk routine will be declared
;;                      as an external symbol.
;;
;;			On entry to the user's stack checking procedure,
;;                      the frame has been setup except for allocating
;;                      local variable space and saving autosave registers.
;;
;;			The user supplied macro is passed as an argument
;;                      the number of byte of stack space requested.
;;
;;	?PROFILE  If defined then all far cBegin entries will have StartNMeas,
;;		  and all cEnd will have StopNMeas calls, StartNMeas and
;;		  StopNMeas will be defined as externfp
;;
;;	?NOPARMR  If defined, then the "parmR"	 macro	will not be defined.
;;
;;	?NOGLOBAL If defined, then the "globalx" macros will not be defined.
;;
;;	?NOSTATIC If defined, then the "staticx" macros will not be defined.
;;
;;	?NOEXTERN If defined, then the "externx" macros will not be defined.
;;
;;	?NOLABEL  If defined, then the "labelx"  macros will not be defined.
;;
;;	?NODEF	  If defined, then the "defx"	 macros will not be defined.
;;
;;	?NOPTR	  If defined, then "farptr & regptr"	will not be defined.
;;
;;	?QUIET	  If defined, then only error messages will be issued to
;;		  the console.	If undefined, then certain cmacro text will
;;		  be generated to the console.
;;
;;	?NOATOMIC If defined, then ATOMIC will be ignored (for giving real
;;		  frames to all procedures (and profiling).
;;
;;	?NO_BP	  If defined, then equates generated for parms and locals
;;		  will not explicitly reference BP.
;;	IAX, ICX, IDX, IBX, ISP, IBP, ISI, IDI
;;		  these pseudo registers expand to either ax..., or eax...
;;		  depending upon 32bit mode being enabled.  they should be
;;		  used whenever a pointer or integer is being used in order
;;		  to make source code machine independant



.xcref					;;Get rid of a lot of symbols


;	??_out	- output given message to the console unless ?QUIET has
;	been specified.
;
;	usage:
;		??_out	<t>
;
;	where:
;		<t> is the message to output

.xcref	??_out
??_out macro t
  ifndef ?QUIET
    %out t
  endif
endm



;	outif - output msg if name is non-zero.  if name is undefined,
;	set name = 0, else set name to the default value.
;
;	usage:
;		outif	name,defval,onmsg,offmsg
;	where:
;		name	name of symbol
;		defval	default value to give symbol if not defined
;			if blank, then 0 will be used
;		onmsg	text to display if symbol is non-zero
;		offmsg	test to be displayed if symbol is zero


outif macro name,defval,onmsg,offmsg
  ifndef name
    ifb <defval>
      name=0
    else
      name=defval
    endif
  endif
  if name
    name=1
    ifnb <onmsg>
      ??_out <! onmsg>
    endif
  else
    ifnb <offmsg>
      ??_out <! offmsg>
    endif
  endif
endm



;	??error - output msg and generate an assembly time error
;		  on regardess of assembler pass
;	usage:
;		??error <t>
;	where:
;		t	is the text to be output


.xcref	??error
??error macro	msg
  %out e r r o r ----- msg		;;to console
  .err e r r o r ----- msg		;;forced error by assembler
endm


;	??error2 - output msg and generate an assembly time error
;		   on pass 2 only
;	usage:
;		??error2 <t>
;	where:
;		t	is the text to be output


.xcref	??error2
??error2 macro	 msg
  if2
  %out e r r o r ----- msg		;;to console
  .err e r r o r ----- msg		;;forced error by assembler
  endif
endm


.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized,memS32,sizeI,wordI

;if1					;;Only on pass 1
  ASMpass=1
  ifdef ?SMALL				;;inform user what is going on
    memS=1
  endif
  ifdef ?MEDIUM
    memM=1
  endif
  ifdef ?COMPACT
    memC=1
  endif
  ifdef ?LARGE
    memL=1
  endif
  ifdef ?HUGE
    memH=1
  endif
  ifdef ?SMALL32
    memS32=1
  endif
  ifdef ?FLAT32
    memF32=1
  endif

  ??_out  <cMacros Version 3.06h - 01/25/90>
  ??_out  <Copyright (C) 1984-2001 Microsoft Corporation. All rights reserved.>
  outif   memS,0,<Small Model>
  outif   memM,0,<Medium model>
  outif   memL,0,<Large Model>
  outif   memC,0,<Compact Model>
  outif   memH,0,<Huge Model>
  outif	  memS32,0,<32 Bit Small Model>
  outif   memF32,0,<32 Bit Flat Model>

  memMOD= memS + memM + memL + memC + memH + memS32
  if memMOD ne 1
    if memMOD eq 0
      memS = 1				; assume small model
      outif   memS,0,<Small model>
    else
      ??error	<must have only 1 memory model selected>
    endif
  endif

  sizec=  memM + memL + memH		; large code
  sized=  memL + memC + (memH*2)	; large data (2 if huge)
  ;; note that memS32 is used generaly to indicate 32 bitness.  I
  ;; doubt very much whether anyone will ever do other models in
  ;; 32 bit code...
  if memS32
    sizeI = 4				; size of a push
    wordI equ <dword>
    asmdI equ <dd>
  else
    sizeI = 2
    wordI equ <word>
    asmdI equ <dw>
  endif

  outif ?DF,0,<No segments or groups will be defined>
  outif ?DFDATA,0,<No data segments will be defined>
  outif ?DFCODE,0,<No code segments will be defined>
  outif ?TF,0,<Epilog sequences assume valid SP>
  outif ?WIN,1,<Windows support>
  outif	?COW,0,<Characters Windows support>
  outif ?PLM,1,<PL/M calling convention>
  outif	?NOATOMIC,0,<ATOMIC disabled>
  outif ?NODATA,0,<NODATA module>

  ife ?NODATA
    ?nodata1=0
  else
    ?nodata1=1
  endif

  ifndef ?CHKSTK
    ?chkstk1=0
  else
    ?chkstk1=1
    ifdef ?CHKSTKPROC
      ??_out <! Private stack checking enabled>
    else
      ??_out <! Stack checking enabled>
    endif
  endif

  ifndef DOS5
    ?DOS5=0
  else
    ?DOS5=1
    ??_out <! DOS5 module>
  endif

  ifdef ?PROFILE
    ??_out <! Native profiling enabled>
  endif

  ifndef ?NO_BP
    ?no_bp1=0
  else
    ?no_bp1=1
    ??_out <! NO_BP is default>
  endif
;else
  ASMpass=2
;endif

;; define pseudo registers and instructions for 386/8086 independance
if memS32
  .386
  IAX equ <eax>
  ICX equ <ecx>
  IDX equ <edx>
  IBX equ <ebx>
  ISP equ <esp>
  IBP equ <ebp>
  ISI equ <esi>
  IDI equ <edi>
  IPUSHF equ pushfd
  IPOPF equ popfd
  IPUSHA equ pushad
  IPOPA equ popad
  IIRET equ iretd
else
  IAX equ <ax>
  ICX equ <cx>
  IDX equ <dx>
  IBX equ <bx>
  ISP equ <sp>
  IBP equ <bp>
  ISI equ <si>
  IDI equ <di>
  IPUSHF equ pushf
  IPOPF equ popf
;  IPUSHA equ pusha
;  IPOPA equ popa
  IIRET equ iret
endif

;;	Initialize all symbols used in the macros.  Theses symbols will not be
;;      included in any cross reference listing.

	.xcref	?n,?ax,?ah,?al,?bx,?bh
	.xcref	?bl,?cx,?ch,?cl,?dx,?dh
	.xcref	?dl,?si,?di,?es,?ds,?bp
	.xcref	?sp,?ss,?cs
	.xcref	?n,?AX,?AH,?AL,?BX,?BH
	.xcref	?BL,?CX,?CH,?CL,?DX,?DH
	.xcref	?DL,?SI,?DI,?ES,?DS,?BP
	.xcref	?SP,?SS,?CS
	.xcref  ?EAX,?EBX,?ECX,?EDX,?ESI,?EDI,?ESP,?EBP
	.xcref  ?eax,?ebx,?ecx,?edx,?esi,?edi,?esp,?ebp
	.xcref  ?IAX,?IBX,?ICX,?IDX,?ISI,?IDI,?ISP,?IBP

	.xcref	?rsl,?cpd,?argl,?argc,?ba
	.xcref	?acb,???,?po
	.xcref	?pas,?pc

	.xcref	uconcat,mpush,mpop
	.xcref	?ri,?pp,?pp1,?al1
	.xcref	?ad,?ap,?atal,?dd,?dd1,?dd2
	.xcref	?pg,?pg1,?aloc,?cs1,?cs2
	.xcref	?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
	.xcref	?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
	.xcref	?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
	.xcref	defgrp,addseg,createSeg
	.xcref	save,outif,errnz,errn$,errnz1
	.xcref	?PLMPrevParm,?gcc
	.xcref	?cCall1,?pcc,?no_bp1,?no_bp2
	.xcref	?cbe,?pcbe



;;      conditionals set by the macros
;;
;;	?pc	Procedure class.  If this is set to 1, then the procedure
;;              is a far procedure, else it is a near procedure.
;;
;;	?ia	Interface adjustment count for far procedures.	The
;;              interface adjustment defines the number of bytes of
;;		storage allocated between BP and the first frame variable
;;              allocated on the stack.
;;
;;		Normally zero, it will be adjusted for both far windows
;;              procedures and by register parameters.
;;
;;	?cpd	Current procedure defined.  This is set to a non-zero
;;		value if a procedure is being defined (i.e a cProc has
;;		been encountered, and cBegin has not).
;;
;;	?ba	Begin active.  This is set to a non-zero value if a
;;		cBegin is active (i.e. a cBegin has been encountered,
;;		and cEnd has not).
;;
;;	?wfp	Windows far procedure.	Set if a windows far procedure
;;
;;	?pcc	procedure calling conventing.  Calling convention for
;;		this procedure.  May be different than the default set
;;		via ?PLM
;;
;;
;;	Other variables that are defined once so that the .xcref command
;;      doesn't get too upset if they show up missing!

?rsl    =       0                       ;;0 = no register to save
?cpd    =       0                       ;;<> 0 if in a procedure definition
?argl   =       0                       ;;length of arguments pushed on stack
?argc   =       0                       ;;# of arguments so far
?ba     =       0                       ;;<>0 if in a procedure (xbegin)
?acb    =       0                       ;;number of arguments to a call
???     =       0                       ;;byte count of local storage
?po     =       0                       ;;byte count of parameters
?pas    =       0                       ;;autosave value for procedure
?pc     =       0                       ;;class of a procedure (near/far)
?ia     =       0                       ;;no adjustment
?pu     =       0                       ;;public flag for some macros
?adj    =       0                       ;;initial define for .xcref
?rp     =       0                       ;;count of register parameters
?uf     =       0                       ;;user's frame code specified
?nd	=	0			;;NODATA keyword specified
?nx	=	0			;;ATOMIC keyword specified
?wfp    =       0                       ;;window far procedure
?ff     =       0                       ;;forceframe keyword specified
?dd2	=	0			;;used for globalx and staticx
?cCall1 =	0			;;used for cCalls
?pcc	=	?PLM			;;procedure calling convention
?PLMPrevParm =	0			;;Used in parameter processing
?no_bp2 =	?no_bp1 		;;BP / No BP flag
?cbe	=	0			;;cbegin/cEnd keyword flag

	.xcref	?casen
if1					;;only define ?casen on pass 1
?casen	=	0			;;case sensitive assembly if <> 0
endif



?n      =       0000000000000000b       ;;register none
?ax	=	0000000000000011b	;;register ax
?ah	=	0000000000000001b	;;register ah
?al	=	0000000000000010b	;;register al
?bx	=	0000000000001100b	;;register bx
?bh	=	0000000000000100b	;;register bh
?bl	=	0000000000001000b	;;register bl
?cx	=	0000000000110000b	;;register cx
?ch	=	0000000000010000b	;;register ch
?cl	=	0000000000100000b	;;register cl
?dx	=	0000000011000000b	;;register dx
?dh	=	0000000001000000b	;;register dh
?dl	=	0000000010000000b	;;register dl
?si	=	0000000100000000b	;;register si
?di	=	0000001000000000b	;;register di
?es	=	0000010000000000b	;;register es
?ds	=	0000100000000000b	;;register ds
?bp	=	0001000000000000b	;;register bp
?sp	=	0010000000000000b	;;register sp
?ss	=	0100000000000000b	;;register ss
?cs	=	1000000000000000b	;;register cs
					;;Incase we're case sensitive
?AX	=	0000000000000011b	;;register ax
?AH	=	0000000000000001b	;;register ah
?AL	=	0000000000000010b	;;register al
?BX	=	0000000000001100b	;;register bx
?BH	=	0000000000000100b	;;register bh
?BL	=	0000000000001000b	;;register bl
?CX	=	0000000000110000b	;;register cx
?CH	=	0000000000010000b	;;register ch
?CL	=	0000000000100000b	;;register cl
?DX	=	0000000011000000b	;;register dx
?DH	=	0000000001000000b	;;register dh
?DL	=	0000000010000000b	;;register dl
?SI	=	0000000100000000b	;;register si
?DI	=	0000001000000000b	;;register di
?ES	=	0000010000000000b	;;register es
?DS	=	0000100000000000b	;;register ds
?BP	=	0001000000000000b	;;register bp
?SP	=	0010000000000000b	;;register sp
?SS	=	0100000000000000b	;;register ss
?CS	=	1000000000000000b	;;register cs

?EAX	=	0000000000000011b	;;register ax
?EBX	=	0000000000001100b	;;register bx
?ECX	=	0000000000110000b	;;register cx
?EDX	=	0000000011000000b	;;register dx
?ESI	=	0000000100000000b	;;register si
?EDI	=	0000001000000000b	;;register di
?EBP	=	0001000000000000b	;;register bp
?ESP	=	0010000000000000b	;;register sp

?eax	=	0000000000000011b	;;register ax
?ebx	=	0000000000001100b	;;register bx
?ecx	=	0000000000110000b	;;register cx
?edx	=	0000000011000000b	;;register dx
?esi	=	0000000100000000b	;;register si
?edi	=	0000001000000000b	;;register di
?ebp	=	0001000000000000b	;;register bp
?esp	=	0010000000000000b	;;register sp

?IAX	=	0000000000000011b	;;register ax
?IBX	=	0000000000001100b	;;register bx
?ICX	=	0000000000110000b	;;register cx
?IDX	=	0000000011000000b	;;register dx
?ISI	=	0000000100000000b	;;register si
?IDI	=	0000001000000000b	;;register di
?IBP	=	0001000000000000b	;;register bp
?ISP	=	0010000000000000b	;;register sp

        .cref



;;      uconcat - unconditionally generate a statement from a field
;;      of given parameters
;;
;;      usage:
;;		uconcat  a,b,c,d,e,f,g
;;
;;      where:
;;              a,b   are concatenated for field 1
;;              c,d   are concatenated for field 2
;;		e,f,g are concatenated for field 3

uconcat macro a,b,c,d,e,f,g
  a&b c&d e&f&g
endm



;;      mpush pushes multiple registers onto the stack according to
;;      a register specification.
;;
;;      format:
;;              mpush   r
;;
;;      where:
;;              r       is a numeric expression returned from ?ri
;;                      or any other valid register expression

mpush macro r
  irp x,<IAX,IBX,ICX,IDX,ISI,IDI,es,ds,IBP,ISP,ss,cs>
    if (r and ?&&x)
      push x								      ;@
    endif
  endm
endm



;;      mpop pops multiple registers from the stack according to
;;      a register specification.
;;
;;      format:
;;              mpop    r
;;
;;      where:
;;              r       is a numeric expression returned from ?ri
;;                      or any other valid register expression

mpop macro r
  irp x,<cs,ss,ISP,IBP,ds,es,IDI,ISI,IDX,ICX,IBX,IAX>
    if (r and ?&&x)
      pop x								      ;@
    endif
  endm
endm


;;      save - flag that the indicated registers are to be saved/restored
;;
;;	A flag is created which indicates which registers are to be saved
;;	when the cCall macro is invoked, and then restored after the call.
;;
;;      usage:
;;              save    <r>
;;
;;      where  r  is the list of registers to save, which may be:
;;
;;		register     saves
;;		   AX	      AX
;;		   AH	      AX
;;		   AL	      AX
;;		   BX	      BX
;;		   BH	      BX
;;		   BL	      BX
;;		   CX	      CX
;;		   CH	      CX
;;		   CL	      CX
;;		   DX	      DX
;;		   DH	      DX
;;		   DL	      DX
;;		   SI	      SI
;;		   DI	      DI
;;		   ES	      ES
;;		   DS	      DS
;;		   BP	      BP
;;
;;		  none	    nothing
;;
;;      the macro generates a value for the variable ?rsl

save macro r
  ?rsl=0				;;initialize save list
  ?ri ?rsl,<r>				;;generate magic number
endm



;;      ?ri - or register indexes to variable
;;
;;      ?ri is a macro that examines the passed argument list and computes
;;      a register index variable.
;;
;;	The values ORed with the variable are:
;;
;;              ?n       equ     0000000000000000b;
;;		?AX	 equ	 0000000000000011b;
;;		?AH	 equ	 0000000000000001b;
;;		?AL	 equ	 0000000000000010b;
;;		?BX	 equ	 0000000000001100b;
;;		?BH	 equ	 0000000000000100b;
;;		?BL	 equ	 0000000000001000b;
;;		?CX	 equ	 0000000000110000b;
;;		?CH	 equ	 0000000000010000b;
;;		?CL	 equ	 0000000000100000b;
;;		?DX	 equ	 0000000011000000b;
;;		?DH	 equ	 0000000001000000b;
;;		?DL	 equ	 0000000010000000b;
;;		?SI	 equ	 0000000100000000b;
;;		?DI	 equ	 0000001000000000b;
;;		?ES	 equ	 0000010000000000b;
;;		?DS	 equ	 0000100000000000b;
;;		?BP	 equ	 0001000000000000b;
;;		?SP	 equ	 0010000000000000b;
;;		?SS	 equ	 0100000000000000b;
;;		?CS	 equ	 1000000000000000b;
;;      usage:
;;		?ri n,<rl>
;s mach independant names;      where:
;;              n       is the variable to contain the new index value
;;		r	is the register list

?ri macro n,r
  irp x,<r>
    ifdef ?&&x				;;if defined, then add to list
      n=n or ?&&x
    else
      ??error2 <unknown register x>
      .err
    endif
  endm
endm



;;      parmx - generate reference to parameter(s) on the stack
;;
;;	An equate is generated for addressing a paramter(s)
;;      on the stack for the current procedural frame.
;;
;;	An error message is generated if there isn't a current frame.
;;
;;      usage:
;;              parmX   n
;;      where:
;;              X       is the type of the argument(s)  B=byte, W=word, D=dword
;;			I = machine independant int size
;;              n       is the name(s) to be given the parameter(s).
;;
;;	Bytes are considered to be two bytes long for alignment.
;;
;;	The parmd form of the macro generates three equates:
;;
;;              name       -    for accessing the parameter as a double word
;;              off_name   -    for accessing the offset  (lsw) of the parameter
;;              seg_name   -    for accessing the segment (msw) of the parameter

.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP,parmH,parmI
.cref

parmB macro n
  ?pp <n>,<byte>,sizeI,1
endm

parmW macro n
  ?pp <n>,<word>,sizeI,2
endm

parmI macro n
  ?pp <n>,wordI,sizeI,sizeI
endm

parmD macro n
  ife ?pcc				;;if to assemble for C
    irp x,<n>
      ?pp <&&x>,<dword>,0,4
      ?pp <off_&&x>,<word>,2,2
      ?pp <seg_&&x>,<word>,2,2
    endm
  else					;;if to assemble for PL/M
    irp x,<n>
      ?pp <seg_&&x>,<word>,2,2
      ?pp <off_&&x>,<word>,2,2
      ?pp <&&x>,<dword>,0,4
    endm
  endif
endm

parmH macro n
  ?pp <n>,<word>,4,2
endm

parmQ macro n
  ?pp <n>,<qword>,8,8
endm

parmT macro n
  ?pp <n>,<tbyte>,10,10
endm

if sizec
  parmCP macro n
    parmD <n>
  endm
else
  parmCP macro n
    parmW <n>
  endm
endif

if sized
  parmDP macro n
    parmD <n>
  endm
else
  parmDP macro n
    parmI <n>
  endm
endif



;;      ?pp is the generalized parameter definition macro
;;
;;      usage:
;;              ?pp m,t,l,s
;;
;;      where:
;;              n       is the name(s) of the parameters
;;              t       is the type (word, dword)
;;              l       is the length to update parameter byte count by
;;              s       is the internal typing size


?pp macro n,t,l,s			;;process parameter
  if ?cpd				;;must be in a procedure definition
    .xcref
    irp x,<n>
      .xcref ?t&&x			;;don't want this in xref
      ?t&&x=s				;;save size info
      ife ?pcc				;;if C calling convention
	?pp1 x,<t>,,,%(?po+?adj)
	?po=?po+l			;;update parameter offset
      else				;;else assemble for PL/M
	?PLMPrevParm=?PLMPrevParm+1	;;Show next parameter
	?po=?po+l			;;update parameter offset
	?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
      endif
    endm
    .cref
  else
    ??error2 <parm(s) "&n" declared outside proc def>
  endif
endm



;;	?pp1 is the macro that generates the text equate for the
;;	parameter.  Two options exist, one for the C calling
;;      convention where the last parameter was the first pushed onto
;;	the stack ('C' convention), and one for the PL/M calling
;;      convention where the first parameter was the first
;;      pushed (also the same as ms-pascal).
;;
;;	The text generated will be of one of two forms:
;;
;;		name equ (type ptr [bp+(adj+offset)]) for C
;;           or
;;		name equ (type ptr [bp+adj+?po-offset]) for PL/M
;;
;;
;;	For C, since parameters are pushed first last, the offset
;;      plus the adjust will point to the correct parameter.
;;
;;	For PL/M, since parameters are pushed first first, the offset
;;	of a parameter is much more complicated.  A known portion of
;;      the offset can be computed when the text equate is generated.
;;
;;	What is known is the number of garbage bytes between BP and
;;      the nearest parameter (in this case the last parameter), and
;;      also how many bytes of parameters have preceeded this parameter.
;;
;;	What is unknown is how many total bytes of parameters there will
;;      be, which affects all the generated text equates since the offset
;;      from bp must be determined at some point.
;;
;;	Well, the offset from BP can be computed with one variable if
;;      the following is remembered:
;;
;;          the offset of any parameter from the first parameter is always
;;          the current parameter offset (?po).
;;
;;	With this in mind, you just have to figure out where the first
;;      parameter is, which is:
;;
;;              bp + garbage adjustment + distance to first parameter
;;         or
;;              bp + ?adj + ?po
;;
;;	This implies that any parameter can be defined as:
;;
;;              bp + ?adj + ?po -%?po
;;
;;	Make any sense?
;;
;;	For PL/M, a chain of self-purging macros will be generated
;;	which will pass the evaluated ?po to any previous incarnation
;;	of the macro.  This will allow the text equate to be generated
;;	with the actual offset instead of the symbolic ?po.
;;
;;
;;      usage:
;;		?pp1	n,t,o,a,b,cpc,ppc
;;
;;      where:
;;              n    is the name to be given the equate
;;              t    is the type (byte, word, dword)
;;              o    is the offset from the first parameter
;;              a    is the adjustment
;;              b    is the adjustment plus the offset from the first parameter
;;		cpc  is the number of parameters so far
;;		ppc  is cpc - 1


?pp1 macro n,t,o,a,b,cpc,ppc
  ife ?pcc				;;if to generate for C
    if ?no_bp2
      n equ (t ptr [+b])
    else
      n equ (t ptr [IBP][+b])
    endif
  else					;;else generate for PL/M
    .xcref
    .xcref ?PLMParm&cpc
    .cref
    if ?no_bp2
      ?PLMParm&cpc &macro po
	uconcat <n>,,<equ>,,<(t ptr [+>,%(a+po-o),<])>
	?PLMParm&ppc po
	purge ?PLMParm&cpc
      &endm
    else
      ?PLMParm&cpc &macro po
	uconcat <n>,,<equ>,,<(t ptr [IBP][+>,%(a+po-o),<])>
	?PLMParm&ppc po
	purge ?PLMParm&cpc
      &endm
    endif
  endif
endm



;;	parmR - register parameter
;;
;;	parmR is the macro used for generating register parameters.
;;	The space allocated for the register parameters will be
;;      the ?ia (interface adjust) area which is between the  old
;;	BP and the first parameter.  Normally this is empty (?ia=0),
;;      or has the saved ds for a windows far procedure.
;;
;;	Byte and dword register parameters will be allowed.
;;
;;      usage:
;;		parmR	n,r,r2
;;      where:
;;              n       is the name of the parameter
;;              r       is the register it is in
;;              r2      is the offset register if a dword


ifndef ?NOPARMR
  .xcref
  .xcref ?pr,parmR
  .cref

  parmR macro n,r,r2
    ?pr n,r,r2,%?rp,%(?ia+2)
  endm

  ;;	?pr - register parameter
  ;;
  ;;	?pr is the actual macro for generating the equates for
  ;;	register parameters.
  ;;
  ;;	usage:
  ;;		parmR	n,r,r2,i,o
  ;;	where:
  ;;		n	is the name of the parameter
  ;;		r	is the register it is in
  ;;		r2	is the offset register if a dword
  ;;		i	is the index of the ?rp to generate
  ;;		o	is the offset from bp where the parm will be

  ?pr macro n,r,r2,i,o
    .xcref
    ifnb <r2>				;;if a dword parameter
      parmR seg_&n,r			;;define segment equate
      parmR off_&n,r2			;;define offset  equate
      if ?no_bp2
	n equ (dword ptr [-o-2])	;;define dword equate
      else
	n equ (dword ptr [bp][-o-2])	;;define dword equate
      endif
      .xcref ?t&n
      ?t&n=4				;;show a dword to cmacros
    else
      .xcref ?rp&i
      ?rp&i=0				;;show no register(s)
      ifdef ?&r 			;;define register if valid
	?rp&i=?&r
      endif

      if ??? or (?cpd eq 0) or (?rp&i eq 0)
	??error2 <invalid parmR encountered: &n,&r>
	exitm
      endif

      if ?no_bp2
	n equ (word ptr [-o])		;;assume a word register
      else
	n equ (word ptr [bp][-o])	;;assume a word register
      endif
      .xcref ?t&n
      ?t&n=2				;;show a word to cmacros
      irp x,<bh,ch,dh,bl,cl,dl,ah,al>
	if ?&&x eq ?&r			;;if really a byte register
	  if ?no_bp2
	    n equ (byte ptr [-o])	;;  then make it a byte
	  else
	    n equ (byte ptr [bp][-o])	;;  then make it a byte
	  endif
	  ?t&n=1			;;show a byte to cmacros
	  exitm
	endif
      endm
      ?ia=?ia+2 			;;show this guy is out there
      ?rp=?rp+1 			;;show one more register parameter
    endif
    .cref
  endm
endif



;;      localx - generate reference to a local variable on the stack
;;
;;	An equate is generated for addressing a local variable
;;      on the stack for the current procedural frame.
;;
;;      usage:
;;              localx    n
;;      where:
;;              x       is the type b=byte, w=word, d=dword, v=variable size
;;              n       is the name(s) to be given the variable(s).
;;
;;	Bytes are considered to be two bytes long for alignment reasons
;;
;;	The locald form of the macro generates three equates:
;;
;;              name       -    for accessing the variable as a double word
;;              off_name   -    for accessing the offset  (lsw) of the variable
;;              seg_name   -    for accessing the segment (msw) of the variable


.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV,localI
.cref

localB macro n
  ?aloc <n>,<byte ptr>,1,1,0		;; no alignment
endm

localW macro n
  ?aloc <n>,<word ptr>,2,2,1		;; word aligned
endm

localI macro n
  ?aloc <n>,&wordI&< ptr>,sizeI,sizeI,1	;; dword aligned
endm

localD macro n
  irp x,<n>
    ?aloc <seg_&&x>,<word ptr>,2,2,1	;; word aligned
    ?aloc <off_&&x>,<word ptr>,2,2,1	;; word aligned
    ?aloc <&&x>,<dword ptr>,0,4,1	;; word aligned
  endm
endm

localQ macro n
  ?aloc <n>,<qword ptr>,8,8,1		;; word aligned
endm

localT macro n
  ?aloc <n>,<tbyte ptr>,10,10,1 	;; word aligned
endm

if sizec
  localCP macro n
    localD <n>
  endm
else
  localCP macro n
    localW <n>
  endm
endif

if sized
  localDP macro n
    localD <n>
  endm
else
  localDP macro n
    localI <n>
  endm
endif

localV macro n,a
  ?aloc <n>,,%(a),0,1			;; word aligned
endm


;;      ?aloc is the macro that actually allocates local storage.
;;      it is only invoked by the localx macros.
;;
;;      usage:
;;              ?aloc  n,t,l,s,a
;;      where:
;;              n      is a list of names of local variable of the
;;                      given type.
;;              t       is the text string for the given variable
;;                      and is one of:
;;                          word  ptr
;;                          dword ptr
;;                          byte  ptr
;;                      or alternatively left blank for variable size
;;                      allocations (no implicit type).
;;              l       is the size of the variable in bytes
;;              s       is the internal type flag (size), and is one of:
;;                              word     - 2
;;                              dword    - 4
;;                              byte     - 1
;;                              variable - 0
;;              a       is a flag indicating that word alignment is to be
;;                      forced for this type of item.
;;
;;	NOTE:	It is assumed that the stack is already aligned on a word
;;		boundary when the cProc is invoked.  The macros will guarantee
;;		to allocate an even number of bytes on the stack to maintain
;;              word alignment.


?aloc macro n,t,l,s,a
  if ?cpd				;;must be in a proc def
    .xcref
    irp x,<n>				;;generate symbol equates
      ???=???+l 			;;update length of locals
      if a				;;if align, then force word alignment
	if memS32 and l GT 2
	  ???=((??? + 3) and 0fffffffch) ;; dword alignment
	else
	  ???=((??? + 1) and 0fffeh)
	endif
      endif
      ?al1 x,<t>,%(???+?ia)		;;?ia will always be valid (0 or 2)
      .xcref ?t&&x
      ?t&&x=s				;;save size info
    endm
    .cref
  else
    ??error2 <locals "&n" declared outside procedure def>
  endif
endm



;;      ?al1 - allocate local, continued.
;;
;;      ?al1 actually generates the text equate for the local variable.
;;	The form of the text equate generated is more or less:
;;
;;		name equ (type ptr [bp-?ia-nn])
;;          or
;;		name equ ([bp-?ia-nn])
;;
;;      where:
;;              ?ia   is defined to be either zero, or is defined to be
;;		      the number of bytes between the saved BP and the first
;;		      local.  ?ia is only applicable if the current cProc is
;;		      a windows far procedure or if parmRs have been
;;		      encountered.  If not, the ?ia will be zero.  since ?ia
;;		      is determinable prior to invoking this macro, it will be
;;		      added into the  offset ("nn") passed to this macro
;;
;;      usage:
;;              ?al1 n,t,o
;;      where:
;;              n    is the name for the text equate
;;              t    is the type of the equate
;;              o    is the offset of the equate


?al1 macro n,t,o
  if ?no_bp2
    n equ (t [-o])
  else
    n equ (t [IBP][-o])
  endif
endm


;;	?gcc - get calling convention
;;
;;	?gcv sets the given symbol to the calling convention
;;	to be used.
;;
;;	usage:
;;		?gcc s,i,cc
;;
;;	where:
;;		s  is the symbol to return the convention in
;;		   s = 0 if 'C' calling convention
;;		   s = 1 if PL/M (PASCAL) calling convention
;;		i  is the initial value for s
;;		cc is the calling convention override, and may be one of
;;		   C	  use 'C' convention
;;		   PLM	  use PL/M calling convention
;;		   PASCAL use PL/M calling convention

?gcc macro s,i,cc
  s = i 				;;Set default calling convention
  ifnb <cc>
    ifidn <cc>,<C>			;;If overriding default
      s=0				;;  'C' calling convention
    endif
    ifidn <cc>,<PLM>
      s=1				;;  PL/M calling convention
    endif
    ifidn <cc>,<PASCAL>
      s=1				;;  PL/M calling convention
    endif
  endif
endm



ifndef ?NOGLOBAL
  .xcref
  .xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP,globalI
  .cref

  ;;	globalx - define global data of type x
  ;;
  ;;	usage:
  ;;		globalx n,i,s,c
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is the name to be given the variable.
  ;;		i	is the initial value of the variable.
  ;;		s	is the duplication factor
  ;;		c	is the convention, C for C, PLM or PASCAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.
  ;;
  ;;	The D form will generate two extra equates of the form off_n and seg_n.

  globalB macro n,i,s,c
    ?ad <n>,1
    ?dd n,1,<byte>,<db>,<i>,<s>,<c>
  endm

  globalW macro n,i,s,c
    ?ad <n>,2
    ?dd n,1,<word>,<dw>,<i>,<s>,<c>
  endm

  globalI macro n,i,s,c
    ?ad <n>,2
    ?dd n,1,wordI,%asmdI,<i>,<s>,<c>
  endm

  globalD macro n,i,s,c
    ?ad <n>,4
    ?dd n,1,<dword>,<dd>,<i>,<s>,<c>
    off_&n equ word ptr n[0]
    seg_&n equ word ptr n[2]
  endm

  globalQ macro n,i,s,c
    ?ad <n>,8
    ?dd n,1,<qword>,<dq>,<i>,<s>,<c>
  endm

  globalT macro n,i,s,c
    ?ad <n>,10
    ?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
  endm

  if sizec
    globalCP macro n,i,s,c
      globalD n,<i>,<s>,<c>
    endm
  else
    globalCP macro n,i,s,c
      globalW n,<i>,<s>,<c>
    endm
  endif

  if sized
    globalDP macro n,i,s,c
      globalD n,<i>,<s>,<c>
    endm
  else
    globalDP macro n,i,s,c
      globalI n,<i>,<s>,<c>
    endm
  endif

endif


ifndef ?NOSTATIC
  .xcref
  .xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP,staticI
  .cref

  ;;	staticx - define static data of type x
  ;;
  ;;	usage:
  ;;		staticx n,i,s
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is the name to be given the variable.
  ;;		i	is the initial value of the variable.
  ;;		s	is the duplication factor
  ;;
  ;;	statics do not generate an underscored version of the symbol
  ;;	since they are intended to be internal symbols.  If they are
  ;;	required to be public, use globlax.


  staticB macro n,i,s
    ?ad <n>,1
    ?dd n,0,<byte>,<db>,<i>,<s>,<PLM>	;;PLM to keep from generating _
  endm

  staticW macro n,i,s
    ?ad <n>,2
    ?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
  endm

  staticD macro n,i,s
    ?ad <n>,4
    ?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
  endm

  staticI macro n,i,s
    ?ad <n>,sizeI
    ?dd n,0,wordI,%asmdI,<i>,<s>,<PLM>
  endm

  staticQ macro n,i,s
    ?ad <n>,8
    ?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
  endm

  staticT macro n,i,s
    ?ad <n>,10
    ?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
  endm

  if sizec
    staticCP macro n,i,s
      staticD n,<i>,<s>
    endm
  else
    staticCP macro n,i,s
      staticW n,<i>,<s>
    endm
  endif

  if sized
    staticDP macro n,i,s
      staticD n,<i>,<s>
    endm
  else
    staticDP macro   n,i,s
      staticI n,<i>,<s>
    endm
  endif
endif



;;      ?dd is the generalized data definition macro.
;;
;;      format:
;;		?dd n,p,t,d,i,s,c
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              t       is the assembler type (byte, word, dword)
;;              d       is the assembler directive (db,dw or dd)
;;              i       is the initial value
;;              s       is a duplication factor
;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
;;			The default (?PLM flag) will be used if not specified.


?dd macro n,p,t,d,i,s,c
  ?gcc ?dd2,%?PLM,<c>			;;Set calling convention
  ife ?dd2				;;If 'C'
    n label t
    ?dd1 _&n,p,<d>,<i>,<s>		;;Microsoft C uses leading underscores
  else
    ?dd1 n,p,<d>,<i>,<s>		;;If PL/M
  endif
endm



;;      ?dd1 is the generalized data definition macro.
;;
;;      format:
;;              ?dd1 n,p,d,i,s
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              d       is the assembler directive (db,dw or dd)
;;              i       is the initial value
;;              s       is a duplication factor


?dd1 macro n,p,d,i,s
  if p
    public n
  endif
  ifb <s>
    n d i
  else
    ifb <i>
      n d s dup (?)
    else
      n d s dup (i)
    endif
  endif
endm



ifndef ?NOEXTERN
  .xcref
  .xcref ?ex1,?ex2,externB,externW,externD,externQ,externT,externI
  .xcref externNP,externFP,externP,externCP,externDP,externA
  .cref
  ?ex2 = 0

  ;;	externx - define external data of type x
  ;;
  ;;	usage:
  ;;		externx n,c
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer
  ;;			dp=data pointer,  a=absolute
  ;;		n	is a list of names to define
  ;;		c	is the convention, C for C, PLM or PSACAL forPL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  externA macro n,c			;;40h is reserved for whatever will
    ?ex1 <n>,40h,<abs>,<c>,<>		;;  be done in the future for ASB
  endm					;;  externals

  externB macro n,c
    ?ex1 <n>,1,<byte>,<c>,<>
  endm

  externW macro n,c
    ?ex1 <n>,2,<word>,<c>,<>
  endm

  externD macro n,c
    ?ex1 <n>,4,<dword>,<c>,<>
  endm

  externI macro n,c
    ?ex1 <n>,sizeI,%wordI,<c>,<>
  endm

  externQ macro n,c
    ?ex1 <n>,8,<qword>,<c>,<>
  endm

  externT macro n,c
    ?ex1 <n>,10,<tbyte>,<c>,<>
  endm

  externNP macro n,c
    ?ex1 <n>,2,<near>,<c>,<cc>
  endm

  externFP macro n,c
    ?ex1 <n>,4,<far>,<c>,<cc>
  endm

  if sizec
    externP macro n,c
      ?ex1 <n>,4,<far>,<c>,<cc>
    endm
  else
    externP macro n,c
      ?ex1 <n>,2,<near>,<c>,<cc>
    endm
  endif

  if sizec
    externCP macro n,c
      ?ex1 <n>,4,<dword>,<c>,<>
    endm
  else
    externCP macro n,c
      ?ex1 <n>,2,<word>,<c>,<>
    endm
  endif

  if sized
    externDP macro n,c
      ?ex1 <n>,4,<dword>,<c>,<>
    endm
  else
    externDP macro n,c
      ?ex1 <n>,2,<word>,<c>,<>
    endm
  endif



  ;;	?ex1 is the generalized external definition macro
  ;;
  ;;	format:
  ;;		?ex1 n,s,d,c,scv
  ;;	where:
  ;;		n	is are the names of the externals
  ;;		s	is the size in bytes (used for typing)
  ;;		d	is the type
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.
  ;;		scv	save calling convention.  If this field is "cc", then
  ;;			the calling convention will be saved in a ?CCn equ.

  ?ex1 macro n,s,d,c,scv
    ?gcc ?ex2,%?PLM,<c>
    irp x,<n>
      .xcref
      .xcref ?t&&x
      .cref
      ?t&&x=s				;;save size info
      ife ?ex2
	extrn _&&x:&d
	x equ _&&x
      else
	extrn x:&d
      endif
      ifidn <scv>,<cc>			;;save calling convention (C or PL/M)
	.xcref				;;  if NP, FP, or P
	.xcref ?CC&&x
	.cref
	?CC&&x=?ex2
      endif
    endm
  endm
endif



ifndef ?NOLABEL
  .xcref
  .xcref ?lb1,?lblpu,?lb2
  .xcref labelB,labelW,labelD,labelQ,labelT
  .xcref labelNP,labelFP,labelP,labelCP,labelDP
  .cref
  ?lblpu = 0
  ?lb2 = 0

  ;;	  labelx - define label of data type x
  ;;
  ;;	  usage:
  ;;		  labelx n,c
  ;;	  where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is a list of names to define, the first of which can
  ;;			be the keyword public
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  labelB macro n,c
    ?lb1 <n>,1,<byte>,<c>
  endm

  labelW macro n,c
    ?lb1 <n>,2,<word>,<c>
  endm

  labelD macro n,c
    ?lb1 <n>,4,<dword>,<c>
  endm

  labelQ macro n,c
    ?lb1 <n>,8,<qword>,<c>
  endm

  labelT macro n,c
    ?lb1 <n>,10,<tbyte>,<c>
  endm

  labelNP macro n,c
    ?lb1 <n>,2,<near>,<c>
  endm

  labelFP macro n,c
    ?lb1 <n>,4,<far>,<c>
  endm

  if sizec
    labelP macro n,c
      ?lb1 <n>,4,<far>,<c>
    endm
  else
    labelP macro n,c
      ?lb1 <n>,2,<near>,<c>
    endm
  endif

  if sizec
    labelCP macro n,c
      ?lb1 <n>,4,<dword>,<c>
    endm
  else
    labelCP macro n,c
      ?lb1 <n>,2,<word>,<c>
    endm
  endif

  if sized
    labelDP macro n,c
      ?lb1 <n>,4,<dword>,<c>
    endm
  else
    labelDP macro n,c
      ?lb1 <n>,2,<word>,<c>
    endm
  endif


  ;;	?lb1 is the generalized label definition macro
  ;;
  ;;	format:
  ;;		?lb1 n,s,d
  ;;	where:
  ;;		n	are the names of the labels
  ;;		s	is the size in bytes (used for typing)
  ;;		d	is the type
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  ?lb1 macro n,s,d,c
   ?gcc ?lb2,%?PLM,<c>
    ?lblpu=0
    irp x,<n>
      ifidn <x>,<PUBLIC>
	?lblpu=1
      else
	.xcref
	.xcref ?t&&x
	.cref
	?t&&x=s 			;;save size info
	ife ?lb2			;;If C
	  if ?lblpu
	     public _&&x
	  endif
	  _&&x label &d
	  x equ _&&x
	else				;;If PL/M
	  if ?lblpu
	     public x
	  endif
	  x label &d
	endif
      endif
    endm
  endm
endif



ifndef ?NODEF

  ;;	defx - inform macros that name is of type x
  ;;
  ;;	The given name(s) is flaged to be of the given type.  This macro
  ;;	is intended for giving types to variables that were not generated
  ;;	by the macros (i.e., static storage).  There must be a type definition
  ;;	for all parameters in a call list.
  ;;
  ;;	usage:
  ;;		defx	n
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;		n      is the name(s) to be given the variable(s).
  ;;
  ;;	Bytes are considered to be two bytes long for alignment reasons

  .xcref
  .xcref defB,defW,defD,defQ,defT,defCP,defDP
  .cref

  defB macro n
    ?ad <n>,1
  endm

  defW macro n
    ?ad <n>,2
  endm

  defD macro n
    ?ad <n>,4
  endm

  defQ macro n
    ?ad <n>,8
  endm

  defT macro n
    ?ad <n>,10
  endm

  if sizec
    defCP macro n
      defD <n>
    endm
  else
    defCP macro n
      defW <n>
    endm
  endif

  if sized
    defDP macro n
      defD <n>
    endm
  else
    defDP macro n
      defW <n>
    endm
  endif
endif



;	?ad is the macro which creates a definition for the given
;	symbol
;
;	usage:
;		?ad <n>,s
;	where:
;		n is a list of names to define
;		s is the size info (1,2,4,8,10)


?ad macro n,s
  irp x,<n>
    .xcref
    .xcref ?t&&x
    .cref
    ?t&&x=s				;;save size info
  endm
endm



ifndef ?NOPTR
  .xcref
  .xcref regPtr,farPtr
  .cref

  ;;	regPtr generates information allowing a 32-bit pointer currently
  ;;	in a register to be pushed as a parameter to a subroutine using
  ;;	the cCall macro.
  ;;
  ;;	usage:
  ;;		regptr	n,s,o
  ;;	where:
  ;;		n	is the name the argument will be known as
  ;;		s	is the register containing the segment portion
  ;;			of the pointer
  ;;		o	is the register containing the offset portion
  ;;			of the pointer
  ;;
  ;;	2/14/85 - made obsolete with farptr

  regPtr macro n,s,o
    farPtr n,s,o
  endm



  ;;	farPtr generates information allowing a 32-bit pointer to be
  ;;	pushed as a parameter to a subroutine using the cCall macro.
  ;;
  ;;	usage:
  ;;		farptr	n,s,o
  ;;	where:
  ;;		n	is the name the argument will be known as
  ;;		s	is the segment portion of the pointer
  ;;		o	is the offset portion of the pointer
  ;;
  ;;	Note that any cast must have been made in the argument itself
  ;;	(i.e. regptr ptr1,ds,<word ptr 3[si]>)


  farPtr macro n,s,o
    .xcref
    .xcref ?t&n
    .cref
    n &macro
      push s								      ;@
      push o								      ;@
    &endm
    ?t&n=80h
  endm
endif



;;      arg - declare argument
;;
;;	The given argument(s) is added to the argument list structure
;;
;;      format:
;;              arg     a
;;
;;      where:
;;              a       is any valid argument to push.
;;
;;	If any element in arglist has not been defined or isn't a 16-bit
;;      register, then a complete specification must have been given in a
;;      text equate and a defx also given (if not, you'll pay the penalty!)


arg macro a
  irp x,<a>
    ?argc=?argc+1			;;increment the arg count
    ?atal <x>,%?argc			;;generate argument
  endm
endm



;;      ?atal (add to argument list) generates a macro that will cause
;;	the given argument to be processed when invoked.  It is used by
;;      the arg macro only.


?atal macro n,i
  .xcref
  .xcref ?ali&i
  .cref
  ?ali&i &macro
    ?ap <n>
  &endm
endm



;;      ?ap - process arguments and place onto stack
;;
;;	The given argument is processed (type checking) and place on
;;	the stack for a pending call.  There must be a type definition
;;	for all arguments (except words).  This can be done by using
;;      text equates and the defx macro.
;;
;;      format:
;;              ?ap n
;;      where:
;;              n       is the name of the argument to be pushed
;;
;;	The variable  ?argl  is updated by the length of the arguments
;;      pushed so that the stack can be cleaned up after the call.


?ap macro n
  ?argl=?argl+2 			;;assume one word is pushed
  ifdef ?t&n
    ife ?t&n-1				;;byte type
      push word ptr (n) 						      ;@
      exitm
    endif

    ife ?t&n-2				;;word type
      push n								      ;@
      exitm
    endif

    ife ?t&n-4				;;dword type
      push word ptr (n)[2]						      ;@
      push word ptr (n) 						      ;@
      ?argl=?argl+2
      exitm
    endif

    ife ?t&n-8				;;qword type
      push word ptr (n)[6]						      ;@
      push word ptr (n)[4]						      ;@
      push word ptr (n)[2]						      ;@
      push word ptr (n) 						      ;@
      ?argl=?argl+6
      exitm
    endif

    if ?t&n and 80h			;;far pointer type
      n
      ?argl=?argl+2
      exitm
    endif

    ife ?t&n				;;variable storage
      push word ptr (n) 						      ;@
      exitm
    endif
  endif

  push n				;;unknown or register or immediate    ;@
endm



;;	cCall - call a 'c' language procedure
;;
;;	The given procedure is called with the given parameters.
;;	If the calling convention is C, the arguments are pushed
;;      in reverse order, and removed after the called procedure
;;	returns.  If the calling conventing is PL/M, the arguments
;;      are pushed as they were encountered, and the called procedure
;;      is assumed to have removed them from the stack.
;;
;;	The calling convention priority will be:
;;	   1)	that specified on the cCall if present
;;	   2)	that defined by the target
;;	   3)	the default (?PLM flag)
;;
;;      format:
;;		ccall n,<a>,c
;;
;;      where:
;;              n       is the name of the procedure to call
;;              a       are arguments to be pushed (optional, may be
;;                      specified with the "arg" macro.
;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
;;			The default (?PLM flag) will be used if not specified.


cCall macro n,a,c
  ifnb <a>				;;add any arguments to list
    arg <a>
  endif
  mpush %?rsl				;;save registers (if any)

  ifdef ?CC&n				;;if calling convention has been
    ?cCall1=?CC&n			;;   defined for target, use it
  else					;;else use the default
    ?cCall1=?PLM
  endif

  ifnb <c>				;;If possible override, check it out
    ?gcc ?cCall1,%?cCall1,<c>
  endif

  ?argl=0				;;init argument length
  ife ?cCall1				;;if C calling convention
    ?acb=?argc				;;initialize for looping
  else
    ?acb=1				;;initialize for looping
  endif

  rept ?argc				;;push arguments and purge macros
    uconcat <?ali>,%?acb
    uconcat <purge>,,<?ali>,%?acb
    ife ?cCall1 			;;if C calling convention
      ?acb=?acb-1
    else
      ?acb=?acb+1
    endif
  endm
  call n				;;call the procedure		      ;@
  if ((?cCall1 eq 0) and (?argl ne 0))	;;If C calling convention and arguments
    add sp,?argl			;;  then remove them		      ;@
  endif
  mpop %?rsl				;;pop all specified regs
  ?rsl=0				;;invalidate save list
  ?argc= 0				;;    "      arguments
  ?argl= 0
endm




;;	cProc - define a 'c' procedure
;;
;;	cProc is the procedure definition for procedures.
;;
;;      format:
;;		cProc n,cf,a
;;      where:
;;              n       is the name of the procedure
;;
;;		cf	controls certain definitions, and may be:
;;			    NEAR       proc is to be a near label
;;			    FAR        proc is to be a far  label
;;			    PUBLIC     proc is to be defined as public
;;			    SMALL      call makeframe procedure
;;			    NODATA     dont create prolog code to setup DS
;;			    ATOMIC     don't link stack if not needed
;;				       NODATA must be specified for ATOMIC
;;			    FORCEFRAME Force generation of a frame
;;			    C	       proc is to be a C    procedure
;;			    PLM        proc is to be a PL/M procedure
;;			    PASCAL     proc is to be a PL/M procedure
;;			    WIN        proc is to be a windows procedure
;;			    NONWIN     proc isn't to be a windows procedure
;;			    NO_BP      don't generate BP in text equates
;;			    BP	       generate BP in text equates
;;
;;              a       is a list of registers that are to be saved whenever
;;                      the procedure is invoked.
;;
;;			makeframe procedure:   If small is specified, then
;;                      the "makeframe procedure" is invoked instead of
;;                      generating normal prologues/epilogues
;;
;;			A call is performed to the makeframe procedure.  The
;;                      call is followed by two bytes.  the first byte is the
;;                      number of locals to allocate for the frame, the second
;;			is the number of bytes of parameters.  The makeframe
;;			procedure will in turn call the cProc routine at the
;;			address following the data bytes.  When the cProc is
;;                      finished, it will do a near return to the makeframe
;;                      procedure to clean up the frame and exit.
;;
;;			Note that register parameters and makeframe are
;;                      incompatible and cannot be used together.
;;
;;			The makeframe procedure will save SI, DI, and also
;;			DS if a far procedure.	These registers will be
;;                      removed from the autosave list if specified.


cProc macro n,cf,a
  if ?cpd
    ?utpe				;;generate unterminated proc error
  endif

  ?cpd=1				;;a procdef is active now
  ???=0 				;;no locals are defined yet
  ?argc=0				;;no arguments are defined
  ?ba=0 				;;not in a procedure
  ?po=0 				;;initial parameter offset
  ?pu=0 				;;initial public setting
  ?ia=0 				;;no special prolog/epilog
  ?adj=2*sizeI				;;parameter adjustment (near ret+bp)
  ?rp=0 				;;no register parameters
  ?uf=0 				;;don't use makeframe
  ?wfp=?WIN				;;default far procedure (win or not)
  ?ff=0 				;;don't force frame setup
  ?pas=0				;;process register save list
  ?pcc=?PLM				;;calling convention (C or PL/M)
  ?no_bp2=?no_bp1			;;Default base register generation

  ifnb <a>				;;register save list
    ?ri ?pas,<a>
  endif

  ?pc=sizec				;;default size
  ?nd=?nodata1				;;default NODATA flag
  ?nx=0 				;;default is not ATOMIC

  irp x,<cf>
    ifdef ??_cproc_&&x
      ??_cproc_&&x
    else
      ??error2 <e r r o r - unknown keyword x>
      .err
    endif

  endm

  if ?pcc				;;If PLM
    ?PLMPrevParm=0			;;  show no previous parameter
    .xcref
    .xcref ?PLMParm0
    .cref
    ?PLMParm0 &macro			;;Null macro to terminate
    purge ?PLMParm0
    &endm
  endif

  .xcref
  .xcref ?CC&n
  .cref
  ?CC&n=?pcc				;;Save procedure type

  if (?nx eq 1) and (?nd eq 0)		;;ATOMIC requires NODATA
    ?nx = 0				;;clear the ATOMIC keyword
    ??error2 <ATOMIC specified without NODATA - ATOMIC ignored>
  endif

  if ?pc				;;if a far procedure
    if ?wfp				;;if windows
      ife ?nx				;;if not ATOMIC
        ife ?COW			;; COW dos not save DS
	  ?ia=2				;;  adjust locals for saved ds
	  ?pas = ?pas and (not ?ds)	;;no need for extra save
	endif
      endif
    endif
    ?adj=?adj+sizeI 			;;far, make parameter adjustment
  else
    ?wfp=0				;;not a far windows procedure
  endif

  ?pas = ?pas and (not (?sp+?cs+?ss))	;;make no sense to save these

  if ?uf				;;don't save these if user frame
    ?pas = ?pas and (not (?bp+?si+?di))
  endif

  ife ?pcc
    ?pg  <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
  else
    ?pg  <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
  endif
endm




;;      ?pg - generate begin and nested macros for current procedure
;;
;;      format:
;;		?pg n,p,c,a,w,nnu,cc
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              c       is the class definition for the procedure
;;              a       is an enumerated list of registers to save
;;                      at entry and restore at exit
;;              w       true if a far windows procedure
;;		nnu	procedure name without any underscore
;;		cc	calling convention (C or PL/M)
;;
;;
;;      local stack allocation will be forced to an even byte count to
;;      maintain stack word alignment.


?pg macro n,p,c,a,w,nnu,cc
  .xcref
  if ?uf				;;if user frame
    if ?nd
      ??error2 <NODATA encountered in &n - user frame ignored>
      ?uf=0
    endif
  endif

  .xcref cBegin
  cBegin &macro g			;;generate cBegin macro
    .xcref
    if cc				;;Finish definition of parameters
      uconcat <?PLMParm>,%?PLMPrevParm,%?po
    endif

    if ?uf				;;if user frame
      if ?rp				;;If register parameters
	??error2 <parmR encountered in &n - user frame ignored>
	?uf=0
      endif
    endif
    ?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc,<nnu>,%??? ;;generate cEnd macro
    ?cpd=0				;;terminate current proc def
    ?argc=0				;;no arguments are defined yet
    ?ba=1				;;have reached a begin
    ???=(???+1) and 0fffeh		;;word align local storage

    if p				;;If to be public
      public n
    endif

    ife c				;;declare procedure type
      n proc near
    else
      n proc far
    endif

    ife cc				;;if 'C' calling convention
      nnu equ n 			;;  generate label without underscore
    endif

    ?cbe = 0				;;Assume no command on cBegin line
    ifnb <g>
      ?pcbe <g>,<nnu>,<cBegin>
    endif
    if ?cbe eq 1			;;if nogen, then cannot have locals
      if ???+a+?rp			;;  saved regs, or parmRs
	if2
	  ??_out <cBegin - possibly invalid use of nogen>
	endif
      endif
    else				;;else must generate a frame
      if ?uf				;;if user frame code specified
	 ?mf c,%???,%?po		;;  call user's makeframe
	 mpush a			;;  save specified registers
      else
	ife ?cbe			;;If full frame to be set up
	  if w				;;if a far windows procedure
	    ife ?nd			;;if not NODATA,
	      mov IAX,ds 		;;   then set AX = current ds, and    ;@
	      nop			;;   leave room for  MOV AX,1234h     ;@
	    endif
	    ife ?nx			;;if not ATOMIC, far frame must be set
	      ife ?DOS5 		;;if not DOS5, then set far frame flag
		inc IBP			;;  by incrementing the old bp	      ;@
	      endif
	      push IBP							      ;@
	      mov IBP,ISP 						      ;@
	      ife ?COW			;; save DS not needed for CW
	  	push ds							      ;@
	      endif
	    else			;;ATOMIC procedure
	      if ?ff+???+?po+?rp	;;if any locals or parameters
		push IBP 		;;  then must set frame pointer       ;@
		mov IBP,ISP		;;  to be able to access them	      ;@
	      endif
	    endif
	    ife ?nd			;;if not NODATA, then AX should
	      mov ds,IAX 		;;  have the ds to use		      ;@
	    endif
	  else				;;not windows.	use standard prolog
	    if ?ff+???+?po+?rp		;;if any locals or parameters
	      push IBP			;;  then must set frame pointer       ;@
	      mov IBP,ISP 		;;  to be able to access them	      ;@
	    endif
	  endif
	  if ?rp			;;if parmR's, push them before
	    ?uf=0			;;  allocating locals and saving
	    rept ?rp			;;  the autosave registers
	      uconcat mpush,,?rp,%?uf
	      ?uf=?uf+1
	    endm
	  endif
	  if ???			;;if locals to allocate
	    if ?chkstk1 		;;if stack checking enabled
	      ifdef ?CHKSTKPROC 	;;if user supplied stack checking
		?CHKSTKPROC %???	;;  invoke it with bytes requested
	      else
		mov IAX,???		;;invoke default stack checking       ;@
		ife cc
		  call _chkstk						      ;@
		else
		  call chkstk						      ;@
		endif
	      endif
	    else			;;no stack checking
	      sub   ISP,???		;; allocate any local storage	      ;@
	    endif
	  endif
	else				;;partial frame, only set locals
	  if ?rp			;;If parmRs, error
	    ??error2 <cBegin - parmRs encountered with partial frame>
	  else
	    if ???			;;Only realloc frame if locals
	      lea ISP,[IBP][-???-?ia]	;;?ia will adjust for saved BP	      ;@
	    endif
	  endif
	endif
	mpush a 			;;save autosave registers
      endif

      ifdef ?PROFILE			;;if profiling enabled
	if c				;;  and a far procedure
	  call StartNMeas		;;  invoke profile start procedure    ;@
	endif
      endif

    endif

    .cref
    purge cBegin			;;remove the macro
  &endm 				;;end of cBegin macro

  .xcref ?utpe
  ?utpe &macro
    ??error2 <unterminated procedure definition: "&n">
  &endm
  .cref
endm					;;end of ?pg macro




;;      ?pg1 - generate end macro for current procedure
;;
;;      format:
;;		?pg1 n,c,a,o,w,f,d,r,cc,nnu,lc
;;      where:
;;              n       is the name of the procedure
;;              c       is the class definition for the procedure
;;              a       is an enumerated list of registers to save
;;                      at entry and restore at exit
;;              o       is the number of bytes of paramteres to remove at exit
;;              w       true if a far windows procedure
;;              f       is 1 if to use the user's makeframe procedure
;;		d	is 1 if NODATA procedure
;;              r       number of register parameters
;;		cc	calling convention (C or PL/M)
;;		nnu	procedure name without any underscore
;;		lc	locals byte count


?pg1 macro n,c,a,o,w,f,d,r,cc,nnu,lc
  .xcref
  .xcref cEnd

  parm_bytes_&nnu = o			;;Define number of parameter bytes

  cEnd &macro g 			;;start of cEnd macro
    .xcref
    ?ba=0				;;no longer in a procedure
    ?cbe = 0				;;Assume no command on cBegin line
    ifnb <g>
      ?pcbe <g>,<nnu>,<cEnd>
    endif
    if ?cbe eq 1			;;if nogen, then cannot have parmRs
      if a+r+lc 			;;  locals, or saved registers
	if2
	  ??_out <cEnd - possibly invalid use of nogen>
	endif
      endif
    else				;;else must remove the frame
      ifdef ?PROFILE			;;if profiling enabled
	if c				;;  and a far procedure
	  call StopNMeas		;;  invoke profile stop procedure
	endif				;;  (doesn't trash DX:AX)
      endif
      mpop a				;;restore autosaved registers
      if f				;;if to use the "makeframe" procedure
	db 0c3h 			;;  near return to user's makeframe    @
      else
	if w				;;if far win proc, use special epilog
	  ife ?nx			;;if not ATOMIC, bp was pushed
	    ife ?COW			;; restore DS not needed for CW
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
		lea sp,-2[bp]		;;  or locals or parmR's, get valid SP @
	      endif
	      pop ds			;;restore saved ds and bp	       @
	    else
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
	        mov sp,bp
	      endif
	    endif
	    pop IBP			;;				       @
	    ife ?DOS5			;;if not DOS5, bp was
	      dec IBP			;;  incremented to mark far frame      @
	    endif
	  else				;;ATOMIC frame was set up
	    if memS32
	      leave
	    else
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
	        mov ISP,IBP 		;;  or locals or parmR's, get valid SP @
	      endif
	      if ???+?po+r
	        pop IBP						      ;@
	      endif
	    endif
	  endif
	else				;;non-windows standard epilog
	  if ?ff+???+?po+r		;;if any parameters
	    if (?TF eq 0) or (???+r)	;;if cannot assume valid SP
	      mov ISP,IBP 		;;  or locals or parmR's, get valid SP;@
	    endif
	    pop IBP							      ;@
	  endif
	endif
	if ?cbe ne 4			;;Don't generate ret if ??cleanframe??   e
	  ife cc			;;if C calling convention
	    ret 			;;  return			      ;@
	  else				;;else
	    ret o			;;  return and remove paramteres      ;@
	  endif
	endif
      endif
    endif
    if ?cbe ne 4			;;Don't delete macro if ??cleanframe??   e
      n endp				;;end of process
      .cref
      purge cEnd			;;remove the macro
    else
      .cref
    endif
  &endm
  .cref
endm


;;	cleanframe
;;
;;	cleanframe removes a cMacros generated frame, invoking cEnd
;;	with a special keyword which will keep the cEnd macro from
;;	generating a return statement and purging itself.

.xcref
.xcref cleanframe
cleanframe macro
  cEnd <??cleanframe??>
endm
.cref



;; The following macros are used to speed up the processing of the
;; command allowed on a cProc command line.  They simply set or clear
;; the correct flag as needed.

.xcref
.xcref ??_cproc_FAR,??_cproc_NEAR,??_cproc_PUBLIC,??_cproc_SMALL
.xcref ??_cproc_DATA,??_cproc_NODATA,??_cproc_ATOMIC,??_cproc_C
.xcref ??_cproc_PLM,??_cproc_PASCAL,??_cproc_WIN,??_cproc_NONWIN
.xcref ??_cproc_NO_BP,??_cproc_BP

.xcref ??_cproc_far,??_cproc_near,??_cproc_public,??_cproc_small
.xcref ??_cproc_data,??_cproc_nodata,??_cproc_atomic,??_cproc_c
.xcref ??_cproc_plm,??_cproc_pascal,??_cproc_win,??_cproc_nonwin
.xcref ??_cproc_no_bp,??_cproc_bp
.cref

??_cproc_FAR macro
 ?pc=1
endm

??_cproc_NEAR macro
  ?pc=0
endm

??_cproc_PUBLIC macro
  ?pu=1
endm

??_cproc_SMALL macro
  ?uf=1
endm

??_cproc_DATA macro
  ?nd=0
endm

??_cproc_NODATA macro
  ?nd=1
endm

??_cproc_ATOMIC macro
  ?nx=1
endm

??_cproc_C macro
  ?pcc=0
endm

??_cproc_PLM macro
  ?pcc=1
endm

??_cproc_PASCAL macro
  ?pcc=1
endm

??_cproc_WIN macro
  ?wfp=1
endm

??_cproc_NONWIN macro
  ?wfp=0
endm

??_cproc_NO_BP macro
  ?no_bp2=1
endm

??_cproc_BP macro
  ?no_bp2=0
endm

??_cproc_far macro
 ?pc=1
endm

??_cproc_near macro
  ?pc=0
endm

??_cproc_public macro
  ?pu=1
endm

??_cproc_small macro
  ?uf=1
endm

??_cproc_data macro
  ?nd=0
endm

??_cproc_nodata macro
  ?nd=1
endm

??_cproc_atomic macro
  ?nx=1
endm

??_cproc_c macro
  ?pcc=0
endm

??_cproc_plm macro
  ?pcc=1
endm

??_cproc_pascal macro
  ?pcc=1
endm

??_cproc_win macro
  ?wfp=1
endm

??_cproc_nonwin macro
  ?wfp=0
endm

??_cproc_no_bp macro
  ?no_bp2=1
endm

??_cproc_bp macro
  ?no_bp2=0
endm


;	?pcbe is the macro which processes the text on cBegin/cEnd
;	The text is allowed to be:
;
;		NOGEN	nogen
;		PARTIAL partial
;		the procedure name as given on the cProc line
;
;	usage:
;		?pcbe <g>,<nnu>,<mt>
;	where:
;		g	is the text on the cBegin/cEnd line
;		nnu	is the procedure name without any underscores
;		mt	macro type (cBegin/cEnd)
;
;	The variable ?cbe is set to the following value
;
;		0 = invalid (defualt action>
;		1 = nogen
;		2 = partial frame
;		4 = clean frame


?pcbe macro g,nnu,mt
  ifidn <g>,<NOGEN>
    ?cbe = 1
  else
    ifidn <g>,<nogen>
      ?cbe = 1
    else
      ifidn <mt>,<cBegin>
	ifidn <g>,<PARTIAL>
	  ?cbe = 2
	else
	  ifidn <g>,<partial>
	    ?cbe = 2
	  else
	    ifdif <g>,<nnu>
	      ??error2 <mt - unknown keyword g>
	    endif
	  endif
	endif
      else
	ifidn <g>,<??cleanframe??>
	  ?cbe = 4
	else
	  ifdif <g>,<nnu>
	    ??error2 <mt - unknown keyword g>
	  endif
	endif
      endif
    endif
  endif
endm



;	assumes is a macro that will set up the assumes for a segment
;	or group created with the createSeg macro.  If the assumed
;	value passed in isn't known, then a normal assume is made.
;
;       usage:
;               assumes s,g
;
;       where:
;               s       is the register to make the assumption about
;		g	is the value to assume is in it
;
; as a hack, substitute FLAT for g if memF32 is set


assumes macro   s,ln
  if  memF32
    assume s:FLAT
  endif
  ife memF32
    ifndef ln&_assumes
      assume s:ln
    else
      ln&_assumes s
    endif
  endif
endm



;	createSeg is a macro that sets up a segment definition and
;	a logical name for that segment.  The logical name can be
;       used to enter the segment, but it cannot be used for anything
;       else.
;
;       usage:
;		createSeg n,ln,a,co,cl,grp
;       where:
;               n       is the physical name of the segment
;               ln      is the name it is to be invoked by
;               a       is the alignment, and is optional
;               co      is the combine type, and is optional
;               cl      is the class, and is optional
;               grp     is the name of the group that contains this segment


createSeg macro n,ln,a,co,cl,grp
  ifnb <cl>
    n segment a co '&cl'
  else
    n segment a co
  endif
  n ends
  ifnb <grp>
    addseg grp,n
  else
    ln&OFFSET equ offset n:
    ln&BASE equ n
    ?cs3 <ln>,<n>
  endif
  ?cs1 <ln>,<n>
endm


addseg macro grp,seg
  .xcref
  .xcref grp&_def
  .cref
  ifndef  grp&_def
    grp&_def=0
  endif
  if grp&_def ne ASMpass
    .xcref
    .xcref grp&_add
    .cref
    grp&_add &macro s
      grp&_in <seg>,s
    &endm
    .xcref
    .xcref grp&_in
    .cref
    grp&_in &macro sl,s
      ifb <s>
	grp group sl
      else
	grp&_add &macro  ns
	grp&_in  <sl,s>,ns
	&endm
      endif
    &endm
    grp&_def=ASMpass
  else
    grp&_add seg
  endif
endm


defgrp macro grp,ln
  addseg grp
  ifnb <ln>
    irp x,<ln>
      ?cs3 <&x>,<grp>
      x&&OFFSET equ offset grp:
      x&&BASE equ grp
    endm
  endif
endm


?cs1 macro ln,n
  .xcref
  .xcref ln&_sbegin
  .cref
  ln&_sbegin &macro
    .xcref
    .xcref ?mf
    .cref
    ?mf &&macro c,l,p			;;when sBegin is invoked, generate
      if c				;;  the makeframe macro
	extrn n&_FARFRAME:near		;;  make frame for far procedures     ;@
	call n&_FARFRAME						      ;@
      else
	extrn n&_NEARFRAME:near 	;;  make frame for near procedures    ;@
	call n&_NEARFRAME						      ;@
      endif
      db l shr 1			;;define number of locals	      ;@
      db p shr 1			;;define number of parameters	      ;@
      &&endm
    ?cs2 <ln>,<n>
    n segment
  &endm
endm


?cs2 macro ln,n
  .xcref
  .xcref sEnd
  .cref
  sEnd &macro
    n ends
    purge ?mf				;;delete the makeframe macro
    purge sEnd
  &endm
endm


?cs3 macro ln,n
  .xcref
  .xcref ln&_assumes
  .cref
  ln&_assumes &macro s
    assume s:&n
  &endm
endm



;	sBegin is the macro that opens up the definition of a segment.
;	The segment must have already been defined with the createSeg
;       macro.
;
;       usage:
;		sBegin ln
;
;       where:
;               ln      is the logical name given to the segment when
;                       it was declared.

.xcref
.xcref sBegin
.cref
sBegin macro ln
  ln&_sbegin
endm

BeginDATA macro
  ife memF32
    sBegin DATA
  else
    .data
  endif
endm

BeginCODE macro
  ife memF32
    sBegin CODE
  else
    .code
  endif
endm

EndDATA macro
  ife memF32
    sEnd DATA
  endif
endm

EndCODE macro
  ife memF32
    sEnd CODE
  endif
endm

ife ?DF

  ;	Define all segments that will be used.	This will allow the
  ;	assume and groups to be set up at one given place, and also
  ;	allow quick changes to be made
  ;
  ;	createSeg name,logname,align,combine,class,group

ife ?DFCODE
  createSeg _TEXT,CODE,%wordI,public,CODE
endif
  ife ?nodata1
    createSeg _DATA,DATA,%wordI,public,DATA,DGROUP
    defgrp DGROUP,DATA
  else
    ife ?DFDATA
      createSeg _DATA,DATA,%wordI,public,DATA,DGROUP
      defgrp DGROUP,DATA
    endif
  endif

  if ?chkstk1
    ifndef ?CHKSTKPROC
      externp <chkstk>
    endif
  endif
endif


;       errnz exp - generate error message if expression isn't zero
;
;	The errnz will generate an error message if the expression "exp"
;	does not evaluate to zero.  This macro is very useful for testing
;       relationships between items, labels, and data that was coded into
;       an application.
;
;                  errnz   <offset $ - offset label>   ;error if not at "label"
;                  errnz   <eofflag and 00000001b>     ;eofflag must be bit 0
;
;	For expressions involving more than one token, the angle brackets
;       must be used.
;
;	The macro is only evaluated on pass 2, so forward references may be
;       used in the expression.

errnz macro x				;;display error if expression is <>0
  if2
    if x				;;if expression is non-zero,
      errnz1  <x>,%(x)
    endif
  endif
endm

errnz1 macro x1,x2
  = *errnz* x1 = x2
  .err
endm



;       errn$ label,exp - generate error message if label (exp) <> $
;
;	The errnz will generate an error message if the label and "exp"
;       does not evaluate to the current value of the location counter.
;	This macro is very useful for testing relationships between
;       labels and the location counter that was coded into an application.
;
;       examples:  errn$   label        ;error if not at "label"
;                  errn$   label,+3     ;error if not three bytes from "label"
;                  errn$   label,-3     ;error if not three bytes past "label"
;
;	If no "exp" is given, it is the same as specifying 0
;
;	The macro is only evaluated on pass 2, so forward references may be
;       used in the expression.

errn$ macro l,x 			;;error if <$-label1 (exp2)> <>0
  errnz   <offset $ - offset l x>
endm



;;	If profile has been specified, declare the profile routines
;;	to be external and far.  It would be best if this could be done
;;	when the call is actually made, but then the fix-up would be
;;	generated as segment-relative.


ifdef ?PROFILE
  externFP  <StartNMeas,StopNMeas>
endif

if memF32
  .model small
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\cmsgs.h ===
/***
*cmsgs.h - runtime errors
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The file defines, in one place, all error message strings used within
*       the C run-time library.
*
*       [Internal]
*
*Revision History:
*       06-04-90  GJF   Module created.
*       08-08-90  GJF   Added _RT_CONIO_TXT
*       10-11-90  GJF   Added _RT_ABORT_TXT, _RT_FLOAT_TXT, _RT_HEAP_TXT.
*       09-08-91  GJF   Added _RT_ONEXIT_TXT for Win32 (_WIN32_).
*       09-18-91  GJF   Fixed _RT_NONCONT_TXT and _RT_INVALDISP_TXT to
*                       avoid conflict with RTE messages in 16-bit Windows
*                       libs. Also, added math error messages.
*       10-23-92  GJF   Added _RT_PUREVIRT_TXT.
*       02-23-93  SKS   Update copyright to 1993
*       12-15-94  XY    merged with mac header
*       02-14-95  CFW   Clean up Mac merge.
*       03-03-95  GJF   Added _RT_STDIOINIT_TXT.
*       03-29-95  CFW   Add error message to internal headers.
*       06-02-95  GJF   Added _RT_LOWIOINIT_TXT.
*       12-14-95  JWM   Add "#pragma once".
*       04-22-96  GJF   Added _RT_HEAPINIT_TXT.
*       02-24-97  GJF   Replaced defined(_M_MPPC) || defined(_M_M68K) with
*                       defined(_MAC).
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CMSGS
#define _INC_CMSGS

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

/*
 * runtime error and termination messages
 */

#define EOL "\r\n"

#define _RT_STACK_TXT      "R6000" EOL "- stack overflow" EOL

#define _RT_FLOAT_TXT      "R6002" EOL "- floating point not loaded" EOL

#define _RT_INTDIV_TXT     "R6003" EOL "- integer divide by 0" EOL

#define _RT_SPACEARG_TXT   "R6008" EOL "- not enough space for arguments" EOL

#define _RT_SPACEENV_TXT   "R6009" EOL "- not enough space for environment" EOL

#define _RT_ABORT_TXT      "" EOL "This application has requested the Runtime to terminate it in an unusual way.\nPlease contact the application's support team for more information." EOL

#define _RT_THREAD_TXT     "R6016" EOL "- not enough space for thread data" EOL

#define _RT_LOCK_TXT       "R6017" EOL "- unexpected multithread lock error" EOL

#define _RT_HEAP_TXT       "R6018" EOL "- unexpected heap error" EOL

#define _RT_OPENCON_TXT    "R6019" EOL "- unable to open console device" EOL

#define _RT_NONCONT_TXT    "R6022" EOL "- non-continuable exception" EOL

#define _RT_INVALDISP_TXT  "R6023" EOL "- invalid exception disposition" EOL

/*
 * _RT_ONEXIT_TXT is specific to Win32 and Dosx32 platforms
 */
#define _RT_ONEXIT_TXT     "R6024" EOL "- not enough space for _onexit/atexit table" EOL

#define _RT_PUREVIRT_TXT   "R6025" EOL "- pure virtual function call" EOL

#define _RT_STDIOINIT_TXT  "R6026" EOL "- not enough space for stdio initialization" EOL

#define _RT_LOWIOINIT_TXT  "R6027" EOL "- not enough space for lowio initialization" EOL

#define _RT_HEAPINIT_TXT   "R6028" EOL "- unable to initialize heap" EOL

/*
 * _RT_DOMAIN_TXT, _RT_SING_TXT and _RT_TLOSS_TXT are used by the floating
 * point library.
 */
#define _RT_DOMAIN_TXT     "DOMAIN error" EOL

#define _RT_SING_TXT       "SING error" EOL

#define _RT_TLOSS_TXT      "TLOSS error" EOL


#define _RT_CRNL_TXT       EOL

#define _RT_BANNER_TXT     "runtime error "


#endif  /* _INC_CMSGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\ctime.h ===
/***
*ctime.h - constant for dates and times
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Include file used by the c time routines containing definitions of
*       various constants and macros used in determining dates and times.
*
*       [Internal]
*
*Revision History:
*       03-??-84  RLB   written
*       05-??-84  DFW   split out the constant from each routine into this file
*       07-27-89  GJF   Fixed copyright
*       10-30-89  GJF   Fixed copyright (again)
*       02-28-90  GJF   Added #ifndef _INC_CTIME stuff.
*       03-29-93  GJF   Revised constants.
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*       05-07-97  GJF   Added _MAX_YEAR64 and _MAX_TIME64_T constants. Added
*                       _IS_LEAP_YEAR() and _ELAPSED_LEAP_YEAR macros. Took
*                       out unnecessary casts.
*       02-09-98  GJF   Changes for Win64: removed unnecessary typing of 
*                       constants as long, also put in larger value for 
*                       _MAX_YEAR.
*       12-10-99  GB    _MAX_YEAR for Win64 be equal to _MAX_YEAR64 
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CTIME
#define _INC_CTIME

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

/*
 * Constants
 */
#define _DAY_SEC           (24 * 60 * 60)       /* secs in a day */

#define _YEAR_SEC          (365 * _DAY_SEC)     /* secs in a year */

#define _FOUR_YEAR_SEC     (1461 * _DAY_SEC)    /* secs in a 4 year interval */

#define _DEC_SEC           315532800            /* secs in 1970-1979 */

#define _BASE_YEAR         70                   /* 1970 is the base year */

#define _BASE_DOW          4                    /* 01-01-70 was a Thursday */

#define _LEAP_YEAR_ADJUST  17                   /* Leap years 1900 - 1970 */

#ifdef  _WIN64
#define _MAX_YEAR          1099                 /* 2999 is the max year */
#else
#define _MAX_YEAR          138                  /* 2038 is the max year */
#endif

#define _MAX_YEAR64        1099                 /* 2999 is the max year */

#define _MAX__TIME64_T     0x100000000000i64    /* number of seconds from 
                                                   00:00:00, 01/01/1970 UTC to
                                                   23:59:59. 12/31/2999 UTC */

/*
 * Macro to determine if a given year, expressed as the number of years since
 * 1900, is a leap year.
 */
#define _IS_LEAP_YEAR(y)        (((y % 4 == 0) && (y % 100 != 0)) || \
                                ((y + 1900) % 400 == 0))

/*
 * Number of leap years from 1970 up to, but not including, the specified year
 * (expressed as the number of years since 1900).
 */
#define _ELAPSED_LEAP_YEARS(y)  (((y - 1)/4) - ((y - 1)/100) + ((y + 299)/400) \
                                - _LEAP_YEAR_ADJUST)

#endif  /* _INC_CTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
*Revision History:
*       07-27-87  SKS   Added inpw(), outpw()
*       08-05-87  SKS   Change outpw() from "int" return to "unsigned"
*       11-16-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_loadds" functionality
*       12-17-87  JCR   Added _MTHREAD_ONLY
*       12-18-87  JCR   Added _FAR_ to declarations
*       02-10-88  JCR   Cleaned up white space
*       08-19-88  GJF   Modified to also work for the 386 (small model only)
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       07-27-89  GJF   Cleanup, now specific to the 386
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       11-17-89  GJF   Added const to appropriate arg types of cprintf(),
*                       cputs() and cscanf().
*       02-27-90  GJF   Added #ifndef _INC_CONIO and #include <cruntime.h>
*                       stuff. Also, removed some (now) useless preprocessor
*                       directives.
*       03-21-90  GJF   Replaced _cdecl with _CALLTYPE1 or _CALLTYPE2 in
*                       prototypes.
*       07-23-90  SBM   Added _getch_lk() prototype/macro
*       01-16-91  GJF   ANSI support. Also, removed prototypes for port i/o
*                       functions (not supported in 32-bit).
*       08-20-91  JCR   C++ and ANSI naming
*       09-28-91  JCR   ANSI names: DOSX32=prototypes, WIN32=#defines for now
*       08-26-92  GJF   Function calling type and variable type macros.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Use link-time aliases for old names, not #define's
*       04-09-93  GJF   Restored prototypes for port i/o.
*       04-13-93  GJF   Change port i/o prototypes per ChuckM.
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       10-27-93  GJF   Made port i/o prototypes conditional on _M_IX86.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       05-24-95  CFW   Header not for use with Mac.
*       12-14-95  JWM   Add "#pragma once".
*       01-23-97  GJF   Cleaned out obsolete support for _NTSDK and _CRTAPI*.
*                       Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       02-11-00  GB    Added support for unicode console output functions.
*       04-25-00  GB    Added support for unicode console input functions.
*       07-20-00  GB    typedefed wint_t to unsigned short
*       11-22-00  PML   Wide-char *putwc* functions take a wchar_t, not wint_t.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CONIO
#define _INC_CONIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef  _M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef  _M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);

#ifdef  _MT                                                 /* _MTHREAD_ONLY */
int __cdecl _getch_lk(void);                                /* _MTHREAD_ONLY */
int __cdecl _getche_lk(void);                               /* _MTHREAD_ONLY */
int __cdecl _putch_lk(int);                                 /* _MTHREAD_ONLY */
int __cdecl _ungetch_lk(int);                               /* _MTHREAD_ONLY */
#else                                                       /* _MTHREAD_ONLY */
#define _getch_lk()             _getch()                    /* _MTHREAD_ONLY */
#define _getche_lk()            _getche()                   /* _MTHREAD_ONLY */
#define _putch_lk(c)            _putch(c)                   /* _MTHREAD_ONLY */
#define _ungetch_lk(c)          _ungetch(c)                 /* _MTHREAD_ONLY */
#endif                                                      /* _MTHREAD_ONLY */

#ifndef _WCONIO_DEFINED

/* wide function prototypes, also declared in wchar.h */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);

#ifdef  _MT                                                 /* _MTHREAD_ONLY */
wint_t __cdecl _putwch_lk(wchar_t);                         /* _MTHREAD_ONLY */
wint_t __cdecl _getwch_lk();                                /* _MTHREAD_ONLY */
wint_t __cdecl _getwche_lk();                               /* _MTHREAD_ONLY */
wint_t __cdecl _ungetwch_lk(wint_t);                        /* _MTHREAD_ONLY */
#else   /* ndef _MT */                                      /* _MTHREAD_ONLY */
#define _putwch_lk(c)           _putwch(c)                  /* _MTHREAD_ONLY */
#define _getwch_lk()            _getwch()                   /* _MTHREAD_ONLY */
#define _getwche_lk()           _getwche()                  /* _MTHREAD_ONLY */
#define _ungetwch_lk(c)         _ungetwch(c)                /* _MTHREAD_ONLY */
#endif  /* _MT */                                           /* _MTHREAD_ONLY */

#define _WCONIO_DEFINED
#endif  //_WCONIO_DEFINED

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef  _M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef  _M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
*Revision History:
*       08-16-94  CFW   Module created.
*       11-28-94  CFW   Add DumpClient, more params for AllocHook.
*       12-08-94  CFW   Use non-win32 names.
*       01-09-95  CFW   Dump client needs size, add _CrtSetBreakAlloc,
*                       use const state pointers.
*       01-10-95  CFW   dbgint.h merge.
*       01-20-94  CFW   Change unsigned chars to chars.
*       01-24-94  CFW   Cleanup: remove unneeded funcs, add _CrtSetDbgFlag.
*       01-24-94  CFW   _CrtDbgReport now returns 1 for debug.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       02-17-95  CFW   new() proto moved from dbgint.h.
*       02-27-95  CFW   Change debug break scheme.
*       03-21-95  CFW   Add _CRT_ASSERT & _delete_client, remove tracking.
*       03-23-95  JWM   Restored tracking.
*       03-28-95  CFW   Remove tracking, export _crtBreakAlloc.
*       04-06-95  CFW   Add malloc -> _malloc_dbg macros.
*       04-10-95  CFW   Define NULL.
*       03-21-95  CFW   Remove _delete_client.
*       03-30-95  CFW   Avoid _CRTDBG_xxx conflicts with MFC.
*       05-11-95  CFW   Move C++ code to its own section.
*       05-12-95  CFW   Use _CrtIsValidPointer & _CrtIsValidHeapPointer.
*       06-08-95  CFW   Add return value parameter to report hook.
*       06-27-95  CFW   Add win32s support for debug libs.
*       07-25-95  CFW   Add win32s support for user visible debug heap variables.
*       09-01-95  GJF   Moved a proto for new up slightly to avoid compiler
*                       error C2660 (Olympus 1015).
*       09-20-95  CFW   Change _RPT0, _RPTF0 to support messages with '%' in them.
*       12-14-95  JWM   Add "#pragma once".
*       01-23-97  GJF   Cleaned out obsolete support for Win32s.
*       04-21-97  JWM   Added 4-parameter operator delete(), required by 6.0 compiler.
*       04-29-97  JWM   Made 4-parameter operator delete() #if _MSC_VER >= 1200.
*       08-14-97  GJF   Strip __p_* prototypes from release version. Also,
*                       moved the constant and type definition out of the ifdef
*                       _DEBUG so they are always defined.
*       01-19-98  JWM   At request of DeanM, made debug prototypes of new & delete
*                       #ifndef _MFC_OVERRIDES_NEW
*       05-22-98  JWM   Added support for new[] & delete[], courtesy of KFrei's RTC work.
*       06-08-98  JWM   Minor cleanups.
*       12-01-98  GJF   More choices for calling _CrtCheckMemory than never or always.
*       12-15-98  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*       08-30-99  PML   Get rid of unprintable character in comment.
*       10-06-99  PML   Add _W64 modifier to types which are 32 bits in Win32,
*                       64 bits in Win64.
*       11-02-99  PML   Add extern "C++" around C++ definitions.
*       11-08-99  PML   Don't mark debug operator new _CRTIMP (vs7#16060).
*       11-16-99  PML   Forward-decl _CrtMemBlockHeader to work around vs7#63059
*       01-04-00  GB    Added support for debug version for _aligned routines
*       02-25-00  PML   _CrtDbgBreak should use __debugbreak if available.
*       05-31-00  PML   Add _CrtReportBlockType (VS7#55049).
*       09-26-00  PML   Fix _ASSERT*, _RPT* to compile /W4 clean (vs7#166894)
*       12-10-00  PML   Non-_DEBUG macro versions of _CrtSet* should not be
*                       typed as void (vs7#166572).
*       03-21-01  PML   Add _CrtSetReportHook2 (vs7#124998)
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 /*IFSTRIP=IGN*/
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

/*
 * Some bit values for _crtDbgFlag which correspond to frequencies for checking
 * the the heap.
 */
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000  /* check heap every 16 heap ops */
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000  /* check heap every 128 heap ops */
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000  /* check heap every 1024 heap ops */
#define _CRTDBG_CHECK_DEFAULT_DF    _CRTDBG_CHECK_EVERY_1024_DF

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[_MAX_BLOCKS];
        size_t lSizes[_MAX_BLOCKS];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _aligned_malloc_dbg(s, a, f, l)     _aligned_malloc(s, a)
#define _aligned_realloc_dbg(p, s, a, f, l) _aligned_realloc(p, s, a)
#define _aligned_free_dbg(p)                _aligned_free(p)
#define _aligned_offset_malloc_dbg(s, a, o, f, l)       _aligned_offset_malloc(s, a, o)
#define _aligned_offset_realloc_dbg(p, s, a, o, f, l)   _aligned_offset_realloc(p, s, a, o)

#define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook2(t, f)            ((int)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((_HFILE)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
#define _CrtReportBlockType(p)              ((int)-1)

#define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

#ifndef _INTERNAL_IFSTRIP_
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP long * __cdecl __p__crtAssertBusy(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportHook2(
        int,
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE) /*IFSTRIP=IGN*/
#define _ASSERT_BASE(expr, msg) \
        (void) ((expr) || \
                (1 != _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg)) || \
                (_CrtDbgBreak(), 0))
#else
#define _ASSERT_BASE(expr, msg) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg))) \
             _CrtDbgBreak(); } while (0)
#endif

#define _ASSERT(expr)   _ASSERT_BASE((expr), NULL)

#define _ASSERTE(expr)  _ASSERT_BASE((expr), #expr)

/* Reports with no file/line info */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE) /*IFSTRIP=IGN*/
#define _RPT_BASE(args) \
        (void) ((1 != _CrtDbgReport args) || \
                (_CrtDbgBreak(), 0))
#else
#define _RPT_BASE(args) \
        do { if ((1 == _CrtDbgReport args)) \
                _CrtDbgBreak(); } while (0)
#endif

#define _RPT0(rptno, msg) \
        _RPT_BASE((rptno, NULL, 0, NULL, "%s", msg))

#define _RPT1(rptno, msg, arg1) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1))

#define _RPT2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2))

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, "%s", msg))

#define _RPTF1(rptno, msg, arg1) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1))

#define _RPTF2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))

#if     _MSC_VER >= 1300 && !defined(_CRT_PORTABLE) /*IFSTRIP=IGN*/
#define _CrtDbgBreak() __debugbreak()
#elif   defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtDbgBreak() _BPT()
#elif   defined(_M_IA64) && !defined(_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtDbgBreak() __break(0x80016)
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)
#define   _aligned_malloc(s, a)                 _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
#define   _aligned_realloc(p, s, a)             _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
#define   _aligned_offset_malloc(s, a, o)       _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
#define   _aligned_offset_realloc(p, s, a, o)   _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
#define   _aligned_free(p)  _aligned_free_dbg(p)

#endif  /* _CRTDBG_MAP_ALLOC */

#ifndef _INTERNAL_IFSTRIP_
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP long * __cdecl __p__crtBreakAlloc(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );

_CRTIMP void * __cdecl _aligned_malloc_dbg(
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_realloc_dbg(
        void *,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_malloc_dbg(
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_realloc_dbg(
        void *,
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void __cdecl _aligned_free_dbg(
        void *
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

#ifndef _INTERNAL_IFSTRIP_
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP int * __cdecl __p__crtDbgFlag(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );

_CRTIMP int __cdecl _CrtReportBlockType(
        const void *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

extern "C++" {

#pragma warning(disable: 4507)  /* Ignore faulty warning */

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

 
void * __cdecl operator new[](size_t);

inline void * __cdecl operator new(size_t s, int, const char *, int)
        { return ::operator new(s); }

inline void* __cdecl operator new[](size_t s, int, const char *, int)
        { return ::operator new[](s); }

#if     _MSC_VER >= 1200 /*IFSTRIP=IGN*/


void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/
 
void * __cdecl operator new[](size_t);

void * __cdecl operator new(
        size_t,
        int,
        const char *,
        int
        );

void * __cdecl operator new[](
        size_t,
        int,
        const char *,
        int
        );

#if     _MSC_VER >= 1200 /*IFSTRIP=IGN*/
void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }

inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void * __cdecl operator new(size_t s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

inline void* __cdecl operator new[](size_t s)
        { return ::operator new[](s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

}

#endif  /* _MFC_OVERRIDES_NEW */

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
*Revision History:
*       07-31-87  PHG   changed (unsigned char)(c) to (0xFF & (c)) to
*                       suppress -W2 warning
*       08-07-87  SKS   Removed (0xFF & (c)) -- is????() functions take an (int)
*       12-18-87  JCR   Added _FAR_ to declarations
*       01-19-87  JCR   DLL routines
*       02-10-88  JCR   Cleaned up white space
*       08-19-88  GJF   Modify to also work for the 386 (small model only)
*       12-08-88  JCR   DLL now access _ctype directly (removed DLL routines)
*       03-26-89  GJF   Brought into sync with CRT\H\CTYPE.H
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       07-28-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*       10-30-89  GJF   Fixed copyright, removed dummy args from prototypes
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       02-28-90  GJF   Added #ifndef _INC_CTYPE and #include <cruntime.h>
*                       stuff. Also, removed #ifndef _CTYPE_DEFINED stuff and
*                       some other (now) useless preprocessor directives.
*       03-22-90  GJF   Replaced _cdecl with _CALLTYPE1 in prototypes and
*                       with _VARTYPE1 in variable declarations.
*       01-16-91  GJF   ANSI naming.
*       03-21-91  KRS   Added isleadbyte macro.
*       08-20-91  JCR   C++ and ANSI naming
*       09-28-91  JCR   ANSI names: DOSX32=prototypes, WIN32=#defines for now
*       10-11-91  ETC   All under _INTL: isleadbyte/isw* macros, prototypes;
*                       new is* macros; add wchar_t typedef; some intl defines.
*       12-17-91  ETC   ctype width now independent of _INTL, leave original
*                       short ctype table under _NEWCTYPETABLE.
*       01-22-92  GJF   Changed definition of _ctype for users of crtdll.dll.
*       04-06-92  KRS   Changes for new ISO proposal.
*       08-07-92  GJF   Function calling type and variable type macros.
*       10-26-92  GJF   Fixed _pctype and _pwctype for crtdll.
*       01-19-93  CFW   Move to _NEWCTYPETABLE, remove switch.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       02-17-93  CFW   Removed incorrect UNDONE comment and unused code.
*       02-18-93  CFW   Clean up common _WCTYPE_DEFINED section.
*       03-25-93  CFW   _toupper\_tolower now defined when _INTL.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Use link-time aliases for old names, not #define's
*       04-12-93  CFW   Change is*, isw* macros to evaluate args only once.
*       04-14-93  CFW   Simplify MB_CUR_MAX def.
*       05-05-93  CFW   Change is_wctype to iswctype as per ISO.
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       10-14-93  SRW   Add support for _CTYPE_DISABLE_MACROS symbol
*       11-11-93  GJF   Merged in change above (10-14-93).
*       11-22-93  CFW   Wide stuff must be under !__STDC__.
*       11-30-93  CFW   Change is_wctype from #define to proto.
*       12-07-93  CFW   Move wide defs outside __STDC__ check.
*       02-07-94  CFW   Move _isctype proto.
*       04-08-94  CFW   Optimize isleadbyte.
*       04-11-94  GJF   Made MB_CUR_MAX, _pctype and _pwctype into deferences
*                       of function returns for _DLL (for compatiblity with
*                       the Win32s version of msvcrt*.dll). Also,
*                       conditionally include win32s.h for DLL_FOR_WIN32S.
*       05-03-94  GJF   Made declarations of MB_CUR_MAX, _pctype and _pwctype
*                       for _DLL also conditional on _M_IX86.
*       10-18-94  GJF   Added prototypes and macros for _tolower_lk,
*                       _toupper_lk, _towlower_lk and _towupper_lk.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       04-03-95  JCF   Remove #ifdef _WIN32 around wchar_t.
*       10-16-95  GJF   Define _to[w][lower|upper]_lk to be to[w][lower|upper]
*                       for DLL_FOR_WIN32S.
*       12-14-95  JWM   Add "#pragma once".
*       02-22-96  JWM   Merge in PlumHall mods.
*       01-21-97  GJF   Cleaned out obsolete support for Win32s, _NTSDK and
*                       _CRTAPI*. Fixed prototype for __p_pwctype(). Also,
*                       detab-ed.
*       08-14-97  GJF   Strip __p_* prototypes from release version.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       09-10-98  GJF   Added support for per-thread locale information.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       10-25-99  GB    Added chvalidator for debug version. VS7#5695
*       11-08-99  PML   wctype_t is unsigned short, not wchar_t - it's a set
*                       of bitflags, not a wide char.
*       07-20-00  GB    typedefed wint_t to unsigned short
*       08-18-00  GB    changed MACRO __ascii_iswalpha to just work 'A'-'Z'
*                       and 'a' to 'z'.
*       09-06-00  GB    declared _ctype, _pwctype etc as const.
*       01-29-01  GB    Added __pctype_func, __pwctype_func, __mb_cur_max_func
*                       for use with STATIC_STDCPP stuff
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CTYPE
#define _INC_CTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
#ifndef _INTERNAL_IFSTRIP_
_CRTIMP const unsigned short * __cdecl __pctype_func(void);
_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const unsigned short ** __cdecl __p__pctype(void);
_CRTIMP const wctype_t ** __cdecl __p__pwctype(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */


#ifndef _INTERNAL_IFSTRIP_
#ifdef  _MT
struct  threadlocaleinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
extern pthreadlocinfo __ptlocinfo;
pthreadlocinfo __cdecl __updatetlocinfo(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);
_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX
#ifndef _INTERNAL_IFSTRIP_
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP int * __cdecl __p___mb_cur_max(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Introduced to detect error when character testing functions are called
 * with illegal input of integer.
 */
#ifdef _DEBUG
_CRTIMP int __cdecl _chvalidator(int, int);
#define __chvalidchk(a,b)       _chvalidator(a,b)
#else
#define __chvalidchk(a,b)       (_pctype[a] & (b))
#endif


#ifndef _INTERNAL_IFSTRIP_
#define __ascii_isalpha(c)      ( __chvalidchk(c, _ALPHA))
#define __ascii_isdigit(c)      ( __chvalidchk(c, _DIGIT))
#define __ascii_tolower(c)      ( (((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c) )
#define __ascii_toupper(c)      ( (((c) >= 'a') && ((c) <= 'z')) ? ((c) - 'a' + 'A') : (c) )
#define __ascii_iswalpha(c)     ( ('A' <= (c) && (c) <= 'Z') || ( 'a' <= (c) && (c) <= 'z'))
#define __ascii_iswdigit(c)     ( '0' <= (c) && (c) <= '9')
#define __ascii_towlower(c)     ( (((c) >= L'A') && ((c) <= L'Z')) ? ((c) - L'A' + L'a') : (c) )
#define __ascii_towupper(c)     ( (((c) >= L'a') && ((c) <= L'z')) ? ((c) - L'a' + L'A') : (c) )
#endif  /* _INTERNAL_IFSTRIP_ */

#ifndef _MT
#ifndef __cplusplus
#define isalpha(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : __chvalidchk(_c, _ALPHA))
#define isupper(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : __chvalidchk(_c, _UPPER))
#define islower(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : __chvalidchk(_c, _LOWER))
#define isdigit(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : __chvalidchk(_c, _DIGIT))
#define isxdigit(_c)    (MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : __chvalidchk(_c, _HEX))
#define isspace(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : __chvalidchk(_c, _SPACE))
#define ispunct(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : __chvalidchk(_c, _PUNCT))
#define isalnum(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : __chvalidchk(_c, (_ALPHA|_DIGIT)))
#define isprint(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_BLANK|_PUNCT|_ALPHA|_DIGIT)))
#define isgraph(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_PUNCT|_ALPHA|_DIGIT)))
#define iscntrl(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : __chvalidchk(_c, _CONTROL))
#elif   0         /* Pending ANSI C++ integration */
inline int isalpha(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA) : __chvalidchk(_C, _ALPHA)); }
inline int isupper(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_UPPER) : __chvalidchk(_C, _UPPER)); }
inline int islower(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_LOWER) : __chvalidchk(_C, _LOWER)); }
inline int isdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_DIGIT) : __chvalidchk(_C, _DIGIT)); }
inline int isxdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_HEX)   : __chvalidchk(_C, _HEX)); }
inline int isspace(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_SPACE) : __chvalidchk(_C, _SPACE)); }
inline int ispunct(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT) : __chvalidchk(_C, _PUNCT)); }
inline int isalnum(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA|_DIGIT)
                : __chvalidchk(_C) , (_ALPHA|_DIGIT)); }
inline int isprint(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_BLANK|_PUNCT|_ALPHA|_DIGIT))); }
inline int isgraph(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_PUNCT|_ALPHA|_DIGIT))); }
inline int iscntrl(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_CONTROL)
                : __chvalidchk(_C , _CONTROL)); }
#endif  /* __cplusplus */
#endif  /* _MT */

#ifdef _MT                                                                          /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
#ifdef _DEBUG                                                                       /* _MTHREAD_ONLY */
int __cdecl _chvalidator_mt(pthreadlocinfo, int, int);                              /* _MTHREAD_ONLY */
#define __chvalidchk_mt(p, a, b)  _chvalidator_mt(p, a, b)                          /* _MTHREAD_ONLY */
#else                                                                               /* _MTHREAD_ONLY */
#define __chvalidchk_mt(p, a, b)  (p->pctype[a] & (b))                              /* _MTHREAD_ONLY */
#endif  /* DEBUG */                                                                 /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
int __cdecl __isctype_mt(pthreadlocinfo, int, int);                                 /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
#define __ischartype_mt(p, c, a)    ( p->mb_cur_max > 1 ? __isctype_mt(p, c, (a)) : __chvalidchk_mt(p,c,a))    /* _MTHREAD_ONLY */
#define __isalpha_mt(p, c)      __ischartype_mt(p, c, _ALPHA)                       /* _MTHREAD_ONLY */
#define __isupper_mt(p, c)      __ischartype_mt(p, c, _UPPER)                       /* _MTHREAD_ONLY */
#define __islower_mt(p, c)      __ischartype_mt(p, c, _LOWER)                       /* _MTHREAD_ONLY */
#define __isdigit_mt(p, c)      __ischartype_mt(p, c, _DIGIT)                       /* _MTHREAD_ONLY */
#define __isxdigit_mt(p, c)     __ischartype_mt(p, c, _HEX)                         /* _MTHREAD_ONLY */
#define __isspace_mt(p, c)      __ischartype_mt(p, c, _SPACE)                       /* _MTHREAD_ONLY */
#define __ispunct_mt(p, c)      __ischartype_mt(p, c, _PUNCT)                       /* _MTHREAD_ONLY */
#define __isalnum_mt(p, c)      __ischartype_mt(p, c, _ALPHA|_DIGIT)                /* _MTHREAD_ONLY */
#define __isprint_mt(p, c)      __ischartype_mt(p, c, _BLANK|_PUNCT|_ALPHA|_DIGIT)  /* _MTHREAD_ONLY */
#define __isgraph_mt(p, c)      __ischartype_mt(p, c, _PUNCT|_ALPHA|_DIGIT)         /* _MTHREAD_ONLY */
#define __iscntrl_mt(p, c)      __ischartype_mt(p, c, _CONTROL)                     /* _MTHREAD_ONLY */
#define __isleadbyte_mt(p, c)   (p->pctype[(unsigned char)(c)] & _LEADBYTE)         /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
#endif /* _MT */                                                                    /* _MTHREAD_ONLY */

#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )

#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )
#define isleadbyte(_c)  ( _pctype[(unsigned char)(_c)] & _LEADBYTE)
#elif   0         /* __cplusplus */
inline int iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

#ifdef  _MT                                                                         /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
int __cdecl __iswctype_mt(pthreadlocinfo, wchar_t, wctype_t);                       /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
#define __iswupper_mt(p, _c)    ( __iswctype_mt(p, _c,_UPPER) )                     /* _MTHREAD_ONLY */
#define __iswlower_mt(p, _c)    ( __iswctype_mt(p, _c,_LOWER) )                     /* _MTHREAD_ONLY */
#define __iswspace_mt(p, _c)    ( __iswctype_mt(p, _c,_SPACE) )                     /* _MTHREAD_ONLY */
#endif                                                                              /* _MTHREAD_ONLY */


/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#endif  /* _CTYPE_DISABLE_MACROS */

#ifdef  _MT                                                 /* _MTHREAD_ONLY */
int __cdecl __tolower_mt(pthreadlocinfo, int);              /* _MTHREAD_ONLY */
int __cdecl __toupper_mt(pthreadlocinfo, int);              /* _MTHREAD_ONLY */
wchar_t __cdecl __towlower_mt(pthreadlocinfo, wchar_t);     /* _MTHREAD_ONLY */
wchar_t __cdecl __towupper_mt(pthreadlocinfo, wchar_t);     /* _MTHREAD_ONLY */
#else                                                       /* _MTHREAD_ONLY */
#define __tolower_mt(p, c)  tolower(c)                      /* _MTHREAD_ONLY */
#define __toupper_mt(p, c)  toupper(c)                      /* _MTHREAD_ONLY */
#define __towlower_mt(p, c) towlower(c)                     /* _MTHREAD_ONLY */
#define __towupper_mt(p, c) towupper(c)                     /* _MTHREAD_ONLY */
#endif                                                      /* _MTHREAD_ONLY */

#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif


#endif  /* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\cvt.h ===
/***
*cvt.h - definitions used by formatting routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       cvt.h contains definitions used by the formatting routines [efg]cvt and
*       _output and _input.  The value of CVTBUFSIZE is used to dimension
*       arrays used to hold the maximum size double precision number plus some
*       slop to aid in formatting.
*
*       [Internal]
*
*Revision History:
*       12-11-87  JCR   Added "_loadds" functionality
*       02-10-88  JCR   Cleaned up white space
*       07-28-89  GJF   Fixed copyright
*       10-30-89  GJF   Fixed copyright (again)
*       02-28-90  GJF   Added #ifndef _INC_CVT stuff. Also, removed some
*                       (now) useless preprocessor directives.
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       06-23-95  GJF   Added leading '_' to several macros to avoid conflict
*                       with macros in win*.h.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CVT
#define _INC_CVT

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define _SHORT  1
#define _LONG   2
#define _USIGN  4
#define _NEAR   8
#define _FAR    16

#define OCTAL   8
#define DECIMAL 10
#define HEX     16

#define MUL10(x)        ( (((x)<<2) + (x))<<1 )
#define ISDIGIT(c)      ( ((c) >= '0') && ((c) <= '9') )

#define CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop */

#endif  /* _INC_CVT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\h\dbgint.h ===
/***
*dbgint.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Internal]
*
*Revision History:
*       08-16-94  CFW   Module created.
*       11-28-94  CFW   Add DumpClient.
*       12-05-94  CFW   Fix debug new handler support, clean up macros.
*       12-06-94  CFW   Export _CrtThrowMemoryException.
*       12-08-94  CFW   Export _assertfailed.
*       01-05-95  CFW   Asserts are errors, add report hook.
*       01-05-95  CFW   Filename pointers are const.
*       01-10-95  CFW   Lots moved to crtdbg.h
*       01-11-95  CFW   Add _xxxx_crt macros.
*       01-13-95  CFW   Add new() support.
*       01-20-94  CFW   Change unsigned chars to chars.
*       02-14-95  CFW   Clean up Mac merge.
*       02-17-95  CFW   new() proto moved to crtdbg.h.
*       03-21-95  CFW   Add _delete_crt.
*       03-29-95  CFW   Add error message to internal headers.
*       03-21-95  CFW   Remove _delete_crt, add _BLOCK_TYPE_IS_VALID.
*       06-27-95  CFW   Add win32s support for debug libs.
*       12-14-95  JWM   Add "#pragma once".
*       04-17-96  JWM   Make _CrtSetDbgBlockType() _CRTIMP (for msvcirtd.dll).
*       02-05-97  GJF   Removed use of obsolete DLL_FOR_WIN32S.
*       01-04-00  GB    Added support for debug version of _aligned routines.
*       08-25-00  PML   Reverse _CrtMemBlockHeader fields nDataSize and
*                       nBlockUse on Win64 so size % 16 == 0 (vs7#153113).
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_DBGINT
#define _INC_DBGINT

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif /* _CRTBLD */

#include <crtdbg.h>

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#ifdef  __cplusplus

#define _new_crt                        new

#endif  /* __cplusplus */

#define _malloc_crt                     malloc
#define _calloc_crt                     calloc
#define _realloc_crt                    realloc
#define _expand_crt                     _expand
#define _free_crt                       free
#define _msize_crt                      _msize


#define _malloc_base                    malloc
#define _nh_malloc_base                 _nh_malloc
#define _nh_malloc_dbg(s, n, t, f, l)   _nh_malloc(s, n)
#define _heap_alloc_base                _heap_alloc
#define _heap_alloc_dbg(s, t, f, l)     _heap_alloc(s)
#define _calloc_base                    calloc
#define _realloc_base                   realloc
#define _expand_base                    _expand
#define _free_base                      free
#define _msize_base                     _msize
#define _aligned_malloc_base            _aligned_malloc
#define _aligned_realloc_base           _aligned_realloc
#define _aligned_offset_malloc_base     _aligned_offset_malloc
#define _aligned_offset_realloc_base    _aligned_offset_realloc
#define _aligned_free_base              _aligned_free

#ifdef  _MT

#define _calloc_dbg_lk(c, s, t, f, l)   _calloc_lk(c, s)
#define _realloc_dbg_lk(p, s, t, f, l)  _realloc_lk(p, s)
#define _free_base_lk                   _free_lk
#define _free_dbg_lk(p, t)              _free_lk(p)

#else   /* ndef _MT */

#define _calloc_dbg_lk(c, s, t, f, l)   calloc(c, s)
#define _realloc_dbg_lk(p, s, t, f, l)  realloc(p, s)
#define _free_base_lk                   free
#define _free_dbg_lk(p, t)              free(p)

#endif  /* _MT */


#else   /* _DEBUG */


 /***************************************************************************