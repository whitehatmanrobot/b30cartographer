ansferToKernel(
    IN PTRANSFER_ROUTINE SystemEntry,
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )

/*++

Routine Description:

    This routine prepares the AMD64 data structures required for kernel
    execution, including page table structures and 64-bit loader block,
    and transfers control to the kernel.

    This routine returns only upon an error.

Arguments:

    SystemEntry - Pointer to the kernel entry point.

    BlLoaderBlock - Pointer to the 32-bit loader block structure.

Return Value:

    No return on success.  On failure, returns the status of the operation.

--*/

{

    BlAmd64LoaderParameterBlock = PTR_64(BlAmd64LoaderBlock64);
    BlAmd64KernelEntry = PTR_64(SystemEntry);

    DbgPrint("BlAmd64TransferToKernel():\n"
             "    BlAmd64LoaderParameterBlock = 0x%08x%08x\n"
             "    BlAmd64KernelEntry = 0x%08x%08x\n",

             (ULONG)(BlAmd64LoaderParameterBlock >> 32),
             (ULONG)BlAmd64LoaderParameterBlock,

             (ULONG)(BlAmd64KernelEntry >> 32),
             (ULONG)BlAmd64KernelEntry );

    BlAmd64SwitchToLongMode();

    return EINVAL;
}


ARC_STATUS
BlAmd64PrepForTransferToKernelPhase1(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )

/*++

Routine Description:

    This routine prepares the AMD64 data structures required for kernel
    execution, including page table structures and 64-bit loader block.

    This is the first of two phases of preperation.  This phase is executed
    while heap and descriptor allocations are still permitted.

Arguments:

    BlLoaderBlock - Pointer to the 32-bit loader block structure.

Return Value:

    No return on success.  On failure, returns the status of the operation.

--*/

{
    ARC_STATUS status;

    //
    // This is the main routine called to do preperatory work before
    // transitioning into the AMD64 kernel.
    //

    BlAmd64LoaderBlock32 = BlLoaderBlock;

    //
    // Build a 64-bit copy of the loader parameter block.
    //

    status = BlAmd64BuildLoaderBlock64();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Process the loaded modules.
    //

    status = BlAmd64TransferLoadedModuleState();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Next the boot driver nodes
    //

    status = BlAmd64TransferBootDriverNodes();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // NLS data
    //

    status = BlAmd64TransferNlsData();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Configuration component data tree
    //

    status = BlAmd64TransferConfigurationComponentData();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // ARC disk information
    //

    status = BlAmd64TransferArcDiskInformation();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Setup loader block
    //

    status = BlAmd64TransferSetupLoaderBlock();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Allocate structures needed by the kernel: KPCR etc.
    //

    status = BlAmd64PrepareSystemStructures();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Pre-allocate any pages needed for the long mode paging structures.
    //

    status = BlAmd64BuildMappingPhase1();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Pre-allocate the 64-bit memory allocation descriptors that will be
    // used by BlAmd64TransferMemoryAllocationDescriptors().
    //

    status = BlAmd64AllocateMemoryAllocationDescriptors();
    if (status != ESUCCESS) {
        return status;
    }

    return status;
}

VOID
BlAmd64PrepForTransferToKernelPhase2(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )

/*++

Routine Description:

    This routine prepares the AMD64 data structures required for kernel
    execution, including page table structures and 64-bit loader block.

    This is the second of two phases of preperation.  This phase is executed
    after the 32-bit page tables have been purged of any unused mappings.

    Note that descriptor and heap allocations are not permitted at this
    point.  Any necessary storage must have been preallocated during phase 1.


Arguments:

    BlLoaderBlock - Pointer to the 32-bit loader block structure.

Return Value:

    No return on success.  On failure, returns the status of the operation.

--*/

{
    PLOADER_PARAMETER_EXTENSION_64 extension;
    ARC_STATUS status;

    //
    // At this point everything has been preallocated, nothing can fail.
    //

    status = BlAmd64BuildMappingPhase2();
    ASSERT(status == ESUCCESS);

    //
    // Transfer the memory descriptor state.
    //

    status = BlAmd64TransferMemoryAllocationDescriptors();
    ASSERT(status == ESUCCESS);

    //
    // Set LoaderPagesSpanned in the 64-bit loader block.
    //

    extension = PTR_32(BlAmd64LoaderBlock64->Extension);
    extension->LoaderPagesSpanned = BlHighestPage+1;
}

ARC_STATUS
BlAmd64BuildMappingPhase1(
    VOID
    )

/*++

Routine Description:

    This routine performs the first of the two-phase long mode mapping
    structure creation process now, while memory allocations are still
    possible.  It simply calls BlAmd64BuilMappingWorker() which in fact
    creates the mapping structures, and (more importantly) allocates all
    of the page tables required to do so.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ARC_STATUS status;

    //
    // While it is possible to perform memory allocations, reserve enough
    // page tables to build the AMD64 paging structures.
    //
    // The easiest way to calculate the maximum number of pages needed is
    // to actually build the structures.  We do that now with the first of
    // two calls to BlAmd64BuildMappingWorker().
    // 

    status = BlAmd64BuildMappingWorker();
    if (status != ESUCCESS) {
        return status;
    }

    return ESUCCESS;
}

ARC_STATUS
BlAmd64BuildMappingPhase2(
    VOID
    )

/*++

Routine Description:

    This routine performs the second of the two-phase long mode mapping
    structure creation process.  All page tables will have been preallocated
    as a result of the work performed by BlAmd64BuildMappingPhase1().

Arguments:

    None.

Return Value:

    None.

--*/

{
    ARC_STATUS status;

    //
    // Reset the Amd64 paging structures
    // 

    BlAmd64ResetPageTableHeap();

    //
    // All necessary page tables can now be found on BlAmd64FreePfnList.
    // On this, the second call to BlAmd64BuildMappingWorker(), those are the
    // pages that will be used to perform the mapping.
    // 

    status = BlAmd64BuildMappingWorker();
    if (status != ESUCCESS) {
        return status;
    }

    return ESUCCESS;
}

ARC_STATUS
BlAmd64BuildMappingWorker(
    VOID
    )

/*++

Routine Description:

    This routine creates any necessary memory mappings in the long-mode
    page table structure.  It is called twice, once from
    BlAmd64BuildMappingPhase1() and again from BlAmd64BuildMappingPhase2().

    Any additional memory mapping that must be carried out should go in
    this routine.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ARC_STATUS status;
    PFN_NUMBER pfn;

    //
    // Any long mode mapping code goes here.  This routine is called twice:
    // once from BlAmd64BuildMappingPhase1(), and again from
    // BlAmd64BuildMappingPhase2().
    // 

    //
    // Transfer any mappings in the first 32MB of identity mapping.
    //

    status = BlAmd64MapMemoryRegion( 0,
                                     32 * 1024 * 1024 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Transfer any mappings in the 1GB region starting at KSEG0_BASE_X86.
    //

    status = BlAmd64MapMemoryRegion( KSEG0_BASE_X86,
                                     0x40000000 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // "Map" the HAL va
    //

    status = BlAmd64MapHalVaSpace();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Map the shared user data page
    //

    BlAmd64IsPageMapped( KI_USER_SHARED_DATA, &pfn, NULL );

    status = BlAmd64CreateMapping( KI_USER_SHARED_DATA_64, pfn );
    if (status != ESUCCESS) {
        return status;
    }

    return ESUCCESS;
}


VOID
BlAmd64ResetPageTableHeap(
    VOID
    )

/*++

Routine Description:

    This function is called as part of the two-phase page table creation
    process.  Its purpose is to move all of the PFNs required to build
    the long mode page tables back to the free list, and to otherwise
    initialize the long mode paging structure.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PPT_NODE ptNodeLast;

    //
    // Move the page table nodes from the busy list to the free list.
    //

    if (BlAmd64BusyPfnList != NULL) {

        //
        // A tail pointer is not kept, so find the tail node here.
        //

        ptNodeLast = BlAmd64BusyPfnList;
        while (ptNodeLast->Next != NULL) {
            ptNodeLast = ptNodeLast->Next;
        }

        ptNodeLast->Next = BlAmd64FreePfnList;
        BlAmd64FreePfnList = BlAmd64BusyPfnList;
        BlAmd64BusyPfnList = NULL;
    }

    //
    // Zero the top-level pte declared in amd64.c
    //

    BlAmd64ClearTopLevelPte();
}

ARC_STATUS
BlAmd64TransferHardwareIdList(
    IN  PPNP_HARDWARE_ID HardwareId,
    OUT POINTER64 *HardwareIdDatabaseList64
    )

/*++

Routine Description:

    This routine walks the singly-linked list of PNP_HARDWARE_ID structures
    and for each one found, creates a 64-bit PNP_HARDWARE_ID_64 structure and
    inserts it on a list of same.

    The resultant 64-bit list is in the same order as the supplied 32-bit
    list.

Arguments:

    HardwareId - Supplies a pointer to the head of the singly-linked list of
                 PNP_HARDWARE_ID structures.

    HardwareIdDatabaseList64 -
                 Supplies a pointer to a POINTER64 which upon successful
                 completion of this routine will contain a 64-bit KSEG0
                 pointer to the created 64-bit PNP_HARDWARE_ID_64 list.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PPNP_HARDWARE_ID_64 hardwareId64;
    ARC_STATUS status;

    //
    // Walk the id list backwards.  To do this we call ourselves
    // recursively until we find the end of the list, then process the nodes
    // on the way back up.
    //

    if (HardwareId == NULL) {
        return ESUCCESS;
    }

    status = BlAmd64TransferHardwareIdList( HardwareId->Next,
                                            HardwareIdDatabaseList64 );
    if (status != ESUCCESS) {
        return status;
    }

    hardwareId64 = BlAllocateHeap(sizeof(PNP_HARDWARE_ID));
    if (hardwareId64 == NULL) {
        return ENOMEM;
    }

    status = Copy_PNP_HARDWARE_ID( HardwareId, hardwareId64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Link it into the front of the 64-bit list.
    //

    hardwareId64->Next = *HardwareIdDatabaseList64;
    *HardwareIdDatabaseList64 = PTR_64(hardwareId64);

    return ESUCCESS;
}


ARC_STATUS
BlAmd64TransferDeviceRegistryList(
    IN  PDETECTED_DEVICE_REGISTRY DetectedDeviceRegistry32,
    OUT POINTER64 *DetectedDeviceRegistry64
    )

/*++

Routine Description:

    This routine walks the singly-linked list of DETECTED_DEVICE_REGISTRY
    structures and for each one found, creates a 64-bit
    DETECTED_DEVICE_REGISTRY_64 structure and inserts it on a list of same.

    The resultant 64-bit list is in the same order as the supplied 32-bit
    list.

Arguments:

    DetectedDeviceRegistry32 - Supplies a pointer to the head of the singly-linked list of
                 DETECTED_DEVICE_REGISTRY structures.

    DetectedDeviceRegistry64 -
                 Supplies a pointer to a POINTER64 which upon successful
                 completion of this routine will contain a 64-bit KSEG0
                 pointer to the created 64-bit DETECTED_DEVICE_REGISTRY_64
                 list.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PDETECTED_DEVICE_REGISTRY_64 registry64;
    ARC_STATUS status;

    //
    // Walk the registry list backwards.  To do this we call ourselves
    // recursively until we find the end of the list, then process the nodes
    // on the way back up.
    //

    if (DetectedDeviceRegistry32 == NULL) {
        return ESUCCESS;
    }

    status = BlAmd64TransferDeviceRegistryList( DetectedDeviceRegistry32->Next,
                                                DetectedDeviceRegistry64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Allocate a 64-bit registry structure and copy the contents
    // of the 32-bit one in.
    //

    registry64 = BlAllocateHeap(sizeof(DETECTED_DEVICE_REGISTRY_64));
    if (registry64 == NULL) {
        return ENOMEM;
    }

    status = Copy_DETECTED_DEVICE_REGISTRY( DetectedDeviceRegistry32, registry64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Link it into the front of the 64-bit list.
    //

    registry64->Next = *DetectedDeviceRegistry64;
    *DetectedDeviceRegistry64 = PTR_64(registry64);

    return ESUCCESS;
}

ARC_STATUS
BlAmd64TransferDeviceFileList(
    IN  PDETECTED_DEVICE_FILE DetectedDeviceFile32,
    OUT POINTER64 *DetectedDeviceFile64
    )

/*++

Routine Description:

    This routine walks the singly-linked list of DETECTED_DEVICE_FILE
    structures and for each one found, creates a 64-bit
    DETECTED_DEVICE_FILE_64 structure and inserts it on a list of same.

    The resultant 64-bit list is in the same order as the supplied 32-bit
    list.

Arguments:

    DetectedDeviceFile32 - Supplies a pointer to the head of the singly-linked
                 list of DETECTED_DEVICE_FILE structures.

    DetectedDeviceFile64 -
                 Supplies a pointer to a POINTER64 which upon successful
                 completion of this routine will contain a 64-bit KSEG0
                 pointer to the created 64-bit DETECTED_DEVICE_FILE_64
                 list.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PDETECTED_DEVICE_FILE_64 file64;
    ARC_STATUS status;

    //
    // Walk the file list backwards.  To do this we call ourselves
    // recursively until we find the end of the list, then process the nodes
    // on the way back up.
    //

    if (DetectedDeviceFile32 == NULL) {
        return ESUCCESS;
    }

    status = BlAmd64TransferDeviceFileList( DetectedDeviceFile32->Next,
                                            DetectedDeviceFile64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Allocate a 64-bit file structure and copy the contents
    // of the 32-bit one in.
    //

    file64 = BlAllocateHeap(sizeof(DETECTED_DEVICE_FILE_64));
    if (file64 == NULL) {
        return ENOMEM;
    }

    status = Copy_DETECTED_DEVICE_FILE( DetectedDeviceFile32, file64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Transfer the singly-linked list of DETECTED_DEVICE_REGISTRY structures
    // linked to this DETECTED_DEVICE_FILE structure.
    //

    status = BlAmd64TransferDeviceRegistryList(
                    DetectedDeviceFile32->RegistryValueList,
                    &file64->RegistryValueList );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Link it into the front of the 64-bit list.
    //

    file64->Next = *DetectedDeviceFile64;
    *DetectedDeviceFile64 = PTR_64(file64);

    return ESUCCESS;
}

ARC_STATUS
BlAmd64TransferDeviceList(
    IN  PDETECTED_DEVICE  DetectedDevice32,
    OUT POINTER64        *DetectedDeviceList64
    )

/*++

Routine Description:

    This routine walks the singly-linked list of DETECTED_DEVICE
    structures and for each one found, creates a 64-bit
    DETECTED_DEVICE_64 structure and inserts it on a list of same.

    The resultant 64-bit list is in the same order as the supplied 32-bit
    list.

Arguments:

    DetectedDevice32 - Supplies a pointer to the head of the singly-linked
                 list of DETECTED_DEVICE structures.

    DetectedDeviceList64 -
                 Supplies a pointer to a POINTER64 which upon successful
                 completion of this routine will contain a 64-bit KSEG0
                 pointer to the created 64-bit DETECTED_DEVICE_64
                 list.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PDETECTED_DEVICE_64 device64;
    ARC_STATUS status;

    //
    // Walk the device list backwards.  To do this we call ourselves
    // recursively until we find the end of the list, then process the nodes
    // on the way back up.
    //

    if (DetectedDevice32 == NULL) {
        return ESUCCESS;
    }

    status = BlAmd64TransferDeviceList( DetectedDevice32->Next,
                                        DetectedDeviceList64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Allocate a 64-bit device structure and copy the contents
    // of the 32-bit one in.
    //

    device64 = BlAllocateHeap(sizeof(DETECTED_DEVICE_64));
    if (device64 == NULL) {
        return ENOMEM;
    }

    status = Copy_DETECTED_DEVICE( DetectedDevice32, device64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Transfer any PROTECTED_DEVICE_FILE structures
    //

    status = BlAmd64TransferDeviceFileList( DetectedDevice32->Files,
                                            &device64->Files );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Link it into the front of the 64-bit list.
    //

    device64->Next = *DetectedDeviceList64;
    *DetectedDeviceList64 = PTR_64(device64);

    return ESUCCESS;
}

ARC_STATUS
BlAmd64TransferSetupLoaderBlock(
    VOID
    )

/*++

Routine Description:

    This routine creates a SETUP_LOADER_BLOCK_64 structure that is the
    equivalent of the 32-bit SETUP_LOADER_BLOCK structure referenced within
    the 32-bit setup loader block.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PSETUP_LOADER_BLOCK    setupBlock32;
    PSETUP_LOADER_BLOCK_64 setupBlock64;
    ARC_STATUS status;

    setupBlock32 = BlAmd64LoaderBlock32->SetupLoaderBlock;
    if (setupBlock32 == NULL) {
        return ESUCCESS;
    }

    setupBlock64 = BlAllocateHeap(sizeof(SETUP_LOADER_BLOCK_64));
    if (setupBlock64 == NULL) {
        return ENOMEM;
    }

    status = Copy_SETUP_LOADER_BLOCK( setupBlock32, setupBlock64 );
    if (status != ESUCCESS) {
        return status;
    }

    {
        #define TRANSFER_DEVICE_LIST(x)                             \
            setupBlock64->x = PTR_64(NULL);                         \
            status = BlAmd64TransferDeviceList( setupBlock32->x,    \
                                                &setupBlock64->x ); \
            if (status != ESUCCESS) return status;
    
        TRANSFER_DEVICE_LIST(KeyboardDevices);
        TRANSFER_DEVICE_LIST(ScsiDevices);
        TRANSFER_DEVICE_LIST(BootBusExtenders);
        TRANSFER_DEVICE_LIST(BusExtenders);
        TRANSFER_DEVICE_LIST(InputDevicesSupport);
    
        #undef TRANSFER_DEVICE_LIST
    }

    setupBlock64->HardwareIdDatabase = PTR_64(NULL);
    status = BlAmd64TransferHardwareIdList( setupBlock32->HardwareIdDatabase,
                                            &setupBlock64->HardwareIdDatabase );

    return status;
}

ARC_STATUS
BlAmd64TransferArcDiskInformation(
    VOID
    )

/*++

Routine Description:

    This routine creates an ARC_DISK_INFORMATION_64 structure that is the
    equivalent of the 32-bit ARC_DISK_INFORMATION structure referenced within
    the 32-bit loader block.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    ARC_STATUS status;

    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;

    PARC_DISK_INFORMATION diskInfo32;
    PARC_DISK_INFORMATION_64 diskInfo64;

    PARC_DISK_SIGNATURE diskSignature32;
    PARC_DISK_SIGNATURE_64 diskSignature64;

    //
    // Create a 64-bit ARC_DISK_INFORMATION structure
    // 

    diskInfo32 = BlAmd64LoaderBlock32->ArcDiskInformation;
    if (diskInfo32 == NULL) {
        return ESUCCESS;
    }

    diskInfo64 = BlAllocateHeap(sizeof(ARC_DISK_INFORMATION_64));
    if (diskInfo64 == NULL) {
        return ENOMEM;
    }

    status = Copy_ARC_DISK_INFORMATION( diskInfo32, diskInfo64 );
    if (status != ESUCCESS) {
        return status;
    }

    InitializeListHead64( &diskInfo64->DiskSignatures );

    //
    // Walk the 32-bit list of ARC_DISK_SIGNATURE nodes and create
    // a 64-bit version of each
    // 

    listHead = &diskInfo32->DiskSignatures;
    listEntry = listHead->Flink;
    while (listEntry != listHead) {

        diskSignature32 = CONTAINING_RECORD( listEntry,
                                             ARC_DISK_SIGNATURE,
                                             ListEntry );

        diskSignature64 = BlAllocateHeap(sizeof(ARC_DISK_SIGNATURE_64));
        if (diskSignature64 == NULL) {
            return ENOMEM;
        }

        status = Copy_ARC_DISK_SIGNATURE( diskSignature32, diskSignature64 );
        if (status != ESUCCESS) {
            return status;
        }

        InsertTailList64( &diskInfo64->DiskSignatures,
                          &diskSignature64->ListEntry );

        listEntry = listEntry->Flink;
    }

    BlAmd64LoaderBlock64->ArcDiskInformation = PTR_64(diskInfo64);

    return ESUCCESS;
}


ARC_STATUS
BlAmd64TransferConfigurationComponentData(
    VOID
    )

/*++

Routine Description:

    This routine creates a CONFIGURATION_COMPONENT_DATA_64 structure tree
    that is the equivalent of the 32-bit CONFIGURATION_COMPONENT_DATA
    structure tree referenced within the 32-bit loader block.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PCONFIGURATION_COMPONENT_DATA_64 rootComponent64;

    if (BlAmd64LoaderBlock32->ConfigurationRoot == NULL) {
        return ESUCCESS;
    }

    rootComponent64 =
        BlAmd64TransferConfigWorker( BlAmd64LoaderBlock32->ConfigurationRoot,
                                     NULL );

    if (rootComponent64 == NULL) {
        return ENOMEM;
    }

    BlAmd64LoaderBlock64->ConfigurationRoot = PTR_64(rootComponent64);
    return ESUCCESS;
}

PCONFIGURATION_COMPONENT_DATA_64
BlAmd64TransferConfigWorker(
    IN PCONFIGURATION_COMPONENT_DATA    ComponentData32,
    IN PCONFIGURATION_COMPONENT_DATA_64 ComponentDataParent64
    )

/*++

Routine Description:

    Given a 32-bit CONFIGURATION_COMPONENT_DATA structure, this routine
    creates an equivalent 64-bit CONFIGURATION_COMPONENT_DATA structure
    for the supplied structure, as well as for all of its children and
    siblings.

    This routine calls itself recursively for each sibling and child.

Arguments:

    ComponentData32 - Supplies a pointer to the 32-bit structure to transfer.

    ComponentDataParent64 - Supplies a pointer to the current 64-bit parent
    structure.

Return Value:

    Returns a pointer to the created 64-bit structure, or NULL if a failure
    was encountered.

--*/

{
    ARC_STATUS status;
    ULONG componentDataSize64;
    ULONG partialResourceListSize64;
    BOOLEAN thunkResourceList;

    PCONFIGURATION_COMPONENT_DATA    componentData32;
    PCONFIGURATION_COMPONENT_DATA_64 componentData64;
    PCONFIGURATION_COMPONENT_DATA_64 newCompData64;

    //
    // Create and copy configuration component data node
    //

    componentDataSize64 = sizeof(CONFIGURATION_COMPONENT_DATA_64);
    thunkResourceList = BlAmd64ContainsResourceList(ComponentData32,
                                                    &partialResourceListSize64);

    if (thunkResourceList != FALSE) {

        //
        // This node contains a CM_PARTIAL_RESOURCE_LIST structure.
        // partialResourceListSize64 contains the number of bytes beyond the
        // CONFIGURATION_COMPONENT_DATA header that must be allocated in order to
        // thunk the CM_PARTIAL_RESOURCE_LIST into a 64-bit version.
        //

        componentDataSize64 += partialResourceListSize64;
    }

    componentData64 = BlAllocateHeap(componentDataSize64);
    if (componentData64 == NULL) {
        return NULL;
    }

    status = Copy_CONFIGURATION_COMPONENT_DATA( ComponentData32,
                                                componentData64 );
    if (status != ESUCCESS) {
        return NULL;
    }

    if (thunkResourceList != FALSE) {

        //
        // Update the configuration component data size
        //

        componentData64->ComponentEntry.ConfigurationDataLength =
            partialResourceListSize64;
    }

    componentData64->Parent = PTR_64(ComponentDataParent64);

    if (thunkResourceList != FALSE) {

        //
        // Now transfer the resource list.
        //

        BlAmd64TransferResourceList(ComponentData32,componentData64);
    }

    //
    // Process the child (and recursively, all children)
    // 

    if (ComponentData32->Child != NULL) {

        newCompData64 = BlAmd64TransferConfigWorker( ComponentData32->Child,
                                                     componentData64 );
        if (newCompData64 == NULL) {
            return newCompData64;
        }

        componentData64->Child = PTR_64(newCompData64);
    }

    //
    // Process the sibling (and recursively, all siblings)
    //

    if (ComponentData32->Sibling != NULL) {

        newCompData64 = BlAmd64TransferConfigWorker( ComponentData32->Sibling,
                                                     ComponentDataParent64 );
        if (newCompData64 == NULL) {
            return newCompData64;
        }

        componentData64->Sibling = PTR_64(newCompData64);
    }

    return componentData64;
}


VOID
BlAmd64TransferResourceList(
    IN  PCONFIGURATION_COMPONENT_DATA ComponentData32,
    OUT PCONFIGURATION_COMPONENT_DATA_64 ComponentData64
    )

/*++

Routine Description:

    This routine transfers the 32-bit CM_PARTIAL_RESOURCE_LIST structure that
    immediately follows ComponentData32 to the memory immediately after
    ComponentData64.

Arguments:

    ComponentData32 - Supplies a pointer to the 32-bit structure to transfer from.

    ComponentData64 - Supplies a pointer to the 64-bit structure to transfer to.

Return Value:

    None.

--*/

{
    PCM_PARTIAL_RESOURCE_LIST resourceList32;
    PCM_PARTIAL_RESOURCE_LIST_64 resourceList64;

    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDesc32;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR_64 resourceDesc64;

    PVOID descBody32;
    PVOID descBody64;

    PUCHAR tail32;
    PUCHAR tail64;
    ULONG tailSize;

    ULONG descriptorCount;

    //
    // Calculate pointers to the source and target descriptor lists.
    //

    resourceList32 = (PCM_PARTIAL_RESOURCE_LIST)ComponentData32->ConfigurationData;
    resourceList64 = (PCM_PARTIAL_RESOURCE_LIST_64)(ComponentData64 + 1);

    //
    // Update ComponentData64 to refer to it's new data area, which will be immediately
    // following the component data structure.
    //

    ComponentData64->ConfigurationData = PTR_64(resourceList64);

    //
    // Copy the resource list header information
    //

    Copy_CM_PARTIAL_RESOURCE_LIST(resourceList32,resourceList64);

    //
    // Now thunk each of the resource descriptors
    //

    descriptorCount = resourceList32->Count;
    resourceDesc32 = resourceList32->PartialDescriptors;
    resourceDesc64 = &resourceList64->PartialDescriptors;

    while (descriptorCount > 0) {

        //
        // Transfer the common header information
        //

        Copy_CM_PARTIAL_RESOURCE_DESCRIPTOR(resourceDesc32,resourceDesc64);
        descBody32 = &resourceDesc32->u;
        descBody64 = &resourceDesc64->u;

        //
        // Transfer the body according to the type
        // 

        switch(resourceDesc32->Type) {
           
            case CmResourceTypeNull:
                break;

            case CmResourceTypePort:
                Copy_CM_PRD_PORT(descBody32,descBody64);
                break;

            case CmResourceTypeInterrupt:
                Copy_CM_PRD_INTERRUPT(descBody32,descBody64);
                break;

            case CmResourceTypeMemory:
                Copy_CM_PRD_MEMORY(descBody32,descBody64);
                break;

            case CmResourceTypeDma:
                Copy_CM_PRD_DMA(descBody32,descBody64);
                break;

            case CmResourceTypeDeviceSpecific:
                Copy_CM_PRD_DEVICESPECIFICDATA(descBody32,descBody64);
                break;

            case CmResourceTypeBusNumber:
                Copy_CM_PRD_BUSNUMBER(descBody32,descBody64);
                break;

            default:
                Copy_CM_PRD_GENERIC(descBody32,descBody64);
                break;
        }

        resourceDesc32 += 1;
        resourceDesc64 += 1;
        descriptorCount -= 1;
    }

    //
    // Calculate how much data, if any, is appended to the resource list.
    //

    tailSize = ComponentData32->ComponentEntry.ConfigurationDataLength +
               (PUCHAR)resourceList32 -
               (PUCHAR)resourceDesc32;

    if (tailSize > 0) {

        //
        // Some data is there, append it as-is to the 64-bit structure.
        //

        tail32 = (PUCHAR)resourceDesc32;
        tail64 = (PUCHAR)resourceDesc64;
        RtlCopyMemory(tail64,tail32,tailSize);
    }
}


BOOLEAN
BlAmd64ContainsResourceList(
    IN PCONFIGURATION_COMPONENT_DATA ComponentData32,
    OUT PULONG ResourceListSize64
    )

/*++

Routine Description:

    Given a 32-bit CONFIGURATION_COMPONENT_DATA structure, this routine
    determines whether the data associated with the structure contains a
    CM_PARTIAL_RESOURCE_LIST structure.

    If it does, the size of the 64-bit representation of this structure is calculated,
    added to any data that might be appended to the resource list structure, and
    returned in ResourceListSize64.

Arguments:

    ComponentData32 - Supplies a pointer to the 32-bit structure to transfer.

    ResourceListSize64 - Supplies a pointer to a ULONG in which the necessary
                         additional data size is returned.

Return Value:

    Returns TRUE if the CONFIGURATION_COMPONENT_DATA stucture refers to a
    CM_PARTIAL_RESOURCE_LIST structure, FALSE otherwise.

--*/

{
    ULONG resourceListSize64;
    ULONG configDataLen;
    PCM_PARTIAL_RESOURCE_LIST resourceList;
    ULONG resourceCount;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR lastResourceDescriptor;

    configDataLen = ComponentData32->ComponentEntry.ConfigurationDataLength;
    if (configDataLen < sizeof(CM_PARTIAL_RESOURCE_LIST)) {

        //
        // Data not large enough to contain the smallest possible resource list
        //

        return FALSE;
    }

    resourceList = (PCM_PARTIAL_RESOURCE_LIST)ComponentData32->ConfigurationData;
    if (resourceList->Version != 0 || resourceList->Revision != 0) {

        //
        // Unrecognized version.
        //

        return FALSE;
    }

    configDataLen -= FIELD_OFFSET(CM_PARTIAL_RESOURCE_LIST,PartialDescriptors);

    resourceCount = resourceList->Count;
    if (configDataLen < sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * resourceCount) {

        //
        // Config data len is not large enough to contain a CM_PARTIAL_RESOURCE_LIST
        // as large as this one claims to be.
        //

        return FALSE;
    }
    
    //
    // Validate each of the CM_PARTIAL_RESOURCE_DESCRIPTOR structures in the list
    //

    resourceDescriptor = resourceList->PartialDescriptors;
    lastResourceDescriptor = resourceDescriptor + resourceCount;

    while (resourceDescriptor < lastResourceDescriptor) {

        if (resourceDescriptor->Type > CmResourceTypeMaximum) {
            return FALSE;
        }

        resourceDescriptor += 1;
    }

    //
    // Looks like this is an actual resource list.  Calculate the size of any remaining
    // data after the CM_PARTIAL_RESOURCE_LIST structure.
    //

    configDataLen -= sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * resourceCount;

    *ResourceListSize64 = sizeof(CM_PARTIAL_RESOURCE_LIST) +
                          sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * (resourceCount - 1) +
                          configDataLen;

    return TRUE;
}

ARC_STATUS
BlAmd64TransferNlsData(
    VOID
    )

/*++

Routine Description:

    This routine creates an NLS_DATA_BLOCK64 structure that is the 
    equivalent of the 32-bit NLS_DATA_BLOCK structure referenced within
    the 32-bit loader block.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    ARC_STATUS status;
    PNLS_DATA_BLOCK    nlsDataBlock32;
    PNLS_DATA_BLOCK_64 nlsDataBlock64;

    nlsDataBlock32 = BlAmd64LoaderBlock32->NlsData;
    if (nlsDataBlock32 == NULL) {
        return ESUCCESS;
    }

    nlsDataBlock64 = BlAllocateHeap(sizeof(NLS_DATA_BLOCK_64));
    if (nlsDataBlock64 == NULL) {
        return ENOMEM;
    }

    status = Copy_NLS_DATA_BLOCK( nlsDataBlock32, nlsDataBlock64 );
    if (status != ESUCCESS) {
        return status;
    }

    BlAmd64LoaderBlock64->NlsData = PTR_64( nlsDataBlock64 );

    return ESUCCESS;
}

ARC_STATUS
BlAmd64BuildLoaderBlock64(
    VOID
    )

/*++

Routine Description:

    This routine allocates a 64-bit loader parameter block and copies the
    contents of the 32-bit loader parameter block into it.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    ARC_STATUS status;

    //
    // Allocate the loader block and extension
    //

    BlAmd64LoaderBlock64 = BlAllocateHeap(sizeof(LOADER_PARAMETER_BLOCK_64));
    if (BlAmd64LoaderBlock64 == NULL) {
        return ENOMEM;
    }

    //
    // Copy the contents of the 32-bit loader parameter block to the
    // 64-bit version
    //

    status = Copy_LOADER_PARAMETER_BLOCK( BlAmd64LoaderBlock32, BlAmd64LoaderBlock64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Build the loader block extension
    //

    status = BlAmd64BuildLoaderBlockExtension64();
    if (status != ESUCCESS) {
        return status;
    }

    return ESUCCESS;
}

ARC_STATUS
BlAmd64TransferMemoryAllocationDescriptors(
    VOID
    )

/*++

Routine Description:

    This routine transfers all of the 32-bit memory allocation descriptors
    to a 64-bit list.

    The storage for the 64-bit memory allocation descriptors has been
    preallocated by a previous call to
    BlAmd64AllocateMemoryAllocationDescriptors().  This memory is described
    by BlAmd64DescriptorArray and BlAmd64DescriptorArraySize.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    ARC_STATUS status;
    PMEMORY_ALLOCATION_DESCRIPTOR    memDesc32;
    PMEMORY_ALLOCATION_DESCRIPTOR_64 memDesc64;
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    LONG descriptorCount;

    //
    // Modify some descriptor types.  All of the descriptors of type
    // LoaderMemoryData really contain things that won't be used in 64-bit
    // mode, such as 32-bit page tables and the like.
    //
    // The descriptors that we really want to stick around are allocated with
    // LoaderAmd64MemoryData.
    //
    // Perform two memory descriptor list search-and-replacements:
    //
    //  LoaderMemoryData      -> LoaderOSLoaderHeap
    //
    //      These desriptors will be freed during kernel init phase 1
    //
    //  LoaderAmd64MemoryData -> LoaderMemoryData
    //
    //      This stuff will be kept around
    //

    //
    // All existing LoaderMemoryData refers to structures that are not useful
    // once running in long mode.  However, we're using some of the structures
    // now (32-bit page tables for example), so convert them to
    // type LoaderOsloaderHeap, which will be eventually freed by the kernel.
    // 

    BlAmd64ReplaceMemoryDescriptorType(LoaderMemoryData,
                                       LoaderOsloaderHeap,
                                       TRUE);

    //
    // Same for LoaderStartupPcrPage
    //

    BlAmd64ReplaceMemoryDescriptorType(LoaderStartupPcrPage,
                                       LoaderOsloaderHeap,
                                       TRUE);

    //
    // All of the permanent structures that need to be around for longmode
    // were temporarily allocated with LoaderAmd64MemoryData.  Convert all
    // of those to LoaderMemoryData now.
    //

    BlAmd64ReplaceMemoryDescriptorType(LoaderAmd64MemoryData,
                                       LoaderMemoryData,
                                       TRUE);


    //
    // Now walk the 32-bit memory descriptors, filling in and inserting a
    // 64-bit version into BlAmd64LoaderBlock64.
    //

    InitializeListHead64( &BlAmd64LoaderBlock64->MemoryDescriptorListHead );
    memDesc64 = BlAmd64DescriptorArray;
    descriptorCount = BlAmd64DescriptorArraySize;

    listHead = &BlAmd64LoaderBlock32->MemoryDescriptorListHead;
    listEntry = listHead->Flink;
    while (listEntry != listHead && descriptorCount > 0) {

        memDesc32 = CONTAINING_RECORD( listEntry,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry );

        status = Copy_MEMORY_ALLOCATION_DESCRIPTOR( memDesc32, memDesc64 );
        if (status != ESUCCESS) {
            return status;
        }

#if DBG
        DbgPrint("Base 0x%08x size 0x%02x %s\n",
                 memDesc32->BasePage,
                 memDesc32->PageCount,
                 BlAmd64MemoryDescriptorText[memDesc32->MemoryType]);
#endif

        InsertTailList64( &BlAmd64LoaderBlock64->MemoryDescriptorListHead,
                          &memDesc64->ListEntry );

        listEntry = listEntry->Flink;
        memDesc64 = memDesc64 + 1;
        descriptorCount -= 1;
    }

    ASSERT( descriptorCount >= 0 && listEntry == listHead );

    return ESUCCESS;
}


ARC_STATUS
BlAmd64AllocateMemoryAllocationDescriptors(
    VOID
    )

/*++

Routine Description:

    This routine preallocates a quantity of memory sufficient to contain
    a 64-bit version of each memory allocation descriptor.

    The resultant memory is described in two globals: BlAmd64DescriptorArray
    and BlAmd64DescriptorArrayCount.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    ULONG descriptorCount;
    ULONG arraySize;
    PMEMORY_ALLOCATION_DESCRIPTOR_64 descriptorArray;

    //
    // Count the number of descriptors needed.
    //

    descriptorCount = 0;
    listHead = &BlAmd64LoaderBlock32->MemoryDescriptorListHead;
    listEntry = listHead->Flink;
    while (listEntry != listHead) {
        descriptorCount += 1;
        listEntry = listEntry->Flink;
    }

    //
    // Allocate memory sufficient to contain them all in 64-bit form.
    //

    arraySize = descriptorCount *
                sizeof(MEMORY_ALLOCATION_DESCRIPTOR_64);

    descriptorArray = BlAllocateHeap(arraySize);
    if (descriptorArray == NULL) {
        return ENOMEM;
    }

    BlAmd64DescriptorArray = descriptorArray;
    BlAmd64DescriptorArraySize = descriptorCount;

    return ESUCCESS;
}
    
ARC_STATUS
BlAmd64TransferLoadedModuleState(
    VOID
    )

/*++

Routine Description:

    This routine transfers the 32-bit list of LDR_DATA_TABLE_ENTRY structures
    to an equivalent 64-bit list.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    PLDR_DATA_TABLE_ENTRY dataTableEntry32;
    PLDR_DATA_TABLE_ENTRY_64 dataTableEntry64;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY listHead;
    ARC_STATUS status;

    InitializeListHead64( &BlAmd64LoaderBlock64->LoadOrderListHead );

    //
    // For each of the LDR_DATA_TABLE_ENTRY structures in the 32-bit
    // loader parameter block, create a 64-bit LDR_DATA_TABLE_ENTRY
    // and queue it on the 64-bit loader parameter block.
    // 

    listHead = &BlAmd64LoaderBlock32->LoadOrderListHead;
    listEntry = listHead->Flink;
    while (listEntry != listHead) {

        dataTableEntry32 = CONTAINING_RECORD( listEntry,
                                              LDR_DATA_TABLE_ENTRY,
                                              InLoadOrderLinks );

        status = BlAmd64BuildLdrDataTableEntry64( dataTableEntry32,
                                                  &dataTableEntry64 );
        if (status != ESUCCESS) {
            return status;
        }

        //
        // Insert it into the 64-bit loader block's data table queue.
        // 

        InsertTailList64( &BlAmd64LoaderBlock64->LoadOrderListHead,
                          &dataTableEntry64->InLoadOrderLinks );

        listEntry = listEntry->Flink;
    }
    return ESUCCESS;
}

ARC_STATUS
BlAmd64BuildLdrDataTableEntry64(
    IN  PLDR_DATA_TABLE_ENTRY     DataTableEntry32,
    OUT PLDR_DATA_TABLE_ENTRY_64 *DataTableEntry64
    )

/*++

Routine Description:

    This routine transfers the contents of a single 32-bit
    LDR_DATA_TABLE_ENTRY structure to the 64-bit equivalent.

Arguments:

    DataTableEntry32 - Supplies a pointer to the source structure.

    DataTableEntry64 - Supplies a pointer to the destination pointer to
                       the created structure.

Return Value:

    The status of the operation.

--*/

{
    ARC_STATUS status;
    PLDR_DATA_TABLE_ENTRY_64 dataTableEntry64;

    //
    // Allocate a 64-bit data table entry and transfer the 32-bit
    // contents
    //

    dataTableEntry64 = BlAllocateHeap( sizeof(LDR_DATA_TABLE_ENTRY_64) );
    if (dataTableEntry64 == NULL) {
        return ENOMEM;
    }

    status = Copy_LDR_DATA_TABLE_ENTRY( DataTableEntry32, dataTableEntry64 );
    if (status != ESUCCESS) {
        return status;
    }

    *DataTableEntry64 = dataTableEntry64;

    //
    // Later on, we'll need to determine the 64-bit copy of this data
    // table entry.  Store the 64-bit pointer to the copy here.
    //

    *((POINTER64 *)&DataTableEntry32->DllBase) = PTR_64(dataTableEntry64);

    return ESUCCESS;
}


ARC_STATUS
BlAmd64BuildLoaderBlockExtension64(
    VOID
    )

/*++

Routine Description:

    This routine transfers the contents of the 32-bit loader block
    extension to a 64-bit equivalent.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    PLOADER_PARAMETER_EXTENSION_64 loaderExtension;
    ARC_STATUS status;

    //
    // Allocate the 64-bit extension and transfer the contents of the
    // 32-bit block.
    // 

    loaderExtension = BlAllocateHeap( sizeof(LOADER_PARAMETER_EXTENSION_64) );
    if (loaderExtension == NULL) {
        return ENOMEM;
    }

    //
    // Perform automatic copy of most fields
    //

    status = Copy_LOADER_PARAMETER_EXTENSION( BlLoaderBlock->Extension,
                                              loaderExtension );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Manually fix up remaining fields
    //

    loaderExtension->Size = sizeof(LOADER_PARAMETER_EXTENSION_64);

    BlAmd64LoaderBlock64->Extension = PTR_64(loaderExtension);

    return ESUCCESS;
}


ARC_STATUS
BlAmd64TransferBootDriverNodes(
    VOID
    )

/*++

Routine Description:

    This routine transfers the 32-bit list of BOOT_DRIVER_NODE structures
    to an equivalent 64-bit list.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    PBOOT_DRIVER_LIST_ENTRY driverListEntry32;
    PBOOT_DRIVER_LIST_ENTRY_64 driverListEntry64;
    PBOOT_DRIVER_NODE driverNode32;
    PBOOT_DRIVER_NODE_64 driverNode64;
    POINTER64 dataTableEntry64;
    PKLDR_DATA_TABLE_ENTRY dataTableEntry;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY listHead;
    ARC_STATUS status;

    InitializeListHead64( &BlAmd64LoaderBlock64->BootDriverListHead );

    //
    // For each of the BOOT_DRIVER_NODE structures in the 32-bit
    // loader parameter block, create a 64-bit BOOT_DRIVER_NODE
    // and (possibly) associated LDR_DATA_TABLE_ENTRY structure.
    // 

    listHead = &BlAmd64LoaderBlock32->BootDriverListHead;
    listEntry = listHead->Flink;
    while (listEntry != listHead) {

        driverListEntry32 = CONTAINING_RECORD( listEntry,
                                               BOOT_DRIVER_LIST_ENTRY,
                                               Link );

        driverNode32 = CONTAINING_RECORD( driverListEntry32,
                                          BOOT_DRIVER_NODE,
                                          ListEntry );

        driverNode64 = BlAllocateHeap( sizeof(BOOT_DRIVER_NODE_64) );
        if (driverNode64 == NULL) {
            return ENOMEM;
        }

        status = Copy_BOOT_DRIVER_NODE( driverNode32, driverNode64 );
        if (status != ESUCCESS) {
            return status;
        }

        dataTableEntry = driverNode32->ListEntry.LdrEntry;
        if (dataTableEntry != NULL) {

            //
            // There is already a 64-bit copy of this table entry, and we
            // stored a pointer to it at DllBase.
            //

            dataTableEntry64 = *((POINTER64 *)&dataTableEntry->DllBase);
            driverNode64->ListEntry.LdrEntry = dataTableEntry64;
        }

        //
        // Now insert the driver list entry into the 64-bit loader block.
        //

        InsertTailList64( &BlAmd64LoaderBlock64->BootDriverListHead,
                          &driverNode64->ListEntry.Link );

        listEntry = listEntry->Flink;
    }
    return ESUCCESS;
}

ARC_STATUS
BlAmd64CheckForLongMode(
    IN     ULONG LoadDeviceId,
    IN OUT PCHAR KernelPath,
    IN     PCHAR KernelFileName
    )

/*++

Routine Description:

    This routine examines a kernel image and determines whether it was
    compiled for AMD64.  The global BlAmd64UseLongMode is set to non-zero
    if a long-mode kernel is discovered.

Arguments:

    LoadDeviceId - Supplies the load device identifier.

    KernelPath - Supplies a pointer to the path to the kernel directory.
                 Upon successful return, KernelFileName will be appended
                 to this path.

    KernelFileName - Supplies a pointer to the name of the kernel file.

Return Value:

    The status of the operation.  Upon successful completion ESUCCESS
    is returned, whether long mode capability was detected or not.

--*/

{
    CHAR localBufferSpace[ SECTOR_SIZE * 2 + SECTOR_SIZE - 1 ];
    PCHAR localBuffer;
    ULONG fileId;
    PIMAGE_NT_HEADERS32 ntHeaders;
    ARC_STATUS status;
    ULONG bytesRead;
    PCHAR kernelNameTarget;

    //
    // File I/O here must be sector-aligned.
    //

    localBuffer = (PCHAR)
        (((ULONG)localBufferSpace + SECTOR_SIZE - 1) & ~(SECTOR_SIZE - 1));

    //
    // Build the path to the kernel and open it.
    //

    kernelNameTarget = KernelPath + strlen(KernelPath);
    strcpy(kernelNameTarget, KernelFileName);
    status = BlOpen( LoadDeviceId, KernelPath, ArcOpenReadOnly, &fileId );
    *kernelNameTarget = '\0';       // Restore the kernel path, assuming
                                    // failure.

    if (status != ESUCCESS) {
        return status;
    }

    //
    // Read the PE image header
    //

    status = BlRead( fileId, localBuffer, SECTOR_SIZE * 2, &bytesRead );
    BlClose( fileId );

    //
    // Determine whether the image header is valid, and if so whether
    // the image is AMD64, I386 or something else.
    // 

    ntHeaders = RtlImageNtHeader( localBuffer );
    if (ntHeaders == NULL) {
        return EBADF;
    }

    if (IMAGE_64BIT(ntHeaders)) {

        //
        // Return with the kernel name appended to the path
        //

        if (BlIsAmd64Supported() != FALSE) {

            strcpy(kernelNameTarget, KernelFileName);
            BlAmd64UseLongMode = TRUE;
            status = ESUCCESS;

        } else {

            //
            // We have an AMD64 image, but the processor does not support
            // AMD64.  There is nothing we can do.
            //

            status = EBADF;
        }

    } else if (IMAGE_32BIT(ntHeaders)) {

        ASSERT( BlAmd64UseLongMode == FALSE );
        status = ESUCCESS;

    } else {

        status = EBADF;
    }

    return status;
}

ARC_STATUS
BlAmd64PrepareSystemStructures(
    VOID
    )

/*++

Routine Description:

    This routine allocates and initializes several structures necessary
    for transfer to an AMD64 kernel.  These structures include:

        KPCR
        GDT
        IDT
        KTSS64
        EPROCESS
        ETHREAD
        Idle thread stack
        DPC stack

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    PCHAR processorData;
    ULONG dataSize;
    ULONG descriptor;
    ULONG stackOffset;

    PKTSS64_64 sysTss64;
    PCHAR idleStack;
    PCHAR dpcStack;
    PCHAR doubleFaultStack;
    PCHAR mcaStack;


    PVOID gdt64;
    PVOID idt64;

    ARC_STATUS status;

    //
    // Calculate the cumulative, rounded size of the various structures that
    // we need, and allocate a sufficient number of pages.
    // 

    dataSize = ROUNDUP16(GDT_64_SIZE)                       +
               ROUNDUP16(IDT_64_SIZE)                       +
               ROUNDUP16(FIELD_OFFSET(KTSS64_64,IoMap));

    dataSize = ROUNDUP_PAGE(dataSize);
    stackOffset = dataSize;

    dataSize += KERNEL_STACK_SIZE_64 +          // Idle thread stack
                KERNEL_STACK_SIZE_64 +          // DPC stack
                DOUBLE_FAULT_STACK_SIZE_64 +    // Double fault stack
                MCA_EXCEPTION_STACK_SIZE_64;    // MCA exception stack

    //
    // dataSize is still page aligned.
    //

    status = BlAllocateDescriptor( LoaderAmd64MemoryData,
                                   0,
                                   dataSize / PAGE_SIZE,
                                   &descriptor );
    if (status != ESUCCESS) {
        return status;
    }

    processorData = (PCHAR)(descriptor * PAGE_SIZE | KSEG0_BASE_X86);

    //
    // Zero the block that was just allocated, then get local pointers to the
    // various structures within.
    // 

    RtlZeroMemory( processorData, dataSize );

    //
    // Assign the stack pointers.  Stack pointers start at the TOP of their
    // respective stack areas.
    //

    idleStack = processorData + stackOffset + KERNEL_STACK_SIZE_64;
    dpcStack = idleStack + KERNEL_STACK_SIZE_64;
    doubleFaultStack = dpcStack + DOUBLE_FAULT_STACK_SIZE_64;
    mcaStack = doubleFaultStack + MCA_EXCEPTION_STACK_SIZE_64;

    //
    // Record the idle stack base so that we can switch to it in amd64s.asm
    //

    BlAmd64IdleStack64 = PTR_64(idleStack);

    //
    // Assign pointers to GDT, IDT and KTSS64.
    //

    gdt64 = (PVOID)processorData;
    processorData += ROUNDUP16(GDT_64_SIZE);

    idt64 = (PVOID)processorData;
    processorData += ROUNDUP16(IDT_64_SIZE);

    sysTss64 = (PKTSS64_64)processorData;
    processorData += ROUNDUP16(FIELD_OFFSET(KTSS64_64,IoMap));

    //
    // Build the GDT.  This is done in amd64.c as it involves AMD64
    // structure definitions.  The IDT remains zeroed.
    //

    BlAmd64BuildAmd64GDT( sysTss64, gdt64 );

    //
    // Build the pseudo-descriptors for the GDT and IDT.  These will
    // be referenced during the long-mode transition in amd64s.asm.
    // 

    BlAmd64GdtDescriptor.Limit = (USHORT)(GDT_64_SIZE - 1);
    BlAmd64GdtDescriptor.Base = PTR_64(gdt64);

    BlAmd64IdtDescriptor.Limit = (USHORT)(IDT_64_SIZE - 1);
    BlAmd64IdtDescriptor.Base = PTR_64(idt64);

    //
    // Build another GDT pseudo-descriptor, this one with a 32-bit
    // base.  This base address must be a 32-bit address that is addressible
    // from long mode during init, so use the mapping in the identity mapped
    // region.
    //

    BlAmd32GdtDescriptor.Limit = (USHORT)(GDT_64_SIZE - 1);
    BlAmd32GdtDescriptor.Base = (ULONG)gdt64 ^ KSEG0_BASE_X86;

    //
    // Initialize the system TSS
    //

    sysTss64->Rsp0 = PTR_64(idleStack);
    sysTss64->Ist[TSS64_IST_PANIC] = PTR_64(doubleFaultStack);
    sysTss64->Ist[TSS64_IST_MCA] = PTR_64(mcaStack);

    //
    // Fill required fields within the loader block
    //

    BlAmd64LoaderBlock64->KernelStack = PTR_64(dpcStack);

    return ESUCCESS;
}

VOID
BlAmd64ReplaceMemoryDescriptorType(
    IN TYPE_OF_MEMORY Target,
    IN TYPE_OF_MEMORY Replacement,
    IN BOOLEAN Coallesce
    )

/*++

Routine Description:

    This routine walks the 32-bit memory allocation descriptor list and
    performs a "search and replace" of the types therein.

    Optionally, it will coallesce each successful replacement with
    adjacent descriptors of like type.

Arguments:

    Target - The descriptor type to search for

    Replacement - The type with which to replace each located Target type.

    Coallesce - If !FALSE, indicates that each successful replacement should
                be coallesced with any like-typed neighbors.

Return Value:

    None.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR descriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR adjacentDescriptor;
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY adjacentListEntry;

    listHead = &BlAmd64LoaderBlock32->MemoryDescriptorListHead;
    listEntry = listHead;
    while (TRUE) {

        listEntry = listEntry->Flink;
        if (listEntry == listHead) {
            break;
        }

        descriptor = CONTAINING_RECORD(listEntry,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry);
        if (descriptor->MemoryType != Target) {
            continue;
        }

        descriptor->MemoryType = Replacement;
        if (Coallesce == FALSE) {

            //
            // Do not attempt to coallesce
            //

            continue;
        }

        //
        // Now attempt to coallesce the descriptor.  First try the
        // next descriptor.
        //

        adjacentListEntry = listEntry->Flink;
        if (adjacentListEntry != listHead) {

            adjacentDescriptor = CONTAINING_RECORD(adjacentListEntry,
                                                   MEMORY_ALLOCATION_DESCRIPTOR,
                                                   ListEntry);

            if (adjacentDescriptor->MemoryType == descriptor->MemoryType &&
                descriptor->BasePage + descriptor->PageCount ==
                adjacentDescriptor->BasePage) {

                descriptor->PageCount += adjacentDescriptor->PageCount;
                BlRemoveDescriptor(adjacentDescriptor);
            }
        }

        //
        // Now try the previous descriptor.
        //

        adjacentListEntry = listEntry->Blink;
        if (adjacentListEntry != listHead) {

            adjacentDescriptor = CONTAINING_RECORD(adjacentListEntry,
                                                   MEMORY_ALLOCATION_DESCRIPTOR,
                                                   ListEntry);

            if (adjacentDescriptor->MemoryType == descriptor->MemoryType &&
                adjacentDescriptor->BasePage + adjacentDescriptor->PageCount ==
                descriptor->BasePage) {

                descriptor->PageCount += adjacentDescriptor->PageCount;
                descriptor->BasePage -= adjacentDescriptor->PageCount;
                BlRemoveDescriptor(adjacentDescriptor);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\daytona_dbg\makefile.inc ===
#
# Copy the stub files over.  Then, if the amd64 files are on this machine,
# copy them over the top.
#

amd64clean:
    -del ..\i386\amd64.c    >nul 2>nul
    -del ..\i386\amd64x86.c >nul 2>nul
    -del ..\i386\amd64s.asm >nul 2>nul

amd64stub: amd64clean
    copy ..\i386\amd64_stub.c    ..\i386\amd64.c    >nul 2>nul    
    copy ..\i386\amd64x86_stub.c ..\i386\amd64x86.c >nul 2>nul
    copy ..\i386\amd64s_stub.asm ..\i386\amd64s.asm >nul 2>nul
    if exist ..\amd64\amd64.c copy ..\amd64\amd64*.* ..\i386 >nul 2>nul
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\amd64s_stub.asm ===
;++
;
;Copyright (c) 2000  Microsoft Corporation
;
;Module Name:
;
;    amd64s.asm
;
;Abstract:
;
;    This module is a placeholder for the actual module containing
;    proprietary AMD64 information.
;
;Author:
;
;    Forrest Foltz (forrestf) 04-20-00
;
;
;Revision History:
;
;--

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\daytona\makefile.inc ===
#
# Copy the stub files over.  Then, if the amd64 files are on this machine,
# copy them over the top.
#

amd64clean:
    -del ..\i386\amd64.c    >nul 2>nul
    -del ..\i386\amd64x86.c >nul 2>nul
    -del ..\i386\amd64s.asm >nul 2>nul

amd64stub: amd64clean
    copy ..\i386\amd64_stub.c    ..\i386\amd64.c    >nul 2>nul    
    copy ..\i386\amd64x86_stub.c ..\i386\amd64x86.c >nul 2>nul
    copy ..\i386\amd64s_stub.asm ..\i386\amd64s.asm >nul 2>nul
    if exist ..\amd64\amd64.c copy ..\amd64\amd64*.* ..\i386 >nul 2>nul
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\bootfont.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    bootfint.h

Abstract:

    Header file describing the bootfont.bin file used to provide
    dbcs support during system or setup bootstrap.

Author:

    tedm 11-July-1995

Revision History:

--*/


//
// Define maximum number of dbcs lead byte ranges we support.
//
#define MAX_DBCS_RANGE  5

//
// Define signature value.
//
#define BOOTFONTBIN_SIGNATURE 0x5465644d

//
// Define structure used as a header for the bootfont.bin file.
//
typedef struct _BOOTFONTBIN_HEADER {

    //
    // Signature. Must be BOOTFONTBIN_SIGNATURE.
    //
    ULONG Signature;

    //
    // Language id of the language supported by this font.
    // This should match the language id of resources in msgs.xxx.
    //
    ULONG LanguageId;

    //
    // Number of sbcs characters and dbcs characters contained in the file.
    //
    unsigned NumSbcsChars;
    unsigned NumDbcsChars;

    //
    // Offsets within the file to the images.
    //
    unsigned SbcsOffset;
    unsigned DbcsOffset;

    //
    // Total sizes of the images.
    //
    unsigned SbcsEntriesTotalSize;
    unsigned DbcsEntriesTotalSize;

    //
    // Dbcs lead byte table. Must contain a pair of 0's to indicate the end.
    //
    UCHAR DbcsLeadTable[(MAX_DBCS_RANGE+1)*2];

    //
    // Height values for the font.
    // CharacterImageHeight is the height in scan lines/pixels of the
    // font image. Each character is drawn with additional 'padding'
    // lines on the top and bottom, whose sizes are also contained here.
    //
    UCHAR CharacterImageHeight;
    UCHAR CharacterTopPad;
    UCHAR CharacterBottomPad;

    //
    // Width values for the font. These values contain the width in pixels
    // of a single byte character and double byte character.
    //
    // NOTE: CURRENTLY THE SINGLE BYTE WIDTH *MUST* BE 8 AND THE DOUBLE BYTE
    // WIDTH *MUST* BE 16!!!
    //
    UCHAR CharacterImageSbcsWidth;
    UCHAR CharacterImageDbcsWidth;

} BOOTFONTBIN_HEADER, *PBOOTFONTBIN_HEADER;

//
// Images themselves follow.
//
// First there are SbcsCharacters entries for single-byte chars.
// The first byte in each entry is the ascii char code. The next n bytes are
// the image. n is dependent on the width and height of an sbcs char.
//
// Following these are the dbcs images. The first 2 bytes are the dbcs
// character code (highbyte lowbyte) and the next n bytes are the image.
// n is dependent on the width and height of a dbcs char.
//
// Important note: the characters must be sorted in ascending order!
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\amd64bl.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    amd64.h

Abstract:

    This header file defines the Amd64 specific interfaces that are
    callable from the main loader code.

Author:

    Forrest Foltz (forrestf) 20-Apr-00


Revision History:

--*/

#if !defined(_AMD64BL_H_)
#define _AMD64BL_H_

#include "bootx86.h"

BOOLEAN
BlDetectAmd64(
    VOID
    );

ARC_STATUS
BlPrepareAmd64Phase1(
    VOID
    );

ARC_STATUS
BlPrepareAmd64Phase2(
    VOID
    );

VOID
BlSwitchToAmd64Mode(
    VOID
    );

#endif  // _AMD64BL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\amd64x86_stub.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    amd64.c

Abstract:

    This module contains stub functions to support the AMD64 processor.

Author:

    Forrest Foltz (forrestf) 20-Apr-2000

Environment:


Revision History:

--*/

#include "amd64bl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\acpidtct.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved

Module Name:

    acpisetd.c

Abstract:

    This module detects an ACPI system.  It
    is included into setup so that setup
    can figure out which HAL to load

Author:

    Jake Oshins (jakeo) - Feb. 7, 1997.

Environment:

    Textmode setup.

Revision History:


--*/
#include "bootx86.h"

#include "stdlib.h"
#include "string.h"

VOID
BlPrint(
    PCHAR cp,
    ...
    );


#ifdef DEBUG
#undef DEBUG_PRINT
#define DEBUG_PRINT BlPrint
#else
#define DEBUG_PRINT
#endif

typedef struct _ACPI_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[8];             // "RSD PTR" (ascii)
    UCHAR Checksum;
    UCHAR OemId[6];                 // An OEM-supplied string
    UCHAR reserved;                 // must be 0
    ULONG RsdtAddress;              // 32-bit physical address of RSDT
} ACPI_BIOS_INSTALLATION_CHECK, *PACPI_BIOS_INSTALLATION_CHECK;

#include "acpitabl.h"

PRSDP   BlRsdp;
PRSDT   BlRsdt;
PXSDT   BlXsdt;
BOOLEAN BlLegacyFree = FALSE;

PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    );

// from boot\detect\i386\acpibios.h
//
// Acpi BIOS Installation check
//
#define ACPI_BIOS_START            0xE0000
#define ACPI_BIOS_END              0xFFFFF
#define ACPI_BIOS_HEADER_INCREMENT 16

VOID
BlFindRsdp (
    VOID
    )
#define EBDA_SEGMENT_PTR    0x40e
{
    ULONG romAddr, romEnd;
    PACPI_BIOS_INSTALLATION_CHECK header;
    UCHAR sum, node = 0;
    USHORT i, nodeSize;
    ULONG EbdaSegmentPtr;
    ULONG EbdaPhysicalAdd = 0;
    PUCHAR EbdaVirtualAdd = 0;
    PHYSICAL_ADDRESS paddr;
    enum PASS { PASS1 = 0, PASS2, MAX_PASSES } pass;
    USHORT count = 0;

    //
    // Search on 16 byte boundaries for the signature of the
    // Root System Description Table structure.
    //
    for (pass = PASS1; pass < MAX_PASSES; pass++) {

        if (pass == PASS1) {

            //
            // On the first pass, we search the first 1K of the
            // Extended BIOS data area.  The EBDA segment address
            // is available at physical address 40:0E.
            //

            paddr.QuadPart = 0;
            EbdaSegmentPtr = (ULONG) MmMapIoSpace( paddr,
                                                   PAGE_SIZE,
                                                   TRUE);

            EbdaSegmentPtr += EBDA_SEGMENT_PTR;
            EbdaPhysicalAdd = *((PUSHORT)EbdaSegmentPtr);
            EbdaPhysicalAdd = EbdaPhysicalAdd << 4;

            if (EbdaPhysicalAdd) {
                paddr.HighPart = 0;
                paddr.LowPart = EbdaPhysicalAdd;
                EbdaVirtualAdd = MmMapIoSpace( paddr,
                                               2 * PAGE_SIZE,
                                               TRUE);
            }

            if (!EbdaVirtualAdd) {
                continue;
            }

            romAddr = (ULONG)EbdaVirtualAdd;
            romEnd  = romAddr + 1024;

        } else {
            //
            // On the second pass, we search (physical) memory 0xE0000
            // to 0xF0000.

            paddr.LowPart = ACPI_BIOS_START;
            romAddr = (ULONG)MmMapIoSpace(paddr,
                                          ACPI_BIOS_END - ACPI_BIOS_START,
                                          TRUE);

            romEnd  = romAddr + (ACPI_BIOS_END - ACPI_BIOS_START);
        }

        while (romAddr < romEnd) {

            header = (PACPI_BIOS_INSTALLATION_CHECK)romAddr;

            //
            // Signature to match is the string "RSD PTR ".
            //

            if (header->Signature[0] == 'R' && header->Signature[1] == 'S' &&
                header->Signature[2] == 'D' && header->Signature[3] == ' ' &&
                header->Signature[4] == 'P' && header->Signature[5] == 'T' &&
                header->Signature[6] == 'R' && header->Signature[7] == ' ' ) {

                sum = 0;
                for (i = 0; i < sizeof(ACPI_BIOS_INSTALLATION_CHECK); i++) {
                    sum += ((PUCHAR)romAddr)[i];
                }
                if (sum == 0) {
                    pass = MAX_PASSES; // leave 'for' loop
                    break;    // leave 'while' loop
                }
            }

            romAddr += ACPI_BIOS_HEADER_INCREMENT;
        }
    }

    if (romAddr >= romEnd) {
        BlRsdp = NULL;
        BlRsdt = NULL;
        return;
    }

    BlRsdp = (PRSDP)romAddr;
    paddr.LowPart = BlRsdp->RsdtAddress;
    BlRsdt = MmMapIoSpace(paddr, sizeof(RSDT), TRUE);
    BlRsdt = MmMapIoSpace(paddr, BlRsdt->Header.Length, TRUE);

#ifdef ACPI_20_COMPLIANT
    if (BlRsdp->Revision > 1) {

        //
        // ACPI 2.0 BIOS
        //

        BlXsdt = MmMapIoSpace(paddr, sizeof(XSDT), TRUE);
        BlXsdt = MmMapIoSpace(paddr, BlXsdt->Header.Length, TRUE);
    }
#endif
    return;
}

BOOLEAN
BlDetectLegacyFreeBios(
    VOID
    )
{
    PFADT   fadt;

    if (BlLegacyFree) {
        return TRUE;
    }

    BlFindRsdp();

    if (BlRsdt) {

        fadt = (PFADT)BlFindACPITable("FACP", sizeof(FADT));

        if (fadt == NULL) {
            return FALSE;
        }

        if ((fadt->Header.Revision < 2) ||
            (fadt->Header.Length <= 116)) {

            //
            // The BIOS is earlier than the legacy-free
            // additions.
            //
            return FALSE;
        }

        if (!(fadt->boot_arch & I8042)) {
            BlLegacyFree = TRUE;
            return TRUE;
        }
    }

    return FALSE;
}

PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    )
/*++

Routine Description:

    Given a table name, finds that table in the ACPI BIOS

Arguments:

    TableName - Supplies the table name

    TableLength - Supplies the length of the table to map

Return Value:

    Pointer to the table if found

    NULL if the table is not found

--*/

{
    ULONG Signature;
    PFADT Fadt;
    PDESCRIPTION_HEADER Header;
    ULONG TableCount;
    ULONG i;
    PHYSICAL_ADDRESS paddr = {0};

    Signature = *((ULONG UNALIGNED *)TableName);
    if (Signature == RSDT_SIGNATURE) {
        return(&BlRsdt->Header);
    } else if (Signature == XSDT_SIGNATURE) {
        return(&BlXsdt->Header);
    } else if (Signature == DSDT_SIGNATURE) {
        Fadt = (PFADT)BlFindACPITable("FACP", sizeof(PFADT));
        if (Fadt == NULL) {
            return(NULL);
        }
        if (BlXsdt) {
            paddr = Fadt->x_dsdt;
        } else {
#if defined(_X86_)
            paddr.LowPart = Fadt->dsdt;
#else
            paddr.QuadPart = Fadt->dsdt;
#endif
        }
        Header = MmMapIoSpace(paddr, TableLength, TRUE);
        return(Header);
    } else {

        //
        // Make sure...
        //
        if( !BlRsdt ) {
            BlFindRsdp();
        }

        if( BlRsdt ) {

            TableCount = BlXsdt ?
                NumTableEntriesFromXSDTPointer(BlXsdt) :
                NumTableEntriesFromRSDTPointer(BlRsdt);

            //
            // Sanity check.
            //
            if( TableCount > 0x100 ) {
                return(NULL);
            }

            for (i=0;i<TableCount;i++) {


                if (BlXsdt) {

                    paddr = BlXsdt->Tables[i];

                } else {

#if defined(_X86_)
                    paddr.HighPart = 0;
                    paddr.LowPart = BlRsdt->Tables[i];
#else
                    paddr.QuadPart = BlRsdt->Tables[i];
#endif
                }

                Header = MmMapIoSpace(paddr, sizeof(DESCRIPTION_HEADER), TRUE);
                if (Header == NULL) {
                    return(NULL);
                }
                if (Header->Signature == Signature) {
                    //
                    // if we need to map more than just the DESCRIPTION_HEADER, do that before
                    // returning.  Check to see if the end of the table lies past the page 
                    // boundary the header lies on.  If so, we will have to map it.
                    //
                    if ( ((paddr.LowPart + TableLength) & ~(PAGE_SIZE - 1)) >
                         ((paddr.LowPart + sizeof(DESCRIPTION_HEADER)) & ~(PAGE_SIZE - 1)) ) {
                        Header = MmMapIoSpace(paddr, TableLength, TRUE);
                    }
                    return(Header);
                }
            }
        }
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\biosdrv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    biosdrv.c

Abstract:

    Provides the ARC emulation routines for I/O to a device supported by
    real-mode INT 13h BIOS calls.

Author:

    John Vert (jvert) 7-Aug-1991

Revision History:

--*/

#include "arccodes.h"
#include "bootx86.h"

#include "stdlib.h"
#include "string.h"

#include "flop.h"


#if 0
#define DBGOUT(x)   BlPrint x
#define DBGPAUSE    while(!GET_KEY());
#else
#define DBGOUT(x)
#define DBGPAUSE
#endif

//
// Defines for buffer alignment and boundary checks in BiosDisk*
// functions.
//

#define BIOSDISK_1MB            (1 * 1024 * 1024)
#define BIOSDISK_64KB           (64 * 1024)
#define BIOSDISK_64KB_MASK      (~(BIOSDISK_64KB - 1))

//
// Definitions for caching the last read sector.
//

#define BL_LAST_SECTOR_CACHE_MAX_SIZE 4096

typedef struct _BL_LAST_SECTOR_CACHE
{
    BOOLEAN Initialized;
    BOOLEAN Valid;
    ULONG DeviceId;
    ULONGLONG SectorNumber;
    PUCHAR Data;
} BL_LAST_SECTOR_CACHE, *PBL_LAST_SECTOR_CACHE;

//
// This is the global variable used for caching the last sector read
// from the last disk. Callers who access files sequentially but do
// not make sure their offsets are sector aligned end up reading the
// last sector they read again with their next request. This solves
// the problem. Its Data buffer is allocated from the pool at the
// first disk read. It is setup and used in BiosDiskRead, invalidated
// in BiosDiskWrite.
//

BL_LAST_SECTOR_CACHE FwLastSectorCache = {0};

//
// defines for doing console I/O
//
#define CSI 0x95
#define SGR_INVERSE 7
#define SGR_NORMAL 0

//
// static data for console I/O
//
BOOLEAN ControlSequence=FALSE;
BOOLEAN EscapeSequence=FALSE;
BOOLEAN FontSelection=FALSE;
BOOLEAN HighIntensity=FALSE;
BOOLEAN Blink=FALSE;
ULONG PCount=0;

#define CONTROL_SEQUENCE_MAX_PARAMETER 10
ULONG Parameter[CONTROL_SEQUENCE_MAX_PARAMETER];

#define KEY_INPUT_BUFFER_SIZE 16
UCHAR KeyBuffer[KEY_INPUT_BUFFER_SIZE];
ULONG KeyBufferEnd=0;
ULONG KeyBufferStart=0;

//
// array for translating between ANSI colors and the VGA standard
//
UCHAR TranslateColor[] = {0,4,2,6,1,5,3,7};

ARC_STATUS
BiosDiskClose(
    IN ULONG FileId
    );

VOID
BiosConsoleFillBuffer(
    IN ULONG Key
    );


//
// There are two sorts of things we can open in this module, disk partitions,
// and raw disk devices.  The following device entry tables are
// used for these things.
//

BL_DEVICE_ENTRY_TABLE BiosPartitionEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosPartitionClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosPartitionOpen,
        (PARC_READ_ROUTINE)BiosPartitionRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BiosPartitionWrite,
        (PARC_GET_FILE_INFO_ROUTINE)BiosPartitionGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)BlArcNotYetImplemented
    };

BL_DEVICE_ENTRY_TABLE BiosDiskEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosDiskClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosDiskOpen,
        (PARC_READ_ROUTINE)BiosDiskRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BiosDiskWrite,
        (PARC_GET_FILE_INFO_ROUTINE)BiosDiskGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)BlArcNotYetImplemented
    };

BL_DEVICE_ENTRY_TABLE BiosEDDSEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosDiskClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosDiskOpen,
        (PARC_READ_ROUTINE)BiosElToritoDiskRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_FILE_INFO_ROUTINE)BiosDiskGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)BlArcNotYetImplemented
    };


ARC_STATUS
BiosDiskClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the specified device

Arguments:

    FileId - Supplies file id of the device to be closed

Return Value:

    ESUCCESS - Device closed successfully

    !ESUCCESS - Device was not closed.

--*/

{
    if (BlFileTable[FileId].Flags.Open == 0) {
#if DBG
        BlPrint("ERROR - Unopened fileid %lx closed\n",FileId);
#endif
    }
    BlFileTable[FileId].Flags.Open = 0;

    //
    // Invalidate the last read sector cache if it was for this disk.
    //
    if (FwLastSectorCache.DeviceId == FileId) {
        FwLastSectorCache.Valid = FALSE;
    }
    
    return(ESUCCESS);
}

ARC_STATUS
BiosPartitionClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the specified device

Arguments:

    FileId - Supplies file id of the device to be closed

Return Value:

    ESUCCESS - Device closed successfully

    !ESUCCESS - Device was not closed.

--*/

{
    if (BlFileTable[FileId].Flags.Open == 0) {
#if DBG
        BlPrint("ERROR - Unopened fileid %lx closed\n",FileId);
#endif
    }
    BlFileTable[FileId].Flags.Open = 0;

    return(BiosDiskClose((ULONG)BlFileTable[FileId].u.PartitionContext.DiskId));
}


ARC_STATUS
BiosPartitionOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens the disk partition specified by OpenPath.  This routine will open
    floppy drives 0 and 1, and any partition on hard drive 0 or 1.

Arguments:

    OpenPath - Supplies a pointer to the name of the partition.  If OpenPath
               is "A:" or "B:" the corresponding floppy drive will be opened.
               If it is "C:" or above, this routine will find the corresponding
               partition on hard drive 0 or 1 and open it.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only
                1 - Write Only
                2 - Read/Write

    FileId - Returns the file descriptor for use with the Close, Read, Write,
             and Seek routines

Return Value:

    ESUCCESS - File successfully opened.

--*/

{
    ARC_STATUS Status;
    ULONG DiskFileId;
    UCHAR PartitionNumber;
    ULONG Controller;
    ULONG Key;
    BOOLEAN IsEisa = FALSE;

    //
    // BIOS devices are always "multi(0)" (except for EISA flakiness
    // where we treat "eisa(0)..." like "multi(0)..." in floppy cases.
    //
    if(FwGetPathMnemonicKey(OpenPath,"multi",&Key)) {

        if(FwGetPathMnemonicKey(OpenPath,"eisa", &Key)) {
            return(EBADF);
        } else {
            IsEisa = TRUE;
        }
    }

    if (Key!=0) {
        return(EBADF);
    }

    //
    // If we're opening a floppy drive, there are no partitions
    // so we can just return the physical device.
    //

    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(0)partition(0)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(0)partition(0)" ) == 0))
    {
        return(BiosDiskOpen( 0, 0, FileId));
    }
    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(1)partition(0)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(1)partition(0)" ) == 0))
    {
        return(BiosDiskOpen( 1, 0, FileId));
    }

    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(0)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(0)" ) == 0))
    {
        return(BiosDiskOpen( 0, 0, FileId));
    }
    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(1)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(1)" ) == 0))
    {
        return(BiosDiskOpen( 1, 0, FileId));
    }

    //
    // We can't handle eisa(0) cases for hard disks.
    //
    if(IsEisa) {
        return(EBADF);
    }

    //
    // We can only deal with disk controller 0
    //

    if (FwGetPathMnemonicKey(OpenPath,"disk",&Controller)) {
        return(EBADF);
    }
    if ( Controller!=0 ) {
        return(EBADF);
    }

    if (!FwGetPathMnemonicKey(OpenPath,"cdrom",&Key)) {
        //
        // Now we have a CD-ROM disk number, so we open that for raw access.
        // Use a special bit to indicate CD-ROM, because otherwise
        // the BiosDiskOpen routine thinks a third or greater disk is
        // a CD-ROM.
        //
        return(BiosDiskOpen( Key | 0x80000000, 0, FileId ) );
    }

    if (FwGetPathMnemonicKey(OpenPath,"rdisk",&Key)) {
        return(EBADF);
    }

    //
    // Now we have a disk number, so we open that for raw access.
    // We need to add 0x80 to translate it to a BIOS number.
    //

    Status = BiosDiskOpen( 0x80 + Key,
                           0,
                           &DiskFileId );

    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Find the partition number to open
    //

    if (FwGetPathMnemonicKey(OpenPath,"partition",&Key)) {
        BiosPartitionClose(DiskFileId);
        return(EBADF);
    }

    //
    // If the partition number was 0, then we are opening the device
    // for raw access, so we are already done.
    //
    if (Key == 0) {
        *FileId = DiskFileId;
        return(ESUCCESS);
    }

    //
    // Before we open the partition, we need to find an available
    // file descriptor.
    //

    *FileId=2;

    while (BlFileTable[*FileId].Flags.Open != 0) {
        *FileId += 1;
        if (*FileId == BL_FILE_TABLE_SIZE) {
            return(ENOENT);
        }
    }

    //
    // We found an entry we can use, so mark it as open.
    //
    BlFileTable[*FileId].Flags.Open = 1;

    BlFileTable[*FileId].DeviceEntryTable=&BiosPartitionEntryTable;


    //
    // Convert to zero-based partition number
    //
    PartitionNumber = (UCHAR)(Key - 1);

    //
    // Try to open the MBR partition
    //
    Status = HardDiskPartitionOpen( *FileId,
                                   DiskFileId,
                                   PartitionNumber);

#ifdef EFI_PARTITION_SUPPORT

    if (Status != ESUCCESS) {
        //
        // Try to open the GPT partition
        //
        Status = BlOpenGPTDiskPartition( *FileId,
                                       DiskFileId,
                                       PartitionNumber);
    }              

#endif    

    return Status;
}


ARC_STATUS
BiosPartitionRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Reads from the specified file

    NOTE John Vert (jvert) 18-Jun-1991
        This only supports block sector reads.  Thus, everything
        is assumed to start on a sector boundary, and every offset
        is considered an offset from the logical beginning of the disk
        partition.

Arguments:

    FileId - Supplies the file to read from

    Buffer - Supplies buffer to hold the data that is read

    Length - Supplies maximum number of bytes to read

    Count -  Returns actual bytes read.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    LARGE_INTEGER PhysicalOffset;
    ULONG DiskId;
    PhysicalOffset.QuadPart = BlFileTable[FileId].Position.QuadPart +
                            SECTOR_SIZE * (LONGLONG)BlFileTable[FileId].u.PartitionContext.StartingSector;

    DiskId = BlFileTable[FileId].u.PartitionContext.DiskId;

    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &PhysicalOffset,
                                                          SeekAbsolute );

    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                          Buffer,
                                                          Length,
                                                          Count );

    BlFileTable[FileId].Position.QuadPart += *Count;

    return(Status);
}



ARC_STATUS
BiosPartitionSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    Changes the current offset of the file specified by FileId

Arguments:

    FileId - specifies the file on which the current offset is to
             be changed.

    Offset - New offset into file.

    SeekMode - Either SeekAbsolute or SeekRelative
               SeekEndRelative is not supported

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{
    switch (SeekMode) {
        case SeekAbsolute:
            BlFileTable[FileId].Position = *Offset;
            break;
        case SeekRelative:
            BlFileTable[FileId].Position.QuadPart += Offset->QuadPart;
            break;
        default:
#if DBG
            BlPrint("SeekMode %lx not supported\n",SeekMode);
#endif
            return(EACCES);

    }
    return(ESUCCESS);

}



ARC_STATUS
BiosPartitionWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes to the specified file

    NOTE John Vert (jvert) 18-Jun-1991
        This only supports block sector reads.  Thus, everything
        is assumed to start on a sector boundary, and every offset
        is considered an offset from the logical beginning of the disk
        partition.

Arguments:

    FileId - Supplies the file to write to

    Buffer - Supplies buffer with data to write

    Length - Supplies number of bytes to write

    Count -  Returns actual bytes written.

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed.

--*/

{
    ARC_STATUS Status;
    LARGE_INTEGER PhysicalOffset;
    ULONG DiskId;
    PhysicalOffset.QuadPart = BlFileTable[FileId].Position.QuadPart +
                              SECTOR_SIZE * (LONGLONG)BlFileTable[FileId].u.PartitionContext.StartingSector;

    DiskId = BlFileTable[FileId].u.PartitionContext.DiskId;

    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &PhysicalOffset,
                                                          SeekAbsolute );

    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = (BlFileTable[DiskId].DeviceEntryTable->Write)(DiskId,
                                                           Buffer,
                                                           Length,
                                                           Count );

    if(Status == ESUCCESS) {
        BlFileTable[FileId].Position.QuadPart += *Count;
    }

    return(Status);
}



ARC_STATUS
BiosConsoleOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Attempts to open either the console input or output

Arguments:

    OpenPath - Supplies a pointer to the name of the device to open.  If
               this is either CONSOLE_INPUT_NAME or CONSOLE_OUTPUT_NAME,
               a file descriptor is allocated and filled in.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only (CONSOLE_INPUT_NAME)
                1 - Write Only (CONSOLE_OUTPUT_NAME)

    FileId - Returns the file descriptor for use with the Close, Read and
             Write routines

Return Value:

    ESUCCESS - Console successfully opened.

--*/

{
    if (_stricmp(OpenPath, CONSOLE_INPUT_NAME)==0) {

        //
        // Open the keyboard for input
        //

        if (OpenMode != ArcOpenReadOnly) {
            return(EACCES);
        }

        *FileId = 0;

        return(ESUCCESS);
    }

    if (_stricmp(OpenPath, CONSOLE_OUTPUT_NAME)==0) {

        //
        // Open the display for output
        //

        if (OpenMode != ArcOpenWriteOnly) {
            return(EACCES);
        }
        *FileId = 1;

        return(ESUCCESS);
    }

    return(ENOENT);

}

ARC_STATUS
BiosConsoleReadStatus(
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine determines if there is a keypress pending

Arguments:

    FileId - Supplies the FileId to be read.  (should always be 0 for this
            function)

Return Value:

    ESUCCESS - There is a key pending

    EAGAIN - There is not a key pending

--*/

{
    ULONG Key;

    //
    // If we have buffered input...
    //
    if (KeyBufferEnd != KeyBufferStart) {
        return(ESUCCESS);
    }

    //
    // Check for a key
    //
    Key = GET_KEY();
    if (Key != 0) {
        //
        // We got a key, so we have to stick it back into our buffer
        // and return ESUCCESS.
        //
        BiosConsoleFillBuffer(Key);
        return(ESUCCESS);

    } else {
        //
        // no key pending
        //
        return(EAGAIN);
    }

}

ARC_STATUS
BiosConsoleRead(
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Gets input from the keyboard.

Arguments:

    FileId - Supplies the FileId to be read (should always be 0 for this
             function)

    Buffer - Returns the keyboard input.

    Length - Supplies the length of the buffer (in bytes)

    Count  - Returns the actual number of bytes read

Return Value:

    ESUCCESS - Keyboard read completed succesfully.

--*/

{
    ULONG Key;

    *Count = 0;

    while (*Count < Length) {
        if (KeyBufferEnd == KeyBufferStart) { // then buffer is presently empty
            do {

                //
                // Poll the keyboard until input is available
                //

                Key = GET_KEY();
            } while ( Key==0 );

            BiosConsoleFillBuffer(Key);
        }

        Buffer[*Count] = KeyBuffer[KeyBufferStart];
        KeyBufferStart = (KeyBufferStart+1) % KEY_INPUT_BUFFER_SIZE;

        *Count = *Count + 1;
    }
    return(ESUCCESS);
}



VOID
BiosConsoleFillBuffer(
    IN ULONG Key
    )

/*++

Routine Description:

    Places input from the keyboard into the keyboard buffer, expanding the
    special keys as appropriate.
    
    All keys translated here use the ARC translation table, as defined in the 
    ARC specification, with one exception -- the BACKTAB_KEY, for which the
    ARC spec is lacking.  I have decided that BACKTAB_KEY is ESC+TAB.

Arguments:

    Key - Raw keypress value as returned by GET_KEY().

Return Value:

    none.

--*/

{
    switch(Key) {
        case UP_ARROW:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'A';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case DOWN_ARROW:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'B';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case RIGHT_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'C';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case LEFT_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'D';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case INS_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = '@';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case DEL_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'P';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F1_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'P';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F2_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'Q';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F3_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'w';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F5_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 't';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F6_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'u';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F7_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'q';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F8_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'r';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F10_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'M';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;
        
        case F11_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'A';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F12_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'B';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case HOME_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'H';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case END_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'K';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case ESCAPE_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case BACKTAB_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = (UCHAR)(TAB_KEY & 0xFF);
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        default:
            //
            // The ASCII code is the low byte of Key
            //
            KeyBuffer[KeyBufferEnd] = (UCHAR)(Key & 0xff);
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
    }
}



ARC_STATUS
BiosConsoleWrite(
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Outputs to the console.  (In this case, the VGA display)

Arguments:

    FileId - Supplies the FileId to be written (should always be 1 for this
             function)

    Buffer - Supplies characters to be output

    Length - Supplies the length of the buffer (in bytes)

    Count  - Returns the actual number of bytes written

Return Value:

    ESUCCESS - Console write completed succesfully.

--*/
{
    ARC_STATUS Status;
    PUCHAR String;
    ULONG Index;
    UCHAR a;
    PUCHAR p;

    //
    // Process each character in turn.
    //

    Status = ESUCCESS;
    String = (PUCHAR)Buffer;

    for ( *Count = 0 ;
          *Count < Length ;
          (*Count)++, String++ ) {

        //
        // If we're in the middle of a control sequence, continue scanning,
        // otherwise process character.
        //

        if (ControlSequence) {

            //
            // If the character is a digit, update parameter value.
            //

            if ((*String >= '0') && (*String <= '9')) {
                Parameter[PCount] = Parameter[PCount] * 10 + *String - '0';
                continue;
            }

            //
            // If we are in the middle of a font selection sequence, this
            // character must be a 'D', otherwise reset control sequence.
            //

            if (FontSelection) {

                //if (*String == 'D') {
                //
                //    //
                //    // Other fonts not implemented yet.
                //    //
                //
                //} else {
                //}

                ControlSequence = FALSE;
                FontSelection = FALSE;
                continue;
            }

            switch (*String) {

            //
            // If a semicolon, move to the next parameter.
            //

            case ';':

                PCount++;
                if (PCount > CONTROL_SEQUENCE_MAX_PARAMETER) {
                    PCount = CONTROL_SEQUENCE_MAX_PARAMETER;
                }
                Parameter[PCount] = 0;
                break;

            //
            // If a 'J', erase part or all of the screen.
            //

            case 'J':

                switch (Parameter[0]) {
                    case 0:
                        //
                        // Erase to end of the screen
                        //
                        TextClearToEndOfDisplay();
                        break;

                    case 1:
                        //
                        // Erase from the beginning of the screen
                        //
                        break;

                    default:
                        //
                        // Erase entire screen
                        //
                        TextClearDisplay();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'K', erase part or all of the line.
            //

            case 'K':

                switch (Parameter[0]) {

                //
                // Erase to end of the line.
                //

                    case 0:
                        TextClearToEndOfLine();
                        break;

                    //
                    // Erase from the beginning of the line.
                    //

                    case 1:
                        TextClearFromStartOfLine();
                        break;

                    //
                    // Erase entire line.
                    //

                    default :
                        TextClearFromStartOfLine();
                        TextClearToEndOfLine();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'H', move cursor to position.
            //

            case 'H':
                TextSetCursorPosition(Parameter[1]-1, Parameter[0]-1);
                ControlSequence = FALSE;
                break;

            //
            // If a ' ', could be a FNT selection command.
            //

            case ' ':
                FontSelection = TRUE;
                break;

            case 'm':
                //
                // Select action based on each parameter.
                //
                // Blink and HighIntensity are by default disabled
                // each time a new SGR is specified, unless they are
                // explicitly specified again, in which case these
                // will be set to TRUE at that time.
                //

                HighIntensity = FALSE;
                Blink = FALSE;

                for ( Index = 0 ; Index <= PCount ; Index++ ) {
                    switch (Parameter[Index]) {

                    //
                    // Attributes off.
                    //

                    case 0:
                        TextSetCurrentAttribute(7);
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // High Intensity.
                    //

                    case 1:
                        TextSetCurrentAttribute(0xf);
                        HighIntensity = TRUE;
                        break;

                    //
                    // Underscored.
                    //

                    case 4:
                        break;

                    //
                    // Blink.
                    //

                    case 5:
                        TextSetCurrentAttribute(0x87);
                        Blink = TRUE;
                        break;

                    //
                    // Reverse Video.
                    //

                    case 7:
                        TextSetCurrentAttribute(0x70);
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // Font selection, not implemented yet.
                    //

                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                        break;

                    //
                    // Foreground Color
                    //

                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                        a = TextGetCurrentAttribute();
                        a &= 0x70;
                        a |= TranslateColor[Parameter[Index]-30];
                        if (HighIntensity) {
                            a |= 0x08;
                        }
                        if (Blink) {
                            a |= 0x80;
                        }
                        TextSetCurrentAttribute(a);
                        break;

                    //
                    // Background Color
                    //

                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                        a = TextGetCurrentAttribute();
                        a &= 0x8f;
                        a |= TranslateColor[Parameter[Index]-40] << 4;
                        TextSetCurrentAttribute(a);
                        break;

                    default:
                        break;
                    }
                }

            default:
                ControlSequence = FALSE;
                break;
            }

        //
        // This is not a control sequence, check for escape sequence.
        //

        } else {

            //
            // If escape sequence, check for control sequence, otherwise
            // process single character.
            //

            if (EscapeSequence) {

                //
                // Check for '[', means control sequence, any other following
                // character is ignored.
                //

                if (*String == '[') {

                    ControlSequence = TRUE;

                    //
                    // Initialize first parameter.
                    //

                    PCount = 0;
                    Parameter[0] = 0;
                }
                EscapeSequence = FALSE;

            //
            // This is not a control or escape sequence, process single character.
            //

            } else {

                switch (*String) {
                    //
                    // Check for escape sequence.
                    //

                    case ASCI_ESC:
                        EscapeSequence = TRUE;
                        break;

                    default:
                        p = TextCharOut(String);
                        //
                        // Each pass through the loop increments String by 1.
                        // If we output a dbcs char we need to increment by
                        // one more.
                        //
                        (*Count) += (p - String) - 1;
                        String += (p - String) - 1;
                        break;
                }

            }
        }
    }
    return Status;
}


ARC_STATUS
BiosDiskOpen(
    IN ULONG DriveId,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens a BIOS-accessible disk for raw sector access.

Arguments:

    DriveId - Supplies the BIOS DriveId of the drive to open
              0 - Floppy 0
              1 - Floppy 1
              0x80 - Hard Drive 0
              0x81 - Hard Drive 1
              0x82 - Hard Drive 2
              etc

              High bit set and ID > 0x81 means the device is expected to be
              a CD-ROM drive.

    OpenMode - Supplies the mode of the open

    FileId - Supplies a pointer to a variable that specifies the file
             table entry that is filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    USHORT NumberHeads;
    UCHAR NumberSectors;
    USHORT NumberCylinders;
    UCHAR NumberDrives;
    ULONG Result;
    PDRIVE_CONTEXT Context;
    ULONG Retries;
    BOOLEAN IsCd;
    UCHAR *Buffer = FwDiskCache;
    ULONG BufferSize = 512; // sector size
    BOOLEAN xInt13;

    DBGOUT(("BiosDiskOpen: enter, id = 0x%lx\r\n",DriveId));
      
    //
    // Check special drive number encoding for CD-ROM case
    //
    if(DriveId > 0x80000081) {
        IsCd = TRUE;
        DriveId &= 0x7fffffff;
    } else {
        IsCd = FALSE;
    }

    xInt13 = FALSE;

    //
    // If we are opening Floppy 0 or Floppy 1, we want to read the BPB off
    // the disk so we can deal with all the odd disk formats.
    //
    // If we are opening a hard drive, we can just call the BIOS to find out
    // its characteristics
    //
    if(DriveId < 128) {
        PPACKED_BOOT_SECTOR BootSector;
        BIOS_PARAMETER_BLOCK Bpb;

        //
        // Read the boot sector off the floppy and extract the cylinder,
        // sector, and head information. We fake the CHS values here
        // to allow sector 0 to be read before we actually know the
        // geometry we want to use.
        //
        if(ReadPhysicalSectors((UCHAR)DriveId,0,1,Buffer,1,1,1,FALSE)) {
            DBGOUT(("BiosDiskOpen: error reading from floppy drive\r\n"));
            DBGPAUSE
            return(EIO);
        }
        BootSector = (PPACKED_BOOT_SECTOR)Buffer;

        FatUnpackBios(&Bpb, &(BootSector->PackedBpb));

        NumberHeads = Bpb.Heads;
        NumberSectors = (UCHAR)Bpb.SectorsPerTrack;
        NumberCylinders = Bpb.Sectors / (NumberSectors * NumberHeads);

    } else if(IsCd) {
        //
        // This is an El Torito drive
        // Just use bogus values since CHS values are meaningless for no-emulation El Torito boot
        //
        NumberCylinders = 1;
        NumberHeads =  1;
        NumberSectors = 1;

    } else {
        //
        // Get Drive Parameters via int13 function 8
        // Return of 0 means success; otherwise we get back what the BIOS
        // returned in ax.
        //
        ULONG Retries = 0;

        do {            
            if(BIOS_IO(0x08,(UCHAR)DriveId,0,0,0,0,0)) {
                DBGOUT(("BiosDiskOpen: error getting params for drive\r\n"));
                DBGPAUSE
                return(EIO);
            }

            //
            // At this point, ECX looks like this:
            //
            //    bits 31..22  - Maximum cylinder
            //    bits 21..16  - Maximum sector
            //    bits 15..8   - Maximum head
            //    bits 7..0    - Number of drives
            //
            // Unpack the information from ecx.
            //
            _asm {
                mov Result, ecx
            }

            NumberDrives = (UCHAR)Result;
            NumberHeads = (((USHORT)Result >> 8) & 0xff) + 1;
            NumberSectors = (UCHAR)((Result >> 16) & 0x3f);
            NumberCylinders = (USHORT)(((Result >> 24) + ((Result >> 14) & 0x300)) + 1);
            ++Retries;
        } while ( ((NumberHeads==0) || (NumberSectors==0) || (NumberCylinders==0))
               && (Retries < 5) );

        DBGOUT((
            "BiosDiskOpen: cyl=%u, heads=%u, sect=%u, drives=%u\r\n",
            NumberCylinders,
            NumberHeads,
            NumberSectors,
            NumberDrives
            ));

        if(((UCHAR)DriveId & 0x7f) >= NumberDrives) {
            //
            // The requested drive does not exist
            //
            DBGOUT(("BiosDiskOpen: invalid drive\r\n"));
            DBGPAUSE
            return(EIO);
        }

        if (Retries == 5) {
            DBGOUT(("Couldn't get BIOS configuration info\n"));
            DBGPAUSE
            return(EIO);
        }

        //
        // Attempt to get extended int13 parameters.
        // Note that we use a buffer that's on the stack, so it's guaranteed
        // to be under the 1 MB line (required when passing buffers to real-mode
        // services).
        //
        // Note that we don't actually care about the parameters, just whether
        // extended int13 services are available.
        //
        RtlZeroMemory(Buffer,BufferSize);
        xInt13 = GET_XINT13_PARAMS(Buffer,(UCHAR)DriveId);

        DBGOUT(("BiosDiskOpen: xint13 for drive: %s\r\n",xInt13 ? "yes" : "no"));
    }

    //
    // Find an available FileId descriptor to open the device with
    //
    *FileId=2;

    while (BlFileTable[*FileId].Flags.Open != 0) {
        *FileId += 1;
        if(*FileId == BL_FILE_TABLE_SIZE) {
            DBGOUT(("BiosDiskOpen: no file table entry available\r\n"));
            DBGPAUSE
            return(ENOENT);
        }
    }

    //
    // We found an entry we can use, so mark it as open.
    //
    BlFileTable[*FileId].Flags.Open = 1;

    BlFileTable[*FileId].DeviceEntryTable = IsCd
                                          ? &BiosEDDSEntryTable
                                          : &BiosDiskEntryTable;

    Context = &(BlFileTable[*FileId].u.DriveContext);

    Context->IsCd = IsCd;
    Context->Drive = (UCHAR)DriveId;
    Context->Cylinders = NumberCylinders;
    Context->Heads = NumberHeads;
    Context->Sectors = NumberSectors;
    Context->xInt13 = xInt13;

    DBGOUT(("BiosDiskOpen: exit success\r\n"));

    return(ESUCCESS);
}


ARC_STATUS
BiospWritePartialSector(
    IN UCHAR Int13Unit,
    IN ULONGLONG Sector,
    IN PUCHAR Buffer,
    IN BOOLEAN IsHead,
    IN ULONG Bytes,
    IN UCHAR SectorsPerTrack,
    IN USHORT Heads,
    IN USHORT Cylinders,
    IN BOOLEAN AllowXInt13
    )
{
    ARC_STATUS Status;

    //
    // Read sector into the write buffer
    //
    Status = ReadPhysicalSectors(
                Int13Unit,
                Sector,
                1,
                FwDiskCache,
                SectorsPerTrack,
                Heads,
                Cylinders,
                AllowXInt13
                );

    if(Status != ESUCCESS) {
        return(Status);
    }

    //
    // Transfer the appropriate bytes from the user buffer to the write buffer
    //
    RtlMoveMemory(
        IsHead ? (FwDiskCache + Bytes) : FwDiskCache,
        Buffer,
        IsHead ? (SECTOR_SIZE - Bytes) : Bytes
        );

    //
    // Write the sector out
    //
    Status = WritePhysicalSectors(
                Int13Unit,
                Sector,
                1,
                FwDiskCache,
                SectorsPerTrack,
                Heads,
                Cylinders,
                AllowXInt13
                );

    return(Status);
}


ARC_STATUS
BiosDiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes sectors directly to an open physical disk.

Arguments:

    FileId - Supplies the file to write to

    Buffer - Supplies buffer with data to write

    Length - Supplies number of bytes to write

    Count - Returns actual bytes written

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed

--*/

{
    ULONGLONG HeadSector,TailSector,CurrentSector;
    UCHAR Int13Unit;
    ULONG HeadOffset,TailByteCount;
    UCHAR SectorsPerTrack;
    USHORT Heads,Cylinders;
    BOOLEAN AllowXInt13;
    ARC_STATUS Status;
    ULONG BytesLeftToTransfer;
    UCHAR SectorsToTransfer;
    BOOLEAN Under1MegLine;
    PVOID TransferBuffer;
    PUCHAR UserBuffer;
    ULONG         PhysicalSectors;

    BytesLeftToTransfer = Length;
    PhysicalSectors = SECTOR_SIZE;

    HeadSector = BlFileTable[FileId].Position.QuadPart / PhysicalSectors;
    HeadOffset = (ULONG)(BlFileTable[FileId].Position.QuadPart % PhysicalSectors);

    TailSector = (BlFileTable[FileId].Position.QuadPart + Length) / PhysicalSectors;
    TailByteCount = (ULONG)((BlFileTable[FileId].Position.QuadPart + Length) % PhysicalSectors);

    Int13Unit = BlFileTable[FileId].u.DriveContext.Drive;
    SectorsPerTrack = BlFileTable[FileId].u.DriveContext.Sectors;
    Heads = BlFileTable[FileId].u.DriveContext.Heads;
    Cylinders = BlFileTable[FileId].u.DriveContext.Cylinders;
    AllowXInt13 = BlFileTable[FileId].u.DriveContext.xInt13;

    UserBuffer = Buffer;

    //
    // If this write will even partially write over the sector cached
    // in the last read sector cache, invalidate the cache.
    //

    if (FwLastSectorCache.Initialized &&
        FwLastSectorCache.Valid &&
        (FwLastSectorCache.SectorNumber >= HeadSector) && 
        (FwLastSectorCache.SectorNumber <= TailSector)) {
        
        FwLastSectorCache.Valid = FALSE;
    }

    //
    // Special case of transfer occuring entirely within one sector
    //
    CurrentSector = HeadSector;
    if(HeadOffset && TailByteCount && (HeadSector == TailSector)) {

        Status = ReadPhysicalSectors(
                    Int13Unit,
                    CurrentSector,
                    1,
                    FwDiskCache,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13
                    );

        if(Status != ESUCCESS) {
            goto BiosDiskWriteDone;
        }

        RtlMoveMemory(FwDiskCache+HeadOffset,Buffer,Length);

        Status = WritePhysicalSectors(
                    Int13Unit,
                    CurrentSector,
                    1,
                    FwDiskCache,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13
                    );

        if(Status != ESUCCESS) {
            goto BiosDiskWriteDone;
        }

        BytesLeftToTransfer = 0;
        goto BiosDiskWriteDone;
    }

    if(HeadOffset) {

        Status = BiospWritePartialSector(
                    Int13Unit,
                    HeadSector,
                    Buffer,
                    TRUE,
                    HeadOffset,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13
                    );

        if(Status != ESUCCESS) {
            return(Status);
        }

        BytesLeftToTransfer -= PhysicalSectors - HeadOffset;
        UserBuffer += PhysicalSectors - HeadOffset;
        CurrentSector += 1;
    }

    if(TailByteCount) {

        Status = BiospWritePartialSector(
                    Int13Unit,
                    TailSector,
                    (PUCHAR)Buffer + Length - TailByteCount,
                    FALSE,
                    TailByteCount,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13
                    );

        if(Status != ESUCCESS) {
            return(Status);
        }

        BytesLeftToTransfer -= TailByteCount;
    }

    //
    // The following calculation is not inside the transfer loop because
    // it is unlikely that a caller's buffer will *cross* the 1 meg line
    // due to the PC memory map.
    //
    if((ULONG)UserBuffer + BytesLeftToTransfer <= 0x100000) {
        Under1MegLine = TRUE;
    } else {
        Under1MegLine = FALSE;
    }

    //
    // Now handle the middle part.  This is some number of whole sectors.
    //
    while(BytesLeftToTransfer) {

        //
        // The number of sectors to transfer is the minimum of:
        // - the number of sectors left in the current track
        // - BytesLeftToTransfer / SECTOR_SIZE
        //
        // Because sectors per track is 1-63 we know this will fit in a UCHAR
        //
        SectorsToTransfer = (UCHAR)min(
                                    SectorsPerTrack - (CurrentSector % SectorsPerTrack),
                                    BytesLeftToTransfer / PhysicalSectors
                                    );

        //
        // Now we'll figure out where to transfer the data from.  If the
        // caller's buffer is under the 1 meg line, we can transfer the
        // data directly from the caller's buffer.  Otherwise we'll copy the
        // user's buffer to our local buffer and transfer from there.
        // In the latter case we can only transfer in chunks of
        // SCRATCH_BUFFER_SIZE because that's the size of the local buffer.
        //
        // Also make sure the transfer won't cross a 64k boundary.
        //
        if(Under1MegLine) {
            //
            // Check if the transfer would cross a 64k boundary.  If so,
            // use the local buffer.  Otherwise use the user's buffer.
            //
            if(((ULONG)UserBuffer & 0xffff0000) !=
              (((ULONG)UserBuffer + (SectorsToTransfer * PhysicalSectors) - 1) & 0xffff0000))
            {
                TransferBuffer = FwDiskCache;
                SectorsToTransfer = min(SectorsToTransfer, SCRATCH_BUFFER_SIZE / (USHORT)PhysicalSectors);

            } else {

                TransferBuffer = UserBuffer;
            }
        } else {
            TransferBuffer = FwDiskCache;
            SectorsToTransfer = min(SectorsToTransfer, SCRATCH_BUFFER_SIZE / (USHORT)PhysicalSectors);
        }

        if(TransferBuffer == FwDiskCache) {
            RtlMoveMemory(FwDiskCache,UserBuffer,SectorsToTransfer*PhysicalSectors);
        }

        Status = WritePhysicalSectors(
                    Int13Unit,
                    CurrentSector,
                    SectorsToTransfer,
                    TransferBuffer,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13
                    );

        if(Status != ESUCCESS) {
            //
            // Tail part isn't contiguous with middle part
            //
            BytesLeftToTransfer += TailByteCount;
            return(Status);
        }

        CurrentSector += SectorsToTransfer;
        BytesLeftToTransfer -= SectorsToTransfer * PhysicalSectors;
        UserBuffer += SectorsToTransfer * PhysicalSectors;
    }

    Status = ESUCCESS;

    BiosDiskWriteDone:

    *Count = Length - BytesLeftToTransfer;
    BlFileTable[FileId].Position.QuadPart += *Count;
    return(Status);
}


ARC_STATUS
pBiosDiskReadWorker(
    IN  ULONG   FileId,
    OUT PVOID   Buffer,
    IN  ULONG   Length,
    OUT PULONG  Count,
    IN  USHORT  SectorSize,
    IN  BOOLEAN xInt13
    )

/*++

Routine Description:

    Reads sectors directly from an open physical disk.

Arguments:

    FileId - Supplies the file to read from

    Buffer - Supplies buffer to hold the data that is read

    Length - Supplies maximum number of bytes to read

    Count - Returns actual bytes read

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed

--*/

{
    ULONGLONG HeadSector,TailSector,CurrentSector;
    ULONG HeadOffset,TailByteCount;
    USHORT Heads,Cylinders;
    UCHAR SectorsPerTrack;
    UCHAR Int13Unit;
    ARC_STATUS Status;
    UCHAR SectorsToTransfer;
    ULONG NumBytesToTransfer;
    BOOLEAN Under1MegLine;
    PVOID TransferBuffer;
    BOOLEAN AllowXInt13;
    PUCHAR pDestInUserBuffer;
    PUCHAR pEndOfUserBuffer;
    PUCHAR pTransferDest;
    PUCHAR pSrc;
    ULONG CopyLength;
    ULONG ReadLength;
    PUCHAR pLastReadSector = NULL;
    ULONGLONG LastReadSectorNumber;
    PUCHAR TargetBuffer;

    DBGOUT(("BiosDiskRead: enter; length=0x%lx, sector size=%u, xint13=%u\r\n",Length,SectorSize,xInt13));

    //
    // Reset number of bytes transfered.
    //

    *Count = 0;

    //
    // Complete 0 length requests immediately.
    //

    if (Length == 0) {
        return ESUCCESS;
    }

    //
    // Initialize the last sector cache if it has not been 
    // initialized.
    //

    if (!FwLastSectorCache.Initialized) {
        FwLastSectorCache.Data = 
            FwAllocatePool(BL_LAST_SECTOR_CACHE_MAX_SIZE);

        if (FwLastSectorCache.Data) {
            FwLastSectorCache.Initialized = TRUE;
        }
    }

    //
    // Gather disk stats.
    //

    SectorsPerTrack = BlFileTable[FileId].u.DriveContext.Sectors;
    Heads = BlFileTable[FileId].u.DriveContext.Heads;
    Cylinders = BlFileTable[FileId].u.DriveContext.Cylinders;
    AllowXInt13 = BlFileTable[FileId].u.DriveContext.xInt13;
    Int13Unit = BlFileTable[FileId].u.DriveContext.Drive;

    DBGOUT(("BiosDiskRead: unit 0x%x CHS=%lu %lu %lu\r\n",
            Int13Unit,
            Cylinders,
            Heads,
            SectorsPerTrack));

    //
    // Initialize locals that denote where we are in satisfying the
    // request.
    //

    //
    // If the buffer is in the first 1MB of KSEG0, we want to use the
    // identity-mapped address
    //
    if (((ULONG_PTR)((PUCHAR)Buffer+Length) & ~KSEG0_BASE) < BIOSDISK_1MB) {
        pDestInUserBuffer = (PUCHAR)((ULONG_PTR)Buffer & ~KSEG0_BASE);
    } else {
        pDestInUserBuffer = Buffer;
    }
    
    pEndOfUserBuffer = (PUCHAR) pDestInUserBuffer + Length;
    TargetBuffer = pDestInUserBuffer;
    
    //
    // Calculating these before hand makes it easier to hand the
    // special cases. Note that tail sector is the last sector this
    // read wants bytes from. That is why we subtract one. We handle 
    // the Length == 0 case above.
    //

    HeadSector = BlFileTable[FileId].Position.QuadPart / SectorSize;
    HeadOffset = (ULONG)(BlFileTable[FileId].Position.QuadPart % SectorSize);

    TailSector = (BlFileTable[FileId].Position.QuadPart + Length - 1) / SectorSize;
    TailByteCount = (ULONG)((BlFileTable[FileId].Position.QuadPart + Length - 1) % SectorSize);
    TailByteCount ++;

    //
    // While there is data we should read, read.
    //
    
    CurrentSector = HeadSector;

    while (pDestInUserBuffer != pEndOfUserBuffer) {
        //
        // Look to see if we can find the current sector we have to 
        // read in the last sector cache.
        //
        
        if (FwLastSectorCache.Valid &&
            FwLastSectorCache.DeviceId == FileId &&
            FwLastSectorCache.SectorNumber == CurrentSector) {

            pSrc = FwLastSectorCache.Data;
            CopyLength = SectorSize;

            //
            // Adjust copy parameters depending on whether
            // this sector is the Head and/or Tail sector.
            //

            if (HeadSector == CurrentSector) {
                pSrc += HeadOffset;
                CopyLength -= HeadOffset;
            }

            if (TailSector == CurrentSector) {
                CopyLength -= (SectorSize - TailByteCount);
            }

            //
            // Copy the cached data to users buffer.
            //
           
            RtlCopyMemory(pDestInUserBuffer, pSrc, CopyLength);

            //
            // Update our status.
            //

            CurrentSector += 1;
            pDestInUserBuffer += CopyLength;
            *Count += CopyLength;

            continue;
        }

        //
        // Calculate number of sectors we have to read. Read a maximum
        // of SCRATCH_BUFFER_SIZE so we can use our local buffer if the
        // user's buffer crosses 64KB boundary or is not under 1MB.
        //
        
        SectorsToTransfer = (UCHAR)min ((LONG) (TailSector - CurrentSector + 1),
                                         SCRATCH_BUFFER_SIZE / SectorSize);
        if (!xInt13) {
            //
            // Make sure the number of sectors to transfer does not exceed
            // the number of sectors left in the track.
            //
            SectorsToTransfer = (UCHAR)min(SectorsPerTrack - (CurrentSector % SectorsPerTrack),
                                           SectorsToTransfer);
        }
        NumBytesToTransfer = SectorsToTransfer * SectorSize;

        //
        // Determine where we want to read into. We can use the
        // current chunk of user buffer only if it is under 1MB and
        // does not cross a 64KB boundary, and it can take all we want
        // to read into it.
        //
        
        if (((ULONG_PTR) pDestInUserBuffer + NumBytesToTransfer < BIOSDISK_1MB) && 
            (((ULONG_PTR) pDestInUserBuffer & BIOSDISK_64KB_MASK) ==
             (((ULONG_PTR) pDestInUserBuffer + NumBytesToTransfer) & BIOSDISK_64KB_MASK)) &&
            ((pEndOfUserBuffer - pDestInUserBuffer) >= (LONG) NumBytesToTransfer)) {

            pTransferDest = pDestInUserBuffer;

        } else {

            pTransferDest = FwDiskCache;
        }
        
        //
        // Perform the read.
        //

        if(xInt13) {
            Status = ReadExtendedPhysicalSectors(Int13Unit,
                                                 CurrentSector,
                                                 SectorsToTransfer,
                                                 pTransferDest);
        } else {
            Status = ReadPhysicalSectors(Int13Unit,
                                         CurrentSector,
                                         SectorsToTransfer,
                                         pTransferDest,
                                         SectorsPerTrack,
                                         Heads,
                                         Cylinders,
                                         AllowXInt13);
        }

        if(Status != ESUCCESS) {
            DBGOUT(("BiosDiskRead: read failed with %u\r\n",Status));
            goto BiosDiskReadDone;
        }

        //
        // Note the last sector that was read from the disk.
        //

        pLastReadSector = pTransferDest + (SectorsToTransfer - 1) * SectorSize;
        LastReadSectorNumber = CurrentSector + SectorsToTransfer - 1;

        //
        // Note the amount read.
        //
        
        ReadLength = NumBytesToTransfer;

        //
        // Copy transfered data into user's buffer if we did not
        // directly read into that.
        //

        if (pTransferDest != pDestInUserBuffer) {
            pSrc = pTransferDest;
            CopyLength = NumBytesToTransfer;

            //
            // Adjust copy parameters depending on whether
            // we have read the Head and/or Tail sectors.
            //

            if (HeadSector == CurrentSector) {
                pSrc += HeadOffset;
                CopyLength -= HeadOffset;
            } 

            if (TailSector == CurrentSector + SectorsToTransfer - 1) {
                CopyLength -= (SectorSize - TailByteCount);
            }

            //
            // Copy the read data to users buffer.
            //            
            ASSERT(pDestInUserBuffer >= TargetBuffer);
            ASSERT(pEndOfUserBuffer >= pDestInUserBuffer + CopyLength);
            ASSERT(CopyLength <= SCRATCH_BUFFER_SIZE);
            ASSERT(pSrc >= (PUCHAR) FwDiskCache);
            ASSERT(pSrc < (PUCHAR) FwDiskCache + SCRATCH_BUFFER_SIZE);
            
            RtlCopyMemory(pDestInUserBuffer, pSrc, CopyLength);

            //
            // Adjust the amount read into user's buffer.
            //
            
            ReadLength = CopyLength;
        }
        
        //
        // Update our status.
        //

        CurrentSector += SectorsToTransfer;
        pDestInUserBuffer += ReadLength;
        *Count += ReadLength;
    }

    //
    // Update the last read sector cache.
    //

    if (pLastReadSector && 
        FwLastSectorCache.Initialized &&
        BL_LAST_SECTOR_CACHE_MAX_SIZE >= SectorSize) {

        FwLastSectorCache.DeviceId = FileId;
        FwLastSectorCache.SectorNumber = LastReadSectorNumber;

        RtlCopyMemory(FwLastSectorCache.Data, 
                      pLastReadSector,
                      SectorSize);

        FwLastSectorCache.Valid = TRUE;
    }

    DBGOUT(("BiosDiskRead: exit success\r\n"));
    Status = ESUCCESS;

    BiosDiskReadDone:

    BlFileTable[FileId].Position.QuadPart += *Count;
    return(Status);
}


ARC_STATUS
BiosDiskRead(
    IN  ULONG  FileId,
    OUT PVOID  Buffer,
    IN  ULONG  Length,
    OUT PULONG Count
    )
{
    USHORT    PhysicalSectors;

    PhysicalSectors = SECTOR_SIZE;
    return(pBiosDiskReadWorker(FileId,Buffer,Length,Count,PhysicalSectors,FALSE));
}


ARC_STATUS
BiosElToritoDiskRead(
    IN  ULONG  FileId,
    OUT PVOID  Buffer,
    IN  ULONG  Length,
    OUT PULONG Count
    )
{
    return(pBiosDiskReadWorker(FileId,Buffer,Length,Count,2048,TRUE));
}


ARC_STATUS
BiosPartitionGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    )
{
    //
    // THIS ROUTINE DOES NOT WORK FOR PARTITION 0.
    //

    PPARTITION_CONTEXT Context;

    RtlZeroMemory(Finfo, sizeof(FILE_INFORMATION));

    Context = &BlFileTable[FileId].u.PartitionContext;

    Finfo->StartingAddress.QuadPart = Context->StartingSector;    
    Finfo->StartingAddress.QuadPart = Finfo->StartingAddress.QuadPart << (CCHAR)Context->SectorShift;   
    Finfo->EndingAddress.QuadPart = Finfo->StartingAddress.QuadPart + Context->PartitionLength.QuadPart;
    Finfo->Type = DiskPeripheral;

    return ESUCCESS;
}

ARC_STATUS
BiosDiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    )
/*++

Routine Description:

    Gets the information about the isk.

Arguments:

    FileId - The file id to the disk for which information is needed

    FileInfo - Place holder for returning information about the disk

Return Value:

    ESUCCESS if successful, otherwise appropriate ARC error code.

--*/
{
    ARC_STATUS Result = EINVAL;

    if (FileInfo) {
        PDRIVE_CONTEXT  DriveContext;
        LONGLONG   DriveSize = 0;
        ULONG SectorSize = SECTOR_SIZE;

        DriveContext = &(BlFileTable[FileId].u.DriveContext);
        Result = EIO;

        //
        // NOTE : SectorSize == 512 bytes for everything except
        // Eltorito disks for which sector size is 2048.
        //
        if (DriveContext->IsCd) {
            SectorSize = 2048;
        }
        
        DriveSize = (DriveContext->Heads * DriveContext->Cylinders * 
                        DriveContext->Sectors * SectorSize);

        if (DriveSize) {
            RtlZeroMemory(FileInfo, sizeof(FILE_INFORMATION));        
            
            FileInfo->StartingAddress.QuadPart = 0;
            FileInfo->EndingAddress.QuadPart = DriveSize;
            FileInfo->CurrentPosition = BlFileTable[FileId].Position;

            //
            // Any thing less than 3MB is floppy drive
            //
            if (DriveSize <= 0x300000) {
                FileInfo->Type = FloppyDiskPeripheral;
            } else {
                FileInfo->Type = DiskPeripheral;
            }

            Result = ESUCCESS;
        }            
    }        

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\amd64_stub.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    amd64.c

Abstract:

    This module contains stub functions to support the AMD64 processor.

Author:

    Forrest Foltz (forrestf) 20-Apr-2000

Environment:


Revision History:

--*/

#include "amd64bl.h"

BOOLEAN
BlDetectAmd64(
    VOID
    )
{
    return FALSE;
}

ARC_STATUS
BlPrepareAmd64Phase1(
    VOID
    )
{
    return ESUCCESS;
}

ARC_STATUS
BlPrepareAmd64Phase2(
    VOID
    )
{
    return ESUCCESS;
}

VOID
BlEnableAmd64LongMode(
    VOID
    )
{
    NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\arcemul.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    arcemul.c

Abstract:

    This module provides the x86 emulation for the Arc routines which are
    built into the firmware on ARC machines.

    N. B.   This is where all the initialization of the SYSTEM_PARAMETER_BLOCK
            takes place.  If there is any non-standard hardware, some of the
            vectors may have to be changed.  This is where to do it.


Author:

    John Vert (jvert) 13-Jun-1991

Environment:

    x86 only

Revision History:

--*/

#include "arccodes.h"
#include "bootx86.h"
#include "ntdddisk.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "scsi.h"
#include "scsiboot.h"
#include "ramdisk.h"

#define CMOS_CONTROL_PORT ((PUCHAR)0x70)
#define CMOS_DATA_PORT    ((PUCHAR)0x71)
#define CMOS_STATUS_B     0x0B
#define CMOS_DAYLIGHT_BIT 1

extern PCHAR MnemonicTable[];

//
// Size definitions for HardDiskInitialize()
//

#define SUPPORTED_NUMBER_OF_DISKS 32
#define SIZE_FOR_SUPPORTED_DISK_STRUCTURE (SUPPORTED_NUMBER_OF_DISKS*sizeof(DRIVER_LOOKUP_ENTRY))

BOOLEAN AEBiosDisabled = FALSE;

// spew UTF8 data over the headless port on FE builds.
#define UTF8_CLIENT_SUPPORT (1)


BOOLEAN AEArcDiskInformationInitialized = FALSE;
ARC_DISK_INFORMATION AEArcDiskInformation;

PDRIVER_UNLOAD AEDriverUnloadRoutine = NULL;

#define PORT_BUFFER_SIZE 10
UCHAR PortBuffer[PORT_BUFFER_SIZE];
ULONG PortBufferStart = 0;
ULONG PortBufferEnd = 0;

//
// Macro for aligning buffers. It returns the aligned pointer into the
// buffer. Buffer should be of size you want to use + alignment.
//

#define ALIGN_BUFFER_ON_BOUNDARY(Buffer,Alignment) ((PVOID) \
 ((((ULONG_PTR)(Buffer) + (Alignment) - 1)) & (~((ULONG_PTR)(Alignment) - 1))))

//
// Miniport DriverEntry typedef
//

typedef NTSTATUS
(*PDRIVER_ENTRY) (
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Parameter2
    );

typedef
BOOLEAN
(*PFWNODE_CALLBACK)(
    IN PCONFIGURATION_COMPONENT FoundComponent
    );

//
// Private function prototypes
//

ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    );

PCONFIGURATION_COMPONENT
AEComponentInfo(
    IN PCONFIGURATION_COMPONENT Current
    );

PCONFIGURATION_COMPONENT
FwGetChild(
    IN PCONFIGURATION_COMPONENT Current
    );

BOOLEAN
FwSearchTree(
    IN PCONFIGURATION_COMPONENT Node,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN ULONG Key,
    IN PFWNODE_CALLBACK CallbackRoutine
    );

PCHAR
AEGetEnvironment(
    IN PCHAR Variable
    );

PCONFIGURATION_COMPONENT
FwGetPeer(
    IN PCONFIGURATION_COMPONENT Current
    );

BOOLEAN
AEEnumerateDisks(
    PCONFIGURATION_COMPONENT Disk
    );

VOID
AEGetArcDiskInformation(
    VOID
    );

VOID
AEGetPathnameFromComponent(
    IN PCONFIGURATION_COMPONENT Component,
    OUT PCHAR ArcName
    );

PCONFIGURATION_COMPONENT
AEGetParent(
    IN PCONFIGURATION_COMPONENT Current
    );

ARC_STATUS
AEGetConfigurationData(
    IN PVOID ConfigurationData,
    IN PCONFIGURATION_COMPONENT Current
    );

PMEMORY_DESCRIPTOR
AEGetMemoryDescriptor(
    IN PMEMORY_DESCRIPTOR MemoryDescriptor OPTIONAL
    );

ARC_STATUS
AEOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
AEClose(
    IN ULONG FileId
    );

ARC_STATUS
AERead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
AEReadStatus (
    IN ULONG FileId
    );

VOID
AEReboot(
    VOID
    );

ARC_STATUS
AESeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
AEWrite (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
AEGetFileInformation(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInformation
    );

PTIME_FIELDS
AEGetTime(
    VOID
    );

ULONG
AEGetRelativeTime(
    VOID
    );

ARC_STATUS
ScsiDiskClose (
    IN ULONG FileId
    );

ARC_STATUS
ScsiDiskMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
ScsiDiskOpen (
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
ScsiDiskRead (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
ScsiDiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
ScsiDiskWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

VOID
HardDiskInitialize(
    IN OUT PVOID LookupTable,
    IN ULONG Entries,
    IN PVOID DeviceFoundCallback
    );

BOOLEAN
AEReadDiskSignature(
    IN PCHAR DiskName,
    IN BOOLEAN IsCdRom
    );

//
// This is the x86 version of the system parameter block on the ARC machines.
// It lives here, and any module that uses an ArcXXXX routine must declare
// it external.  Machines that have other than very plain-vanilla hardware
// may have to replace some of the hard-wired vectors with different
// procedures.
//

PVOID GlobalFirmwareVectors[MaximumRoutine];

SYSTEM_PARAMETER_BLOCK GlobalSystemBlock =
    {
        0,                              // Signature??
        sizeof(SYSTEM_PARAMETER_BLOCK), // Length
        0,                              // Version
        0,                              // Revision
        NULL,                           // RestartBlock
        NULL,                           // DebugBlock
        NULL,                           // GenerateExceptionVector
        NULL,                           // TlbMissExceptionVector
        MaximumRoutine,                 // FirmwareVectorLength
        GlobalFirmwareVectors,          // Pointer to vector block
        0,                              // VendorVectorLength
        NULL                            // Pointer to vendor vector block
    };


extern BL_FILE_TABLE BlFileTable[BL_FILE_TABLE_SIZE];

//
// temptemp John Vert (jvert) 6-Sep-1991
//      Just do this until we can make our device driver interface look
//      like the ARC firmware one.
//

extern BL_DEVICE_ENTRY_TABLE ScsiDiskEntryTable;

ULONG FwStallCounter;



//
// This table provides a quick lookup conversion between ASCII values
// that fall between 128 and 255, and their UNICODE counterpart.
//
// Note that ASCII values between 0 and 127 are equvilent to their
// unicode counter parts, so no lookups would be required.
//
// Therefore when using this table, remove the high bit from the ASCII
// value and use the resulting value as an offset into this array.  For
// example, 0x80 ->(remove the high bit) 00 -> 0x00C7.
//
USHORT PcAnsiToUnicode[0xFF] = {
        0x00C7,
        0x00FC,
        0x00E9,
        0x00E2,
        0x00E4,
        0x00E0,
        0x00E5,
        0x0087,
        0x00EA,
        0x00EB,
        0x00E8,
        0x00EF,
        0x00EE,
        0x00EC,
        0x00C4,
        0x00C5,
        0x00C9,
        0x00E6,
        0x00C6,
        0x00F4,
        0x00F6,
        0x00F2,
        0x00FB,
        0x00F9,
        0x00FF,
        0x00D6,
        0x00DC,
        0x00A2,
        0x00A3,
        0x00A5,
        0x20A7,
        0x0192,
        0x00E1,
        0x00ED,
        0x00F3,
        0x00FA,
        0x00F1,
        0x00D1,
        0x00AA,
        0x00BA,
        0x00BF,
        0x2310,
        0x00AC,
        0x00BD,
        0x00BC,
        0x00A1,
        0x00AB,
        0x00BB,
        0x2591,
        0x2592,
        0x2593,
        0x2502,
        0x2524,
        0x2561,
        0x2562,
        0x2556,
        0x2555,
        0x2563,
        0x2551,
        0x2557,
        0x255D,
        0x255C,
        0x255B,
        0x2510,
        0x2514,
        0x2534,
        0x252C,
        0x251C,
        0x2500,
        0x253C,
        0x255E,
        0x255F,
        0x255A,
        0x2554,
        0x2569,
        0x2566,
        0x2560,
        0x2550,
        0x256C,
        0x2567,
        0x2568,
        0x2564,
        0x2565,
        0x2559,
        0x2558,
        0x2552,
        0x2553,
        0x256B,
        0x256A,
        0x2518,
        0x250C,
        0x2588,
        0x2584,
        0x258C,
        0x2590,
        0x2580,
        0x03B1,
        0x00DF,
        0x0393,
        0x03C0,
        0x03A3,
        0x03C3,
        0x00B5,
        0x03C4,
        0x03A6,
        0x0398,
        0x03A9,
        0x03B4,
        0x221E,
        0x03C6,
        0x03B5,
        0x2229,
        0x2261,
        0x00B1,
        0x2265,
        0x2264,
        0x2320,
        0x2321,
        0x00F7,
        0x2248,
        0x00B0,
        0x2219,
        0x00B7,
        0x221A,
        0x207F,
        0x00B2,
        0x25A0,
        0x00A0
        };



VOID
AEInitializeStall(
    VOID
    )
{
    FwStallCounter = GET_STALL_COUNT();

    return;
}


ARC_STATUS
AEInitializeIo(
    IN ULONG DriveId
    )

/*++

Routine Description:

    Initializes SCSI boot driver, if any.  Loads ntbootdd.sys from the
    boot partition, binds it to the osloader, and initializes it.

Arguments:

    DriveId - file id of the opened boot partition

Return Value:

    ESUCCESS - Drivers successfully initialized

--*/

{
    extern ULONG ScsiPortCount;
    extern ULONG MachineType;
    ARC_STATUS Status;
    PVOID Buffer;
    PVOID ImageBase;
    PKLDR_DATA_TABLE_ENTRY DriverDataTableEntry;
    PDRIVER_ENTRY Entry;
    extern MEMORY_DESCRIPTOR MDArray[];

    ScsiPortCount = 0;

    FwStallCounter = GET_STALL_COUNT();
    Status = BlLoadImage(DriveId,
                         MemoryFirmwarePermanent,
                         "\\NTBOOTDD.SYS",
                         TARGET_IMAGE,
                         &ImageBase);

    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Find the memory descriptor for this entry in the table in the loader
    // block and then allocate it in the MD array.
    //

    {
        ULONG imageBasePage;
        ULONG imageEndPage = 0;
        PLIST_ENTRY entry;

        imageBasePage = (((ULONG)ImageBase) & 0x7fffffff) >> PAGE_SHIFT;

        entry = BlLoaderBlock->MemoryDescriptorListHead.Flink;

        while(entry != &(BlLoaderBlock->MemoryDescriptorListHead)) {
            PMEMORY_ALLOCATION_DESCRIPTOR descriptor;

            descriptor = CONTAINING_RECORD(entry,
                                           MEMORY_ALLOCATION_DESCRIPTOR,
                                           ListEntry);

            if(descriptor->BasePage == imageBasePage) {
                imageEndPage = imageBasePage + descriptor->PageCount;
                break;
            }

            entry = entry->Flink;
        }

        if(imageEndPage == 0) {
            return EINVAL;
        }

        Status = MempAllocDescriptor(imageBasePage,
                                     imageEndPage,
                                     MemoryFirmwareTemporary);

        if(Status != ESUCCESS) {
            return EINVAL;
        }
    }

    Status = BlAllocateDataTableEntry("NTBOOTDD.SYS",
                                      "\\NTBOOTDD.SYS",
                                      ImageBase,
                                      &DriverDataTableEntry);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // [ChuckL 2001-Dec-04]
    // BlAllocateDataTableEntry inserts the data table entry for NTBOOTDD.SYS
    // into BlLoaderBlock->LoadOrderListHead. We don't want this, for at least
    // two reasons:
    //
    //      1) This entry is only temporarily loaded for use by the loader. We
    //         don't want the kernel to think that it's loaded.
    //
    //      2) There is code in the kernel (MM) that assumes that the first two
    //         entries in the list are the kernel and HAL. But we've just
    //         inserted ntbootdd.sys as the first entry. This really screws up
    //         MM, because it ends up moving the HAL as if it were a loaded
    //         driver.
    //
    // Prior to a change to boot\bldr\osloader.c, the routine BlMemoryInitialize()
    // was called twice during loader init. The second call occurred after ntbootdd
    // was loaded, and reinitialized the LoadOrderListHead, thereby eliminating (by
    // accident) ntbootdd from the module list. Now we don't do the second memory
    // initialization, so we have to explicitly remove ntbootdd from the list.
    //

    RemoveEntryList(&DriverDataTableEntry->InLoadOrderLinks);

    //
    // Scan the import table and bind to osloader
    //

    Status = BlScanOsloaderBoundImportTable(DriverDataTableEntry);

    if (Status != ESUCCESS) {
        return(Status);
    }

    Entry = (PDRIVER_ENTRY)DriverDataTableEntry->EntryPoint;

    //
    // Before calling into the driver we need to collect ARC info blocks
    // for all the bios based devices.
    //

    AEGetArcDiskInformation();

    //
    // Zero out the driver object.
    //

    Status = (*Entry)(NULL, NULL);

    if (Status == ESUCCESS) {

        Buffer = FwAllocateHeap(SIZE_FOR_SUPPORTED_DISK_STRUCTURE);

        if(Buffer == NULL) {
            return ENOMEM;
        }

        HardDiskInitialize(Buffer, SUPPORTED_NUMBER_OF_DISKS, NULL);
    }

    if(Status == ESUCCESS) {
        AEBiosDisabled = TRUE;
    }
    return(Status);
}


VOID
BlFillInSystemParameters(
    IN PBOOT_CONTEXT BootContextRecord
    )
/*++

Routine Description:

    This routine fills in all the fields in the Global System Parameter Block
    that it can.  This includes all the firmware vectors, the vendor-specific
    information, and anything else that may come up.

Arguments:

    None.


Return Value:

    None.

--*/

{
    int cnt;

    //
    // Fill in the pointers to the firmware functions which we emulate.
    // Those which we don't emulate are stubbed by BlArcNotYetImplemented,
    // which will print an error message if it is accidentally called.
    //

    for (cnt=0; cnt<MaximumRoutine; cnt++) {
        GlobalFirmwareVectors[cnt]=(PVOID)BlArcNotYetImplemented;
    }
    GlobalFirmwareVectors[CloseRoutine]  = (PVOID)AEClose;
    GlobalFirmwareVectors[OpenRoutine]  = (PVOID)AEOpen;
    GlobalFirmwareVectors[MemoryRoutine]= (PVOID)AEGetMemoryDescriptor;
    GlobalFirmwareVectors[SeekRoutine]  = (PVOID)AESeek;
    GlobalFirmwareVectors[ReadRoutine]  = (PVOID)AERead;
    GlobalFirmwareVectors[ReadStatusRoutine]  = (PVOID)AEReadStatus;
    GlobalFirmwareVectors[WriteRoutine] = (PVOID)AEWrite;
    GlobalFirmwareVectors[GetFileInformationRoutine] = (PVOID)AEGetFileInformation;
    GlobalFirmwareVectors[GetTimeRoutine] = (PVOID)AEGetTime;
    GlobalFirmwareVectors[GetRelativeTimeRoutine] = (PVOID)AEGetRelativeTime;

    GlobalFirmwareVectors[GetPeerRoutine] = (PVOID)FwGetPeer;
    GlobalFirmwareVectors[GetChildRoutine] = (PVOID)FwGetChild;
    GlobalFirmwareVectors[GetParentRoutine] = (PVOID)AEGetParent;
    GlobalFirmwareVectors[GetComponentRoutine] = (PVOID)FwGetComponent;
    GlobalFirmwareVectors[GetDataRoutine] = (PVOID)AEGetConfigurationData;
    GlobalFirmwareVectors[GetEnvironmentRoutine] = (PVOID)AEGetEnvironment;

    GlobalFirmwareVectors[RestartRoutine] = (PVOID)AEReboot;
    GlobalFirmwareVectors[RebootRoutine] = (PVOID)AEReboot;

}


PMEMORY_DESCRIPTOR
AEGetMemoryDescriptor(
    IN PMEMORY_DESCRIPTOR MemoryDescriptor OPTIONAL
    )

/*++

Routine Description:

    Emulates the Arc GetMemoryDescriptor call.  This must translate
    between the memory description passed to us by the SU module and
    the MEMORYDESCRIPTOR type defined by ARC.

Arguments:

    MemoryDescriptor - Supplies current memory descriptor.
        If MemoryDescriptor==NULL, return the first memory descriptor.
        If MemoryDescriptor!=NULL, return the next memory descriptor.

Return Value:

    Next memory descriptor in the list.
    NULL if MemoryDescriptor is the last descriptor in the list.

--*/

{
    extern MEMORY_DESCRIPTOR MDArray[];
    extern ULONG NumberDescriptors;
    PMEMORY_DESCRIPTOR Return;
    if (MemoryDescriptor==NULL) {
        Return=MDArray;
    } else {
        if((ULONG)(MemoryDescriptor-MDArray) >= (NumberDescriptors-1)) {
            return NULL;
        } else {
            Return = ++MemoryDescriptor;
        }
    }
    return(Return);

}


ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    )

/*++

Routine Description:

    This is a stub routine used to fill in the firmware vectors which haven't
    been defined yet.  It uses BlPrint to print a message on the screen.

Arguments:

    None.

Return Value:

    EINVAL

--*/

{
    BlPrint("ERROR - Unimplemented Firmware Vector called (FID %lx)\n",
            FileId );
    return(EINVAL);
}


PCONFIGURATION_COMPONENT
FwGetChild(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetChild.  Based on the current
    component, it returns the component's child component.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;

    //
    // if current component is NULL, return a pointer to first system
    // component; otherwise return current component's child component.
    //

    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Child) {
            return(&(CurrentEntry->Child->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        if (FwConfigurationTree) {
            return(&(FwConfigurationTree->ComponentEntry));
        } else {
            return(NULL);
        }
    }

}


PCONFIGURATION_COMPONENT
FwGetPeer(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetPeer.  Based on the current
    component, it returns the component's sibling.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Sibling) {
            return(&(CurrentEntry->Sibling->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        return(NULL);
    }

}


PCONFIGURATION_COMPONENT
AEGetParent(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetParent.  Based on the current
    component, it returns the component's parent.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Parent) {
            return(&(CurrentEntry->Parent->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        return(NULL);
    }

}


ARC_STATUS
AEGetConfigurationData(
    IN PVOID ConfigurationData,
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetParent.  Based on the current
    component, it returns the component's parent.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    ESUCCESS - Data successfully returned.


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        RtlMoveMemory(ConfigurationData,
                      CurrentEntry->ConfigurationData,
                      Current->ConfigurationDataLength);
        return(ESUCCESS);
    } else {
        return(EINVAL);
    }

}


PCHAR
AEGetEnvironment(
    IN PCHAR Variable
    )

/*++

Routine Description:

    This is the arc emulation routine for ArcGetEnvironment.  It returns
    the value of the specified NVRAM environment variable.

    NOTE John Vert (jvert) 23-Apr-1992
        This particular implementation uses the Daylight Savings Bit on
        the Real Time Clock to reflect the state of the LastKnownGood
        environment variable.  This is the only variable we support.

Arguments:

    Variable - Supplies the name of the environment variable to look up.

Return Value:

    A pointer to the specified environment variable's value, or
    NULL if the variable does not exist.

--*/

{
    UCHAR StatusByte;

    if (_stricmp(Variable, "LastKnownGood") != 0) {
        return(NULL);
    }

    //
    // Read the Daylight Savings Bit out of the RTC to determine whether
    // the LastKnownGood environment variable is TRUE or FALSE.
    //

    WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
    StatusByte = READ_PORT_UCHAR(CMOS_DATA_PORT);
    if (StatusByte & CMOS_DAYLIGHT_BIT) {
        return("TRUE");
    } else {
        return(NULL);
    }


}


ARC_STATUS
AEOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens the file or device specified by OpenPath.

Arguments:

    OpenPath - Supplies a pointer to the fully-qualified path name.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only
                1 - Write Only
                2 - Read/Write

    FileId - Returns the file descriptor for use with the Close, Read, Write,
             and Seek routines

Return Value:

    ESUCCESS - File successfully opened.

--*/

{
    ARC_STATUS Status;
    CHAR Buffer[128];

    Status = RamdiskOpen( OpenPath,
                          OpenMode,
                          FileId );

    if (Status == ESUCCESS) {
        return(ESUCCESS);
    }

    Status = BiosConsoleOpen( OpenPath,
                              OpenMode,
                              FileId );

    if (Status == ESUCCESS) {
        return(ESUCCESS);
    }

    //
    // Once a disk driver has been loaded we need to disable bios access to
    // all drives to avoid mixing bios & driver i/o operations.
    //

    if(AEBiosDisabled == FALSE) {
        Status = BiosPartitionOpen( OpenPath,
                                    OpenMode,
                                    FileId );

        if (Status == ESUCCESS) {
            return(ESUCCESS);
        }
    }

    //
    // It's not the console or a BIOS partition, so let's try the SCSI
    // driver.
    //

    //
    // Find a free FileId
    //

    *FileId = 2;
    while (BlFileTable[*FileId].Flags.Open == 1) {
        *FileId += 1;
        if (*FileId == BL_FILE_TABLE_SIZE) {
            return(ENOENT);
        }
    }

    strcpy(Buffer,OpenPath);

    Status = ScsiDiskOpen( Buffer,
                           OpenMode,
                           FileId );

    if (Status == ESUCCESS) {

        //
        // SCSI successfully opened it.  For now, we stick the appropriate
        // SCSI DeviceEntryTable into the BlFileTable.  This is temporary.
        //

        BlFileTable[*FileId].Flags.Open = 1;
        BlFileTable[*FileId].DeviceEntryTable = &ScsiDiskEntryTable;
        return(ESUCCESS);
    }

    return(Status);
}


ARC_STATUS
AESeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    Changes the current offset of the file specified by FileId

Arguments:

    FileId - specifies the file on which the current offset is to
             be changed.

    Offset - New offset into file.

    SeekMode - Either SeekAbsolute or SeekRelative
               SeekEndRelative is not supported

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{
    return(BlFileTable[FileId].DeviceEntryTable->Seek)( FileId,
                                                        Offset,
                                                        SeekMode );
}


ARC_STATUS
AEClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the file specified by FileId

Arguments:

    FileId - specifies the file to close

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{

    return(BlFileTable[FileId].DeviceEntryTable->Close)(FileId);

}


ARC_STATUS
AEReadStatus(
    IN ULONG FileId
    )

/*++

Routine Description:

    Determines if data is available on the specified device

Arguments:

    FileId - Specifies the device to check for data.

Return Value:

    ESUCCESS - At least one byte is available.

    EAGAIN - No data is available

--*/

{
    //
    // Special case for console input
    //
    if (FileId == 0) {

        //
        // Give priority to dumb terminal
        //
        if (BlIsTerminalConnected() && (PortBufferStart != PortBufferEnd)) {
            return(ESUCCESS);
        }

        if (BlIsTerminalConnected() && (BlPortPollOnly(BlTerminalDeviceId) == CP_GET_SUCCESS)) {
            return(ESUCCESS);
        }
        return(BiosConsoleReadStatus(FileId));
    } else {
        return(BlArcNotYetImplemented(FileId));
    }

}


ARC_STATUS
AERead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Reads from the specified file or device

Arguments:

    FileId - specifies the file to read from

    Buffer - Address of buffer to hold the data that is read

    Length - Maximum number of bytes to read

    Count -  Address of location in which to store the actual bytes read.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    ULONG Limit;
    ULONG PartCount;
    PCHAR TmpBuffer;
    ULONG StartTime;
    ULONG LastTime;
    UCHAR Ch;

    //
    // Special case console input
    //
    if (FileId == 0) {

RetryRead:

        if (BlIsTerminalConnected()) {

            *Count = 0;
            TmpBuffer = (PCHAR)Buffer;

            while (*Count < Length) {

                //
                // First return any buffered input
                //
                if (PortBufferStart != PortBufferEnd) {
                    TmpBuffer[*Count] = PortBuffer[PortBufferStart];
                    PortBufferStart++;
                    PortBufferStart = PortBufferStart % PORT_BUFFER_SIZE;
                    *Count = *Count + 1;
                    continue;
                }

                //
                // Now check for new input
                //
                if (BlPortPollByte(BlTerminalDeviceId, TmpBuffer + *Count) != CP_GET_SUCCESS) {
                    break;
                }

                //
                // Convert ESC key to the local equivalent
                //
                if (TmpBuffer[*Count] == 0x1b) {
                    TmpBuffer[*Count] = (CHAR)ASCI_CSI_IN;

                    //
                    // Wait for the user to type a key.
                    //
                    StartTime = AEGetRelativeTime();

                    while (BlPortPollOnly(BlTerminalDeviceId) != CP_GET_SUCCESS) {
                        LastTime = AEGetRelativeTime();

                        //
                        // if the counter wraps back to zero, just restart the wait.
                        //
                        if (LastTime < StartTime) {
                            StartTime = LastTime;
                        }

                        //
                        // If one second has passed, the user must have just wanted a single
                        // escape key, so return with that.
                        //
                        if ((LastTime - StartTime) > 1) {
                            *Count = *Count + 1;
                            return (ESUCCESS);
                        }

                    }

                    //
                    // We have another key, get it and translate the escape sequence.
                    //
                    if (BlPortPollByte(BlTerminalDeviceId, &Ch) != CP_GET_SUCCESS) {
                        *Count = *Count + 1;
                        return (ESUCCESS);
                    }


                    switch (Ch) {
                    case '@': // F12 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'B';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '!': // F11 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'A';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '0': // F10 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'M';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '9': // F9 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'p';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '8': // F8 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'r';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '7': // F7 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'q';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '6': // F6 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'u';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '5': // F5 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 't';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '4': // F4 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'x';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '3': // F3 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'w';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '2': // F2 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'Q';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '1': // F1 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'P';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case 'H': // Home key
                    case 'h': // Home key
                        PortBuffer[PortBufferEnd] = 'H';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case 'K': // End key
                    case 'k': // End key
                        PortBuffer[PortBufferEnd] = 'K';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '+': // Insert key
                        PortBuffer[PortBufferEnd] = '@';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '-': // Del key
                        PortBuffer[PortBufferEnd] = 'P';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case (UCHAR)TAB_KEY: // Tab key
                        PortBuffer[PortBufferEnd] = (UCHAR)TAB_KEY;
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '[': // Cursor movement key

                        //
                        // The local computer can run a lot faster than the serial port can give bytes,
                        // so spin, polling, for a second.
                        //
                        StartTime = AEGetRelativeTime();
                        while (BlPortPollOnly(BlTerminalDeviceId) != CP_GET_SUCCESS) {
                            LastTime = AEGetRelativeTime();

                            //
                            // if the counter wraps back to zero, just restart the wait.
                            //
                            if (LastTime < StartTime) {
                                StartTime = LastTime;
                            }

                            //
                            // If one second has passed, we must be done.
                            //
                            if ((LastTime - StartTime) > 1) {
                                break;
                            }

                        }

                        if (BlPortPollByte(BlTerminalDeviceId, &Ch) != CP_GET_SUCCESS) {
                            PortBuffer[PortBufferEnd] = '[';
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                            break;
                        }

                        if ((Ch == 'A') || (Ch == 'B') || (Ch == 'C') || (Ch == 'D')) { // Arrow key.

                            PortBuffer[PortBufferEnd] = Ch;
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;

                        } else {

                            //
                            // Leave it as is
                            //
                            PortBuffer[PortBufferEnd] = '[';
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                            PortBuffer[PortBufferEnd] = Ch;
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        }
                        break;

                    default:
                        PortBuffer[PortBufferEnd] = Ch;
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;
                    }

                } else if (TmpBuffer[*Count] == 0x7F) { // DEL key
                    TmpBuffer[*Count] = (CHAR)ASCI_CSI_IN;
                    PortBuffer[PortBufferEnd] = 'P';
                    PortBufferEnd++;
                    PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                }

                *Count = *Count + 1;
            }

            if (*Count != 0) {
                return(ESUCCESS);
            }

        }

        if (BiosConsoleReadStatus(FileId) == ESUCCESS) {
            return(BiosConsoleRead(FileId,Buffer,Length,Count));
        }

        goto RetryRead;

    } else {

        //
        // Declare a local 64KB aligned buffer, so we don't have to
        // break up I/Os of size less than 64KB, because the buffer
        // crosses a 64KB boundary.
        //
        static PCHAR AlignedBuf = 0;
        BOOLEAN fUseAlignedBuf;

        //
        // Initialize the AlignedBuf once from the pool.
        //

        if (!AlignedBuf) {
            AlignedBuf = FwAllocatePool(128 * 1024);
            AlignedBuf = ALIGN_BUFFER_ON_BOUNDARY(AlignedBuf, 64 * 1024);
        }

        *Count = 0;

        do {
            fUseAlignedBuf = FALSE;

            if (((ULONG) Buffer & 0xffff0000) !=
               (((ULONG) Buffer + Length - 1) & 0xffff0000)) {

                //
                // If the buffer crosses the 64KB boundary use our
                // aligned buffer instead. If we don't have an aligned
                // buffer, adjust the read size.
                //

                if (AlignedBuf) {
                    fUseAlignedBuf = TRUE;

                    //
                    // We can read max 64KB into our aligned
                    // buffer.
                    //

                    Limit = Length;

                    if (Limit > (ULONG) 0xFFFF) {
                        Limit = (ULONG) 0xFFFF;
                    }

                } else {
                    Limit = (64 * 1024) - ((ULONG_PTR) Buffer & 0xFFFF);
                }

            } else {

                Limit = Length;
            }

            Status = (BlFileTable[FileId].DeviceEntryTable->Read)( FileId,
                                                                (fUseAlignedBuf) ? AlignedBuf : Buffer,
                                                                Limit,
                                                                &PartCount  );

            //
            // If we used our aligned buffer, copy the read data
            // to the callers buffer.
            //

            if (fUseAlignedBuf) {
                RtlCopyMemory(Buffer, AlignedBuf, PartCount);
            }

            *Count += PartCount;
            Length -= Limit;
            (PCHAR) Buffer += Limit;

            if (Status != ESUCCESS) {
#if DBG
                BlPrint("Disk I/O error: Status = %lx\n",Status);
#endif
                return(Status);
            }

        } while (Length > 0);

        return(Status);
    }
}


ARC_STATUS
AEWrite (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes to the specified file or device

Arguments:

    FileId - Supplies the file or device to write to

    Buffer - Supplies address of the data to be written

    Length - Supplies number of bytes to write

    Count -  Address of location in which to store the actual bytes written.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    ULONG Limit;
    ULONG PartCount;
    PUCHAR TmpBuffer, String;
    UCHAR Char;
    USHORT WChar;

    //
    // Special case for console output
    //
    if (FileId == 1) {

        if (BlIsTerminalConnected()) {
            BOOLEAN InTerminalEscape = FALSE;

            //
            // Translate ANSI codes to vt100 escape sequences
            //
            TmpBuffer = (PUCHAR)Buffer;
            Limit = Length;
            if (Length == 4) {
                if (strncmp(TmpBuffer, "\033[2J", Length)==0) {
                    //
                    // <CSI>2J turns into <CSI>H<CSI>J
                    //
                    // (erase entire screen)
                    //
                    TmpBuffer = "\033[H\033[J";
                    Limit = 6;
                } else if (strncmp(TmpBuffer, "\033[0J", Length)==0) {
                    //
                    // <CSI>0J turns into <CSI>J
                    //
                    // (erase to end of screen)
                    //
                    TmpBuffer = "\033[J";
                    Limit = 3;
                } else if (strncmp(TmpBuffer, "\033[0K", Length)==0) {
                    //
                    // <CSI>0K turns into <CSI>K
                    //
                    // (erase to end of the line)
                    // 
                    TmpBuffer = "\033[K";
                    Limit = 3;
                } else if (strncmp(TmpBuffer, "\033[0m", Length)==0) {
                    //
                    // <CSI>0m turns into <CSI>m
                    //
                    // (turn attributes off)
                    //
                    TmpBuffer = "\033[m";
                    Limit = 3;
                }
            }

            //
            // loop through the string to be output, printing data to the
            // headless terminal.
            //
            String = TmpBuffer;
            for (PartCount = 0; PartCount < Limit; PartCount++, String++) {

#if UTF8_CLIENT_SUPPORT

                //
                // check if we're in a DBCS language.  If we are, then we
                // need to translate the characters into UTF8 codes by
                // referencing a lookup table in bootfont.bin
                //
                if (DbcsLangId) {
                    UCHAR  UTF8Encoding[3];
                    ULONG  i;
                    
                    if (GrIsDBCSLeadByte(*String)) {
                        
                        //
                        // double byte characters have their own separate table
                        // from the SBCS characters.
                        //
                        // we need to advance the string forward 2 characters
                        // for double byte characters.
                        //
                        GetDBCSUtf8Translation(String,UTF8Encoding);
                        String += 1;
                        PartCount += 1;
                    
                    } else {
                        ULONG Bytes;
                        LPSTR p;
                        //
                        // single byte characters have their own separate table
                        // from the DBCS characters.
                        //
                        GetSBCSUtf8Translation(String,UTF8Encoding);
                    }
                
                
                    for( i = 0; i < 3; i++ ) {
                        if( UTF8Encoding[i] != 0 ) {
                            BlPortPutByte( BlTerminalDeviceId, UTF8Encoding[i] );
                            FwStallExecution(BlTerminalDelay);
                        }
                    }
                
                
                } else
#endif
                {
                    //
                    // standard ASCII character
                    //
                    Char = *String;
#if 1                    
                    //
                    // filter some characters that aren't printable in VT100
                    // into substitute characters which are printable
                    //
                    if (Char & 0x80) {
                    
                        switch (Char) {
                        case 0xB0:  // Light shaded block
                        case 0xB3:  // Light vertical
                        case 0xBA:  // Double vertical line
                            Char = '|';
                            break;
                        case 0xB1:  // Middle shaded block
                        case 0xDC:  // Lower half block
                        case 0xDD:  // Right half block
                        case 0xDE:  // Left half block
                        case 0xDF:  // Upper half block
                            Char = '%';
                            break;
                        case 0xB2:  // Dark shaded block
                        case 0xDB:  // Full block
                            Char = '#';
                            break;
                        case 0xA9: // Reversed NOT sign
                        case 0xAA: // NOT sign
                        case 0xBB: // ''
                        case 0xBC: // ''
                        case 0xBF: // ''
                        case 0xC0: // ''
                        case 0xC8: // ''
                        case 0xC9: // ''
                        case 0xD9: // ''
                        case 0xDA: // ''
                            Char = '+';
                            break;
                        case 0xC4: // ''
                            Char = '-';
                            break;
                        case 0xCD: // ''
                            Char = '=';
                            break;
                        }
                    
                    }
#endif                        
                    
                    //
                    // If the high-bit is still set, and we're here, then we  know we're
                    // not doing DBCS/SBCS characters.  We need to convert this
                    // 8bit ANSI character into unicode, then UTF8 encode that, then send
                    // it over the wire.
                    //
                    if( Char & 0x80 ) {
                        
                        UCHAR  UTF8Encoding[3];
                        ULONG  i;

                        //
                        // Lookup the Unicode equivilent of this 8-bit ANSI value.
                        //
                        UTF8Encode( PcAnsiToUnicode[(Char & 0x7F)],
                                    UTF8Encoding );

                        for( i = 0; i < 3; i++ ) {
                            if( UTF8Encoding[i] != 0 ) {
                                BlPortPutByte( BlTerminalDeviceId, UTF8Encoding[i] );
                                FwStallExecution(BlTerminalDelay);
                            }
                        }

                        
                    } else {
                    
                        // 
                        // write the data to the port.  Note that we write an 8 bit
                        // character to the terminal, and that the remote display 
                        // must correctly interpret the code for it to display
                        // properly.
                        //
                        BlPortPutByte(BlTerminalDeviceId, Char);
                        FwStallExecution(BlTerminalDelay);
                    }
                }
            }                
        }        

        return (BiosConsoleWrite(FileId,Buffer,Length,Count));

    } else {

        *Count = 0;

        do {

            if (((ULONG) Buffer & 0xffff0000) !=
               (((ULONG) Buffer + Length) & 0xffff0000)) {

                Limit = 0x10000 - ((ULONG) Buffer & 0x0000ffff);
            } else {

                Limit = Length;

            }

            Status = (BlFileTable[FileId].DeviceEntryTable->Write)( FileId,
                                                                Buffer,
                                                                Limit,
                                                                &PartCount  );
            *Count += PartCount;
            Length -= Limit;
            (PCHAR) Buffer += Limit;

            if (Status != ESUCCESS) {
#if DBG
                BlPrint("AERead: Status = %lx\n",Status);
#endif
                return(Status);
            }

        } while (Length > 0);

        return(Status);
    }
}

ARC_STATUS
AEGetFileInformation(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInformation
    )
{
    return(BlFileTable[FileId].DeviceEntryTable->GetFileInformation)( FileId,
                                                                      FileInformation);
}


TIME_FIELDS AETime;

PTIME_FIELDS
AEGetTime(
    VOID
    )
{
    ULONG Date,Time;

    GET_DATETIME(&Date,&Time);

    //
    // Date and time are filled as as follows:
    //
    // Date:
    //
    //    bits 0  - 4  : day
    //    bits 5  - 8  : month
    //    bits 9  - 31 : year
    //
    // Time:
    //
    //    bits 0  - 5  : second
    //    bits 6  - 11 : minute
    //    bits 12 - 16 : hour
    //

    AETime.Second = (CSHORT)((Time & 0x0000003f) >> 0);
    AETime.Minute = (CSHORT)((Time & 0x00000fc0) >> 6);
    AETime.Hour   = (CSHORT)((Time & 0x0001f000) >> 12);

    AETime.Day    = (CSHORT)((Date & 0x0000001f) >> 0);
    AETime.Month  = (CSHORT)((Date & 0x000001e0) >> 5);
    AETime.Year   = (CSHORT)((Date & 0xfffffe00) >> 9);

    AETime.Milliseconds = 0;        // info is not available
    AETime.Weekday = 7;             // info is not available - set out of range

    return(&AETime);
}


ULONG
AEGetRelativeTime(
    VOID
    )

/*++

Routine Description:

    Returns the time in seconds since some arbitrary starting point.

Arguments:

    None

Return Value:

    Time in seconds since some arbitrary starting point.

--*/

{
    ULONG TimerTicks;

    TimerTicks = GET_COUNTER();

    return((TimerTicks*10) / 182);
}


VOID
AEReboot(
    VOID
    )

/*++

Routine Description:

    Reboots the machine.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    ULONG DriveId;
    ULONG Status;

    TextGrTerminate();

    //
    // HACKHACK John Vert (jvert)
    //     Some SCSI drives get really confused and return zeroes when
    //     you use the BIOS to query their size after the AHA driver has
    //     initialized.  This can completely tube OS/2 or DOS.  So here
    //     we try and open both BIOS-accessible hard drives.  Our open
    //     code is smart enough to retry if it gets back zeros, so hopefully
    //     this will give the SCSI drives a chance to get their act together.
    //
    Status = ArcOpen("multi(0)disk(0)rdisk(0)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId);
    if (Status == ESUCCESS) {
        ArcClose(DriveId);
    }

    Status = ArcOpen("multi(0)disk(0)rdisk(1)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId);
    if (Status == ESUCCESS) {
        ArcClose(DriveId);
    }

    REBOOT_PROCESSOR();
}




ARC_STATUS
HardDiskPartitionOpen(
    IN ULONG   FileId,
    IN ULONG   DiskId,
    IN UCHAR   PartitionNumber
    )

/*++

Routine Description:

    This routine opens the specified partition and sets the partition info
    in the FileTable at the specified index.  It does not fill in the
    Device Entry table.

    It reads the partition information until the requested partition
    is found or no more partitions are defined.

Arguments:

    FileId - Supplies the file id for the file table entry.

    DiskId - Supplies the file id for the physical device.

    PartitionNumber - Supplies the zero-based partition number

Return Value:

    If a valid partition is found on the hard disk, then ESUCCESS is
    returned. Otherwise, EIO is returned.

--*/

{

    USHORT DataBuffer[SECTOR_SIZE / sizeof(USHORT)];
    PPARTITION_DESCRIPTOR Partition;
    ULONG PartitionLength;
    ULONG StartingSector;
    ULONG VolumeOffset;
    ARC_STATUS Status;
    BOOLEAN PrimaryPartitionTable;
    ULONG PartitionOffset=0;
    ULONG PartitionIndex,PartitionCount=0;
    ULONG Count;
    LARGE_INTEGER SeekPosition;

    BlFileTable[FileId].u.PartitionContext.DiskId=(UCHAR)DiskId;
    BlFileTable[FileId].Position.QuadPart=0;

    VolumeOffset=0;
    PrimaryPartitionTable=TRUE;

    //
    // Change to a 1-based partition number
    //
    PartitionNumber++;

    do {
        SeekPosition.QuadPart = (LONGLONG)PartitionOffset * SECTOR_SIZE;
        Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                              &SeekPosition,
                                                              SeekAbsolute );
        if (Status != ESUCCESS) {
            return(Status);
        }
        Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                              DataBuffer,
                                                              SECTOR_SIZE,
                                                              &Count );

        if (Status != ESUCCESS) {
            return Status;
        }
        
        //
        // If sector zero is not a master boot record, then return failure
        // status. Otherwise return success.
        //

        if (DataBuffer[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
#if DBG
            BlPrint("Boot record signature %x not found (%x found)\n",
                    BOOT_RECORD_SIGNATURE,
                    DataBuffer[BOOT_SIGNATURE_OFFSET] );
#endif
            Status = EIO;
            break;
        }

        //
        // Read the partition information until the four entries are
        // checked or until we found the requested one.
        //
        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];
        for (PartitionIndex=0;
             PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
             PartitionIndex++,Partition++) {

            //
            // Count first the partitions in the MBR. The units
            // inside the extended partition are counted later.
            //
            if ((Partition->PartitionType != PARTITION_ENTRY_UNUSED) &&
                (Partition->PartitionType != STALE_GPT_PARTITION_ENTRY) &&
                !IsContainerPartition(Partition->PartitionType))
            {
                PartitionCount++;   // another partition found.
            }

            //
            // Check if the requested partition has already been found.
            // set the partition info in the file table and return.
            //
            if (PartitionCount == PartitionNumber) {
                StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                 (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                 (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                 (ULONG)(Partition->StartingSectorMsb1 << 24);
                PartitionLength = (ULONG)(Partition->PartitionLengthLsb0) |
                                  (ULONG)(Partition->PartitionLengthLsb1 << 8) |
                                  (ULONG)(Partition->PartitionLengthMsb0 << 16) |
                                  (ULONG)(Partition->PartitionLengthMsb1 << 24);
                BlFileTable[FileId].u.PartitionContext.PartitionLength.QuadPart =
                        (PartitionLength << SECTOR_SHIFT);
                BlFileTable[FileId].u.PartitionContext.StartingSector=PartitionOffset + StartingSector;
                return ESUCCESS;
            }
        }

        //
        //  If requested partition was not yet found.
        //  Look for an extended partition.
        //
        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];
        PartitionOffset = 0;
        for (PartitionIndex=0;
            PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
            PartitionIndex++,Partition++) {
            if (IsContainerPartition(Partition->PartitionType)) {
                StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                 (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                 (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                 (ULONG)(Partition->StartingSectorMsb1 << 24);
                PartitionOffset = VolumeOffset+StartingSector;
                if (PrimaryPartitionTable) {
                    VolumeOffset = StartingSector;
                }
                break;      // only one partition can be extended.
            }
        }

        PrimaryPartitionTable=FALSE;
    } while (PartitionOffset != 0);
    
    return EBADF;
}


VOID
BlpTranslateDosToArc(
    IN PCHAR DosName,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    This routine takes a DOS drive name ("A:" "B:" "C:" etc.) and translates
    it into an ARC name.  ("multi(0)disk(0)rdisk(0)partition(1)")

    N.B.    This will always return some sort of name suitable for passing
            to BiosPartitionOpen.  The name it constructs may not be an
            actual partition.  BiosPartitionOpen is responsible for
            determining whether the partition actually exists.

            Since no other driver should ever use ARC names beginning with
            "multi(0)disk(0)..." this will not be a problem.  (there is no
            way this routine will construct a name that BiosPartitionOpen
            will not open, but some other random driver will grab and
            successfully open)

Arguments:

    DosName - Supplies the DOS name of the drive.

    ArcName - Returns the ARC name of the drive.

Return Value:

--*/

{
    ARC_STATUS Status;
    ULONG DriveId;
    ULONG PartitionNumber;
    ULONG PartitionCount;
    ULONG Count;
    USHORT DataBuffer[SECTOR_SIZE / sizeof(USHORT)];
    PPARTITION_DESCRIPTOR Partition;
    ULONG PartitionIndex;
    BOOLEAN HasPrimary;
    LARGE_INTEGER SeekPosition;

    //
    // Eliminate the easy ones first.
    //    A: is always "multi(0)disk(0)fdisk(0)partition(0)"
    //    B: is always "multi(0)disk(0)fdisk(1)partition(0)"
    //    C: is always "multi(0)disk(0)rdisk(0)partition(1)"
    //

    if (_stricmp(DosName,"A:")==0) {
        strcpy(ArcName,"multi(0)disk(0)fdisk(0)partition(0)");
        return;
    }
    if (_stricmp(DosName,"B:")==0) {
        strcpy(ArcName,"multi(0)disk(0)fdisk(1)partition(0)");
        return;
    }
    if (_stricmp(DosName,"C:")==0) {
        strcpy(ArcName,"multi(0)disk(0)rdisk(0)partition(1)");
        return;
    }

    //
    // Now things get more unpleasant.  If there are two drives, then
    // D: is the primary partition on the second drive.  Successive letters
    // are the secondary partitions on the first drive, then back to the
    // second drive when that runs out.
    //
    // The exception to this is when there is no primary partition on the
    // second drive.  Then, we letter the partitions on the first driver
    // consecutively, and when those partitions run out, we letter the
    // partitions on the second drive.
    //
    // I have no idea who came up with this wonderful scheme, but we have
    // to live with it.
    //

    //
    // Try to open the second drive.  If this doesn't work, we only have
    // one drive and life is easy.
    //
    Status = ArcOpen("multi(0)disk(0)rdisk(1)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId );

    if (Status != ESUCCESS) {

        //
        // We only have one drive, so whatever drive letter he's requesting
        // has got to be on it.
        //

        sprintf(ArcName,
                "multi(0)disk(0)rdisk(0)partition(%d)",
                toupper(DosName[0]) - 'C' + 1 );

        return;
    } else {

        //
        // Now we read the partition table off the second drive, so we can
        // tell if there is a primary partition or not.
        //
        SeekPosition.QuadPart = 0;

        Status = ArcSeek(DriveId,
                         &SeekPosition,
                         SeekAbsolute);
        if (Status != ESUCCESS) {
            ArcName[0]='\0';
            return;
        }

        Status = ArcRead(DriveId, DataBuffer, SECTOR_SIZE, &Count);
        ArcClose(DriveId);

        if (Status != ESUCCESS) {
            ArcName[0] = '\0';
            return;
        }

        HasPrimary = FALSE;

        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];
        for (PartitionIndex = 0;
             PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
             PartitionIndex++,Partition++) {
            if (IsRecognizedPartition(Partition->PartitionType)) {
                HasPrimary = TRUE;
            }
        }

        //
        // Now we have to go through and count
        // the partitions on the first drive.  We do this by just constructing
        // ARC names for each successive partition until one BiosPartitionOpen
        // call fails.
        //

        PartitionCount = 0;
        do {
            ++PartitionCount;
            sprintf(ArcName,
                    "multi(0)disk(0)rdisk(0)partition(%d)",
                    PartitionCount+1);

            Status = BiosPartitionOpen( ArcName,
                                        ArcOpenReadOnly,
                                        &DriveId );

            if (Status==ESUCCESS) {
                BiosPartitionClose(DriveId);
            }
        } while ( Status == ESUCCESS );

        PartitionNumber = toupper(DosName[0])-'C' + 1;

        if (HasPrimary) {

            //
            // There is Windows NT primary partition on the second drive.
            //
            // If the DosName is "D:" then we know
            // this is the first partition on the second drive.
            //

            if (_stricmp(DosName,"D:")==0) {
                strcpy(ArcName,"multi(0)disk(0)rdisk(1)partition(1)");
                return;
            }

            if (PartitionNumber-1 > PartitionCount) {
                PartitionNumber -= PartitionCount;
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(1)partition(%d)",
                        PartitionNumber );
            } else {
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(0)partition(%d)",
                        PartitionNumber-1);
            }

        } else {

            //
            // There is no primary partition on the second drive, so we
            // consecutively letter the partitions on the first drive,
            // then the second drive.
            //

            if (PartitionNumber > PartitionCount) {
                PartitionNumber -= PartitionCount;
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(1)partition(%d)",
                        PartitionNumber );
            } else {
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(0)partition(%d)",
                        PartitionNumber);
            }

        }


        return;
    }
}


VOID
FwStallExecution(
    IN ULONG Microseconds
    )

/*++

Routine Description:

    Does a busy wait for a specified number of microseconds (very approximate!)

Arguments:

    Microseconds - Supplies the number of microseconds to busy wait.

Return Value:

    None.

--*/

{
    ULONG FinalCount;

    FinalCount = Microseconds * FwStallCounter;

    _asm {
        mov eax,FinalCount
looptop:
        sub eax,1
        jnz short looptop
    }
}


BOOLEAN
FwGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    )

/*++

Routine Description:

    This routine looks for the given Mnemonic in OpenPath.
    If Mnemonic is a component of the path, then it converts the key
    value to an integer wich is returned in Key.

Arguments:

    OpenPath - Pointer to a string that contains an ARC pathname.

    Mnemonic - Pointer to a string that contains a ARC Mnemonic

    Key      - Pointer to a ULONG where the Key value is stored.


Return Value:

    FALSE  if mnemonic is found in path and a valid key is converted.
    TRUE   otherwise.

--*/

{
    return(BlGetPathMnemonicKey(OpenPath,Mnemonic,Key));
}


PCONFIGURATION_COMPONENT
FwAddChild (
    IN PCONFIGURATION_COMPONENT Component,
    IN PCONFIGURATION_COMPONENT NewComponent,
    IN PVOID ConfigurationData OPTIONAL
    )
{
    ULONG Size;
    PCONFIGURATION_COMPONENT_DATA NewEntry;
    PCONFIGURATION_COMPONENT_DATA Parent;

    if (Component==NULL) {
        return(NULL);
    }

    Parent = CONTAINING_RECORD(Component,
                               CONFIGURATION_COMPONENT_DATA,
                               ComponentEntry);

    Size = sizeof(CONFIGURATION_COMPONENT_DATA) +
           NewComponent->IdentifierLength + 1;

    NewEntry = FwAllocateHeap(Size);
    if (NewEntry==NULL) {
        return(NULL);
    }

    RtlCopyMemory(&NewEntry->ComponentEntry,
                  NewComponent,
                  sizeof(CONFIGURATION_COMPONENT));
    NewEntry->ComponentEntry.Identifier = (PUCHAR)(NewEntry+1);
    NewEntry->ComponentEntry.ConfigurationDataLength = 0;
    strncpy(NewEntry->ComponentEntry.Identifier,
            NewComponent->Identifier,
            NewComponent->IdentifierLength);

    //
    // Add the new component as the first child of its parent.
    //
    NewEntry->Child = NULL;
    NewEntry->Sibling = Parent->Child;
    Parent->Child = NewEntry;

    return(&NewEntry->ComponentEntry);

}

PCONFIGURATION_COMPONENT
FwGetComponent(
    IN PCHAR Pathname
    )
{
    PCONFIGURATION_COMPONENT Component;
    PCONFIGURATION_COMPONENT MatchComponent;
    PCHAR PathString;
    PCHAR MatchString;
    PCHAR Token;
    ULONG Key;

    PathString = Pathname;

    //
    // Get the the root component.
    //

    MatchComponent = FwGetChild(NULL);

    //
    // Repeat search for each new match component.
    //

    do {

        //
        // Get the first child of the current match component.
        //

        Component = FwGetChild( MatchComponent );

        //
        // Search each child of the current match component for the next match.
        //

        while ( Component != NULL ) {

            //
            // Reset Token to be the current position on the pathname.
            //

            Token = PathString;

            MatchString = MnemonicTable[Component->Type];

            //
            // Compare strings.
            //

            while (*MatchString == tolower(*Token)) {
                MatchString++;
                Token++;
            }

            //
            // Strings compare if the first mismatch is the terminator for
            // each.
            //

            if ((*MatchString == 0) && (*Token == '(')) {

                //
                // Form key.
                //

                Key = 0;
                Token++;
                while ((*Token != ')') && (*Token != 0)) {
                    Key = (Key * 10) + *Token++ - '0';
                }

                //
                // If the key matches the component matches, so update
                // pointers and break.
                //

                if (Component->Key == Key) {
                    PathString = Token + 1;
                    MatchComponent = Component;
                    break;
                }
            }

            Component = FwGetPeer( Component );
        }

    } while ((Component != NULL) && (*PathString != 0));

    return MatchComponent;
}
/**********************
*
* The following are just stubs for the MIPS firmware.  They all return NULL
*
***********************/



ARC_STATUS
FwDeleteComponent (
    IN PCONFIGURATION_COMPONENT Component
    )
{
    return(ESUCCESS);
}


VOID
AEGetArcDiskInformation(
    VOID
    )
{
    InitializeListHead(&(AEArcDiskInformation.DiskSignatures));
    AEArcDiskInformationInitialized = TRUE;

    //
    // Scan through each node of the hardware tree - look for disk type
    // devices hanging off of multi-function controllers.
    //

    FwSearchTree(FwGetChild(NULL),
                 PeripheralClass,
                 DiskPeripheral,
                 -1,
                 AEEnumerateDisks);
    return;
}


BOOLEAN
FwSearchTree(
    IN PCONFIGURATION_COMPONENT Node,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN ULONG Key,
    IN PFWNODE_CALLBACK CallbackRoutine
    )
/*++

Routine Description:

    Conduct a depth-first search of the firmware configuration tree starting
    at a given node, looking for nodes that match a given class and type.
    When a matching node is found, call a callback routine.

Arguments:

    CurrentNode - node at which to begin the search.

    Class - configuration class to match, or -1 to match any class

    Type - configuration type to match, or -1 to match any class

    Key - key to match, or -1 to match any key

    FoundRoutine - pointer to a routine to be called when a node whose
        class and type match the class and type passed in is located.
        The routine takes a pointer to the configuration node and must
        return a boolean indicating whether to continue with the traversal.

Return Value:

    FALSE if the caller should abandon the search.
--*/
{
    PCONFIGURATION_COMPONENT child;

    do {
        if (child = FwGetChild(Node)) {
            if (!FwSearchTree(child,
                              Class,
                              Type,
                              Key,
                              CallbackRoutine)) {
                return(FALSE);
            }
        }

        if (((Class == -1) || (Node->Class == Class)) &&
            ((Type == -1) || (Node->Type == Type)) &&
            ((Key == (ULONG)-1) || (Node->Key == Key))) {

            if (!CallbackRoutine(Node)) {
                return(FALSE);
            }
        }

        Node = FwGetPeer(Node);

    } while ( Node != NULL );

    return(TRUE);
}


VOID
AEGetPathnameFromComponent(
    IN PCONFIGURATION_COMPONENT Component,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    This function builds an ARC pathname for the specified component.

Arguments:

    Component - Supplies a pointer to a configuration component.

    ArcName - Returns the ARC name of the specified component.  Caller must
        provide a large enough buffer.

Return Value:

    None.

--*/
{

    if (AEGetParent(Component) != NULL) {
        AEGetPathnameFromComponent(AEGetParent(Component),ArcName);

        //
        // append our segment to the arcname
        //

        sprintf(ArcName+strlen(ArcName),
                "%s(%d)",
                MnemonicTable[Component->Type],
                Component->Key);

    } else {
        //
        // We are the parent, initialize the string and return
        //
        ArcName[0] = '\0';
    }

    return;
}


BOOLEAN
AEEnumerateDisks(
    IN PCONFIGURATION_COMPONENT Disk
    )

/*++

Routine Description:

    Callback routine for enumerating the disks in the ARC firmware tree.  It
    reads all the necessary information from the disk to uniquely identify
    it.

Arguments:

    ConfigData - Supplies a pointer to the disk's ARC component data.

Return Value:

    TRUE - continue searching

    FALSE - stop searching tree.

--*/

{
    UCHAR path[100] = "";
    ULONG key;

    AEGetPathnameFromComponent(Disk, path);

#if 0
    if((BlGetPathMnemonicKey(path, "multi", &key) == FALSE) ||
       (BlGetPathMnemonicKey(path, "eisa", &key) == FALSE)) {
        DbgPrint("Found multi disk %s\n", path);
    } else {
        DbgPrint("Found disk %s\n", path);
    }
#endif

    AEReadDiskSignature(path, FALSE);

    return TRUE;
}


BOOLEAN
AEReadDiskSignature(
    IN PCHAR DiskName,
    IN BOOLEAN IsCdRom
    )

/*++

Routine Description:

    Given an ARC disk name, reads the MBR and adds its signature to the list of
    disks.

Arguments:

    Diskname - Supplies the name of the disk.

    IsCdRom - Indicates whether the disk is a CD-ROM.

Return Value:

    TRUE - Success

    FALSE - Failure

--*/

{
    PARC_DISK_SIGNATURE signature;
    BOOLEAN status;

    signature = FwAllocateHeap(sizeof(ARC_DISK_SIGNATURE));
    if (signature==NULL) {
        return(FALSE);
    }

    signature->ArcName = FwAllocateHeap(strlen(DiskName)+2);
    if (signature->ArcName==NULL) {
        return(FALSE);
    }

    status = BlGetDiskSignature(DiskName, IsCdRom, signature);
    if (status) {
        InsertHeadList(&(AEArcDiskInformation.DiskSignatures),
                       &(signature->ListEntry));

    }

    return(TRUE);
}


BOOLEAN
BlFindDiskSignature(
    IN PCHAR DiskName,
    IN PARC_DISK_SIGNATURE Signature
    )
{
    PARC_DISK_SIGNATURE match;
    UCHAR buffer[] = "multi(xxx)disk(xxx)rdisk(xxx)";

    if(AEArcDiskInformationInitialized == FALSE) {
        return FALSE;
    }

    //
    // If the disk name passed in contains an eisa component then convert
    // the entire string into one with a multi component.
    //

    if(strncmp(DiskName, "eisa", strlen("eisa")) == 0) {
        strcpy(&(buffer[1]), DiskName);
        RtlCopyMemory(buffer, "multi", 5);
        DiskName = buffer;
    }

    match = CONTAINING_RECORD(AEArcDiskInformation.DiskSignatures.Flink,
                              ARC_DISK_SIGNATURE,
                              ListEntry);


    while(&(match->ListEntry) != &(AEArcDiskInformation.DiskSignatures)) {

        if(strcmp(DiskName, match->ArcName) == 0) {

            PCHAR c;

            //
            // We found a match.  Copy all the information out of this node.
            //

            // DbgPrint("BlFindDiskSignature found a match for %s - %#08lx\n", DiskName, match);

            Signature->CheckSum = match->CheckSum;
            Signature->Signature = match->Signature;
            Signature->ValidPartitionTable = match->ValidPartitionTable;

            strcpy(Signature->ArcName, match->ArcName);

            return TRUE;
        }

        match = CONTAINING_RECORD(match->ListEntry.Flink,
                                  ARC_DISK_SIGNATURE,
                                  ListEntry);
    }

    DbgPrint("BlFindDiskSignature found no match for %s\n", DiskName);
    return FALSE;
}

VOID
AETerminateIo(
    VOID
    )
{
    if(AEDriverUnloadRoutine != NULL) {
        AEDriverUnloadRoutine(NULL);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\cpu386.asm ===
title  "Processor type and stepping detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    cpu type and stepping information.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 28-Oct-1991.
;
; Environment:
;
;    80x86
;
; Revision History:
;
;--

.586p
        .xlist
include mac386.inc
include callconv.inc
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

CR0_AM          equ     40000h
EFLAGS_AC       equ     40000h

        subttl  "Is386"
;++
;
; BOOLEAN
; BlIs386(
;    VOID
;    )
;
; Routine Description:
;
;    This function determines whether the processor we're running on
;    is a 386. If not a 386, it is assumed that the processor is
;    a 486 or greater.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (al) = 1 - processor is a 386
;    (al) = 0 - processor is a 486 or greater.
;
;--
        public  _BlIs386@0
_BlIs386@0 proc

        mov     eax,cr0
        push    eax                         ; save current cr0
        and     eax,not CR0_AM              ; mask out alignment check bit
        mov     cr0,eax                     ; disable alignment check
        pushfd                              ; save flags
        pushfd                              ; turn on alignment check bit in
        or      dword ptr [esp],EFLAGS_AC   ; a copy of the flags register
        popfd                               ; and try to load flags
        pushfd
        pop     ecx                         ; get new flags into ecx
        popfd                               ; restore original flags
        pop     eax                         ; restore original cr0
        mov     cr0,eax
        xor     al,al                       ; prepare for return, assume not 386
        and     ecx,EFLAGS_AC               ; did AC bit get set?
        jnz     short @f                    ; yes, we don't have a 386
        inc     al                          ; we have a 386
@@:     ret

_BlIs386@0 endp

        subttl  "IsCpuidPresent"
;++
;
; BOOLEAN
; BlIsCpuidPresent(
;     VOID
;     )
;
; Routine Description:
;
;    If bit 21 of the EFLAGS register is writable, CPUID is supported on
;    this processor.   If not writable, CPUID is not supported.  
;
;    Note: It is expected that this routine is "locked" onto a single
;    processor when run.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE  if CPUID is supported, 
;    FALSE otherwise.
;
;--

EFLAGS_ID   equ 200000h             ; bit 21


cPublicProc _BlIsCpuidPresent ,0
        pushfd                      ; save EFLAGS
        pop     ecx                 ; get current value
        xor     ecx, EFLAGS_ID      ; flip bit 21
        push    ecx                 ; set flipped value in EFLAGS
        popfd
        pushfd                      ; read it back again
        pop     eax
        xor     eax, ecx            ; if new value is what we set
        shr     eax, 21             ; then these two are the same
        and     eax, 1              ; isolate bit 21 (in bit 0)
        xor     eax, 1              ; and flip it

        stdRET _BlIsCpuidPresent

stdENDP _BlIsCpuidPresent


        page
        subttl  "GetFeatureBits"
;++
;
; VOID
; BlGetFeatureBits(
;     VOID
;     )
;
; Routine Description:
;
;    Execute the CPUID instruction to get the feature bits supported
;    by this processor.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Returns the set of feature bits supported by this processor or
;    0 if this processor does not support the CPUID instruction.
;
;--


cPublicProc _BlGetFeatureBits ,0
        stdCall _BlIsCpuidPresent   ; Does this processor do CPUID?
        test    eax, 1
        jnz     short @f            ; Jif yes.
        xor     eax, eax            ; No, return 0.
        stdRet  _BlGetFeatureBits

@@:     mov     eax, 1              ; CPUID function 1 gets feature bits.
        push    ebx                 ; save ebx
        cpuid                       ; execute 

        ;
        ; Due to a bug in NT 4, some processors report that they do
        ; not support cmpxchg8b even though they do.   Win2K doesn't
        ; care but cmpxchg8b is a requirement for Whistler. 
        ;
        ; Check to see if this is one of those processors and if we
        ; have been told by the processor manufacturer how to reenable
        ; cmpxchg8b, do so.
        ;

        test    edx, 0100h          ; is cmpxchg8b present?
        jnz     short gfb90         ; yes, skip

        ;
        ; cmpxchg8b not present, check for recognized processor
        ;

        push    eax                 ; save Family, Model, Stepping
        mov     eax, 0
        cpuid
        pop     eax
        
        cmp     ebx, 0746e6543h     ; Cyrix III = 'CentaurHauls'
        jnz     short gfb30
        cmp     edx, 048727561h
        jnz     short gfb80
        cmp     ecx, 0736c7561h
        jnz     short gfb80
        cmp     eax, 0600h          ; consider Cyrix III F/M/S 600 and above

        ;
        ; Cyrix (Centaur) Set MSR 1107h bit 1 to 1.
        ;

        mov     ecx, 01107h
        jae     gfb20
        cmp     eax, 0500h          ; consider IDT/Centaur F/M/S 500 and above
        jb      short gfb80

        ;
        ; Centaur family 5, set MSR 107h bit 1 to 1.
        ;

        mov     ecx, 0107h

gfb20:  rdmsr
        or      eax, 2
        wrmsr
        jmp     short gfb80


gfb30:  cmp     ebx, 0756e6547h     ; Transmeta = 'GenuineTMx86'
        jnz     short gfb80
        cmp     edx, 054656e69h
        jnz     short gfb80
        cmp     ecx, 03638784dh
        jnz     short gfb80
        cmp     eax, 0542h          ; consider Transmeta F/M/S 542 and above
        jb      short gfb80

        ;
        ; Transmeta MSR 80860004h is a mask applied to the feature bits.
        ;

        mov     ecx, 080860004h
        rdmsr
        or      eax, 0100h
        wrmsr


gfb80:  mov     eax, 1              ; reexecute CPUID function 1
        cpuid
gfb90:  mov     eax, edx            ; return feature bits 
        pop     ebx                 ; restore ebx, esi

        stdRET _BlGetFeatureBits

stdENDP _BlGetFeatureBits

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\displayp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    displayp.h

Abstract:

    Private header file for display routines.

Author:

    Ted Miller (tedm) 7-July-1995

Revision History:

--*/

//
// NOTICE
//
// Under no circumstances is anyone besides display.c to call these routines
// directly. This would break DBCS display for Far Eastern locales.
//

//
// Globals
//
extern USHORT TextColumn;
extern USHORT TextRow;
extern UCHAR TextCurrentAttribute;

//
// Vga text mode stuff
//
VOID
TextTmScrollDisplay(
    VOID
    );

VOID
TextTmClearDisplay(
    VOID
    );

VOID
TextTmClearToEndOfDisplay(
    VOID
    );

VOID
TextTmClearFromStartOfLine(
    VOID
    );

VOID
TextTmClearToEndOfLine(
    VOID
    );

VOID
TextTmFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );

PUCHAR
TextTmCharOut(
    PUCHAR pc
    );

VOID
TextTmStringOut(
    IN PUCHAR String
    );

VOID
TextTmPositionCursor(
    USHORT Row,
    USHORT Column
    );

VOID
TextTmSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextTmGetGraphicsChar(
    IN GraphicsChar WhichOne
    );

//
// Vga graphics mode stuff
//

VOID
TextGrScrollDisplay(
    VOID
    );

VOID
TextGrClearDisplay(
    VOID
    );

VOID
TextGrClearToEndOfDisplay(
    VOID
    );

VOID
TextGrClearFromStartOfLine(
    VOID
    );

VOID
TextGrClearToEndOfLine(
    VOID
    );

VOID
TextGrFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );

PUCHAR
TextGrCharOut(
    PUCHAR pc
    );

VOID
TextGrStringOut(
    IN PUCHAR String
    );

VOID
TextGrPositionCursor(
    USHORT Row,
    USHORT Column
    );

VOID
TextGrSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextGrGetGraphicsChar(
    IN GraphicsChar WhichOne
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\decode.inc ===
;**     Decoding macros
;
;       These walk a state machine based on where a command (i.e., char or string)
;       begins.  


;**     BitsAt - Extract from bit position n some bits
;
;       Macro parameter:
;               n       bit position to begin extract
;               cbits   number of bits to extract
;       Entry:  eax     working data
;               esi     input stream
;               edi     output stream
;       Exit:   eax     updated so that next data begins in al
;               esi/edi updated
;               ecx     contains data
;       Uses:   none

BitsAt  macro   n,cbits
        .errnz  n eq 0
        if      (n+cbits) lt 8          ; entire operation occurs in low byte
                CopyBits cx,ax,n,cbits  ; (cx) = desired bits rightmost
        elseif (n+cbits) lt 16          ; operation consumes byte
                CopyBits cx,ax,n,cbits  ; (cx) = desired bits rightmost
                lodsb                   ; (ah/al) = next input
                xchg    al,ah           ; (al/ah) = next input
        elseif (n+cbits) eq 16          ; operation consumes remainder of buffered data
                CopyBits cx,ax,n,cbits  ; (cx) = desired bits rightmost
                lodsw                   ; (al/ah) = next input
        else                            ; operation consumes into unbuffered data
                mov     ecx,eax
                lodsw
                shrd    cx,ax,n
                and     ecx,(1 shl cbits)-1
        endif
endm
                

;**     CmdAt - macro that processes a command at a bit position
;
;       Macro parameter:
;               n       bit position where command is expected
;       Entry:  eax     working data, command begins in al
;               esi     points to input stream
;               edi     points to output stream
;       Exit:   eax     updated so that next command begins in al
;               esi/edi updated
;               EXPECTS FALL-THROUGH TO NEXT CmdAT
;       Uses:   ecx, edx (not directly, but by virtue of OffsetAt, which
;               in turn calls LengthAt....)

CmdAt   macro   n
        local   ca1

        align4
        public  CmdAt&n
CmdAt&n:
    if n eq 7
        ror     eax,1
        test    al,11b shl 6
        rol     eax,1
    else
        test    al,11b shl n
    endif
        jpo     ca1

        OffsetAt %(n+1)
        align4                          ; note that OffsetAt jumps away
ca1:                                    ; so there is no fall-through penalty
        CharAt  %(n+1)
endm


;**     CharAt - macro that processes a character at a bit position
;
;       Macro parameter:
;               n       bit position where char is expected
;       Entry:  eax     working data, char may be in ah
;               esi     input stream
;               edi     output stream
;       Exit:   eax     updated so that next command begins in al
;               esi/edi updated
;       Uses:   ch

CharAt  macro   n
        if n eq 8
                mov     al,ah           ; (al) = char for output
                XlatChr
                CheckOffset
                stosb                   ; store it
                lodsw                   ; (al/ah) = next input
        else
                if n eq 1
                        shr     eax,1   ; (al) = byte for output
                        XlatChr
                        CheckOffset
                        stosb           ; store it
                        add     eax,eax ; (ah) = next byte
                        lodsb           ; (ah/al) = next input
                else
                        mov     ch,ah   ; (ch) = saved next input
                        shr     eax,n   ; (al) = byte for output
                        XlatChr
                        CheckOffset
                        stosb           ; store it
                        lodsb           ; (al) = byte-after-next
                        mov     ah,ch   ; (ah/al) = next input
                endif
                xchg    al,ah           ; (al/ah) = next input
        endif
endm


;**     OffsetAt - Parse an offset at a bit position
;
;       Macro parameter:
;               n       bit position where offset is expected
;       Entry:  cbits   number of bits in offset
;               eax     working data, offset may begin in ah
;               esi     input stream
;               edi     output stream
;       Exit:   eax     updated so that length begins in al
;               ecx     offset
;               esi/edi updated
;       Uses:   ecx

OffsetAt macro  n
        local   try8,try12

        public  OffsetAt&n
OffsetAt&n:
        CheckBit a,n                    ; does a 6-bit offset follow?
        jnz     try8                    ; no, try an 8-bit offset
        BitsAt  %(n+1),6                ; yes, load it into (ecx) and go
        Jump    LengthAt,%((n+7) mod 8)
        align4
try8:
        CheckBit a,%(n+1)               ; does an 8-bit offset follow?
        jnz     try12                   ; no, must be a 12-bit offset
        BitsAt  %(n+2),8                ; yes, load it into (ecx)
        add     ecx,MAX_6BIT_OFFSET+1   ;
        Jump    LengthAt,%((n+10) mod 8); go process the following length
        align4
try12:
        BitsAt  %(n+2),12               ; load 12-bit offset into (ecx)
        add     ecx,MAX_8BIT_OFFSET+1   ;
        Jump    LengthAt,%((n+14) mod 8); go process the following length
endm


;**     LengthAt - parse off a length at a position and move the bytes
;
;       LengthAt parses off a length (gamma-prime encoded), moves the
;       relevant string, and dispatches to the next command.
;
;       Macro parameter:
;               n       bit position to begin extract
;       Entry:  eax     working data
;               ecx     offset for string
;               esi     input stream
;               edi     output stream
;       Exit:   eax     updated so that next data begins in al
;               esi/edi updated
;       Uses:   ecx, edx

LengthAt macro  n
        local   try3,try5,try7,try9,tryGeneral,done,error

      % ifidni  <LastErrBJump>,<DecodeError>
        LastErrBJump equ <error>
        endif

        align4
        public  LengthAt&n
LengthAt&n:
        jecxz   error                   ; check for 0 offset (illegal)
        cmp     ecx,SPECIAL_EOS         ; check end-of-segment offset
        je      done                    ; that's our EOS, so get out
        CheckBit a,n                    ; is this a degenerate encoding?
        jz      try3                    ; no, go for a wider encoding
        DoMovs  short,2
        if n eq 7                       ; are we finished with this byte?
                lodsb                   ; (ah/al) is next input
                xchg    al,ah           ; (al/ah) is next input
        endif
        Jump    CmdAt,%((n + 1) mod 8)  ; go process next command
done:
        mov     dl,n                    ; DL == current state
        jmp     DecodeDone              ; exit
error:
;;        Debug_Out "MRCI32 Decompress32: bad offset in LengthAt&n"
        jmp     DecodeError

        align4
try3:
        mov     edx,ecx                 ; save delta
        CheckBit a,%(n + 1)             ; is this a 3-bit encoding?
        jz      try5                    ; no, go for wider still
        BitsAt  %(n+2),1
        DoMovs  short,ecx,3
        Jump    CmdAt,%((n + 3) mod 8)  ; go process next command

        align4
try5:
        CheckBit a,%(n + 2)             ; is this a 5-bit encoding?
        jz      try7                    ; no, go test for wider STILL
        BitsAt  %(n+3),2
        DoMovs  short,ecx,5
        Jump    CmdAt,%((n + 5) mod 8)  ; go process next command

        align4
try7:
        CheckBit a,%(n + 3)             ; is this a 7 bit encoding?
        jz      try9                    ; no, go test for wider STILL
        BitsAt  %(n+4),3
        DoMovs  long,ecx,9
        Jump    CmdAt,%((n + 7) mod 8)  ; go process next command

        align4
try9:
        CheckBit a,%(n + 4)             ; is this a 9 bit encoding?
        jz      tryGeneral              ; no, go handle generically
        BitsAt  %(n+5),4
        DoMovs  long,ecx,17
        Jump    CmdAt,%((n + 9) mod 8) ; go process next command
;
;       Length exception handling code goes here
;
        align4
tryGeneral:
        mov     cl,n+5                  ; CL == # of bits to eat to yield
        if      n NE 7
        jmp     LengthAbove32           ; gamma length with 5 leading zeros stripped
        else
;;        .errnz  $-GeneralLength         ; assert that we'll fall through
        endif
endm


DoGeneralLength macro
        local   try11,try13,try15,try17

        public  LengthAbove32,CopyString

GeneralLength:
        align4

LengthAbove32:
        shl     eax,16                  ;
        mov     ax,[esi]                ; get 16 more bits
        add     cl,16                   ;
        ror     eax,cl                  ; (eax) is filled, time to party
;
;   Figure out the length and do a string op
;
try11:
        shr     eax,1                   ; is it an 11-bit encoding?
        jnc     try13                   ; no
        and     eax,1Fh                 ; mask off the numeric value
        add     eax,33                  ;
        xchg    ecx,eax                 ; (ecx) now has string length
        sub     al,10                   ; record # extra bits in this length
;
;   At this point, (ecx) is the # of bytes to copy and (al) is the number of
;   additional bits to eat for the particular gamma length.
;
;   Good coding practices suggest that CopyString be at the end so that the
;   other gamma decoders need not jump backwards to it, but if we assume
;   that the longer strings are marginally less common, then it is marginally
;   better to fall through on this, the smallest of the general cases.
;
        align4

CopyString:
        DoMovs  long,ecx

        mov     dl,al                   ; (dl) == bit position in old ax
        cmp     dl,24                   ; is it the max?
        jb      @F                      ; no
        inc     esi                     ; yes, need to skip 1 more whole byte
        lodsw                           ; get new (ax) to restart state machine
        sub     dl,24                   ; (dl) == new state
        DecodeRestart

        align4
@@:
        cmp     dl,16                   ; did we exhaust the old ax?
        jae     @F                      ; yes
        dec     esi                     ; no,
        add     dl,8                    ;  but we know we exhausted the low byte
@@:
        lodsw                           ; get new (ax) to restart state machine
        sub     dl,16                   ; (dl) == new state
        DecodeRestart

        align4
try13:
        shr     eax,1                   ; is it an 13-bit encoding?
        jnc     try15                   ; no
        and     eax,3Fh                 ; mask off the numeric value
        add     eax,65                  ;
        xchg    ecx,eax                 ; (cx) now has string length
        sub     al,8                    ; record # extra bits in this length
        jmp     CopyString              ;

        align4
try15:
        shr     eax,1                   ; is it an 15-bit encoding?
        jnc     try17                   ; no
        and     eax,7Fh                 ; mask off the numeric value
        add     eax,129                 ;
        xchg    ecx,eax                 ; (ecx) now has string length
        sub     al,6                    ; record # extra bits in this length
        jmp     CopyString              ;

        align4
try17:
        shr     eax,1                   ; is it an 17-bit encoding?
;;        Debug_OutNC "MRCI32 Decompress32: invalid length"
        jnc     DecodeError             ; no, ERROR
        and     eax,0FFh                ; mask off the numeric value
        add     eax,257                 ;
        xchg    ecx,eax                 ; (ecx) now has string length
        sub     al,4                    ; record # extra bits in this length
        jmp     CopyString              ;
endm


;**     DoMovs - worker macro for LengthAt and DoGeneralLength
;
;       <size> is either "short" or "long";  if short, then we don't
;       bother trying to do a movsw/movsb combo (overhead swamps benefit);
;       if long, we do.
;
;       If <len> == 2, the offset to use is in (ecx).  (edx) is trashed.
;
;       Otherwise, the offset has been saved in (edx), and <len>
;       is the size of the string to move (normally ecx).  (ecx) and (edx)
;       are trashed.
;
;       <errjmp> is where to go if the expansion is going to overflow the
;       destination buffer.  DoMovs just passes this parameter along to the
;       CheckOffset macro.
;
DoMovs  macro   size,len,extra,errjmp
        local   slower

    ifidni <len>,<2>

        mov     edx,esi                 ; save (esi) in (edx)
        mov     esi,edi
        sub     esi,ecx
        CheckOffset 2,errjmp            ; check target offset
        movsb                           ; don't do movsw,
        movsb                           ; that doesn't handle overlap!
        mov     esi,edx                 ; restore (esi) from (edx)

    else

     ifnb <len>
      ifdifi <len>,<ecx>
       ifb <extra>
        mov     ecx,len
       else
        lea     ecx,[len+extra]
       endif
      else
       ifnb <extra>
        add     ecx,extra
       endif
      endif
     endif

        mov     ebx,esi                 ; save (esi) in (ebx)
        mov     esi,edi                 ;
        sub     esi,edx                 ; (esi) points to string to move
        CheckOffset ecx,errjmp          ; check target offset

      ifidni <size>,<short>
        rep     movsb
      elseifidni <size>,<long>
        cmp     edx,1                   ; if the offset is 1,
        je      short slower            ; then overlap forces us to do movsb
        shr     ecx,1
        rep     movsw
        adc     ecx,ecx
slower: rep     movsb
      else
        .err    <Bad DoMovs parameter: size>
      endif

        mov     esi,ebx                 ; restore (esi) from (ebx)

    endif
endm


;**     CheckOffset - Verify offsets in ESI and EDI are ok for len bytes
;
;       If "len" is blank, then CheckOffset simply does a 1-byte check.
;       In the event of an error in any case, it branches to DecodeError.
;
LastErrSJump    equ <DecodeError>
LastErrBJump    equ <DecodeError>


CheckOffset macro   len,errjmp
        local   tmp,jsjmp,jbjmp

IFDEF   MAXDEBUG
        cmp     edi,[maxOffset]
        jb      short tmp
        int 3
tmp:
ENDIF

    ifnb    <errjmp>
        ErrSJump    equ     <errjmp>
    else
        ErrSJump    catstr  LastErrSJump
        LastErrSJump equ    <jsjmp>
    endif

    ifb     <len>
        dec     ebp             ; space remaining in destination buffer?
    else
        sub     ebp,len         ; space remaining in destination buffer?
    endif

;;        Debug_OutS "MRCI32 Decompress32: target buffer overflow"

jsjmp:  js      ErrSJump

IFDEF   INLINE_LOWER_BOUND_CHECKING
;
;   In-line bounds checking is disabled in favor of an invalid page fault
;   handler.  To use this code, be aware that EBX cannot be used by the
;   decoding macros above (and it currently is!)
;
    ifnb    <len>
        ifnb    <errjmp>
            ErrBJump    equ     <errjmp>
        else
            ErrBJump    catstr  LastErrBJump
            LastErrBJump equ    <jbjmp>
        endif

        cmp     esi,ebx         ; have we ventured before start of dest. buffer?

;;        Debug_OutB "MRCI32 Decompress32: target buffer underflow"

jbjmp:  jb      ErrBJump
    endif

ENDIF   ;INLINE_LOWER_BOUND_CHECKING

endm


;*      Misc. macros

Jump    macro   lab,tag
        jmp     lab&tag
endm


XlatChr macro   ch
        ror     al,1
        xor     al,80h
endm


align4  macro
;
;   This actually slowed down the real-mode decompressor, so some
;   time will need to be spent verifying this is a real win... -JP
;
        align   4
endm


CheckBit macro  reg,bit
        if bit lt 8
                test    reg&l,(1 shl bit)
        else
                test    reg&h,(1 shl (bit-8))
        endif
endm


CopyBits macro  dst,src,n,cbits
        shld    dst,src,16-n
        and     e&dst,(1 shl cbits)-1
endm


;
;   AX has the remaining bits, DL has the next state
;
DecodeRestart macro

IFDEF   DEBUG
        cmp     dl,8
;;        Debug_OutAE "MRCI32 Decompress32: bad decode state in DL"
ENDIF
        movzx   edx,dl
        jmp     aCmdAt[edx*4]   ; go to correct state handler
endm


IFDEF   MAXDEBUG
        public  maxOffset
maxOffset       dd      -1      ; handy for getting control at a specific point
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\detsup.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    detsup.c

Abstract:

    Various detection code is included from the HALs and this module
    includes compatible functions for setup

Revision History:

--*/

#include "haldtect.h"
#define _NTHAL_
#define _HALI_

//
// Include NCR detection code
//

#define SETUP

//
// Include ACPI detection code
//

#include "halacpi\acpisetd.c"

//
// Include MPS 1.1 detection code
//

#include "halmps\i386\mpdetect.c"

//
// Thunk functions.
// Equivalent Hal functions which various detection code may use
//

PVOID
HalpMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This routine maps physical memory into the area of virtual memory.

Arguments:

    PhysicalAddress - Supplies the physical address of the start of the
                      area of physical memory to be mapped.

    NumberPages - Supplies the number of pages contained in the area of
                  physical memory to be mapped.

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

--*/
{
    extern  PHARDWARE_PTE HalPT;
    ULONG   PageFrame;
    ULONG   i, j, PagesMapped;

    PageFrame = (PhysicalAddress.LowPart) >> PAGE_SHIFT;
    if (PageFrame >= 1  &&  PageFrame+NumberPages < 0x1000) {
        //
        // The lower 16M is 'identity' mapped with the physical addresses.
        //

        return (PVOID)PhysicalAddress.LowPart;
    }

    //
    // Map a pointer to the address requested
    //

    for (i=0; i <= 1024-NumberPages; i++) {
        for (j=0; j < NumberPages; j++) {
            if ( ((PULONG)HalPT)[i+j] ) {
                break;
            }
        }

        if (j == NumberPages) {
            for (j=0; j<NumberPages; j++) {
                HalPT[i+j].PageFrameNumber = PageFrame+j;
                HalPT[i+j].Valid = 1;
                HalPT[i+j].Write = 1;
            }

            j = 0xffc00000 | (i<<12) | ((PhysicalAddress.LowPart) & 0xfff);
            return (PVOID) j;
        }
    }

    SlFatalError(PhysicalAddress.LowPart);
    return NULL;
}


PVOID
HalpMapPhysicalMemoryWriteThrough64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This routine maps physical memory into the area of virtual memory.

Arguments:

    PhysicalAddress - Supplies the physical address of the start of the
                      area of physical memory to be mapped.

    NumberPages - Supplies the number of pages contained in the area of
                  physical memory to be mapped.

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

--*/
{
    extern  PHARDWARE_PTE HalPT;
    ULONG   PageFrame;
    ULONG   i, j, PagesMapped;

    PageFrame = (PhysicalAddress.LowPart) >> PAGE_SHIFT;

    //
    // Map a pointer to the address requested
    //

    for (i=0; i <= 1024-NumberPages; i++) {
        for (j=0; j < NumberPages; j++) {
            if ( ((PULONG)HalPT)[i+j] ) {
                break;
            }
        }

        if (j == NumberPages) {
            for (j=0; j<NumberPages; j++) {
                HalPT[i+j].PageFrameNumber = PageFrame+j;
                HalPT[i+j].Valid = 1;
                HalPT[i+j].Write = 1;
                HalPT[i+j].WriteThrough = 1;
                HalPT[i+j].CacheDisable = 1;
            }

            j = 0xffc00000 | (i<<12) | ((PhysicalAddress.LowPart) & 0xfff);
            return (PVOID) j;
        }
    }

    SlFatalError(PhysicalAddress.LowPart);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\bootx86.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bootx86.h

Abstract:

    Header file for the x86-specific portions of the common boot library

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

--*/

#ifndef _BOOTX86_
#define _BOOTX86_

#include "bldrx86.h"
#include "..\bootlib.h"

//
// common typedefs
//

//
// This must match the structure with the same name in startup\i386\types.h,
// and the FsContextRecord struct in startup\i386\su.inc.
//
typedef struct _FSCONTEXT_RECORD {
    UCHAR BootDrive;
} FSCONTEXT_RECORD, *PFSCONTEXT_RECORD;

//          M E M O R Y   D E S C R I P T O R
//
// Memory Descriptor - each contiguous block of physical memory is
// described by a Memory Descriptor. The descriptors are a table, with
// the last entry having a BlockBase and BlockSize of zero.  A pointer
// to the beginning of this table is passed as part of the BootContext
// Record to the OS Loader.
//

typedef struct _SU_MEMORY_DESCRIPTOR {
    ULONG BlockBase;
    ULONG BlockSize;
} SU_MEMORY_DESCRIPTOR , *PSU_MEMORY_DESCRIPTOR;

VOID
InitializeMemoryDescriptors (
    VOID
    );


//          B O O T   C O N T E X T   R E C O R D
//
//  Passed to the OS loader by the SU module or bootstrap
//  code, whatever the case. Constains all the basic machine
//  and environment information the OS loaders needs to get
//  itself going.
//

typedef struct _BOOT_CONTEXT {
    PFSCONTEXT_RECORD FSContextPointer;
    PEXTERNAL_SERVICES_TABLE ExternalServicesTable;
    PSU_MEMORY_DESCRIPTOR MemoryDescriptorList;
    ULONG MachineType;
    ULONG OsLoaderStart;
    ULONG OsLoaderEnd;
    ULONG ResourceDirectory;
    ULONG ResourceOffset;
    ULONG OsLoaderBase;
    ULONG OsLoaderExports;
    ULONG BootFlags;
    ULONG NtDetectStart;
    ULONG NtDetectEnd;
    ULONG SdiAddress;
} BOOT_CONTEXT, *PBOOT_CONTEXT;

//
// Common function prototypes
//

VOID
InitializeDisplaySubsystem(
    VOID
    );

ARC_STATUS
InitializeMemorySubsystem(
    PBOOT_CONTEXT
    );

ARC_STATUS
XferPhysicalDiskSectors(
    IN  UCHAR     Int13UnitNumber,
    IN  ULONGLONG StartSector,
    IN  UCHAR     SectorCount,
    OUT PUCHAR    Buffer,
    IN  UCHAR     SectorsPerTrack,
    IN  USHORT    Heads,
    IN  USHORT    Cylinders,
    IN  BOOLEAN   AllowExtendedInt13,
    IN  BOOLEAN   Write
    );

#define ReadPhysicalSectors(d,a,n,p,s,h,c,f)                                \
                                                                            \
            XferPhysicalDiskSectors((d),(a),(n),(p),(s),(h),(c),(f),FALSE)

#define WritePhysicalSectors(d,a,n,p,s,h,c,f)                               \
                                                                            \
            XferPhysicalDiskSectors((d),(a),(n),(p),(s),(h),(c),(f),TRUE)


ARC_STATUS
XferExtendedPhysicalDiskSectors(
    IN  UCHAR     Int13UnitNumber,
    IN  ULONGLONG StartSector,
    IN  USHORT    SectorCount,
    OUT PUCHAR    Buffer,
    IN  BOOLEAN   Write
    );

#define ReadExtendedPhysicalSectors(d,a,c,p)                                \
                                                                            \
            XferExtendedPhysicalDiskSectors((d),(a),(c),(p),FALSE)

#define WriteExtendedPhysicalSectors(d,a,c,p)                               \
                                                                            \
            XferExtendedPhysicalDiskSectors((d),(a),(c),(p),TRUE)

VOID
ResetDiskSystem(
    UCHAR Int13UnitNumber
    );

VOID
MdShutoffFloppy(
    VOID
    );


BOOLEAN
FwGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    );

PVOID
FwAllocateHeapAligned(
    IN ULONG Size
    );

PVOID
FwAllocatePool(
    IN ULONG Size
    );

PVOID
FwAllocateHeapPermanent(
    IN ULONG NumberPages
    );

VOID
FwStallExecution(
    IN ULONG Microseconds
    );

VOID
BlGetActivePartition(
    OUT PUCHAR PartitionName
    );

VOID
BlFillInSystemParameters(
    IN PBOOT_CONTEXT BootContextRecord
    );

VOID
BlpRemapReserve (
    VOID
    );

ARC_STATUS
BlpMarkExtendedVideoRegionOffLimits(
    VOID
    );
//
// global data definitions
//

extern ULONG MachineType;
extern PCONFIGURATION_COMPONENT_DATA FwConfigurationTree;
extern ULONG HeapUsed;
extern ULONG BlHighestPage;
extern ULONG BlLowestPage;

#define HYPER_SPACE_ENTRY       768
#define HYPER_SPACE_BEGIN       0xC0000000
#define HYPER_PAGE_DIR          0xC0300000

//
// X86 Detection definitions
// The size is *ALWAYS* assumed to be 64K.
// N.B.  The definition *MUST* be the same as the ones defined in
//       startup\su.inc
//

#define DETECTION_LOADED_ADDRESS 0x10000

//
//  We need to allocate permanent and temporary memory for the page directory,
//  assorted page tables, and the memory descriptors before the blmemory
//  routines ever get control.  So we have two private heaps, one for permanent
//  data and one for temporary data.  There are two descriptors for this.  The
//  permanent heap descriptor starts out as zero-length at P.A. 0x30000.  The
//  temporary heap descriptor immediately follows the permanent heap in memory
//  and starts out as 128k long.  As we allocate permanent pages, we increase
//  the size of the permanent heap descriptor and increase the base (thereby
//  decreasing the size) of the temporary heap descriptor)
//
//  So the permanent heap starts at P.A. 0x30000 and grows upwards.  The
//  temporary heap starts at P.A. 0x5C000 and grows downwards.  This gives us
//  a total of 128k of combined permanent and temporary data.
//

//
// Heap starting locations (in pages)
//

//
// Scratch buffer for disk cache is 36K and begins before the permanent heap
//
#define SCRATCH_BUFFER_SIZE (36*1024)
extern PUCHAR FwDiskCache;

#define BIOS_DISK_CACHE_START 0x30
#define PERMANENT_HEAP_START (0x30+(SCRATCH_BUFFER_SIZE/PAGE_SIZE))
#define TEMPORARY_HEAP_START 0x60

//
// The base "window" for the loader and loaded images == 16MB
// See the comments in memory.c for the implications of changing these.
//
#define BASE_LOADER_IMAGE     (16*1024*1024)

//
// Useful Macro Definitions
//

#define ROUND_UP(Num,Size)  (((Num) + Size - 1) & ~(Size -1))

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) { \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) { \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) { \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

//
// Global definitions for the BIOS ARC Emulation
//
// Defines for the ARC name of console input and output
//

#define CONSOLE_INPUT_NAME "multi(0)key(0)keyboard(0)"
#define CONSOLE_OUTPUT_NAME "multi(0)video(0)monitor(0)"

//
// Define special character values.
//

#define ASCI_NUL 0x00
#define ASCI_BEL 0x07
#define ASCI_BS  0x08
#define ASCI_HT  0x09
#define ASCI_LF  0x0A
#define ASCI_VT  0x0B
#define ASCI_FF  0x0C
#define ASCI_CR  0x0D
#define ASCI_ESC 0x1B
#define ASCI_SYSRQ 0x80

//
// Device I/O prototypes
//

ARC_STATUS
BiosPartitionClose(
    IN ULONG FileId
    );

ARC_STATUS
BiosPartitionOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosPartitionRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
BiosPartitionGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );
    
ARC_STATUS
BiosDiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );

ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosConsoleReadStatus(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleRead (
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosConsoleWrite (
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosDiskOpen(
    IN ULONG DriveId,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosDiskRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosElToritoDiskRead(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

BOOLEAN
BlIsElToritoCDBoot(
    UCHAR DriveNum
    );

ARC_STATUS
BiosDiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
HardDiskPartitionOpen(
    IN ULONG   FileId,
    IN ULONG   DiskId,
    IN UCHAR   PartitionNumber
    );

//
// Boot debugger prototypes required to initialize the appropriate IDT entries.
//

VOID
BdTrap01 (
    VOID
    );

VOID
BdTrap03 (
    VOID
    );

VOID
BdTrap0d (
    VOID
    );

VOID
BdTrap0e (
    VOID
    );

VOID
BdTrap2d (
    VOID
    );


//
// Helper functions and macros
//

#define PTE_PER_PAGE_X86 (PAGE_SIZE / sizeof(HARDWARE_PTE_X86))
#define PTE_PER_PAGE_X86PAE (PAGE_SIZE / sizeof(HARDWARE_PTE_X86PAE))

#define PAGE_FRAME_FROM_PTE( _pte ) \
            ((PVOID)(_pte->PageFrameNumber << PAGE_SHIFT))

#define PPI_SHIFT_X86PAE 30

#define PT_INDEX_PAE( va ) (((ULONG_PTR)(va) >> PTI_SHIFT) & \
                            ((1 << (PDI_SHIFT_X86PAE - PTI_SHIFT)) - 1))

#define PD_INDEX_PAE( va ) (((ULONG_PTR)(va) >> PDI_SHIFT_X86PAE) & \
                            ((1 << (PPI_SHIFT_X86PAE - PDI_SHIFT_X86PAE)) - 1));

#define PP_INDEX_PAE( va ) ((ULONG_PTR)(va) >> PPI_SHIFT_X86PAE)

#define PAGE_TO_VIRTUAL( page ) ((PVOID)((page << PAGE_SHIFT)))

#endif // _BOOTX86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\disp98.h ===
/*++

Copyright (c) 1995  Nec Software Ltd., Tokyo. Japan.

Module Name:

    disp98.h

Abstract:

    Private header file for display routines of PC98.

Author:

    Hideaki Shono 19-Sep-1995

Revision History:

--*/
//
// structures
//
static UCHAR EmulColor[8][8]={
                {0x01,0x21,0x81,0xA1,0x41,0x61,0xC1,0xE1}, //black
                {0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1}, //white character on black background
//                {0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5}, //blue
                {0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85}, //green
                {0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5}, //cyan
                {0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45}, //red
                {0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65}, //magenta
                {0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5}, //yellow
                {0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5}  //white
        };

//
// Code Page 932's code set to PC-98 VRAM code set. (graphics only)
//
static UCHAR Convert932GrphChrSet[0x20] =
        { 0x20, 0x98, 0x99, 0x9A, 0x9B, 0x96, 0x95, 0x0F,   // 0x00 - 0x07
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x08 - 0x0F
          0x8F, 0x20, 0x20, 0x20, 0x87, 0x90, 0x91, 0x92,   // 0x10 - 0x17
          0x20, 0x93, 0x20, 0x20, 0x1E, 0x20, 0x1C, 0x1D }; // 0x18 - 0x1F

//
// From IBM ASCII char set (0xB0-0xDF) to NEC char set
//
static UCHAR ConvertToNECGrphChrSet[0x40] =
        { 0x8A, 0x8B, 0x8C, 0x96, 0x92, 0x92, 0x92, 0x99,   // 0xB0 - 0xB7
          0x99, 0x92, 0x96, 0x99, 0x9B, 0x9B, 0x9B, 0x99,   // 0xB8 - 0xBF
          0x9A, 0x90, 0x91, 0x93, 0x95, 0x8F, 0x93, 0x93,   // 0xC0 - 0xC7
          0x9A, 0x98, 0x90, 0x91, 0x93, 0x95, 0x8F, 0x90,   // 0xC8 - 0xCF
          0x90, 0x91, 0x91, 0x9A, 0x9A, 0x98, 0x98, 0x8F,   // 0xD0 - 0xD7
          0x8F, 0x9B, 0x98, 0x87, 0x83, 0x8A, 0x97, 0x94 }; // 0xD8 - 0xDF
//
// Code Page 437's code set to PC-98 VRAM code set.
//
/*
static UCHAR Convert437GrphChrSet[0x100] = {
          0x20, 0x20, 0x20, 0xE9, 0xEA, 0xEB, 0xE8, 0x20,   // 0x00 - 0x07
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x08 - 0x0F
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x10 - 0x17
          0x1E, 0x1F, 0x1C, 0x1D, 0x20, 0x20, 0x20, 0x20,   // 0x18 - 0x1F
          0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,   // 0x20 - 0x27
          0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,   // 0x28 - 0x2F
          0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,   // 0x30 - 0x37
          0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,   // 0x38 - 0x3F
          0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,   // 0x40 - 0x47
          0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,   // 0x48 - 0x4F
          0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,   // 0x50 - 0x57
          0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,   // 0x58 - 0x5F
          0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,   // 0x60 - 0x67
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,   // 0x68 - 0x6F
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,   // 0x70 - 0x77
          0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,   // 0x78 - 0x7F
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x80 - 0x87
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x88 - 0x8F
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x90 - 0x97
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x98 - 0x9F
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xA0 - 0xA7
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xA8 - 0xAF
          0x20, 0x20, 0x20, 0x96, 0x92, 0x92, 0x92, 0x99,   // 0xB0 - 0xB7
          0x99, 0x92, 0x96, 0x99, 0x9B, 0x9B, 0x9B, 0x99,   // 0xB8 - 0xBF
          0x9A, 0x90, 0x91, 0x93, 0x95, 0x8F, 0x93, 0x93,   // 0xC0 - 0xC7
          0x9A, 0x98, 0x90, 0x91, 0x93, 0x95, 0x8F, 0x90,   // 0xC8 - 0xCF
          0x90, 0x91, 0x91, 0x9A, 0x9A, 0x98, 0x98, 0x8F,   // 0xD0 - 0xD7
          0x8F, 0x9B, 0x98, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xD8 - 0xDF
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xE0 - 0xE7
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xE8 - 0xEF
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xF0 - 0xF7
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20 }; // 0xF8 - 0xFF
*/

//
// define
//
#define ATTROFFSET98 0x2000
#define IsANK(c) (!((c >= (UCHAR)0x81 && c <= (UCHAR)0x9f) || (c >= (UCHAR)0xe0 && c <= (UCHAR)0xfe)))


//
// Globals
//
static BOOLEAN IsKanji2nd = FALSE;
static UCHAR   Kanji1st;

// extern BOOLEAN  bInGraphicsMode;
//
// These should be set by an call to a initialization routine.
//
USHORT  RowsPerScreen = 25;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\detmach.asm ===
SETUP equ 1

;**
;
; Machine-specific detection code
;
;--

.386p

include hal386.inc
include callconv.inc

;
; Include SystemPro detection code
;
SYSTEMPRO   equ     1
include halsp\i386\spdetect.asm


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; Thunk functions.
; Equivalent Hal functions which various detection code may use
;

;++
;
; CMOS space read  functions.
;
;--

CMOSAddressPort equ     70H
CMOSDataPort    equ     71H

CMOSExAddressLSBPort    equ     74H
CMOSExAddressMSBPort    equ     75H
CMOSExDataPort          equ     76H

;++
;
;   VOID
;   ReadCMOS(
;       ULONG   StartingOffset
;       ULONG   Count
;       PUCHAR  ReturnValuePtr
;       )
;
;   Read CMOS starting at the given offset for the given number of
;   bytes putting the bytes read into the buffer pointed to by the
;   given address.
;
;   Arguments:
;
;       StartingOffset  : where to start in CMOS
;
;       Count           : how many bytes to read
;
;       ReturnValuePtr  : where to put bytes read
;
;   Returns:
;       None.
;
;--
StartingOffset  equ     2*4[ebp]
Count           equ     3*4[ebp]
ReturnValuePtr  equ     4*4[ebp]

cPublicProc _ReadCMOS,3

        push    ebp
        mov     ebp, esp
        push    ebx             ; caller's reg
        push    edi             ; caller's reg

        mov     ebx, StartingOffset
        mov     ecx, Count
        mov     edi, ReturnValuePtr

        align   dword
NextByte:
        cmp     bh, 0
        jne     ExCMOSRead

        mov     al, bl
        out     CMOSAddressPort, al
        in      al, CMOSDataPort
        mov     [edi], al

        add     ebx, 1
        add     edi, 1
        sub     ecx, 1
        jg      NextByte

        pop     edi             ; restore caller's reg
        pop     ebx             ; restore caller's reg
        pop     ebp
        stdRET  _ReadCmos

        align   dword
ExCMOSRead:

        mov     al, bl
        out     CMOSExAddressLSBPort, al
        mov     al, bh
        out     CMOSExAddressMSBPort, al
        in      al, CMOSExDataPort
        mov     [edi], al

        add     ebx, 1
        add     edi, 1
        sub     ecx, 1
        jg      ExCMOSRead

        pop     edi             ; restore caller's reg
        pop     ebx             ; restore caller's reg
        pop     ebp
        stdRET  _ReadCMOS

stdENDP _ReadCMOS


; 486 C step CPU detection code.

CR0_ET          equ     10h
CR0_TS          equ     08H
CR0_EM          equ     04H
CR0_MP          equ     02H

;
; The following equates define the control bits of EFALGS register
;

EFLAGS_AC       equ     40000h
EFLAGS_ID       equ     200000h

;
; Constants for Floating Point test
;

REALLONG_LOW          equ     00000000
REALLONG_HIGH         equ     3FE00000h
PSEUDO_DENORMAL_LOW   equ     00000000h
PSEUDO_DENORMAL_MID   equ     80000000h
PSEUDO_DENORMAL_HIGH  equ     0000h

;
; Define the iret frame
;

IretFrame       struc

IretEip        dd      0
IretCs         dd      0
IretEFlags     dd      0

IretFrame       ends

;++
;
; BOOLEAN
; Detect486CStep (
;    IN PBOOLEAN Dummy
;    )
;
; Routine Description:
;
;   Returns TRUE if the processor is a 486 C stepping.  We detect the CPU
;   in order to use a specific HAL.  This HAL attempts to work around
;   a 486 C stepping bug which the normal HAL tends to aggravate.
;

cPublicProc _Detect486CStep,1
        push    edi
        push    esi
        push    ebx                     ; Save C registers
        mov     eax, cr0
        push    eax
        pushfd                          ; save Cr0 & flags

        pop     ebx                     ; Get flags into eax
        push    ebx                     ; Save original flags

        mov     ecx, ebx
        xor     ecx, EFLAGS_AC          ; flip AC bit
        push    ecx
        popfd                           ; load it into flags
        pushfd                          ; re-save flags
        pop     ecx                     ; get flags into eax
        cmp     ebx, ecx                ; did bit stay flipped?
        je      short Not486C           ; No, then this is a 386

        mov     ecx, ebx
        xor     ecx, EFLAGS_ID          ; flip ID bit
        push    ecx
        popfd                           ; load it into flags
        pushfd                          ; re-save flags
        pop     ecx                     ; get flags into eax
        cmp     ebx, ecx                ; did bit stay flipped?
        jne     short Not486C           ; Yes, then this >= 586

        mov     eax, cr0
        and     eax, NOT (CR0_ET+CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, eax

        call    IsNpxPresent            ; Check if cpu has coprocessor support?
        or      ax, ax
        jz      short Is486C            ; it is actually 486sx, assume C step

        call    Check486CStepping       ; Check for <= C stepping
        jnc     short Not486C           ; if nc, it is NOT a C stepping

Is486C:
        mov     eax, 1                  ; Return TRUE
        jmp     short DetectCpuExit

Not486C:
        xor     eax, eax

DetectCpuExit:
        popfd
        pop     ebx
        mov     cr0, ebx
        pop     ebx
        pop     esi
        pop     edi
        stdRET  _Detect486CStep

stdENDP _Detect486CStep

;++
;
; BOOLEAN
; Check486CStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 C Stepping.
;
;    This routine takes advantage of the fact that FSCALE produces
;    wrong result with Denormal or Pseudo-denormal operand on 486
;    C and earlier steps.
;
;    If the value contained in ST(1), second location in the floating
;    point stack, is between 1 and 11, and the value in ST, top of the
;    floating point stack, is either a pseudo-denormal number or a
;    denormal number with the underflow exception unmasked, the FSCALE
;    instruction produces an incorrect result.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D or later stepping.
;    Carry Flag set if C stepping.
;
;--

FpControl       equ     [ebp - 2]
RealLongSt1     equ     [ebp - 10]
PseudoDenormal  equ     [ebp - 20]
FscaleResult    equ     [ebp - 30]

        public  Check486CStepping
Check486CStepping       proc

        push    ebp
        mov     ebp, esp
        sub     esp, 30                 ; Allocate space for temp real variables

;
; Initialize the local FP variables to predefined values.
; RealLongSt1 = 1.0 * (2 ** -1) = 0.5 in normalized double precision FP form
; PseudoDenormal =  a unsupported format by IEEE.
;                   Sign bit = 0
;                   Exponent = 000000000000000B
;                   Significand = 100000...0B
; FscaleResult = The result of FSCALE instruction.  Depending on 486 step,
;                the value will be different:
;                Under C and earlier steps, 486 returns the original value
;                in ST as the result.  The correct returned value should be
;                original significand and an exponent of 0...01.
;

        mov     dword ptr RealLongSt1, REALLONG_LOW
        mov     dword ptr RealLongSt1 + 4, REALLONG_HIGH
        mov     dword ptr PseudoDenormal, PSEUDO_DENORMAL_LOW
        mov     dword ptr PseudoDenormal + 4, PSEUDO_DENORMAL_MID
        mov     word ptr PseudoDenormal + 8, PSEUDO_DENORMAL_HIGH

.387
        fnstcw  FpControl               ; Get FP control word
        or      word ptr FpControl, 0FFh ; Mask all the FP exceptions
        fldcw   FpControl               ; Set FP control

        fld     qword ptr RealLongSt1   ; 0 < ST(1) = RealLongSt1 < 1
        fld     tbyte ptr PseudoDenormal; Denormalized operand. Note, i486
                                        ; won't report denormal exception
                                        ; on 'FLD' instruction.
                                        ; ST(0) = Extended Denormalized operand
        fscale                          ; try to trigger 486Cx errata
        fstp    tbyte ptr FscaleResult  ; Store ST(0) in FscaleResult
        cmp     word ptr FscaleResult + 8, PSEUDO_DENORMAL_HIGH
                                        ; Is Exponent changed?
        jz      short c4ds00            ; if z, no, it is C step
        clc
        jmp     short c4ds10
c4ds00: stc
c4ds10: mov     esp, ebp
        pop     ebp
        ret

Check486CStepping       endp

;++
;
; BOOLEAN
; IsNpxPresent(
;     VOID
;     );
;
; Routine Description:
;
;     This routine determines if there is any Numeric coprocessor
;     present.
;
; Arguments:
;
;     None.
;
; Return:
;
;     TRUE - If NPX is present.  Else a value of FALSE is returned.
;
;--

        public  IsNpxPresent
IsNpxPresent   proc    near

        push    ebp                     ; Save caller's bp
        xor     edx, edx
.287
        fninit                          ; Initialize NPX
        mov     ecx, 5A5A5A5Ah          ; Put non-zero value
        push    ecx                     ;   into the memory we are going to use
        mov     ebp, esp
        fnstsw  word ptr [ebp]          ; Retrieve status - must use non-wait
        cmp     byte ptr [ebp], 0       ; All bits cleared by fninit?
        jne     Inp10

        mov     edx, 1

Inp10:
        pop     eax                     ; clear scratch value
        pop     ebp                     ; Restore caller's bp
        mov     eax, edx
        ret

IsNpxPresent   endp


_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Author:

    Thomas Parslow [TomP] Feb-13-1991
    Reworked substantially in Tokyo 7-July-95 (tedm)

Abstract:

    This file contains an interface to the screen that is independent
    of the screen type actually being written to. It is layered on top
    of modules pecific to vga text mode and vga graphics mode.

--*/


#include "bootx86.h"
#include "displayp.h"


#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + \
    (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))

//
// Current screen position.
//
USHORT TextColumn = 0;
USHORT TextRow  = 0;

//
// Current text attribute
//
UCHAR TextCurrentAttribute = 0x07;      // start with white on black.

//
// Internal routines
//
VOID
puti(
    LONG
    );

VOID
putx(
    ULONG
    );

VOID
putu(
    ULONG
    );

VOID
pTextCharOut(
    IN UCHAR c
    );

VOID
putwS(
    PUNICODE_STRING String
    );


VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.

Returns:

    Nothing

--*/

{
    USHORT b,c,w,len;
    PUCHAR ap;
    ULONG l;
    ULONG Count;
    CHAR ch;
    ULONG DeviceId;


    if (BlConsoleOutDeviceId == 0) {
        DeviceId = 1;
    } else {
        DeviceId = BlConsoleOutDeviceId;
    }

    //
    // Cast a pointer to the first word on the stack
    //
    ap = (PUCHAR)&cp + sizeof(PCHAR);

    //
    // Process the arguments using the descriptor string
    //
    while(b = *cp++) {
        if(b == '%') {

            c = *cp++;

            switch (c) {

            case 'd':
                puti((long)*((int *)ap));
                ap += sizeof(int);
                break;

            case 's':
                ArcWrite(DeviceId, *((PCHAR *)ap), strlen(*((PCHAR *)ap)), &Count);
                ap += sizeof(char *);
                break;

            case 'c':
                //
                // Does not handle dbcs chars
                //
                ArcWrite(DeviceId, ((char *)ap), 1, &Count);
                ap += sizeof(int);
                break;

            case 'x':
                w = *((USHORT *)ap);
                len = (USHORT)ZLEN_SHORT(w);
                ch = '0';
                while (len--) {
                    ArcWrite(DeviceId, &ch, 1, &Count);
                }
                putx((ULONG)*((USHORT *)ap));
                ap += sizeof(int);
                break;

            case 'u':
                putu((ULONG)*((USHORT *)ap));
                ap += sizeof(int);
                break;

            case 'w':
                c = *cp++;
                switch (c) {
                case 'S':
                case 'Z':
                    putwS(*((PUNICODE_STRING *)ap));
                    ap += sizeof(PUNICODE_STRING);
                    break;
                }
                break;

            case 'l':
                c = *cp++;

                switch(c) {

                case '0':
                    break;

                case 'u':
                    putu(*((ULONG *)ap));
                    ap += sizeof(long);
                    break;

                case 'x':
                    l = *((ULONG *)ap);
                    len = (USHORT)ZLEN_LONG(l);
                    ch = '0';
                    while (len--) {
                        ArcWrite(DeviceId, &ch, 1, &Count);
                    }
                    putx(*((ULONG *)ap));
                    ap += sizeof(long);
                    break;

                case 'd':
                    puti(*((ULONG *)ap));
                    ap += sizeof(long);
                    break;
                }
                break;

            default :
                ch = (char)b;
                ArcWrite(DeviceId, &ch, 1, &Count);
                ch = (char)c;
                ArcWrite(DeviceId, &ch, 1, &Count);
            }
        } else {

            if (DbcsLangId && GrIsDBCSLeadByte(*(cp - 1)))  {
                //
                // A double-byte char.
                //
                ArcWrite(DeviceId, cp - 1, 2, &Count);
                cp++;
            } else {
                ArcWrite(DeviceId, cp - 1, 1, &Count);
            }

        }

    }

}


VOID
putwS(
    PUNICODE_STRING String
    )

/*++

Routine Description:

    Writes unicode string to the display at the current cursor position.

Arguments:

    String - pointer to unicode string to display

Returns:

    Nothing

--*/

{
    ULONG i;
    ULONG Count;
    UCHAR ch;

    for(i=0; i < String->Length/sizeof(WCHAR); i++) {
        ch = (UCHAR)String->Buffer[i];
        ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
    }
}


VOID
putx(
    ULONG x
    )

/*++

Routine Description:

    Writes hex long to the display at the current cursor position.

Arguments:

    x - ulong to write

Returns:

    Nothing

--*/

{
    ULONG j;
    ULONG Count;
    UCHAR ch;

    if(x/16) {
        putx(x/16);
    }

    if((j=x%16) > 9) {
        ch = (UCHAR)(j+'A'-10);
        ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
    } else {
        ch = (UCHAR)(j+'0');
        ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
    }
}


VOID
puti(
    LONG i
    )

/*++

Routine Description:

    Writes a long integer on the display at the current cursor position.

Arguments:

    i - the integer to write to the display.

Returns:

    Nothing

--*/

{
    ULONG Count;
    UCHAR ch;

    if(i<0) {
        i = -i;
        ch = '-';
        ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
    }

    if(i/10) {
        puti(i/10);
    }

    ch = (UCHAR)((i%10)+'0');
    ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
}


VOID
putu(
    ULONG u
    )

/*++

Routine Description:

    Write an unsigned long to display

Arguments:

    u - unsigned

Returns:

    Nothing

--*/

{
    ULONG Count;
    UCHAR ch;

    if(u/10) {
        putu(u/10);
    }
    
    ch = (UCHAR)((u%10)+'0');
    ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
}


VOID
pTextCharOut(
    IN UCHAR c
    )
{
    if(DbcsLangId) {
        //
        // Single-byte only
        //
        TextGrCharOut(&c);
    } else {
        TextTmCharOut(&c);
    }
}


PUCHAR
TextCharOut(
    IN PUCHAR pc
    )
{
    if(DbcsLangId) {
        return(TextGrCharOut(pc));
    } else {
        return(TextTmCharOut(pc));
    }
}


VOID
TextStringOut(
    IN PUCHAR String
    )
{
    if(DbcsLangId) {
        TextGrStringOut(String);
    } else {
        TextTmStringOut(String);
    }
}


VOID
TextClearToEndOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the line
    by writing blanks with the current video attribute.

Arguments:

    None

Returns:

    Nothing


--*/

{
    if(DbcsLangId) {
        TextGrClearToEndOfLine();
    } else {
        TextTmClearToEndOfLine();
    }
}


VOID
TextClearFromStartOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the start of the line to the current cursor position
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    if(DbcsLangId) {
        TextGrClearFromStartOfLine();
    } else {
        TextTmClearFromStartOfLine();
    }
}


VOID
TextClearToEndOfDisplay(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the video
    display by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    if(DbcsLangId) {
        TextGrClearToEndOfDisplay();
    } else {
        TextTmClearToEndOfDisplay();
    }
}


VOID
TextClearDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the video display and positions the cursor
    at the upper left corner of the screen (0,0).

Arguments:

    None

Returns:

    Nothing

--*/

{
    if(DbcsLangId) {
        TextGrClearDisplay();
    } else {
        TextTmClearDisplay();
    }
    TextSetCursorPosition(0,0);
}


VOID
TextSetCursorPosition(
    IN ULONG X,
    IN ULONG Y
    )

/*++

Routine Description:

    Moves the location of the software cursor to the specified X,Y position
    on screen.

Arguments:

    X - Supplies the X-position of the cursor

    Y - Supplies the Y-position of the cursor

Return Value:

    None.

--*/

{
    TextColumn = (USHORT)X;
    TextRow = (USHORT)Y;

    if(DbcsLangId) {
        TextGrPositionCursor((USHORT)Y,(USHORT)X);
    } else {
        TextTmPositionCursor((USHORT)Y,(USHORT)X);
    }
}


VOID
TextGetCursorPosition(
    OUT PULONG X,
    OUT PULONG Y
    )

/*++

Routine Description:

    Gets the position of the soft cursor.

Arguments:

    X - Receives column coordinate of where character would be written.

    Y - Receives row coordinate of where next character would be written.

Returns:

    Nothing.

--*/

{
    *X = (ULONG)TextColumn;
    *Y = (ULONG)TextRow;
}


VOID
TextSetCurrentAttribute(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Sets the character attribute to be used for subsequent text display.

Arguments:

Returns:

    Nothing.

--*/

{
    TextCurrentAttribute = Attribute;

    if(DbcsLangId) {
        TextGrSetCurrentAttribute(Attribute);
    } else {
        TextTmSetCurrentAttribute(Attribute);
    }
}


UCHAR
TextGetCurrentAttribute(
    VOID
    )
{
    return(TextCurrentAttribute);
}

VOID
TextFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    )

/*++

Routine Description:

    Changes the screen attribute starting at the current cursor position.
    The cursor is not moved.

Arguments:

    Attribute - Supplies the new attribute

    Length - Supplies the length of the area to change (in bytes)

Return Value:

    None.

--*/

{
    if(DbcsLangId) {
        TextGrFillAttribute(Attribute,Length);
    } else {
        TextTmFillAttribute(Attribute,Length);
    }
}


UCHAR
TextGetGraphicsCharacter(
    IN GraphicsChar WhichOne
    )
{
    return((WhichOne < GraphicsCharMax)
           ? (DbcsLangId ? TextGrGetGraphicsChar(WhichOne) : TextTmGetGraphicsChar(WhichOne))
           : ' ');
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\disp_tm.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    disp_tm.c

Author:

    Ted Miller 6-July-1995

Abstract:

    This routine contains low-level routines to operate on a
    CGA-style text mode video buffer.

    It collects up various other bits and pieces that were written by
    others and once contained in other source files.

--*/

#include "bootx86.h"
#include "displayp.h"

//
// Standard cga 80x25 text mode's video buffer address,
// resolution, etc.
//
#define VIDEO_BUFFER_VA 0xb8000
#define VIDEO_ROWS      25
#define VIDEO_COLUMNS   80
#define VIDEO_BYTES_PER_ROW (VIDEO_COLUMNS*2)

//
// Various globals to track location on screen, attribute, etc.
//
PUCHAR Vp = (PUCHAR)VIDEO_BUFFER_VA;


VOID
TextTmPositionCursor(
    USHORT Row,
    USHORT Column
    )

/*++

Routine Description:

    Sets the position of the soft cursor. That is, it doesn't move the
    hardware cursor but sets the location of the next write to the
    screen.

Arguments:

    Row - Row coordinate of where character is to be written.

    Column - Column coordinate of where character is to be written.

Returns:

    Nothing.

--*/

{
    if(Row >= VIDEO_ROWS) {
        Row = VIDEO_ROWS-1;
    }

    if(Column >= VIDEO_COLUMNS) {
        Column = VIDEO_COLUMNS-1;
    }

    Vp = (PUCHAR)(VIDEO_BUFFER_VA + (Row * VIDEO_BYTES_PER_ROW) + (2 * Column));
}


VOID
TextTmStringOut(
    IN PUCHAR String
    )
{
    PUCHAR p = String;

    while(*p) {
        p = TextTmCharOut(p);
    }
}


PUCHAR
TextTmCharOut(
    PUCHAR pc
    )

/*++

Routine Description:

    Writes a character on the display at the current position.
    Newlines and tabs are interpreted and acted upon.

Arguments:

    c - pointer to character to write

Returns:

    Pointer to next char in string

--*/



{
    unsigned u;
    UCHAR c;
    UCHAR temp;

    c = *pc;

    switch (c) {
    case '\n':
        if(TextRow == (VIDEO_ROWS-1)) {
            TextTmScrollDisplay();
            TextSetCursorPosition(0,TextRow);
        } else {
            TextSetCursorPosition(0,TextRow+1);
        }
        break;

    case '\r':
        //
        // ignore
        //
        break;

    case '\t':
        temp = ' ';
        u = 8 - (TextColumn % 8);
        while(u--) {
            TextTmCharOut(&temp);
        }
        TextSetCursorPosition(TextColumn+u,TextRow);
        break;

    default :
        *Vp++ = c;
        *Vp++ = TextCurrentAttribute;
        TextSetCursorPosition(TextColumn+1,TextRow);
      }

      return(pc+1);
}


VOID
TextTmFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    )

/*++

Routine Description:

    Changes the screen attribute starting at the current cursor position.
    The cursor is not moved.

Arguments:

    Attribute - Supplies the new attribute

    Length - Supplies the length of the area to change (in bytes)

Return Value:

    None.

--*/

{
    PUCHAR Temp;

    Temp = Vp+1;

    while((Vp+1+Length*2) > Temp) {
        *Temp++ = (UCHAR)Attribute;
        Temp++;
    }
}


VOID
TextTmClearToEndOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the line
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    PUSHORT p;
    unsigned u;

    //
    // Calculate address of current cursor position
    //
    p = (PUSHORT)((PUCHAR)VIDEO_BUFFER_VA + (TextRow*VIDEO_BYTES_PER_ROW)) + TextColumn;

    //
    // Fill with blanks up to end of line.
    //
    for(u=TextColumn; u<VIDEO_COLUMNS; u++) {
        *p++ = (TextCurrentAttribute << 8) + ' ';
    }
}


VOID
TextTmClearFromStartOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the start of the line to the current cursor position
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    PUSHORT p;
    unsigned u;

    //
    // Calculate address of start of line in video buffer
    //
    p = (PUSHORT)((PUCHAR)VIDEO_BUFFER_VA + (TextRow*VIDEO_BYTES_PER_ROW));

    //
    // Fill with blanks up to char before cursor position.
    //
    for(u=0; u<TextColumn; u++) {
        *p++ = (TextCurrentAttribute << 8) + ' ';
    }
}


VOID
TextTmClearToEndOfDisplay(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the video
    display by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/
{
    USHORT x,y;
    PUSHORT p;

    //
    // Clear current line
    //
    TextTmClearToEndOfLine();

    //
    // Clear the remaining lines
    //
    p = (PUSHORT)((PUCHAR)VIDEO_BUFFER_VA + ((TextRow+1)*VIDEO_BYTES_PER_ROW));

    for(y=TextRow+1; y<VIDEO_ROWS; y++) {

        for(x=0; x<VIDEO_COLUMNS; x++) {

            *p++ =(TextCurrentAttribute << 8) + ' ';
        }
    }
}


VOID
TextTmClearDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the text-mode video display by writing blanks with
    the current video attribute over the entire display.

Arguments:

    None

Returns:

    Nothing

--*/

{
    unsigned u;

    //
    // Write blanks in the current attribute to the entire screen.
    //
    for(u=0; u<VIDEO_ROWS*VIDEO_COLUMNS; u++) {
        ((PUSHORT)VIDEO_BUFFER_VA)[u] = (TextCurrentAttribute << 8) + ' ';
    }
}


VOID
TextTmScrollDisplay(
    VOID
    )

/*++

Routine Description:

    Scrolls the display up one line. The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    PUSHORT Sp,Dp;
    USHORT i,j,c;

    Dp = (PUSHORT) VIDEO_BUFFER_VA;
    Sp = (PUSHORT) (VIDEO_BUFFER_VA + VIDEO_BYTES_PER_ROW);

    //
    // Move each row up one row
    //
    for(i=0 ; i < (USHORT)(VIDEO_ROWS-1) ; i++) {
        for(j=0; j < (USHORT)VIDEO_COLUMNS; j++) {
            *Dp++ = *Sp++;
        }
    }

    //
    // Write blanks in the bottom line, using the attribute
    // from the leftmost char on the bottom line on the screen.
    //
    c = (*Dp & (USHORT)0xff00) + (USHORT)' ';

    for(i=0; i < (USHORT)VIDEO_COLUMNS; ++i) {
        *Dp++ = c;
    }
}


VOID
TextTmSetCurrentAttribute(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Noop.

Arguments:

    Attribute - New attribute to set to.

Return Value:

    Nothing.

--*/

{
    UNREFERENCED_PARAMETER(Attribute);
}


CHAR TmGraphicsChars[GraphicsCharMax] = { '','','','','','' };

UCHAR
TextTmGetGraphicsChar(
    IN GraphicsChar WhichOne
    )
{
    return((UCHAR)TmGraphicsChars[WhichOne]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\disp_gr.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    disp_gr.c

Abstract:

    This file was created from \private\windows\setup\textmode\splib\ixdispj.c.
    This file contains routines to display MBCS characters to the Graphics
    VRAM.

Author:

    v-junm (Compaq Japan)
    hideyukn
    tedm

Environment:

    Kernel mode only.

Revision History:

--*/

#include "bootx86.h"
#include "displayp.h"
#include "bootfont.h"

#include "vmode.h"

//
// Physical video attributes.
//
#define VIDEO_BUFFER_VA 0xa0000
#define VIDEO_BYTES_PER_SCAN_LINE   80
#define VIDEO_WIDTH_PIXELS          640
#define VIDEO_HEIGHT_SCAN_LINES     480
#define VIDEO_SIZE_BYTES            (VIDEO_BYTES_PER_SCAN_LINE*VIDEO_HEIGHT_SCAN_LINES)


PUCHAR GrVp = (PUCHAR)VIDEO_BUFFER_VA;

//
// Screen width and height in half-character cells
// and macro to determine total number of characters
// displayed on the screen at once.
//
unsigned ScreenWidthCells,ScreenHeightCells;
#define SCREEN_SIZE_CELLS   (ScreenWidthCells*ScreenHeightCells)

//
// Globals:
//
// CharacterCellHeight is the number of scan lines total in a character.
// It includes any top or bottom fill lines.
//
// CharacterImageHeight is the number of scan lines in the image of a character.
// This is dependent on the font. Characters may be padded top and bottom.
//
// NOTE: All of this code assumes the font's single-byte characters are 8 bits wide
// and the font's double-byte characters are 16 bits wide!
//
unsigned CharacterCellHeight;
unsigned CharacterImageHeight;
unsigned CharacterTopPad;
unsigned CharacterBottomPad;

#define VIDEO_BYTES_PER_TEXT_ROW    (VIDEO_BYTES_PER_SCAN_LINE*CharacterCellHeight)

//
// Values describing the number of each type of character in the font,
// and pointers to the base of the glyphs.
//
unsigned SbcsCharCount;
unsigned DbcsCharCount;
PUCHAR SbcsImages;
PUCHAR DbcsImages;

//
// Values to be passed to GrDisplayMBCSChar
//
#define SBCSWIDTH 8
#define DBCSWIDTH 16

//
// Lead byte table. Read from bootfont.bin.
//
UCHAR LeadByteTable[2*(MAX_DBCS_RANGE+1)];


VOID
GrDisplayMBCSChar(
    IN PUCHAR   image,
    IN unsigned width,
    IN UCHAR    top,
    IN UCHAR    bottom
    );

PUCHAR
GrGetDBCSFontImage(
    USHORT Code
    );

PUCHAR
GrGetSBCSFontImage(
    UCHAR Code
    );


VOID
GrWriteSBCSChar(
    IN UCHAR c
    )

/*++

Routine Description:

    Displays a character at the current cursor position.  ONLY SBCS
    characters can be displayed using this routine.

Arguments:

    c - character to display.

Return Value:

    None.

--*/

{
    unsigned u;
    PUCHAR pImage;
    UCHAR temp;

    switch(c) {

    case '\n':
        if(TextRow == (ScreenHeightCells-1)) {
            TextGrScrollDisplay();
            TextSetCursorPosition(0,TextRow);
        } else {
            TextSetCursorPosition(0,TextRow+1);
        }
        break;

    case '\r':
        break;          // ignore

    case '\t':
        temp = ' ';
        u = 8 - (TextColumn % 8);
        while(u--) {
            TextGrCharOut(&temp);
        }
        TextSetCursorPosition(TextColumn+u,TextRow);
        break;

    default:
        //
        // Assume it's a valid SBCS character.
        // Get font image for SBCS char.
        //
        pImage = GrGetSBCSFontImage(c);

        //
        // Display the SBCS char. Check for special graphics characters.
        // Add top and bottom extra pixels accordingly (otherwise the grids
        // don't connect properly, because of top and bottom spacing).
        //
        if ( c == 0x2 || c == 0x1 || c == 0x16 )
            GrDisplayMBCSChar( pImage, SBCSWIDTH, 0x00, 0x24 );
        else if ( c == 0x4 || c == 0x3 || c == 0x15 )
            GrDisplayMBCSChar( pImage, SBCSWIDTH, 0x24, 0x00 );
        else if ( c == 0x5 || c == 10 || c == 0x17 || c == 0x19 )
            GrDisplayMBCSChar( pImage, SBCSWIDTH, 0x24, 0x24 );
        else
            GrDisplayMBCSChar( pImage, SBCSWIDTH, 0x00, 0x00 );
    }
}


VOID
GrDisplayMBCSChar(
    IN PUCHAR   image,
    IN unsigned width,
    IN UCHAR    top,
    IN UCHAR    bottom
    )

/*++

Routine Description:

    Displays a DBCS or a SBCS character at the current cursor
    position.

Arguments:

    image - SBCS or DBCS font image.
    width - Width in bits of character image (must be SBCSWIDTH pr DBCSWIDTH).
    top   - Character to fill the top extra character line(s).
    bottom- Character to fill the bottom extra character line(s).

Return Value:

    FALSE if image points to NULL,
    else TRUE.

--*/

{
    unsigned i;
    PUCHAR VpOld = GrVp;

    //
    // Validate parameter
    //
    if(image == NULL) {
        return;
    }


    //
    // There are TOP_EXTRA lines at the top that we need to skip (background color).
    //
    for(i=0; i<CharacterTopPad; i++) {

        //
        // If DBCS char, we need to clear 2 bytes.
        //
        if(width == DBCSWIDTH) {
            *GrVp++ = top;
        }
        *GrVp++ = top;

        //
        // Position pointer at next scan line
        // for the font image.
        //
        GrVp += VIDEO_BYTES_PER_SCAN_LINE - (width/SBCSWIDTH);
    }

    //
    // Display full height of DBCS or SBCS char.
    //
    for(i=0; i<CharacterImageHeight; i++) {

        //
        // If DBCS char, need to display 2 bytes,
        // so display first byte here.
        //
        if(width == DBCSWIDTH) {
            *GrVp++ = *image++;
        }

        //
        // Display 2nd byte of DBCS char or the
        // first and only byte of SBCS char.
        //
        *GrVp++ = *image++;

        //
        // Increment GrVP to display location of
        // next row of font image.
        //
        GrVp += VIDEO_BYTES_PER_SCAN_LINE - (width/SBCSWIDTH);
    }

    //
    // There are BOT_EXTRA lines at the bottom that we need to fill with the
    // background color.
    //
    for(i=0; i<CharacterBottomPad; i++) {

        //
        // If DBCS char, need to clear 2 bytes
        //
        if(width == DBCSWIDTH) {
            *GrVp++ = bottom;
        }
        *GrVp++ = bottom;

        //
        // Position pointer at next scan line
        // for the font image.
        //
        GrVp += VIDEO_BYTES_PER_SCAN_LINE - (width/SBCSWIDTH);
    }

    //
    // Increment cursor and video pointer
    //
    if(width == DBCSWIDTH) {
        TextSetCursorPosition(TextColumn+2,TextRow);
    } else {
        TextSetCursorPosition(TextColumn+1,TextRow);
    }
}


unsigned
GrWriteMBCSString(
    IN PUCHAR   String,
    IN unsigned MaxChars
    )

/*++

Routine Description:

    Displays a mixed byte string at the current cursor
    position.

Arguments:

    String - supplies pointer to asciz string.

    MaxBytes - supplies the maximum number of characters to be written.

Return Value:

    Number of bytes written.

--*/

{
    PCHAR  pImage;
    USHORT DBCSChar;
    unsigned BytesWritten;

    BytesWritten = 0;

    //
    // While string is not NULL,
    // get font image and display it.
    //
    while(*String && MaxChars--)  {

        //
        // Determine if char is SBCS or DBCS, get the correct font image,
        // and display it.
        //
        if(GrIsDBCSLeadByte(*String))  {
            DBCSChar = *String++ << 8;
            DBCSChar = DBCSChar | *String++;
            pImage = GrGetDBCSFontImage(DBCSChar);
            GrDisplayMBCSChar(pImage,DBCSWIDTH,0x00,0x00);
            BytesWritten++;
        } else {
            GrWriteSBCSChar(*String++);
        }
        BytesWritten++;
    }

    return(BytesWritten);
}


BOOLEAN
GrIsDBCSLeadByte(
    IN UCHAR c
    )

/*++

Routine Description:

    Checks to see if a char is a DBCS leadbyte.

Arguments:

    c - char to check if leadbyte or not.

Return Value:

    TRUE  - Leadbyte.
    FALSE - Non-Leadbyte.

--*/

{
    int i;

    //
    // Check to see if char is in leadbyte range.
    // Note if (CHAR)(0) is a valid leadbyte,
    // this routine will fail.
    //

    for(i=0; LeadByteTable[i]; i+=2)  {
        if((LeadByteTable[i] <= c) && (LeadByteTable[i+1] >= c)) {
            return(TRUE);
        }
    }

    return(FALSE);
}


PUCHAR
GrGetDBCSFontImage(
    USHORT Code
    )

/*++

Routine Description:

    Gets the font image for DBCS char.

Arguments:

    Code - DBCS char code.

Return Value:

    Pointer to font image, or else NULL.

--*/

{
    int Min,Max,Mid;
    int Multiplier;
    int Index;
    USHORT code;

    Min = 0;
    Max = DbcsCharCount;
    // multiplier = 2 (for index) +
    //              2 * height +
    //              2 (for unicode encoding)
    //
    Multiplier = 2 + (2*CharacterImageHeight) + 2;

    //
    // Do a binary search for the image.
    // Format of table:
    //   First 2 bytes contain the DBCS char code.
    //   Next (2 * CharacterImageHeight) bytes are the char image.
    //   Next 2 bytes are for unicode version.
    //
    while(Max >= Min)  {
        Mid = (Max + Min) / 2;
        Index = Mid*Multiplier;
        code = (DbcsImages[Index] << 8) | DbcsImages[Index+1];

        if(Code == code) {
            return(DbcsImages+Index+2);
        }

        if(Code < code) {
            Max = Mid - 1;
        } else {
            Min = Mid + 1;
        }
    }

    //
    // ERROR: No image found.
    //
    return(NULL);
}


PUCHAR
GrGetSBCSFontImage(
    UCHAR Code
    )

/*++

Routine Description:

    Gets the font image for SBCS char.

Arguments:

    Code - SBCS char code.

Return Value:

    Pointer to font image, or else NULL.

--*/

{
    int Max,Min,Mid;
    int Multiplier;
    int Index;

    Min = 0;
    Max = SbcsCharCount;
    // multiplier = 1 (for index) +
    //              height +
    //              2 (for unicode encoding)
    //
    Multiplier = 1 + (CharacterImageHeight) + 2;


    //
    // Do a binary search for the image.
    // Format of table:
    //   First byte contains the SBCS char code.
    //   Next (CharacterImageHeight) bytes are the char image.
    //   Next 2 bytes are for unicode version.
    //
    while(Max >= Min) {
        Mid = (Max + Min) / 2;
        Index = Mid*Multiplier;

        if(Code == SbcsImages[Index]) {
            return(SbcsImages+Index+1);
        }

        if(Code < SbcsImages[Index]) {
            Max = Mid - 1;
        } else {
            Min = Mid + 1;
        }
    }

    //
    // ERROR: No image found.
    //
    return(NULL);
}


//
// Need to turn off optimization for this
// routine.  Since the write and read to
// GVRAM seem useless to the compiler.
//

#pragma optimize( "", off )

VOID
TextGrSetCurrentAttribute(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Sets the attribute by setting up various VGA registers.
    The comments only say what registers are set to what, so
    to understand the logic, follow the code while looking at
    Figure 5-5 of PC&PS/2 Video Systems by Richard Wilton.
    The book is published by Microsoft Press.

Arguments:

    Attribute - New attribute to set to.
    Attribute:
        High nibble - background attribute.
        Low  nibble - foreground attribute.

Return Value:

    Nothing.

--*/

{
    UCHAR   temp = 0;

    //
    // Address of GVRAM off the screen.
    //

    PUCHAR  OffTheScreen = (PUCHAR)(0xa9600);

    union WordOrByte {
        struct Word { unsigned short    ax; } x;
        struct Byte { unsigned char     al, ah; } h;
    } regs;

    //
    // Reset Data Rotate/Function Select
    // regisger.
    //

    outpw( 0x3ce, 0x3 );        // Need to reset Data Rotate/Function Select.

    //
    // Set Enable Set/Reset to
    // all (0f).
    //

    outpw( 0x3ce, 0xf01 );

    //
    // Put background color into Set/Reset register.
    // This is done to put the background color into
    // the latches later.
    //

    regs.x.ax = (unsigned short)(Attribute & 0x0f0) << 4;
    outpw( 0x3ce, regs.x.ax );      // Put BLUE color in Set/Reset register.

    //
    // Put Set/Reset register value into GVRAM
    // off the screen.
    //

    *OffTheScreen = temp;

    //
    // Read from screen, so the latches will be
    // updated with the background color.
    //

    temp = *OffTheScreen;

    //
    // Set Data Rotate/Function Select register
    // to be XOR.
    //

    outpw( 0x3ce, 0x1803 );

    //
    // XOR the foreground and background color and
    // put it in Set/Reset register.
    //

    regs.h.ah = (Attribute >> 4) ^ (Attribute & 0x0f);
    regs.h.al = 0;
    outpw( 0x3ce, regs.x.ax );

    //
    // Put Inverse(~) of the XOR of foreground and
    // ground attribute into Enable Set/Reset register.
    //

    regs.x.ax = ~regs.x.ax & 0x0f01;
    outpw( 0x3ce, regs.x.ax );
}

//
// Turn optimization on again.
//

#pragma optimize( "", on )


VOID
TextGrPositionCursor(
    USHORT Row,
    USHORT Column
    )

/*++

Routine Description:

    Sets the position of the soft cursor. That is, it doesn't move the
    hardware cursor but sets the location of the next write to the
    screen.

Arguments:

    Row - Row coordinate of where character is to be written.

    Column - Column coordinate of where character is to be written.

Returns:

    Nothing.

--*/

{
    if(Row >= ScreenHeightCells) {
        Row = ScreenHeightCells-1;
    }

    if(Column >= ScreenWidthCells) {
        Column = ScreenWidthCells-1;
    }

    GrVp = (PUCHAR)VIDEO_BUFFER_VA + (Row * VIDEO_BYTES_PER_TEXT_ROW) + Column;
}


VOID
TextGrStringOut(
    IN PUCHAR String
    )
{
    GrWriteMBCSString(String,(unsigned)(-1));
}


PUCHAR
TextGrCharOut(
    PUCHAR pc
    )

/*++

Routine Description:

    Writes a character on the display at the current position.
    Newlines and tabs are interpreted and acted upon.

Arguments:

    pc - pointer to mbcs character to write.

Returns:

    pointer to next character

--*/

{
    return(pc + GrWriteMBCSString(pc,1));
}


VOID
TextGrFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    )

/*++

Routine Description:

    Changes the screen attribute starting at the current cursor position.
    The cursor is not moved.

Arguments:

    Attribute - Supplies the new attribute

    Length - Supplies the length of the area to change (in bytes)

Return Value:

    None.

--*/

{
    UCHAR OldAttribute;
    unsigned i;
    ULONG x,y;
    PUCHAR pImage;

    //
    // Save the current attribute and set the attribute to the
    // character desired by the caller.
    //
    TextGetCursorPosition(&x,&y);
    OldAttribute = TextCurrentAttribute;
    TextSetCurrentAttribute(Attribute);

    //
    // Dirty hack: just write spaces into the area requested by the caller.
    //
    pImage = GrGetSBCSFontImage(' ');
    for(i=0; i<Length; i++) {
        GrDisplayMBCSChar(pImage,SBCSWIDTH,0x00,0x00);
    }

    //
    // Restore the current attribute.
    //
    TextSetCurrentAttribute(OldAttribute);
    TextSetCursorPosition(x,y);
}


VOID
TextGrClearToEndOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the line
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    unsigned u;
    ULONG OldX,OldY;
    UCHAR temp;

    //
    // Fill with blanks up to char before cursor position.
    //
    temp = ' ';
    TextGetCursorPosition(&OldX,&OldY);
    for(u=TextColumn; u<ScreenWidthCells; u++) {
        TextGrCharOut(&temp);
    }
    TextSetCursorPosition(OldX,OldY);
}


VOID
TextGrClearFromStartOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the start of the line to the current cursor position
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    unsigned u;
    ULONG OldX,OldY;
    UCHAR temp = ' ';

    //
    // Fill with blanks up to char before cursor position.
    //
    TextGetCursorPosition(&OldX,&OldY);
    TextSetCursorPosition(0,OldY);
    for(u=0; u<TextColumn; u++) {
        TextGrCharOut(&temp);
    }
    TextSetCursorPosition(OldX,OldY);
}

VOID
TextGrClearToEndOfDisplay(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the video
    display by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/
{
    unsigned i;
    //
    // Clear current line
    //
    TextGrClearToEndOfLine();

    //
    // Clear the remaining lines
    //
    for(i=(TextRow+1)*VIDEO_BYTES_PER_TEXT_ROW; i<VIDEO_SIZE_BYTES; i++) {
        ((PUCHAR)VIDEO_BUFFER_VA)[i] = 0x00;
    }
}


VOID
TextGrClearDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the text-mode video display by writing blanks with
    the current video attribute over the entire display.

Arguments:

    None

Returns:

    Nothing

--*/

{
    unsigned i;

    //
    // Clear screen.
    //
    for(i=0; i<VIDEO_SIZE_BYTES; i++) {
        ((PUCHAR)VIDEO_BUFFER_VA)[i] = 0x00;
    }
}


VOID
TextGrScrollDisplay(
    VOID
    )

/*++

Routine Description:

    Scrolls the display up one line. The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    PUCHAR Source,Dest;
    unsigned n,i;
    ULONG OldX,OldY;
    UCHAR temp = ' ';

    Source = (PUCHAR)(VIDEO_BUFFER_VA) + VIDEO_BYTES_PER_TEXT_ROW;
    Dest = (PUCHAR)VIDEO_BUFFER_VA;

    n = VIDEO_BYTES_PER_TEXT_ROW * (ScreenHeightCells-1);

    for(i=0; i<n; i++) {
        *Dest++ = *Source++;
    }

    //
    // Write blanks in the bottom line, using the current attribute.
    //
    TextGetCursorPosition(&OldX,&OldY);

    TextSetCursorPosition(0,ScreenHeightCells-1);
    for(i=0; i<ScreenWidthCells; i++) {
        TextGrCharOut(&temp);
    }

    TextSetCursorPosition(OldX,OldY);
}


UCHAR GrGraphicsChars[GraphicsCharMax] = { 1,2,3,4,5,6 };

UCHAR
TextGrGetGraphicsChar(
    IN GraphicsChar WhichOne
    )
{
    return(GrGraphicsChars[WhichOne]);
}


VOID
TextGrInitialize(
    IN ULONG DiskId,
    OUT PULONG ImageLength
    )
{
    ULONG FileId;
    ARC_STATUS Status;
    PUCHAR FontImage;
    ULONG BytesRead;
    BOOTFONTBIN_HEADER FileHeader;
    LARGE_INTEGER SeekOffset;
    ULONG SbcsSize,DbcsSize;

    if (ImageLength) {
        *ImageLength = 0;
    }
    
    //
    // Attempt to open bootfont.bin. If this fails, then boot in single-byte charset mode.
    //
    if (BlBootingFromNet
#if defined(REMOTE_BOOT)
        && NetworkBootRom
#endif // defined(REMOTE_BOOT)
        ) {
        CHAR Buffer[129];
        strcpy(Buffer, NetBootPath);
        strcat(Buffer, "BOOTFONT.BIN");
        Status = BlOpen(DiskId,Buffer,ArcOpenReadOnly,&FileId);
    } else {
        Status = BlOpen(DiskId,"\\BOOTFONT.BIN",ArcOpenReadOnly,&FileId);
    }
    if(Status != ESUCCESS) {
        goto clean0;
    }

    //
    // Read in the file header and check some values.
    // We enforce the width of 8/16 here. If this is changed code all over the
    // rest of this module must also be changed.
    //
    Status = BlRead(FileId,&FileHeader,sizeof(BOOTFONTBIN_HEADER),&BytesRead);
    if((Status != ESUCCESS)
    || (BytesRead != sizeof(BOOTFONTBIN_HEADER))
    || (FileHeader.Signature != BOOTFONTBIN_SIGNATURE)
    || (FileHeader.CharacterImageSbcsWidth != 8)
    || (FileHeader.CharacterImageDbcsWidth != 16)
    ) {
        goto clean1;
    }

    //
    // Calculate the amount of memory needed to hold the sbcs and dbcs
    // character entries. Each sbcs entry is 1 byte for the ascii value
    // followed by n bytes for the image itself. We assume a width of 8 pixels.
    // For dbcs chars each entry is 2 bytes for the codepoint and n bytes
    // for the image itself. We assume a width of 16 pixels.
    //
    // Add in an extra 2 bytes per entry for the ending unicode value of the SBCS/DBCS
    // character.
    //
    // Also perform further validation on the file by comparing the sizes
    // given in the header against a size we calculate.
    //
    SbcsSize = FileHeader.NumSbcsChars * (FileHeader.CharacterImageHeight + 1 + 2);
    DbcsSize = FileHeader.NumDbcsChars * ((2 * FileHeader.CharacterImageHeight) + 2 + 2);

    if((SbcsSize != FileHeader.SbcsEntriesTotalSize)
    || (DbcsSize != FileHeader.DbcsEntriesTotalSize)) {
        goto clean1;
    }

    //
    // save off the image length argument if requested
    //
    if (ImageLength) {
        (*ImageLength) = sizeof(BOOTFONTBIN_HEADER) + SbcsSize + DbcsSize;
    }

    //
    // Allocate memory to hold the font. We use FwAllocatePool() because
    // that routine uses a separate heap that was inititialized before the
    // high-level Bl memory system was initialized, and thus is safe.
    //
    FontImage = FwAllocatePool(SbcsSize+DbcsSize);
    if(!FontImage) {
        goto clean1;
    }

    //
    // The entries get read into the base of the region we carved out.
    // The dbcs images get read in immediately after that.
    //
    SbcsImages = FontImage;
    DbcsImages = SbcsImages + FileHeader.SbcsEntriesTotalSize;

    //
    // Read in the sbcs entries.
    //
    SeekOffset.HighPart = 0;
    SeekOffset.LowPart = FileHeader.SbcsOffset;
    if((BlSeek(FileId,&SeekOffset,SeekAbsolute) != ESUCCESS)
    || (BlRead(FileId,SbcsImages,FileHeader.SbcsEntriesTotalSize,&BytesRead) != ESUCCESS)
    || (BytesRead != FileHeader.SbcsEntriesTotalSize)) {
        goto clean2;
    }

    //
    // Read in the dbcs entries.
    //
    SeekOffset.HighPart = 0;
    SeekOffset.LowPart = FileHeader.DbcsOffset;
    if((BlSeek(FileId,&SeekOffset,SeekAbsolute) != ESUCCESS)
    || (BlRead(FileId,DbcsImages,FileHeader.DbcsEntriesTotalSize,&BytesRead) != ESUCCESS)
    || (BytesRead != FileHeader.DbcsEntriesTotalSize)) {
        goto clean2;
    }

    //
    // We're done with the file now.
    //
    BlClose(FileId);

    //
    // Set up various values used for displaying the font.
    //
    DbcsLangId = FileHeader.LanguageId;
    CharacterImageHeight = FileHeader.CharacterImageHeight;
    CharacterTopPad = FileHeader.CharacterTopPad;
    CharacterBottomPad = FileHeader.CharacterBottomPad;
    CharacterCellHeight = CharacterImageHeight + CharacterTopPad + CharacterBottomPad;
    SbcsCharCount = FileHeader.NumSbcsChars;
    DbcsCharCount = FileHeader.NumDbcsChars;
    ScreenWidthCells = VIDEO_WIDTH_PIXELS / FileHeader.CharacterImageSbcsWidth;
    ScreenHeightCells = VIDEO_HEIGHT_SCAN_LINES / CharacterCellHeight;

    RtlMoveMemory(LeadByteTable,FileHeader.DbcsLeadTable,(MAX_DBCS_RANGE+1)*2);

    //
    // Switch the display into 640x480 graphics mode and clear it.
    // We're done.
    //
    HW_CURSOR(0x80000000,0x12);
    TextClearDisplay();
    return;

clean2:
    //
    // Want to free the memory we allocated but there's no routine to do it
    //
    //FwFreePool();
clean1:
    //
    // Close the font file.
    //
    BlClose(FileId);
clean0:
    return;
}


VOID
TextGrTerminate(
    VOID
    )
{
    if(DbcsLangId) {
        DbcsLangId = 0;
        //
        // This command switches the display into 80x25 text mode
        // if there is no bitmap logo displayed. The logo is common
        // to the loader and bootvid, and in this case we don't want
        // to switch to text mode and then back to graphics.
        //
        if(!GraphicsMode)
            HW_CURSOR(0x80000000,0x3);
    }
}


VOID
UTF8Encode(
    USHORT  InputValue,
    PUCHAR UTF8Encoding
    )
/*++

Routine Description:

    Generates the UTF8 translation for a 16-bit value.

Arguments:

    InputValue - 16-bit value to be encoded.
    UTF8Encoding - receives the UTF8-encoding of the 16-bit value

Return Value:

    NONE.
--*/
{

    //
    // convert into UTF8 for actual transmission
    //
    // UTF-8 encodes 2-byte Unicode characters as follows:
    // If the first nine bits are zero (00000000 0xxxxxxx), encode it as one byte 0xxxxxxx
    // If the first five bits are zero (00000yyy yyxxxxxx), encode it as two bytes 110yyyyy 10xxxxxx
    // Otherwise (zzzzyyyy yyxxxxxx), encode it as three bytes 1110zzzz 10yyyyyy 10xxxxxx
    //
    if( (InputValue & 0xFF80) == 0 ) {
        //
        // if the top 9 bits are zero, then just
        // encode as 1 byte.  (ASCII passes through unchanged).
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0xFF);
    } else if( (InputValue & 0xF700) == 0 ) {
        //
        // if the top 5 bits are zero, then encode as 2 bytes
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0x3F) | 0x80;
        UTF8Encoding[1] = (UCHAR)((InputValue >> 6) & 0x1F) | 0xC0;
    } else {
        //
        // encode as 3 bytes
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0x3F) | 0x80;
        UTF8Encoding[1] = (UCHAR)((InputValue >> 6) & 0x3F) | 0x80;
        UTF8Encoding[0] = (UCHAR)((InputValue >> 12) & 0xF) | 0xE0;
    }
}

VOID
GetDBCSUtf8Translation(
    PUCHAR InputChar,
    PUCHAR UTF8Encoding
    )
/*++

Routine Description:

    Gets the UTF8 translation for a DBCS char.

Arguments:

    InputChar - pointer to DBCS character code.
    UTF8Encoding - receives the UTF8-encoding of the DBCS character code

Return Value:

    NONE.

--*/

{
    int Min,Max,Mid;
    int Multiplier;
    int Index;
    USHORT code;
    USHORT Code;

    Code = *InputChar++ << 8;
    Code = Code | *InputChar++;


    // initialize our output.
    for( Index = 0; Index < 3; Index++ ) {
        UTF8Encoding[Index] = 0;
    }


    Min = 0;
    Max = DbcsCharCount;
    
    //
    // multiplier = 2 (for index) +
    //              2* height + 
    //              2 (for unicode encoding) 
    //
    Multiplier = 2 + (2*CharacterImageHeight) + 2;

    //
    // Do a binary search for the image.
    // Format of table:
    //   First 2 bytes contain the DBCS char code.
    //   Next (2 * CharacterImageHeight) bytes are the char image.
    //   Next 2 bytes are for unicode version.
    //
    while(Max >= Min)  {
        Mid = (Max + Min) / 2;
        Index = Mid*Multiplier;
        code = (DbcsImages[Index] << 8) | (DbcsImages[Index+1]);
    
        if(Code == code) {

            WCHAR UnicodeValue = L'\0';
            PUCHAR Image = (PUCHAR)DbcsImages+Index+2;


            //
            // image is pointing to an array of uchars, which are
            // a bitmap of the character we want to display.  Right
            // behind this array is the unicode encoding of the
            // character.  Here's what the structure looks like:
            //
            // index      bitmap                   unicode encoding of 'index'
            // ^          ^                        ^
            // |          |                        |
            // |          |                         - we previously converted 'index' into
            // |          |                           its unicode equivilent.
            // |          |
            // |           - This is where 'image' is pointing.  It's an array of characters
            // |             (2 * width in length), which represents the bitmap to be displayed
            // |             on the screen which will  represent the value in 'index'
            // |
            //  - This is either an 8-bit value (if we're messing with SBCS), or a 16-bit value 
            //    (if we're dealing with DBCS), in which case 'width' will be DBCSWIDTH.
            //
            // We're going to jump over the bitmap and retrieve the unicode encoding.  Then we'll
            // encode it into UTF8, then spew it over the headless port.
            //
            UnicodeValue = (WCHAR)( (Image[DBCSWIDTH*2]) | (Image[(DBCSWIDTH*2) + 1] << 8) );

            UTF8Encode( UnicodeValue,
                        UTF8Encoding );
            
            return;
        }

        if(Code < code) {
            Max = Mid - 1;
        } else {
            Min = Mid + 1;
        }
    }

    //
    // ERROR: No image found.
    //
    return;
}


VOID
GetSBCSUtf8Translation(
    PUCHAR InputChar,
    PUCHAR UTF8Encoding
    )

/*++

Routine Description:

    Gets the font image for SBCS char.

Arguments:

    InputChar - pointer to SBCS character code.
    UTF8Encoding - receives the UTF8-encoding of the SBCS character code

Return Value:

    NONE.

--*/

{
    int Max,Min,Mid;
    int Multiplier;
    int Index;
    UCHAR Code = *InputChar;

    
    // initialize our output.
    for( Index = 0; Index < 3; Index++ ) {
        UTF8Encoding[Index] = 0;
    }
    
    Min = 0;    
    Max = SbcsCharCount;
    
    //
    // multiplier = 1 (for index) +
    //              height + 
    //              2 (for unicode encoding) 
    //
    Multiplier = 1 + (CharacterImageHeight) + 2;

    //
    // Do a binary search for the image.
    // Format of table:
    //   First byte contain the SBCS char code.
    //   Next byte is the character code length in bytes (1 byte)
    //   After that is the UTF8 code string
    //   then the graphic char image
    //
    while(Max >= Min) {
        Mid = (Max + Min) / 2;
        Index = Mid*Multiplier;

        if(Code == SbcsImages[Index]) {
        
            WCHAR UnicodeValue = L'\0';
            PUCHAR Image = (PUCHAR)SbcsImages+Index+1;
            
            //
            // For a description of the image format, see GetDBCSUtf8Translation().
            //
            UnicodeValue = (WCHAR)( (Image[SBCSWIDTH*2]) | (Image[(SBCSWIDTH*2) + 1] << 8) );

            UTF8Encode( UnicodeValue,
                        UTF8Encoding );
            
            return;
        
        }

        if(Code < SbcsImages[Index]) {
            Max = Mid - 1;
        } else {
            Min = Mid + 1;
        }
    }

    
    //
    // ERROR: No image found.
    //
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\flop.h ===
BOOLEAN
FcIsThisFloppyCached(
    IN PUCHAR Buffer
    );

VOID
FcCacheFloppyDisk(
    PBIOS_PARAMETER_BLOCK Bpb    
    );

VOID
FcUncacheFloppyDisk(
    VOID
    );

ARC_STATUS
FcReadFromCache(
    IN  ULONG  Offset,
    IN  ULONG  Length,
    OUT PUCHAR Buffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\flopcach.c ===
#include "arccodes.h"
#include "bootx86.h"
#include "flop.h"

#ifdef FLOPPY_CACHE

//#define FLOPPY_CACHE_DEBUG
#ifdef FLOPPY_CACHE_DEBUG
#define DBGOUT(x) BlPrint x
#else
#define DBGOUT(x)
#endif


#define MAX_FLOPPY_LEN 1474560

UCHAR CachedDiskImage[MAX_FLOPPY_LEN];
UCHAR CachedDiskBadSectorMap[(MAX_FLOPPY_LEN/512)];
UCHAR CachedDiskCylinderMap[80];
USHORT CachedDiskBytesPerSector;
USHORT CachedDiskSectorsPerTrack;
USHORT CachedDiskSectorsPerCylinder;
USHORT CachedDiskBytesPerTrack;
ULONG CachedDiskLastSector;

BOOLEAN DiskInCache = FALSE;


VOID
FcpCacheOneCylinder(
    IN USHORT Cylinder
    )
{
    PUCHAR pCache;
    unsigned track,sector;
    ULONG AbsoluteSector;
    ARC_STATUS Status;
    unsigned retry;

    //
    // Calculate the location in the cache image where this cylinder should go.
    //
    AbsoluteSector = Cylinder * CachedDiskSectorsPerCylinder;
    pCache = CachedDiskImage + (AbsoluteSector * CachedDiskBytesPerSector);

    //
    // Read track 0 and 1 of this cylinder.
    //
    for(track=0; track<2; track++) {

        DBGOUT(("FcCacheFloppyDisk: Cylinder %u head %u: ",Cylinder,track));

        retry = 0;

        do {

            Status = GET_SECTOR(
                        2,                          // int13 request = read
                        0,                          // disk number (a:)
                        (USHORT)track,              // head (0 or 1)
                        Cylinder,                   // track (usually 0-79)
                        1,                          // sector number (1-based)
                        CachedDiskSectorsPerTrack,  // number of sectors to read
                        LocalBuffer                 // buffer
                        );

            if(Status) {
                retry++;
                RESET_DISK(0,0,0,0,0,0,0);
            }

        } while(Status && (retry <= 3));

        if(Status) {

            DBGOUT(("Error!\n"));

            //
            // One or more sectors in the track were bad -- read individually.
            //
            for(sector=1; sector<=CachedDiskSectorsPerTrack; sector++) {
            
                DBGOUT(("                             Sector %u: ",sector));

                retry = 0;

                do {

                    Status = GET_SECTOR(
                                2,                      // int13 request = read
                                0,                      // disk number (a:)
                                (USHORT)track,          // head (0 or 1)
                                Cylinder,               // cylinder (usually 0-79)
                                (USHORT)sector,         // sector number (1-based)
                                1,                      // number of sectors to read
                                LocalBuffer             // buffer
                                );

                    if(Status) {
                        retry++;
                        RESET_DISK(0,0,0,0,0,0,0);
                    }

                } while(Status && (retry <= 2));

                if(Status) {

                    //
                    // Sector is bad.
                    //
                    CachedDiskBadSectorMap[AbsoluteSector] = TRUE;

                    DBGOUT(("bad\n"));

                } else {

                    //
                    // Sector is good.  Transfer the data into the cache buffer.
                    //
                    RtlMoveMemory(pCache,LocalBuffer,CachedDiskBytesPerSector);

                    DBGOUT(("OK\n"));
                }

                //
                // Advance to the next sector in the cache buffer.
                //
                pCache += CachedDiskBytesPerSector;
                AbsoluteSector++;
            }

        } else {
            //
            // Transfer the whole track we just successfully read
            // into the cached disk buffer.
            //
            RtlMoveMemory(pCache,LocalBuffer,CachedDiskBytesPerTrack);
            pCache += CachedDiskBytesPerTrack;
            AbsoluteSector += CachedDiskSectorsPerTrack;

            DBGOUT(("OK\n"));
        }
    }

    CachedDiskCylinderMap[Cylinder] = TRUE;
}


BOOLEAN
FcIsThisFloppyCached(
    IN PUCHAR Buffer
    )
{
    if(!DiskInCache) {
        return(FALSE);
    }

    //
    // Compare the first 512 bytes of the cached disk
    // to the buffer passed in.  If they are equal,
    // then the disk is already cached.
    //
    if(RtlCompareMemory(CachedDiskImage,Buffer,512) == 512) {
        return(TRUE);
    }

    //
    // Disk is not cached.
    //
    return(FALSE);
}
    

VOID
FcUncacheFloppyDisk(
    VOID
    )
{
    DiskInCache = FALSE;
}


VOID
FcCacheFloppyDisk(
    PBIOS_PARAMETER_BLOCK Bpb    
    )
{
    //
    // Indicate that the cache is invalid.
    //
    DiskInCache = FALSE;

    //
    // Sanity check the bpb.
    // Ensure it's a standard 1.2 meg or 1.44 meg disk.
    //
    if((Bpb->Heads != 2) || (Bpb->BytesPerSector != 512)
    || ((Bpb->SectorsPerTrack != 15) && (Bpb->SectorsPerTrack != 18))
    || ((Bpb->Sectors != 2880) && (Bpb->Sectors != 2400)))
    {
        DBGOUT(("FcCacheFloppyDisk: floppy not standard 1.2 or 1.44 meg disk\n"));
        return;
    }

    //
    // Grab a buffer under the 1 meg line.
    // The buffer must be big enough to hold one whole track of 
    // a 1.44 meg floppy.
    //

    if(LocalBuffer == NULL) {
        LocalBuffer = FwAllocateHeap(18 * 512);
        if(LocalBuffer == NULL) {
            DBGOUT(("FcCacheFloppyDisk: Couldn't allocate local buffer\n"));
            return;
        }
    }

    DBGOUT(("FcCacheFloppyDisk: LocalBuffer @ %lx\n",LocalBuffer));

    //
    // The disk is one we can cache.  Indicate that a disk is cached
    // and mark all sectors good and all tracks not present.
    //
    DiskInCache = TRUE;
    RtlZeroMemory(CachedDiskBadSectorMap,sizeof(CachedDiskBadSectorMap));
    RtlZeroMemory(CachedDiskCylinderMap,sizeof(CachedDiskCylinderMap));
    CachedDiskSectorsPerTrack = Bpb->SectorsPerTrack;
    CachedDiskSectorsPerCylinder = Bpb->Heads * Bpb->SectorsPerTrack;
    CachedDiskBytesPerSector = Bpb->BytesPerSector;

    //
    // Calculate the number of bytes in a Track on the floppy.
    //
    CachedDiskBytesPerTrack = CachedDiskSectorsPerTrack * Bpb->BytesPerSector;

    //
    // Calculate the number of tracks.
    //
    CachedDiskLastSector = Bpb->Sectors-1;

    DBGOUT(("FcCacheFloppyDisk: Caching disk, %u sectors per track\n",CachedDiskSectorsPerTrack));

    FcpCacheOneCylinder(0);
}



ARC_STATUS
FcReadFromCache(
    IN  ULONG  Offset,
    IN  ULONG  Length,
    OUT PUCHAR Buffer
    )
{
    ULONG FirstSector,LastSector,Sector;
    ULONG FirstCyl,LastCyl,cyl;

    if(!Length) {
        return(ESUCCESS);
    }

    if(!DiskInCache) {
        return(EINVAL);
    }

    //
    // Determine the first sector in the transfer.
    //
    FirstSector = Offset / 512;

    //
    // Determine and validate the last sector in the transfer.
    //
    LastSector = FirstSector + ((Length-1)/512);

    if(LastSector > CachedDiskLastSector) {
        return(E2BIG);
    }

    //
    // Determine the first and last cylinders involved in the transfer.
    //
    FirstCyl = FirstSector / CachedDiskSectorsPerCylinder;
    LastCyl  = LastSector / CachedDiskSectorsPerCylinder;

    //
    // Make sure all these cylinders are cached.
    //
    for(cyl=FirstCyl; cyl<=LastCyl; cyl++) {
        if(!CachedDiskCylinderMap[cyl]) {
            FcpCacheOneCylinder((USHORT)cyl);
        }
    }

    //
    // Determine if any of the sectors in the transfer range 
    // are marked bad in the sector map.
    // 
    // If so, return an i/o error.
    //
    for(Sector=FirstSector; Sector<=LastSector; Sector++) {
        if(CachedDiskBadSectorMap[Sector]) {
            return(EIO);
        }
    }

    //
    // Transfer the data into the caller's buffer.
    //
    RtlMoveMemory(Buffer,CachedDiskImage+Offset,Length);

    return(ESUCCESS);
}

#endif // def FLOPPY_CACHE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\entry.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    entry.c

Abstract:

    x86-specific startup for setupldr

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

--*/
#include "bootx86.h"
#include "stdio.h"
#include "flop.h"
#include <ramdisk.h>

#if 0
#define DBGOUT(x)   BlPrint x
#define DBGPAUSE    while(!GET_KEY());
#else
#define DBGOUT(x)
#define DBGPAUSE
#endif


//
// Prototypes for Internal Routines
//

VOID
DoGlobalInitialization(
    PBOOT_CONTEXT
    );

#if defined(ELTORITO)
BOOLEAN ElToritoCDBoot = FALSE;
#endif

extern CHAR NetBootPath[];

//
// Global context pointers. These are passed to us by the SU module or
// the bootstrap code.
//

PCONFIGURATION_COMPONENT_DATA FwConfigurationTree = NULL;
PEXTERNAL_SERVICES_TABLE ExternalServicesTable;
UCHAR BootPartitionName[80];
ULONG MachineType = 0;
ULONG OsLoaderBase;
ULONG OsLoaderExports;
extern PUCHAR BlpResourceDirectory;
extern PUCHAR BlpResourceFileOffset;
ULONG PcrBasePage;
ULONG TssBasePage;

ULONG BootFlags = 0;

ULONG NtDetectStart = 0;
ULONG NtDetectEnd = 0;

#ifdef FORCE_CD_BOOT

BOOLEAN
BlGetCdRomDrive(
  PUCHAR DriveId
  )
{
  BOOLEAN Result = FALSE;
  UCHAR Id = 0;

  do {
    if (BlIsElToritoCDBoot(Id)) {
      *DriveId = Id;
      Result = TRUE;

      break;
    }

    Id++;
  }
  while (Id != 0);

  return Result;
}

#endif

VOID
NtProcessStartup(
    IN PBOOT_CONTEXT BootContextRecord
    )
/*++

Routine Description:

    Main entry point for setup loader. Control is transferred here by the
    start-up (SU) module.

Arguments:

    BootContextRecord - Supplies the boot context, particularly the
        ExternalServicesTable.

Returns:

    Does not return. Control eventually passed to the kernel.


--*/
{
    ARC_STATUS Status;

#ifdef FORCE_CD_BOOT
    BOOLEAN CdFound;
    UCHAR CdId;
#endif

    ULONG_PTR pFirmwareHeapAddress;
    ULONG TssSize,TssPages;

    //
    // Initialize the boot loader's video
    //

    DoGlobalInitialization(BootContextRecord);

    BlFillInSystemParameters(BootContextRecord);

    //
    // Set the global bootflags
    //
    BootFlags = BootContextRecord->BootFlags;

#ifdef FORCE_CD_BOOT
    CdFound = BlGetCdRomDrive(&CdId);

    if (CdFound) {
      BlPrint("CD/DVD-Rom drive found with id:%u\n", CdId);
      BootContextRecord->FSContextPointer->BootDrive = CdId;
    } else {
      BlPrint("CD/DVD-Rom drive not found");
    }
#endif  // for FORCE_CD_BOOT

    if (BootContextRecord->FSContextPointer->BootDrive == 0) {

        //
        // Boot was from A:
        //

        strcpy(BootPartitionName,"multi(0)disk(0)fdisk(0)");

        //
        // To get around an apparent bug on the BIOS of some MCA machines
        // (specifically the NCR 386sx/MC20 w/ BIOS version 1.04.00 (3421),
        // Phoenix BIOS 1.02.07), whereby the first int13 to floppy results
        // in a garbage buffer, reset drive 0 here.
        //

        GET_SECTOR(0,0,0,0,0,0,NULL);

    } else if (BootContextRecord->FSContextPointer->BootDrive == 0x40) {

        //
        // Boot was from the net
        //

        strcpy(BootPartitionName,"net(0)");
        BlBootingFromNet = TRUE;

#if defined(REMOTE_BOOT)
        BlGetActivePartition(NetBootActivePartitionName);
        NetFindCSCPartitionName();
#endif

    } else if (BootContextRecord->FSContextPointer->BootDrive == 0x41) {

        //
        // Boot was from an SDI image
        //

        strcpy(BootPartitionName,"ramdisk(0)");

    } else if (BlIsElToritoCDBoot(BootContextRecord->FSContextPointer->BootDrive)) {

        //
        // Boot was from El Torito CD
        //

        sprintf(BootPartitionName, "multi(0)disk(0)cdrom(%u)", BootContextRecord->FSContextPointer->BootDrive);
        ElToritoCDBoot = TRUE;

    } else {

        //
        // Find the partition we have been booted from.  Note that this
        // is *NOT* necessarily the active partition.  If the system has
        // Boot Mangler installed, it will be the active partition, and
        // we have to go figure out what partition we are actually on.
        //
        BlGetActivePartition(BootPartitionName);

#if defined(REMOTE_BOOT)
        strcpy(NetBootActivePartitionName, BootPartitionName);
        NetFindCSCPartitionName();
#endif

    }


    //
    // We need to make sure that we've got a signature on disk 80.
    // If not, then write one.
    //
    {
    ULONG   DriveId;
    ULONG   NewSignature;
    UCHAR SectorBuffer[4096+256];
    PUCHAR Sector;
    LARGE_INTEGER SeekValue;
    ULONG Count;
    

        Status = ArcOpen("multi(0)disk(0)rdisk(0)partition(0)", ArcOpenReadWrite, &DriveId);

        if (Status == ESUCCESS) {

            //
            // Get a reasonably unique seed to start with.
            //
            NewSignature = ArcGetRelativeTime();
            NewSignature = (NewSignature & 0xFFFF) << 16;
            NewSignature += ArcGetRelativeTime();

            //
            // Now we have a valid new signature to put on the disk.
            // Read the sector off disk, put the new signature in,
            // write the sector back, and recompute the checksum.
            //
            Sector = ALIGN_BUFFER(SectorBuffer);
            SeekValue.QuadPart = 0;
            Status = ArcSeek(DriveId, &SeekValue, SeekAbsolute);
            if (Status == ESUCCESS) {
                Status = ArcRead(DriveId,Sector,512,&Count);

                if( Status == ESUCCESS ) {
                    if( ((PULONG)Sector)[PARTITION_TABLE_OFFSET/2-1] == 0 ) {
                        //
                        // He's 0.  Write a real signature in there.
                        //

                        ((PULONG)Sector)[PARTITION_TABLE_OFFSET/2-1] = NewSignature;

                        Status = ArcSeek(DriveId, &SeekValue, SeekAbsolute);
                        if (Status == ESUCCESS) {
                            Status = ArcWrite(DriveId,Sector,512,&Count);
                            if( Status != ESUCCESS ) {
#if DBG
                                BlPrint( "Falied to write the new signature on the boot partition.\n" );
#endif
                            }
                        } else {
#if DBG
                            BlPrint( "Failed second ArcSeek on the boot partition to check for a signature.\n" );
#endif
                        }
                    }
                } else {
#if DBG
                    BlPrint( "Failed to ArcRead the boot partition to check for a signature.\n" );
#endif
                }
            } else {
#if DBG
                BlPrint( "Failed to ArcSeek the boot partition to check for a signature.\n" );
#endif
            }

            ArcClose(DriveId);
        } else {
#if DBG
            BlPrint( "Couldn't Open the boot partition to check for a signature.\n" );
#endif
        }
    }

    //
    // squirrel away some memory for the PCR and TSS so that we get the 
    // preferred memory location (<16MB) for this data.
    //
    pFirmwareHeapAddress = (ULONG_PTR)FwAllocateHeapPermanent( 2 );
    if (!pFirmwareHeapAddress) {
        BlPrint("Couldn't allocate memory for PCR\n");
        goto BootFailed;
    }
    PcrBasePage = (ULONG)(pFirmwareHeapAddress>>PAGE_SHIFT);

    TssSize = (sizeof(KTSS) + PAGE_SIZE) & ~(PAGE_SIZE - 1);
    TssPages = TssSize / PAGE_SIZE;
    pFirmwareHeapAddress = (ULONG_PTR)FwAllocateHeapPermanent( TssPages );
    if (!pFirmwareHeapAddress) {
        BlPrint("Couldn't allocate memory for TSS\n");
        goto BootFailed;
    }
    TssBasePage = (ULONG)(pFirmwareHeapAddress>>PAGE_SHIFT);

    //
    // Initialize the memory descriptor list, the OS loader heap, and the
    // OS loader parameter block.
    //
    Status = BlMemoryInitialize();
    if (Status != ESUCCESS) {
        BlPrint("Couldn't initialize memory\n");
        goto BootFailed;
    }

    //
    // Initialize the OS loader I/O system.
    //

    AEInitializeStall();

    Status = BlIoInitialize();
    if (Status != ESUCCESS) {
        BlPrint("Couldn't initialize I/O\n");
        goto BootFailed;
    }

    //
    // Call off to regular startup code
    //
    BlStartup(BootPartitionName);

    //
    // we should never get here!
    //
BootFailed:
    if (BootFlags & BOOTFLAG_REBOOT_ON_FAILURE) {
        ULONG StartTime = ArcGetRelativeTime();
        BlPrint(TEXT("\nRebooting in 5 seconds...\n"));
        while ( ArcGetRelativeTime() - StartTime < 5) {}
        ArcRestart();      
    }

    do {
        GET_KEY();  // BOOT FAILED!
        if (BlTerminalHandleLoaderFailure()) {
           ArcRestart();
        }
    } while ( 1 );

}

BOOLEAN
BlDetectHardware(
    IN ULONG DriveId,
    IN PCHAR LoadOptions
    )

/*++

Routine Description:

    Loads and runs NTDETECT.COM to populate the ARC configuration tree.

Arguments:

    DriveId - Supplies drive id where NTDETECT is located.

    LoadOptions - Supplies Load Options string to ntdetect.

Return Value:

    TRUE - NTDETECT successfully run.

    FALSE - Error

--*/

{

// Current Loader stack size is 8K, so make sure you do not
// blow that space. Make sure this is not smaller than 140.
#define LOAD_OPTIONS_BUFFER_SIZE 512

    ARC_STATUS Status;
    PCONFIGURATION_COMPONENT_DATA TempFwTree;
    ULONG TempFwHeapUsed;
    ULONG FileSize;
    ULONG DetectFileId;
    FILE_INFORMATION FileInformation;
    PUCHAR DetectionBuffer = (PUCHAR)DETECTION_LOADED_ADDRESS;
    PUCHAR Options = NULL;
    UCHAR Buffer[LOAD_OPTIONS_BUFFER_SIZE];
    LARGE_INTEGER SeekPosition;
    ULONG Read;
    BOOLEAN SkipLegacyDetection;
    BOOLEAN Success = FALSE;
    ULONG HeapStart;
    ULONG HeapSize;
    ULONG RequiredLength = 0;

    //
    // Check if the ntdetect.com was bundled as a data section
    // in the loader executable.
    //
    if (NtDetectStart == 0) {

        //
        // Now check if we have ntdetect.com in the root directory, if yes,
        // we will load it to predefined location and transfer control to
        // it.
        //

#if defined(ELTORITO)
        if (ElToritoCDBoot) {
            // we assume ntdetect.com is in the i386 directory
            Status = BlOpen( DriveId,
                             "\\i386\\ntdetect.com",
                             ArcOpenReadOnly,
                             &DetectFileId );
        } else {
#endif

        if (BlBootingFromNet
#if defined(REMOTE_BOOT)
            && NetworkBootRom
#endif // defined(REMOTE_BOOT)
            ) {
    
            strcpy(Buffer, NetBootPath);
    
#if defined(REMOTE_BOOT)
            //
            // This is the way it was done for remote BOOT, where we were
            // booting out of a client's machine directory.
            //
            strcat(Buffer, "BootDrive\\ntdetect.com");
#else
            //
            // This is how it is done for remote INSTALL, where we are
            // booting out of the templates directory under a setup directory.
            //
            strcat(Buffer, "ntdetect.com");
#endif // defined(REMOTE_BOOT)
    
            Status = BlOpen( DriveId,
                             Buffer,
                             ArcOpenReadOnly,
                             &DetectFileId );
        } else {
            Status = BlOpen( DriveId,
                             "\\ntdetect.com",
                             ArcOpenReadOnly,
                             &DetectFileId );
        }
#if defined(ELTORITO)
        }
#endif

        if (Status != ESUCCESS) {
#if DBG
            BlPrint("Error opening NTDETECT.COM, status = %x\n", Status);
            BlPrint("Press any key to continue\n");
#endif
            goto Exit;
        }
    
        //
        // Determine the length of the ntdetect.com file
        //
    
        Status = BlGetFileInformation(DetectFileId, &FileInformation);
        if (Status != ESUCCESS) {
            BlClose(DetectFileId);
#if DBG
            BlPrint("Error getting NTDETECT.COM file information, status = %x\n", Status);
            BlPrint("Press any key to continue\n");
#endif
            goto Exit;
        }
    
        FileSize = FileInformation.EndingAddress.LowPart;
        if (FileSize == 0) {
            BlClose(DetectFileId);
#if DBG
            BlPrint("Error: size of NTDETECT.COM is zero.\n");
            BlPrint("Press any key to continue\n");
#endif
            goto Exit;
        }
    
        SeekPosition.QuadPart = 0;
        Status = BlSeek(DetectFileId,
                        &SeekPosition,
                        SeekAbsolute);
        if (Status != ESUCCESS) {
            BlClose(DetectFileId);
#if DBG
            BlPrint("Error seeking to start of NTDETECT.COM file\n");
            BlPrint("Press any key to continue\n");
#endif
            goto Exit;
        }
        
        Status = BlRead( DetectFileId,
                         DetectionBuffer,
                         FileSize,
                         &Read );
    
        BlClose(DetectFileId);
        if (Status != ESUCCESS) {
#if DBG
            BlPrint("Error reading from NTDETECT.COM\n");
            BlPrint("Read %lx bytes\n",Read);
            BlPrint("Press any key to continue\n");
#endif
            goto Exit;
        }
    } else {

        // ntdetect.com was bundled in the loader image
        // as a data section. We will use it contents
        // instead of opening the file.
        RtlCopyMemory( DetectionBuffer, (PVOID)NtDetectStart, NtDetectEnd - NtDetectStart );
    }
    
    //
    // Set the heap start and size used by ntdetect
    //
    HeapStart = (TEMPORARY_HEAP_START - 0x10) * PAGE_SIZE;
    HeapSize = 0x10000; // 64K

    //
    // We need to pass NTDETECT pointers < 1Mb, so
    // use local storage off the stack if possible.  (which is
    // always < 1Mb.) If not possible (boot.ini is too big)
    // and we will add it to the heap used by ntdetect.com, thereby
    // reducing the heap space used by ntdetect.com
    //
    if ( LoadOptions ) {
        // count the characters in LoadOptions + null terminator + 
        // room for " NOLEGACY" that might be appended later
        RequiredLength = strlen(LoadOptions) + strlen(" NOLEGACY") + 1;

        // check if the buffer on the stack is big enough
        if ( RequiredLength > LOAD_OPTIONS_BUFFER_SIZE ) {
            //
            // Buffer is too small. let move it to the 
            // end of the ntdetect heap
            //
            Options = (PCHAR)( HeapStart + HeapSize - RequiredLength );
            HeapSize -= RequiredLength;

            strcpy( Options, LoadOptions );
            
        } else {
            //
            // Load options will fit on the stack. copy them there
            //
            strcpy( Buffer, LoadOptions );
            Options = Buffer;

        }
    } else {
        //
        // No load options
        //
        Options = NULL;
    }

    //
    // Check whether we need to add the NOLEGACY option
    //
    if (BlDetectLegacyFreeBios()) {
        if (Options != NULL) {
            strcat(Options, " NOLEGACY");
        } else {
            strcpy(Buffer, " NOLEGACY");
            Options = Buffer;
        }
    }
    
    DETECT_HARDWARE((ULONG)HeapStart,
                    (ULONG)HeapSize,
                    (PVOID)&TempFwTree,
                    (PULONG)&TempFwHeapUsed,
                    (PCHAR)Options,
                    (Options != NULL) ? strlen(Options) : 0
                    );

    FwConfigurationTree = TempFwTree;

    Status = BlpMarkExtendedVideoRegionOffLimits();
    
    Success = (BOOLEAN)(Status == ESUCCESS);

Exit:

    //
    // Reinitialize the headless port - detect wipes it out.
    //
    BlInitializeHeadlessPort();

    return(Success);
}


VOID
DoGlobalInitialization(
    IN PBOOT_CONTEXT BootContextRecord
    )

/*++

Routine Description

    This routine calls all of the subsytem initialization routines.


Arguments:

    None

Returns:

    Nothing

--*/

{
    ARC_STATUS Status;

    //
    // Set base address of OS Loader image for the debugger.
    //

    OsLoaderBase = BootContextRecord->OsLoaderBase;
    OsLoaderExports = BootContextRecord->OsLoaderExports;

    //
    // Initialize memory.
    //

    Status = InitializeMemorySubsystem(BootContextRecord);
    if (Status != ESUCCESS) {
        BlPrint("InitializeMemory failed %lx\n",Status);
        while (1) {
        }
    }
    ExternalServicesTable=BootContextRecord->ExternalServicesTable;
    MachineType = BootContextRecord->MachineType;

    //
    // Turn the cursor off
    //

    HW_CURSOR(0,127);

    BlpResourceDirectory = (PUCHAR)(BootContextRecord->ResourceDirectory);
    BlpResourceFileOffset = (PUCHAR)(BootContextRecord->ResourceOffset);

    NtDetectStart = BootContextRecord->NtDetectStart;
    NtDetectEnd = BootContextRecord->NtDetectEnd;

    //
    // If this is an SDI boot, copy the address of the SDI image out of the
    // boot context record. SdiAddress is declared in boot\inc\ramdisk.h and
    // initialized to 0 in boot\lib\ramdisk.c.
    //

    if (BootContextRecord->FSContextPointer->BootDrive == 0x41) {
        SdiAddress = BootContextRecord->SdiAddress;
    }

    InitializeMemoryDescriptors ();
}


VOID
BlGetActivePartition(
    OUT PUCHAR BootPartitionName
    )

/*++

Routine Description:

    Determine the ARC name for the partition NTLDR was started from

Arguments:

    BootPartitionName - Supplies a buffer where the ARC name of the
        partition will be returned.

Return Value:

    Name of the partition is in BootPartitionName.

    Must always succeed.
--*/

{
    UCHAR SectorBuffer[512];
    ARC_STATUS Status;
    ULONG FileId;
    ULONG Count;
    int i;

    //
    // The boot sector used to boot us is still in memory at 0x7c00.
    // The hidden sectors field in the BPB is pretty much guaranteed
    // to be intact, since all boot codes use that field and thus
    // are unlikely to have overwritten it.
    // We open each partition and compare the in-memory hidden sector count
    // at 0x7c1c to the hidden sector value in the BPB.
    //
    i = 1;
    do {

        sprintf(BootPartitionName,"multi(0)disk(0)rdisk(0)partition(%u)",i);

        Status = ArcOpen(BootPartitionName,ArcOpenReadOnly,&FileId);
        if(Status == ESUCCESS) {

            //
            // Read the first part of the partition.
            //
            Status = ArcRead(FileId,SectorBuffer,512,&Count);
            ArcClose(FileId);
            if((Status == ESUCCESS) && !memcmp(SectorBuffer+0x1c,(PVOID)0x7c1c,4)) {
                //
                // Found it, BootPartitionName is already set for return.
                //
                return;
            }

            Status = ESUCCESS;
        }

        i++;

    } while (Status == ESUCCESS);

    //
    // Run out of partitions without finding match. Fall back on partition 1.
    //
    strcpy(BootPartitionName,"multi(0)disk(0)rdisk(0)partition(1)");
}


BOOLEAN
BlIsElToritoCDBoot(
    UCHAR DriveNum
    )
{

    //
    // Note, even though args are short, they are pushed on the stack with
    // 32bit alignment so the effect on the stack seen by the 16bit real
    // mode code is the same as if we were pushing longs here.
    //
    // GET_ELTORITO_STATUS is 0 if we are in emulation mode

    if (DriveNum > 0x81) {
        if (!GET_ELTORITO_STATUS(FwDiskCache,DriveNum)) {
            return(TRUE);
        } else {
            return(FALSE);
        }
    } else {
        return(FALSE);
    }
}

#if defined(REMOTE_BOOT)
BOOLEAN
NetFindCSCPartitionName(
    )
{
    UCHAR FileName[80];
    UCHAR DiskName[80];
    UCHAR PartitionName[80];
    PUCHAR p;
    ULONG Part;
    ULONG FileId;
    ULONG DeviceId;

    if (NetBootSearchedForCSC) {
        return((BOOLEAN)strlen(NetBootCSCPartitionName));
    }

    if (!strlen(NetBootActivePartitionName)) {
        BlGetActivePartition(NetBootActivePartitionName);
    }

    strcpy(DiskName, NetBootActivePartitionName);
    p = strstr(DiskName, "partition");
    ASSERT( p != NULL );
    *p = '\0';

    Part = 1;
    while (TRUE) {

        sprintf(PartitionName, "%spartition(%u)", DiskName, Part);
        if (ArcOpen(PartitionName, ArcOpenReadOnly, &DeviceId) != ESUCCESS) {
            break;
        }
        ArcClose(DeviceId);

        sprintf(FileName,
                "%s%s",
                PartitionName,
                REMOTE_BOOT_IMIRROR_PATH_A REMOTE_BOOT_CSC_SUBDIR_A);

        if (ArcOpen(FileName, ArcOpenReadOnly, &FileId) == ESUCCESS) {
            ArcClose(FileId);
            NetBootSearchedForCSC = TRUE;
            strcpy(NetBootCSCPartitionName, PartitionName);
            return TRUE;
        }
        ArcClose(FileId);
        Part++;
    }

    strcpy(NetBootCSCPartitionName, NetBootActivePartitionName);
    return FALSE;
}
#endif // defined(REMOTE_BOOT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\ixfwhal.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixfwhal.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    Intel x86 specific interfaces, defines and structures.

Author:

    Jeff Havens (jhavens) 20-Jun-91


Revision History:

--*/

#ifndef _IXHALP_
#define _IXHALP_


//
// The MAXIMUM_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for devices which require phyically contigous buffers.
//

#define MAXIMUM_MAP_BUFFER_SIZE  0x1000000

//
// Define the initial buffer allocation size for a map buffers.
//

#define INITIAL_MAP_BUFFER_SIZE 0x20000

//
// Define the incremental buffer allocation for a map buffers.
//

#define INCREMENT_MAP_BUFFER_SIZE 0x10000

//
// Define the maximum number of map registers that can be requested at one time
// if actual map registers are required for the transfer.
//

#define MAXIMUM_ISA_MAP_REGISTER  16

//
// Define the maximum physical address which can be handled by an Isa card.
//

#define MAXIMUM_PHYSICAL_ADDRESS 0x01000000

//
// Define adapter object structure.
//

typedef struct _ADAPTER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    ULONG MapRegistersPerChannel;
    PVOID AdapterBaseVa;
    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;
    UCHAR ChannelNumber;
    UCHAR AdapterNumber;
    UCHAR AdapterMode;
    UCHAR ExtendedModeFlags;
    USHORT DmaPortAddress;
    BOOLEAN NeedsMapRegisters;
    BOOLEAN IsaDevice;
    BOOLEAN MasterDevice;
    BOOLEAN Width16Bits;
    BOOLEAN AdapterInUse;
    PUCHAR PagePort;
} ADAPTER_OBJECT;

//
// Define map register translation entry structure.
//

typedef struct _TRANSLATION_ENTRY {
    PVOID VirtualAddress;
    ULONG PhysicalAddress;
    ULONG Index;
} TRANSLATION_ENTRY, *PTRANSLATION_ENTRY;

//
// Define External data structures.
//

//
// Some devices require a phyicially contiguous data buffers for DMA transfers.
// Map registers are used give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//
// In this system, the map registers are translation entries which point to
// map buffers.  Map buffers are physically contiguous and have physical memory
// addresses less than 0x01000000.  All of the map registers are allocated
// initialially; however, the map buffers are allocated base in the number of
// adapters which are allocated.
//
// If the master adapter is NULL in the adapter object then device does not
// require any map registers.
//

extern PADAPTER_OBJECT MasterAdapterObject;

extern POBJECT_TYPE IoAdapterObjectType;

extern BOOLEAN LessThan16Mb;

//
// Define function prototypes.
//

BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    );

PADAPTER_OBJECT
IopAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID MapRegisterBase
    );

VOID
HalpInitializeDisplay(
    IN PUSHORT VideoBufferAddress
    );

#endif // _IXHALP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\ixbusdat.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixbusdat.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

Environment:

    Kernel mode

Revision History:


--*/

#include "bootx86.h"
#include "arc.h"
#include "ixfwhal.h"
#include "eisa.h"
#include "ntconfig.h"

ULONG
HalpGetCmosData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG
HalpGetEisaData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpGetPCIData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

/*
 *
 * Router functions.  Routes each call to specific handler
 *
 */


ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for GetBusData

--*/
{
    switch (BusDataType) {
        case Cmos:
            if (Offset != 0) {
                return 0;
            }

            return HalpGetCmosData(BusNumber, Slot, Buffer, Length);

        case EisaConfiguration:
            return HalpGetEisaData(BusNumber, Slot, Buffer, Offset, Length);

        case PCIConfiguration:
            return HalpGetPCIData(BusNumber, Slot, Buffer, Offset, Length);
    }
    return 0;
}

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for SetBusData

--*/
{
    switch (BusDataType) {
        case PCIConfiguration:
            return HalpSetPCIData(BusNumber, Slot, Buffer, Offset, Length);
    }
    return 0;
}


NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Dispatcher for AssignSlotResources

--*/
{
    switch (BusType) {
        case PCIBus:
            return HalpAssignPCISlotResources (
                        BusNumber,
                        SlotNumber,
                        AllocatedResources
                        );
        default:
            break;
    }
    return STATUS_NOT_FOUND;
}





/**
 **
 ** Standard PC bus functions
 **
 **/



BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusNumber          - Supplies the bus number.  This is ignored on
                         standard x86 systems

    BusAddress         - Supplies the bus-relative address

    AddressSpace       - Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => I/O space
                         AddressSpace == 1 => memory space

    TranslatedAddress - Pointer to a physical_address.

Return Value:

    System physical address corresponding to the supplied bus relative
    address and bus address number.

--*/

{
    TranslatedAddress->HighPart = 0;
    TranslatedAddress->LowPart = BusAddress.LowPart;
    return(TRUE);
}


ULONG
HalpGetEisaData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*--

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{

    ULONG DataLength = 0;
    ULONG i;
    ULONG TotalDataSize;
    ULONG SlotDataSize;
    ULONG PartialCount;
    ULONG Index = 0;
    PUCHAR DataBuffer = Buffer;
    PCONFIGURATION_COMPONENT_DATA ConfigData;
    PCM_EISA_SLOT_INFORMATION SlotInformation;
    PCM_PARTIAL_RESOURCE_LIST Descriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResource;
    BOOLEAN Found = FALSE;

    if (MachineType != MACHINE_TYPE_EISA) {
        return 0;
    }

    ConfigData = KeFindConfigurationEntry(
        FwConfigurationTree,
        AdapterClass,
        EisaAdapter,
        NULL
        );

    if (ConfigData == NULL) {
        DbgPrint("HalGetBusData: KeFindConfigurationEntry failed\n");
        return(0);
    }

    Descriptor = ConfigData->ConfigurationData;
    PartialResource = Descriptor->PartialDescriptors;
    PartialCount = Descriptor->Count;

    for (i = 0; i < PartialCount; i++) {

        //
        // Do each partial Resource
        //

        switch (PartialResource->Type) {
            case CmResourceTypeNull:
            case CmResourceTypePort:
            case CmResourceTypeInterrupt:
            case CmResourceTypeMemory:
            case CmResourceTypeDma:

                //
                // We dont care about these.
                //

                PartialResource++;

                break;

            case CmResourceTypeDeviceSpecific:

                //
                // Bingo!
                //

                TotalDataSize = PartialResource->u.DeviceSpecificData.DataSize;

                SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                                    ((PUCHAR)PartialResource +
                                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                while (((LONG)TotalDataSize) > 0) {

                    if (SlotInformation->ReturnCode == EISA_EMPTY_SLOT) {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION);

                    } else {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION) +
                                  SlotInformation->NumberFunctions *
                                  sizeof(CM_EISA_FUNCTION_INFORMATION);
                    }

                    if (SlotDataSize > TotalDataSize) {

                        //
                        // Something is wrong again
                        //

                        DbgPrint("HalGetBusData: SlotDataSize > TotalDataSize\n");

                        return(0);

                    }

                    if (SlotNumber != 0) {

                        SlotNumber--;

                        SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                            ((PUCHAR)SlotInformation + SlotDataSize);

                        TotalDataSize -= SlotDataSize;

                        continue;

                    }

                    //
                    // This is our slot
                    //

                    Found = TRUE;
                    break;

                }

                //
                // End loop
                //

                i = PartialCount;

                break;

            default:

#if DBG
                DbgPrint("Bad Data in registry!\n");
#endif

                return(0);

        }

    }

    if (Found) {

        //
        // As a hack if the length is zero then the buffer points to a
        // PVOID where the pointer to the data should be stored.  This is
        // done in the loader because we quickly run out of heap scaning
        // all of the EISA configuration data.
        //

        if (Length == 0) {

            //
            // Return the pointer to the mini-port driver.
            //

            *((PVOID *)Buffer) = SlotInformation;
            return(SlotDataSize);
        }

        i = Length + Offset;
        if (i > SlotDataSize) {
            i = SlotDataSize;
        }

        DataLength = i - Offset;
        RtlMoveMemory(Buffer, ((PUCHAR) SlotInformation + Offset), DataLength);
    }

    return(DataLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\input.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    input.c

Author:

    Ken Reneris Oct-2-1997

Abstract:

--*/


#include "bootx86.h"
#include "displayp.h"
#include "stdio.h"

//
// Takes any pending input and converts it into a KEY value.  Non-blocking, returning 0 if no input available.
//
ULONG
BlGetKey()
{
    ULONG Key = 0;
    UCHAR Ch;
    ULONG Count;

    if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {

        ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);

        if (Ch == ASCI_CSI_IN) {

            if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {

                ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);

                //
                // All the function keys start with ESC-O
                //
                switch (Ch) {
                case 'O':

                    ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);  // will not or block, as the buffer is already filled

                    switch (Ch) {
                    case 'P': 
                        Key = F1_KEY;
                        break;

                    case 'Q': 
                        Key = F2_KEY;
                        break;

                    case 'w': 
                        Key = F3_KEY;
                        break;

                    case 't': 
                        Key = F5_KEY;
                        break;

                    case 'u': 
                        Key = F6_KEY;
                        break;

                    case 'r': 
                        Key = F8_KEY;
                        break;

                    case 'M':
                        Key = F10_KEY;
                        break;

                    case 'A':
                        Key = F11_KEY;
                        break;

                    case 'B':
                        Key = F12_KEY;
                        break;
                    }
                    break;

                case 'A':
                    Key = UP_ARROW;
                    break;

                case 'B':
                    Key = DOWN_ARROW;
                    break;

                case 'C':
                    Key = RIGHT_KEY;
                    break;

                case 'D':
                    Key = LEFT_KEY;
                    break;

                case 'H':
                    Key = HOME_KEY;
                    break;

                case 'K':
                    Key = END_KEY;
                    break;

                case '@':
                    Key = INS_KEY;
                    break;

                case 'P':
                    Key = DEL_KEY;
                    break;
                    
                case TAB_KEY:
                    Key = BACKTAB_KEY;
                    break;

                }

            } else { // Single escape key, as no input is waiting.

                Key = ESCAPE_KEY;

            }

        } else if (Ch == 0x8) {

            Key = BKSP_KEY;

        } else {

            Key = (ULONG)Ch;

        }

    }

    return Key;
}

VOID
BlInputString(
    IN ULONG    Prompt,
    IN ULONG    CursorX,
    IN ULONG    PosY,
    IN PUCHAR   String,
    IN ULONG    MaxLength
    )
{
    PUCHAR      PromptString;
    ULONG       TextX, TextY;
    ULONG       Length, Index;
    UCHAR       CursorChar[2];
    ULONG       Key;
    PUCHAR      p;
    ULONG       i;
    ULONG       Count;

    PromptString = BlFindMessage(Prompt);
    Length = strlen(String);
    CursorChar[1] = 0;

    //
    // Print prompt
    //
    
    ARC_DISPLAY_POSITION_CURSOR(CursorX, PosY);
    ArcWrite(BlConsoleOutDeviceId, PromptString, strlen(PromptString), &Count);

    //
    // Indent cursor to right of prompt
    //

    CursorX += strlen(PromptString);
    TextX = CursorX;
    Key = 0;

    for (; ;) {

        TextY = TextX + Length;
        if (CursorX > TextY) {
            CursorX = TextY;
        }
        if (CursorX < TextX) {
            CursorX = TextX;
        }

        Index = CursorX - TextX;
        String[Length] = 0;

        //
        // Display current string
        //

        ARC_DISPLAY_POSITION_CURSOR(TextX, PosY);
        ArcWrite(BlConsoleOutDeviceId, String, strlen(String), &Count);
        ArcWrite(BlConsoleOutDeviceId, "  ", sizeof("  "), &Count);
        if (Key == 0x0d) {      // enter key?
            break ;
        }

        //
        // Display cursor
        //

        ARC_DISPLAY_POSITION_CURSOR(CursorX, PosY);
        ARC_DISPLAY_INVERSE_VIDEO();
        CursorChar[0] = String[Index] ? String[Index] : ' ';
        ArcWrite(BlConsoleOutDeviceId, CursorChar, sizeof(UCHAR), &Count);
        ARC_DISPLAY_ATTRIBUTES_OFF();
        ARC_DISPLAY_POSITION_CURSOR(CursorX, PosY);

        //
        // Get key and process it
        //
        while (!(Key = BlGetKey())) {
        }

        switch (Key) {
            case HOME_KEY:
                CursorX = TextX;
                break;

            case END_KEY:
                CursorX = TextY;
                break;

            case LEFT_KEY:
                CursorX -= 1;
                break;

            case RIGHT_KEY:
                CursorX += 1;
                break;

            case BKSP_KEY:
                if (!Index) {
                    break;
                }

                CursorX -= 1;
                String[Index-1] = CursorChar[0];
                // fallthough to DEL_KEY
            case DEL_KEY:
                if (Length) {
                    p = String+Index;
                    i = Length-Index+1;
                    while (i) {
                        p[0] = p[1];
                        p += 1;
                        i -= 1;
                    }
                    Length -= 1;
                }
                break;

            case INS_KEY:
                if (Length < MaxLength) {
                    p = String+Length;
                    i = Length-Index+1;
                    while (i) {
                        p[1] = p[0];
                        p -= 1;
                        i -= 1;
                    }
                    String[Index] = ' ';
                    Length += 1;
                }
                break;

            default:
                Key = Key & 0xff;

                if (Key >= ' '  &&  Key <= 'z') {
                    if (CursorX == TextY  &&  Length < MaxLength) {
                        Length += 1;
                    }

                    String[Index] = (UCHAR)Key;
                    String[MaxLength] = 0;
                    CursorX += 1;
                }
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\lnkconst.asm ===
.386p

_DATA segment dword use32 public 'DATA'

    extrn osloader_EXPORTS:DWORD
    extrn header:DWORD

    public _osloader_EXPORTS
    public _header

_osloader_EXPORTS DD osloader_EXPORTS
_header           DD header

_DATA ends
      end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\ixcmos.asm ===
title  "Cmos Access Routines"
;++
;
; Copyright (c) 1992 NCR Corporation
;
; Module Name:
;
;    mccmos.asm
;
; Abstract:
;
;    Procedures necessary to access CMOS/ECMOS information.
;
; Author:
;
;    David Risner (o-ncrdr) 20 Apr 1992
;
; Revision History:
;
;--

.386p
        .xlist
;include ks386.inc
;include mac386.inc
include callconv.inc
        .list

;        extrn   _HalpSystemHardwareLock:DWORD

        subttl  "HalpGetCmosData"
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; CMOS space read and write functions.
;
;--

CmosAddressPort         equ     70H
CmosDataPort            equ     71H

ECmosAddressLsbPort     equ     74H
ECmosAddressMsbPort     equ     75H
ECmosDataPort           equ     76H

;++
;
;   ULONG
;   HalpGetCmosData(
;       IN ULONG    SourceLocation
;       IN ULONG    SourceAddress
;       IN ULONG    ReturnBuffer
;       IN PUCHAR   ByteCount
;       )
;
;   This routine reads the requested number of bytes from CMOS/ECMOS and
;   stores the data read into the supplied buffer in system memory.  If
;   the requested data amount exceeds the allowable extent of the source
;   location, the return data is truncated.
;
;   Arguments:
;
;       SourceLocation  : where data is to be read from CMOS or ECMOS
;                           0 - CMOS, 1 - ECMOS
;
;       SourceAddress   : address in CMOS/ECMOS where data is to be read from
;
;       ReturnBuffer    : address in system memory for return data
;
;       ByteCount       : number of bytes to be read
;
;   Returns:
;
;       Number of byte actually read.
;
;--

SourceLocation  equ     2*4[ebp]
SourceAddress   equ     3*4[ebp]
ReturnBuffer    equ     4*4[ebp]
ByteCount       equ     5*4[ebp]

cPublicProc     _HalpGetCmosData,4

        push    ebp
        mov     ebp, esp
        push    ebx
        push    edi

    ;
    ; NOTE: The spinlock is needed even in the UP case, because
    ;    the resource is also used in an interrupt handler (profiler).
    ;    If we own the spinlock in this routine, and we service
    ;    the profiler interrupt (which will wait for the spinlock forever),
    ;    then we have a hosed system.
    ;
Hgcd01:
        cli
;        lea     eax, _HalpSystemHardwareLock
;        ACQUIRE_SPINLOCK    eax, Hgcd90

        xor     edx, edx                ; initialize return data length
        mov     ecx, ByteCount

        or      ecx, ecx                ; validate requested byte count
        jz      HalpGetCmosDataExit     ; if no work to do, exit

        mov     edx, SourceAddress
        mov     edi, ReturnBuffer

        mov     eax, SourceLocation     ; cmos or extended cmos?
        cmp     eax, 1                  
        je      ECmosReadByte
        cmp     eax, 0
        jne     HalpGetCmosDataExit

        align   4
CmosReadByte:

        cmp     edx, 0ffH               ; validate cmos source address
        ja      HalpGetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     CmosAddressPort, al
        in      al, CmosDataPort
        mov     [edi], al
        inc     edx
        inc     edi
        dec     ecx
        jnz     CmosReadByte
        jmp     SHORT HalpGetCmosDataExit

        align   4
ECmosReadByte:


        cmp     edx,0ffffH              ; validate ecmos source address
        ja      HalpGetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     ECmosAddressLsbPort, al
        mov     al, dh
        out     ECmosAddressMsbPort, al
        in      al, ECmosDataPort
        mov     [edi], al
        inc     edx
        inc     edi
        dec     ecx
        jnz     ECmosReadByte

HalpGetCmosDataExit:

;        lea     eax, _HalpSystemHardwareLock
;        RELEASE_SPINLOCK    eax
        mov     eax, edx                ; return bytes read

        pop     edi
        pop     ebx
        pop     ebp

        stdRET  _HalpGetCmosData

;Hgcd90:
;        sti
;        SPIN_ON_SPINLOCK    eax, <Hgcd01>

stdENDP _HalpGetCmosData


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\ixphwsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixphwsup.c

Abstract:

    This module contains the IopXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would normally reside in the internal.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "bootx86.h"
#include "arc.h"
#include "ixfwhal.h"
#include "eisa.h"


PADAPTER_OBJECT
IopAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber
    )

/*++

Routine Description:

    This routine allocates and initializes an adapter object to represent an
    adapter or a DMA controller on the system.  If no map registers are required
    then a standalone adapter object is allocated with no master adapter.

    If map registers are required, then a master adapter object is used to
    allocate the map registers.  For Isa systems these registers are really
    phyically contiguous memory pages.

Arguments:

    MapRegistersPerChannel - Specifies the number of map registers that each
        channel provides for I/O memory mapping.

    AdapterBaseVa - Address of the the DMA controller.

    ChannelNumber - Unused.

Return Value:

    The function value is a pointer to the allocate adapter object.

--*/

{

    PADAPTER_OBJECT AdapterObject;
    CSHORT Size;

    //
    // Determine the size of the adapter.
    //

    Size = sizeof( ADAPTER_OBJECT );

    //
    // Now create the adapter object.
    //

    AdapterObject = FwAllocateHeap(Size);

    //
    // If the adapter object was successfully created, then attempt to insert
    // it into the the object table.
    //

    if (AdapterObject) {

        RtlZeroMemory(AdapterObject, Size);

        //
        // Initialize the adapter object itself.
        //

        AdapterObject->Type = IO_TYPE_ADAPTER;
        AdapterObject->Size = Size;
        AdapterObject->MapRegistersPerChannel = 0;
        AdapterObject->AdapterBaseVa = AdapterBaseVa;
        AdapterObject->PagePort = NULL;
        AdapterObject->AdapterInUse = FALSE;

    } else {

        //
        // An error was incurred for some reason.  Set the return value
        // to NULL.
        //

        return(NULL);
    }

    return AdapterObject;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\haldtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    detecthw.c

Abstract:

    Routines for determining which drivers/HAL need to be loaded.

Author:

    John Vert (jvert) 20-Oct-1993

Revision History:

--*/
#include "haldtect.h"
#include <stdlib.h>

#ifndef ARCI386
//
// detection function prototypes
//
ULONG   DetectSystemPro(PBOOLEAN);
ULONG   DetectMPACPI(PBOOLEAN);
ULONG   DetectApicACPI(PBOOLEAN);
ULONG   DetectPicACPI(PBOOLEAN);
ULONG   DetectUPMPS(PBOOLEAN);
ULONG   DetectMPS(PBOOLEAN);
ULONG   DetectTrue(PBOOLEAN);

typedef struct _HAL_DETECT_ENTRY {
    ULONG           (*DetectFunction)(PBOOLEAN);
    PCHAR           Shortname;
} HAL_DETECT_ENTRY, *PHAL_DETECT_ENTRY;

HAL_DETECT_ENTRY DetectHal[] = {

// First check for a HAL to match some specific hardware.
    DetectMPACPI,          "acpiapic_mp",
    DetectApicACPI,        "acpiapic_up",
    DetectPicACPI,         "acpipic_up",
    DetectMPS,             "mps_mp",
    DetectUPMPS,           "mps_up",
    DetectSystemPro,       "syspro_mp", // check SystemPro last

// Use default hal for given bus type...
    DetectTrue,            "e_isa_up",

    0,       NULL,                   NULL
};


PCHAR
SlDetectHal(
    VOID
    )

/*++

Routine Description:

    Determines which HAL to load and returns the filename.

Arguments:

    None.

Return Value:

    PCHAR - pointer to the filename of the HAL to be loaded.

--*/

{
    PCONFIGURATION_COMPONENT_DATA Adapter;
    BOOLEAN IsMpMachine;
    ULONG i;
    PCHAR MachineShortname;

    //
    // Figure out machine and hal type.
    //

    for (i=0;;i++) {
        if (DetectHal[i].DetectFunction == NULL) {
            //
            // We reached the end of the list without
            // figuring it out!
            //
            SlFatalError(i);
            return(NULL);
        }

        IsMpMachine = FALSE;
        if ((DetectHal[i].DetectFunction)(&IsMpMachine) != 0) {

            //
            // Found the correct HAL.
            //

            MachineShortname = DetectHal[i].Shortname;
            break;
        }
    }

    return(MachineShortname);
}


ULONG
DetectTrue(
    OUT PBOOLEAN IsMP
)
/*++

Routine Description:

    To Return TRUE

Return Value:

    TRUE

--*/
{
    return TRUE;
}
#else   // ARCI386 path...

PVOID InfFile;
PVOID WinntSifHandle;


PCHAR
SlDetectHal(
    VOID
    )

/*++

Routine Description:

    Determines the canonical short machine name for the HAL to be loaded for
    this machine.

    It does this by enumerating the [Map.Computer] section of the INF file and
    comparing the strings there with the computer description in the ARC tree.

    [Map.Computer]
        msjazz_up   = *Jazz
        desksta1_up = "DESKTECH-ARCStation I"
        pica61_up   = "PICA-61"
        duo_mp      = *Duo

    [Map.Computer]
        DECjensen = "DEC-20Jensen"
        DECjensen = "DEC-10Jensen"

Arguments:

    None.

Return Value:

    PCHAR - pointer to canonical shortname for the machine.
    NULL - the type of machine could not be determined.

--*/

{
    PCONFIGURATION_COMPONENT_DATA Node;
    PCHAR MachineName;

    //
    // Find the system description node
    //
    Node = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                    SystemClass,
                                    ArcSystem,
                                    NULL);
    if (Node==NULL) {
        SlError(0);
        return(NULL);
    }

    MachineName = Node->ComponentEntry.Identifier;
    MachineName = (MachineName ? SlSearchSection("Map.Computer", MachineName) : NULL);
    return(MachineName);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\ixpcibus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpcidat.c

Abstract:

    Get/Set bus data routines for the PCI bus

Author:

Environment:

    Kernel mode

Revision History:


--*/

#include "bootx86.h"
#include "arc.h"
#include "ixfwhal.h"
#include "ntconfig.h"

#include "pci.h"

//extern WCHAR rgzMultiFunctionAdapter[];
//extern WCHAR rgzConfigurationData[];
//extern WCHAR rgzIdentifier[];
//extern WCHAR rgzPCIIdentifier[];

//
// Hal specific PCI bus structures
//

typedef struct tagPCIPBUSDATA {
    union {
        struct {
            PULONG      Address;
            ULONG       Data;
        } Type1;
        struct {
            PUCHAR      CSE;
            PUCHAR      Forward;
            ULONG       Base;
        } Type2;
    } Config;

} PCIPBUSDATA, *PPCIPBUSDATA;

#define PciBitIndex(Dev,Fnc)    (Fnc*32 + Dev);
#define PCI_CONFIG_TYPE(PciData)    ((PciData)->HeaderType & ~PCI_MULTIFUNCTION)

#define BUSHANDLER  _BUSHANDLER
#define PBUSHANDLER _PBUSHANDLER

// thunk for NtLdr
typedef struct {
    ULONG           NoBuses;
    ULONG           BusNumber;
    PVOID           BusData;
    PCIPBUSDATA     theBusData;
} BUSHANDLER, *PBUSHANDLER;

#define HalpPCIPin2Line(bus,rbus,slot,pcidata)
#define HalpPCILine2Pin(bus,rbus,slot,pcidata,pcidata2)
#define ExAllocatePool(a,l) FwAllocatePool(l)
// thunk for NtLdr


typedef ULONG (*FncConfigIO) (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

typedef VOID (*FncSync) (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

typedef VOID (*FncReleaseSync) (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

typedef struct {
    FncSync         Synchronize;
    FncReleaseSync  ReleaseSynchronzation;
    FncConfigIO     ConfigRead[3];
    FncConfigIO     ConfigWrite[3];
} CONFIG_HANDLER, *PCONFIG_HANDLER;


//
// Prototypes
//

ULONG
HalpGetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern ULONG
HalpGetPCIInterruptVector (
    IN PBUSHANDLER BusHandler,
    IN PBUSHANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

NTSTATUS
HalpAdjustPCIResourceList (
    IN PBUSHANDLER BusHandler,
    IN PBUSHANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

VOID
HalpInitializePciBuses (
    VOID
    );

//VOID
//HalpPCIPin2Line (
//    IN PBUSHANDLER         BusHandler,
//    IN PBUSHANDLER         RootHandler,
//    IN PCI_SLOT_NUMBER     Slot,
//    IN PPCI_COMMON_CONFIG  PciData
//    );
//
//VOID
//HalpPCILine2Pin (
//    IN PBUSHANDLER          BusHandler,
//    IN PBUSHANDLER          RootHandler,
//    IN PCI_SLOT_NUMBER      SlotNumber,
//    IN PPCI_COMMON_CONFIG   PciNewData,
//    IN PPCI_COMMON_CONFIG   PciOldData
//    );

BOOLEAN
HalpValidPCISlot (
    IN PBUSHANDLER     BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );

VOID
HalpReadPCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


VOID
HalpWritePCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

PBUSHANDLER
HalpGetPciBusHandler (
    IN ULONG BusNumber
    );

//-------------------------------------------------

VOID HalpPCISynchronizeType1 (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType1 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

VOID HalpPCISynchronizeType2 (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );


#define DISABLE_INTERRUPTS() //_asm { cli }
#define ENABLE_INTERRUPTS()  //_asm { sti }


//
// Globals
//

ULONG               PCIMaxDevice;
BUSHANDLER          PCIBusHandler;

CONFIG_HANDLER      PCIConfigHandlers = {
    HalpPCISynchronizeType1,
    HalpPCIReleaseSynchronzationType1,
    {
        HalpPCIReadUlongType1,          // 0
        HalpPCIReadUcharType1,          // 1
        HalpPCIReadUshortType1          // 2
    },
    {
        HalpPCIWriteUlongType1,         // 0
        HalpPCIWriteUcharType1,         // 1
        HalpPCIWriteUshortType1         // 2
    }
};

CONFIG_HANDLER      PCIConfigHandlersType2 = {
    HalpPCISynchronizeType2,
    HalpPCIReleaseSynchronzationType2,
    {
        HalpPCIReadUlongType2,          // 0
        HalpPCIReadUcharType2,          // 1
        HalpPCIReadUshortType2          // 2
    },
    {
        HalpPCIWriteUlongType2,         // 0
        HalpPCIWriteUcharType2,         // 1
        HalpPCIWriteUshortType2         // 2
    }
};

UCHAR PCIDeref[4][4] = { {0,1,2,2},{1,1,1,1},{2,1,2,2},{1,1,1,1} };


VOID
HalpPCIConfig (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    );


VOID
HalpInitializePciBus (
    VOID
    )
{
    PPCI_REGISTRY_INFO  PCIRegInfo;
    PPCIPBUSDATA        BusData;
    PBUSHANDLER         Bus;
    PCONFIGURATION_COMPONENT_DATA   ConfigData;
    PCM_PARTIAL_RESOURCE_LIST       Desc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    ULONG               i;
    ULONG               HwType;

    Bus = &PCIBusHandler;
    PCIBusHandler.BusData = &PCIBusHandler.theBusData;

    PCIRegInfo = NULL;      // not found
    ConfigData = NULL;      // start at begining
    do {
        ConfigData = KeFindConfigurationNextEntry (
            FwConfigurationTree,
            AdapterClass,
            MultiFunctionAdapter,
            NULL,
            &ConfigData
            );

        if (ConfigData == NULL) {
            // PCI info not found
            return ;
        }

        if (ConfigData->ComponentEntry.Identifier == NULL  ||
            _stricmp (ConfigData->ComponentEntry.Identifier, "PCI") != 0) {
            continue;
        }

        PCIRegInfo = NULL;
        Desc  = ConfigData->ConfigurationData;
        PDesc = Desc->PartialDescriptors;
        for (i = 0; i < Desc->Count; i++) {
            if (PDesc->Type == CmResourceTypeDeviceSpecific) {
                PCIRegInfo = (PPCI_REGISTRY_INFO) (PDesc+1);
                break;
            }
            PDesc++;
        }
    } while (!PCIRegInfo) ;

    //
    // PCIRegInfo describes the system's PCI support as indicated
    // by the BIOS.
    //

    HwType = PCIRegInfo->HardwareMechanism & 0xf;

    switch (HwType) {
        case 1:
            // this is the default case
            PCIMaxDevice = PCI_MAX_DEVICES;
            break;

        //
        // Type2 does not work MP, nor does the default type2
        // support more the 0xf device slots
        //

        case 2:
            RtlMoveMemory (&PCIConfigHandlers,
                           &PCIConfigHandlersType2,
                           sizeof (PCIConfigHandlersType2));
            PCIMaxDevice = 0x10;
            break;

        default:
            // unsupport type
            PCIRegInfo->NoBuses = 0;
    }

    PCIBusHandler.NoBuses = PCIRegInfo->NoBuses;
    if (PCIRegInfo->NoBuses) {

        BusData = (PPCIPBUSDATA) Bus->BusData;
        switch (HwType) {
            case 1:
                BusData->Config.Type1.Address = PCI_TYPE1_ADDR_PORT;
                BusData->Config.Type1.Data    = PCI_TYPE1_DATA_PORT;
                break;

            case 2:
                BusData->Config.Type2.CSE     = PCI_TYPE2_CSE_PORT;
                BusData->Config.Type2.Forward = PCI_TYPE2_FORWARD_PORT;
                BusData->Config.Type2.Base    = PCI_TYPE2_ADDRESS_BASE;
                break;
        }
    }
}


PBUSHANDLER
HalpGetPciBusHandler (
    IN ULONG BusNumber
    )
{
    if (PCIBusHandler.BusData == NULL) {
        HalpInitializePciBus ();
    }

    if (BusNumber > PCIBusHandler.NoBuses) {
        return NULL;
    }

    PCIBusHandler.BusNumber = BusNumber;
    return &PCIBusHandler;
}


ULONG
HalpGetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:

    BusNumber - Indicates which bus.

    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

    If this PCI slot has never been set, then the configuration information
    returned is zeroed.


--*/
{
    PBUSHANDLER         BusHandler;
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue
        // in the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested at least some data within the
        // common header.  Read the whole header, effect the
        // fields we need to and then copy the user's requested
        // bytes from the header
        //

        //
        // Read this PCI devices slot data
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            Len = 2;       // only return invalid id
        }

        //
        // Has this PCI device been configured?
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;
        HalpPCIPin2Line (BusHandler, RootHandler, Slot, PciData);

        //
        // Copy whatever data overlaps into the callers buffer
        //

        if (Len < Offset) {
            // no data at caller's buffer
            return 0;
        }

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory(Buffer, iBuffer + Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and read from it.
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long & WORD aligned.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpReadPCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

ULONG
HalpSetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:


    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{
    PBUSHANDLER         BusHandler;
    PPCI_COMMON_CONFIG  PciData, PciData2;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    UCHAR               iBuffer2[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;
    PciData2 = (PPCI_COMMON_CONFIG) iBuffer2;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue in
        // the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested to set at least some data within the
        // common header.
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);
        if (PciData->VendorID == PCI_INVALID_VENDORID  ||
            PCI_CONFIG_TYPE (PciData) != 0) {

            // no device, or header type unkown
            return 0;
        }

        //
        // Set this device as configured
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;
        //
        // Copy COMMON_HDR values to buffer2, then overlay callers changes.
        //

        RtlMoveMemory (iBuffer2, iBuffer, Len);

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory (iBuffer2+Offset, Buffer, Len);

        // in case interrupt line or pin was editted
        HalpPCILine2Pin (BusHandler, RootHandler, Slot, PciData2, PciData);

        //
        // Set new PCI configuration
        //

        HalpWritePCIConfig (BusHandler, Slot, iBuffer2+Offset, Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and write it
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long & WORD aligned.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpWritePCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

VOID
HalpReadPCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID return no data
        //

        RtlFillMemory (Buffer, Length, (UCHAR) -1);
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                   PCIConfigHandlers.ConfigRead);
}

VOID
HalpWritePCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID do nothing
        //
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                   PCIConfigHandlers.ConfigWrite);
}

BOOLEAN
HalpValidPCISlot (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
{
    PCI_SLOT_NUMBER                 Slot2;
    UCHAR                           HeaderType;
    ULONG                           i;

    if (Slot.u.bits.Reserved != 0) {
        return FALSE;
    }

    if (Slot.u.bits.DeviceNumber >= PCIMaxDevice) {
        return FALSE;
    }

    if (Slot.u.bits.FunctionNumber == 0) {
        return TRUE;
    }

    //
    // Non zero function numbers are only supported if the
    // device has the PCI_MULTIFUNCTION bit set in it's header
    //

    i = Slot.u.bits.DeviceNumber;

    //
    // Read DeviceNumber, Function zero, to determine if the
    // PCI supports multifunction devices
    //

    Slot2 = Slot;
    Slot2.u.bits.FunctionNumber = 0;

    HalpReadPCIConfig (
        BusHandler,
        Slot2,
        &HeaderType,
        FIELD_OFFSET (PCI_COMMON_CONFIG, HeaderType),
        sizeof (UCHAR)
        );

    if (!(HeaderType & PCI_MULTIFUNCTION) || HeaderType == 0xFF) {
        // this device doesn't exists or doesn't support MULTIFUNCTION types
        return FALSE;
    }

    return TRUE;
}


VOID
HalpPCIConfig (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    )
{
    KIRQL               OldIrql;
    ULONG               i;
    UCHAR               State[20];
    PPCIPBUSDATA        BusData;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    PCIConfigHandlers.Synchronize (BusHandler, Slot, &OldIrql, State);

    while (Length) {
        i = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];
        i = ConfigIO[i] (BusData, State, Buffer, Offset);

        Offset += i;
        Buffer += i;
        Length -= i;
    }

    PCIConfigHandlers.ReleaseSynchronzation (BusHandler, OldIrql);
}

VOID HalpPCISynchronizeType1 (
    IN PBUSHANDLER          BusHandler,
    IN PCI_SLOT_NUMBER      Slot,
    IN PKIRQL               Irql,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1
    )
{
    //
    // Initialize PciCfg1
    //

    PciCfg1->u.AsULONG = 0;
    PciCfg1->u.bits.BusNumber = BusHandler->BusNumber;
    PciCfg1->u.bits.DeviceNumber = Slot.u.bits.DeviceNumber;
    PciCfg1->u.bits.FunctionNumber = Slot.u.bits.FunctionNumber;
    PciCfg1->u.bits.Enable = TRUE;

    //
    // Synchronize with PCI type1 config space
    //

    //KeAcquireSpinLock (&HalpPCIConfigLock, Irql);
}

VOID HalpPCIReleaseSynchronzationType1 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    )
{
    PCI_TYPE1_CFG_BITS  PciCfg1;
    PPCIPBUSDATA        BusData;

    //
    // Disable PCI configuration space
    //

    PciCfg1.u.AsULONG = 0;
    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1.u.AsULONG);

    //
    // Release spinlock
    //

    //KeReleaseSpinLock (&HalpPCIConfigLock, Irql);
}


ULONG
HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *Buffer = READ_PORT_UCHAR ((PUCHAR) (BusData->Config.Type1.Data + i));
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PUSHORT) Buffer) = READ_PORT_USHORT ((PUSHORT) (BusData->Config.Type1.Data + i));
    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PULONG) Buffer) = READ_PORT_ULONG ((PULONG) BusData->Config.Type1.Data);
    return sizeof (ULONG);
}


ULONG
HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_UCHAR ((PUCHAR) (BusData->Config.Type1.Data + i), *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_USHORT ((PUSHORT) (BusData->Config.Type1.Data + i), *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_ULONG ((PULONG) BusData->Config.Type1.Data, *((PULONG) Buffer));
    return sizeof (ULONG);
}


VOID HalpPCISynchronizeType2 (
    IN PBUSHANDLER              BusHandler,
    IN PCI_SLOT_NUMBER          Slot,
    IN PKIRQL                   Irql,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Initialize Cfg2Addr
    //

    PciCfg2Addr->u.AsUSHORT = 0;
    PciCfg2Addr->u.bits.Agent = (USHORT) Slot.u.bits.DeviceNumber;
    PciCfg2Addr->u.bits.AddressBase = (USHORT) BusData->Config.Type2.Base;

    //
    // Synchronize with type2 config space - type2 config space
    // remaps 4K of IO space, so we can not allow other I/Os to occur
    // while using type2 config space, hence the disable_interrupts.
    //

    //KeAcquireSpinLock (&HalpPCIConfigLock, Irql);
    //DISABLE_INTERRUPTS ();                      // is not MP safe

    PciCfg2Cse.u.AsUCHAR = 0;
    PciCfg2Cse.u.bits.Enable = TRUE;
    PciCfg2Cse.u.bits.FunctionNumber = (UCHAR) Slot.u.bits.FunctionNumber;
    PciCfg2Cse.u.bits.Key = 0xff;

    //
    // Select bus & enable type 2 configuration space
    //

    WRITE_PORT_UCHAR (BusData->Config.Type2.Forward, (UCHAR) BusHandler->BusNumber);
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);
}


VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUSHANDLER          BusHandler,
    IN KIRQL                Irql
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    //
    // disable PCI configuration space
    //

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    PciCfg2Cse.u.AsUCHAR = 0;
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);

    //
    // Restore interrupts, release spinlock
    //

    //ENABLE_INTERRUPTS ();
    //KeReleaseSpinLock (&HalpPCIConfigLock, Irql);
}


ULONG
HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *Buffer = READ_PORT_UCHAR ((PUCHAR) PciCfg2Addr->u.AsUSHORT);
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *((PUSHORT) Buffer) = READ_PORT_USHORT ((PUSHORT) PciCfg2Addr->u.AsUSHORT);
    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *((PULONG) Buffer) = READ_PORT_ULONG ((PULONG) PciCfg2Addr->u.AsUSHORT);
    return sizeof(ULONG);
}


ULONG
HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_UCHAR ((PUCHAR) PciCfg2Addr->u.AsUSHORT, *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_USHORT ((PUSHORT) PciCfg2Addr->u.AsUSHORT, *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_ULONG ((PULONG) PciCfg2Addr->u.AsUSHORT, *((PULONG) Buffer));
    return sizeof(ULONG);
}

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *pAllocatedResources
    )
/*++

Routine Description:

    Reads the targeted device to determine it's required resources.
    Calls IoAssignResources to allocate them.
    Sets the targeted device with it's assigned resoruces
    and returns the assignments to the caller.

Arguments:

Return Value:

    STATUS_SUCCESS or error

--*/
{
    PBUSHANDLER                     BusHandler;
    UCHAR                           buffer[PCI_COMMON_HDR_LENGTH];
    UCHAR                           buffer2[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG              PciData, PciData2;
    PCI_SLOT_NUMBER                 PciSlot;
    ULONG                           i, j, length, type;
    PHYSICAL_ADDRESS                Address;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor;
    static PCM_RESOURCE_LIST        CmResList;
    USHORT                          NewCommand;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    *pAllocatedResources = NULL;

    PciData  = (PPCI_COMMON_CONFIG) buffer;
    PciData2 = (PPCI_COMMON_CONFIG) buffer2;
    PciSlot  = *((PPCI_SLOT_NUMBER) &Slot);
    BusNumber = BusHandler->BusNumber;

    //
    // Read the PCI device's configuration
    //

    HalpReadPCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    if (PciData->VendorID == PCI_INVALID_VENDORID) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Make a copy of the device's current settings
    //

    RtlMoveMemory (buffer2, buffer, PCI_COMMON_HDR_LENGTH);

    //
    // Set resources to all bits on to see what type of resources
    // are required.
    //

    for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
        PciData->u.type0.BaseAddresses[j] = 0xFFFFFFFF;
    }
    PciData->u.type0.ROMBaseAddress = 0xFFFFFFFF;

    NewCommand = PciData->Command;
    PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
    PciData->u.type0.ROMBaseAddress &= ~PCI_ROMADDRESS_ENABLED;
    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpReadPCIConfig  (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpPCIPin2Line (BusHandler, RootHandler, PciSlot, PciData);

    //
    // Restore the device's settings in case we don't complete
    //

    HalpWritePCIConfig (BusHandler, PciSlot, buffer2, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Build a CmResource descriptor list for the device
    //

    if (!CmResList) {
        // NtLdr pool is only allocated and never freed.  Allocate the
        // buffer once, and from then on just use the buffer over

        CmResList = ExAllocatePool (PagedPool,
            sizeof (CM_RESOURCE_LIST) +
            sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2)
            );
    }

    if (!CmResList) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (CmResList,
        sizeof (CM_RESOURCE_LIST) +
        sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2)
        );

    *pAllocatedResources = CmResList;
    CmResList->List[0].InterfaceType = PCIBus;
    CmResList->List[0].BusNumber = BusNumber;

    CmDescriptor = CmResList->List[0].PartialResourceList.PartialDescriptors;
    if (PciData->u.type0.InterruptPin) {

        CmDescriptor->Type = CmResourceTypeInterrupt;
        CmDescriptor->ShareDisposition = CmResourceShareShared;
        CmDescriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

        // in the loader interrupts aren't actually enabled, so just
        // pass back the untranslated values
        CmDescriptor->u.Interrupt.Level = PciData->u.type0.InterruptLine;
        CmDescriptor->u.Interrupt.Vector =  PciData->u.type0.InterruptLine;
        CmDescriptor->u.Interrupt.Affinity = 1;

        CmResList->List[0].PartialResourceList.Count++;
        CmDescriptor++;
    }

    // clear last address index + 1
    PciData->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] = 0;
    if (PciData2->u.type0.ROMBaseAddress & PCI_ROMADDRESS_ENABLED) {

        // put rom address in last index+1
        PciData->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] =
            PciData->u.type0.ROMBaseAddress & ~PCI_ADDRESS_IO_SPACE;

        PciData2->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] =
            PciData2->u.type0.ROMBaseAddress & ~PCI_ADDRESS_IO_SPACE;
    }

    for (j=0; j < PCI_TYPE0_ADDRESSES + 1; j++) {
        if (PciData->u.type0.BaseAddresses[j]) {
            i = PciData->u.type0.BaseAddresses[j];

            //
            // Make sure the appropriate decode is turned on for this BAR.
            //
            if (i & PCI_ADDRESS_IO_SPACE) {
                NewCommand |= PCI_ENABLE_IO_SPACE;
            } else {
                NewCommand |= PCI_ENABLE_MEMORY_SPACE;
            }

            // scan for first set bit, that's the length & alignment
            length = 1 << (i & PCI_ADDRESS_IO_SPACE ? 2 : 4);
            Address.HighPart = 0;
            Address.LowPart = PciData2->u.type0.BaseAddresses[j] & ~(length-1);
            while (!(i & length)  &&  length) {
                length <<= 1;
            }

            // translate bus specific address
            type = (i & PCI_ADDRESS_IO_SPACE) ? 0 : 1;
            if (!HalTranslateBusAddress (
                    PCIBus,
                    BusNumber,
                    Address,
                    &type,
                    &Address )) {
                // translation failed, skip it
                continue;
            }

            // fill in CmDescriptor to return
            if (type == 0) {
                CmDescriptor->Type = CmResourceTypePort;
                CmDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                CmDescriptor->Flags = CM_RESOURCE_PORT_IO;
                CmDescriptor->u.Port.Length = length;
                CmDescriptor->u.Port.Start = Address;
            } else {
                CmDescriptor->Type = CmResourceTypeMemory;
                CmDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                CmDescriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
                CmDescriptor->u.Memory.Length = length;
                CmDescriptor->u.Memory.Start = Address;

                if (j == PCI_TYPE0_ADDRESSES) {
                    // this is a ROM address
                    CmDescriptor->Flags = CM_RESOURCE_MEMORY_READ_ONLY;
                }
            }

            CmResList->List[0].PartialResourceList.Count++;
            CmDescriptor++;

            if (i & PCI_TYPE_64BIT) {
                // skip upper half of 64 bit address.
                j++;
            }
        }
    }

    //
    // If any decodes need to be turned on, do this now.
    //
    if (NewCommand != PciData2->Command) {
        HalpWritePCIConfig(BusHandler, 
                           PciSlot, 
                           &NewCommand, 
                           FIELD_OFFSET(PCI_COMMON_CONFIG, Command), 
                           sizeof(NewCommand));
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\ixhwsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "bootx86.h"
#include "arc.h"
#include "ixfwhal.h"
#include "eisa.h"
#include "ntconfig.h"

extern PHARDWARE_PTE HalPT;
PVOID HalpEisaControlBase;

//
// Define save area for ESIA adapter objects.
//

PADAPTER_OBJECT HalpEisaAdapter[8];

VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

ULONG
IoMapTransferMca(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );


VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine copies the speicific data between the user's buffer and the
    map register buffer.  First a the user buffer is mapped if necessary, then
    the data is copied.  Finally the user buffer will be unmapped if
    neccessary.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    TranslationEntry - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
        registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    None.

--*/
{
    PCCHAR bufferAddress;
    BOOLEAN mapped;

    //
    // Check to see if the buffer needs to be mapped.
    //


    if ((Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0) {

        //
        // Map the buffer into system space.
        //

        bufferAddress = MmGetMdlVirtualAddress(Mdl);
        mapped = TRUE;

    } else {

        bufferAddress = Mdl->MappedSystemVa;
        mapped = FALSE;

    }

    //
    // Calculate the actual start of the buffer based on the system VA and
    // the current VA.
    //

    bufferAddress += (PCCHAR) CurrentVa - (PCCHAR) MmGetMdlVirtualAddress(Mdl);

    //
    // Copy the data between the user buffer and map buffer
    //

    if (WriteToDevice) {

        RtlMoveMemory( TranslationEntry->VirtualAddress, bufferAddress, Length);

    } else {

        RtlMoveMemory(bufferAddress, TranslationEntry->VirtualAddress, Length);

    }

}

PADAPTER_OBJECT
HalGetAdapter(
    IN PDEVICE_DESCRIPTION DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )

/*++

Routine Description:

    This function returns the appropriate adapter object for the device defined
    in the device description structure.  This code works for Isa and Eisa
    systems.

Arguments:

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
        may be allocated by the device driver.

Return Value:

    A pointer to the requested adpater object or NULL if an adapter could not
    be created.

--*/

{
    PADAPTER_OBJECT adapterObject;
    PVOID adapterBaseVa;
    ULONG channelNumber;
    ULONG controllerNumber;
    DMA_EXTENDED_MODE extendedMode;
    UCHAR adapterMode;
    ULONG numberOfMapRegisters;
    BOOLEAN useChannel;
    ULONG maximumLength;

    //
    // Determine if the the channel number is important.  Master cards on
    // Eisa and Mca do not use a channel number.
    //

    if (DeviceDescriptor->InterfaceType != Isa &&
        DeviceDescriptor->Master) {

        useChannel = FALSE;
    } else {

        useChannel = TRUE;
    }

    //
    // Support for ISA local bus machines:
    // If the driver is a Master but really does not want a channel since it
    // is using the local bus DMA, just don't use an ISA channel.
    //

    if (DeviceDescriptor->InterfaceType == Isa &&
        DeviceDescriptor->DmaChannel > 7) {

        useChannel = FALSE;
    }

    //
    // Limit the maximum length to 2 GB this is done so that the BYTES_TO_PAGES
    // macro works correctly.
    //

    maximumLength = DeviceDescriptor->MaximumLength & 0x7fffffff;

    //
    // Channel 4 cannot be used since it is used for chaining. Return null if
    // it is requested.
    //

    if (DeviceDescriptor->DmaChannel == 4 && useChannel &&
        DeviceDescriptor->InterfaceType != MicroChannel) {
        return(NULL);
    }

    //
    // Determine the number of map registers for this device.
    //

    if (DeviceDescriptor->ScatterGather && DeviceDescriptor->InterfaceType == Eisa) {

        //
        // Since the device support scatter/Gather then map registers are not
        // required.
        //

        numberOfMapRegisters = 0;

    } else {

        //
        // Determine the number of map registers required based on the maximum
        // transfer length, up to a maximum number.
        //

        numberOfMapRegisters = BYTES_TO_PAGES(maximumLength)
            + 1;
        numberOfMapRegisters = numberOfMapRegisters > MAXIMUM_ISA_MAP_REGISTER ?
            MAXIMUM_ISA_MAP_REGISTER : numberOfMapRegisters;

    }

    //
    // Set the channel number number.
    //

    channelNumber = DeviceDescriptor->DmaChannel & 0x03;

    //
    // Set the adapter base address to the Base address register and controller
    // number.
    //

    if (!(DeviceDescriptor->DmaChannel & 0x04)) {

        controllerNumber = 1;
        adapterBaseVa = (PVOID) &((PEISA_CONTROL) HalpEisaControlBase)->Dma1BasePort;

    } else {

        controllerNumber = 2;
        adapterBaseVa = &((PEISA_CONTROL) HalpEisaControlBase)->Dma2BasePort;

    }

    //
    // Determine if a new adapter object is necessary.  If so then allocate it.
    //

    if (useChannel && HalpEisaAdapter[DeviceDescriptor->DmaChannel] != NULL) {

        adapterObject = HalpEisaAdapter[DeviceDescriptor->DmaChannel];

    } else {

        //
        // Allocate an adapter object.
        //

        adapterObject = (PADAPTER_OBJECT) IopAllocateAdapter(
            numberOfMapRegisters,
            adapterBaseVa,
            NULL
            );

        if (adapterObject == NULL) {

            return(NULL);

        }

        if (useChannel) {

            HalpEisaAdapter[DeviceDescriptor->DmaChannel] = adapterObject;

        }

        //
        // We never need map registers.
        //

        adapterObject->NeedsMapRegisters = FALSE;

        //
        // Set the maximum number of map registers for this channel bus on
        // the number requested and the type of device.
        //

        if (numberOfMapRegisters) {

            //
            // The speicified number of registers are actually allowed to be
            // allocated.
            //

            adapterObject->MapRegistersPerChannel = numberOfMapRegisters;

        } else {

            //
            // No real map registers were allocated.  If this is a master
            // device, then the device can have as may registers as it wants.
            //


            if (DeviceDescriptor->Master) {

                adapterObject->MapRegistersPerChannel = BYTES_TO_PAGES(
                    maximumLength
                    )
                    + 1;

            } else {

                //
                // The device only gets one register.  It must call
                // IoMapTransfer repeatedly to do a large transfer.
                //

                adapterObject->MapRegistersPerChannel = 1;
            }
        }
    }

    *NumberOfMapRegisters = adapterObject->MapRegistersPerChannel;

    //
    // If the channel number is not used then we are finished.  The rest of
    // the work deals with channels.
    //

    if (!useChannel) {
        return(adapterObject);
    }

    //
    // Setup the pointers to all the random registers.
    //

    adapterObject->ChannelNumber = (UCHAR) channelNumber;

    if (controllerNumber == 1) {

        switch ((UCHAR)channelNumber) {

        case 0:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel0;
            break;

        case 1:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel1;
            break;

        case 2:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel2;
            break;

        case 3:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel3;
            break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 1;

        //
        // Save the extended mode register address.
        //

        adapterBaseVa =
            &((PEISA_CONTROL) HalpEisaControlBase)->Dma1ExtendedModePort;

    } else {

        switch (channelNumber) {
        case 1:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel5;
            break;

        case 2:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel6;
            break;

        case 3:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel7;
            break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 2;

        //
        // Save the extended mode register address.
        //
        adapterBaseVa =
            &((PEISA_CONTROL) HalpEisaControlBase)->Dma2ExtendedModePort;

    }

    adapterObject->Width16Bits = FALSE;

    if (MachineType == MACHINE_TYPE_EISA) {

        //
        // Initialzie the extended mode port.
        //

        *((PUCHAR) &extendedMode) = 0;
        extendedMode.ChannelNumber = (UCHAR)channelNumber;

        switch (DeviceDescriptor->DmaSpeed) {
        case Compatible:
            extendedMode.TimingMode = COMPATIBLITY_TIMING;
            break;

        case TypeA:
            extendedMode.TimingMode = TYPE_A_TIMING;
            break;

        case TypeB:
            extendedMode.TimingMode = TYPE_B_TIMING;
            break;

        case TypeC:
            extendedMode.TimingMode = BURST_TIMING;
            break;

        default:
            return(NULL);

        }

        switch (DeviceDescriptor->DmaWidth) {
        case Width8Bits:
            extendedMode.TransferSize = BY_BYTE_8_BITS;
            break;

        case Width16Bits:
            extendedMode.TransferSize = BY_BYTE_16_BITS;

            //
            // Note Width16bits should not be set here because there is no need
            // to shift the address and the transfer count.
            //

            break;

        case Width32Bits:
            extendedMode.TransferSize = BY_BYTE_32_BITS;
            break;

        default:
            return(NULL);

        }

        WRITE_PORT_UCHAR( adapterBaseVa, *((PUCHAR) &extendedMode));

    } else if (!DeviceDescriptor->Master) {


        switch (DeviceDescriptor->DmaWidth) {
        case Width8Bits:

            //
            // The channel must use controller 1.
            //

            if (controllerNumber != 1) {
                return(NULL);
            }

            break;

        case Width16Bits:

            //
            // The channel must use controller 2.
            //

            if (controllerNumber != 2) {
                return(NULL);
            }

            adapterObject->Width16Bits = TRUE;
            break;

        default:
            return(NULL);

        }
    }


    //
    // Determine if this is an Isa adapter.
    //

    if (DeviceDescriptor->InterfaceType == Isa) {

        adapterObject->IsaDevice = TRUE;

    }

    //
    // Initialize the adapter mode register value to the correct parameters,
    // and save them in the adapter object.
    //

    adapterMode = 0;
    ((PDMA_EISA_MODE) &adapterMode)->Channel = adapterObject->ChannelNumber;

    adapterObject->MasterDevice = FALSE;

    if (DeviceDescriptor->Master) {

        adapterObject->MasterDevice = TRUE;

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = CASCADE_REQUEST_MODE;

        //
        // Set the mode, and enable the request.
        //

        if (adapterObject->AdapterNumber == 1) {

            //
            // This request is for DMA controller 1
            //

            PDMA1_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                &dmaControl->SingleMask,
                 (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                 );

        } else {

            //
            // This request is for DMA controller 1
            //

            PDMA2_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                &dmaControl->SingleMask,
                 (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                 );

        }

    } else if (DeviceDescriptor->DemandMode) {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = DEMAND_REQUEST_MODE;

    } else {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = SINGLE_REQUEST_MODE;

    }

    if (DeviceDescriptor->AutoInitialize) {

        ((PDMA_EISA_MODE) &adapterMode)->AutoInitialize = 1;

    }

    adapterObject->AdapterMode = adapterMode;

    return(adapterObject);
}

NTSTATUS
IoAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by placing the device object of the driver that wants
    to allocate the adapter on the adapter's queue.  If the queue is already
    "busy", then the adapter has already been allocated, so the device object
    is simply placed onto the queue and waits until the adapter becomes free.

    Once the adapter becomes free (or if it already is), then the driver's
    execution routine is invoked.

    Also, a number of map registers may be allocated to the driver by specifying
    a non-zero value for NumberOfMapRegisters.  If this is the case, then the
    base address of the allocated map registers in the adapter is also passed
    to the driver's execution routine.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the driver's device object that represents the
        device allocating the adapter.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/

{
    IO_ALLOCATION_ACTION action;

    //
    // Make sure the adapter if free.
    //

    if (AdapterObject->AdapterInUse) {
        DbgPrint("IoAllocateAdapterChannel: Called while adapter in use.\n");
    }

    //
    // Make sure there are enough map registers.
    //

    if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {

        DbgPrint("IoAllocateAdapterChannel:  Out of map registers.\n");
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    action = ExecutionRoutine( DeviceObject,
                               DeviceObject->CurrentIrp,
                               AdapterObject->MapRegisterBase,
                               Context );

    //
    // If the driver wishes to keep the map registers then
    // increment the current base and decrease the number of existing map
    // registers.
    //

    if (action == DeallocateObjectKeepRegisters &&
        AdapterObject->MapRegisterBase != NULL) {

        AdapterObject->MapRegistersPerChannel -= NumberOfMapRegisters;
        (PTRANSLATION_ENTRY) AdapterObject->MapRegisterBase  +=
            NumberOfMapRegisters;

    } else if (action == KeepObject) {

        AdapterObject->AdapterInUse = TRUE;

    }

    return(STATUS_SUCCESS);
}

VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified adapter object.
    Any map registers that were allocated are also automatically deallocated.
    No checks are made to ensure that the adapter is really allocated to
    a device object.  However, if it is not, then kernel will bugcheck.

    If another device is waiting in the queue to allocate the adapter object
    it will be pulled from the queue and its execution routine will be
    invoked.

Arguments:

    AdapterObject - Pointer to the adapter object to be deallocated.

Return Value:

    None.

--*/

{

    AdapterObject->AdapterInUse = FALSE;
}

PHYSICAL_ADDRESS
IoMapTransfer(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    BOOLEAN useBuffer;
    ULONG transferLength;
    ULONG logicalAddress;
    PULONG pageFrame;
    PUCHAR bytePointer;
    UCHAR adapterMode;
    UCHAR dataByte;
    PTRANSLATION_ENTRY translationEntry;
    BOOLEAN masterDevice;
    PHYSICAL_ADDRESS ReturnAddress;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
        TRUE : FALSE;

    translationEntry = MapRegisterBase;
    transferLength = *Length;

    //
    // Determine if the data transfer needs to use the map buffer.
    //

    if (translationEntry && !masterDevice &&
        ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, transferLength) > 1) {

        logicalAddress = translationEntry->PhysicalAddress;
        useBuffer = TRUE;

    } else {

        //
        // The transfer can only be done for one page.
        //



        transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
        pageFrame = (PULONG)(Mdl+1);
        pageFrame += ((ULONG) CurrentVa - (ULONG) Mdl->StartVa) / PAGE_SIZE;
        logicalAddress = (*pageFrame << PAGE_SHIFT) + BYTE_OFFSET(CurrentVa);

        //
        // If the buffer is contigous and does not cross a 64 K boundary then
        // just extend the buffer.
        //

        while( transferLength < *Length ){

            if (*pageFrame + 1 != *(pageFrame + 1) ||
                (*pageFrame & ~0x0ffff) != (*(pageFrame + 1) & ~0x0ffff)) {
                    break;
            }

            transferLength += PAGE_SIZE;
            pageFrame++;

        }


        transferLength = transferLength > *Length ? *Length : transferLength;

        useBuffer = FALSE;
    }

    //
    // Check to see if this device has any map registers allocated. If it
    // does, then it must require memory to be at less than 16 MB.  If the
    // logical address is greater than 16MB then map registers must be used
    //

    if (translationEntry && logicalAddress >= MAXIMUM_PHYSICAL_ADDRESS) {

        logicalAddress = (translationEntry + translationEntry->Index)->
            PhysicalAddress;
        useBuffer = TRUE;

    }

    //
    // Return the length.
    //

    *Length = transferLength;

    //
    // Copy the data if necessary.
    //

    if (useBuffer && WriteToDevice) {

        HalpCopyBufferMap(
            Mdl,
            translationEntry + translationEntry->Index,
            CurrentVa,
            *Length,
            WriteToDevice
            );

    }

    //
    // If there are map registers, then update the index to indicate
    // how many have been used.
    //

    if (translationEntry) {

        translationEntry->Index += ADDRESS_AND_SIZE_TO_SPAN_PAGES(
            CurrentVa,
            transferLength
            );

    }

    //
    // If no adapter was specificed then there is no more work to do so
    // return.
    //

    if (masterDevice) {

        //
        // We only support 32 bits, but the return is 64.  Just
        // zero extend
        //

        ReturnAddress.QuadPart = logicalAddress;
        return(ReturnAddress);
    }

    //
    // Determine the mode based on the transfer direction.
    //

    adapterMode = AdapterObject->AdapterMode;
    ((PDMA_EISA_MODE) &adapterMode)->TransferType = (UCHAR) (WriteToDevice ?
        WRITE_TRANSFER :  READ_TRANSFER);

    ReturnAddress.QuadPart = logicalAddress;
    bytePointer = (PUCHAR) &logicalAddress;

    if (AdapterObject->Width16Bits) {

        //
        // If this is a 16 bit transfer then adjust the length and the address
        // for the 16 bit DMA mode.
        //

        transferLength >>= 1;

        //
        // In 16 bit DMA mode the low 16 bits are shifted right one and the
        // page register value is unchanged. So save the page register value
        // and shift the logical address then restore the page value.
        //

        dataByte = bytePointer[2];
        logicalAddress >>= 1;
        bytePointer[2] = dataByte;

    }

    //
    // Determine the controller number based on the Adapter number.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[0]
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[1]
            );

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
            (ULONG)AdapterObject->PagePort,
            bytePointer[2]
            );

#if 0
        //
        // Write the high page register with zero value. This enable a special mode
        // which allows ties the page register and base count into a single 24 bit
        // address register.
        //

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
            (ULONG)AdapterObject->PagePort,
            0
            );
#endif

        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) & 0xff)
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) >> 8)
            );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
             (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
             );

    } else {

        //
        // This request is for DMA controller 2
        //

        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[0]
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[1]
            );

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
            (ULONG)AdapterObject->PagePort,
            bytePointer[2]
            );
#if 0

        //
        // Write the high page register with zero value. This enable a special mode
        // which allows ties the page register and base count into a single 24 bit
        // address register.
        //

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
            (ULONG)AdapterObject->PagePort,
            0
            );

#endif
        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) & 0xff)
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) >> 8)
            );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
             (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
             );

    }

    return(ReturnAddress);
}

BOOLEAN
IoFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine flushes the DMA adpater object buffers.  For the Jazz system
    its clears the enable flag which aborts the dma.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel.

    Mdl - A pointer to a Memory Descriptor List (MDL) that maps the locked-down
        buffer to/from which the I/O occured.

    MapRegisterBase - A pointer to the base of the map registers in the adapter
        or DMA controller.

    CurrentVa - The current virtual address in the buffer described the the Mdl
        where the I/O operation occurred.

    Length - Supplies the length of the transfer.

    WriteToDevice - Supplies a BOOLEAN value that indicates the direction of
        the data transfer was to the device.

Return Value:

    TRUE - No errors are detected so the transfer must succeed.

--*/

{
    PTRANSLATION_ENTRY translationEntry;
    PULONG pageFrame;
    ULONG transferLength;
    ULONG partialLength;
    BOOLEAN masterDevice;
    BOOLEAN mapped = FALSE;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
        TRUE : FALSE;

    translationEntry = MapRegisterBase;

    //
    // Clear the index of used buffers.
    //

    if (translationEntry) {

        translationEntry->Index = 0;
    }

    //
    // Determine if the data needs to be copied to the orginal buffer.
    // This only occurs if the data tranfer is from the device, the
    // MapReisterBase is not NULL and the transfer spans a page.
    //

    if (!WriteToDevice && translationEntry) {

        //
        // If this is not a master device, then just transfer the buffer.
        //

        if (ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, Length) > 1 &&
            !masterDevice) {

            HalpCopyBufferMap(
                Mdl,
                translationEntry,
                CurrentVa,
                Length,
                WriteToDevice
                );

        } else {

            //
            // Cycle through the pages of the transfer to determine if there
            // are any which need to be copied back.
            //

            transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
            partialLength = transferLength;
            pageFrame = (PULONG)(Mdl+1);
            pageFrame += ((ULONG) CurrentVa - (ULONG) Mdl->StartVa) / PAGE_SIZE;

            while( transferLength <= Length ){

                if (*pageFrame >= BYTES_TO_PAGES(MAXIMUM_PHYSICAL_ADDRESS)) {

                    //
                    // Check to see that the MDL is mapped in system space.
                    // If is not mapped, then map it.  This ensures that the
                    // buffer will only have to be mapped at most once per I/O.
                    //

                    if ((Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0) {

                        Mdl->MappedSystemVa = MmGetMdlVirtualAddress(Mdl);
                        Mdl->MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;
                        mapped = TRUE;

                    }

                    HalpCopyBufferMap(
                        Mdl,
                        translationEntry,
                        CurrentVa,
                        partialLength,
                        WriteToDevice
                        );

                }

                (PCCHAR) CurrentVa += partialLength;
                partialLength = PAGE_SIZE;

                //
                // Note that transferLength indicates the amount which will be
                // transfered after the next loop; thus, it is updated with the
                // new partial length.
                //

                transferLength += partialLength;
                pageFrame++;
                translationEntry++;
            }

            //
            // Process the any remaining residue.
            //

            partialLength = Length - transferLength + partialLength;
            if (partialLength && *pageFrame >= BYTES_TO_PAGES(MAXIMUM_PHYSICAL_ADDRESS)) {

                HalpCopyBufferMap(
                    Mdl,
                    translationEntry,
                    CurrentVa,
                    partialLength,
                    WriteToDevice
                    );

            }
        }

    }


    //
    // If this is a master device, then there is nothing more to do so return
    // TRUE.
    //

    if (masterDevice) {

        return(TRUE);

    }

    //
    // Mask the DMA request line so that DMA requests cannot occur.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
            );

    } else {

        //
        // This request is for DMA controller 2
        //

        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
            );

    }

    return TRUE;
}

VOID
IoFreeMapRegisters(
   PADAPTER_OBJECT AdapterObject,
   PVOID MapRegisterBase,
   ULONG NumberOfMapRegisters
   )
/*++

Routine Description:

   This routine deallocates the map registers for the adapter.  If there are
   any queued adapter waiting for an attempt is made to allocate the next
   entry.

Arguments:

   AdapterObject - The adapter object to where the map register should be
        returned.

   MapRegisterBase - The map register base of the registers to be deallocated.

   NumberOfMapRegisters - The number of registers to be deallocated.

Return Value:

   None

--+*/
{
    PTRANSLATION_ENTRY translationEntry;

    //
    // Determine if this was the last allocation from the adapter. If is was
    // then free the map registers by restoring the map register base and the
    // channel count; otherwise the registers are lost.  This handles the
    // normal case.
    //

    translationEntry = AdapterObject->MapRegisterBase;
    translationEntry -= NumberOfMapRegisters;

    if (translationEntry == MapRegisterBase) {

        //
        // The last allocated registers are being freed.
        //

        AdapterObject->MapRegisterBase = (PVOID) translationEntry;
        AdapterObject->MapRegistersPerChannel += NumberOfMapRegisters;
    }
}

PHYSICAL_ADDRESS
MmGetPhysicalAddress (
     IN PVOID BaseAddress
     )

/*++

Routine Description:

    This function returns the corresponding physical address for a
    valid virtual address.

Arguments:

    BaseAddress - Supplies the virtual address for which to return the
                  physical address.

Return Value:

    Returns the corresponding physical address.

Environment:

    Kernel mode.  Any IRQL level.

--*/

{
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG Index;

    PhysicalAddress.HighPart = 0;
    PhysicalAddress.LowPart = (ULONG)BaseAddress & ~KSEG0_BASE;

    //
    // If the address is in the hal map range, get the physical
    // addressed mapped by the pte
    //

    if (((ULONG) BaseAddress) >= 0xffc00000) {
        Index = (PhysicalAddress.LowPart >> 12) & 0x3ff;
        PhysicalAddress.LowPart = HalPT[Index].PageFrameNumber << PAGE_SHIFT;
        PhysicalAddress.LowPart |= ((ULONG)BaseAddress) & (PAGE_SIZE-1);
    }

    return(PhysicalAddress);
}

PVOID
MmAllocateNonCachedMemory (
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a range of noncached memory in
    the non-paged portion of the system address space.

    This routine is designed to be used by a driver's initialization
    routine to allocate a noncached block of virtual memory for
    various device specific buffers.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - the specified request could not be satisfied.

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated phyiscally contiguous
               memory.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

--*/

{
    PVOID BaseAddress;

    //
    // Allocated the memory.
    //

    BaseAddress = FwAllocateHeap(NumberOfBytes);
    return BaseAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\mdequ.inc ===
;----------------------------------------------------------------------------
;  MDEQU.INC - General equate file
;
;  Microsoft Confidential
;  Copyright (C) Microsoft Corporation 1992-1993
;  All Rights Reserved.
;
;  History:
;   20-Jul-92 chuckst   Initial version.
;
;  VxD History:
;   21-Apr-93 jeffpar   Adapted for MRCI.386
;----------------------------------------------------------------------------


; Define the following variable to generate the standalone
; version of DBLSPACE.BIN, which loads as a device driver under
; MS-DOS 5.0 or greater.
;
;STANDALONE	 equ	 0ffffh


; Note that the final version of DblSpace switched to 6-8-12 encoding
; which assumes the following scheme:
;
;         ccccccc10     raw char ( < 128)
;         ccccccc01     raw char ( >=128)
;          oooooo00     6-bit offset
;       oooooooo011     8-bit offset
;   oooooooooooo111    12-bit offset
;

MAX_6BIT_OFFSET equ     63
MAX_8BIT_OFFSET equ     (MAX_6BIT_OFFSET+256)
MAX_12BIT_OFFSET equ    ((MAX_8BIT_OFFSET+4096)-1)
SPECIAL_EOS     equ     4415            ;End of Sector code
.errnz  MAX_12BIT_OFFSET+1 ne SPECIAL_EOS

MAX_LENGTH_BITS equ     17
MAX_TRUE_LENGTH equ     512
MAX_RAW_LENGTH  equ     (MAX_TRUE_LENGTH-2) ; lengths are stored 2 less than true length


fatal_error_0   equ     0       ; re-entered at strat
fatal_error_1   equ     1       ; irpt without 1 strat
fatal_error_2   equ     2       ; 2 irpts per strat
fatal_error_3   equ     3       ; get_sqztor, number too low
fatal_error_4   equ     4       ; put_sqztor, number too low
fatal_error_5   equ     5       ; get_sqztor, number too high
fatal_error_6   equ     6       ; put_sqztor, number too high
fatal_error_7   equ     7       ; DOS system I/O too high
fatal_error_8   equ     8       ; DOS system I/O too low
fatal_error_9   equ     9       ; HEAP I/O too high
fatal_error_10  equ     10      ; HEAP I/O too low
fatal_error_11  equ     11      ; BITFAT I/O too high
fatal_error_12  equ     12      ; BITFAT I/O too low
fatal_error_13  equ     13      ; MDFAT I/O too high
fatal_error_14  equ     14      ; MDFAT I/O too low
fatal_error_15  equ     15      ; Bad signature check on CVF fragment list
fatal_error_16	equ	16	; Invalid int2f subfn (for forcing popup)
fatal_error_17	equ	17	; free to free sqztor
fatal_error_18	equ	18	; unfree to used sqztor

;;
;; Equates
;;

multMagicdrv    equ     4a11h   ; Int2f multiplex number

DRVMAP_CPR_BIT  equ     80h     ; bit indicating mounted CVF in drv_map array

cr              =       13
lf              =       10
tab             =       9
ctrlz           =       1ah

CVF_SEQ_SWAP    equ     0       ; Sequence number which implies SWAP
CVF_SEQ_MAX     equ     255     ; Maximum allowable sequence number

MAX_ACTIVATES   equ     24      ; 26 drive letters, less two floppies

BIG_CLUSTER     equ     8192            ;Size of BIG cluster (8K)
SMALL_CLUSTER   equ     4096            ;Size of SMALL cluster (4K)

BPTR    equ     BYTE PTR

MAX_FULL                equ     32  ;;64;Minimum of free sectors b4 we declare this disk as full
MAX_WARN                equ     256     ;Minimum free sectors to generate an 'almost full' warning

;; temp_buf_list values
ORIGINAL_DATA           equ     1       ;This sector has an original data
NEW_DATA                equ     2       ;This sector contains new data

MAX_DEMO_HIWORD_SIZE    equ     48      ;Maximum high word for demo file
MAX_SECTOR_SIZE         equ     2048    ;Maximum host sector size (2K)

IO_PART_SPACE           equ     2048    ;Page size for sqztor table
PART_CLUSTER_SIZE_POW2  equ     9       ;How many clusters per one page (DWORD per cluster)

BIT_FAT_SPACE           equ     2048    ;Page size of sec_list table (free space)
SECTORS_PER_BIT_FAT_POW2 equ    14      ;In power 2 if sectors
SECTORS_PER_BIT_FAT     equ     16384   ;Number of bits (sectors) in one page

;BPB equates
DBL_SIGN                equ     512     ;Where the 'DBL' signature can be located
RETRACT_SIGNATURE       equ     1       ; signature is last full sector, ie:
;                                       ;  end of file (rounded down to sector)
;                                       ;  minus 1

RH                      equ     ds:[bx] ;Addressability to Request Header structure

MAX_DISK_UNITS          equ     15      ;Maximumm of extended disk we can handle

cMINFILEFRAGMENTS       equ     50      ;Minimum file fragment heap size
cDEFFILEFRAGMENTS	equ	700	;Default  "      "	 "   "
cMAXFILEFRAGMENTS       equ     10000   ;Maximum  "      "       "   "

; cluster_to_Sqztor equates. See globals definition
NO_FLAGS_MASK           equ     001FH   ;Just the entry, without flags
RESERVED1_MASK          equ     0020H   ;Reserved bit just after 21-bit sector#
PHYSICAL_SIZE_MASK      equ     03C0H   ;Only the physical size bits
PHYSICAL_SIZE_OFFSET    equ     6       ;THe physical size bits offset
PLAINTEXT_MASK          equ     3C00H   ;Only the plaintext size bits
PLAINTEXT_OFFSET        equ     10      ;Plaintext size bits offset
UNCODED_CLUSTER_MASK    equ     4000H   ;Uncompress cluster bit
USED_CLUSTER_MASK       equ     8000H   ;Used cluster bit

PARA_SIZE_POW2          equ     4       ;Number of bytes in one 8088 paragraph
STACK_SIZE              equ     768     ;Size of our stack

; Device driver equates
READ_DISK_CMD           equ     4
WRITE_DISK_CMD          equ     8

STAT_WRITP              equ     8000H           ;Write protect violation
STAT_DFULL              equ     8027h           ;Disk full error
STAT_NRDY               equ     8002H           ;Device not ready
STAT_NOCOM              equ     8003H           ;Unkown command
STAT_CRC                equ     8004H           ;CRC error
STAT_SNF                equ     8008H           ;sector not found error
STAT_SEEK               equ     8006H           ;Seek error
STAT_WRITE              equ     800AH           ;Write FAULT
STAT_READ               equ     800BH           ;Read fault
STAT_GEN                equ     800CH           ;General failore

DOS        EQU  21H             ;DOS request INT
DOS_PCHR   EQU  02H             ;print character function

;Constants for compression/Decompression alg.
MAX_BITS        equ     12              ;Maximum bits (2048 entries)
TABLESIZE       equ     2048            ;Hash table size

shCHUNK         equ     9
cbCHUNK         equ     (1 shl shCHUNK) ; size of a 'chunk'
.errnz cbCHUNK ne 512
cbLONGCOPY      equ     32              ; do extra checking for string copies >= this


;Generic IOCTL return codes
NO_ERROR            equ 0               ;No error
LETTER_BOUNDRY_ERROR equ 1              ;Letter out of bounds
UNIT_USED_ERROR     equ 2               ;Unit already used
NO_FREE_SLOT_ERROR  equ 3               ;No reserved slot available
STAMP_ERROR         equ 4               ;Stamp error on extended disk


;Cluster signature
;Compressed clusters has the signature:
; 44 53 00 00   -  Cluster compressed real time
; 44 53 00 01   -  Cluster SuperCompressed offline
; 44 53 00 02   -  Cluster XCompressed real time
;
; NOTE: If you load these signature as words, they look like:
;
;   low  word = 5344h
;   high word = 0000h or 0100h

; XCMP defines a different REAL_TIME_COMPRESSED signature so a XCMP and
; non XCMP driver can be used on the same CVF and not get confused trying
; to UpdateCompress a XCMP block (XCMP does not support UpdateCompress).

SIG_SIZE                equ     4       ; 4 byte signature
STANDARD_COMPRESSED	equ  0000h	; High word of stamp
SUPER_COMPRESSED        equ  0100h      ; High word of stamp
X_COMPRESSED		equ  0200h	; High word of stamp
REAL_TIME_COMPRESSED    equ  X_COMPRESSED ; Stamp used for real-time compress

;;
;; We always keep at least 64k of extra sqztors around so a
;; file overwrite won't expand to more sqztors that are available.
;; Of course this is a raw heuristic since these should also
;; be contingous.  For more info, see dospatch.asm and
;; low_dlb.asm referenece to FUDGESTOR
FUDGESTOR       equ     128


; eXperimental compression code uses a lookup table to find past
; occurances of individual characters.	The table is currently
; 256 rows (1 for each possible byte value) X N (tracks N occurances
; of each character).

cltROWS EQU	256		; lookup table 256 rows x
cltCOLS EQU     8               ;   N columns

;
; The following basic structures were moved from MDSTRUC.INC to
; eliminate the need to include MDSTRUC.INC except where necessary;
; MDSTRUC.INC is primarily disk-management structures that are of no
; interest to MRCI.
;

;***	offst_segmt -- struc allows easy access to parts of dword pointer
;
offst_segmt	struc
offst	dw	0
segmt	dw	0
offst_segmt	ends

;***	loword_hiword -- struct allows easy access to words of dword
;
loword_hiword	struc
loword	dw	0
hiword	dw	0
loword_hiword	ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\machine.c ===
/*++

Module Name:

    machine.c

Author:

    Thomas Parslow [TomP] Feb-13-1990
    Reworked substantially in Tokyo 7-July-95 (tedm)

Abstract:

    Machine/hardware dependent routines reside within this module/file.
    (Video is in disp_tm.c and disp_gm.c.)

--*/


#include "arccodes.h"
#include "bootx86.h"

#define FLOPPY_CONTROL_REGISTER (PUCHAR)0x3f2

ARC_STATUS
XferExtendedPhysicalDiskSectors(
    IN  UCHAR     Int13UnitNumber,
    IN  ULONGLONG StartSector,
    IN  USHORT    SectorCount,
        PUCHAR    Buffer,
    IN  BOOLEAN   Write
    )

/*++

Routine Description:

    Read or write disk sectors via extended int13.

    It is assumed that the caller has ensured that the transfer buffer is
    under the 1MB line, that the sector run does not cross a 64K boundary,
    etc.

    This routine does not check whether extended int13 is actually available
    for the drive.

Arguments:

    Int13UnitNumber - supplies the int13 drive number for the drive
        to be read from/written to.

    StartSector - supplies the absolute physical sector number. This is 0-based
        relative to all sectors on the drive.

    SectorCount - supplies the number of sectors to read/write.

    Buffer - receives data read from the disk or supplies data to be written.

    Write - supplies a flag indicating whether this is a write operation.
        If FALSE, then it's a read. Otherwise it's a write.

Return Value:

    ARC status code indicating outcome.

--*/

{
    ARC_STATUS s;
    ULONG l,h;
    UCHAR Operation;

    //
    // Buffer must be under 1MB to be addressable in real mode.
    // The hardcoded 512 is wrong the CD-ROM case, but close enough.
    //
    if(((ULONG)Buffer + (SectorCount * 512)) > 0x100000) {
        return(EFAULT);
    }

    if(!SectorCount) {
        return(ESUCCESS);
    }

    l = (ULONG)StartSector;
    h = (ULONG)(StartSector >> 32);

    Operation = (UCHAR)(Write ? 0x43 : 0x42);

    //
    // Retry a couple of times if this fails.
    // We don't reset since this routine is only used on hard drives and
    // CD-ROMs, and we don't totally understand the effect of a disk reset
    // on ElTorito.
    //
    s = GET_EDDS_SECTOR(Int13UnitNumber,l,h,SectorCount,Buffer,Operation);
    if(s) {
        s = GET_EDDS_SECTOR(Int13UnitNumber,l,h,SectorCount,Buffer,Operation);
        if(s) {
            s = GET_EDDS_SECTOR(Int13UnitNumber,l,h,SectorCount,Buffer,Operation);
        }
    }

    return(s);
}


ARC_STATUS
XferPhysicalDiskSectors(
    IN  UCHAR     Int13UnitNumber,
    IN  ULONGLONG StartSector,
    IN  UCHAR     SectorCount,
    IN  PUCHAR    Buffer,
    IN  UCHAR     SectorsPerTrack,
    IN  USHORT    Heads,
    IN  USHORT    Cylinders,
    IN  BOOLEAN   AllowExtendedInt13,
    IN  BOOLEAN   Write
    )

/*++

Routine Description:

    Read or write disk sectors.

    Xfers sectors via int13. If the request starts on a cylinder
    larger than the number of cylinders reported by conventional int13, then
    extended int13 will be used if the drive supports it.

    It is assumed that the caller has ensured that the transfer buffer is
    under the 1MB line, that the sector run does not cross a 64K boundary,
    and that the sector run does not cross a track boundary. (The latter
    might not be strictly necessary, but the i/o will fail if the sector run
    starts inside the magic CHS boundary and ends past it since we won't
    switch to xint13 unless the start sector indicates that it is necessary.)

Arguments:

    Int13UnitNumber - supplies the int13 drive number for the drive
        to be read from/written to.

    StartSector - supplies the absolute physical sector number. This is 0-based
        relative to all sectors on the drive.

    SectorCount - supplies the number of sectors to read/write.

    Buffer - receives data read from the disk or supplies data to be written.

    SectorsPerTrack - supplies sectors per track (1-63) from int13 function 8
        for the drive.

    Heads - supplies number of heads (1-255) from int13 function 8 for the drive.

    Cylinders - supplies number of cylinders (1-1023) from int13 function 8
        for the drive.

    AllowExtendedInt13 - if TRUE and the start cylinder for the i/o is
        greater than the cylinder count reported by conventional int13 for
        the drive, then extended int13 will be used to do the i/o operation.

    Write - supplies a flag indicating whether this is a write operation.
        If FALSE, then it's a read. Otherwise it's a write.

Return Value:

    ARC status code indicating outcome.

--*/

{
    ULONGLONG r;
    ULONGLONG cylinder;
    USHORT head;
    UCHAR sector;
    USHORT SectorsPerCylinder;
    int retry;
    ARC_STATUS s;

    //
    // Buffer must be under 1MB to be addressable in real mode
    //
    if(((ULONG)Buffer + (SectorCount * 512)) > 0x100000) {
        return(EFAULT);
    }

    //
    // Figure out CHS values. Note that we use a ULONGLONG for the cylinder,
    // because it could overflow 1023 if the start sector is large.
    //
    SectorsPerCylinder = SectorsPerTrack * Heads;
    cylinder = (ULONG)(StartSector / SectorsPerCylinder);
    r = StartSector % SectorsPerCylinder;
    head = (USHORT)(r / SectorsPerTrack);
    sector = (UCHAR)(r % SectorsPerTrack) + 1;

    //
    // Check to see whether the cylinder is addressable via conventional int13.
    //
    if(cylinder >= Cylinders) {

        //
        // First try standard int13.
        // Some BIOSes (Thinkpad 600) misreport the disk size and ext int13.
        // So let's get this case out of the way now by trying the read anyway.
        //

        if( cylinder == Cylinders ) {
            if( cylinder <= 1023 ) {
            
                //
                // Give conventional int13 a shot.
                //
    
                s = GET_SECTOR(
                        (UCHAR)(Write ? 3 : 2),     // int13 function number
                        Int13UnitNumber,
                        head,
                        (USHORT)cylinder,           // we know it's 0-1023
                        sector,
                        SectorCount,
                        Buffer
                        );
        
                if(s) {
                    
                    //
                    // failed, fall through to ExtendedInt13
                    //
    
                } else {
    
                    // success, let's return
    
                    return(s);
                }
            }
        }

        if(AllowExtendedInt13) {

            s = XferExtendedPhysicalDiskSectors(
                    Int13UnitNumber,
                    StartSector,
                    SectorCount,
                    Buffer,
                    Write
                    );

            return(s);

        //
        // The read is beyond the geometry reported by the BIOS. If it's
        // in the first cylinder beyond that reported by the BIOS, and
        // it's below cylinder 1024, then assume that the BIOS and NT
        // just have a slight disagreement about the geometry and try
        // the read using conventional int13.
        //
        } else if((cylinder > 1023) || (cylinder > Cylinders)) {            
            return(E2BIG);
        }

        //
        // The read is in the "extra" cylinder. Fall through to conventional int13.
        //
    }

    if(!SectorCount) {
        return(ESUCCESS);
    }

    //
    // OK, xfer the sectors via conventional int13.
    //
    retry = (Int13UnitNumber < 128) ? 3 : 1;
    do {
        s = GET_SECTOR(
                (UCHAR)(Write ? 3 : 2),     // int13 function number
                Int13UnitNumber,
                head,
                (USHORT)cylinder,           // we know it's 0-1023
                sector,
                SectorCount,
                Buffer
                );

        if(s) {
            ResetDiskSystem(Int13UnitNumber);
        }
    } while(s && retry--);

    return(s);
}


VOID
ResetDiskSystem(
    UCHAR Int13UnitNumber
    )

/*++

Routine Description:

    Reset the specified drive. Generally used after an error is returned
    by the GetSector routine.

Arguments:

    Int13UnitNumber -

            0x00 - 1st floppy drive
            0x01 - 2nd floppy drive

            0x80 - 1st hard drive
            0x81 - 2nd hard drive

            etc

Returns:

    None.

--*/
{
    RESET_DISK(
        (UCHAR)((Int13UnitNumber < 128) ? 0 : 13),  // int13 function number
        Int13UnitNumber,
        0,
        0,
        0,
        0,
        NULL
        );
}


VOID
MdShutoffFloppy(
    VOID
    )

/*++

Routine Description:

    Shuts off the floppy drive motor.

Arguments:

    None

Return Value:

    None.

--*/

{
    WRITE_PORT_UCHAR(FLOPPY_CONTROL_REGISTER,0xC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\rdcomp.asm ===
IFDEF DBLSPACE_LEGAL
        page    ,130
        title   DeCompressor
;-----------------------------------------------------------------------
; Name: RDCOMP.ASM
;
; Routines defined:
;   Decompress32
;
; Description:
;   This file holds the code that is responsible for decompressing
;   the compressed data.
;
; VxD History:
;   22-Apr-93 jeffpar   Major adaptation and cleanup for MRCI32.386
;-----------------------------------------------------------------------

        .386p

        .xlist
;;        include vmm.inc
;;        include debug.inc
        include mdequ.inc
        .list

    MD_STAMP equ "SD"

;;;-----------------------------------------------------------------------
;;; Data segment
;;;-----------------------------------------------------------------------
;;
;;VxD_LOCKED_DATA_SEG
;;
;;        public  pLowerBound
;;pLowerBound     dd      0       ; if non-zero, then this is the lowest linear
;;                                ; address we treat as *our* error
;;        public  pUpperBound
;;pUpperBound     dd      0       ; if non-zero, then this is the highest linear
;;                                ; address we treat as *our* error (plus one)
;;        public  pPrevPgFltHdlr
;;pPrevPgFltHdlr  dd      0       ; if non-zero, addr of previous page fault hdlr
;;
;;VxD_LOCKED_DATA_ENDS
;;
;;
;;VxD_PAGEABLE_DATA_SEG
_DATA SEGMENT DWORD PUBLIC 'DATA'

        include decode.inc      ; include macros and tables used for decoding

        public  decode_data_end
decode_data_end label byte

;;VxD_PAGEABLE_DATA_ENDS
_DATA ENDS


;-----------------------------------------------------------------------
; Code segment
;-----------------------------------------------------------------------

;;VxD_PAGEABLE_CODE_SEG
_TEXT SEGMENT DWORD USE32 PUBLIC 'CODE'
      ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


        public  aCmdAt
aCmdAt  dd      CmdAt0,CmdAt1,CmdAt2,CmdAt3,CmdAt4,CmdAt5,CmdAt6,CmdAt7


;-----------------------------------------------------------------------
; Decompression Algorithm
; -----------------------
; Decode the next chunk of text in 'coding_buffer', into the buffer as
;  stated in the 'init'.
;
; Entry:
;   CLD
;   EBX == start of cluster (see  MRCI32IncDecompress!)
;   ECX == chunk count
;   ESI -> compressed data
;   EDI -> destination buffer
;   EDX == remaining data(low)/bits(high) from last call, 0 if none
;
; Exit:
;   If successful, CY clear and:
;   ESI == offset to next byte uncompressed data (if any)
;   EDI == offset to next free byte in dest buffer
;   EDX == remaining data(low)/bits(high) for next call, 0 if none
;
; Uses:
;   Everything except EBP
;-----------------------------------------------------------------------

;;BeginProc Decompress32
        public  Decompress32
Decompress32 proc near

        push    ebp
        push    ebp                     ; [esp] is our "chunk_count"

;;        push    ebx
        sub     ebx,MAX_12BIT_OFFSET    ;
;;        mov     [pLowerBound],ebx       ;
;;        pop     [pUpperBound]           ; fault handler enabled *now*

        mov     eax,edx                 ; remaining data to AX
        shr     edx,16                  ; move state to low word of EDX
        jnz     short @F                ; jump if continuing previous state
        lodsw                           ; new decompression, load initial data
@@:     mov     [esp],ecx               ; save chunk count

DecodeLoop:
;
;   AX has the remaining bits, DL has the next state
;
        mov     ebp,cbCHUNK             ; (ebp) is # bytes left this chunk
        DecodeRestart

        LastErrSJump equ <FirstErrSJump>
FirstErrSJump:  jmp     DecodeError     ; put first nice fat jump out of the way

irpc    c,<01234567>
        CmdAt   c
endm
        jmp     CmdAt0

irpc    c,<01234567>
        LengthAt c
endm

        DoGeneralLength                 ; generate code here to handle large lengths

DecodeDone:
;
;   AX has the remaining bits, DL has the next state -- check chunk status
;
        test    ebp,ebp                 ; perfect chunk-size decompression?
        jnz     DecodeCheckLast         ; no, check for last chunk

        dec     dword ptr [esp]         ; chunks remaining?
        jz      DecodeSuccess           ; no, so we're all done
        jmp     DecodeLoop              ; yes, process them

        public  DecodeError
DecodeError label near
        stc                             ; random decomp failure jump target
        jmp     short DecodeExit

DecodeCheckLast:
        dec     dword ptr [esp]         ; chunks remaining?
        jnz     DecodeError             ; yes, then we have an error

DecodeSuccess:
        mov     dh,1                    ; return non-0 EDX indicating state exists
        shl     edx,16                  ; move state to high word of EDX
        movzx   eax,ax                  ; make sure high word of EAX is clear
        or      edx,eax                 ; EDX == state (and carry is CLEAR)

DecodeExit:
;;        mov     [pUpperBound],0         ; fault handler disabled *now*
;;        mov     [pLowerBound],0         ;
        pop     ebp                     ; throw away our "chunk_count" at [esp]
        pop     ebp
        ret

;;EndProc Decompress32
        Decompress32 endp





;;VxD_PAGEABLE_CODE_ENDS
_TEXT ENDS

;;
;;VxD_LOCKED_CODE_SEG
;;
;;;-----------------------------------------------------------------------
;;; Decompress32_Page_Fault
;;; -----------------------
;;; Looks for VMM page faults caused by the decompressor.  The fault
;;; must have taken place in the range from [pLowerBound] to [pUpperBound]-1.
;;; If the fault IS in that range, then we set EIP to DecodeError.
;;;
;;; WARNING: this takes advantage of the fact that the decompressor does not
;;; use the stack;  otherwise, we would obviously need to record and re-set ESP
;;; to a known point as well.
;;;
;;; This is in locked code to insure that a subsequent fault doesn't destroy
;;; the information necessary to process the first (eg, CR2)!
;;;
;;; Entry:
;;;   EBX == VM handle
;;;   EBP -> VMM re-entrant stack frame
;;;
;;; Uses:
;;;   May use everything except SEG REGS
;;;-----------------------------------------------------------------------
;;
;;BeginProc Decompress32_Page_Fault
;;;
;;;   Note: the fall-through case is the common one (ie, not our page fault)
;;;
;;        push    eax
;;        mov     eax,cr2                 ; get faulting address
;;        cmp     eax,[pUpperBound]
;;        jb      short dpf_maybe         ; it might be ours
;;                                        ; otherwise, definitely not
;;dpf_prev:
;;        pop     eax                     ; we've been told to preserve everything
;;        jmp     [pPrevPgFltHdlr]        ; dispatch to real page fault handler
;;                                        ; (if we installed, then there *is* one)
;;dpf_maybe:
;;        cmp     eax,[pLowerBound]
;;        jb      short dpf_prev          ; not going to "fix" it
;;
;;        Trace_Out "Decompress32_Page_Fault: correcting fault on bad cluster"
;;
;;        mov     [ebp].Client_EIP,OFFSET32 DecodeError
;;        pop     eax
;;        ret                             ; we "fixed" it
;;
;;EndProc Decompress32_Page_Fault
;;
;;VxD_LOCKED_CODE_ENDS


;++
;
; ULONG
; DblsMrcfDecompress (
;     PUCHAR UncompressedBuffer,
;     ULONG UncompressedLength,
;     PUCHAR CompressedBuffer,
;     ULONG CompressedLength,
;     PMRCF_DECOMPRESS WorkSpace
;     )
;
; Routine Description:
;
;     This routine decompresses a buffer of StandardCompressed or MaxCompressed
;     data.
;
; Arguments:
;
;     UncompressedBuffer - buffer to receive uncompressed data
;
;     UncompressedLength - length of UncompressedBuffer
;
;           NOTE: UncompressedLength must be the EXACT length of the uncompressed
;                 data, as Decompress uses this information to detect
;                 when decompression is complete.  If this value is
;                 incorrect, Decompress may crash!
; 
;     CompressedBuffer - buffer containing compressed data
;
;     CompressedLength - length of CompressedBuffer
;
;     WorkSpace - pointer to a private work area for use by this operation
; 
; Return Value:
;
;     ULONG - Returns the size of the decompressed data in bytes. Returns 0 if
;         there was an error in the decompress.
;--

_TEXT SEGMENT DWORD USE32 PUBLIC 'CODE'
      ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        public  _DblsMrcfDecompress@20
_DblsMrcfDecompress@20 proc near

        push    esi
        push    edi
        push    ebx

        mov     ecx,dword ptr [esp+20]
        mov     edx,ecx
        shr     ecx,9
        and     edx,512-1    
        jz      @f
        inc     ecx
        sub     edx,edx
@@:     mov     esi,dword ptr [esp+24]
        mov     edi,dword ptr [esp+16]
        mov     ebx,edi

        cld
        lodsd
        cmp     ax,MD_STAMP
        je      @f
        sub     eax,eax
        jz      done

@@:     call    Decompress32
        jnc     @f
        sub     eax,eax
        jz      done    

@@:     sub     edi,dword ptr [esp+16]
        mov     eax,edi

done:
        pop     ebx
        pop     edi
        pop     esi

        ret     20

_DblsMrcfDecompress@20 endp

_TEXT ENDS
        ENDIF   ; DEF DBLSPACE_LEGAL
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\memory.c ===
/*++


Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    memory.c

Abstract:

    This module sets up paging so that the first 1Mb of virtual memory is
    directly mapped to the first 1Mb of physical memory.  This allows the
    BIOS callbacks to work, and the osloader to continue running below
    1Mb.  It also maps up to the first 16MB of physical memory to KSEG0_BASE
    and ALTERNATE_BASE, so the osloader can load kernel code into kernel
    space, and allocate kernel parameters in kernel space. This allows the
    dynamic configuration of the system for either a 2gb or 3gb user space
    address range.

Note!!
    3/16/00 (mikeg):
        All I/O (BlRead etc.) use a buffer below 1MB to do transfers so we
        don't need to worry about ISA cards DMA buffers. This change allows
        setupldr to run with all files compressed.
        If you need to change this, also change BASE_LOADER_IMAGE in bootx86.h 
        or the PDE will not be completely unmapped. This must ALSO match 
        ntos\mm\i386\mi386.h (BOOT_IMAGE_SIZE) so we know where
        to start loading images.



Memory Map used by NTLDR:

    000000 - 000fff         RM IDT & Bios Data Area

    007C00 - 007fff         BPB loaded by Bootstrap

    010000 - 01ffff         Loadable miniport drivers, free memory

    020000 - 02ffff         SU + real-mode stack

    030000 - 039000         BIOS disk cache

    039000 - 039000         Permanent heap (GDT, IDT, TSS, Page Dir, Page Tables)
                            (grows up)
                                |
                                v

                                ^
                                |
                            (grows down)
    039000 - 05ffff         Temporary heap

    060000 - 062000         osloader stack (grows down)

    062000 - 09ffff         osloader heap (grows down)

    0b8000 - 0bbfff         Video Buffer

    0d0000 - 0fffff         Bios and Adaptor ROM area

Author:

    John Vert (jvert) 18-Jun-1991

Environment:

    Kernel Mode


Revision History:


--*/

#include "arccodes.h"
#include "bootx86.h"

//
// 1-megabyte boundary line (in pages)
//

#define _1MB ((ULONG)0x100000 >> PAGE_SHIFT)

//
// 4-gigabyte boundary line (in pages)
//

#define _4G (1 << (32 - PAGE_SHIFT))

//
// Bogus memory line.  (We don't ever want to use the memory that is in
// the 0x40 pages just under the 16Mb line.)
//

#define _16MB_BOGUS (((ULONG)0x1000000-0x40*PAGE_SIZE) >> PAGE_SHIFT)

#define ROM_START_PAGE (0x0A0000 >> PAGE_SHIFT)
#define ROM_END_PAGE   (0x100000 >> PAGE_SHIFT)

//
// Buffer for temporary storage of data read from the disk that needs
// to end up in a location above the 1MB boundary.
//
// NOTE: it is very important that this buffer not cross a 64k boundary.
//
PUCHAR FwDiskCache = (PUCHAR)(BIOS_DISK_CACHE_START * PAGE_SIZE);

//
// Current heap start pointers (physical addresses)
// Note that 0x50000 to 0x5ffff is reserved for detection configuration memory
//
ULONG FwPermanentHeap = PERMANENT_HEAP_START * PAGE_SIZE;
ULONG FwTemporaryHeap = (TEMPORARY_HEAP_START - 0x10) * PAGE_SIZE;


//
// Current pool pointers.  This is different than the temporary/permanent
// heaps, because it is not required to be under 1MB.  It is used by the
// SCSI miniports for allocating their extensions and for the dbcs font image.
//

#define FW_POOL_SIZE 96
ULONG FwPoolStart;
ULONG FwPoolEnd;

//
// This gets set to FALSE right before we call into the osloader, so we
// know that the fw memory descriptors can no longer be changed at will.
//
BOOLEAN FwDescriptorsValid = TRUE;


ULONG HighestPde=((_16MB << PAGE_SHIFT) >> PDI_SHIFT);

//
// Private function prototypes
//

ARC_STATUS
MempCopyGdt(
    VOID
    );

ARC_STATUS
MempSetupPaging(
    IN ULONG StartPage,
    IN ULONG NumberOfPages
    );

VOID
MempDisablePages(
    VOID
    );

ARC_STATUS
MempTurnOnPaging(
    VOID
    );

ARC_STATUS
MempSetDescriptorRegion (
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    );

ARC_STATUS
MempSetPageMappingOverride(
    IN ULONG StartPage,
    IN ULONG NumberOfPages,
    IN BOOLEAN Enable
    );

extern
void
BlpTrackUsage (
    MEMORY_TYPE MemoryType,
    ULONG ActualBase,
    ULONG  NumberPages
    );
//
// Global - memory management variables.
//

PHARDWARE_PTE PDE;
PHARDWARE_PTE HalPT;

#define MAX_DESCRIPTORS 60

MEMORY_DESCRIPTOR MDArray[MAX_DESCRIPTORS];      // Memory Descriptor List

ULONG NumberDescriptors=0;

ARC_STATUS
InitializeMemorySubsystem(
    PBOOT_CONTEXT BootContext
    )
/*++

Routine Description:

    The initial heap is mapped and allocated. Pointers to the
    Page directory and page tables are initialized.

Arguments:

    BootContext - Supplies basic information provided by SU module.

Returns:

    ESUCCESS - Memory succesfully initialized.

--*/

{
    ARC_STATUS Status;
    PSU_MEMORY_DESCRIPTOR SuMemory;
    ULONG PageStart;
    ULONG PageEnd;
    ULONG RomStart = ROM_START_PAGE;
    ULONG LoaderStart;
    ULONG LoaderEnd;
    ULONG BAddr, EAddr, BRound, ERound;

    //
    // Start by creating memory descriptors to describe all of the memory
    // we know about.  Then setup the page tables.  Finally, allocate
    // descriptors that describe our memory layout.
    //

    //
    // We know that one of the SU descriptors is for < 1Mb,
    // and we don't care about that, since we know everything we'll run
    // on will have at least 1Mb of memory.  The rest are for extended
    // memory, and those are the ones we are interested in.
    //

    SuMemory = BootContext->MemoryDescriptorList;
    while (SuMemory->BlockSize != 0) {

        BAddr = SuMemory->BlockBase;
        EAddr = BAddr + SuMemory->BlockSize - 1;

        //
        // Round the starting address to a page boundry.
        //

        BRound = BAddr & (ULONG) (PAGE_SIZE - 1);
        if (BRound) {
            BAddr = BAddr + PAGE_SIZE - BRound;
        }

        //
        // Round the ending address to a page boundry minus 1
        //

        ERound = (EAddr + 1) & (ULONG) (PAGE_SIZE - 1);
        if (ERound) {
            EAddr -= ERound;
        }

        //
        // Covert begining & ending address to page
        //

        PageStart = BAddr >> PAGE_SHIFT;
        PageEnd   = (EAddr + 1) >> PAGE_SHIFT;

        //
        // If this memory descriptor describes conventional ( <640k )
        // memory, then assume the ROM starts immediately after it
        // ends.
        //

        if (PageStart == 0) {
            RomStart = PageEnd;
        }

        //
        // If PageStart was rounded up to a page boundry, then add
        // the fractional page as SpecialMemory
        //

        if (BRound) {
            Status = MempSetDescriptorRegion (
                        PageStart - 1,
                        PageStart,
                        MemorySpecialMemory
                        );
            if (Status != ESUCCESS) {
                break;
            }
        }

        //
        // If PageEnd was rounded down to a page boundry, then add
        // the fractional page as SpecialMemory
        //

        if (ERound) {
            Status = MempSetDescriptorRegion (
                        PageEnd,
                        PageEnd + 1,
                        MemorySpecialMemory
                        );
            if (Status != ESUCCESS) {
                break;
            }

            //
            // RomStart starts after the reserved page
            //

            if (RomStart == PageEnd) {
                RomStart += 1;
            }
        }

        //
        // Add memory range PageStart though PageEnd
        //

        if (PageEnd <= _16MB_BOGUS) {

            //
            // This memory descriptor is all below the 16MB_BOGUS mark
            //

            Status = MempSetDescriptorRegion( PageStart, PageEnd, MemoryFree );

        } else if (PageStart >= _16MB) {

            //
            // Memory above 16MB is only used when absolutely necessary so it
            // is flagged as LoaderReserve
            //
            // --- 3/14/00 Allow it to be used. The diamond code
            // and the bios disk code manage read buffers to
            // keep reads below the 1Mb or 16MB lines
            //

            Status = MempSetDescriptorRegion( PageStart, PageEnd, LoaderReserve);

        } else {

            //
            // This memory descriptor describes memory within the
            // last 40h pages of the 16MB mark - otherwise known as
            // 16MB_BOGUS.
            //
            //

            if (PageStart < _16MB_BOGUS) {

                //
                // Clip starting address to 16MB_BOGUS mark, and add
                // memory below 16MB_BOGUS as useable memory.
                //

                Status = MempSetDescriptorRegion( PageStart, _16MB_BOGUS,
                                               MemoryFree );
                if (Status != ESUCCESS) {
                    break;
                }

                PageStart = _16MB_BOGUS;
            }

            //
            // Add remaining memory as LoaderReserve.
            //
            Status = MempSetDescriptorRegion( PageStart, PageEnd, LoaderReserve);

        }

        if (Status != ESUCCESS) {
            break;
        }

        //
        // Move to the next memory descriptor
        //

        ++SuMemory;
    }

    if (Status != ESUCCESS) {
        BlPrint("MempSetDescriptorRegion failed %lx\n",Status);
        return(Status);
    }

    //
    // Set the range 16MB_BOGUS - 16MB as unusable
    //

    Status = MempSetDescriptorRegion(_16MB_BOGUS, _16MB, MemorySpecialMemory);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Hack for EISA machines that insist there is usable memory in the
    // ROM area, where we know darn well there isn't.
    //

    // Remove anything in this range..
    MempSetDescriptorRegion(ROM_START_PAGE, ROM_END_PAGE, LoaderMaximum);

    //
    // Describe the BIOS area
    //
    MempSetDescriptorRegion(RomStart, ROM_END_PAGE, MemoryFirmwarePermanent);

    //
    // If this is a remote boot, then everything between the "size of free
    // base memory" mark and the start of the ROM area needs to be marked
    // as firmware temporary.  This is the boot ROM's data/stack area.
    //
    if ( BootContext->FSContextPointer->BootDrive == 0x40 ) {
        ULONG SizeOfFreeBaseMemory = (ULONG)*(USHORT *)0x413 * 1024;
        ULONG FirstRomDataPage = SizeOfFreeBaseMemory >> PAGE_SHIFT;
        if ( FirstRomDataPage < RomStart ) {
            MempSetDescriptorRegion(FirstRomDataPage, RomStart, MemoryFirmwareTemporary);
        }
    }

    //
    // Now we have descriptors that map all of physical memory.  Carve
    // out descriptors from these that describe the parts that we are
    // currently using.
    //

    //
    // Create the descriptors which describe the low 1Mb of memory.
    //

    //
    // 00000 - 00fff  real-mode interrupt vectors
    //
    Status = MempAllocDescriptor(0, 1, MemoryFirmwarePermanent);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // 01000 - 1ffff  loadable miniport drivers, free memory.
    //
    Status = MempAllocDescriptor(1, 0x20, MemoryFree);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // 20000 - 2ffff  SU module, SU stack
    //
    Status = MempAllocDescriptor(0x20, PERMANENT_HEAP_START, MemoryFirmwareTemporary);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // 30000 - 30000  Firmware Permanent
    //  This starts out as zero-length.  It grows into the firmware temporary
    //  heap descriptor as we allocate permanent pages for the Page Directory
    //  and Page Tables
    //

    Status = MempAllocDescriptor(PERMANENT_HEAP_START,
                                  PERMANENT_HEAP_START,
                                  LoaderMemoryData);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // 30000 - 5ffff  Firmware temporary heap
    //

    Status = MempAllocDescriptor(PERMANENT_HEAP_START,
                                  TEMPORARY_HEAP_START,
                                  MemoryFirmwareTemporary);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Stack we are currently running on.
    //
    Status = MempAllocDescriptor(TEMPORARY_HEAP_START,
                                 TEMPORARY_HEAP_START+2,
                                 MemoryFirmwareTemporary);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Describe the osloader memory image
    //
    LoaderStart = BootContext->OsLoaderStart >> PAGE_SHIFT;
    LoaderEnd = (BootContext->OsLoaderEnd + PAGE_SIZE - 1) >> PAGE_SHIFT;
    Status = MempAllocDescriptor(LoaderStart,
                                 LoaderEnd,
                                 MemoryLoadedProgram);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Describe the memory pool used to allocate memory for the SCSI
    // miniports.
    //
    Status = MempAllocDescriptor(LoaderEnd,
                                 LoaderEnd + FW_POOL_SIZE,
                                 MemoryFirmwareTemporary);
    if (Status != ESUCCESS) {
        return(Status);
    }
    FwPoolStart = LoaderEnd << PAGE_SHIFT;
    FwPoolEnd = FwPoolStart + (FW_POOL_SIZE << PAGE_SHIFT);

    //
    // HACKHACK - try to mark a page just below the osloader as firmwaretemp,
    // so it will not get used for heap/stack.  This is to force
    // our heap/stack to be < 1Mb.
    //
    MempAllocDescriptor((BootContext->OsLoaderStart >> PAGE_SHIFT)-1,
                        BootContext->OsLoaderStart >> PAGE_SHIFT,
                        MemoryFirmwareTemporary);


    Status = MempTurnOnPaging();

    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = MempCopyGdt();

    //
    // Find any reserved ranges described by the firmware and
    // record these
    //

    return(Status);
}

VOID
InitializeMemoryDescriptors (
    VOID
    )
/*++

Routine Description:

    Pass 2 of InitializeMemorySubsystem.  This function reads the
    firmware address space map and reserves ranges the firmware declares
    as "address space reserved".

    Note: free memory range descriptors has already been reported by su.

Arguments:

    none

Returns:

    none

--*/
{
    ULONGLONG       BAddr, EAddr, Length;
    ULONG           BPage, EPage;
    E820FRAME       Frame;

#ifdef LOADER_DEBUG
    BlPrint("Begin InitializeMemoryDescriptors\n") ;
#endif

    Frame.Key = 0;
    do {
        Frame.Size = sizeof (Frame.Descriptor);
        GET_MEMORY_DESCRIPTOR (&Frame);
        if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {
            break;
        }

#ifdef LOADER_DEBUG
        BlPrint("*E820: %lx  %lx:%lx %lx:%lx %lx %lx\n",
            Frame.Size,
            Frame.Descriptor.BaseAddrHigh,  Frame.Descriptor.BaseAddrLow,
            Frame.Descriptor.SizeHigh,      Frame.Descriptor.SizeLow,
            Frame.Descriptor.MemoryType,
            Frame.Key
            );
#endif

        BAddr = Frame.Descriptor.BaseAddrHigh;
        BAddr = (BAddr << 32) + Frame.Descriptor.BaseAddrLow;

        Length = Frame.Descriptor.SizeHigh;
        Length = (Length << 32) + Frame.Descriptor.SizeLow;

        EAddr = BAddr + Length - 1;

        //
        // The memory range is described as the region from BAddr to EAddr
        // inclusive.
        //

        //
        // Some processors support physical addressing above 32 bits.
        //

        //
        // Based upon the address range descriptor type, find the
        // available memory and add it to the descriptor list
        //

        switch (Frame.Descriptor.MemoryType) {
            case 1:
                //
                // This is a memory descriptor - it's already been handled
                // by su (eisac.c)
                //
                // However, any memory within 16MB_BOGUS - 16MB was
                // considered unuseable.  Reclaim memory within this
                // region which is described via this interface.
                //
                // Also, any memory above 4G was considered unusable.
                // Reclaim memory within this range as well.
                //

                BPage = (ULONG)((BAddr + PAGE_SIZE - 1) >> PAGE_SHIFT);
                EPage = (ULONG)((EAddr >> PAGE_SHIFT) + 1);

                //
                // Clip to bogus range
                //

                if (BPage < _16MB_BOGUS  &&  EPage >= _16MB_BOGUS) {
                    BPage = _16MB_BOGUS;
                }

                if (EPage > (_16MB-1) &&  BPage <= (_16MB-1)) {
                    EPage = (_16MB-1);
                }

                if (BPage >= _16MB_BOGUS  &&  EPage <= (_16MB-1)) {
                    //
                    // Reclaim memory within the bogus range
                    // by setting it to FirmwareTemporary
                    //

                    MempSetDescriptorRegion (
                        BPage,
                        EPage,
                        MemoryFirmwareTemporary
                        );
                }

                //
                // Now reclaim any portion of this range that lies above
                // the 4G line.
                //

                BPage = (ULONG)((BAddr + PAGE_SIZE - 1) >> PAGE_SHIFT);
                EPage = (ULONG)((EAddr >> PAGE_SHIFT) + 1);

                if (EPage >= _4G) {

                    //
                    // At least part of this region is above 4G.  Truncate
                    // any portion that falls below 4G, and reclaim
                    // the memory.
                    //

                    if (BPage < _4G) {
                        BPage = _4G;
                    }

                    MempSetDescriptorRegion (
                        BPage,
                        EPage,
                        MemoryFirmwareTemporary
                        );
                }

                break;

            default:    // unkown types are treated as Reserved
            case 2:

                //
                // This memory descriptor is a reserved address range
                //

                BPage = (ULONG)(BAddr >> PAGE_SHIFT);
                EPage = (ULONG)((EAddr + 1 + PAGE_SIZE - 1) >> PAGE_SHIFT);

                MempSetDescriptorRegion (
                    BPage,
                    EPage,
                    MemorySpecialMemory
                    );

                break;
        }

    } while (Frame.Key) ;


    //
    // Disable pages from KSEG0 which are disabled
    //

    MempDisablePages();

#ifdef LOADER_DEBUG
    BlPrint("Complete InitializeMemoryDescriptors\n") ;
#endif

    return;
}



ARC_STATUS
MempCopyGdt(
    VOID
    )

/*++

Routine Description:

    Copies the GDT & IDT into pages allocated out of our permanent heap.

Arguments:

    None

Return Value:

    ESUCCESS - GDT & IDT copy successful

--*/

{
    #pragma pack(2)
    static struct {
        USHORT Limit;
        ULONG Base;
    } GdtDef, IdtDef;
    #pragma pack(4)

    ULONG BlockSize;
    PKGDTENTRY NewGdt;
    PKIDTENTRY NewIdt;
    ULONG NumPages;

    //
    // Get the current location of the GDT & IDT
    //
    _asm {
        sgdt GdtDef;
        sidt IdtDef;
    }

    if (GdtDef.Base + GdtDef.Limit + 1 != IdtDef.Base) {

        //
        // Just a sanity check to make sure that the IDT immediately
        // follows the GDT.  (As set up in SUDATA.ASM)
        //

        BlPrint("ERROR - GDT and IDT are not contiguous!\n");
        BlPrint("GDT - %lx (%x)  IDT - %lx (%x)\n",
            GdtDef.Base, GdtDef.Limit,
            IdtDef.Base, IdtDef.Limit);
        while (1);
    }

    BlockSize = GdtDef.Limit+1 + IdtDef.Limit+1;

    NumPages = (BlockSize + PAGE_SIZE-1) >> PAGE_SHIFT;

    NewGdt = (PKGDTENTRY)FwAllocateHeapPermanent(NumPages);

    if (NewGdt == NULL) {
        return(ENOMEM);
    }

    RtlMoveMemory((PVOID)NewGdt, (PVOID)GdtDef.Base, NumPages << PAGE_SHIFT);

    GdtDef.Base = (ULONG)NewGdt;
    IdtDef.Base = (ULONG)((PUCHAR)NewGdt + GdtDef.Limit + 1);

    //
    // Initialize the boot debugger IDT entries.
    //

    NewIdt = (PKIDTENTRY)IdtDef.Base;
    NewIdt[1].Offset = (USHORT)((ULONG)BdTrap01 & 0xffff);
    NewIdt[1].Selector = 8;
    NewIdt[1].Access = 0x8e00;
    NewIdt[1].ExtendedOffset = (USHORT)((ULONG)BdTrap01 >> 16);

    NewIdt[3].Offset = (USHORT)((ULONG)BdTrap03 & 0xffff);
    NewIdt[3].Selector = 8;
    NewIdt[3].Access = 0x8e00;
    NewIdt[3].ExtendedOffset = (USHORT)((ULONG)BdTrap03 >> 16);

    NewIdt[0xd].Offset = (USHORT)((ULONG)BdTrap0d & 0xffff);
    NewIdt[0xd].Selector = 8;
    NewIdt[0xd].Access = 0x8e00;
    NewIdt[0xd].ExtendedOffset = (USHORT)((ULONG)BdTrap0d >> 16);

    NewIdt[0xe].Offset = (USHORT)((ULONG)BdTrap0e & 0xffff);
    NewIdt[0xe].Selector = 8;
    NewIdt[0xe].Access = 0x8e00;
    NewIdt[0xe].ExtendedOffset = (USHORT)((ULONG)BdTrap0e >> 16);

    NewIdt[0x2d].Offset = (USHORT)((ULONG)BdTrap2d & 0xffff);
    NewIdt[0x2d].Selector = 8;
    NewIdt[0x2d].Access = 0x8e00;
    NewIdt[0x2d].ExtendedOffset = (USHORT)((ULONG)BdTrap2d >> 16);

    //
    // Load GDT and IDT registers.
    //

    _asm {
        lgdt GdtDef;
        lidt IdtDef;
    }

    //
    // Initialize the boot debugger.
    //

#if defined(ENABLE_LOADER_DEBUG)
    BdInitDebugger(OsLoaderName, (PVOID)OsLoaderBase, ENABLE_LOADER_DEBUG);
#else
    BdInitDebugger(OsLoaderName, (PVOID)OsLoaderBase, NULL);
#endif

    return ESUCCESS;
}

ARC_STATUS
MempSetDescriptorRegion (
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    )
/*++

Routine Description:

    This function sets a range to the corrisponding memory type.
    Descriptors will be removed, modified, inserted as needed to
    set the specified range.

Arguments:

    StartPage  - Supplies the beginning page of the new memory descriptor

    EndPage    - Supplies the ending page of the new memory descriptor

    MemoryType - Supplies the type of memory of the new memory descriptor

Return Value:

    ESUCCESS - Memory descriptor succesfully added to MDL array

    ENOMEM   - MDArray is full.

--*/
{
    ULONG           i;
    ULONG           sp, ep;
    TYPE_OF_MEMORY  mt;
    BOOLEAN         RegionAdded;

    if (EndPage <= StartPage) {
        //
        // This is a completely bogus memory descriptor. Ignore it.
        //

#ifdef LOADER_DEBUG
        BlPrint("Attempt to create invalid memory descriptor %lx - %lx\n",
                StartPage,EndPage);
#endif
        return(ESUCCESS);
    }

    RegionAdded = FALSE;

    //
    // Clip, remove, any descriptors in target area
    //

    for (i=0; i < NumberDescriptors; i++) {
        sp = MDArray[i].BasePage;
        ep = MDArray[i].BasePage + MDArray[i].PageCount;
        mt = MDArray[i].MemoryType;

        if (sp < StartPage) {
            if (ep > StartPage  &&  ep <= EndPage) {
                // truncate this descriptor
                ep = StartPage;
            }

            if (ep > EndPage) {
                //
                // Target area is contained totally within this
                // descriptor.  Split the descriptor into two ranges
                //

                if (NumberDescriptors == MAX_DESCRIPTORS) {
                    return(ENOMEM);
                }

                //
                // Add descriptor for EndPage - ep
                //

                MDArray[NumberDescriptors].MemoryType = mt;
                MDArray[NumberDescriptors].BasePage   = EndPage;
                MDArray[NumberDescriptors].PageCount  = ep - EndPage;
                NumberDescriptors += 1;

                //
                // Adjust current descriptor for sp - StartPage
                //

                ep = StartPage;
            }

        } else {
            // sp >= StartPage

            if (sp < EndPage) {
                if (ep < EndPage) {
                    //
                    // This descriptor is totally within the target area -
                    // remove it
                    //

                    ep = sp;

                }  else {
                    // bump begining page of this descriptor
                    sp = EndPage;
                }
            }
        }

        //
        // Check if the new range can be appended or prepended to
        // this descriptor
        //
        if (mt == MemoryType && !RegionAdded) {
            if (sp == EndPage) {
                // prepend region being set
                sp = StartPage;
                RegionAdded = TRUE;

            } else if (ep == StartPage) {
                // append region being set
                ep = EndPage;
                RegionAdded = TRUE;

            }
        }

        if (MDArray[i].BasePage == sp  &&  MDArray[i].PageCount == ep-sp) {

            //
            // Descriptor was not editted
            //

            continue;
        }

        //
        // Reset this descriptor
        //

        MDArray[i].BasePage  = sp;
        MDArray[i].PageCount = ep - sp;

        if (ep == sp) {

            //
            // Descriptor vanished - remove it
            //

            NumberDescriptors -= 1;
            if (i < NumberDescriptors) {
                MDArray[i] = MDArray[NumberDescriptors];
            }

            i--;        // backup & recheck current position
        }
    }

    //
    // If region wasn't already added to a neighboring region, then
    // create a new descriptor now
    //

    if (!RegionAdded  &&  MemoryType < LoaderMaximum) {
        if (NumberDescriptors == MAX_DESCRIPTORS) {
            return(ENOMEM);
        }

#ifdef LOADER_DEBUG
        BlPrint("Adding '%lx - %lx, type %x' to descriptor list\n",
                StartPage << PAGE_SHIFT,
                EndPage << PAGE_SHIFT,
                (USHORT) MemoryType
                );
#endif

        MDArray[NumberDescriptors].MemoryType = MemoryType;
        MDArray[NumberDescriptors].BasePage   = StartPage;
        MDArray[NumberDescriptors].PageCount  = EndPage - StartPage;
        NumberDescriptors += 1;
    }
    return (ESUCCESS);
}

ARC_STATUS
MempAllocDescriptor(
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    )

/*++

Routine Description:

    This routine carves out a specific memory descriptor from the
    memory descriptors that have already been created.  The MD array
    is updated to reflect the new state of memory.

    The new memory descriptor must be completely contained within an
    already existing memory descriptor.  (i.e.  memory that does not
    exist should never be marked as a certain type)

Arguments:

    StartPage  - Supplies the beginning page of the new memory descriptor

    EndPage    - Supplies the ending page of the new memory descriptor

    MemoryType - Supplies the type of memory of the new memory descriptor

Return Value:

    ESUCCESS - Memory descriptor succesfully added to MDL array

    ENOMEM   - MDArray is full.

--*/
{
    ULONG i;

    //
    // Walk through the memory descriptors until we find one that
    // contains the start of the descriptor.
    //
    for (i=0; i<NumberDescriptors; i++) {
        if ((MDArray[i].MemoryType == MemoryFree) &&
            (MDArray[i].BasePage <= StartPage )     &&
            (MDArray[i].BasePage+MDArray[i].PageCount >  StartPage) &&
            (MDArray[i].BasePage+MDArray[i].PageCount >= EndPage)) {

            break;
        }
    }

    if (i==NumberDescriptors) {
        return(ENOMEM);
    }

    if (MDArray[i].BasePage == StartPage) {

        if (MDArray[i].BasePage+MDArray[i].PageCount == EndPage) {

            //
            // The new descriptor is identical to the existing descriptor.
            // Simply change the memory type of the existing descriptor in
            // place.
            //

            MDArray[i].MemoryType = MemoryType;
        } else {

            //
            // The new descriptor starts on the same page, but is smaller
            // than the existing descriptor.  Shrink the existing descriptor
            // by moving its start page up, and create a new descriptor.
            //
            if (NumberDescriptors == MAX_DESCRIPTORS) {
                return(ENOMEM);
            }
            MDArray[i].BasePage = EndPage;
            MDArray[i].PageCount -= (EndPage-StartPage);

            MDArray[NumberDescriptors].BasePage = StartPage;
            MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
            MDArray[NumberDescriptors].MemoryType = MemoryType;
            ++NumberDescriptors;

        }
    } else if (MDArray[i].BasePage+MDArray[i].PageCount == EndPage) {

        //
        // The new descriptor ends on the same page.  Shrink the existing
        // by decreasing its page count, and create a new descriptor.
        //
        if (NumberDescriptors == MAX_DESCRIPTORS) {
            return(ENOMEM);
        }
        MDArray[i].PageCount = StartPage - MDArray[i].BasePage;

        MDArray[NumberDescriptors].BasePage = StartPage;
        MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
        MDArray[NumberDescriptors].MemoryType = MemoryType;
        ++NumberDescriptors;
    } else {

        //
        // The new descriptor is in the middle of the existing descriptor.
        // Shrink the existing descriptor by decreasing its page count, and
        // create two new descriptors.
        //

        if (NumberDescriptors+1 >= MAX_DESCRIPTORS) {
            return(ENOMEM);
        }

        MDArray[NumberDescriptors].BasePage = EndPage;
        MDArray[NumberDescriptors].PageCount = MDArray[i].PageCount -
                (EndPage-MDArray[i].BasePage);
        MDArray[NumberDescriptors].MemoryType = MemoryFree;
        ++NumberDescriptors;

        MDArray[i].PageCount = StartPage - MDArray[i].BasePage;

        MDArray[NumberDescriptors].BasePage = StartPage;
        MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
        MDArray[NumberDescriptors].MemoryType = MemoryType;
        ++NumberDescriptors;
    }

    BlpTrackUsage (MemoryType,StartPage,EndPage-StartPage);

    return(ESUCCESS);
}

ARC_STATUS
MempTurnOnPaging(
    VOID
    )

/*++

Routine Description:

    Sets up the page tables necessary to map the first 16mb of memory and
    enables paging.

Arguments:

    None.

Return Value:

    ESUCCESS - Paging successfully turned on

--*/

{

    ULONG i;
    ARC_STATUS Status;

    //
    // Allocate, initialize, and map the PDE page onto itself (i.e., virtual
    // address PDE_BASE).
    //

    PDE = FwAllocateHeapPermanent(1);
    if (PDE == NULL) {
        return ENOMEM;
    }

    RtlZeroMemory(PDE, PAGE_SIZE);
    PDE[PDE_BASE >> 22].Valid = 1;
    PDE[PDE_BASE >> 22].Write = 1;
    PDE[PDE_BASE >> 22].PageFrameNumber = (ULONG)PDE >> PAGE_SHIFT;

    //
    // Allocate, initialize, and map the HAL page into the last PDE (i.e.,
    // virtual address range 0xffc00000 - 0xffffffff).
    //

    HalPT = FwAllocateHeapPermanent(1);
    if (HalPT == NULL) {
        return ENOMEM;
    }

    RtlZeroMemory(HalPT, PAGE_SIZE);
    PDE[1023].Valid = 1;
    PDE[1023].Write = 1;
    PDE[1023].PageFrameNumber = (ULONG)HalPT >> PAGE_SHIFT;

    //
    // Scan the memory descriptor list and setup paging for each descriptor.
    //

    for (i = 0; i < NumberDescriptors; i++) {

        if (MDArray[i].BasePage < _16MB) {

            Status = MempSetupPaging(MDArray[i].BasePage,
                                     MDArray[i].PageCount);

            if (Status != ESUCCESS) {
                BlPrint("ERROR - MempSetupPaging(%lx, %lx) failed\n",
                        MDArray[i].BasePage,
                        MDArray[i].PageCount);

                return Status;
            }
        }
    }

    //
    // Turn on paging.
    //

    _asm {

        //
        // Load physical address of page directory
        //

        mov eax,PDE
        mov cr3,eax

        //
        // Enable paging mode
        //

        mov eax,cr0
        or  eax,CR0_PG
        mov cr0,eax
    }

    return ESUCCESS;
}

ARC_STATUS
MempSetupPaging(
    IN ULONG StartPage,
    IN ULONG NumberPages
    )

/*++

Routine Description:

    Allocates and initializes the page table pages required to identity map
    the specified region of memory at its physical address, at KSEG0_BASE, OLD_ALTERNATE
    and at ALTERNATE_BASE.

Arguments:

    StartPage - Supplies the first page to start mapping.

    NumberPage - Supplies the number of pages to map.

Return Value:

    ESUCCESS    - Paging successfully set up

--*/

{

    ULONG EndPage;
    ULONG Entry;
    ULONG FrameNumber;
    ULONG Page;
    PHARDWARE_PTE PageTableP;
    PHARDWARE_PTE PageTableV;
    ULONG Offset;

    //
    // The page table pages that are used to map memory at physical equal
    // real addresses are allocated from firmware temporary memory which
    // gets released when memory management initializes.
    //
    // N.B. Physical memory is mapped at its physical address, KSEG0_BASE,
    //      and at ALTERNATE_BASE. This allows the system to be configured
    //      by the OS Loader to be either a 2gb or 3gb user space system
    //      based on an OS Loader option.
    //

    EndPage = StartPage + NumberPages;
    for (Page = StartPage; Page < EndPage; Page += 1) {
        Entry = Page >> 10;

        //
        // If the PDE entry for this page address range is not allocated,
        // then allocate and initialize the PDE entry to map the page table
        // pages for the the memory range. Otherwise, compute the address
        // of the page table pages.
        //
        if (PDE[Entry].Valid == 0) {

            //
            // Allocate and initialize a page table page to map the specified
            // page into physical memory.
            //

            PageTableP = (PHARDWARE_PTE)FwAllocateHeapAligned(PAGE_SIZE);
            if (PageTableP == NULL) {
                return ENOMEM;
            }

            RtlZeroMemory(PageTableP, PAGE_SIZE);
            FrameNumber = (ULONG)PageTableP >> PAGE_SHIFT;
            PDE[Entry].Valid = 1;
            PDE[Entry].Write = 1;
            PDE[Entry].PageFrameNumber = FrameNumber;

            //
            // Allocate and initialize a page table page to map the specified
            // page into KSEG0_BASE and ALTERNATE_BASE.
            //
            // N.B. Only one page table page is allocated since the contents
            //      for both mappings are the same.
            //

            PageTableV = (PHARDWARE_PTE)FwAllocateHeapPermanent(1);
            if (PageTableV == NULL) {
                return ENOMEM;
            }

            RtlZeroMemory(PageTableV, PAGE_SIZE);
            FrameNumber = (ULONG)PageTableV >> PAGE_SHIFT;
            Offset = Entry + (KSEG0_BASE >> 22);
            PDE[Offset].Valid = 1;
            PDE[Offset].Write = 1;
            PDE[Offset].PageFrameNumber = FrameNumber;

            Offset = Entry + (ALTERNATE_BASE >> 22);
            PDE[Offset].Valid = 1;
            PDE[Offset].Write = 1;
            PDE[Offset].PageFrameNumber = FrameNumber;

            if (Entry > HighestPde) {
                HighestPde = Entry;
            }

        } else {
            Offset = Entry + (KSEG0_BASE >> 22);
            PageTableP = (PHARDWARE_PTE)(PDE[Entry].PageFrameNumber << PAGE_SHIFT);
            PageTableV = (PHARDWARE_PTE)(PDE[Offset].PageFrameNumber << PAGE_SHIFT);
        }

        //
        // If this is not the first page in memory, then mark it valid.
        //

        if (Page != 0) {
            Offset = Page & 0x3ff;
            PageTableP[Offset].Valid = 1;
            PageTableP[Offset].Write = 1;
            PageTableP[Offset].PageFrameNumber = Page;

            PageTableV[Offset].Valid = 1;
            PageTableV[Offset].Write = 1;
            PageTableV[Offset].PageFrameNumber = Page;
        }
    }

    return ESUCCESS;
}

VOID
MempDisablePages(
    VOID
    )

/*++

Routine Description:

    Frees as many Page Tables as are required from the KSEG0_BASE, OLD_ALTERNATE
    and ALTERNATE_BASE regions.

Arguments:

    None.

Return Value:

    none

--*/

{

    ULONG EndPage;
    ULONG Entry;
    ULONG i;
    ULONG Offset;
    ULONG Page;
    PHARDWARE_PTE PageTable;

    //
    // Cleanup the KSEG0_BASE and ALTERNATE_BASE regions. The MM PFN database
    // is an array of entries which track each page of main memory.  Large
    // enough memory holes will cause this array to be sparse. MM requires
    // enabled PTEs to have entries in the PFN database. So locate any memory
    // hole and remove their PTEs.
    //

    for (i = 0; i < NumberDescriptors; i += 1) {
        if (MDArray[i].MemoryType == MemorySpecialMemory ||
            MDArray[i].MemoryType == MemoryFirmwarePermanent) {

            //
            // The KSEG0_BASE and ALTERNATE_BASE regions only map up to 16MB,
            // so clip the high end at that address.
            //

            Page = MDArray[i].BasePage;
            EndPage = Page + MDArray[i].PageCount;
            if (EndPage > _16MB) {
                EndPage = _16MB;
            }

            //
            // Some PTEs below 1M may need to stay mapped since they may have
            // been put into ABIOS selectors.  Instead of determining which PTEs
            // they may be, we will leave PTEs below 1M alone.  This doesn't
            // cause the PFN any problems since we know there is some memory
            // below then 680K mark and some more memory at the 1M mark.  Thus
            // there is not a large enough "memory hole" to cause the PFN database
            // to be sparse below 1M.
            //
            // Clip starting address to 1MB
            //

            if (Page < _1MB) {
                Page = _1MB;
            }

            //
            // For each page in this range make sure it is invalid in the
            // KSEG0_BASE and ALTERNATE_BASE regions.
            //
            // N.B. Since there is only one page table page for both the
            //      KSEG0_BASE and ALTERNATE_BASE regions the page only
            //      needs to marked invalid once.
            //

            while (Page < EndPage) {
                Entry = (Page >> 10) + (KSEG0_BASE >> 22);
                if (PDE[Entry].Valid == 1) {
                    PageTable = (PHARDWARE_PTE)(PDE[Entry].PageFrameNumber << PAGE_SHIFT);
                    Offset = Page & 0x3ff;
                    PageTable[Offset].Valid = 0;
                    PageTable[Offset].Write = 0;
                    PageTable[Offset].PageFrameNumber = 0;
                }

                Page += 1;
            }
        }
    }
}

PVOID
FwAllocateHeapPermanent(
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This allocates pages from the private heap.  The memory descriptor for
    the LoaderMemoryData area is grown to include the returned pages, while
    the memory descriptor for the temporary heap is shrunk by the same amount.

    N.B.    DO NOT call this routine after we have passed control to
            BlOsLoader!  Once BlOsLoader calls BlMemoryInitialize, the
            firmware memory descriptors are sucked into the OS Loader heap
            and those are the descriptors passed to the kernel.  So any
            changes in the firmware private heap will be irrelevant.

            If you need to allocate permanent memory after the OS Loader
            has initialized, use BlAllocateDescriptor.

Arguments:

    NumberPages - size of memory to allocate (in pages)

Return Value:

    Pointer to block of memory, if successful.
    NULL, if unsuccessful.

--*/

{

    PVOID MemoryPointer;
    PMEMORY_DESCRIPTOR Descriptor;

    if (FwPermanentHeap + (NumberPages << PAGE_SHIFT) > FwTemporaryHeap) {

        //
        // Our heaps collide, so we are out of memory
        //

        BlPrint("Out of permanent heap!\n");
        while (1) {
        }

        return(NULL);
    }

    //
    // Find the memory descriptor which describes the LoaderMemoryData area,
    // so we can grow it to include the just-allocated pages.
    //
    Descriptor = MDArray;
    while (Descriptor->MemoryType != LoaderMemoryData) {
        ++Descriptor;
        if (Descriptor > MDArray+MAX_DESCRIPTORS) {
            BlPrint("ERROR - FwAllocateHeapPermanent couldn't find the\n");
            BlPrint("        LoaderMemoryData descriptor!\n");
            while (1) {
            }
            return(NULL);
        }
    }
    Descriptor->PageCount += NumberPages;

    //
    // We know that the memory descriptor after this one is the firmware
    // temporary heap descriptor.  Since it is physically contiguous with our
    // LoaderMemoryData block, we remove the pages from its descriptor.
    //

    ++Descriptor;
    Descriptor->PageCount -= NumberPages;
    Descriptor->BasePage  += NumberPages;

    MemoryPointer = (PVOID)FwPermanentHeap;
    FwPermanentHeap += NumberPages << PAGE_SHIFT;

    return(MemoryPointer);
}


PVOID
FwAllocateHeap(
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory from the "firmware" temporary heap.

Arguments:

    Size - Supplies size of block to allocate

Return Value:

    PVOID - Pointer to the beginning of the block
    NULL  - Out of memory

--*/

{
    ULONG i;
    ULONG SizeInPages;
    ULONG StartPage;
    ARC_STATUS Status;

    if (((FwTemporaryHeap - FwPermanentHeap) < Size) && (FwDescriptorsValid)) {
        //
        // Large allocations get their own descriptor so miniports that
        // have huge device extensions don't suck up all of the heap.
        //
        // Note that we can only do this while running in "firmware" mode.
        // Once we call into the osloader, it sucks all the memory descriptors
        // out of the "firmware" and changes to this list will not show
        // up there.
        //
        // We are looking for a descriptor that is MemoryFree and <16Mb.
        //
        // [ChuckL 13-Dec-2001]
        // This routine has always been called after the loader's memory list
        // was initialized, which meant that it was stomping on memory that
        // might have been allocated by the loader. This was not a problem
        // because the loader initialized its memory list twice(!), so it
        // looked at the MDArray again to get an updated picture of the
        // memory allocation situation. This didn't really work, and there
        // used to be extra code here to handle the situation by calling
        // BlFindDescriptor/BlGeneratorDescriptor to tell the loader about
        // the low-level allocation. But even that didn't really work. And
        // now, because of the elimination of the second call to
        // BlMemoryInitialize(), the brokenness of the old code has been
        // exposed. What happened is that this routine would use the MDArray
        // to decide where to allocate memory, then it would tell the loader
        // about it. But using MDArray to find free memory was bogus,
        // because the loader had already used its own copy of the list to
        // make its own allocations. So the same memory was allocated twice.
        // The fix implemented here is to use BlAllocateAlignedDescriptor if
        // the loader has been initialized, skipping the MDArray entirely.
        //

        SizeInPages = (Size+PAGE_SIZE-1) >> PAGE_SHIFT;

        if (BlLoaderBlock != NULL) {

            Status = BlAllocateAlignedDescriptor(
                        LoaderFirmwareTemporary,
                        0,
                        SizeInPages,
                        1,
                        &StartPage
                        );
            if (Status == ESUCCESS) {
                return((PVOID)(StartPage << PAGE_SHIFT));
            }

        } else {

            for (i=0; i<NumberDescriptors; i++) {
                if ((MDArray[i].MemoryType == MemoryFree) &&
                    (MDArray[i].BasePage <= _16MB_BOGUS) &&
                    (MDArray[i].PageCount >= SizeInPages)) {
                    break;
                }
            }
    
            if (i < NumberDescriptors) {
                StartPage = MDArray[i].BasePage+MDArray[i].PageCount-SizeInPages;
                Status = MempAllocDescriptor(StartPage,
                                             StartPage+SizeInPages,
                                             MemoryFirmwareTemporary);
                if (Status==ESUCCESS) {
                    return((PVOID)(StartPage << PAGE_SHIFT));
                }
            }
        }
    }

    FwTemporaryHeap -= Size;

    //
    // Round down to 16-byte boundary
    //

    FwTemporaryHeap &= ~((ULONG)0xf);

    if (FwTemporaryHeap < FwPermanentHeap) {
#if DBG
        BlPrint("Out of temporary heap!\n");
#endif
        return(NULL);
    }

    return((PVOID)FwTemporaryHeap);

}


PVOID
FwAllocatePool(
    IN ULONG Size
    )

/*++

Routine Description:

    This routine allocates memory from the firmware pool.  Note that
    this memory is NOT under the 1MB line, so it cannot be used for
    anything that must be accessed from real mode.  It is currently used
    only by the SCSI miniport drivers and dbcs font loader.

Arguments:

    Size - Supplies size of block to allocate.

Return Value:

    PVOID - pointer to the beginning of the block
    NULL - out of memory

--*/

{
    PVOID Buffer;
    ULONG NewSize;

    //
    // round size up to 16 byte boundary
    //
    NewSize = (Size + 15) & ~0xf;
    if ((FwPoolStart + NewSize) <= FwPoolEnd) {

        Buffer = (PVOID)FwPoolStart;
        FwPoolStart += NewSize;
        return(Buffer);

    } else {
        //
        // we've used up all our pool, try to allocate from the heap.
        //
        return(FwAllocateHeap(Size));
    }


}


PVOID
FwAllocateHeapAligned(
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory from the "firmware" temporary heap.  This memory is
    always allocated on a page boundary, so it can readily be used for
    temporary page tables

Arguments:

    Size - Supplies size of block to allocate

Return Value:

    PVOID - Pointer to the beginning of the block
    NULL  - Out of memory

--*/

{

    FwTemporaryHeap -= Size;

    //
    // Round down to a page boundary
    //

    FwTemporaryHeap &= ~(PAGE_SIZE-1);

    if (FwTemporaryHeap < FwPermanentHeap) {
        BlPrint("Out of temporary heap!\n");
        return(NULL);
    }
    RtlZeroMemory((PVOID)FwTemporaryHeap,Size);

    return((PVOID)FwTemporaryHeap);

}


PVOID
MmMapIoSpace (
     IN PHYSICAL_ADDRESS PhysicalAddress,
     IN ULONG NumberOfBytes,
     IN MEMORY_CACHING_TYPE CacheType
     )

/*++

Routine Description:

    This function returns the corresponding virtual address for a
    known physical address.

Arguments:

    PhysicalAddress - Supplies the physical address.

    NumberOfBytes - Unused.

    CacheType - Unused.

Return Value:

    Returns the corresponding virtual address.

Environment:

    Kernel mode.  Any IRQL level.

--*/

{
    ULONG i;
    ULONG j;
    ULONG NumberPages;

    NumberPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(PhysicalAddress.LowPart, NumberOfBytes);

    //
    // We use the HAL's PDE for mapping memory buffers.
    // Find enough free PTEs.
    //

    //
    // Check the value of NumberPages
    //
#define X86_MAX_NUMBER_OF_PAGES     1024
    //
    // since NumberPages is ULONG any arithmetic with NumberPages will
    // result in a ULONG (unless casted)
    // therefore if NumberPages is greated than X86_MAX_NUMBER_OF_PAGES
    // the results of X86_MAX_NUMBER_OF_PAGES-NUmberPages
    // will not be negative (its a ULONG!) therfore the following loop would
    // have returned some bogus pointer...
    //
    // The following 3 line check was added to avoid this problem
    //
    if (NumberPages > X86_MAX_NUMBER_OF_PAGES) {
        return (NULL);
    }

    for (i=0; i <= X86_MAX_NUMBER_OF_PAGES - NumberPages; i++) {
        for (j=0; j < NumberPages; j++) {
            if ((((PULONG)HalPT))[i+j]) {
                break;
            }
        }

        if (j == NumberPages) {
            for (j=0; j<NumberPages; j++) {
                HalPT[i+j].PageFrameNumber =
                                (PhysicalAddress.LowPart >> PAGE_SHIFT)+j;
                HalPT[i+j].Valid = 1;
                HalPT[i+j].Write = 1;
                HalPT[i+j].WriteThrough = 1;
                if (CacheType == MmNonCached) {
                    HalPT[i+j].CacheDisable = 1;
                }
            }

            return((PVOID)(0xffc00000 | (i<<12) | (PhysicalAddress.LowPart & 0xfff)));
        }

    }
    return(NULL);
}


VOID
MmUnmapIoSpace (
     IN PVOID BaseAddress,
     IN ULONG NumberOfBytes
     )

/*++

Routine Description:

    This function unmaps a range of physical address which were previously
    mapped via an MmMapIoSpace function call.

Arguments:

    BaseAddress - Supplies the base virtual address where the physical
                  address was previously mapped.

    NumberOfBytes - Supplies the number of bytes which were mapped.

Return Value:

    None.

Environment:

    Kernel mode, IRQL of DISPATCH_LEVEL or below.

--*/

{
    ULONG StartPage, PageCount;

    PageCount = COMPUTE_PAGES_SPANNED(BaseAddress, NumberOfBytes);
    StartPage = (((ULONG_PTR)BaseAddress & ~0xffc00000) >> PAGE_SHIFT);
    if (BaseAddress > (PVOID)0xffc00000) {
        RtlZeroMemory(&HalPT[StartPage], PageCount * sizeof(HARDWARE_PTE_X86));
    }

    _asm {
        mov     eax, cr3
        mov     cr3, eax
    }
    return;
}


VOID
BlpTruncateMemory (
    IN ULONG MaxMemory
    )

/*++

Routine Description:

    Eliminates all the memory descriptors above a given boundary

Arguments:

    MaxMemory - Supplies the maximum memory boundary in megabytes

Return Value:

    None.

--*/

{
    extern MEMORY_DESCRIPTOR MDArray[];
    extern ULONG NumberDescriptors;
    ULONG Current = 0;
    ULONG MaxPage = MaxMemory * 256;        // Convert Mb to pages

    if (MaxMemory == 0) {
        return;
    }

    while (Current < NumberDescriptors) {
        if (MDArray[Current].BasePage >= MaxPage) {
            //
            // This memory descriptor lies entirely above the boundary,
            // eliminate it.
            //
            RtlMoveMemory(MDArray+Current,
                          MDArray+Current+1,
                          sizeof(MEMORY_DESCRIPTOR)*
                          (NumberDescriptors-Current-1));
            --NumberDescriptors;
        } else if (MDArray[Current].BasePage + MDArray[Current].PageCount > MaxPage) {
            //
            // This memory descriptor crosses the boundary, truncate it.
            //
            MDArray[Current].PageCount = MaxPage - MDArray[Current].BasePage;
            ++Current;
        } else {
            //
            // This one's ok, keep it.
            //
            ++Current;
        }
    }
}



ARC_STATUS
MempCheckMapping(
    ULONG StartPage,
    ULONG NumberPages
    )
/*++

Routine Description:

    This routine makes sure all pages in the range are mapped and
    tracks the highest page used.

    X86 Only.

Arguments:

    Page - Supplies the physical page number we are starting at.


Return Value:

    None.

--*/
{
    PUCHAR p;
    ULONG EndPage;
    ULONG Entry;
    ULONG FrameNumber;
    ULONG Page;
    PHARDWARE_PTE PageTableP;
    PHARDWARE_PTE PageTableV;
    ULONG Offset;

    //
    // memory under 16MB is always mapped.
    //
    if (StartPage < _16MB) {
        return(ESUCCESS);
    }
    
    //
    // A PDE is 4MB (22 bits, so if we're in the same 4MB region, nothing to do)
    //


    EndPage = StartPage + NumberPages;

    for (Page = StartPage; Page < EndPage; Page += 1) {
        Entry = Page >> 10; 

        //
        // If the PDE entry for this page address range is not allocated,
        // then allocate and initialize the PDE entry to map the page table
        // pages for the the memory range. Otherwise, compute the address
        // of the page table pages.
        //
        if (PDE[Entry].Valid == 0) {

            //
            // Allocate and initialize two page table pages to map the specified
            // page into physical memory.
            //
            p = BlAllocateHeapAligned(PAGE_SIZE*3);
            if (p==NULL) {
                return(ENOMEM);
            }

            PageTableP = (PHARDWARE_PTE)PAGE_ALIGN((ULONG)p+PAGE_SIZE-1);
            RtlZeroMemory(PageTableP, PAGE_SIZE);
            FrameNumber = ((ULONG)PageTableP & ~KSEG0_BASE) >> PAGE_SHIFT;
            PDE[Entry].Valid = 1;
            PDE[Entry].Write = 1;
            PDE[Entry].PageFrameNumber = FrameNumber;

            //
            // initialize a page table page to map the specified
            // page into KSEG0_BASE and ALTERNATE_BASE.
            //
            // N.B. Only one page table page is allocated since the contents
            //      for both mappings are the same.
            //
            PageTableV = (PHARDWARE_PTE)((PUCHAR)PageTableP + PAGE_SIZE);

            RtlZeroMemory(PageTableV, PAGE_SIZE);
            FrameNumber = ((ULONG)PageTableV & ~KSEG0_BASE) >> PAGE_SHIFT;
            Offset = Entry + (KSEG0_BASE >> 22);
            PDE[Offset].Valid = 1;
            PDE[Offset].Write = 1;
            PDE[Offset].PageFrameNumber = FrameNumber;

            if (BlVirtualBias) {
                Offset += (BlVirtualBias >> 22);
                PDE[Offset].Valid = 1;
                PDE[Offset].Write = 1;
                PDE[Offset].PageFrameNumber = FrameNumber;
            }

            if (Entry > HighestPde) {
                HighestPde = Entry;
            }

        } else {
            Offset = Entry + (KSEG0_BASE >> 22);
            PageTableP = (PHARDWARE_PTE)(PDE[Entry].PageFrameNumber << PAGE_SHIFT);
            PageTableV = (PHARDWARE_PTE)(PDE[Offset].PageFrameNumber << PAGE_SHIFT);
        }

        //
        // If this is not the first page in memory, then mark it valid.
        //

        if (Page != 0) {
            Offset = Page & 0x3ff;
            PageTableP[Offset].Valid = 1;
            PageTableP[Offset].Write = 1;
            PageTableP[Offset].PageFrameNumber = Page;

            PageTableV[Offset].Valid = 1;
            PageTableV[Offset].Write = 1;
            PageTableV[Offset].PageFrameNumber = Page;
        }
    }

    _asm {

        //
        // Reload cr3 to force a flush
        //

        mov eax,cr3
        mov cr3,eax
    }
    return ESUCCESS;

}

ARC_STATUS
MempSetPageZeroOverride(
    BOOLEAN Enable
    )
/*++

Routine Description:

    This routine maps or unmaps page 0.

    X86 Only.    
    
Arguments:

    Enable - specifies whether to enable or disable the mapping for this page.

Return Value:

    None.

--*/
{
    ULONG Entry;
    ULONG FrameNumber;
    PHARDWARE_PTE PageTableP;
    PHARDWARE_PTE PageTableV;
    ULONG Offset;
    const ULONG StartPage = 0;
    
    Entry = StartPage >> 10; 

    //
    // compute the address of the page table pages.
    //
    if (PDE[Entry].Valid == 0) {
        
        //
        // the pde for the pte should already be setup.
        // if it's not then we're dead.
        //
        return(ENOMEM);
        

    } else {
        Offset = Entry + (KSEG0_BASE >> 22);
        PageTableP = (PHARDWARE_PTE)(PDE[Entry].PageFrameNumber << PAGE_SHIFT);
        PageTableV = (PHARDWARE_PTE)(PDE[Offset].PageFrameNumber << PAGE_SHIFT);
    }

    Offset = StartPage & 0x3ff;

    if (PageTableP[Offset].PageFrameNumber != StartPage &&
        PageTableV[Offset].PageFrameNumber != StartPage) {
        //
        // the PTE isn't setup correctly.  Bail out.
        //
        return(ENOMEM);
    }

    PageTableP[Offset].Valid = Enable ? 1 : 0;
    PageTableV[Offset].Valid = Enable ? 1 : 0;

    _asm {

        //
        // Reload cr3 to force a flush
        //

        mov eax,cr3
        mov cr3,eax
    }
    
    return ESUCCESS;

}




//
// Convert remaing LoaderReserve (>16MB mem) to
// MemoryFirmwareTemporary for the mmgr
//
//

void
BlpRemapReserve (void)
{
    PMEMORY_ALLOCATION_DESCRIPTOR NextDescriptor;
    PLIST_ENTRY NextEntry;


    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {
           NextDescriptor = CONTAINING_RECORD(NextEntry,
                                              MEMORY_ALLOCATION_DESCRIPTOR,
                                              ListEntry);
       if ((NextDescriptor->MemoryType == LoaderReserve)) {
           NextDescriptor->MemoryType = MemoryFirmwareTemporary;
       }
       NextEntry = NextEntry->Flink;
    }

}


ARC_STATUS
BlpMarkExtendedVideoRegionOffLimits(
    VOID
    )
/*++

Routine Description:

    This routine marks the extended video memory region as permanant, so that
    the OS doesn't try to map this memory.
    
    The ntdetect.com module actually finds out the location of this region as
    well as the region size.  We read this from the memory location that 
    ntdetect put the data in.

Arguments:

    None.


Return Value:

    ARC_STATUS indicating outcome.

--*/
{
    ULONG BaseOfExtendedVideoRegionInBytes;
    ULONG SizeOfExtendedVideoRegionInBytes;
    ARC_STATUS Status;
    
    //
    // ntdetect has placed the base page and size of video rom at physical 
    // address 0x740
    //
    //
    // Before we go read this address, we have to explicitly map in page zero.
    //
    Status = MempSetPageZeroOverride(TRUE);
    if (Status != ESUCCESS) {
        return(Status);
    }
    
    //
    // read the memory.
    //
    BaseOfExtendedVideoRegionInBytes = *(PULONG)0x740;
    SizeOfExtendedVideoRegionInBytes = *(PULONG)0x744;
    
    //
    // Ok, we're done with this page.  unmap it so no one can dereference null.
    //
    Status = MempSetPageZeroOverride(FALSE);
    if (Status != ESUCCESS) {
        return(Status);
    }

    if (BaseOfExtendedVideoRegionInBytes == 0 || SizeOfExtendedVideoRegionInBytes == 0) {
        return(ESUCCESS);
    }

    if (BlLoaderBlock != NULL) {

        PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
        ULONG BasePage;
        ULONG LastPage;
        ULONG PageCount;

        BasePage = BaseOfExtendedVideoRegionInBytes >> PAGE_SHIFT;
        LastPage = (BaseOfExtendedVideoRegionInBytes + SizeOfExtendedVideoRegionInBytes - 1) >> PAGE_SHIFT;
        PageCount = LastPage - BasePage + 1;

        while ( PageCount != 0 ) {

            ULONG thisCount;

            MemoryDescriptor = BlFindMemoryDescriptor(BasePage);
            if (MemoryDescriptor == NULL) {
                break;
            }

            thisCount = PageCount;
            //
            // if we run off of this descriptor, truncate our region
            // at the end of the descriptor. 
            //
            if (BasePage + PageCount > MemoryDescriptor->BasePage + MemoryDescriptor->PageCount) {
                thisCount = (MemoryDescriptor->BasePage + MemoryDescriptor->PageCount) - BasePage;
            }

            BlGenerateDescriptor(MemoryDescriptor,
                                 MemoryFirmwarePermanent,
                                 BasePage,
                                 thisCount);

            BasePage += thisCount;
            PageCount -= thisCount;
        }

    }

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\ntsetup.c ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntsetup.c

Abstract:

    This module is the tail-end of the osloader program.  It performs all
    x86-specific allocations and setups for ntoskrnl.  osloader.c calls
    this module immediately before branching into the loaded kernel image.

Author:

    John Vert (jvert) 20-Jun-1991

Environment:


Revision History:

--*/

#include "bootx86.h"

#ifdef ARCI386
#include "stdio.h"
#include "string.h"
#include "stdlib.h"
CHAR OutputBuffer[256];
char BreakInKey;
ULONG Count;
#endif

extern PHARDWARE_PTE HalPT;
extern PHARDWARE_PTE PDE;
extern ULONG_PTR BlHeapFree;

extern ULONG PcrBasePage;
extern ULONG TssBasePage;

#define PDI_SHIFT_X86PAE 21

//
// PaeEnabled is set to TRUE when we actually transition to PAE mode.
//

BOOLEAN PaeEnabled = FALSE;

//
// PDPT is a pointer to the Page Directory Pointer Table, used to support
// PAE mode.
//

PHARDWARE_PTE_X86PAE PDPT = NULL;

//
// We need a block of memory to split the free heap that we can allocate before
// we begin cleanup
//
PMEMORY_ALLOCATION_DESCRIPTOR SplitDescriptor;


//
// So we know where to unmap to
//
extern ULONG HighestPde;

//
// Private function prototypes
//

VOID
NSFixProcessorContext(
    IN ULONG PCR,
    IN ULONG TSS
    );

VOID
NSDumpMemoryDescriptors(
    IN PLIST_ENTRY ListHead
    );

VOID
NSUnmapFreeDescriptors(
    IN PLIST_ENTRY ListHead
    );

VOID
NSDumpMemory(
    PVOID Start,
    ULONG Length
    );

VOID
NSFixMappings(
    IN PLIST_ENTRY ListHead
    );

ARC_STATUS
BlpAllocatePAETables(
    VOID
    );

PHARDWARE_PTE_X86PAE
BlpFindPAEPageDirectoryEntry(
    IN ULONG Va
    );

PHARDWARE_PTE_X86PAE
BlpFindPAEPageTableEntry(
    IN ULONG Va
    );

VOID
BlpInitializePAETables(
    VOID
    );

VOID
BlpEnablePAE(
    IN ULONG PaePhysicalAddress
    );

VOID
BlpTruncateDescriptors (
    IN ULONG HighestPage
    );


ARC_STATUS
BlSetupForNt(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )

/*++

Routine Description:

    Called by osloader to handle any processor-dependent allocations or
    setups.

Arguments:

    BlLoaderBlock - Pointer to the parameters which will be passed to
                    ntoskrnl

    EntryPoint    - Supplies the entry point for ntoskrnl.exe

Return Value:

    ESUCCESS - All setup succesfully completed.

--*/

{

    ARC_STATUS Status = ESUCCESS;
    static ULONG PCR;
    static ULONG TSS;
    ULONG i;
    HARDWARE_PTE_X86 nullpte;

    //
    // First clean up the display, meaning that any messages displayed after
    // this point cannot be DBCS. Unfortunately there are a couple of messages
    // that can be displayed in certain error paths from this point out but
    // fortunately they are extremely rare.
    //
    // Note that TextGrTerminate goes into real mode to do some of its work
    // so we really really have to call it here (see comment at bottom of
    // this routine about real mode).
    //

    TextGrTerminate();

    BlLoaderBlock->u.I386.CommonDataArea = NULL;
    BlLoaderBlock->u.I386.MachineType = MachineType;
    PCR = PcrBasePage;
    if (PCR == 0 || PCR >= _16MB) {
        BlPrint("Couldn't allocate PCR descriptor in NtProcessStartup,BlSetupForNt is failing\n");
        return(ENOMEM);
    }

    //
    // Mapped hardcoded virtual pointer to the boot processors PCR
    // The virtual pointer comes from the HAL reserved area
    //
    // First zero out any PTEs that may have already been mapped for
    // a SCSI card.
    //

    RtlZeroMemory(HalPT, PAGE_SIZE);
    _asm {
        mov     eax, cr3
        mov     cr3, eax
    }

    HalPT[(KI_USER_SHARED_DATA - 0xFFC00000) >> PAGE_SHIFT].PageFrameNumber = PCR + 1;
    HalPT[(KI_USER_SHARED_DATA - 0xFFC00000) >> PAGE_SHIFT].Valid = 1;
    HalPT[(KI_USER_SHARED_DATA - 0xFFC00000) >> PAGE_SHIFT].Write = 1;
    RtlZeroMemory((PVOID)KI_USER_SHARED_DATA, PAGE_SIZE);

    HalPT[(KIP0PCRADDRESS - 0xFFC00000) >> PAGE_SHIFT].PageFrameNumber = PCR;
    HalPT[(KIP0PCRADDRESS - 0xFFC00000) >> PAGE_SHIFT].Valid = 1;
    HalPT[(KIP0PCRADDRESS - 0xFFC00000) >> PAGE_SHIFT].Write = 1;
    PCR = KIP0PCRADDRESS;

    if (BlUsePae != FALSE) {

        //
        // Allocate the new PAE mapping structures
        //

        Status = BlpAllocatePAETables();
        if (Status != ESUCCESS) {
            goto SetupFailed;
        }

    } else {

        //
        // If we are not booting in PAE mode then truncate any memory
        // above 4G.  The parameter to BlpTruncateDescriptors() is expressed
        // in pages, and is the highest page that will be included after
        // the truncation.
        //

        BlpTruncateDescriptors( 1024 * 1024 - 1 );
    }

    //
    // use our pre-allocated space for Tss.
    //
    TSS = TssBasePage;
    if (TSS == 0 || TSS >= _16MB) {
        BlPrint("Couldn't allocate valid TSS descriptor in NtProcessStartup, BlSetupForNt is failing\n");
        return(ENOMEM);
    }
    TSS = (KSEG0_BASE | (TSS << PAGE_SHIFT)) + BlVirtualBias;

#ifdef LOADER_DEBUG

    NSDumpMemoryDescriptors(&(BlLoaderBlock->MemoryDescriptorListHead));

#endif

    //
    // Clean up the page directory and table entries.
    //
    RtlZeroMemory (&nullpte,sizeof (HARDWARE_PTE_X86));
    if (BlVirtualBias) {
        if (!BlOldKernel) {

            //
            // Blow away the 48MB from the old to the new alternate
            //
            i= OLD_ALTERNATE >> PDI_SHIFT;
            while (i < (ALTERNATE_BASE >> PDI_SHIFT)) {
                PDE[i++]= nullpte;
            }

        }

    } else {

        //
        // Remove both sets of 3GB mappings
        //
        i=(OLD_ALTERNATE) >> PDI_SHIFT;
        for (i; i < (ALTERNATE_BASE+BASE_LOADER_IMAGE) >> PDI_SHIFT; i++) {
            PDE[i]= nullpte;
        }

    }

    //
    // Allocate this before we unmap free descriptors, so we can grow the heap
    //
    SplitDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)BlAllocateHeap(
                                    sizeof(MEMORY_ALLOCATION_DESCRIPTOR));


    //
    // Do this before PAE mode.
    //
    NSUnmapFreeDescriptors(&(BlLoaderBlock->MemoryDescriptorListHead));

    _asm {
        mov     eax, cr3
        mov     cr3, eax
    }
    if (BlUsePae != FALSE) {

        // Copy the four byte page table mapping to the new eight byte
        // mapping and transition to PAE mode.
        //

        BlpInitializePAETables();
        BlpEnablePAE( (ULONG)PDPT );

        //
        // We are now in PAE mode.  The debugger looks at PaeEnabled in order
        // to correctly interpret page table entries, update that now.
        //

        PaeEnabled = TRUE;
    }


    //
    // N. B.  DO NOT GO BACK INTO REAL MODE AFTER REMAPPING THE GDT AND
    //        IDT TO HIGH MEMORY!!  If you do, they will get re-mapped
    //        back into low-memory, then UN-mapped by MmInit, and you
    //        will be completely tubed!
    //

    NSFixProcessorContext(PCR, TSS);

    NSFixMappings(&(BlLoaderBlock->MemoryDescriptorListHead));

    BlLoaderBlock->Extension->LoaderPagesSpanned=BlHighestPage+1;


    if (BlVirtualBias) {

//        BlLoaderBlock->Extension->LoaderPagesSpanned=(BASE_LOADER_IMAGE >> PAGE_SHIFT) - BlLowestPage;
        //
        // gubgub once we can relocate the GDT/IDT use the computation
        //
        BlLoaderBlock->Extension->LoaderPagesSpanned=(BASE_LOADER_IMAGE >> PAGE_SHIFT);
        if (!BlOldKernel) {
            BlVirtualBias += ((BlLowestPage) << PAGE_SHIFT);
        }
    }

    BlLoaderBlock->u.I386.VirtualBias = BlVirtualBias;

    //
    // If the system has not been biased into upper memory to allow 3gb of
    // user address space, then clear the ALTERNATE_BASE PDEs.
    //



SetupFailed:
    return Status;
}

VOID
NSFixProcessorContext(
    IN ULONG PCR,
    IN ULONG TSS
    )

/*++

Routine Description:

    This relocates the GDT, IDT, PCR, and TSS to high virtual memory space.

Arguments:

    PCR - Pointer to the PCR's location (in high virtual memory)
    TSS - Pointer to kernel's TSS (in high virtual memory)

Return Value:

    None.

--*/

{
    #pragma pack(2)
    static struct {
        USHORT Limit;
        ULONG Base;
    } GdtDef,IdtDef;
    #pragma pack(4)

    PKGDTENTRY pGdt;
    ULONG Bias = 0;


    if (BlVirtualBias != 0 ) {
       Bias = BlVirtualBias;
    }
    //
    // Kernel expects the PCR to be zero-filled on startup
    //

    RtlZeroMemory((PVOID)PCR, PAGE_SIZE);
    _asm {
        sgdt GdtDef;
        sidt IdtDef;
    }

    GdtDef.Base = (KSEG0_BASE | GdtDef.Base) + Bias;
    IdtDef.Base = (KSEG0_BASE | IdtDef.Base) + Bias;
    pGdt = (PKGDTENTRY)GdtDef.Base;

    //
    // Initialize selector that points to PCR
    //

    pGdt[6].BaseLow  = (USHORT)(PCR & 0xffff);
    pGdt[6].HighWord.Bytes.BaseMid = (UCHAR)((PCR >> 16) & 0xff);
    pGdt[6].HighWord.Bytes.BaseHi  = (UCHAR)((PCR >> 24) & 0xff);

    //
    // Initialize selector that points to TSS
    //

    pGdt[5].BaseLow = (USHORT)(TSS & 0xffff);
    pGdt[5].HighWord.Bytes.BaseMid = (UCHAR)((TSS >> 16) & 0xff);
    pGdt[5].HighWord.Bytes.BaseHi  = (UCHAR)((TSS >> 24) & 0xff);

    _asm {
        lgdt GdtDef;
        lidt IdtDef;
    }
}

VOID
NSUnmapFreeDescriptors(
    IN PLIST_ENTRY ListHead
    )

/*++

Routine Description:

    Unmaps memory which is marked as free, so it memory management will know
    to reclaim it.

Arguments:

    ListHead - pointer to the start of the MemoryDescriptorList

Return Value:

    None.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR CurrentDescriptor;
    PLIST_ENTRY CurrentLink;
    ULONG EndPage;
    ULONG FrameNumber;
    PHARDWARE_PTE PageTable;
    ULONG StartPage;
    ULONG PageVa;
    ULONG i,stoppde,Limit;
    HARDWARE_PTE_X86 nullpte;

    Limit = 0x1000000 >> PAGE_SHIFT;
    if (BlOldKernel) {
        BlpRemapReserve();
    } else {
        if (Limit < BlHighestPage) {
            Limit = BlHighestPage;
        }
    }

    CurrentLink = ListHead->Flink;
    while (CurrentLink != ListHead) {
        CurrentDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)CurrentLink;

#if 0

#define UNINIT_FILL 0x12345678

        //
        // Fill unused memory with a bogus pattern to catch problems where kernel code
        // expects uninitalized memory to be zero.
        //
        if ((CurrentDescriptor->MemoryType == LoaderFree) ||
            (CurrentDescriptor->MemoryType == LoaderReserve)) {

            if (CurrentDescriptor->BasePage + CurrentDescriptor->PageCount < Limit) {
                //
                // This descriptor should already be mapped, just fill it
                //
                RtlFillMemoryUlong((PVOID)((CurrentDescriptor->BasePage << PAGE_SHIFT) | KSEG0_BASE),
                                   CurrentDescriptor->PageCount << PAGE_SHIFT,
                                   UNINIT_FILL);
            } else {
                //
                // This descriptor is not mapped. Use the first HAL page table to map and fill each page
                //
                for (StartPage = CurrentDescriptor->BasePage;
                     StartPage < CurrentDescriptor->BasePage + CurrentDescriptor->PageCount;
                     StartPage++) {
                    HalPT[0].PageFrameNumber = StartPage;
                    HalPT[0].Valid = 1;
                    HalPT[0].Write = 1;
                    _asm {
                        mov     eax, cr3
                        mov     cr3, eax
                    }
                    RtlFillMemory((PVOID)0xFFC00000,PAGE_SIZE,UNINIT_FILL);
                }
                HalPT[0].PageFrameNumber = 0;
                HalPT[0].Valid = 0;
                HalPT[0].Write = 0;
                _asm {
                    mov     eax, cr3
                    mov     cr3, eax
                }
            }
        }


#endif


        if ( (CurrentDescriptor->MemoryType == LoaderFree) ||
             (((CurrentDescriptor->MemoryType == LoaderFirmwareTemporary) ||
               (CurrentDescriptor->MemoryType == LoaderReserve)) &&
              (CurrentDescriptor->BasePage < Limit)) ||
             (CurrentDescriptor->MemoryType == LoaderLoadedProgram) ||
             (CurrentDescriptor->MemoryType == LoaderOsloaderStack)) {

            StartPage = CurrentDescriptor->BasePage | (KSEG0_BASE >> PAGE_SHIFT);
            EndPage = CurrentDescriptor->BasePage + CurrentDescriptor->PageCount;
            if (EndPage > Limit) {
                EndPage = Limit;
            }
            EndPage |= (KSEG0_BASE >> PAGE_SHIFT);
            while(StartPage < EndPage) {

                if (PDE[StartPage >> 10].Valid != 0) {
                    FrameNumber = PDE[StartPage >> 10].PageFrameNumber;
                    PageTable= (PHARDWARE_PTE)(KSEG0_BASE | (FrameNumber << PAGE_SHIFT));
                    ((PULONG)(PageTable))[StartPage & 0x3ff] = 0;
                }
                StartPage++;
            }
        }

        CurrentLink = CurrentLink->Flink;
    }

    if (BlOldKernel) {
        return;
    }

    //
    // Unmap the PDEs too if running on a new mm
    //

    RtlZeroMemory (&nullpte,sizeof (HARDWARE_PTE_X86));
    for (i=(BlHighestPage >> 10)+1;i <= HighestPde;i++){
        PDE[i]=nullpte;
        PDE[i+(KSEG0_BASE >> PDI_SHIFT)]=nullpte;
        if (BlVirtualBias) {
            PDE[i + ((KSEG0_BASE+BlVirtualBias) >> PDI_SHIFT)] = nullpte;
        }
    }

    if (BlVirtualBias) {

        //
        //BlHighest page here is the address of the LOWEST page used, so put the
        //subtraction in the loader block and use the value for the base of the bias
        //
        i = ((BlVirtualBias|KSEG0_BASE)>> PDI_SHIFT)+1;


        stoppde = (((BlVirtualBias|KSEG0_BASE) -
                    (BASE_LOADER_IMAGE-(BlLowestPage << PAGE_SHIFT)) ) >> PDI_SHIFT)-1;


        while (i < stoppde){
            PDE[i++]=nullpte;
        }
    }


}



/*++

Routine Description:

    Fixup the mappings to be consistent.
    We need to have one at address 0 (For the valid PDE entries)
    One at KSEG0 for standard loads
    One at either ALTERNATE_BASE or OLD_ALTERNATE for /3gb systems on a
    post 5.0 or 5.0 and prior respectively


Arguments:

    None

Return Value:

    None.

--*/

VOID
NSFixMappings(
    IN PLIST_ENTRY ListHead
    )
{

    ULONG Index,Index2;
    ULONG Limit;
    ULONG Count;
    PHARDWARE_PTE_X86PAE PdePae,PdePae2;
    PMEMORY_ALLOCATION_DESCRIPTOR CurrentDescriptor;
    PLIST_ENTRY CurrentLink;
    ULONG StartPage,Bias=0,FreePage,FreeCount,OldFree;



    //
    //  Finally, go through and mark all large OsloaderHeap blocks
    //  as firmware temporary, so that MM reclaims them in phase 0
    //  (for /3gb) EXCEPT the LoaderBlock.
    //

    CurrentLink = ListHead->Flink;

    if (BlVirtualBias) {
        Bias = BlVirtualBias >> PAGE_SHIFT;
    }

    FreePage = (BlHeapFree & ~KSEG0_BASE) >> PAGE_SHIFT;

    while (CurrentLink != ListHead) {

        CurrentDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)CurrentLink;

        StartPage = CurrentDescriptor->BasePage | (KSEG0_BASE >> PAGE_SHIFT) ;
        StartPage += Bias;

        //
        // BlHeapFree is not Biased, it relies on the 2GB mapping.
        //
        if ( CurrentDescriptor->MemoryType == LoaderOsloaderHeap) {

            if ((CurrentDescriptor->BasePage <= FreePage) &&
               ((CurrentDescriptor->BasePage + CurrentDescriptor->PageCount) > FreePage + 1)) {

                FreeCount = CurrentDescriptor->PageCount;
                CurrentDescriptor->PageCount = FreePage-CurrentDescriptor->BasePage+1;

                SplitDescriptor->MemoryType= LoaderFirmwareTemporary;
                SplitDescriptor->BasePage = FreePage+1;
                SplitDescriptor->PageCount = FreeCount-CurrentDescriptor->PageCount;

                BlInsertDescriptor(SplitDescriptor);
            }
            if (PaeEnabled)  {
                PdePae = BlpFindPAEPageDirectoryEntry( StartPage << PAGE_SHIFT);
                if (PdePae->Valid == 0) {
                    CurrentDescriptor->MemoryType = LoaderFirmwareTemporary;
                }
            }else {
                if (PDE[StartPage >> 10].Valid == 0 ) {
                    CurrentDescriptor->MemoryType = LoaderFirmwareTemporary;
                }
            }


        }

        if ( (CurrentDescriptor->MemoryType == LoaderReserve)) {
            CurrentDescriptor->MemoryType = LoaderFree;
        }

        CurrentLink = CurrentLink->Flink;
    }


    _asm {
        mov     eax, cr3
        mov     cr3, eax
    }



}

//
// Temp. for debugging
//

VOID
NSDumpMemory(
    PVOID Start,
    ULONG Length
    )
{
    ULONG cnt;

    BlPrint(" %lx:\n",(ULONG)Start);
    for (cnt=0; cnt<Length; cnt++) {
        BlPrint("%x ",*((PUSHORT)(Start)+cnt));
        if (((cnt+1)%16)==0) {
            BlPrint("\n");
        }
    }
}

VOID
NSDumpMemoryDescriptors(
    IN PLIST_ENTRY ListHead
    )

/*++

Routine Description:

    Dumps a memory descriptor list to the screen.  Used for debugging only.

Arguments:

    ListHead - Pointer to the head of the memory descriptor list

Return Value:

    None.

--*/

{

    PLIST_ENTRY CurrentLink;
    PMEMORY_ALLOCATION_DESCRIPTOR CurrentDescriptor;


    CurrentLink = ListHead->Flink;
    while (CurrentLink != ListHead) {
        CurrentDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)CurrentLink;
        BlPrint("Fl = %lx    Bl = %lx  ",
                (ULONG)CurrentDescriptor->ListEntry.Flink,
                (ULONG)CurrentDescriptor->ListEntry.Blink
               );
        BlPrint("Type %x  Base %lx  Pages %lx\n",
                (USHORT)(CurrentDescriptor->MemoryType),
                CurrentDescriptor->BasePage,
                CurrentDescriptor->PageCount
               );
        CurrentLink = CurrentLink->Flink;
    }
    while (!GET_KEY()) { // DEBUG ONLY!
    }

}

ULONG
BlpCountPAEPagesToMapX86Page(
    PHARDWARE_PTE_X86 PageTable
    )

/*++

Routine Description:

    Called to prepare the conversion of 4-byte PTEs to 8-byte PAE PTEs, this
    routine returns the number of 8-byte page tables that will be required
    to map the contents of this 4-byte page table.

    Because an 8-byte page table has half the number of entries as a 4-byte
    page table, the answer will be 0, 1 or 2.

Arguments:

    PageTable - Pointer to a 4-byte page table.

Return Value:

    The number of 8-byte page tables required to map the contents of this
    4-byte page table.

--*/

{
    PHARDWARE_PTE_X86 pageTableEntry;
    ULONG chunkIndex;
    ULONG pageTableIndex;
    ULONG newPageTableCount;

    //
    // PAE page tables contain fewer PTEs than regular page tables do.
    //
    // Examine the page table in chunks, where each chunk contains the PTEs
    // that represent an entire PAE page table.
    //

    newPageTableCount = 0;
    for (chunkIndex = 0;
         chunkIndex < PTE_PER_PAGE_X86;
         chunkIndex += PTE_PER_PAGE_X86PAE) {

        for (pageTableIndex = 0;
             pageTableIndex < PTE_PER_PAGE_X86PAE;
             pageTableIndex++) {

            pageTableEntry = &PageTable[ chunkIndex + pageTableIndex ];
            if (pageTableEntry->Valid) {

                //
                // One or more PTEs are valid in this chunk, record
                // the fact that a new page table will be needed to map
                // them and skip to the next chunk.
                //

                newPageTableCount++;
                break;
            }
        }
    }
    return newPageTableCount;
}

VOID
BlpCopyX86PteToPAEPte(
    IN  PHARDWARE_PTE_X86 OldPte,
    OUT PHARDWARE_PTE_X86PAE NewPte
    )
/*++

Routine Description:

    Copies the contents of a 4-byte PTE to an 8-byte PTE, with the exception
    of the PageFrameNumber field.

Arguments:

    OldPte - Pointer to the source 4-byte PTE.

    NewPte - Pointer to the destination 8-byte PTE.

Return Value:

    None.

--*/

{
    NewPte->Valid           = OldPte->Valid;
    NewPte->Write           = OldPte->Write;
    NewPte->Owner           = OldPte->Owner;
    NewPte->WriteThrough    = OldPte->WriteThrough;
    NewPte->CacheDisable    = OldPte->CacheDisable;
    NewPte->Accessed        = OldPte->Accessed;
    NewPte->Dirty           = OldPte->Dirty;
    NewPte->LargePage       = OldPte->LargePage;
    NewPte->Global          = OldPte->Global;
}

PHARDWARE_PTE_X86PAE
BlpFindPAEPageDirectoryEntry(
    IN ULONG Va
    )

/*++

Routine Description:

    Given a virtual address, locates and returns a pointer to the appropriate
    8-byte Page Directory Entry.

Arguments:

    Va - Virtual Address for which a PDE pointer is desired.

Return Value:

    Pointer to the page directory entry for the supplied Va.

--*/

{
    PHARDWARE_PTE_X86PAE directoryPointerTableEntry;
    PHARDWARE_PTE_X86PAE pageDirectoryEntry;
    PHARDWARE_PTE_X86PAE pageDirectory;
    ULONG pageDirectoryIndex;
    ULONG directoryPointerTableIndex;

    //
    // Get a pointer to the directory pointer table entry
    //

    directoryPointerTableIndex = PP_INDEX_PAE( Va );
    directoryPointerTableEntry = &PDPT[ directoryPointerTableIndex ];

    //
    // Get a pointer to the page directory entry
    //

    pageDirectory = PAGE_FRAME_FROM_PTE( directoryPointerTableEntry );
    pageDirectoryIndex = PD_INDEX_PAE( Va );
    pageDirectoryEntry = &pageDirectory[ pageDirectoryIndex ];

    return pageDirectoryEntry;
}

PHARDWARE_PTE_X86PAE
BlpFindPAEPageTableEntry(
    IN ULONG Va
    )

/*++

Routine Description:

    Given a virtual address, locates and returns a pointer to the appropriate
    8-byte Page Table Entry.

Arguments:

    Va - Virtual Address for which a PTE pointer is desired.

Return Value:

    Pointer to the page directory entry for the supplied Va.

--*/

{
    PHARDWARE_PTE_X86PAE pageDirectoryEntry;
    PHARDWARE_PTE_X86PAE pageTableEntry;
    PHARDWARE_PTE_X86PAE pageTable;
    ULONG pageTableIndex;

    //
    // Get a pointer to the page directory entry
    //

    pageDirectoryEntry = BlpFindPAEPageDirectoryEntry( Va );
    ASSERT( pageDirectoryEntry->Valid != 0 );

    //
    // Get a pointer to the page table entry
    //

    pageTable = PAGE_FRAME_FROM_PTE( pageDirectoryEntry );
    pageTableIndex = PT_INDEX_PAE( Va );
    pageTableEntry = &pageTable[ pageTableIndex ];

    return pageTableEntry;
}

VOID
BlpMapAddress(
    IN ULONG Va,
    IN PHARDWARE_PTE_X86 OldPageDirectoryEntry,
    IN PHARDWARE_PTE_X86 OldPageTableEntry,
    IN OUT PULONG NextFreePage
    )

/*++

Routine Description:

    Worker function used during the conversion of a two-level, 4-byte mapping
    structure to the three-level, 8-byte mapping structure required for PAE
    mode.

    Maps VA to the physical address referenced by OldPageTableEntry, allocating
    a new page table if necessary.

Arguments:

    Va - Virtual Address for this mapping.

    OldPageDirectoryEntry - Pointer to the existing, 4-byte PDE.

    OldPageTableEntry - Pointer to the existing, 4-byte PTE.

    NextFreePage - Pointer to the physical page number of the next free
        page in our private page pool.

Return Value:

    None.

--*/

{
    PHARDWARE_PTE_X86PAE pageDirectoryEntry;
    PHARDWARE_PTE_X86PAE directoryPointerTableEntry;
    PHARDWARE_PTE_X86PAE  pageTable;
    PHARDWARE_PTE_X86PAE  pageTableEntry;
    ULONG pageFrameNumber;
    ULONG directoryPointerTableIndex;
    ULONG pageTableVa;

    //
    // Ignore recursive mappings that exist in the old page table
    // structure, we set those up as we go.
    //

    if ((Va >= PTE_BASE) && (Va < (PDE_BASE_X86 + PAGE_SIZE))) {
        return;
    }

    //
    // Get a pointer to the page directory entry
    //

    pageDirectoryEntry = BlpFindPAEPageDirectoryEntry( Va );

    //
    // If the page table for this PTE isn't present yet, allocate one and
    // copy over the old page directory attributes.
    //

    if (pageDirectoryEntry->Valid == 0) {

        pageFrameNumber = *NextFreePage;
        *NextFreePage += 1;

        BlpCopyX86PteToPAEPte( OldPageDirectoryEntry, pageDirectoryEntry );
        pageDirectoryEntry->PageFrameNumber = pageFrameNumber;

        //
        // Check the recursive mapping for this page table
        //

        pageTableVa = PTE_BASE +
                      (Va / PAGE_SIZE) * sizeof(HARDWARE_PTE_X86PAE);

        pageTableEntry = BlpFindPAEPageTableEntry( pageTableVa );

        if (pageTableEntry->Valid == 0) {
            DbgBreakPoint();
        }

        if (pageTableEntry->PageFrameNumber != pageFrameNumber) {
            DbgBreakPoint();
        }
    }

    //
    // Get a pointer to the page table entry
    //

    pageTableEntry = BlpFindPAEPageTableEntry( Va );
    if (pageTableEntry->Valid != 0) {
        DbgBreakPoint();
    }

    //
    // Propogate the PTE page and attributes.
    //

    BlpCopyX86PteToPAEPte( OldPageTableEntry, pageTableEntry );
    pageTableEntry->PageFrameNumber = OldPageTableEntry->PageFrameNumber;
}

VOID
BlpInitializePAETables(
    VOID
    )

/*++

Routine Description:

    Allocates a new, three-level, 8-byte PTE mapping structure and duplicates
    in it the mapping described by the existing 4-byte PTE mapping structure.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PHARDWARE_PTE_X86 pageDirectory;
    ULONG pageDirectoryIndex;
    ULONG va;
    ULONG physAddress;
    PHARDWARE_PTE_X86 pageDirectoryEntry;
    PHARDWARE_PTE_X86 pageTableEntry;
    PHARDWARE_PTE_X86 pageTable;
    PHARDWARE_PTE_X86PAE paeDirectoryEntry;
    PHARDWARE_PTE_X86PAE paeTableEntry;
    ULONG directoryPointerIndex;
    ULONG nextFreePage;
    ULONG i;
    ULONG pageTableIndex;
    ULONG pageDirectoryVa;
    ULONG pageTableVa;
    ULONGLONG pageFrameNumber;

    nextFreePage = ((ULONG)PDPT) >> PAGE_SHIFT;

    //
    // Initialize the page directory pointer table to reference the four
    // page directories.
    //

    nextFreePage++;
    for (i = 0; i < 4; i++) {

        PDPT[i].PageFrameNumber = nextFreePage;
        PDPT[i].Valid = 1;
        nextFreePage++;
    }

    //
    // Set up the recursive mapping: first the PDE.
    //

    directoryPointerIndex = PDE_BASE_X86PAE >> PPI_SHIFT_X86PAE;
    pageFrameNumber = PDPT[ directoryPointerIndex ].PageFrameNumber;
    paeDirectoryEntry = (PHARDWARE_PTE_X86PAE)(pageFrameNumber << PAGE_SHIFT);

    for (i = 0; i < 4; i++) {

        paeDirectoryEntry->PageFrameNumber = PDPT[i].PageFrameNumber;
        paeDirectoryEntry->Valid = 1;
        paeDirectoryEntry->Write = 1;

        paeDirectoryEntry++;
    }


    for (pageDirectoryIndex = 0;
         pageDirectoryIndex < PTE_PER_PAGE_X86;
         pageDirectoryIndex++) {

        pageDirectoryEntry = &PDE[pageDirectoryIndex];
        if (pageDirectoryEntry->Valid == 0) {
            continue;
        }

        pageTable = PAGE_FRAME_FROM_PTE( pageDirectoryEntry );
        for (pageTableIndex = 0;
             pageTableIndex < PTE_PER_PAGE_X86;
             pageTableIndex++) {

            pageTableEntry = &pageTable[pageTableIndex];
            if (pageTableEntry->Valid == 0) {
                continue;
            }

            va = (pageDirectoryIndex << PDI_SHIFT_X86) +
                 (pageTableIndex << PTI_SHIFT);

            //
            // We have a physical address and a va, update the new mapping.
            //

            BlpMapAddress( va,
                           pageDirectoryEntry,
                           pageTableEntry,
                           &nextFreePage );
        }
    }

    //
    // Finally, set up the PDE for the second of two HAL common buffer page
    // tables.
    //

    paeDirectoryEntry =
        BlpFindPAEPageDirectoryEntry( 0xFFC00000 + (1 << PDI_SHIFT_X86PAE) );

    paeDirectoryEntry->Valid = 1;
    paeDirectoryEntry->Write = 1;
    paeDirectoryEntry->PageFrameNumber = nextFreePage;

    nextFreePage += 1;
}

ARC_STATUS
BlpAllocatePAETables(
    VOID
    )

/*++

Routine Description:

    Calculates the number of pages required to contain an 8-byte mapping
    structure to duplicate the existing 4-byte mapping structure.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG cr3;
    ULONG pageTableBlockSize;
    ULONG pageDirectoryIndex;
    ULONG pageTableIndex;
    ULONG oldPageTableCount;
    PHARDWARE_PTE_X86 pageDirectoryEntry;
    PHARDWARE_PTE_X86 pageTable;
    PHARDWARE_PTE_X86 pageTableEntry;
    PHARDWARE_PTE_X86PAE pageDirectoryPointerTable;
    ULONG chunkIndex;
    ULONG status;
    ULONG pageBase;
    ULONG newPageTableCount;
    ULONG allocationSize;
    PVOID blockPtr;

    //
    // Find out how many page tables we are going to need by examining the
    // existing page table entries.
    //

    newPageTableCount = 0;

    for (pageDirectoryIndex = 0;
         pageDirectoryIndex < PTE_PER_PAGE_X86;
         pageDirectoryIndex++) {

        pageDirectoryEntry = &PDE[pageDirectoryIndex];
        if (pageDirectoryEntry->Valid != 0) {

            pageTable = PAGE_FRAME_FROM_PTE( pageDirectoryEntry );

            //
            // For each valid page table, scan the PTEs in chunks, where
            // a chunk represents the PTEs that will reside in a PAE page
            // table.
            //

            newPageTableCount += BlpCountPAEPagesToMapX86Page( pageTable );
        }
    }

    //
    // Include a page for the second HAL page table.  This won't get
    // included automatically in the conversion count because it doesn't
    // currently contain any valid page table entries.
    //

    newPageTableCount += 1;

    //
    // Include a page for each of four page directories and the page
    // directory pointer table, then allocate the pages.
    //

    newPageTableCount += 5;

    status = BlAllocateDescriptor( LoaderMemoryData,
                                   0,
                                   newPageTableCount,
                                   &pageBase );
    if (status != ESUCCESS) {
        DbgPrint("BlAllocateDescriptor failed!\n");
        return status;
    }

    allocationSize = newPageTableCount << PAGE_SHIFT;
    pageDirectoryPointerTable =
        (PHARDWARE_PTE_X86PAE)PAGE_TO_VIRTUAL( pageBase );

    RtlZeroMemory( pageDirectoryPointerTable, allocationSize );

    //
    // Set the global PDPT, we're done.
    //

    PDPT = pageDirectoryPointerTable;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\pae.asm ===
;++
;
;Copyright (c) 1998  Microsoft Corporation
;
;Module Name:
;
;    pae.asm
;
;Abstract:
;
;    Contains routines to aid in enabling PAE mode.
;
;Author:
;
;    Forrest Foltz (forrestf) 12-28-98
;
;
;Revision History:
;
;--


.586p
        .xlist
include ks386.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

EFLAGS_ID	equ 	200000h

;++
;
; BOOLEAN
; BlpPaeSupported (
;     VOID
; )
;
; Routine Description:
;
;  	  This routine determines whether the CPU supports PAE mode
;
; Arguments:
;
;     None.
;
; Return value:
;
;     al == 1 if the CPU does support PAE mode.
;     al == 0 if not.
;
;--

public _BlpPaeSupported@0
_BlpPaeSupported@0 proc

	;
	; First determine whether the CPUID instruction is supported.  If
	; the EFLAGS_ID bit "sticks" when stored in the flags register, then
	; the CPUID instruction is supported.
	;

	mov	ecx, EFLAGS_ID
	pushfd
	pop	eax		; eax == flags
	xor	ecx, eax	; ecx == flags ^ EFLAGS_ID
	push	ecx
	popfd			; load new flags
	pushfd
	pop	ecx		; ecx == result of flag load
	xor	eax, ecx	; Q: did the EFLAGS_ID bit stick?
	jz	done            ; N: CPUID is not available

	;
	; We can use the CPUID instruction.
	;

	push	ebx		; CPUID steps on eax, ebx, ecx, edx
	mov	eax, 1
	cpuid
	pop	ebx

	;
	; edx contains the feature bits.  Bit 6 is the PAE extensions flag.
	;

	sub	eax, eax	; assume not set
	test	dl, 40h		; Q: bit 6 set?
	jz	done		; N: return with eax == 0
	inc	eax		; Y: set eax == 1
done:   ret

_BlpPaeSupported@0 endp

;++
;
; VOID
; BlSetPae (
;     IN ULONG IdentityAddress,
;     IN ULONG PaeCr3 
; )
;
; Routine Description:
;
;  Arguments:
;
;  Return
;
;--

public _BlpEnablePAE@4
_BlpEnablePAE@4 proc

	;
	; Load PDPT address
	;

	mov	edx, [esp]+4

	;
	; Do this to set the state machine in motion
	;

	mov	ecx, cr3
	mov	cr3, ecx

	;
	; Disable paging
	;

	mov	eax, cr0
	and	eax, NOT CR0_PG
	mov	cr0, eax
	jmp	$+2

	;
	; Enable physical address extensions
	;

	mov	eax, cr4
	or	eax, CR4_PAE

	;
	; The following instruction was necessary in order to boot some
	; machines.  Probably due to an errata.
	;

	mov	ecx, cr3
	mov	cr4, eax

	;
	; Point cr3 to the page directory pointer table
	; 

	mov	cr3, edx

	;
	; Enable paging
	;

	mov	ecx, cr0
	or	ecx, CR0_PG
	mov	cr0, ecx
	jmp	$+2

	;
	; Clean the stack and return
	;

_BlpEnablePAEEnd:
	ret	4


_BlpEnablePAE@4 endp

_TEXT	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\misc.asm ===
;++
;
;Copyright (c) 2001  Microsoft Corporation
;
;Module Name:
;
;    misc.asm
;
;Abstract:
;
;
;Author:
;
;   Chuck Lenzmeier (chuckl) 27-May-2001
;
;Revision History:
;
;   Two routines moved from wakea.asm
;--


.586p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros

_TEXT   SEGMENT PARA PUBLIC 'CODE'       ; Start 32 bit code
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cPublicProc  _ENABLE_PSE,0
        mov     eax, cr4
        or      eax, CR4_PSE
        mov     cr4, eax
        stdRET _ENABLE_PSE
stdENDP _ENABLE_PSE


cPublicProc  _FLUSH_TB,0
        mov     eax, cr3
        mov     cr3, eax
        stdRET _FLUSH_TB
stdENDP _FLUSH_TB

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\port.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This modules implements com port code to support reading/writing from com ports.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

--*/

#include "bldr.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "ntverp.h"
#include "acpitabl.h"

#ifdef _IA64_
#include "bldria64.h"
#endif


//
// Headless Port information.
//
ULONG   BlTerminalDeviceId = 0;
BOOLEAN BlTerminalConnected = FALSE;
ULONG   BlTerminalDelay = 0;

HEADLESS_LOADER_BLOCK LoaderRedirectionInformation;




//
// Define COM Port registers.
//
#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_FCR     0x02            // FIFO Control Register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

//
// This bit controls the loopback testing mode of the device. Basically
// the outputs are connected to the inputs (and vice versa).
//

#define SERIAL_MCR_LOOP     0x10

//
// This bit is used for general purpose output.
//

#define SERIAL_MCR_OUT1     0x04

//
// This bit contains the (complemented) state of the clear to send
// (CTS) line.
//

#define SERIAL_MSR_CTS      0x10

//
// This bit contains the (complemented) state of the data set ready
// (DSR) line.
//

#define SERIAL_MSR_DSR      0x20

//
// This bit contains the (complemented) state of the ring indicator
// (RI) line.
//

#define SERIAL_MSR_RI       0x40

//
// This bit contains the (complemented) state of the data carrier detect
// (DCD) line.
//

#define SERIAL_MSR_DCD      0x80

typedef struct _CPPORT {
    PUCHAR Address;
    ULONG Baud;
    USHORT Flags;
} CPPORT, *PCPPORT;

#define PORT_DEFAULTRATE    0x0001      // baud rate not specified, using default
#define PORT_MODEMCONTROL   0x0002      // using modem controls

//
// Define wait timeout value.
//

#define TIMEOUT_COUNT 1024 * 200


extern
VOID
FwStallExecution(
    IN ULONG Microseconds
    );

//
// Routines for reading/writing bytes out to the UART.
//
UCHAR
(*READ_UCHAR)(
    IN PUCHAR Addr
    );

VOID
(*WRITE_UCHAR)(
    IN PUCHAR Addr,
    IN UCHAR  Value
    );


//
// Define COM Port function prototypes.
//

VOID
CpInitialize (
    PCPPORT Port,
    PUCHAR Address,
    ULONG Rate
    );

VOID 
CpEnableFifo(
    IN PUCHAR   Address,
    IN BOOLEAN  bEnable
    );

LOGICAL
CpDoesPortExist(
    IN PUCHAR Address
    );

UCHAR
CpReadLsr (
    IN PCPPORT Port,
    IN UCHAR Waiting
    );

VOID
CpSetBaud (
    PCPPORT Port,
    ULONG Rate
    );

USHORT
CpGetByte (
    PCPPORT Port,
    PUCHAR Byte,
    BOOLEAN WaitForData,
    BOOLEAN PollOnly
    );

VOID
CpPutByte (
    PCPPORT Port,
    UCHAR Byte
    );

//
// Define debugger port initial state.
//

CPPORT Port[4] = {
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE}
                 };

//
// This is how we find table information from
// the ACPI table index.
//
extern PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    );



//
// We'll use these to fill in some function pointers,
// which in turn will be used to read/write from the
// UART.  We can't simply assign the function pointers
// to point to READ_PORT_UCHAR/READ_REGISTER_UCHAR and
// WRITE_PORT_UCHAR/WRITE_REGISTER_UCHAR, because in
// the case of IA64, some of these functions are macros.
//
// To get around this, build these dummy functions that
// will inturn simply call the correct READ/WRITE functions/macros.
//
UCHAR
MY_READ_PORT_UCHAR( IN PUCHAR Addr )
{
    return( READ_PORT_UCHAR(Addr) );
}

UCHAR
MY_READ_REGISTER_UCHAR( IN PUCHAR Addr )
{
    return( READ_REGISTER_UCHAR(Addr) );
}


VOID
MY_WRITE_PORT_UCHAR( IN PUCHAR Addr, IN UCHAR  Value )
{
    WRITE_PORT_UCHAR(Addr, Value);
}

VOID
MY_WRITE_REGISTER_UCHAR( IN PUCHAR Addr, IN UCHAR  Value )
{
    WRITE_REGISTER_UCHAR(Addr, Value);
}




LOGICAL
BlRetrieveBIOSRedirectionInformation(
    VOID
    )

/*++

Routine Description:

    This functions retrieves the COM port information from the ACPI
    table.

Arguments:

    We'll be filling in the LoaderRedirectionInformation structure.

Returned Value:

    TRUE - If a debug port is found.

--*/

{

    PDEBUG_PORT_TABLE pPortTable = NULL;
    PUCHAR      CurrentAddress = NULL;
    UCHAR       Checksum;
    ULONG       i;
    ULONG       CheckLength;

    pPortTable = (PDEBUG_PORT_TABLE)BlFindACPITable( "SPCR",
                                                     sizeof(DEBUG_PORT_TABLE) );

    if( pPortTable ) {

        //
        // generate a checksum for later validation.
        //
        CurrentAddress = (PUCHAR)pPortTable;
        CheckLength = pPortTable->Header.Length;
        Checksum = 0;
        for( i = 0; i < CheckLength; i++ ) {
            Checksum += CurrentAddress[i];
        }


        if(
                                                // checksum is okay?
            (Checksum == 0) &&

                                                // device address defined?
            ((UCHAR UNALIGNED *)pPortTable->BaseAddress.Address.LowPart != (UCHAR *)NULL) &&

                                                // he better be in system or memory I/O
                                                // note: 0 - systemI/O
                                                //       1 - memory mapped I/O
            ((pPortTable->BaseAddress.AddressSpaceID == 0) ||
             (pPortTable->BaseAddress.AddressSpaceID == 1))

         ) {


            if( pPortTable->BaseAddress.AddressSpaceID == 0 ) {
                LoaderRedirectionInformation.IsMMIODevice = TRUE;
            } else {
                LoaderRedirectionInformation.IsMMIODevice = FALSE;
            }


            //
            // We got the table.  Now dig out the information we want.
            // See definitiion of DEBUG_PORT_TABLE (acpitabl.h)
            //
            LoaderRedirectionInformation.UsedBiosSettings = TRUE;
            LoaderRedirectionInformation.PortNumber = 3;
            LoaderRedirectionInformation.PortAddress = (UCHAR UNALIGNED *)(pPortTable->BaseAddress.Address.LowPart);

            if( pPortTable->BaudRate == 7 ) {
                LoaderRedirectionInformation.BaudRate = BD_115200;
            } else if( pPortTable->BaudRate == 6 ) {
                LoaderRedirectionInformation.BaudRate = BD_57600;
            } else if( pPortTable->BaudRate == 4 ) {
                LoaderRedirectionInformation.BaudRate = BD_19200;
            } else {
                LoaderRedirectionInformation.BaudRate = BD_9600;
            }

            LoaderRedirectionInformation.Parity = pPortTable->Parity;
            LoaderRedirectionInformation.StopBits = pPortTable->StopBits;
            LoaderRedirectionInformation.TerminalType = pPortTable->TerminalType;

            //
            // If this is a new DEBUG_PORT_TABLE, then it's got the PCI device
            // information.
            //
            if( pPortTable->Header.Length >= sizeof(DEBUG_PORT_TABLE) ) {

                LoaderRedirectionInformation.PciDeviceId = (USHORT UNALIGNED)pPortTable->PciDeviceId;
                LoaderRedirectionInformation.PciVendorId = (USHORT UNALIGNED)pPortTable->PciVendorId;
                LoaderRedirectionInformation.PciBusNumber = (UCHAR)pPortTable->PciBusNumber;
                LoaderRedirectionInformation.PciSlotNumber = (UCHAR)pPortTable->PciSlotNumber;
                LoaderRedirectionInformation.PciFunctionNumber = (UCHAR)pPortTable->PciFunctionNumber;
                LoaderRedirectionInformation.PciFlags = (ULONG UNALIGNED)pPortTable->PciFlags;
            } else {

                //
                // There's no PCI device information in this table.
                //
                LoaderRedirectionInformation.PciDeviceId = (USHORT)0xFFFF;
                LoaderRedirectionInformation.PciVendorId = (USHORT)0xFFFF;
                LoaderRedirectionInformation.PciBusNumber = 0;
                LoaderRedirectionInformation.PciSlotNumber = 0;
                LoaderRedirectionInformation.PciFunctionNumber = 0;
                LoaderRedirectionInformation.PciFlags = 0;
            }

            return TRUE;

        }

    }

    return FALSE;

}



LOGICAL
BlPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    IN PUCHAR PortAddress OPTIONAL,
    IN BOOLEAN ReInitialize,
    OUT PULONG BlFileId
    )

/*++

Routine Description:

    This functions initializes the com port.

Arguments:

    BaudRate - Supplies an optional baud rate.

    PortNumber - supplies an optinal port number.

    ReInitialize - Set to TRUE if we already have this port open, but for some
        reason need to completely reset the port.  Otw it should be FALSE.

    BlFileId - A place to store a fake file Id, if successful.

Returned Value:

    TRUE - If a debug port is found, and BlFileId will point to a location within Port[].

--*/

{


    //
    // Make guesses on any inputs that we didn't get.
    //
    if( BaudRate == 0 ) {
        BaudRate = BD_19200;
    }

    if( PortNumber == 0 ) {

        //
        // Try COM2, then COM1
        //
        if (CpDoesPortExist((PUCHAR)COM2_PORT)) {
            PortNumber = 2;
            PortAddress = (PUCHAR)COM2_PORT;

        } else if (CpDoesPortExist((PUCHAR)COM1_PORT)) {
            PortNumber = 1;
            PortAddress = (PUCHAR)COM1_PORT;
        } else {
            return FALSE;
        }
    }


    //
    // If the user didn't send us a port address, then
    // guess based on the COM port number.
    //
    if( PortAddress == 0 ) {

        switch (PortNumber) {
            case 1:
                PortAddress = (PUCHAR)COM1_PORT;
                break;

            case 2:
                PortAddress = (PUCHAR)COM2_PORT;
                break;

            case 3:
                PortAddress = (PUCHAR)COM3_PORT;
                break;

            default:
                PortNumber = 4;
                PortAddress = (PUCHAR)COM4_PORT;
        }

    }


    //
    // we need to handle the case where we're dealing with
    // MMIO space (as opposed to System I/O space).
    //
    if( LoaderRedirectionInformation.IsMMIODevice ) {
        PHYSICAL_ADDRESS    PhysAddr;
        PVOID               MyPtr;

        PhysAddr.LowPart = PtrToUlong(PortAddress);
        PhysAddr.HighPart = 0;

        MyPtr = MmMapIoSpace(PhysAddr,(1+COM_MSR),TRUE);
        PortAddress = MyPtr;

        READ_UCHAR = MY_READ_REGISTER_UCHAR;
        WRITE_UCHAR = MY_WRITE_REGISTER_UCHAR;

    } else {

        // System IO space.
        READ_UCHAR = MY_READ_PORT_UCHAR;
        WRITE_UCHAR = MY_WRITE_PORT_UCHAR;
    }



    //
    // See if the port even exists...
    //
    if (!CpDoesPortExist(PortAddress)) {
        if( LoaderRedirectionInformation.IsMMIODevice == FALSE ) {

            //
            // Don't fail on this if this is a headless MMIO device.
            // Hack required for HP.
            //
            return FALSE;
        }
    }



    //
    // Check if the port is already in use, and this is a first init.
    //
    if (!ReInitialize && (Port[PortNumber-1].Address != NULL)) {
        return FALSE;
    }



    //
    // Check if someone tries to reinit a port that is not open.
    //
    if (ReInitialize && (Port[PortNumber-1].Address == NULL)) {
        return FALSE;
    }



    //
    // Initialize the specified port.
    //
    CpInitialize(&(Port[PortNumber-1]),
                 PortAddress,
                 BaudRate);



    *BlFileId = (PortNumber-1);
    return TRUE;
}

VOID
BlLoadGUID(
    VOID
    )

/*++

Routine Description:

    Attempt to find the System GUID.  If we find it, load it into
    the LoaderRedirectionInformation structure.

Arguments:

    None.

Return Value:

    None.

--*/

{
#include <smbios.h>
#include <wmidata.h>

PUCHAR      CurrentAddress = NULL;
PUCHAR      EndingAddress = NULL;
UCHAR       Checksum;
ULONG       i;
ULONG       CheckLength;
BOOLEAN     FoundIt = FALSE;
PSYSID_UUID_ENTRY   UuidEntry = NULL;


    CurrentAddress = (PUCHAR)SYSID_EPS_SEARCH_START;
    EndingAddress = CurrentAddress + SYSID_EPS_SEARCH_SIZE;

    while( CurrentAddress < EndingAddress ) {

        UuidEntry = (PSYSID_UUID_ENTRY)CurrentAddress;

        if( memcmp(UuidEntry->Type, SYSID_TYPE_UUID, 0x6) == 0 ) {

            //
            // See if the checksum matches too.
            //
            CheckLength = UuidEntry->Length;
            Checksum = 0;
            for( i = 0; i < CheckLength; i++ ) {
                Checksum += CurrentAddress[i];
            }

            if( Checksum == 0 ) {
                FoundIt = TRUE;

                RtlCopyMemory( &LoaderRedirectionInformation.SystemGUID,
                               UuidEntry->UUID,
                               sizeof(GUID) );

                break;

            }

        }

        CurrentAddress++;

    }


    if( !FoundIt ) {
        RtlZeroMemory( &LoaderRedirectionInformation.SystemGUID,
                       sizeof(SYSID_UUID) );
    }

    return;
}

VOID
BlEnableFifo(
    IN ULONG    DeviceId,
    IN BOOLEAN  bEnable
    )
/*++

Routine Description:

    This routine will attempt to enable the FIFO in the 16550 UART.
    Note that the behaviour is undefined for the 16450, but practically,
    this should have no effect.

Arguments:

    DeviceId - Value returned by BlPortInitialize()
    bEnable  - if TRUE, FIFO is enabled
               if FALSE, FIFO  is disabled
                 
Return Value:

    None

--*/
{
    CpEnableFifo(
        Port[DeviceId].Address,
        bEnable
        );
}

VOID
BlInitializeHeadlessPort(
    VOID
    )

/*++

Routine Description:

    Does x86-specific initialization of a dumb terminal connected to a serial port.  Currently,
    it assumes baud rate and com port are pre-initialized, but this can be changed in the future
    by reading the values from boot.ini or someplace.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG   i;
    PUCHAR  TmpBuffer;


    if( (LoaderRedirectionInformation.PortNumber == 0) ||
        !(LoaderRedirectionInformation.PortAddress) ) {

        //
        // This means that no one has filled in the LoaderRedirectionInformation
        // structure, which means that we aren't redirecting right now.
        // See if the BIOS was redirecting.  If so, pick up those settings
        // and use them.
        //

        BlRetrieveBIOSRedirectionInformation();


    }

    if( LoaderRedirectionInformation.PortNumber ) {


        //
        // We really need to make sure there's an address associated with
        // this port and not just a port number.
        //
        if( LoaderRedirectionInformation.PortAddress == NULL ) {

            switch( LoaderRedirectionInformation.PortNumber ) {

                case 4:
                    LoaderRedirectionInformation.PortAddress = (PUCHAR)COM4_PORT;
                    break;

                case 3:
                    LoaderRedirectionInformation.PortAddress = (PUCHAR)COM3_PORT;
                    break;

                case 2:
                    LoaderRedirectionInformation.PortAddress = (PUCHAR)COM2_PORT;
                    break;

                case 1:
                default:
                    LoaderRedirectionInformation.PortAddress = (PUCHAR)COM1_PORT;
                    break;
            }

        }


        //
        // Either we just created a LoaderRedirectionInformation, or it was
        // built before we ever got into this function.  Either way, we should
        // go try and initialize the port he wants to talk through.
        //

        BlTerminalConnected = (BOOLEAN)BlPortInitialize(LoaderRedirectionInformation.BaudRate,
                                                        LoaderRedirectionInformation.PortNumber,
                                                        LoaderRedirectionInformation.PortAddress,
                                                        BlTerminalConnected,
                                                        &BlTerminalDeviceId);
        
        if (BlIsTerminalConnected()) {


            //
            // Enable the FIFO on the UART so we reduce the chance of a character
            // getting dropped.
            //
            BlEnableFifo(
                BlTerminalDeviceId,
                TRUE
                );


            //
            // Go get the machine's GUID.
            //
            BlLoadGUID();


            //
            // Figure time to delay based on baudrate.  Note: we do this calculation
            // to be at 60% of the baud rate because it appears that FwStallExecution
            // is extremely inaccurate, and that if we dont go slow enough a lot of
            // screen attributes being sent in a row causes a real vt100 to drop
            // characters that follows as it repaints/clears/whatever the screen.
            //
            if( LoaderRedirectionInformation.BaudRate == 0 ) {
                LoaderRedirectionInformation.BaudRate = BD_9600;
            }
            BlTerminalDelay = LoaderRedirectionInformation.BaudRate;
            BlTerminalDelay = BlTerminalDelay / 10;        // 10 bits per character (8-1-1) is the max.
            BlTerminalDelay = ((1000000 / BlTerminalDelay) * 10) / 6; // 60% speed.


            //
            // Make sure there are no stale attributes on the terminal
            // sitting at the other end of our headless port.
            //
            // <CSI>m  (turn attributes off)
            TmpBuffer = "\033[m";
            for( i = 0; i < strlen(TmpBuffer); i++ ) {
                BlPortPutByte( BlTerminalDeviceId, TmpBuffer[i]);
                FwStallExecution(BlTerminalDelay);
            }



        } else {

            //
            // Make sure we don't have any redirection information
            // hanging around if we didn't pass BlIsTerminalConnected()
            //
            RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );
        }

    } else {

        BlTerminalConnected = FALSE;
    }

}

LOGICAL
BlTerminalAttached(
    IN ULONG DeviceId
    )

/*++

Routine Description:

    This routine will attempt to discover if a terminal is attached.

Arguments:

    DeviceId - Value returned by BlPortInitialize()

Return Value:

    TRUE - Port seems to have something attached.

    FALSE - Port doesn't seem to have anything attached.

--*/

{
    UCHAR ModemStatus;
    BOOLEAN ReturnValue;

    //
    // Check for a carrier.
    //
    ModemStatus = READ_UCHAR(Port[DeviceId].Address + COM_MSR);
    ReturnValue = ((ModemStatus & MS_DSRCTSCD) == MS_DSRCTSCD);
    return ReturnValue;
}

VOID
BlSetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock
    )

/*++

Routine Description:

    This routine will fill in the areas of the restart block that are appropriate
    for the headless server effort.

Arguments:

    RestartBlock - The magic structure for holding restart information from oschoice
        to setupldr.

Return Value:

    None.

--*/

{

    if( LoaderRedirectionInformation.PortNumber ) {


        RestartBlock->HeadlessUsedBiosSettings = (ULONG)LoaderRedirectionInformation.UsedBiosSettings;
        RestartBlock->HeadlessPortNumber = (ULONG)LoaderRedirectionInformation.PortNumber;
        RestartBlock->HeadlessPortAddress = (PUCHAR)LoaderRedirectionInformation.PortAddress;
        RestartBlock->HeadlessBaudRate = (ULONG)LoaderRedirectionInformation.BaudRate;
        RestartBlock->HeadlessParity = (ULONG)LoaderRedirectionInformation.Parity;
        RestartBlock->HeadlessStopBits = (ULONG)LoaderRedirectionInformation.StopBits;
        RestartBlock->HeadlessTerminalType = (ULONG)LoaderRedirectionInformation.TerminalType;

        RestartBlock->HeadlessPciDeviceId = LoaderRedirectionInformation.PciDeviceId;
        RestartBlock->HeadlessPciVendorId = LoaderRedirectionInformation.PciVendorId;
        RestartBlock->HeadlessPciBusNumber = LoaderRedirectionInformation.PciBusNumber;
        RestartBlock->HeadlessPciSlotNumber = LoaderRedirectionInformation.PciSlotNumber;
        RestartBlock->HeadlessPciFunctionNumber = LoaderRedirectionInformation.PciFunctionNumber;
        RestartBlock->HeadlessPciFlags = LoaderRedirectionInformation.PciFlags;
    }
}

VOID
BlGetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock,
    IN BOOLEAN RestartBlockValid
    )

/*++

Routine Description:

    This routine will get all the information from a restart block
    for the headless server effort.

Arguments:

    RestartBlock - The magic structure for holding restart information from oschoice
        to setupldr.

    RestartBlockValid - Is this block valid (full of good info)?

Return Value:

    None.

--*/

{

    LoaderRedirectionInformation.UsedBiosSettings = (BOOLEAN)RestartBlock->HeadlessUsedBiosSettings;
    LoaderRedirectionInformation.DataBits = 0;
    LoaderRedirectionInformation.StopBits = (UCHAR)RestartBlock->HeadlessStopBits;
    LoaderRedirectionInformation.Parity = (BOOLEAN)RestartBlock->HeadlessParity;
    LoaderRedirectionInformation.BaudRate = (ULONG)RestartBlock->HeadlessBaudRate;;
    LoaderRedirectionInformation.PortNumber = (ULONG)RestartBlock->HeadlessPortNumber;
    LoaderRedirectionInformation.PortAddress = (PUCHAR)RestartBlock->HeadlessPortAddress;
    LoaderRedirectionInformation.TerminalType = (UCHAR)RestartBlock->HeadlessTerminalType;

    LoaderRedirectionInformation.PciDeviceId = (USHORT)RestartBlock->HeadlessPciDeviceId;
    LoaderRedirectionInformation.PciVendorId = (USHORT)RestartBlock->HeadlessPciVendorId;
    LoaderRedirectionInformation.PciBusNumber = (UCHAR)RestartBlock->HeadlessPciBusNumber;
    LoaderRedirectionInformation.PciSlotNumber = (UCHAR)RestartBlock->HeadlessPciSlotNumber;
    LoaderRedirectionInformation.PciFunctionNumber = (UCHAR)RestartBlock->HeadlessPciFunctionNumber;
    LoaderRedirectionInformation.PciFlags = (ULONG)RestartBlock->HeadlessPciFlags;

}

ULONG
BlPortGetByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the port and return it.

Arguments:

    BlFileId - The port to read from.

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.

    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    return CpGetByte(&Port[BlFileId], Input, TRUE, FALSE);
}

VOID
BlPortPutByte (
    IN ULONG BlFileId,
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the port.

Arguments:

    BlFileId - The port to write to.

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
    CpPutByte(&Port[BlFileId], Output);
}

ULONG
BlPortPollByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the port and return it if one is available.

Arguments:

    BlFileId - The port to poll.

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    return CpGetByte(&Port[BlFileId], Input, FALSE, FALSE);
}

ULONG
BlPortPollOnly (
    IN ULONG BlFileId
    )

/*++

Routine Description:

    Check if a byte is available

Arguments:

    BlFileId - The port to poll.

Return Value:

    CP_GET_SUCCESS is returned if a byte is ready.
    CP_GET_ERROR is returned if error encountered.
    CP_GET_NODATA is returned if timeout.

--*/

{
    CHAR Input;

    return CpGetByte(&Port[BlFileId], &Input, FALSE, TRUE);
}

VOID
CpInitialize (
    PCPPORT Port,
    PUCHAR Address,
    ULONG Rate
    )

/*++

    Routine Description:

        Fill in the com port port object, set the initial baud rate,
        turn on the hardware.

    Arguments:

        Port - address of port object

        Address - port address of the com port
                    (CP_COM1_PORT, CP_COM2_PORT)

        Rate - baud rate  (CP_BD_150 ... CP_BD_19200)

--*/

{

    PUCHAR hwport;
    UCHAR   mcr, ier;

    Port->Address = Address;
    Port->Baud = 0;

    CpSetBaud(Port, Rate);

    //
    // Assert DTR, RTS.
    //

    hwport = Port->Address;
    hwport += COM_MCR;

    mcr = MC_DTRRTS;
    WRITE_UCHAR(hwport, mcr);

    hwport = Port->Address;
    hwport += COM_IEN;

    ier = 0;
    WRITE_UCHAR(hwport, ier);
    return;
}

VOID 
CpEnableFifo(
    IN PUCHAR   Address,
    IN BOOLEAN  bEnable
    )
/*++

Routine Description:

    This routine will attempt to enable the FIFO in the
    UART at the address specified.  If this is a 16550,
    this works.  The behaviour on a 16450 is not defined,
    but practically, there is no effect.

Arguments:

    Address - address of hw port.
    bEnable - if TRUE, FIFO is enabled
              if FALSE, FIFO  is disabled

Return Value:

    None

--*/
{
    //
    // Enable the FIFO in the UART. The behaviour is undefined on the
    // 16450, but practically, it should just ignore the command.
    //
    PUCHAR hwport = Address;
    hwport += COM_FCR;
    WRITE_UCHAR(hwport, bEnable);   
}

LOGICAL
CpDoesPortExist(
    IN PUCHAR Address
    )

/*++

Routine Description:

    This routine will attempt to place the port into its
    diagnostic mode.  If it does it will twiddle a bit in
    the modem control register.  If the port exists this
    twiddling should show up in the modem status register.

    NOTE: This routine must be called before the device is
          enabled for interrupts, this includes setting the
          output2 bit in the modem control register.

    This is blatantly stolen from TonyE's code in ntos\dd\serial\serial.c.

Arguments:

    Address - address of hw port.

Return Value:

    TRUE - Port exists.

    FALSE - Port doesn't exist.

--*/

{
    UCHAR OldModemStatus;
    UCHAR ModemStatus;
    BOOLEAN ReturnValue = TRUE;

    //
    // Save the old value of the modem control register.
    //
    OldModemStatus = READ_UCHAR(Address + COM_MCR);

    //
    // Set the port into diagnostic mode.
    //
    WRITE_UCHAR(Address + COM_MCR, SERIAL_MCR_LOOP);

    //
    // Bang on it again to make sure that all the lower bits
    // are clear.
    //
    WRITE_UCHAR(Address + COM_MCR, SERIAL_MCR_LOOP);

    //
    // Read the modem status register.  The high for bits should
    // be clear.
    //

    ModemStatus = READ_UCHAR(Address + COM_MSR);
    if (ModemStatus & (SERIAL_MSR_CTS | SERIAL_MSR_DSR |
                       SERIAL_MSR_RI  | SERIAL_MSR_DCD)) {
        ReturnValue = FALSE;
        goto EndFirstTest;
    }

    //
    // So far so good.  Now turn on OUT1 in the modem control register
    // and this should turn on ring indicator in the modem status register.
    //
    WRITE_UCHAR(Address + COM_MCR, (SERIAL_MCR_OUT1 | SERIAL_MCR_LOOP));

    ModemStatus = READ_UCHAR(Address + COM_MSR);
    if (!(ModemStatus & SERIAL_MSR_RI)) {
        ReturnValue = FALSE;
        goto EndFirstTest;
    }


EndFirstTest:

    if( ReturnValue == FALSE ) {

        UCHAR       OldIEValue = 0, OldLCValue = 0;
        USHORT      Value1 = 0, Value2 = 0;

        UCHAR       PreviousLineControl = 0;

        //
        // We failed the loopback test.  Test another way.
        //

        // Remember the original Interrupt Enable setting and
        // Line Control setting.
        OldIEValue = READ_UCHAR( Address + COM_IEN );
        OldLCValue = READ_UCHAR( Address + COM_LCR );


        // Make sure we aren't accessing the divisor latch.
        WRITE_UCHAR( Address + COM_LCR, OldLCValue | LC_DLAB );

        WRITE_UCHAR( Address + COM_IEN, 0xF );

        Value1 = READ_UCHAR( Address + COM_IEN );
        Value1 = Value1 << 8;
        Value1 |= READ_UCHAR( Address + COM_DAT );

        // Now read the divisor latch.
        PreviousLineControl = READ_UCHAR( Address + COM_LCR );
        WRITE_UCHAR( Address + COM_LCR, (UCHAR)(PreviousLineControl | LC_DLAB) );
        Value2 = READ_UCHAR( Address + COM_DLL );
        Value2 = Value2 + (READ_UCHAR(Address + COM_DLM) << 8 );
        WRITE_UCHAR( Address + COM_LCR, PreviousLineControl );


        // Restore original Line Control register and
        // Interrupt Enable setting.
        WRITE_UCHAR( Address + COM_LCR, OldLCValue );
        WRITE_UCHAR( Address + COM_IEN, OldIEValue );

        if( Value1 == Value2 ) {

            //
            // We passed this test.  Reset ReturnValue
            // appropriately.
            //
            ReturnValue = TRUE;
        }
    }



    //
    // Put the modem control back into a clean state.
    //
    WRITE_UCHAR(Address + COM_MCR, OldModemStatus);
    return ReturnValue;
}

UCHAR
CpReadLsr (
    PCPPORT Port,
    UCHAR waiting
    )

/*++

    Routine Description:

        Read LSR byte from specified port.  If HAL owns port & display
        it will also cause a debug status to be kept up to date.

        Handles entering & exiting modem control mode for debugger.

    Arguments:

        Port - Address of CPPORT

    Returns:

        Byte read from port

--*/

{

    static  UCHAR ringflag = 0;
    UCHAR   lsr, msr;

    lsr = READ_UCHAR(Port->Address + COM_LSR);

    if ((lsr & waiting) == 0) {
        msr = READ_UCHAR (Port->Address + COM_MSR);
        ringflag |= (msr & SERIAL_MSR_RI) ? 1 : 2;
        if (ringflag == 3) {

            //
            // The ring indicate line has toggled, use modem control from
            // now on.
            //

            Port->Flags |= PORT_MODEMCONTROL;
        }
    }

    return lsr;
}

VOID
CpSetBaud (
    PCPPORT Port,
    ULONG Rate
    )

/*++

    Routine Description:

        Set the baud rate for the port and record it in the port object.

    Arguments:

        Port - address of port object

        Rate - baud rate  (CP_BD_150 ... CP_BD_56000)

--*/

{

    ULONG   divisorlatch;
    PUCHAR  hwport;
    UCHAR   lcr;

    //
    // compute the divsor
    //

    divisorlatch = CLOCK_RATE / Rate;

    //
    // set the divisor latch access bit (DLAB) in the line control reg
    //

    hwport = Port->Address;
    hwport += COM_LCR;                  // hwport = LCR register

    lcr = READ_UCHAR(hwport);

    lcr |= LC_DLAB;
    WRITE_UCHAR(hwport, lcr);

    //
    // set the divisor latch value.
    //

    hwport = Port->Address;
    hwport += COM_DLM;                  // divisor latch msb
    WRITE_UCHAR(hwport, (UCHAR)((divisorlatch >> 8) & 0xff));

    hwport--;                           // divisor latch lsb
    WRITE_UCHAR(hwport, (UCHAR)(divisorlatch & 0xff));

    //
    // Set LCR to 3.  (3 is a magic number in the original assembler)
    //

    hwport = Port->Address;
    hwport += COM_LCR;
    WRITE_UCHAR(hwport, 3);

    //
    // Remember the baud rate
    //

    Port->Baud = Rate;
    return;
}

USHORT
CpGetByte (
    PCPPORT Port,
    PUCHAR Byte,
    BOOLEAN WaitForByte,
    BOOLEAN PollOnly
    )

/*++

    Routine Description:

        Fetch a byte and return it.

    Arguments:

        Port - address of port object that describes hw port

        Byte - address of variable to hold the result

        WaitForByte - flag indicates wait for byte or not.

        PollOnly - flag indicates whether to return immediately, not reading the byte, or not.

    Return Value:

        CP_GET_SUCCESS if data returned, or if data is ready and PollOnly is TRUE.

        CP_GET_NODATA if no data available, but no error.

        CP_GET_ERROR if error (overrun, parity, etc.)

--*/

{

    UCHAR   lsr;
    UCHAR   value;
    ULONG   limitcount;

    //
    // Check to make sure the CPPORT we were passed has been initialized.
    // (The only time it won't be initialized is when the kernel debugger
    // is disabled, in which case we just return.)
    //

    if (Port->Address == NULL) {
        return CP_GET_NODATA;
    }

    limitcount = WaitForByte ? TIMEOUT_COUNT : 1;
    while (limitcount != 0) {
        limitcount--;

        lsr = CpReadLsr(Port, COM_DATRDY);
        if ((lsr & COM_DATRDY) == COM_DATRDY) {

            //
            // Check for errors
            //

            //
            // If we get an overrun error, and there is data ready, we should
            // return the data we have, so we ignore overrun errors.  Reading
            // the LSR clears this bit, so the first read already cleared the
            // overrun error.
            //
            if (lsr & (COM_FE | COM_PE)) {
                *Byte = 0;
                return CP_GET_ERROR;
            }

            if (PollOnly) {
                return CP_GET_SUCCESS;
            }

            //
            // fetch the byte
            //

            *Byte = READ_UCHAR(Port->Address + COM_DAT);
            if (Port->Flags & PORT_MODEMCONTROL) {

                //
                // Using modem control.  If no CD, then skip this byte.
                //

                if ((READ_UCHAR(Port->Address + COM_MSR) & MS_CD) == 0) {
                    continue;
                }
            }

            return CP_GET_SUCCESS;
        }
    }

    CpReadLsr(Port, 0);
    return CP_GET_NODATA;
}

VOID
CpPutByte (
    PCPPORT  Port,
    UCHAR   Byte
    )

/*++

    Routine Description:

        Write a byte out to the specified com port.

    Arguments:

        Port - Address of CPPORT object

        Byte - data to emit

--*/

{

    UCHAR   msr, lsr;

    //
    // If modem control, make sure DSR, CTS and CD are all set before
    // sending any data.
    //

    while ((Port->Flags & PORT_MODEMCONTROL)  &&
           (msr = READ_UCHAR(Port->Address + COM_MSR) & MS_DSRCTSCD) != MS_DSRCTSCD) {

        //
        // If no CD, and there's a charactor ready, eat it
        //

        lsr = CpReadLsr(Port, 0);
        if ((msr & MS_CD) == 0  && (lsr & COM_DATRDY) == COM_DATRDY) {
            READ_UCHAR(Port->Address + COM_DAT);
        }
    }

    //
    //  Wait for port to not be busy
    //

    while (!(CpReadLsr(Port, COM_OUTRDY) & COM_OUTRDY)) ;

    //
    // Send the byte
    //

    WRITE_UCHAR(Port->Address + COM_DAT, Byte);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\xsum.asm ===
.xlist
 include xsum.x86
 .list
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\xxioacc.asm ===
title  "ix ioaccess"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixioacc.asm
;
; Abstract:
;
;    Procedures to correctly touch I/O registers.
;
; Author:
;
;    Bryan Willman (bryanwi) 16 May 1990
;
; Environment:
;
;    User or Kernel, although privledge (IOPL) may be required.
;
; Revision History:
;
;--

.386p
        include callconv.inc
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; I/O port space read and write functions.
;
;  These have to be actual functions on the 386, because we need
;  to use assembler, but cannot return a value if we inline it.
;
;  This set of functions manipulates I/O registers in PORT space.
;  (Uses x86 in and out instructions)
;
;  WARNING: Port addresses must always be in the range 0 to 64K, because
;           that's the range the hardware understands.
;
;--



;++
;
;   UCHAR
;   READ_PORT_UCHAR(
;       PUCHAR  Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc  _READ_PORT_UCHAR,1

        mov     dx,[esp+4]              ; (dx) = Port
        in      al,dx
        stdRET  _READ_PORT_UCHAR

stdENDP _READ_PORT_UCHAR

;++
;
;   USHORT
;   READ_PORT_USHORT(
;       PUSHORT Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc  _READ_PORT_USHORT,1

        mov     dx,[esp+4]             ; (dx) = Port
        in      ax,dx
        stdRET  _READ_PORT_USHORT

stdENDP _READ_PORT_USHORT



;++
;
;   ULONG
;   READ_PORT_ULONG(
;       PULONG  Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc  _READ_PORT_ULONG,1

        mov     dx,[esp+4]             ; (dx) = Port
        in      eax,dx
        stdRET  _READ_PORT_ULONG

stdENDP _READ_PORT_ULONG



;++
;
;   VOID
;   READ_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _READ_PORT_BUFFER_UCHAR,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    edi
        mov     edi,[esp+12]            ; (edi) = (esp+8+push) = buffer
    rep insb
        pop     edi
        stdRET  _READ_PORT_BUFFER_UCHAR

stdENDP _READ_PORT_BUFFER_UCHAR


;++
;
;   VOID
;   READ_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _READ_PORT_BUFFER_USHORT,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    edi
        mov     edi,[esp+12]            ; (edi) = (esp+8+push) = buffer
    rep insw
        pop     edi
        stdRET  _READ_PORT_BUFFER_USHORT

stdENDP _READ_PORT_BUFFER_USHORT


;++
;
;   VOID
;   READ_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _READ_PORT_BUFFER_ULONG,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    edi
        mov     edi,[esp+12]            ; (edi) = (esp+8+push) = buffer
    rep insd
        pop     edi
        stdRET  _READ_PORT_BUFFER_ULONG

stdENDP _READ_PORT_BUFFER_ULONG



;++
;
;   VOID
;   WRITE_PORT_UCHAR(
;       PUCHAR  Port,
;       UCHAR   Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc  _WRITE_PORT_UCHAR,2

        mov     dx,[esp+4]              ; (dx) = Port
        mov     al,[esp+8]              ; (al) = Value
        out     dx,al
        stdRET  _WRITE_PORT_UCHAR

stdENDP _WRITE_PORT_UCHAR



;++
;
;   VOID
;   WRITE_PORT_USHORT(
;       PUSHORT Port,
;       USHORT  Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc  _WRITE_PORT_USHORT,2

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ax,[esp+8]              ; (ax) = Value
        out     dx,ax
        stdRET  _WRITE_PORT_USHORT

stdENDP _WRITE_PORT_USHORT



;++
;
;   VOID
;   WRITE_PORT_ULONG(
;       PULONG  Port,
;       ULONG   Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc  _WRITE_PORT_ULONG,2

        mov     dx,[esp+4]              ; (dx) = Port
        mov     eax,[esp+8]             ; (eax) = Value
        out     dx,eax
        stdRET  _WRITE_PORT_ULONG

stdENDP _WRITE_PORT_ULONG



;++
;
;   VOID
;   WRITE_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _WRITE_PORT_BUFFER_UCHAR,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    esi
        mov     esi,[esp+12]            ; (esi) = (esp+8+push) = buffer
    rep outsb
        pop     esi
        stdRET  _WRITE_PORT_BUFFER_UCHAR

stdENDP _WRITE_PORT_BUFFER_UCHAR


;++
;
;   VOID
;   WRITE_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _WRITE_PORT_BUFFER_USHORT,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    esi
        mov     esi,[esp+12]            ; (esi) = (esp+8+push) = buffer
    rep outsw
        pop     esi
        stdRET _WRITE_PORT_BUFFER_USHORT

stdENDP _WRITE_PORT_BUFFER_USHORT


;++
;
;   VOID
;   WRITE_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _WRITE_PORT_BUFFER_ULONG,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    esi
        mov     esi,[esp+12]            ; (esi) = (esp+8+push) = buffer
    rep outsd
        pop     esi
        stdRET _WRITE_PORT_BUFFER_ULONG

stdENDP _WRITE_PORT_BUFFER_ULONG


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\stubs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements stub routines for the boot code.

Author:

    David N. Cutler (davec) 7-Nov-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ntos.h"
#include "bootx86.h"
#include "stdio.h"
#include "stdarg.h"

VOID
KeBugCheck (
    IN ULONG BugCheckCode
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner.

Arguments:

    BugCheckCode - Supplies the reason for the bug check.

Return Value:

    None.

--*/

{

    //
    // Print out the bug check code and break.
    //

    BlPrint("\n*** BugCheck (%lx) ***\n\n", BugCheckCode);
    while(TRUE) {
    };
#if _MSC_VER < 1300
    return;
#endif
}

VOID
RtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{

    BlPrint( "\n*** Assertion failed %s in %s line %d\n",
            FailedAssertion,
            FileName,
            LineNumber );
    if (Message) {
        BlPrint(Message);
    }

    while (TRUE) {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\wakea.asm ===
;++
;
;Copyright (c) 1997  Microsoft Corporation
;
;Module Name:
;
;    wakea.asm
;
;Abstract:
;
;
;Author:
;
;   Ken Reneris (kenr) 05-May-1997
;
;Revision History:
;
;--


.586p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list
        extrn   _HiberPtes:DWORD
        extrn   _HiberVa:DWORD
        extrn   _HiberFirstRemap:DWORD
        extrn   _HiberLastRemap:DWORD
        extrn   _HiberPageFrames:DWORD
        extrn   _HiberTransVa:DWORD
        extrn   _HiberIdentityVa:DWORD
        extrn   _HiberImageFeatureFlags:DWORD
        extrn   _HiberBreakOnWake:BYTE
        extrn   _HiberImagePageSelf:DWORD

DBGOUT  macro   Value
;        push    edx
;        push    eax
;        mov     edx, 80h
;        mov     al, Value
;        out     dx, al
;        pop     eax
;        pop     edx
endm

; These equates must match the defines in po.h

XPRESS_MAX_PAGES        equ     16


;
; These equates must match the defines in bldr.h
;

PTE_SOURCE              equ     0
PTE_DEST                equ     1
PTE_MAP_PAGE            equ     2
PTE_REMAP_PAGE          equ     3
PTE_HIBER_CONTEXT       equ     4
PTE_TRANSFER_PDE        equ     5
PTE_WAKE_PTE            equ     6
PTE_DISPATCHER_START    equ     7
PTE_XPRESS_DEST_FIRST   equ     9
PTE_XPRESS_DEST_LAST    equ     (PTE_XPRESS_DEST_FIRST + XPRESS_MAX_PAGES)
HIBER_PTES              equ     (16 + XPRESS_MAX_PAGES)


;
; Processor paging defines
;

PAGE_SIZE           equ     4096
PAGE_SHIFT          equ     12
PAGE_MASK           equ     (PAGE_SIZE - 1)
PTE_VALID           equ     23h

PDE_SHIFT           equ     22
PTE_SHIFT           equ     12
PTE_INDEX_MASK      equ     3ffh


;
;   Internal defines and structures
;

STACK_SIZE          equ     1024

HbGdt struc
    Limit           dw      ?
    Base            dd      ?
    Pad             dw      ?
HbGdt ends


HbContextBlock struc
    WakeContext     db      processorstatelength dup (?)
    OldEsp          dd      ?
    PteVa           dd      ?
    TransCr3        dd      ?
    TransPteVa      dd      ?
    WakeHiberVa     dd      ?
    Buffer          dd      ?
    MapIndex        dd      ?
    LastMapIndex    dd      ?
    FeatureFlags    dd      ?
    Gdt             db      size HbGdt dup (?)
    Stack           db      STACK_SIZE dup (?)
    BufferData      db      ?       ; buffer starts here
HbContextBlock ends


;
; Addresses based from ebp
;

SourcePage          equ     [ebp + PAGE_SIZE * PTE_SOURCE]
DestPage            equ     [ebp + PAGE_SIZE * PTE_DEST]
Map                 equ     [ebp + PAGE_SIZE * PTE_MAP_PAGE]
Remap               equ     [ebp + PAGE_SIZE * PTE_REMAP_PAGE]
Context             equ     [ebp + PAGE_SIZE * PTE_HIBER_CONTEXT].HbContextBlock



_TEXT   SEGMENT PARA PUBLIC 'CODE'       ; Start 32 bit code
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; WakeDispatch (
; )
;
; Routine Description:
;
;   Relocatable code which copies any remap page to it's final resting
;   place and then restores the processors wake context.
;
;  Arguments:
;
;  Return
;
;   Only returns if there's an internal failure
;
;--


cPublicProc _WakeDispatcher, 0
        public  _WakeDispatcherStart
_WakeDispatcherStart   label   dword

        push    ebp
        push    ebx
        push    esi
        push    edi

;
; Load EBP with base of hiber va.  Everything will be relative from EBP
;

        mov     ebp, _HiberVa

;
; Initialize HbContextBlock
;

        mov     eax, _HiberFirstRemap
        mov     ecx, _HiberLastRemap
        lea     edx, Context.BufferData
        mov     esi, _HiberPtes
        mov     Context.MapIndex, eax
        mov     Context.LastMapIndex, ecx
        mov     Context.OldEsp, esp
        mov     Context.Buffer, edx
        mov     Context.PteVa, esi

        mov     eax, _HiberPageFrames [PTE_TRANSFER_PDE * 4]
        mov     ecx, _HiberTransVa
        mov     edx, _HiberIdentityVa
        mov     Context.TransCr3, eax
        mov     Context.TransPteVa, ecx
        mov     Context.WakeHiberVa, edx

        mov     eax, _HiberImageFeatureFlags
        mov     Context.FeatureFlags, eax

        DBGOUT  1

;
; Copy gdt to shared buffer and switch to it
;

        sgdt    fword ptr Context.Gdt
        movzx   ecx, Context.Gdt.Limit
        inc     ecx
        push    ecx
        call    AllocateHeap
        pop     ecx

        mov     edi, eax
        mov     esi, Context.Gdt.Base
        rep movsb

        mov     Context.Gdt.Base, eax
        lgdt    fword ptr Context.Gdt

        sub     eax, ebp
        add     eax, Context.WakeHiberVa
        mov     Context.Gdt.Base, eax

;
; Locate hiber ptes in hibernated image.  First get the PDE, then find
; the PTE for the hiber ptes.
;
        mov     eax, dword ptr Context.WakeContext.PsSpecialRegisters.SrCr3
        shr     eax, PAGE_SHIFT
        call    LocatePage
        push    eax
        push    PTE_SOURCE
        call    SetPte

        mov     ecx, Context.WakeHiberVa
        shr     ecx, PDE_SHIFT                  ; (ecx) = index into PDE
        mov     eax, [eax+ecx*4]                ; (eax) = PDE for WakeHiberVa PTE
        shr     eax, PAGE_SHIFT

        call    LocatePage
        push    eax
        push    PTE_SOURCE
        call    SetPte

        mov     ecx, Context.WakeHiberVa
        shr     ecx, PTE_SHIFT
        and     ecx, PTE_INDEX_MASK             ; (ecx) = index into PTE
        lea     edi, [eax+ecx*4]                ; (edi) = address of WakeHiber PTEs

;
; Copy the current HiberPtes to the wake image Ptes
;

        mov     esi, Context.PteVa
        mov     ecx, HIBER_PTES
        rep movsd

;
; If break on wake, set the image header signature in destionation
;

        cmp     _HiberBreakOnWake, 0
        jz      short hd05

        mov     eax, _HiberImagePageSelf
        call    LocatePage
        push    eax
        push    PTE_DEST
        call    SetPte
        mov     dword ptr [eax], 706B7262h      ; 'brkp'


;
; Switch to transition CR3
;
hd05:

        DBGOUT  2
        mov     ebx, Context.WakeHiberVa
        mov     eax, Context.TransCr3
        shl     eax, PAGE_SHIFT
        mov     cr3, eax

;
; Move to wake images hiber va
;

        mov     edi, ebx
        add     ebx, PTE_DISPATCHER_START * PAGE_SIZE
        add     ebx, offset hd10 - offset _WakeDispatcherStart
        jmp     ebx
hd10:   mov     ebp, edi
        mov     eax, Context.TransPteVa
        mov     Context.PteVa, eax
        lea     esp, Context.Stack + STACK_SIZE
        lgdt    fword ptr Context.Gdt

;
; Copy all pages to final locations
;

        DBGOUT  3
        mov     edx, Context.MapIndex
hd30:   cmp     edx, Context.LastMapIndex
        jnc     short hd40

        push    dword ptr Map.[edx*4]
        push    PTE_SOURCE
        call    SetPte
        mov     esi, eax

        push    dword ptr Remap.[edx*4]
        push    PTE_DEST
        call    SetPte
        mov     edi, eax

        mov     ecx, PAGE_SIZE / 4
        rep movsd

        inc     edx
        jmp     short hd30

;
; Restore processors wake context
;

hd40:   DBGOUT  5
        lea     esi, Context.WakeContext.PsSpecialRegisters

        mov     eax, cr3                    ; issue a couple of flushes
        mov     cr3, eax                    ; before enabling global ptes
        mov     cr3, eax


        mov     eax, [esi].SrCr4
        test    Context.FeatureFlags, KF_CR4
        jz      short hd50
        mov     cr4, eax
hd50:   mov     eax, [esi].SrCr3
        mov     cr3, eax
        mov     ecx, [esi].SrCr0
        mov     cr0, ecx                    ; on kernel's cr0

        DBGOUT  6

        mov     ecx, [esi].SrGdtr+2         ; base of GDT
        lgdt    fword ptr [esi].SrGdtr      ; load gdtr (w/matching flat cs & ds selectors)
        lidt    fword ptr [esi].SrIdtr      ; load idtr
        lldt    word ptr [esi].SrLdtr       ; load ldtr
        movzx   eax, word ptr [esi].SrTr    ; tss selector
        and     byte ptr [eax+ecx+5], 0fdh  ; clear the busy bit in the TSS
        ltr     ax                          ; load tr

        mov     ds, word ptr Context.WakeContext.PsContextFrame.CsSegDs
        mov     es, word ptr Context.WakeContext.PsContextFrame.CsSegEs
        mov     fs, word ptr Context.WakeContext.PsContextFrame.CsSegFs
        mov     gs, word ptr Context.WakeContext.PsContextFrame.CsSegGs
        mov     ss, word ptr Context.WakeContext.PsContextFrame.CsSegSs

        mov     ebx, dword ptr Context.WakeContext.PsContextFrame.CsEbx
        mov     ecx, dword ptr Context.WakeContext.PsContextFrame.CsEcx
        mov     edx, dword ptr Context.WakeContext.PsContextFrame.CsEdx
        mov     edi, dword ptr Context.WakeContext.PsContextFrame.CsEdi
        mov     esp, dword ptr Context.WakeContext.PsContextFrame.CsEsp

        push    dword ptr Context.WakeContext.PsContextFrame.CsEFlags
        movzx   eax, word ptr Context.WakeContext.PsContextFrame.CsSegCs
        push    eax
        push    dword ptr Context.WakeContext.PsContextFrame.CsEip

        push    dword ptr Context.WakeContext.PsContextFrame.CsEbp
        push    dword ptr Context.WakeContext.PsContextFrame.CsEsi
        push    dword ptr Context.WakeContext.PsContextFrame.CsEax

        lea     esi, Context.WakeContext.PsSpecialRegisters.SrKernelDr0
        lodsd
        mov     dr0, eax                    ; load dr0-dr7
        lodsd
        mov     dr1, eax
        lodsd
        mov     dr2, eax
        lodsd
        mov     dr3, eax
        lodsd
        mov     dr6, eax
        lodsd
        mov     dr7, eax

        DBGOUT  7

        pop     eax
        pop     esi
        pop     ebp
        iretd

; this exit is only used in the shared buffer overflows
Abort:
        mov     esp, Context.OldEsp
        pop     ebp
        pop     ebx
        pop     esi
        pop     edi
        stdRET  _WakeDispatcher


;++
;
; PUCHAR
; AllocateHeap (
;    IN ULONG Length            passed in ECX
;    )
;
; Routine Description:
;
;   Allocates the specified bytes from the wake context page.
;
;   N.B. This function is part of HiberDispacther.
;
;  Arguments:
;   ECX     - Length to allocate
;
;  Returns:
;   EAX     - Virtual address of bytes allocated
;
;  Uses:
;   EAX, ECX, EDX
;
;--

AllocateHeap  label   proc
        mov     eax, Context.Buffer
        mov     edx, eax
        test    eax, 01fh           ; round to 32 byte boundry
        jz      short ah20
        and     eax, not 01fh
        add     eax, 20h
ah20:   add     ecx, eax
        mov     Context.Buffer, ecx
        xor     ecx, edx
        and     ecx, 0ffffffffh - PAGE_MASK
        jnz     short Abort
        ret

;++
;
; PUCHAR
; SetPte (
;    IN ULONG   PteIndex
;    IN ULONG   PageFrameNumber
;    )
;
; Routine Description:
;
;
;   N.B. This function is part of HiberDispacther.
;
;  Arguments:
;
;
;  Returns:
;   EAX va of mapped pte
;
;  Uses:
;   EAX, ECX, EDX
;
;--

SetPte label    proc
        push    ecx
        mov     eax, [esp+8]                ; (eax) =  pte index

        shl     eax, 2                      ; * 4
        add     eax, Context.PteVa          ; + pte base

        mov     ecx, [esp+12]               ; (ecx) = page frame number
        shl     ecx, PAGE_SHIFT
        or      ecx, PTE_VALID
        mov     [eax], ecx                  ; set the Pte

        mov     eax, [esp+8]
        shl     eax, PAGE_SHIFT
        add     eax, ebp                    ; (eax) = va mapped by pte
        invlpg  [eax]
        pop     ecx
        ret     8


;++
;
; ULONG
; LocatePage (
;    IN ULONG PageNumber        passed in eax
;    )
;
; Routine Description:
;
;   Find the page specified by page number in the wake context.
;   The pagenumber must be a valid page.
;
;   N.B. This function is part of HiberDispacther.
;
;  Arguments:
;   EAX     - Length to allocate
;
;  Returns:
;   EAX     - Virtual address of bytes allocated
;
;  Uses:
;   EAX, ECX, EDX
;
;--

LocatePage label    proc

;
; Scan the remap entries for this page.  If it's found, get the
; source address.  If it's not found, then it's already at it's
; proper address
;
        mov     edx, Context.MapIndex
        dec     edx

lp10:   inc     edx
        cmp     edx, Context.LastMapIndex
        jnc     short lp20

        cmp     eax, Remap.[edx*4]
        jnz     short lp10

        mov     eax, Map.[edx*4]
lp20:   ret


        public  _WakeDispatcherEnd
_WakeDispatcherEnd   label   dword
stdENDP _WakeDispatcher

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\mips\query.s ===
//      TITLE("Query Implemention and Revision Information")
//++
//
// Copyright (c) 1993  Microsoft Corporation
//
// Module Name:
//
//    query.s
//
// Abstract:
//
//    This module implements code to query the processor and floating
//    coprocessor implementation and revsion information.
//
// Author:
//
//    David N. Cutler (davec) 22-Jun-1993
//
// Environment:
//
//    User mode.
//
// Revision History:
//
//--

#include "ksmips.h"

        SBTTL("Query Implementation and Revision")
//++
//
// VOID
// BlQueryImplementationAndRevision (
//    OUT PULONG ProcessorId,
//    OUT PULONG FloatingId
//    )
//
// Routine Description:
//
//    This function returns the implementation and revision of the host
//    processor and floating coprocessor.
//
// Arguments:
//
//    ProcessorId (a0) - Supplies a pointer to a variable that receives the
//        processor information.
//
//    Floatingid (a1) - Supplies a pointer to a variable that receives the
//        floating coprocessor information.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(BlQueryImplementationAndRevision)

        .set    noreorder
        .set    noat
        mfc0    t0,prid                 // get implementation and revision
        cfc1    t1,fsrid                // get implementation and revision
        sw      t0,0(a0)                //
        sw      t1,0(a1)                //
        .set    at
        .set    reorder

        j       ra                      // return

        .end    BlQueryImplementationAndRevision
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\oschoice\dcmpstub.c ===
#include "bldr.h"

VOID
DecompEnableDecompression(
    IN BOOLEAN Enable
    )
{
    UNREFERENCED_PARAMETER(Enable);

    return;
}


BOOLEAN
DecompGenerateCompressedName(
    IN  LPCSTR Filename,
    OUT LPSTR  CompressedName
    )
{
    UNREFERENCED_PARAMETER(Filename);
    UNREFERENCED_PARAMETER(CompressedName);

    //
    // Indicate that the caller shouldn't bother trying to locate
    // the compressed filename.
    //
    return(FALSE);
}


ULONG
DecompPrepareToReadCompressedFile(
    IN LPCSTR Filename,
    IN ULONG  FileId
    )
{
    UNREFERENCED_PARAMETER(Filename);
    UNREFERENCED_PARAMETER(FileId);

    //
    // No processing in osloader, only in setupldr.
    // Special return code of -1 takes care of this.
    //
    return((ULONG)(-1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\mips\ntsetup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntsetup.c

Abstract:

    This module is the tail-end of the OS loader program. It performs all
    MIPS specific allocations and initialize. The OS loader invokes this
    this routine immediately before calling the loaded kernel image.

Author:

    John Vert (jvert) 20-Jun-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "bldr.h"
#include "stdio.h"

//
// Define macro to round structure size to next 16-byte boundary
//

#define ROUND_UP(x) ((sizeof(x) + 15) & (~15))

//
// Configuration Data Header
// The following structure is copied from fw\mips\oli2msft.h
// NOTE shielint - Somehow, this structure got incorporated into
//     firmware EISA configuration data.  We need to know the size of the
//     header and remove it before writing eisa configuration data to
//     registry.
//

typedef struct _CONFIGURATION_DATA_HEADER {
            USHORT Version;
            USHORT Revision;
            PCHAR  Type;
            PCHAR  Vendor;
            PCHAR  ProductName;
            PCHAR  SerialNumber;
} CONFIGURATION_DATA_HEADER;

#define CONFIGURATION_DATA_HEADER_SIZE sizeof(CONFIGURATION_DATA_HEADER)

//
// Internal function references
//

ARC_STATUS
ReorganizeEisaConfigurationTree(
    IN PCONFIGURATION_COMPONENT_DATA RootEntry
    );

ARC_STATUS
CreateEisaConfigurationData (
     IN PCONFIGURATION_COMPONENT_DATA RootEntry
     );

VOID
BlQueryImplementationAndRevision (
    OUT PULONG ProcessorId,
    OUT PULONG FloatingId
    );

ARC_STATUS
BlSetupForNt(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )

/*++

Routine Description:

    This function initializes the MIPS specific kernel data structures
    required by the NT system.

Arguments:

    BlLoaderBlock - Supplies the address of the loader parameter block.

Return Value:

    ESUCCESS is returned if the setup is successfully complete. Otherwise,
    an unsuccessful status is returned.

--*/

{

    PCONFIGURATION_COMPONENT_DATA ConfigEntry;
    ULONG FloatingId;
    CHAR Identifier[256];
    ULONG KernelPage;
    ULONG LinesPerBlock;
    ULONG LineSize;
    PCHAR NewIdentifier;
    ULONG PrcbPage;
    ULONG ProcessorId;
    ARC_STATUS Status;

    //
    // If the host configuration is not a multiprocessor machine, then add
    // the processor and floating point coprocessor identification to the
    // processor identification string.
    //

    if (SYSTEM_BLOCK->RestartBlock == NULL) {
        ConfigEntry = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                               ProcessorClass,
                                               CentralProcessor,
                                               NULL);

        if (ConfigEntry != NULL) {
            BlQueryImplementationAndRevision(&ProcessorId, &FloatingId);
            sprintf(&Identifier[0],
                    "%s - Pr %d/%d, Fp %d/%d",
                    ConfigEntry->ComponentEntry.Identifier,
                    (ProcessorId >> 8) & 0xff,
                    ProcessorId & 0xff,
                    (FloatingId >> 8) & 0xff,
                    FloatingId & 0xff);

            NewIdentifier = (PCHAR)BlAllocateHeap(strlen(&Identifier[0]) + 1);
            if (NewIdentifier != NULL) {
                strcpy(NewIdentifier, &Identifier[0]);
                ConfigEntry->ComponentEntry.IdentifierLength = strlen(NewIdentifier);
                ConfigEntry->ComponentEntry.Identifier = NewIdentifier;
            }
        }
    }

    //
    // Find System entry and check each of its direct child to
    // look for EisaAdapter.
    //

    ConfigEntry = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                           SystemClass,
                                           ArcSystem,
                                           NULL);
    if (ConfigEntry) {
        ConfigEntry = ConfigEntry->Child;
    }

    while (ConfigEntry) {

        if ((ConfigEntry->ComponentEntry.Class == AdapterClass) &&
            (ConfigEntry->ComponentEntry.Type == EisaAdapter)) {

            //
            // Convert EISA format configuration data to our CM_ format.
            //

            Status = ReorganizeEisaConfigurationTree(ConfigEntry);
            if (Status != ESUCCESS) {
                return(Status);
            }
        }
        ConfigEntry = ConfigEntry->Sibling;
    }

    //
    // Find the primary data and instruction cache configuration entries, and
    // compute the fill size and cache size for each cache. These entries MUST
    // be present on all ARC compliant systems.
    //

    ConfigEntry = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                           CacheClass,
                                           PrimaryDcache,
                                           NULL);

    if (ConfigEntry != NULL) {
        LinesPerBlock = ConfigEntry->ComponentEntry.Key >> 24;
        LineSize = 1 << ((ConfigEntry->ComponentEntry.Key >> 16) & 0xff);
        BlLoaderBlock->u.Mips.FirstLevelDcacheFillSize = LinesPerBlock * LineSize;
        BlLoaderBlock->u.Mips.FirstLevelDcacheSize =
                1 << ((ConfigEntry->ComponentEntry.Key & 0xffff) + PAGE_SHIFT);

    } else {
        return EINVAL;
    }

    ConfigEntry = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                           CacheClass,
                                           PrimaryIcache,
                                           NULL);

    if (ConfigEntry != NULL) {
        LinesPerBlock = ConfigEntry->ComponentEntry.Key >> 24;
        LineSize = 1 << ((ConfigEntry->ComponentEntry.Key >> 16) & 0xff);
        BlLoaderBlock->u.Mips.FirstLevelIcacheFillSize = LinesPerBlock * LineSize;
        BlLoaderBlock->u.Mips.FirstLevelIcacheSize =
                1 << ((ConfigEntry->ComponentEntry.Key & 0xffff) + PAGE_SHIFT);

    } else {
        return EINVAL;
    }

    //
    // Find the secondary data and instruction cache configuration entries,
    // and if present, compute the fill size and cache size for each cache.
    // These entries are optional, and may or may not, be present.
    //

    ConfigEntry = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                           CacheClass,
                                           SecondaryCache,
                                           NULL);

    if (ConfigEntry != NULL) {
        LinesPerBlock = ConfigEntry->ComponentEntry.Key >> 24;
        LineSize = 1 << ((ConfigEntry->ComponentEntry.Key >> 16) & 0xff);
        BlLoaderBlock->u.Mips.SecondLevelDcacheFillSize = LinesPerBlock * LineSize;
        BlLoaderBlock->u.Mips.SecondLevelDcacheSize =
                1 << ((ConfigEntry->ComponentEntry.Key & 0xffff) + PAGE_SHIFT);

        BlLoaderBlock->u.Mips.SecondLevelIcacheSize = 0;
        BlLoaderBlock->u.Mips.SecondLevelIcacheFillSize = 0;

    } else {
        ConfigEntry = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                               CacheClass,
                                               SecondaryDcache,
                                               NULL);

        if (ConfigEntry != NULL) {
            LinesPerBlock = ConfigEntry->ComponentEntry.Key >> 24;
            LineSize = 1 << ((ConfigEntry->ComponentEntry.Key >> 16) & 0xff);
            BlLoaderBlock->u.Mips.SecondLevelDcacheFillSize = LinesPerBlock * LineSize;
            BlLoaderBlock->u.Mips.SecondLevelDcacheSize =
                    1 << ((ConfigEntry->ComponentEntry.Key & 0xffff) + PAGE_SHIFT);

            ConfigEntry = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                                   CacheClass,
                                                   SecondaryIcache,
                                                   NULL);

            if (ConfigEntry != NULL) {
                LinesPerBlock = ConfigEntry->ComponentEntry.Key >> 24;
                LineSize = 1 << ((ConfigEntry->ComponentEntry.Key >> 16) & 0xff);
                BlLoaderBlock->u.Mips.SecondLevelIcacheFillSize = LinesPerBlock * LineSize;
                BlLoaderBlock->u.Mips.SecondLevelIcacheSize =
                        1 << ((ConfigEntry->ComponentEntry.Key & 0xffff) + PAGE_SHIFT);

            } else {
                BlLoaderBlock->u.Mips.SecondLevelIcacheSize = 0;
                BlLoaderBlock->u.Mips.SecondLevelIcacheFillSize = 0;
            }

        } else {
            BlLoaderBlock->u.Mips.SecondLevelDcacheSize = 0;
            BlLoaderBlock->u.Mips.SecondLevelDcacheFillSize = 0;
            BlLoaderBlock->u.Mips.SecondLevelIcacheSize = 0;
            BlLoaderBlock->u.Mips.SecondLevelIcacheFillSize = 0;
        }
    }

    //
    // Allocate DPC stack pages for the boot processor.
    //

    Status = BlAllocateDescriptor(LoaderStartupDpcStack,
                                  0,
                                  KERNEL_STACK_SIZE >> PAGE_SHIFT,
                                  &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->u.Mips.InterruptStack =
                (KSEG0_BASE | (KernelPage << PAGE_SHIFT)) + KERNEL_STACK_SIZE;

    //
    // Allocate kernel stack pages for the boot processor idle thread.
    //

    Status = BlAllocateDescriptor(LoaderStartupKernelStack,
                                  0,
                                  KERNEL_STACK_SIZE >> PAGE_SHIFT,
                                  &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->KernelStack =
                (KSEG0_BASE | (KernelPage << PAGE_SHIFT)) + KERNEL_STACK_SIZE;

    //
    // Allocate panic stack pages for the boot processor.
    //

    Status = BlAllocateDescriptor(LoaderStartupPanicStack,
                                  0,
                                  KERNEL_STACK_SIZE >> PAGE_SHIFT,
                                  &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->u.Mips.PanicStack =
                (KSEG0_BASE | (KernelPage << PAGE_SHIFT)) + KERNEL_STACK_SIZE;

    //
    // Allocate and zero two pages for the PCR.
    //

    Status = BlAllocateDescriptor(LoaderStartupPcrPage,
                                  0,
                                  2,
                                  &BlLoaderBlock->u.Mips.PcrPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->u.Mips.PcrPage2 = BlLoaderBlock->u.Mips.PcrPage + 1;
    RtlZeroMemory((PVOID)(KSEG0_BASE | (BlLoaderBlock->u.Mips.PcrPage << PAGE_SHIFT)),
                  PAGE_SIZE * 2);

    //
    // Allocate and zero two pages for the PDR and one page of memory for
    // the initial processor block, idle process, and idle thread structures.
    //

    Status = BlAllocateDescriptor(LoaderStartupPdrPage,
                                  0,
                                  3,
                                  &BlLoaderBlock->u.Mips.PdrPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    RtlZeroMemory((PVOID)(KSEG0_BASE | (BlLoaderBlock->u.Mips.PdrPage << PAGE_SHIFT)),
                  PAGE_SIZE * 3);

    //
    // The storage for processor control block, the idle thread object, and
    // the idle thread process object are allocated from the third page of the
    // PDR allocation. The addresses of these data structures are computed
    // and stored in the loader parameter block and the memory is zeroed.
    //

    PrcbPage = BlLoaderBlock->u.Mips.PdrPage + 2;
    if (PAGE_SIZE >= (ROUND_UP(KPRCB) + ROUND_UP(EPROCESS) + ROUND_UP(ETHREAD))) {
        BlLoaderBlock->Prcb = KSEG0_BASE | (PrcbPage << PAGE_SHIFT);
        BlLoaderBlock->Process = BlLoaderBlock->Prcb + ROUND_UP(KPRCB);
        BlLoaderBlock->Thread = BlLoaderBlock->Process + ROUND_UP(EPROCESS);

    } else {
        return(ENOMEM);
    }

    //
    // Flush all caches.
    //

    if (SYSTEM_BLOCK->FirmwareVectorLength > (sizeof(PVOID) * FlushAllCachesRoutine)) {
        ArcFlushAllCaches();
    }

    return(ESUCCESS);
}

ARC_STATUS
ReorganizeEisaConfigurationTree(
    IN PCONFIGURATION_COMPONENT_DATA RootEntry
    )

/*++

Routine Description:

    This routine sorts the eisa adapter configuration tree based on
    the slot the component resided in.  It also creates a new configuration
    data for EisaAdapter component to contain ALL the eisa slot and function
    information.  Finally the Eisa tree will be wiped out.

Arguments:

    RootEntry - Supplies a pointer to a EisaAdapter component.  This is
                the root of Eisa adapter tree.


Returns:

    ESUCCESS is returned if the reorganization is successfully complete.
    Otherwise, an unsuccessful status is returned.

--*/
{

    PCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry;
    PCONFIGURATION_COMPONENT_DATA EntryFound, EntryFoundPrevious;
    PCONFIGURATION_COMPONENT_DATA AttachedEntry, DetachedList;
    ARC_STATUS Status;

    //
    // We sort the direct children of EISA adapter tree based on the slot
    // they reside in.  Only the direct children of EISA root need to be
    // sorted.
    // Note the "Key" field of CONFIGURATION_COMPONENT contains
    // EISA slot number.
    //

    //
    // First, detach all the children from EISA root.
    //

    AttachedEntry = NULL;                       // Child list of Eisa root
    DetachedList = RootEntry->Child;            // Detached child list
    PreviousEntry = NULL;

    while (DetachedList) {

        //
        // Find the component with the smallest slot number from detached
        // list.
        //

        EntryFound = DetachedList;
        EntryFoundPrevious = NULL;
        CurrentEntry = DetachedList->Sibling;
        PreviousEntry = DetachedList;
        while (CurrentEntry) {
            if (CurrentEntry->ComponentEntry.Key <
                EntryFound->ComponentEntry.Key) {
                EntryFound = CurrentEntry;
                EntryFoundPrevious = PreviousEntry;
            }
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
        }

        //
        // Remove the component from the detached child list.
        // If the component is not the head of the detached list, we remove it
        // by setting its previous entry's sibling to the component's sibling.
        // Otherwise, we simply update Detach list head to point to the
        // component's sibling.
        //

        if (EntryFoundPrevious) {
            EntryFoundPrevious->Sibling = EntryFound->Sibling;
        } else {
            DetachedList = EntryFound->Sibling;
        }

        //
        // Attach the component to the child list of Eisa root.
        //

        if (AttachedEntry) {
            AttachedEntry->Sibling = EntryFound;
        } else {
            RootEntry->Child = EntryFound;
        }
        AttachedEntry = EntryFound;
        AttachedEntry->Sibling = NULL;
    }

    //
    // Finally, we traverse the Eisa tree to collect all the Eisa slot
    // and function information and put it to the configuration data of
    // Eisa root entry.
    //

    Status = CreateEisaConfigurationData(RootEntry);

    //
    // Wipe out all the children of EISA tree.
    // NOTE shielint - For each child component, we should convert its
    //   configuration data from EISA format to our CM_ format.
    //

    RootEntry->Child = NULL;
    return(Status);

}

ARC_STATUS
CreateEisaConfigurationData (
     IN PCONFIGURATION_COMPONENT_DATA RootEntry
     )

/*++

Routine Description:

    This routine traverses Eisa configuration tree to collect all the
    slot and function information and attaches it to the configuration data
    of Eisa RootEntry.

    Note that this routine assumes that the EISA tree has been sorted based
    on the slot number.

Arguments:

    RootEntry - Supplies a pointer to the Eisa configuration
        component entry.

Returns:

    ESUCCESS is returned if the new EisaAdapter configuration data is
    successfully created.  Otherwise, an unsuccessful status is returned.

--*/
{
    ULONG DataSize, NextSlot = 0, i;
    PCM_PARTIAL_RESOURCE_LIST Descriptor;
    PCONFIGURATION_COMPONENT Component;
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;
    PUCHAR DataPointer;
    CM_EISA_SLOT_INFORMATION EmptySlot =
                                  {EISA_EMPTY_SLOT, 0, 0, 0, 0, 0, 0, 0};

    //
    // Remove the configuration data of Eisa Adapter
    //

    RootEntry->ConfigurationData = NULL;
    RootEntry->ComponentEntry.ConfigurationDataLength = 0;

    //
    // If the EISA stree contains valid slot information, i.e.
    // root has children attaching to it.
    //

    if (RootEntry->Child) {

        //
        // First find out how much memory is needed to store EISA config
        // data.
        //

        DataSize = sizeof(CM_PARTIAL_RESOURCE_LIST);
        CurrentEntry = RootEntry->Child;

        while (CurrentEntry) {
            Component = &CurrentEntry->ComponentEntry;
            if (CurrentEntry->ConfigurationData) {
                if (Component->Key > NextSlot) {

                    //
                    // If there is any empty slot between current slot
                    // and previous checked slot, we need to count the
                    // space for the empty slots.
                    //

                    DataSize += (Component->Key - NextSlot) *
                                     sizeof(CM_EISA_SLOT_INFORMATION);
                }
                DataSize += Component->ConfigurationDataLength + 1 -
                                            CONFIGURATION_DATA_HEADER_SIZE;
                NextSlot = Component->Key + 1;
            }
            CurrentEntry = CurrentEntry->Sibling;
        }

        //
        // Allocate memory from heap to hold the EISA configuration data.
        //

        DataPointer = BlAllocateHeap(DataSize);

        if (DataPointer == NULL) {
            return ENOMEM;
        } else {
            RootEntry->ConfigurationData = DataPointer;
            RootEntry->ComponentEntry.ConfigurationDataLength = DataSize;
        }

        //
        // Create a CM_PARTIAL_RESOURCE_LIST for the new configuration data.
        //

        Descriptor = (PCM_PARTIAL_RESOURCE_LIST)DataPointer;
        Descriptor->Version = 0;
        Descriptor->Revision = 0;
        Descriptor->Count = 1;
        Descriptor->PartialDescriptors[0].Type = CmResourceTypeDeviceSpecific;
        Descriptor->PartialDescriptors[0].ShareDisposition = 0;
        Descriptor->PartialDescriptors[0].Flags = 0;
        Descriptor->PartialDescriptors[0].u.DeviceSpecificData.Reserved1 = 0;
        Descriptor->PartialDescriptors[0].u.DeviceSpecificData.Reserved2 = 0;
        Descriptor->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                DataSize - sizeof(CM_PARTIAL_RESOURCE_LIST);

        //
        // Visit each child of the RootEntry and copy its ConfigurationData
        // to the new configuration data area.
        // N.B. The configuration data includes a slot information and zero
        //      or more function information.  The slot information provided
        //      by ARC eisa data does not have "ReturnedCode" as defined in
        //      our CM_EISA_SLOT_INFORMATION.  This code will convert the
        //      standard EISA slot information to our CM format.
        //

        CurrentEntry = RootEntry->Child;
        DataPointer += sizeof(CM_PARTIAL_RESOURCE_LIST);
        NextSlot = 0;

        while (CurrentEntry) {
            Component = &CurrentEntry->ComponentEntry;
            if (CurrentEntry->ConfigurationData) {

                //
                // Check if there is any empty slot.  If yes, create empty
                // slot information.  Also make sure the config data area is
                // big enough.
                //

                if (Component->Key > NextSlot) {
                    for (i = NextSlot; i < CurrentEntry->ComponentEntry.Key; i++ ) {
                        *(PCM_EISA_SLOT_INFORMATION)DataPointer = EmptySlot;
                        DataPointer += sizeof(CM_EISA_SLOT_INFORMATION);
                    }
                }

                *DataPointer++ = 0;                // See comment above
                RtlMoveMemory(                     // Skip config data header
                    DataPointer,
                    (PUCHAR)CurrentEntry->ConfigurationData +
                                     CONFIGURATION_DATA_HEADER_SIZE,
                    Component->ConfigurationDataLength -
                                     CONFIGURATION_DATA_HEADER_SIZE
                    );
                DataPointer += Component->ConfigurationDataLength -
                                     CONFIGURATION_DATA_HEADER_SIZE;
                NextSlot = Component->Key + 1;
            }
            CurrentEntry = CurrentEntry->Sibling;
        }
    }
    return(ESUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\i386\wake.c ===
/*++


Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    wake.c

Abstract:


Author:

    Ken Reneris

Environment:

    Kernel Mode


Revision History:


--*/

#include "arccodes.h"
#include "bootx86.h"


extern PHARDWARE_PTE PDE;
extern PHARDWARE_PTE HalPT;
extern ULONG HiberNoMappings;
extern BOOLEAN     HiberIoError;
extern ULONG HiberLastRemap;
extern BOOLEAN     HiberOutOfRemap;
PVOID  HiberTransVa;
ULONG HiberCurrentMapIndex;

#define PDE_SHIFT           22
#define PTE_SHIFT           12
#define PTE_INDEX_MASK      0x3ff


PVOID
HbMapPte (
    IN ULONG    PteToMap,
    IN ULONG    Page
    )
{
    PVOID       Va;

    Va = (PVOID) (HiberVa + (PteToMap << PAGE_SHIFT));
    HbSetPte (Va, HiberPtes, PteToMap, Page);
    return Va;
}


PVOID
HbNextSharedPage (
    IN ULONG    PteToMap,
    IN ULONG    RealPage
    )
/*++

Routine Description:

    Allocates the next available page in the free and
    maps the Hiber pte to the page.   The allocated page
    is put onto the remap list

Arguments:

    PteToMap    - Which Hiber PTE to map

    RealPage    - The page to enter into the remap table for
                  this allocation

Return Value:

    Virtual address of the mapping

--*/

{
    PULONG      MapPage;
    PULONG      RemapPage;
    ULONG       DestPage;
    ULONG       i;

    MapPage = (PULONG) (HiberVa + (PTE_MAP_PAGE << PAGE_SHIFT));
    RemapPage = (PULONG) (HiberVa + (PTE_REMAP_PAGE << PAGE_SHIFT));

    //
    // Loop until we find a free page which is not in
    // use by the loader image, then map it
    //

    while (HiberCurrentMapIndex < HiberNoMappings) {
        DestPage = MapPage[HiberCurrentMapIndex];
        HiberCurrentMapIndex += 1;

        i = HbPageDisposition (DestPage);
        if (i == HbPageInvalid) {
            HiberIoError = TRUE;
            return HiberBuffer;
        }

        if (i == HbPageNotInUse) {


            MapPage[HiberLastRemap] = DestPage;
            RemapPage[HiberLastRemap] = RealPage;
            HiberLastRemap += 1;
            HiberPageFrames[PteToMap] = DestPage;
            return HbMapPte(PteToMap, DestPage);
        }
    }

    HiberOutOfRemap = TRUE;
    return HiberBuffer;
}



VOID
HbAllocatePtes (
     IN ULONG NumberPages,
     OUT PVOID *PteAddress,
     OUT PVOID *MappedAddress
     )
/*++

Routine Description:

    Allocated a consecutive chuck of Ptes.

Arguments:

    NumberPage      - Number of ptes to allocate

    PteAddress      - Pointer to the first PTE

    MappedAddress   - Base VA of the address mapped


--*/
{
    ULONG i;
    ULONG j;

    //
    // We use the HAL's PDE for mapping.  Find enough free PTEs
    //

    for (i=0; i<=1024-NumberPages; i++) {
        for (j=0; j < NumberPages; j++) {
            if ((((PULONG)HalPT))[i+j]) {
                break;
            }
        }

        if (j == NumberPages) {
            *PteAddress = (PVOID) &HalPT[i];
            *MappedAddress = (PVOID) (0xffc00000 | (i<<12));
            return ;
        }
    }
    BlPrint("NoMem");
    while (1);
}

VOID
HbSetPte (
    IN PVOID Va,
    IN PHARDWARE_PTE Pte,
    IN ULONG Index,
    IN ULONG PageNumber
    )
/*++

Routine Description:

    Sets the Pte to the corresponding page address

--*/
{
    Pte[Index].PageFrameNumber = PageNumber;
    Pte[Index].Valid = 1;
    Pte[Index].Write = 1;
    Pte[Index].WriteThrough = 0;
    Pte[Index].CacheDisable = 0;
    _asm {
        mov     eax, Va
        invlpg  [eax]
    }
}


VOID
HiberSetupForWakeDispatch (
    VOID
    )
{
    PHARDWARE_PTE       HbPde;
    PHARDWARE_PTE       HbPte;
    PHARDWARE_PTE       WakePte;
    PHARDWARE_PTE       TransVa;
    ULONG               TransPde;
    ULONG               WakePde;
    ULONG               PteEntry;

    //
    // Allocate a transistion CR3.  A page directory and table which
    // contains the hibernation PTEs
    //

    HbPde = HbNextSharedPage(PTE_TRANSFER_PDE, 0);
    HbPte = HbNextSharedPage(PTE_WAKE_PTE, 0);          // TRANSFER_PTE, 0);

    RtlZeroMemory (HbPde, PAGE_SIZE);
    RtlZeroMemory (HbPte, PAGE_SIZE);

    //
    // Set PDE to point to PTE
    //

    TransPde = ((ULONG) HiberVa) >> PDE_SHIFT;
    HbPde[TransPde].PageFrameNumber = HiberPageFrames[PTE_WAKE_PTE];
    HbPde[TransPde].Write = 1;
    HbPde[TransPde].Valid = 1;

    //
    // Fill in the hiber PTEs
    //

    PteEntry = (((ULONG) HiberVa) >> PTE_SHIFT) & PTE_INDEX_MASK;
    TransVa = &HbPte[PteEntry];
    RtlCopyMemory (TransVa, HiberPtes, HIBER_PTES * sizeof(HARDWARE_PTE));

    //
    // Make another copy at the Va of the wake image hiber ptes
    //

    WakePte = HbPte;
    WakePde = ((ULONG) HiberIdentityVa) >> PDE_SHIFT;
    if (WakePde != TransPde) {
        WakePte = HbNextSharedPage(PTE_WAKE_PTE, 0);
        HbPde[WakePde].PageFrameNumber = HiberPageFrames[PTE_WAKE_PTE];
        HbPde[WakePde].Write = 1;
        HbPde[WakePde].Valid = 1;
    }

    PteEntry = (((ULONG) HiberIdentityVa) >> PTE_SHIFT) & PTE_INDEX_MASK;
    TransVa = &WakePte[PteEntry];
    RtlCopyMemory (TransVa, HiberPtes, HIBER_PTES * sizeof(HARDWARE_PTE));

    //
    // Set TransVa to be relative to the va of the transfer Cr3
    //

    HiberTransVa = (PVOID)  (((PUCHAR) TransVa) - HiberVa + (PUCHAR) HiberIdentityVa);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\mips\stubs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements stub routines for the boot code.

Author:

    David N. Cutler (davec) 7-Nov-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#define _BLDR_
#include "ntos.h"

//
// Define global data.
//

ULONG BlDcacheFillSize = 32;

VOID
KeBugCheck (
    IN ULONG BugCheckCode
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner.

Arguments:

    BugCheckCode - Supplies the reason for the bug check.

Return Value:

    None.

--*/

{

    //
    // Print out the bug check code and break.
    //

    DbgPrint("\n*** BugCheck (%lx) ***\n\n", BugCheckCode);
    while(TRUE) {
        DbgBreakPoint();
    };
    return;
}

LARGE_INTEGER
KeQueryPerformanceCounter (
    OUT PLARGE_INTEGER Frequency OPTIONAL
    )

/*++

Routine Description:

    This routine is a stub for the kernel debugger and always returns a
    value of zero.

Arguments:

    Frequency - Supplies an optional pointer to a variable which receives
        the performance counter frequency in Hertz.

Return Value:

    A value of zero is returned.

--*/

{

    LARGE_INTEGER Counter;

    //
    // Return the current system time as the function value.
    //

    Counter.LowPart = 0;
    Counter.HighPart = 0;
    return Counter;
}

VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    )

/*++

Routine Description:

    This function stalls execution for the specified number of microseconds.

Arguments:

    MicroSeconds - Supplies the number of microseconds that execution is to be
        stalled.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Limit;
    PULONG Store;
    ULONG Value;

    //
    // ****** begin temporary code ******
    //
    // This code must be replaced with a smarter version. For now it assumes
    // an execution rate of 40,000,000 instructions per second and 4 instructions
    // per iteration.
    //

    Store = &Value;
    Limit = (MicroSeconds * 40 / 4);
    for (Index = 0; Index < Limit; Index += 1) {
        *Store = Index;
    }
    return;
}

PVOID
MmDbgReadCheck (
    IN PVOID VirtualAddress
    )

/*++

Routine Description:

    This routine returns the phyiscal address for a virtual address
    which is valid (mapped) for read access.

Arguments:

    VirtualAddress - Supplies the virtual address to check.

Return Value:

    Returns NULL if the address is not valid or readable, otherwise
    returns the physical address of the corresponding virtual address.

--*/

{

    return VirtualAddress;
}

PVOID
MmDbgTranslatePhysicalAddress (
    IN PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:

    This routine returns the phyiscal address for a physical address
    which is valid (mapped).

Arguments:

    PhysicalAddress - Supplies the physical address to check.

Return Value:

    Returns NULL if the address is not valid or readable, otherwise
    returns the physical address of the corresponding virtual address.

--*/

{

    return (PVOID)PhysicalAddress.LowPart;
}

PVOID
MmDbgWriteCheck (
    IN PVOID VirtualAddress
    )

/*++

Routine Description:

    This routine returns the phyiscal address for a virtual address
    which is valid (mapped) for write access.

Arguments:

    VirtualAddress - Supplies the virtual address to check.

Return Value:

    Returns NULL if the address is not valid or readable, otherwise
    returns the physical address of the corresponding virtual address.

--*/

{
    return VirtualAddress;
}

VOID
RtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{

    DbgPrint( "\n*** Assertion failed\n");
    while (TRUE) {
        DbgBreakPoint();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\oschoice\oscheap.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    oscheap.c

Abstract:

    This module contains "local" heap management code for OS Chooser.

Author:

    Geoff Pease (gpease) May 28 1998

Revision History:

--*/

#ifndef __OSCHEAP_H__
#define __OSCHEAP_H__

#ifndef UINT
#define UINT unsigned int
#endif // UINT

void
OscHeapInitialize( );

PCHAR
OscHeapAlloc( 
    IN UINT iSize 
    );

PCHAR
OscHeapFree(
    IN PCHAR pMemory 
    );


#endif // __OSCHEAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\oschoice\diagload.h ===
//
//      Diagnostic loader messages.
//
//
// Defines for Class, Detail and Action are used to lookup
// text from DiagLoadClass, DiagLoadDetail and DiagLoadAction
// respectively.  One must change LOAD_CL_END, DIAG_BL_END
// and LOAD_ACT_END to reflect any change in the content of
// the tables.  They are used for bounds checking to avoid
// access violations.

//
// Class Definitions
//

#define LOAD_SW_INT_ERR_CLASS          0x00000000L
#define LOAD_SW_MISRQD_FILE_CLASS      0x00000001L
#define LOAD_SW_BAD_FILE_CLASS         0x00000002L
#define LOAD_SW_MIS_FILE_CLASS         0x00000003L
#define LOAD_HW_MEM_CLASS              0x00000004L
#define LOAD_HW_DISK_CLASS             0x00000005L
#define LOAD_HW_GEN_ERR_CLASS          0x00000006L
#define LOAD_HW_FW_CFG_CLASS           0x00000007L
#define LOAD_CL_END                    0x00000008L


//
// Class Declarations
//

static PCHAR DiagLoadClass[] = {

"Windows NT could not start because of an error in the software.\r\nPlease report this problem as :\r\n\0",
"Windows NT could not start because the following file was not found\r\nand is required :\r\n\0",
"Windows NT could not start because of a bad copy of the following file :\r\n\0",
"Windows NT could not start because the following file is missing or corrupt:\r\n\0",
"Windows NT could not start because of a hardware memory configuration\r\nproblem.\r\n\0",
"Windows NT could not start because of a computer disk hardware\r\nconfiguration problem.\r\n\0",
"Windows NT could not start because of a general computer hardware\r\nconfiguration problem.\r\n\0",
"Windows NT could not start because of the following ARC firmware\r\nboot configuration problem :\r\n\0"

};

//
// Detail Definitions
//

#define DIAG_BL_MEMORY_INIT            0L
#define DIAG_BL_CONFIG_INIT            1L
#define DIAG_BL_IO_INIT                2L
#define DIAG_BL_FW_GET_BOOT_DEVICE     3L
#define DIAG_BL_OPEN_BOOT_DEVICE       4L
#define DIAG_BL_FW_GET_SYSTEM_DEVICE   5L
#define DIAG_BL_FW_OPEN_SYSTEM_DEVICE  6L
#define DIAG_BL_GET_SYSTEM_PATH        7L
#define DIAG_BL_LOAD_SYSTEM_IMAGE      8L
#define DIAG_BL_FIND_HAL_IMAGE         9L
#define DIAG_BL_LOAD_HAL_IMAGE         10L
#define DIAG_BL_LOAD_SYSTEM_IMAGE_DATA 11L
#define DIAG_BL_LOAD_HAL_IMAGE_DATA    12L
#define DIAG_BL_LOAD_SYSTEM_DLLS       13L
#define DIAG_BL_LOAD_HAL_DLLS          14L
#define DIAG_BL_READ_SYSTEM_REGISTRY   15L
#define DIAG_BL_LOAD_SYSTEM_REGISTRY   16L
#define DIAG_BL_FIND_SYSTEM_DRIVERS    17L
#define DIAG_BL_READ_SYSTEM_DRIVERS    18L
#define DIAG_BL_LOAD_DEVICE_DRIVER     19L
#define DIAG_BL_LOAD_SYSTEM_HIVE       20L
#define DIAG_BL_SYSTEM_PART_DEV_NAME   21L
#define DIAG_BL_BOOT_PART_DEV_NAME     22L
#define DIAG_BL_ARC_BOOT_DEV_NAME      23L
#define DIAG_BL_ARC_HAL_NAME           24L
#define DIAG_BL_SETUP_FOR_NT           25L
#define DIAG_BL_KERNEL_INIT_XFER       26L
#define DIAG_BL_END                    27L

//
// Detail Declarations
//

static PCHAR DiagLoadDetail[] = {

// DIAG_BL_MEMORY_INIT            0L
"Check hardware memory configuration and amount of RAM.\r\n\0",

// DIAG_BL_CONFIG_INIT            1L
"Too many configuration entries.\r\n\0",

// DIAG_BL_IO_INIT                2L
"Could not access disk partition tables \r\n\0",

// DIAG_BL_FW_GET_BOOT_DEVICE     3L
"The 'osloadpartition' parameter setting is invalid.\r\n\0",

// DIAG_BL_OPEN_BOOT_DEVICE       4L
"Could not read from the selected boot disk.  Check boot path\r\nand disk hardware.\r\n\0",

// DIAG_BL_FW_GET_SYSTEM_DEVICE   5L
"The 'systempartition' parameter setting is invalid.\r\n\0",

// DIAG_BL_FW_OPEN_SYSTEM_DEVICE  6L
"Could not read from the selected system boot disk.\r\nCheck 'systempartition' path.\r\n\0",

// DIAG_BL_GET_SYSTEM_PATH        7L
"The 'osloadfilename' parameter does not point to a valid file.\r\n\0",

// DIAG_BL_LOAD_SYSTEM_IMAGE      8L
"<winnt root>\\system32\\ntoskrnl.exe.\r\n\0",

// DIAG_BL_FIND_HAL_IMAGE         9L
"The 'osloader' parameter does not point to a valid file.\r\n\0",

// DIAG_BL_LOAD_HAL_IMAGE         10L
#if defined(i386)
"<winnt root>\\system32\\hal.dll.\r\n\0",
#endif

#if defined(MIPS)
"'osloader'\\hal.dll\r\n\0",
#endif

// DIAG_BL_LOAD_SYSTEM_IMAGE_DATA 11L
"Loader error 1.\r\n\0",

// DIAG_BL_LOAD_HAL_IMAGE_DATA    12L
"Loader error 2.\r\n\0",

// DIAG_BL_LOAD_SYSTEM_DLLS       13L
"load needed DLLs for kernel.\r\n\0",

// DIAG_BL_LOAD_HAL_DLLS          14L
"load needed DLLs for HAL.\r\n\0",

// DIAG_BL_READ_SYSTEM_REGISTRY   15L
"<winnt root>\\system32\\config\\system. \r\n\0",

// DIAG_BL_LOAD_SYSTEM_REGISTRY   16L
"<winnt root>\\system32\\config\\system. \r\n\0",

// DIAG_BL_FIND_SYSTEM_DRIVERS    17L
"find system drivers.\r\n\0",

// DIAG_BL_READ_SYSTEM_DRIVERS    18L
"read system drivers.\r\n\0",

// DIAG_BL_LOAD_DEVICE_DRIVER     19L
"did not load system boot device driver.\r\n\0",

// DIAG_BL_LOAD_SYSTEM_HIVE       20L
"load system hardware configuration file.\r\n\0",

// DIAG_BL_SYSTEM_PART_DEV_NAME   21L
"find system partition name device name.\r\n\0",

// DIAG_BL_BOOT_PART_DEV_NAME     22L
"find boot partition name.\r\n\0",

// DIAG_BL_ARC_BOOT_DEV_NAME      23L
"did not properly generate ARC name for HAL and system paths.\r\n\0",

// DIAG_BL_ARC_HAL_NAME           24L
"did not properly generate ARC name for HAL and system paths.\r\n\0",

// DIAG_BL_SETUP_FOR_NT           25L
"Loader error 3.\r\n\0",

// DIAG_BL_KERNEL_INIT_XFER       25L
"<winnt root>\\system32\\ntoskrnl.exe\r\n\0"

};


//
// Action Definitions
//

#define LOAD_SW_INT_ERR_ACT            0x00000000L
#define LOAD_SW_FILE_REST_ACT          0x00000001L
#define LOAD_SW_FILE_REINST_ACT        0x00000002L
#define LOAD_HW_MEM_ACT                0x00000003L
#define LOAD_HW_DISK_ACT               0x00000004L
#define LOAD_HW_GEN_ACT                0x00000005L
#define LOAD_HW_FW_CFG_ACT             0x00000006L
#define LOAD_ACT_END                   0x00000007L


//
// Action Declarations
//

static PCHAR DiagLoadAction[] = {

"Please contact your support person to report this problem.\r\n\0",
"You can attempt to repair this file by starting Windows NT\r\n"
"Setup using the original Setup floppy disk or CD-ROM.\r\n"
"Select 'r' at the first screen to start repair.\r\n\0",
"Please re-install a copy of the above file.\r\n\0",
"Please check the Windows NT(TM) documentation about hardware\r\nmemory requirements and your hardware reference manuals for\r\nadditional information.\r\n\0",
"Please check the Windows NT(TM) documentation about hardware\r\ndisk configuration and your hardware reference manuals for\r\nadditional information.\r\n\0",
"Please check the Windows NT(TM) documentation about hardware\r\nconfiguration and your hardware reference manuals for additional\r\ninformation.\r\n\0",
"Please check the Windows NT(TM) documentation about ARC configuration\r\noptions and your hardware reference manuals for additional\r\ninformation.\r\n\0"
};



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\mips\xxchkstk.s ===
//      TITLE("Runtime Stack Checking")
//++
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//    xxchkstk.s
//
// Abstract:
//
//    This module implements a stub routine for runtime stack checking.
//
// Author:
//
//    David N. Cutler (davec) 21-Sep-1992
//
// Environment:
//
//    User mode.
//
// Revision History:
//
//--

#include "ksmips.h"

        SBTTL("Check Stack")
//++
//
// VOID
// _RtlCheckStack (
//    IN ULONG Allocation
//    )
//
// Routine Description:
//
//    This function provides a stub routine for runtime stack checking.
//
// Arguments:
//
//    Allocation (t8) - Supplies the size of the allocation in bytes.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(_RtlCheckStack)

        j       ra                      // return

        .end    _RtlCheckStack
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\oschoice\parse.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    parse.c

Abstract:

    This module contains UI code for the OS chooser

Author:

    Geoff Pease (GPease) May 29 1998

Revision History:

--*/

#ifndef __PARSE_H__
#define __PARSE_H__

enum ACTIONS {
    ACTION_NOP = 0,
    ACTION_REBOOT,
    ACTION_JUMP,
    ACTION_LOGIN    
#if defined(_BUILDING_OSDISP_)
    ,ACTION_REFRESH
#endif
};

extern enum ACTIONS SpecialAction;

extern CHAR DomainName[256];
extern CHAR UserName[256];
extern CHAR Password[128];
extern CHAR AdministratorPassword[OSC_ADMIN_PASSWORD_LEN+1];
extern CHAR AdministratorPasswordConfirm[OSC_ADMIN_PASSWORD_LEN+1];

CHAR
BlProcessScreen(
    IN PCHAR InputString,
    OUT PCHAR OutputString
    );

#define ASCI_CSI_OUT    TEXT("\033[")     // escape-leftbracket

#define ATT_FG_BLUE     4
#define ATT_FG_WHITE    7
#define ATT_BG_BLUE     (ATT_FG_BLUE    << 4)
#define ATT_BG_WHITE    (ATT_FG_WHITE   << 4)
#define DEFATT          (ATT_FG_WHITE | ATT_BG_BLUE)
#define INVATT          (ATT_FG_BLUE |  ATT_BG_WHITE)

#endif // __PARSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\oschoice\oschoice.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    osloader.c

Abstract:

    This module contains the code that implements the OS chooser.

Author:

    Adam Barr (adamba) 15-May-1997

Revision History:

--*/

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#include "netboot.h"  // for network functionality
#include "netfs.h"    // for network functionality
#include "stdio.h"
#include "msg.h"
#include <pxe_cmn.h>
#include <pxe_api.h>
#include <tftp_api.h>
#include "parse.h"
#include "stdlib.h"
#include "parseini.h"
#include "haldtect.h"

#ifdef EFI
#define BINL_PORT   0x0FAB    // 4011 (decimal) in little-endian
#else
#define BINL_PORT   0xAB0F    // 4011 (decimal) in big-endian
#endif

#if defined(_WIN64) && defined(_M_IA64)
#pragma section(".base", long, read, write)
__declspec(allocate(".base"))
extern
PVOID __ImageBase;
#else
extern
PVOID __ImageBase;
#endif

VOID
BlpClearScreen(
    VOID
    );

BOOLEAN
BlDetectHal(
    VOID
    );

VOID
BlMainLoop(
    );

UCHAR OsLoaderVersion[] = "OS Chooser V5.0\r\n";
WCHAR OsLoaderVersionW[] = L"OS Chooser V5.0\r\n";
UCHAR OsLoaderName[] = "oschoice.exe";

const CHAR rghex[] = "0123456789ABCDEF";

typedef BOOLEAN BOOL;


BOOLEAN isOSCHOICE=TRUE;
ULONG RemoteHost;
USHORT RemotePort;
USHORT LocalPort;
CHAR DomainName[256];
CHAR UserName[256];
CHAR Password[128];
CHAR AdministratorPassword[OSC_ADMIN_PASSWORD_LEN+1];
CHAR AdministratorPasswordConfirm[OSC_ADMIN_PASSWORD_LEN+1];
WCHAR UnicodePassword[128];
CHAR LmOwfPassword[LM_OWF_PASSWORD_SIZE];
CHAR NtOwfPassword[NT_OWF_PASSWORD_SIZE];
BOOLEAN AllowFlip = TRUE;   // can we be flipped to another server
BOOLEAN LoggedIn = FALSE;   // have we successfully logged in
UCHAR NextBootfile[128];
UCHAR SifFile[128];
BOOLEAN DoSoftReboot = FALSE;
BOOLEAN BlUsePae;

//
// the following globals are for detecting the hal
//
UCHAR HalType[8+1+3+1];
UCHAR HalDescription[128];
PVOID InfFile;
PVOID WinntSifHandle;
PCHAR WinntSifFile;
ULONG WinntSifFileLength;
BOOLEAN DisableACPI = FALSE;

#if 0 && DBG
#define _TRACE_FUNC_
#endif

#ifdef _TRACE_FUNC_
#define TraceFunc( _func)  { \
    CHAR FileLine[80]; \
    sprintf( FileLine, "%s(%u)", __FILE__, __LINE__ ); \
    DPRINT( OSC, ( "%-55s: %s", FileLine, _func )); \
}
#else
#define TraceFunc( _func )
#endif

//
// This removes macro redefinitions which appear because we define __RPC_DOS__,
// but rpc.h defines __RPC_WIN32__
//

#pragma warning(disable:4005)

//
// As of 12/17/98, SECURITY_DOS is *not* defined - adamba
//

#if defined(SECURITY_DOS)
//
// These appear because we defined SECURITY_DOS
//

#define __far
#define __pascal
#define __loadds
#endif

#include <security.h>
#include <rpc.h>
#include <spseal.h>

#if defined(SECURITY_DOS)
//
// PSECURITY_STRING is not supposed to be used when SECURITY_DOS is
// defined -- it should be a WCHAR*. Unfortunately ntlmsp.h breaks
// this rule and even uses the SECURITY_STRING structure, which there
// is really no equivalent for in 16-bit mode.
//

typedef SEC_WCHAR * SECURITY_STRING;   // more-or-less the intention where it is used
typedef SEC_WCHAR * PSECURITY_STRING;
#endif

#include <ntlmsp.h>

//
// Packet structure definitions.
//

#include "oscpkt.h"

#if DBG
VOID
DumpBuffer(
    PVOID Buffer,
    ULONG BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    ULONG i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    PUCHAR BufferPtr = Buffer;


    KdPrint(("------------------------------------\n"));

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            KdPrint(("%02x ", (UCHAR)BufferPtr[i]));

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            KdPrint(("  "));
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            KdPrint(("  %s\n", TextBuffer));
        }

    }

    KdPrint(("------------------------------------\n"));
}

VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    KdPrint(( "%s", Comment ));

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( ConvertTime.LowPart == 0x7FFFFFFF ) {
        KdPrint(( "Infinite\n" ));

    //
    // Otherwise print it more clearly
    //

    } else {

        KdPrint(("%lx %lx\n", ConvertTime.HighPart, ConvertTime.LowPart));
    }

}
#endif // DBG

//
// Define transfer entry of loaded image.
//

typedef
VOID
(*PTRANSFER_ROUTINE) (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

BOOLEAN
BlGetDriveSignature(
    IN PCHAR Name,
    OUT PULONG Signature
    );

PVOID
BlLoadDataFile(
    IN ULONG DeviceId,
    IN PCHAR LoadDevice,
    IN PCHAR SystemPath,
    IN PUNICODE_STRING Filename,
    IN MEMORY_TYPE MemoryType,
    OUT PULONG FileSize
    );

#if defined(REMOTE_BOOT)
BOOLEAN
BlIsDiskless(
    VOID
    );
#endif // defined(REMOTE_BOOT)


//
// Define local static data.
//


PCHAR ArcStatusCodeMessages[] = {
    "operation was success",
    "E2BIG",
    "EACCES",
    "EAGAIN",
    "EBADF",
    "EBUSY",
    "EFAULT",
    "EINVAL",
    "EIO",
    "EISDIR",
    "EMFILE",
    "EMLINK",
    "ENAMETOOLONG",
    "ENODEV",
    "ENOENT",
    "ENOEXEC",
    "ENOMEM",
    "ENOSPC",
    "ENOTDIR",
    "ENOTTY",
    "ENXIO",
    "EROFS",
};

//
// Diagnostic load messages
//

VOID
BlFatalError(
    IN ULONG ClassMessage,
    IN ULONG DetailMessage,
    IN ULONG ActionMessage
    );

VOID
BlBadFileMessage(
    IN PCHAR BadFileName
    );


VOID
BlpSetInverseMode(
    IN BOOLEAN InverseOn
    );

VOID
BlpSendEscape(
    PCHAR Escape
    );

ULONG
BlGetUserResponse(
    IN ULONG XLocation,
    IN ULONG YLocation,
    IN BOOLEAN Hidden,
    IN ULONG MaximumLength,
    OUT PCHAR Response
    );

ULONG
BlGetKeyWithBlink(
    IN ULONG XLocation,
    IN ULONG YLocation
    );

ULONG
BlDoLogin (    );

VOID
BlDoLogoff(
    VOID
    );


//
// Define external static data.
//

BOOLEAN BlConsoleInitialized = FALSE;
ULONG BlConsoleOutDeviceId = 0;
ULONG BlConsoleInDeviceId = 0;
ULONG BlDcacheFillSize = 32;
extern BOOLEAN BlOutputDots;


ULONGLONG NetRebootParameter = (ULONGLONG)0;
UCHAR NetRebootFile[128];
BOOLEAN BlRebootSystem = FALSE;
ULONG BlVirtualBias = 0;

CHAR KernelFileName[8+1+3+1]="ntoskrnl.exe";
CHAR HalFileName[8+1+3+1]="hal.dll";


//
// Globals used during login. Mostly because it would be too many
// parameters to pass to BlDoLogin().
//

#define OUTGOING_MESSAGE_LENGTH 1024
#define INCOMING_MESSAGE_LENGTH 8192
#define TEMP_INCOMING_MESSAGE_LENGTH 1500

#define RECEIVE_TIMEOUT 5
#define RECEIVE_RETRIES 24

CHAR OutgoingMessageBuffer[OUTGOING_MESSAGE_LENGTH];
SIGNED_PACKET UNALIGNED * OutgoingSignedMessage;

CHAR IncomingMessageBuffer[INCOMING_MESSAGE_LENGTH];
SIGNED_PACKET UNALIGNED * IncomingSignedMessage;

CHAR TempIncomingMessage[TEMP_INCOMING_MESSAGE_LENGTH];  // used for reassembly

CredHandle CredentialHandle;
BOOLEAN CredentialHandleValid = FALSE;
CtxtHandle ClientContextHandle;
BOOLEAN ClientContextHandleValid = FALSE;
PSecPkgInfoA PackageInfo = NULL;

ARC_STATUS
BlInitStdio (
    IN ULONG Argc,
    IN PCHAR Argv[]
    )
{
    PCHAR ConsoleOutDevice;
    PCHAR ConsoleInDevice;
    ULONG Status;

    if (BlConsoleInitialized) {
        return ESUCCESS;
    }

    //
    // Get the name of the console output device and open the device for
    // write access.
    //

    ConsoleOutDevice = BlGetArgumentValue(Argc, Argv, "consoleout");
    if (ConsoleOutDevice == NULL) {
        return ENODEV;
    }

    Status = ArcOpen(ConsoleOutDevice, ArcOpenWriteOnly, &BlConsoleOutDeviceId);
    if (Status != ESUCCESS) {
        return Status;
    }

    //
    // Get the name of the console input device and open the device for
    // read access.
    //

    ConsoleInDevice = BlGetArgumentValue(Argc, Argv, "consolein");
    if (ConsoleInDevice == NULL) {
        return ENODEV;
    }

    Status = ArcOpen(ConsoleInDevice, ArcOpenReadOnly, &BlConsoleInDeviceId);
    if (Status != ESUCCESS) {
        return Status;
    }

    BlConsoleInitialized = TRUE;
    return ESUCCESS;
}


extern BOOLEAN NetBoot;

NTSTATUS
UdpSendAndReceive(
    IN PVOID SendBuffer,
    IN ULONG SendBufferLength,
    IN ULONG SendRemoteHost,
    IN USHORT SendRemotePort,
    IN ULONG SendRetryCount,
    IN PVOID ReceiveBuffer,
    IN ULONG ReceiveBufferLength,
    OUT PULONG ReceiveRemoteHost,
    OUT PUSHORT ReceiveRemotePort,
    IN ULONG ReceiveTimeout,
    IN ULONG ReceiveSignatureCount,
    IN PCHAR ReceiveSignatures[],
    IN ULONG ReceiveSequenceNumber
    )
{
    ULONG i, j;
    ULONG length;
    SIGNED_PACKET UNALIGNED * ReceiveHeader =
                (SIGNED_PACKET UNALIGNED *)ReceiveBuffer;

#ifdef _TRACE_FUNC_
    TraceFunc("UdpSendAndReceive( ");
    DPRINT( OSC, ("ReceiveSequenceNumber=%u )\n", ReceiveSequenceNumber) );
#endif

    //
    // Try sending the packet SendRetryCount times, until we receive
    // a response with the right signature, waiting ReceiveTimeout
    // each time.
    //

    for (i = 0; i < SendRetryCount; i++) {

        length = UdpSend(
                    SendBuffer,
                    SendBufferLength,
                    SendRemoteHost,
                    SendRemotePort);

        if ( length != SendBufferLength ) {
            DPRINT( ERROR, ("UdpSend only sent %d bytes, not %d\n", length, SendBufferLength) );
            return STATUS_UNEXPECTED_NETWORK_ERROR;
        }

ReReceive:

        //
        // NULL out the first 12 bytes in case we get shorter data.
        //

        memset(ReceiveBuffer, 0x0, 12);

        length = UdpReceive(
                    ReceiveBuffer,
                    ReceiveBufferLength,
                    ReceiveRemoteHost,
                    ReceiveRemotePort,
                    ReceiveTimeout);

        if ( length == 0 ) {
            DPRINT( ERROR, ("UdpReceive timed out\n") );
            continue;
        }

        //
        // Make sure the signature is one of the ones we expect.
        //

        for (j = 0; j < ReceiveSignatureCount; j++) {
            if (memcmp(ReceiveBuffer, ReceiveSignatures[j], 4) == 0) {

                //
                // Now make sure that the sequence number is correct,
                // if asked to check (0 means don't check).
                //

                if ((ReceiveSequenceNumber == 0) ||
                    (ReceiveSequenceNumber == ReceiveHeader->SequenceNumber)) {

                    return STATUS_SUCCESS;

                } else {

                    DPRINT( ERROR, ("UdpReceive expected seq %d, got %d\n",
                        ReceiveSequenceNumber, ReceiveHeader->SequenceNumber) );

                }
            }
        }

        DPRINT( ERROR, ("UdpReceive got wrong signature\n") );

        //
        // Don't UdpSend again just because we got a bad signature. Still need
        // to respect the original ReceiveTimeout however!
        //

        goto ReReceive;

    }

    //
    // We timed out.
    //

    return STATUS_IO_TIMEOUT;
}


//
// This routine signs and sends a message, waits for a response, and
// then verifies the signature on the response.
//
// It returns a positive number on success, 0 on a timeout, -1 if
// the server did not recognize the client, and -2 on other errors
// (which should be fixable by having the client re-login and
// re-transmit the request).
//
// NOTE: The data is sent as a UDP datagram. This requires a UDP header
// which the SendBuffer is assumed to have room for. In addition, we
// use 32 bytes for the "REQS", the total length, the sequence number,
// the sign length, and the sign itself (which is 16 bytes).
//
// For similar reasons, ReceiveBuffer is assumed to have 32 bytes of
// room at the beginning.
//
// Return values:
//
// 0 - nothing was received
// -1 - a timeout occurred
// -2 - unexpected network error, such as a sign/seal error
// -3 - receive buffer overflow
// positive number - the number of data bytes received
//

#define SIGN_HEADER_SIZE  SIGNED_PACKET_DATA_OFFSET

ULONG CorruptionCounter = 1;

ULONG
SignSendAndReceive(
    IN PVOID SendBuffer,
    IN ULONG SendBufferLength,
    IN ULONG SendRemoteHost,
    IN USHORT SendRemotePort,
    IN ULONG SendRetryCount,
    IN ULONG SendSequenceNumber,
    CtxtHandle ClientContextHandle,
    IN PVOID ReceiveBuffer,
    IN ULONG ReceiveBufferLength,
    OUT PULONG ReceiveRemoteHost,
    OUT PUSHORT ReceiveRemotePort,
    IN ULONG ReceiveTimeout
    )
{
    SECURITY_STATUS SecStatus;
    ULONG Status;
    ULONG length;
    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    SIGNED_PACKET UNALIGNED * SendHeader =
        (SIGNED_PACKET UNALIGNED *)((PCHAR)SendBuffer - SIGN_HEADER_SIZE);
    SIGNED_PACKET UNALIGNED * ReceiveHeader =
        (SIGNED_PACKET UNALIGNED *)((PCHAR)ReceiveBuffer - SIGN_HEADER_SIZE);
    PCHAR ResultSigs[3];
    USHORT FragmentNumber;
    USHORT FragmentTotal;
    FRAGMENT_PACKET UNALIGNED * TempFragment = (FRAGMENT_PACKET UNALIGNED *)TempIncomingMessage;
    ULONG ResendCount = 0;
    ULONG ReceivedDataBytes;

    TraceFunc("SignSendAndReceive( )\n");

    if ( LoggedIn )
    {
        SigBuffers[1].pvBuffer = SendHeader->Sign;
        SigBuffers[1].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        SigBuffers[1].BufferType = SECBUFFER_TOKEN;

        SigBuffers[0].pvBuffer = SendBuffer;
        SigBuffers[0].cbBuffer = SendBufferLength;
        SigBuffers[0].BufferType = SECBUFFER_DATA;

        SignMessage.pBuffers = SigBuffers;
        SignMessage.cBuffers = 2;
        SignMessage.ulVersion = 0;

        //
        // Sign/seal a message
        //

#ifndef ONLY_SIGN_MESSAGES
        SecStatus = SealMessage(
                            &ClientContextHandle,
                            0,
                            &SignMessage,
                            0 );

        if ( SecStatus != SEC_E_OK ) {
            DPRINT( OSC, ("SealMessage: %lx\n", SecStatus) );
            return (ULONG)-2;
        }
#else
        SecStatus = MakeSignature(
                            &ClientContextHandle,
                            0,
                            &SignMessage,
                            0 );

        if ( SecStatus != SEC_E_OK ) {
            DPRINT( OSC, ("MakeSignature: %lx\n", SecStatus) );
            return (ULONG)-2;
        }
#endif

#if 0
        //
        // Corrupt every fifth message.
        //

        if ((CorruptionCounter % 5) == 0) {
            DPRINT( ERROR, ("INTENTIONALLY CORRUPTING A PACKET\n") );
            ((PCHAR)SendBuffer)[0] = '\0';
        }
        ++CorruptionCounter;
#endif
        memcpy(SendHeader->Signature, RequestSignedSignature, 4);
        SendHeader->SignLength = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        ResultSigs[0] = ResponseSignedSignature;

    }
    else
    {
        memcpy(SendHeader->Signature, RequestUnsignedSignature, 4);
        SendHeader->SignLength = 0;
        ResultSigs[0] = ResponseUnsignedSignature;
    }

    ResultSigs[1] = ErrorSignedSignature;
    ResultSigs[2] = UnrecognizedClientSignature;

    //
    // Fill in our header before the SendBuffer. The sign has already been
    // written in because we set up SigBuffers to point to the right place.
    //

    SendHeader->Length = SendBufferLength + SIGNED_PACKET_EMPTY_LENGTH;
    SendHeader->SequenceNumber = SendSequenceNumber;
    SendHeader->FragmentNumber = 1;
    SendHeader->FragmentTotal = 1;

    //
    // Do an exchange with the server.
    //

ReSend:

    Status = UdpSendAndReceive(
                 SendHeader,
                 SendBufferLength + SIGN_HEADER_SIZE,
                 SendRemoteHost,
                 SendRemotePort,
                 SendRetryCount,
                 ReceiveHeader,
                 INCOMING_MESSAGE_LENGTH,
                 ReceiveRemoteHost,
                 ReceiveRemotePort,
                 ReceiveTimeout,
                 3,             // signature count
                 ResultSigs,    // signatures we look for
                 SendSequenceNumber);   // response should have the same one

    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_IO_TIMEOUT) {
            return (ULONG)-1;
        } else {
            return (ULONG)-2;
        }
    }

    //
    // Was it an error?
    //

    if (memcmp(ReceiveHeader->Signature, ErrorSignedSignature, 4) == 0) {

        DPRINT( ERROR, ("SignSendAndReceive: got ERR response\n") );
        return (ULONG)-2;

    }

    //
    // Was the client not recognized by the server?
    //

    if (memcmp(ReceiveHeader->Signature, UnrecognizedClientSignature, 4) == 0) {

        DPRINT( ERROR, ("SignSendAndReceive: got UNR response\n") );
        return (ULONG)-1;

    }

    if (ReceiveHeader->Length < (ULONG)SIGNED_PACKET_EMPTY_LENGTH) {
        DPRINT( ERROR, ("SignSendAndReceive: response is only %d bytes!\n", ReceiveHeader->Length) );
        ++ResendCount;
        if (ResendCount > SendRetryCount) {
            return (ULONG)-2;
        }
        goto ReSend;
    }

    //
    // If there are fragments, then try to receive the rest of them.
    //

    if (ReceiveHeader->FragmentTotal != 1) {

        //
        // Make sure this is fragment 1 -- otherwise the first one
        // was probably dropped and we should re-request it.
        //

        if (ReceiveHeader->FragmentNumber != 1) {
            DPRINT( ERROR, ("UdpReceive got non-first fragment\n") );
            ++ResendCount;
            if (ResendCount > SendRetryCount) {
                return (ULONG)-1;
            }
            goto ReSend;   // redoes the whole exchange.
        }


        FragmentTotal = ReceiveHeader->FragmentTotal;
        ReceivedDataBytes = ReceiveHeader->Length - SIGNED_PACKET_EMPTY_LENGTH;

        for (FragmentNumber = 1; FragmentNumber < FragmentTotal; FragmentNumber ++) {

ReReceive:

            //
            // NULL out the start of the receive buffer.
            //

            memset(TempFragment, 0x0, sizeof(FRAGMENT_PACKET));

            length = UdpReceive(
                        TempFragment,
                        TEMP_INCOMING_MESSAGE_LENGTH,
                        ReceiveRemoteHost,
                        ReceiveRemotePort,
                        ReceiveTimeout);

            if ( length == 0 ) {
                DPRINT( ERROR, ("UdpReceive timed out\n") );
                ++ResendCount;
                if (ResendCount > SendRetryCount) {
                    return (ULONG)-1;
                }
                goto ReSend;   // redoes the whole exchange.
            }

            //
            // Make sure the signature is one of the ones we expect -- only
            // worry about the ResultSignature because we won't get an
            // error response on any fragment besides the first.
            //
            // Also make sure that the
            // sequence number is correct, if asked to check (0 means don't
            // check). If it's not, then go back and wait for another packet.
            //

            if ((TempFragment->Length < (ULONG)FRAGMENT_PACKET_EMPTY_LENGTH) ||
                (memcmp(TempFragment->Signature, ResultSigs[0], 4) != 0) ||
                ((SendSequenceNumber != 0) &&
                 (SendSequenceNumber != TempFragment->SequenceNumber))) {

                DPRINT( ERROR, ("UdpReceive got wrong signature or sequence number\n") );
                goto ReReceive;

            }

            //
            // Check that the fragment number is also correct.
            //

            if (TempFragment->FragmentNumber != FragmentNumber+1) {

                DPRINT( ERROR, ("UdpReceive got wrong fragment number\n") );
                goto ReReceive;

            }

            //
            // Make sure that this fragment won't overflow the buffer.
            //

            if (ReceivedDataBytes + (TempFragment->Length - FRAGMENT_PACKET_EMPTY_LENGTH) >
                ReceiveBufferLength) {
                return (ULONG)-3;
            }

            //
            // This is the correct fragment, so copy it over and loop
            // to the next fragment.
            //

            memcpy(
                &ReceiveHeader->Data[ReceivedDataBytes],
                TempFragment->Data,
                TempFragment->Length - FRAGMENT_PACKET_EMPTY_LENGTH);

            ReceivedDataBytes += TempFragment->Length - FRAGMENT_PACKET_EMPTY_LENGTH;

        }

        //
        // When we are done getting everything, modify the length in the
        // incoming packet to match the total length (currently it will
        // just have the length of the first fragment.
        //

        ReceiveHeader->Length = ReceivedDataBytes + SIGNED_PACKET_EMPTY_LENGTH;

        DPRINT( OSC, ("Got packet with %d fragments, total length %d\n",
            FragmentTotal, ReceiveHeader->Length) );

    }

    //
    // Make sure the sign is the length we expect!!
    //

    if (LoggedIn == TRUE &&
        ReceiveHeader->SignLength != NTLMSSP_MESSAGE_SIGNATURE_SIZE)
    {
        DPRINT( ERROR, ("SignSendAndReceive: signature length is %d bytes!\n", ReceiveHeader->SignLength) );
        ++ResendCount;
        if (ResendCount > SendRetryCount) {
            return (ULONG)-2;
        }
        goto ReSend;
    }
    else if ( LoggedIn == FALSE &&
              ReceiveHeader->SignLength != 0 )
    {
        DPRINT( ERROR, ("SignSendAndReceive: signature length is not 0 bytes (=%u)!\n", ReceiveHeader->SignLength) );
        ++ResendCount;
        if (ResendCount > SendRetryCount) {
            return (ULONG)-2;
        }
        goto ReSend;
    }

    if ( LoggedIn )
    {
        SigBuffers[1].pvBuffer = ReceiveHeader->Sign;
        SigBuffers[1].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        SigBuffers[1].BufferType = SECBUFFER_TOKEN;

        SigBuffers[0].pvBuffer = ReceiveBuffer;
        SigBuffers[0].cbBuffer = ReceiveHeader->Length - SIGNED_PACKET_EMPTY_LENGTH;
        SigBuffers[0].BufferType = SECBUFFER_DATA;

        SignMessage.pBuffers = SigBuffers;
        SignMessage.cBuffers = 2;
        SignMessage.ulVersion = 0;

#ifndef ONLY_SIGN_MESSAGES
        SecStatus = UnsealMessage(
                            &ClientContextHandle,
                            &SignMessage,
                            0,
                            0 );

        if ( SecStatus != SEC_E_OK ) {
            DPRINT( ERROR, ("UnsealMessage: %lx\n", SecStatus) );
            return (ULONG)-2;
        }
#else
        SecStatus = VerifySignature(
                            &ClientContextHandle,
                            &SignMessage,
                            0,
                            0 );

        if ( SecStatus != SEC_E_OK ) {
            DPRINT( ERROR, ("VerifySignature: %lx\n", SecStatus) );
            return (ULONG)-2;
        }
#endif
    }

    //
    // Sucess, so return.
    //

    return (ReceiveHeader->Length - SIGNED_PACKET_EMPTY_LENGTH);

}

#if defined(REMOTE_BOOT)
//
// write secret based on the CREATE_DATA structure
//
VOID
BlWriteSecretFromCreateData(
    PCREATE_DATA CreateData
    )
{
    ULONG FileId;
    RI_SECRET Secret;
    ARC_STATUS ArcStatus;
    UNICODE_STRING TmpNtPassword;
    CHAR TmpLmOwfPassword[LM_OWF_PASSWORD_SIZE];
    CHAR TmpNtOwfPassword[NT_OWF_PASSWORD_SIZE];

    TraceFunc("BlWriteSecretFromCreateData( )\n");

    //
    // Write the secret. This is the secret for the machine account
    // created by BINL, not for the user that logged on.
    //

    if (BlOpenRawDisk(&FileId) == ESUCCESS) {

        if (BlCheckForFreeSectors(FileId) == ESUCCESS) {

            TmpNtPassword.Length = (USHORT)CreateData->UnicodePasswordLength;
            TmpNtPassword.MaximumLength = sizeof(CreateData->UnicodePassword);
            TmpNtPassword.Buffer = CreateData->UnicodePassword;

            BlOwfPassword(
                CreateData->Password,
                &TmpNtPassword,
                TmpLmOwfPassword,
                TmpNtOwfPassword);

            BlInitializeSecret(
                CreateData->Domain,
                CreateData->Name,
                TmpLmOwfPassword,
                TmpNtOwfPassword,
                NULL,               // no password 2
                NULL,               // no password 2
                CreateData->Sid,
                &Secret);

            //
            // Copy the cleartext UnicodePassword into the reserved
            // section. The reserved section has the length followed
            // by the data (up to 32 WCHARs).
            //

            (*(ULONG UNALIGNED *)(Secret.Reserved)) = CreateData->UnicodePasswordLength;
            RtlCopyMemory(
                Secret.Reserved + sizeof(ULONG),
                CreateData->UnicodePassword,
                CreateData->UnicodePasswordLength);

            ArcStatus = BlWriteSecret(FileId, &Secret);

            if (ArcStatus != ESUCCESS) {
                DPRINT( ERROR, ("BlWriteSecret: status is %d\n", ArcStatus) );
            }

        }

        BlCloseRawDisk(FileId);
    }
}
#endif // defined(REMOTE_BOOT)

//
// Retrieve next screen
//
BOOL
BlRetrieveScreen(
    ULONG *SequenceNumber,
    PCHAR OutMessage,
    PCHAR InMessage
    )
{
    ARC_STATUS Status;
    ULONG OutMessageLength = strlen( OutMessage );
    ULONG InMessageLength;
    PCREATE_DATA CreateData;

    TraceFunc("BlRetrieveScreen( )\n");

    // make sure we don't over flow the output buffer
    if ( OutMessageLength > 1023 ) {
        OutMessageLength = 1023;
        OutMessage[OutMessageLength] = '\0';
    }

    ++(*SequenceNumber);
    if ( *SequenceNumber > 0x2000 )
    {
        *SequenceNumber = 1;
    }

    if (!LoggedIn)
    {
#ifdef _TRACE_FUNC_
        TraceFunc( "Sending RQU ");
        DPRINT( OSC, ("(%u)...\n", *SequenceNumber) );
#endif

        memcpy( OutgoingSignedMessage->Data, OutMessage, OutMessageLength );

        Status = SignSendAndReceive(
                    OutgoingSignedMessage->Data,
                    OutMessageLength,
                    NetServerIpAddress,
                    BINL_PORT,
                    RECEIVE_RETRIES,
                    *SequenceNumber,
                    ClientContextHandle,
                    IncomingSignedMessage->Data,
                    INCOMING_MESSAGE_LENGTH - SIGN_HEADER_SIZE,
                    &RemoteHost,
                    &RemotePort,
                    RECEIVE_TIMEOUT);

    }
    else
    {

#ifdef _TRACE_FUNC_
        TraceFunc( "Sending Seal/Signed REQS " );
        DPRINT( OSC, ("(%u)...\n", *SequenceNumber) );
#endif

        while (TRUE)
        {

            memcpy( OutgoingSignedMessage->Data, OutMessage, OutMessageLength );

            Status = SignSendAndReceive(
                        OutgoingSignedMessage->Data,
                        OutMessageLength,
                        NetServerIpAddress,
                        BINL_PORT,
                        RECEIVE_RETRIES,
                        *SequenceNumber,
                        ClientContextHandle,
                        IncomingSignedMessage->Data,
                        INCOMING_MESSAGE_LENGTH - SIGN_HEADER_SIZE,
                        &RemoteHost,
                        &RemotePort,
                        RECEIVE_TIMEOUT);

            if ((Status == 0) || (Status == (ULONG)-2))
            {
                DPRINT( OSC, ("Attempting to re-login\n") );

                //
                // We assume that the server has dropped the current login
                // and don't bother calling BlDoLogoff();
                //
                LoggedIn = FALSE;

                Status = BlDoLogin( );

                *SequenceNumber = 1;

                if (Status == STATUS_SUCCESS)
                {
                    DPRINT( ERROR, ("Successfully re-logged in\n") );
                    memcpy(OutgoingSignedMessage->Data, OutMessage, OutMessageLength);
                    LoggedIn = TRUE;
                    continue;
                }
                else
                {
                    DPRINT( ERROR, ("ERROR - could not re-login, %x\n", Status) );
                    //DbgBreakPoint();

                    //
                    // Call ourselves again, but request the LoginErr screen which
                    // is 00004e28.
                    //
                    strcpy( OutMessage, "00004e28\n" );
                    return BlRetrieveScreen( SequenceNumber, OutMessage, InMessage );
                }
            }
            else if (Status == (ULONG)-1)
            {
                DPRINT( ERROR, ("Unrecognized, requested TIMEOUT screen\n") );

                //
                // We assume that the server has dropped the current login
                //
                LoggedIn = FALSE;

                //
                // Increase the sequence number for the new screen request,
                // don't worry about wrapping since the session will die soon.
                //

                ++(*SequenceNumber);

                //
                // Call ourselves again, but request the TIMEOUT screen.
                //
                strcpy( OutMessage, "00004E2A\n" );
                return BlRetrieveScreen( SequenceNumber, OutMessage, InMessage );
            }
            else if (Status == (ULONG)-3)
            {
                DPRINT( ERROR, ("Unrecognized, requested TOO LONG screen\n") );

                //
                // This screen is a fatal error, so don't worry about
                // staying logged in.
                //
                LoggedIn = FALSE;

                //
                // Increase the sequence number for the new screen request,
                // don't worry about wrapping since the session will die soon.
                //

                ++(*SequenceNumber);

                //
                // Call ourselves again, but request the TIMEOUT screen.
                //
                strcpy( OutMessage, "00004E53\n" );
                return BlRetrieveScreen( SequenceNumber, OutMessage, InMessage );
            }
            else
            {
                break;
            }
        }

    }

    //
    // NULL-terminate it.
    //
    IncomingSignedMessage->Data[IncomingSignedMessage->Length - SIGNED_PACKET_EMPTY_LENGTH] = '\0';
    strcpy( InMessage, IncomingSignedMessage->Data );
    InMessageLength = strlen(InMessage);

    // DumpBuffer( InMessage, strlen(InMessage) );

    //
    // If we got an just an ACCT response, with no screen data, that means a
    // restart is happening.
    //
    if (memcmp(InMessage, "ACCT", 4) == 0)
    {
        CreateData = (PCREATE_DATA) IncomingSignedMessage->Data;
#if defined(REMOTE_BOOT)
        //
        // If doing remote BOOT (as opposed to install) enable this.
        //
        BlWriteSecretFromCreateData( CreateData );
#endif // defined(REMOTE_BOOT)

        DPRINT( OSC, ("Trying to reboot to <%s>\n", CreateData->NextBootfile) );
        strcpy(NextBootfile, CreateData->NextBootfile);
        strcpy(SifFile, CreateData->SifFile);
        DoSoftReboot = TRUE;
        return FALSE;   // exit message loop
    }

    //
    // If we got a screen with an ACCT response after the screen data,
    // should write the secret and do a soft reboot. In this situation
    // InMessageLength will only include the screen data itself, but
    // IncomingSignedMessage->Length will include the whole thing.
    //
    if ((IncomingSignedMessage->Length - SIGNED_PACKET_EMPTY_LENGTH) ==
        (InMessageLength + 1 + sizeof(CREATE_DATA))) {

        CreateData = (PCREATE_DATA) (InMessage + InMessageLength + 1);
        if (memcmp(CreateData->Id, "ACCT", 4) == 0) {

#if defined(REMOTE_BOOT)
            //
            // If doing remote BOOT (as opposed to install) enable this.
            //
            BlWriteSecretFromCreateData( CreateData );
#endif // defined(REMOTE_BOOT)

            DPRINT( OSC, ("INSTALL packet setting up reboot to <%s>\n", CreateData->NextBootfile) );
            strcpy(NextBootfile, CreateData->NextBootfile);
            strcpy(SifFile, CreateData->SifFile);
            DoSoftReboot = TRUE;

            //
            // Don't return FALSE, because we still want to show the INSTALL
            // screen. NextBootFile/SifFile/DoSoftReboot won't be modified by
            // that so we will do a proper soft reboot when the time comes.
            //
        }
    }

    // Special-case server tells us to LAUNCH a file

    if (memcmp(InMessage, "LAUNCH", 6) == 0) {

        CreateData = (PCREATE_DATA) (IncomingSignedMessage->Data + 7);
        DPRINT( OSC, ("Trying to launch <%s>\n", CreateData->NextBootfile) );

        strcpy(NextBootfile, CreateData->NextBootfile);
        strcpy(SifFile, CreateData->SifFile);
        if (CreateData->RebootParameter == OSC_REBOOT_COMMAND_CONSOLE_ONLY) {
            NetRebootParameter = NET_REBOOT_COMMAND_CONSOLE_ONLY;
        } else if (CreateData->RebootParameter == OSC_REBOOT_ASR) {
            NetRebootParameter = NET_REBOOT_ASR;
        }
        DoSoftReboot = TRUE;
        return FALSE;    // exit message loop
    }

    // Special-case REBOOT - server told us to reboot.

    if (memcmp(InMessage, "REBOOT", 6) == 0)
    {
        return FALSE;   // exit message loop
    }

#if defined(REMOTE_BOOT)
    // Special-case GETCREATE - should reboot after we get this

    if (memcmp(InMessage, "GETCREATE", 9) == 0) {

        CreateData = (PCREATE_DATA) (IncomingSignedMessage->Data + 10);
        BlWriteSecretFromCreateData( CreateData );
        //
        // We were soft rebooted to, and it told us where to go back to
        // in NetRebootFile.
        //
        NetRebootParameter = NET_REBOOT_SECRET_VALID;
        strcpy(NextBootfile, NetRebootFile);
        SifFile[0] = '\0';
        DoSoftReboot = TRUE;
        return FALSE;    // exit message loop
    }

    // Special-case REPLDONE - write the secret, then do normal processing.
    // The secret is sent as binary data immediately after the screen.
    //
    // This check for "NAME REPLDONE" is obsolete now that we use OSCML.
    //

    if (memcmp(InMessage, "NAME REPLDONE", 13) == 0) {
        CreateData = (PCREATE_DATA) (InMessage + strlen(InMessage) + 1);
        BlWriteSecretFromCreateData( CreateData );
        //
        // Set this so the user won't be sent back to us to logon for
        // te disk having changed.
        //
        NetRebootParameter = NET_REBOOT_SECRET_VALID;
        strcpy(NextBootfile, CreateData->NextBootfile);
        SifFile[0] = '\0';
        DoSoftReboot = TRUE;
    }
#endif // defined(REMOTE_BOOT)

    return TRUE;    // stay in message loop
}


ARC_STATUS
BlOsLoader (
    IN ULONG Argc,
    IN PCHAR Argv[],
    IN PCHAR Envp[]
    )

/*++

Routine Description:

    This is the main routine that controls the loading of the NT operating
    system on an ARC compliant system. It opens the system partition,
    the boot partition, the console input device, and the console output
    device. The NT operating system and all its DLLs are loaded and bound
    together. Control is then transfered to the loaded system.

Arguments:

    Argc - Supplies the number of arguments that were provided on the
        command that invoked this program.

    Argv - Supplies a pointer to a vector of pointers to null terminated
        argument strings.

    Envp - Supplies a pointer to a vector of pointers to null terminated
        environment variables.

Return Value:

    EBADF is returned if the specified OS image cannot be loaded.

--*/

{
    CHAR OutputBuffer[256];
    ULONG Count;
    ARC_STATUS Status;
    SECURITY_STATUS SecStatus;  // NOTE: This is a SHORT, so not an NTSTATUS failure on error
    ULONG PackageCount;
    PVOID LoaderBase;

    //
    // Initialize the OS loader console input and output.
    //

    Status = BlInitStdio(Argc, Argv);
    if (Status != ESUCCESS) {
        return Status;
    }

    //
    // Initialize the boot debugger for platforms that directly load the
    // OS Loader.
    //
    // N.B. This must occur after the console input and output have been
    //      initialized so debug messages can be printed on the console
    //      output device.
    //
#if defined(_ALPHA_) || defined(ARCI386) || defined(_IA64_)
    
    //
    // If the program memory descriptor was found, then compute the base
    // address of the OS Loader for use by the debugger.
    //
    LoaderBase = &__ImageBase;

    BlPrint(TEXT("about to init debugger...\r\n"));

    //
    // Initialize traps and the boot debugger.
    //
#if defined(ENABLE_LOADER_DEBUG)

#if defined(_ALPHA_)
    BdInitializeTraps();
#endif

    BdInitDebugger("oschoice.exe", LoaderBase, ENABLE_LOADER_DEBUG);

#else

    BdInitDebugger("oschoice.exe", LoaderBase, NULL);

#endif

#endif

    BlPrint(TEXT("back from initializing debugger...\r\n"));

#if DBG
//    NetDebugFlag |= 0x147;
#endif

    TraceFunc("BlOsLoader( )\n");

    //
    // Announce OS Loader.
    //

    BlpClearScreen();
#if 1
#ifdef UNICODE
    BlPrint(OsLoaderVersionW);
#else
    BlPrint(OsLoaderVersion);
#endif
#else
    strcpy(&OutputBuffer[0], OsLoaderVersion);
    ArcWrite(BlConsoleOutDeviceId,
             &OutputBuffer[0],
             strlen(&OutputBuffer[0]),
             &Count);
#endif

    //
    // Initialize the memory descriptor list, the OS loader heap, and the
    // OS loader parameter block.
    //
    
#if 0
//
// bugbug: we already do this in SuMain()
//
    BlPrint(TEXT("about to BlMemoryInitialize...\r\n"));
    Status = BlMemoryInitialize();
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_MEM_CLASS,
                     DIAG_BL_MEMORY_INIT,
                     LOAD_HW_MEM_ACT);

        goto LoadFailed;
    }
#endif

    //
    // Initialize the network.
    //

    NetGetRebootParameters(&NetRebootParameter, NetRebootFile, NULL, NULL, NULL, NULL, NULL, TRUE);

    DPRINT( OSC, ("Initializing the network\n") );

    Status = NetInitialize();

    if (Status != ESUCCESS) {
        return Status;
    }


#ifndef EFI
    //
    // Get ourselves a UDP port.
    //

    LocalPort = UdpAssignUnicastPort();

    DPRINT( OSC, ("Using port %x\n", LocalPort) );
#endif

    //
    // Initialize the security package.
    //

    DPRINT( OSC, ("Initializing security package\n") );

    SecStatus = EnumerateSecurityPackagesA( &PackageCount, &PackageInfo );

    if (SecStatus == SEC_E_OK) {
        DPRINT( OSC, ("NTLMSSP: PackageCount: %ld\n", PackageCount) );
        DPRINT( OSC, ("Name: %s Comment: %s\n", PackageInfo->Name, PackageInfo->Comment) );
        DPRINT( OSC, ("Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken) );
    } else {
        DPRINT( ERROR, ("NTLMSSP: Enumerate failed, %d\n", SecStatus) );
    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfoA( NTLMSP_NAME_A, &PackageInfo );

    if ( SecStatus != SEC_E_OK ) {
        DPRINT( ERROR, ("QuerySecurityPackageInfo failed %d", SecStatus) );
        return SecStatus;
    }

    //
    // Detect the Hal type
    //
    if (!BlDetectHal()) {
        //
        // just fall through if it fails, it's not the end of the world
        //
        HalType[0] = '\0';
        HalDescription[0] = '\0';
        DPRINT( ERROR, ("BlDetectHal failed.\n") );
    }

    //
    // Process screens, loggons, etc... we come back after a "REBOOT"
    // was indicated.
    //
    BlMainLoop( );


    //
    // Inform boot debugger that the boot phase is complete.
    //
    // N.B. This is x86 only for now.
    //

#if defined(_X86_)

    DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);

#endif

#ifdef EFI
    BlEfiSetAttribute( DEFATT );
#else
    BlpSendEscape(";0;37;40m");
#endif
    BlpSetInverseMode( FALSE );
    BlpClearScreen();
    BlPrint(TEXT("Waiting for reboot...\n"));
#ifndef EFI
    HW_CURSOR(1,0);
#endif


    if (DoSoftReboot) {
        Status = NetSoftReboot(
                     NextBootfile,
                     NetRebootParameter,
                     NULL,     // reboot file
                     SifFile,
                     UserName,
                     DomainName,
                     Password,
                     AdministratorPassword);   // this only returns on an error

    } else {
        DPRINT( OSC, ("calling ArcRestart()\n") );
        ArcRestart();
    }

    BlPrint(TEXT("Reboot failed... Press ALT+CTL+DEL to reboot.\n"));

//LoadFailed:
    return Status;

}


//
//
//
ARC_STATUS
BlProcessLogin(
    PCHAR OutgoingMessage )
{
    //
    // If this is the login screen, remember some of the inputs
    // ourselves.
    //
    ARC_STATUS Status;
    UNICODE_STRING TmpNtPassword;
    PCHAR AtSign;
    int i;

    TraceFunc("BlProcessLogin( )\n");

    //
    // We could be trying to log another person in so log off the
    // current user.
    //
    if ( LoggedIn == TRUE )
    {
        BlDoLogoff();
        LoggedIn = FALSE;
    }

    DPRINT( OSC, ("Login info: Domain <%s>, User <%s>, Password<%s>\n", DomainName, UserName, "*") );

    //
    // Do a quick conversion of the password to Unicode.
    //

    TmpNtPassword.Length = strlen(Password) * sizeof(WCHAR);
    TmpNtPassword.MaximumLength = sizeof(UnicodePassword);
    TmpNtPassword.Buffer = UnicodePassword;

    for (i = 0; i < sizeof(Password); i++) {
        UnicodePassword[i] = (WCHAR)(Password[i]);
    }

    BlOwfPassword(Password, &TmpNtPassword, LmOwfPassword, NtOwfPassword);

    Status = BlDoLogin( );

    DPRINT( OSC, ("Login returned: %x\n", Status) );

    return Status;
}

//
//
//
VOID
BlMainLoop(
    )
{
    ULONG SequenceNumber;
    int len;
    PUCHAR psz;
    PUCHAR pch;
    UCHAR OutgoingMessage[1024];
    PUCHAR IncomingMessage;

    TraceFunc("BlMainLoop( )\n");

    //
    // These all point into our single outgoing and incoming buffers.
    //
    OutgoingSignedMessage = (SIGNED_PACKET UNALIGNED *)OutgoingMessageBuffer;
    IncomingSignedMessage = (SIGNED_PACKET UNALIGNED *)IncomingMessageBuffer;

    DomainName[0] = '\0';
    UserName[0] = '\0';
    Password[0] = '\0';

    SequenceNumber = 0;

    //
    // Ask the server for the initial screen
    //
#if defined(REMOTE_BOOT)
    if (NetRebootParameter == NET_REBOOT_WRITE_SECRET_ONLY) {
        strcpy( OutgoingMessage, "LOGIN\n" );    // first screen is logon.
    } else
#endif // defined(REMOTE_BOOT)
    {
        strcpy( OutgoingMessage, "\n" );    // first screen name is <blank>.
    }
    IncomingMessage = IncomingSignedMessage->Data;

    SpecialAction = ACTION_NOP;
    while ( SpecialAction != ACTION_REBOOT )
    {
        CHAR LastKey;

        //
        // Retrieve next screen
        //
#if 0
        IF_DEBUG(OSC) {
            DPRINT( OSC, ("Dumping OutgoingingMessage buffer:\r\n" ) );
            DumpBuffer( (PVOID)OutgoingMessage, 256 );
        }
#endif
        if (!BlRetrieveScreen( &SequenceNumber, OutgoingMessage, IncomingMessage ) )
            break;

        //
        // Process the screen and get user input
        //
        LastKey = BlProcessScreen( IncomingMessage, OutgoingMessage );

        DPRINT( OSC, ("LastKey = 0x%02x\nAction = %u\nResults:\n%s<EOM>\n",
                LastKey, SpecialAction, OutgoingMessage) );

        switch ( SpecialAction )
        {
        case ACTION_LOGIN:
            DPRINT( OSC, ("[SpecialAction] Logging in\n") );
            if ( STATUS_SUCCESS == BlProcessLogin( OutgoingMessage ) )
            {
#if defined(REMOTE_BOOT)
                //
                // If we are only logging on for machine replacement, then request
                // the GETCREATE screen -- we will reboot once we get the
                // response.
                //
                if (NetRebootParameter == NET_REBOOT_WRITE_SECRET_ONLY) {
                    //
                    // Find the current screen name (probably "CHOICE") and
                    // replace it with "GETCREATE").
                    //
                    ULONG OriginalLen = strlen(OutgoingMessage) + 1; // include the '\0'
                    ULONG CurrentScreenLen = (strchr(OutgoingMessage, '\n') - OutgoingMessage);
                    ULONG GetCreateLen = strlen("GETCREATE");

                    if (CurrentScreenLen != GetCreateLen) {
                        memmove(OutgoingMessage + GetCreateLen,
                                OutgoingMessage + CurrentScreenLen,
                                OriginalLen - CurrentScreenLen);
                    }
                    memcpy(OutgoingMessage, "GETCREATE", GetCreateLen);
                }
#endif // defined(REMOTE_BOOT)

                DPRINT( OSC, ("Validate Results are still the same:\n%s<EOM>\n",
                        OutgoingMessage) );

                LoggedIn = TRUE;
                SequenceNumber = 0;
                //
                // If the welcome screen was processed, then add some extra
                // outgoing predetermined variables.
                //
                // Add NIC address
                //
                //  Convert NIC address 0x00a0c968041c to a string
                //

                //
                // Make sure the outgoing has a \n after the screen name
                //
                if ( OutgoingMessage[ strlen(OutgoingMessage) - 1 ] != '\n' )
                {
                    strcat( OutgoingMessage, "\n" );
                }

                strcat( OutgoingMessage, "MAC=" );

                len = 6;
                psz = &OutgoingMessage[ strlen( OutgoingMessage ) ];
                pch = (PCHAR) NetLocalHardwareAddress;

                while (len--) {
                    UCHAR c = *(pch++);
                    *(psz++) = rghex [(c >> 4) & 0x0F] ;
                    *(psz++) = rghex [c & 0x0F];
                }
                *psz = '\0';    // terminate

                //
                // Add the Guid
                //
                pch = NULL;
                len = 0;
                GetGuid(&pch, &len);

                if ((len != 0) && (pch!=NULL)) {
                    
                    strcat( OutgoingMessage, "\nGUID=" );
                    psz = &OutgoingMessage[ strlen( OutgoingMessage ) ];                

                    while (len--) {
                        UCHAR c = *(pch++);
                        *(psz++) = rghex [(c >> 4) & 0x0F] ;
                        *(psz++) = rghex [c & 0x0F];
                    }

                    *psz = '\0';    // terminate
                }

                //
                // if we detected the HAL, specify it here
                //
                if (HalType[0] != '\0') {
                    strcat( OutgoingMessage, "\nHALTYPE=" );
                    strcat( OutgoingMessage, HalType );

                    if (HalDescription[0] != '\0') {
                        strcat( OutgoingMessage, "\nHALTYPEDESCRIPTION=" );
                        strcat( OutgoingMessage, HalDescription );
                    }
                }

                //
                // Add the machine type
                //
#if defined(_ALPHA_)
                strcat( OutgoingMessage, "\nMACHINETYPE=Alpha\n" );    // add machinetype
#else

    #if defined(_IA64_)
                    strcat( OutgoingMessage, "\nMACHINETYPE=ia64\n" );    // add machinetype
    #else // INTEL
                    strcat( OutgoingMessage, "\nMACHINETYPE=i386\n" );    // add machinetype
    #endif // _IA64_

#endif

#if defined(REMOTE_BOOT)
                //
                // If we are diskless, tell BINL.
                //

                if (BlIsDiskless()) {
                    strcat( OutgoingMessage, "DISKLESS=1\n" );
                }
#endif // defined(REMOTE_BOOT)

                //
                // Tell BINL to verify the domain, because otherwise
                // the SSPI package on the server will allow the login
                // to succeed with an invalid domain. BINL will delete
                // this variable from the client state on the server
                // once it does the domain check.
                //

                strcat( OutgoingMessage, "CHECKDOMAIN=1\n" );

            }
            else
            {
                //
                // Goto the Login Error Screen which is
                // 00004e28.
                //
                strcpy( OutgoingMessage, "00004e28\n" );
                LoggedIn = FALSE;
            }
            break;
        }
    }

    //
    // If we logged on successfully, then log off.
    //
    if (LoggedIn)
    {
        BlDoLogoff();
    }
}


//
//
//
ULONG
BlDoLogin (    )
{
    ARC_STATUS Status;
    SECURITY_STATUS SecStatus;
    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;
    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;
    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;
    ULONG ContextAttributes;
    SEC_WINNT_AUTH_IDENTITY_A AuthIdentity;
    TimeStamp Lifetime;
    PCHAR ResultSigs[2];
    UCHAR FlipServerList[MAX_FLIP_SERVER_COUNT * 4];
    ULONG FlipServerCount;
    ULONG CurFlipServer;
    UCHAR OwfPasswords[LM_OWF_PASSWORD_SIZE + NT_OWF_PASSWORD_SIZE];
    PLOGIN_PACKET OutgoingLoginMessage;
    PLOGIN_PACKET IncomingLoginMessage;

    OutgoingLoginMessage = (LOGIN_PACKET *) OutgoingMessageBuffer;
    IncomingLoginMessage = (LOGIN_PACKET *) IncomingMessageBuffer;

    TraceFunc("BlDoLogin( )\n");

    //
    // Delete both contexts if needed.
    //


    if (ClientContextHandleValid) {

        SecStatus = DeleteSecurityContext( &ClientContextHandle );
        ClientContextHandleValid = FALSE;

    }


    if (CredentialHandleValid) {

        SecStatus = FreeCredentialsHandle( &CredentialHandle );
        CredentialHandleValid = FALSE;

    }


    //
    // Acquire a credential handle for the client side. The password
    // we supply is the LM OWF password and the NT OWF password
    // concatenated together.
    //

    memcpy( OwfPasswords, LmOwfPassword, LM_OWF_PASSWORD_SIZE );
    memcpy( OwfPasswords+LM_OWF_PASSWORD_SIZE, NtOwfPassword, NT_OWF_PASSWORD_SIZE );

    RtlZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );

    AuthIdentity.Domain = DomainName;
    AuthIdentity.User = UserName;
    AuthIdentity.Password = OwfPasswords;

#if 0
    IF_DEBUG(OSC) {
        DPRINT( OSC, ("Dumping OwfPasswords:\r\n") );
        DumpBuffer( AuthIdentity.Password, LM_OWF_PASSWORD_SIZE+NT_OWF_PASSWORD_SIZE );
    }
#endif


    DPRINT( OSC, ("About to AcquireCredentialsHandle\n") );

    SecStatus = AcquireCredentialsHandleA(
                    NULL,           // New principal
                    NTLMSP_NAME_A,    // Package Name
                    SECPKG_CRED_OUTBOUND | SECPKG_CRED_OWF_PASSWORD,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle,
                    &Lifetime );

    if ( SecStatus != SEC_E_OK ) {
        DPRINT( ERROR, ("AcquireCredentialsHandle failed: %s ", SecStatus) );
        return SecStatus;
    }

    DPRINT( OSC, ("CredentialHandle: 0x%lx 0x%lx   ",
            CredentialHandle.dwLower, CredentialHandle.dwUpper) );

    CredentialHandleValid = TRUE;

    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = OutgoingLoginMessage->Data;

    SecStatus = InitializeSecurityContextA(
                    &CredentialHandle,
                    NULL,               // No Client context yet
                    NULL,               // No target name needed
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( (SecStatus != SEC_E_OK) && (SecStatus != SEC_I_CONTINUE_NEEDED) ) {
        DPRINT( ERROR, ("InitializeSecurityContext (negotiate): %d" , SecStatus) );
        return SecStatus;
    }

    ClientContextHandleValid = TRUE;


#if 0
    IF_DEBUG(OSC) {
        KdPrint(( "\n\nNegotiate Message:\n" ));
        KdPrint(( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                    ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                    ContextAttributes ));
        PrintTime( "Lifetime: ", Lifetime );
        DumpBuffer( NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }
#endif


    //
    // Send the negotiate buffer to the server and wait for a response.
    //

    memcpy(OutgoingLoginMessage->Signature, NegotiateSignature, 4);
    OutgoingLoginMessage->Length = NegotiateBuffer.cbBuffer;

    TraceFunc("");
    DPRINT( OSC, ("Sending NEG...\n") );

    ResultSigs[0] = ChallengeSignature;
    ResultSigs[1] = NegativeAckSignature;

#if 0
    IF_DEBUG(OSC) {
        KdPrint(( "\n\nNegotiate Message Outgoing Packet:\n" ));
        DumpBuffer( OutgoingLoginMessage, NegotiateBuffer.cbBuffer + LOGIN_PACKET_DATA_OFFSET );
    }
#endif

    Status = UdpSendAndReceive(
                OutgoingLoginMessage,
                NegotiateBuffer.cbBuffer + LOGIN_PACKET_DATA_OFFSET,
                NetServerIpAddress,
                BINL_PORT,
                5,     // retry count
                IncomingLoginMessage,
                INCOMING_MESSAGE_LENGTH,
                &RemoteHost,
                &RemotePort,
                2,      // receive timeout
                2,      // number of signatures
                ResultSigs, // signature we are looking for
                0);     // sequence number (0 means don't check)

    if ( !NT_SUCCESS(Status) ) {        
        DPRINT( ERROR, ("UdpSendAndReceive status is %x\n", Status) );
        return Status;
    }

    //
    // If the response was a NAK, then fail immediately.
    //

    if (memcmp(IncomingLoginMessage->Signature, NegativeAckSignature, 4) == 0) {

        DPRINT( ERROR, ("Received NAK from server\n") );
        return STATUS_LOGON_FAILURE;
    }

#if 0
    IF_DEBUG(OSC) {
        KdPrint(( "\n\nNegotiate Message Incoming Packet: %d %d %d %d\n", 
                  IncomingLoginMessage->Data, 
                  IncomingLoginMessage->Length, 
                  IncomingLoginMessage->Signature, 
                  IncomingLoginMessage->Status ));
        DumpBuffer( IncomingLoginMessage->Data, IncomingLoginMessage->Length );
    }
#endif


    //
    // Get the AuthenticateMessage (ClientSide)
    //

    AuthenticateDesc.ulVersion = 0;
    AuthenticateDesc.cBuffers = 1;
    AuthenticateDesc.pBuffers = &AuthenticateBuffer;

    AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
    AuthenticateBuffer.pvBuffer = OutgoingLoginMessage->Data;

    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = IncomingLoginMessage->Length;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN | SECBUFFER_READONLY;
    ChallengeBuffer.pvBuffer = IncomingLoginMessage->Data;

    DPRINT( OSC, ("About to call InitializeSecurityContext\n") );

    SecStatus = InitializeSecurityContextA(
                    NULL,
                    &ClientContextHandle,
                    NULL,               // No target name needed
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    &ChallengeDesc,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( (SecStatus != SEC_E_OK) ) {        
        DPRINT( OSC, ("InitializeSecurityContext (Authenticate): %d\n", SecStatus) );
        return SecStatus;
    }

    //
    // Send the authenticate buffer to the server and wait for the response.
    //

    if (AllowFlip) {
        memcpy(OutgoingLoginMessage->Signature, AuthenticateSignature, 4);
    } else {
        memcpy(OutgoingLoginMessage->Signature, AuthenticateFlippedSignature, 4);
    }
    OutgoingLoginMessage->Length = AuthenticateBuffer.cbBuffer;

    TraceFunc("");
    DPRINT( OSC, ("Sending AUTH...\n") );

#if 0
    IF_DEBUG(OSC) {
        KdPrint(( "\n\nAuth Message Outgoing Packet:\n" ));
        DumpBuffer( OutgoingLoginMessage, AuthenticateBuffer.cbBuffer + LOGIN_PACKET_DATA_OFFSET );
    }
#endif


    ResultSigs[0] = ResultSignature;

    Status = UdpSendAndReceive(
                OutgoingLoginMessage,
                AuthenticateBuffer.cbBuffer + LOGIN_PACKET_DATA_OFFSET,
                NetServerIpAddress,
                BINL_PORT,
                10,        // retry count
                IncomingLoginMessage,
                INCOMING_MESSAGE_LENGTH,
                &RemoteHost,
                &RemotePort,
                5,         // receive timeout
                1,         // number of signatures we are looking for
                ResultSigs,   // signatures we look for
                0);     // sequence number (0 means don't check)

    if ( !NT_SUCCESS(Status) ) {        
        DPRINT( ERROR, ("UdpSendAndReceive status is %x\n", Status) );
        return Status;
    }

#if 0
    IF_DEBUG(OSC) {
        KdPrint(( "\n\nAuthenticateBuffer Message Incoming Packet: %d %d %d %d\n", 
                  IncomingLoginMessage->Data, 
                  IncomingLoginMessage->Length, 
                  IncomingLoginMessage->Signature, 
                  IncomingLoginMessage->Status ));
        DumpBuffer( IncomingLoginMessage->Data, IncomingLoginMessage->Length );
    }
#endif


    if (memcmp(IncomingLoginMessage->Signature, ResultSignature, 4) == 0) {

        //
        // Login has completed/failed, check status.
        //

        if ( IncomingLoginMessage->Status == STATUS_SUCCESS) {

            TraceFunc("Login successful\n");

            //
            // If we are allowed to be flipped, then check if there is a
            // flip list in the response, and if so try to log in to each one
            // until we succeed at one.
            //

            if (AllowFlip) {

                AllowFlip = FALSE;   // once we have been flipped, don't do it again

                if (IncomingLoginMessage->Length > 4) {

                    FlipServerCount = (IncomingLoginMessage->Length - 4) / 4;
                    if (FlipServerCount > MAX_FLIP_SERVER_COUNT) {
                        FlipServerCount = MAX_FLIP_SERVER_COUNT;
                    }

                    memcpy(
                        FlipServerList,
                        (PUCHAR)(&IncomingLoginMessage->Status) + sizeof(ULONG),
                        FlipServerCount * 4
                        );

                    //
                    // If the first server in the list is our current server,
                    // then don't flip.
                    //

                    if (*(ULONG *)FlipServerList == NetServerIpAddress) {
                        DPRINT( OSC, ("Not flipping, first server is the same\n") );
                        return STATUS_SUCCESS;
                    }

                    DPRINT( OSC, ("Trying %d flip servers\n", FlipServerCount) );

                    for (CurFlipServer = 0; CurFlipServer < FlipServerCount; ++CurFlipServer) {

                        //
                        // Logoff the previous server connection.
                        //

                        BlDoLogoff();

                        //
                        // Now connect to the new server.
                        //

                        NetServerIpAddress = *(ULONG *)(&FlipServerList[CurFlipServer*4]);

                        DPRINT( OSC, ("Trying to flip to server %lx\n", NetServerIpAddress) );

                        //
                        // We will only recurse once because *AllowFlip is now FALSE.
                        //

                        Status = BlDoLogin( );

                        DPRINT( OSC, ("Flip server login returned %lx\n", Status) );

                        if (Status == STATUS_SUCCESS) {
                            return Status;
                        }

                    }

                    //
                    // We have tried each flip server in turn and failed!
                    //
                    TraceFunc("ERROR - We have tried each flip server in turn and failed!\n");

                    return STATUS_NO_LOGON_SERVERS;

                }

            }

        } else {

            DPRINT( ERROR, ("ERROR - could not login, %x\n", IncomingLoginMessage->Status) );

        }

        return IncomingLoginMessage->Status;

    } else {

        //
        // Shouldn't get this because we check signatures!!
        //

        DPRINT( ERROR, ("Got wrong message, expecting success or failure\n") );

        return STATUS_UNEXPECTED_NETWORK_ERROR;

    }

}


VOID
BlDoLogoff (
    VOID
    )
{
    ARC_STATUS Status;

    TraceFunc("BlDoLogoff( )\n");
    //
    // Send a logoff message to the server -- for the moment this is
    // just sent once and not acked, since if it is lost the server
    // will eventually timeout.
    //

    memcpy(OutgoingSignedMessage->Signature, LogoffSignature, 4);
    OutgoingSignedMessage->Length = 0;

    Status = UdpSend(
                OutgoingSignedMessage,
                SIGNED_PACKET_DATA_OFFSET,
                NetServerIpAddress,
                BINL_PORT);

    if ( !NT_SUCCESS(Status) ) {
        DPRINT( ERROR, ("UdpSend status is %x\n", Status) );
    }

}



VOID
BlOutputLoadMessage (
    IN PCHAR DeviceName,
    IN PCHAR FileName,
    IN PTCHAR FileDescription OPTIONAL
    )

/*++

Routine Description:

    This routine outputs a loading message to the console output device.

Arguments:

    DeviceName - Supplies a pointer to a zero terminated device name.

    FileName - Supplies a pointer to a zero terminated file name.

    FileDescription - Friendly name of the file in question.

Return Value:

    None.

--*/

{
    ULONG Count;
    CHAR OutputBuffer[256];
    PTCHAR pOutputBuffer;
#ifdef UNICODE
    WCHAR OutputBufferW[256];
    UNICODE_STRING uString;
    ANSI_STRING aString;
    pOutputBuffer = OutputBufferW;
#else
    pOutputBuffer = OutputBuffer;
#endif
    
    UNREFERENCED_PARAMETER( FileDescription );

    //
    // Construct and output loading file message.
    //

    if (!BlOutputDots) {
        strcpy(&OutputBuffer[0], "  ");
        strcat(&OutputBuffer[0], DeviceName);
        strcat(&OutputBuffer[0], FileName);
        strcat(&OutputBuffer[0], "\r\n");

    } else {
        strcpy(&OutputBuffer[0],".");
    }

#if 0
    BlLog((LOG_LOGFILE,OutputBuffer));
#endif

#ifdef UNICODE
    RtlInitAnsiString( &aString, OutputBuffer);
    uString.MaximumLength = sizeof(OutputBufferW);
    uString.Buffer = OutputBufferW;
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
#endif

    ArcWrite(BlConsoleOutDeviceId,
              pOutputBuffer,
              _tcslen(pOutputBuffer),
              &Count);

    return;
}

BOOLEAN
BlGetDriveSignature(
    IN PCHAR Name,
    OUT PULONG Signature
    )

/*++

Routine Description:

    This routine gets the NTFT disk signature for a specified partition or
    path.

Arguments:

    Name - Supplies the arcname of the partition or drive.

    Signature - Returns the NTFT disk signature for the drive.

Return Value:

    TRUE - success, Signature will be filled in.

    FALSE - failed, Signature will not be filled in.

--*/

{
    UCHAR SectorBuffer[512+256];
    CHAR DiskName[256];
    ULONG DiskId;
    PCHAR p;
    ARC_STATUS Status;
    ULONG Count;
    LARGE_INTEGER SeekValue;

    //
    // Generate the arcname ("...partition(0)") for the raw disk device
    // where the boot partition is, so we can read the MBR.
    //
    strcpy(DiskName, Name);
    p=DiskName;
    while (*p != '\0') {
        if (_strnicmp(p, "partition(",10) == 0) {
            break;
        }
        ++p;
    }
    if (*p != '\0') {
        strcpy(p,"partition(0)");
    }

    Status = ArcOpen(DiskName,ArcOpenReadOnly, &DiskId);
    if (Status!=ESUCCESS) {
        return(FALSE);
    }

    //
    // Read the first sector of the physical drive
    //
    SeekValue.QuadPart = 0;
    Status = ArcSeek(DiskId, &SeekValue, SeekAbsolute);
    if (Status==ESUCCESS) {
        Status = ArcRead(DiskId,
                         ALIGN_BUFFER(SectorBuffer),
                         512,
                         &Count);
    }
    ArcClose(DiskId);
    if (Status!=ESUCCESS) {
        return(FALSE);
    }

    //
    // copy NTFT signature.
    //
    *Signature = ((PULONG)SectorBuffer)[PARTITION_TABLE_OFFSET/2-1];
    return(TRUE);
}

#ifndef EFI

VOID
BlBadFileMessage(
    IN PCHAR BadFileName
    )

/*++

Routine Description:

    This function displays the error message for a missing or incorrect
    critical file.

Arguments:

    BadFileName - Supplies the name of the file that is missing or
                  corrupt.

Return Value:

    None.

--*/

{
    ULONG Count;
    PCHAR Text;

    ArcWrite(BlConsoleOutDeviceId,
             "\r\n",
             strlen("\r\n"),
             &Count);

    Text = BlFindMessage(LOAD_SW_MIS_FILE_CLASS);
    if (Text != NULL) {
        ArcWrite(BlConsoleOutDeviceId,
                 Text,
                 strlen(Text),
                 &Count);
    }

    ArcWrite(BlConsoleOutDeviceId,
             BadFileName,
             strlen(BadFileName),
             &Count);

    ArcWrite(BlConsoleOutDeviceId,
             "\r\n\r\n",
             strlen("\r\n\r\n"),
             &Count);

    Text = BlFindMessage(LOAD_SW_FILE_REST_ACT);
    if (Text != NULL) {
        ArcWrite(BlConsoleOutDeviceId,
                 Text,
                 strlen(Text),
                 &Count);
    }

}


VOID
BlFatalError(
    IN ULONG ClassMessage,
    IN ULONG DetailMessage,
    IN ULONG ActionMessage
    )

/*++

Routine Description:

    This function looks up messages to display at a error condition.
    It attempts to locate the string in the resource section of the
    osloader.  If that fails, it prints a numerical error code.

    The only time it should print a numerical error code is if the
    resource section could not be located.  This will only happen
    on ARC machines where boot fails before the osloader.exe file
    can be opened.

Arguments:

    ClassMessage - General message that describes the class of
                   problem.

    DetailMessage - Detailed description of what caused problem

    ActionMessage - Message that describes a course of action
                    for user to take.

Return Value:

    none

--*/


{
    PCHAR Text;
    CHAR Buffer[40];
    ULONG Count;

    ArcWrite(BlConsoleOutDeviceId,
             "\r\n",
             strlen("\r\n"),
             &Count);


    //
    // Remove any remains from the last known good message.
    //

    BlClearToEndOfScreen();
    Text = BlFindMessage(ClassMessage);
    if (Text == NULL) {
        sprintf(Buffer,"%08lx\r\n",ClassMessage);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             strlen(Text),
             &Count);

    Text = BlFindMessage(DetailMessage);
    if (Text == NULL) {
        sprintf(Buffer,"%08lx\r\n",DetailMessage);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             strlen(Text),
             &Count);

    Text = BlFindMessage(ActionMessage);
    if (Text == NULL) {
        sprintf(Buffer,"%08lx\r\n",ActionMessage);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             strlen(Text),
             &Count);
    return;
}

#endif

#if defined(REMOTE_BOOT)
BOOLEAN
BlIsDiskless(
    VOID
    )

/*++

Routine Description:

    This function returns TRUE if a machine is diskless.

Arguments:

    None.

Return Value:

    TRUE if the machine is diskless, FALSE otherwise.

--*/

{
    ULONG FileId;

    if (BlOpenRawDisk(&FileId) == ESUCCESS) {
        BlCloseRawDisk(FileId);
        return FALSE;
    } else {
        return TRUE;
    }
}
#endif // defined(REMOTE_BOOT)


BOOLEAN
BlDetectHal(
    VOID
    )
/*++

Routine Description:

    This function tries to determine the Hal type for this system.

    It fills in the global "HalType" with the type.

Arguments:

    None.

Return Value:

    TRUE if the function successfully detects the hal type.

--*/
{
    BOOLEAN Status = FALSE;
    PSTR MachineName,HalName;
    CHAR FileName[128];
    ARC_STATUS AStatus;
    ULONG DontCare;


    //
    // detecting the hal requires that you open up a copy of winnt.sif
    //
    strcpy(FileName, NetBootPath);
    strcat(FileName, "winnt.sif" );

    AStatus = SlInitIniFile( NULL,
                                    NET_DEVICE_ID,
                                    FileName,
                                    &InfFile,
                                    &WinntSifFile,
                                    &WinntSifFileLength,
                                    &DontCare );

    //
    // if it opens successfully, then search for the HAL.
    //
    if (AStatus == ESUCCESS) {

        //
        // do the search for the HAL.
        //
        MachineName = SlDetectHal();
        if (MachineName) {
            //
            // OK, got the hal type, now look in the SIF file for the actual
            // hal name.
            //
            HalName = SlGetIniValue(
                                InfFile,
                                "Hal",
                                MachineName,
                                NULL);

            if (HalName) {
                strcpy(HalType, HalName );
                
    
                //
                // also get the hal description, which is a "pretty print" version
                // of the hal name
                //
                HalName = SlGetIniValue(
                                    InfFile,
                                    "Computer",
                                    MachineName,
                                    NULL );

                if (HalName) {
                    strcpy(HalDescription, HalName);
                    Status = TRUE;
                }
            }
        }

        SpFreeINFBuffer( InfFile );

    }

    return(Status);
}

//
// note well:  We stub out these setup functions in oschoice.exe, which are
// needed so that the hal detection routines can run properly.  None of these
// routines should actually be called.
//

VOID
SlErrorBox(
    IN ULONG MessageId,
    IN ULONG Line,
    IN PCHAR File
    )
{
    NOTHING;
}

VOID
SlFatalError(
    IN ULONG MessageId,
    ...
    )
{
    //while(1) {
        NOTHING;
    //};

}

VOID
SlFriendlyError(
    IN ULONG uStatus,
    IN PCHAR pchBadFile,
    IN ULONG uLine,
    IN PCHAR pchCodeFile
    )
{
    NOTHING;
}

VOID
SlNoMemError(
    IN ULONG Line,
    IN PCHAR File
    )
{
    SlFatalError(0,Line,File);
}

VOID
SlBadInfLineError(
    IN ULONG Line,
    IN PCHAR INFFile
    )
{
    SlFatalError(0,Line,INFFile);
}


#define SL_KEY_F3       0x03000000

ULONG
SlGetChar(
    VOID
    )
{
    return(SL_KEY_F3);
}

VOID
SlPrint(
    IN PTCHAR FormatString,
    ...
    )
{
    NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\oschoice\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

$(O)\msg.mc : msg.$(LANGUAGE)
    copy $** $@

!IF $(386)


OSLOADER_LIBS=\
    $(O)\oscldr.lib \
    $(O)\oschoice.res \
    $(PROJECT_ROOT)\boot\lib\daytona\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot\$(O)\bldrrtl.lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
    $(DS_LIB_PATH)\rsa32.lib

$(O)\oschoice.res: msg.$(LANGUAGE)

OSLOADER_LIB_COMPONENTS = \
    $(PROJECT_ROOT)\boot\lib\daytona\$(O)\boot.lib \
    $(O)\oscldr.lib

$(O)\link.rsp : makefile.inc
    type << > $@
-base:0x300000
-debug
-entry:NtProcessStartup@4
-fixed
-incremental:no
-map
-opt:ref
-opt:icf
-subsystem:native
$(LINK_LIB_IGNORE_FLAG)
$(OSLOADER_LIBS)
<<NOKEEP

$(O)\oschoice.lib: $(OSLOADER_LIB_COMPONENTS)
    $(LIB_NAME) -machine:i386 -out:$(O)\oschoice.lib  $(OSLOADER_LIB_COMPONENTS) -ignore:4001

#
# We need to make a split oschoice in the obj directory
#
$(O)\oschoice.exe: $(OSLOADER_LIBS) makefile.inc $(O)\link.rsp
        -$(LINK_NAME) -out:$(O)\oschoice.exe @$(O)\link.rsp
        
!ELSE IF $(IA64)

OSLOADER_LIBS=\
    $(O)\oscldr.lib \
    $(O)\oschoice.res \
    $(PROJECT_ROOT)\boot\lib\daytona\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\efi\daytona\$(O)\efi.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot\$(O)\bldrrtl.lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
    $(DS_LIB_PATH)\rsa32.lib

                
$(O)\link.rsp : makefile.inc
    type << > $@
-subsystem:EFI_APPLICATION
-nodefaultlib
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-machine:IA64
-base:0x1040000
-opt:ref
-opt:icf
-entry:main
-map
-ignore:4049,4001,4217
$(LINK_LIB_IGNORE_FLAG)
$(OSLOADER_LIBS)
<<NOKEEP

$(O)\oschoice.res: msg.$(LANGUAGE)

$(O)\oschoice.efi: $(OSLOADER_LIBS) makefile.inc $(O)\link.rsp
    -$(LINK_NAME) -out:$@ @$(O)\link.rsp

$(O)\oschoice.dbg: $(O)\oschoice.efi
    -pe2dbg $? $@


OSLOADER_LIB_COMPONENTS = \
    $(PROJECT_ROOT)\boot\lib\daytona\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\efi\daytona\$(O)\efi.lib \
    $(O)\oscldr.lib

$(O)\oschoice.lib: $(OSLOADER_LIB_COMPONENTS)
    $(LIB_NAME) -machine:ia64 -out:$(O)\oschoice.lib $(OSLOADER_LIB_COMPONENTS) -ignore:4001
    

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\oschoice\oscheap.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    oscheap.c

Abstract:

    This module contains "local" heap management code for OS Chooser.

Author:

    Geoff Pease (gpease) May 28 1998

Revision History:

--*/

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#include "netfs.h"
#include "oscheap.h"

#define FREE_POOL_TAG 0x0
#define ALLOC_POOL_TAG 0x1

typedef struct _LOCAL_MEMORY_DESCRIPTOR {

    //
    // We create a union to make sure that this struct is always at least the size of a 
    // pointer, and thus will be pointer aligned.
    //
    union {

        struct {
            ULONG Tag;
            ULONG Size;
        };

        struct {
            void *Align;
        };

    };

} LOCAL_MEMORY_DESCRIPTOR, *PLOCAL_MEMORY_DESCRIPTOR;


//
// Variable for holding our memory together.
//
#define OSCHEAPSIZE 0x2000 // 8k
CHAR OscHeap[ OSCHEAPSIZE ];

//
// Functions
//
void
OscHeapInitialize(
    VOID
    )
/*++

Routine Description:

    This routine initializes the internal memory management system.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)OscHeap;

    LocalDescriptor->Tag = FREE_POOL_TAG;
    LocalDescriptor->Size = OSCHEAPSIZE - sizeof(LOCAL_MEMORY_DESCRIPTOR);

    memset((PVOID)(LocalDescriptor + 1), 0, LocalDescriptor->Size);
}

PCHAR
OscHeapAlloc( 
    IN UINT iSize 
    )

/*++

Routine Description:

    This routine allocates memory from our internal structures.

Arguments:

    iSize - Number of bytes the client wants.
    
Return Value:

    A pointer to the allocated block if successful, else NULL

--*/

{
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR NextDescriptor;
    LONG ThisBlockSize;
    ULONG BytesToAllocate;

    //
    // Always allocate in increments of a pointer, minmally.
    //
    if (iSize & (sizeof(void *) - 1)) {
        iSize += sizeof(void *) - (iSize & (sizeof(void *) - 1));
    }

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)OscHeap;
    ThisBlockSize = OSCHEAPSIZE - sizeof(LOCAL_MEMORY_DESCRIPTOR);

    while (ThisBlockSize > 0) {

        if ((LocalDescriptor->Tag == FREE_POOL_TAG) && 
            (LocalDescriptor->Size >= iSize)) {
                
            goto FoundBlock;
        }

        ThisBlockSize -= (LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR));
        LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                     LocalDescriptor->Size +
                                                     sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                     );
    }

    //
    // There is no memory block big enough to hold the request.
    //
    return NULL;
    
FoundBlock:

    //
    // Jump to here when a memory descriptor of the right size has been found.  It is expected that
    // LocalDescriptor points to the correct block.
    //
    if (LocalDescriptor->Size > iSize + sizeof(LOCAL_MEMORY_DESCRIPTOR)) {

        //
        // Make a descriptor of the left over parts of this block.
        //
        NextDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                    sizeof(LOCAL_MEMORY_DESCRIPTOR) +
                                                    iSize
                                                   );

        NextDescriptor->Tag = FREE_POOL_TAG;
        NextDescriptor->Size = (ULONG)(LocalDescriptor->Size - iSize - sizeof(LOCAL_MEMORY_DESCRIPTOR));
        LocalDescriptor->Size = (ULONG)iSize;

    }

    LocalDescriptor->Tag = ALLOC_POOL_TAG;

    memset((LocalDescriptor+1), 0, iSize);

    return (PCHAR)(LocalDescriptor + 1);

}

PCHAR
OscHeapFree(
    IN PCHAR Pointer
    )

/*++


Routine Description:

    This routine frees a block previously allocated from the internal memory management system.

Arguments:

    Pointer - A pointer to free.

Return Value:

    NULL.

--*/

{
    LONG ThisBlockSize;
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR PrevDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR ThisDescriptor;

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)Pointer) - sizeof(LOCAL_MEMORY_DESCRIPTOR));

    //
    // Find the memory block in the heap
    //
    PrevDescriptor = NULL;
    ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)OscHeap;
    ThisBlockSize = OSCHEAPSIZE - sizeof(LOCAL_MEMORY_DESCRIPTOR);

    while (ThisBlockSize > 0) {
            
        if (ThisDescriptor == LocalDescriptor) {
            goto FoundBlock;
        }

        ThisBlockSize -= (ThisDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR));
            
        PrevDescriptor = ThisDescriptor;
        ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)ThisDescriptor) + 
                                                    ThisDescriptor->Size +
                                                    sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                   );
    }

    return NULL;

FoundBlock:

    //
    // Jump to here when the proper memory descriptor has been found.
    //
    
    if (LocalDescriptor->Tag == FREE_POOL_TAG) {
        //
        // Ouch! We tried to free something twice, skip it before bad things happen.
        //
        return NULL;
    }

    LocalDescriptor->Tag = FREE_POOL_TAG;

    //
    // If possible, merge this memory block with the next one.
    //
    if ((ULONG)ThisBlockSize > (LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR))) {
        ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                    LocalDescriptor->Size +
                                                    sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                   );
        if (ThisDescriptor->Tag == FREE_POOL_TAG) {
            LocalDescriptor->Size += ThisDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR);
            ThisDescriptor->Tag = 0;
            ThisDescriptor->Size = 0;
        }

    }

    //
    // Now see if we can merge this block with a previous block.
    //
    if ((PrevDescriptor != NULL) && (PrevDescriptor->Tag == FREE_POOL_TAG)) {
        PrevDescriptor->Size += LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR);
        LocalDescriptor->Tag = 0;
        LocalDescriptor->Size = 0;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\oschoice\parse.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    parse.c

Abstract:

    This module contains UI code for the OS chooser

Author:

    Adam Barr (adamba) 15-May-1997

Revision History:

    Geoff Pease (GPease) 28 May 1998 - Major Overhaul to "OSCML" parser

--*/

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif


#include "ctype.h"
#include "stdio.h"
#include "string.h"
#include <netfs.h>
#include "oscheap.h"
#include "parse.h"
#include "hdlsterm.h"


#if 0 && DBG==1
#define _TRACE_FUNC_
#endif

#ifdef _TRACE_FUNC_
#define TraceFunc( _func)  { \
    CHAR FileLine[80]; \
    sprintf( FileLine, "%s(%u)", __FILE__, __LINE__ ); \
    DPRINT( OSC, ("%-55s: %s", FileLine, _func) ); \
}
#else
#define TraceFunc( _func )
#endif

#define SCREEN_TOP 2
#ifdef EFI
#define SCREEN_BOTTOM 24
#else
#define SCREEN_BOTTOM 25
#endif

// Special translated character codes
#define CHAR_NBSP       ((CHAR)255)

#define MAX_INPUT_BUFFER_LENGTH 1024

#define PRINT(s,l)  { ULONG privCount; ArcWrite(BlConsoleOutDeviceId, (s), (l), &privCount); }
#define PRINTL(s)  { ULONG privCount; ArcWrite(BlConsoleOutDeviceId, (s), _tcslen(s), &privCount); }

#define BLINK_RATE 5
#define BRACKETS   4    // left and right brackets w/one space each

#define CT_TEXT     0x1
#define CT_PASSWORD 0x2
#define CT_RESET    0x4
#define CT_SELECT   0x8
#define CT_OPTION   0x10
#define CT_LOCAL    0x20
#define CT_VARIABLE 0x40

enum ENCODETYPE {
    ET_NONE = 0,
    ET_OWF
};

typedef struct {
    enum ACTIONS Action;
    PCHAR ScreenName;
} KEY_RESPONSE, *LPKEY_RESPONSE;


typedef struct {
    void * Next;
    enum CONTROLTYPE Type;
} CONTROLSTRUCT, *LPCONTROLSTRUCT;

typedef struct {
    void * Next;
    int  Type;
    enum ENCODETYPE Encoding;
    int   Size;
    int   MaxLength;
    int   X;
    int   Y;
    int   CurrentPosition;
    int   FirstVisibleChar;
    PCHAR Name;
    PCHAR Value;
} INPUTSTRUCT, *LPINPUTSTRUCT;

enum OPTIONFLAGS {
    OF_MULTIPLE = 0x01,
    OF_SELECTED = 0x02,
};

typedef struct {
    void * Next;
    enum CONTROLTYPE Type;
    enum OPTIONFLAGS Flags;
    PCHAR Value;
    PCHAR Displayed;
    PCHAR Tip;
    PCHAR EndTip;
} OPTIONSTRUCT, * LPOPTIONSTRUCT;

typedef struct {
    void * Next;
    enum CONTROLTYPE Type;
    enum OPTIONFLAGS Flags;
    int  Size;
    int  X;
    int  Y;
    int  Width;
    int  Timeout;
    BOOLEAN AutoSelect;
    PCHAR Name;
    LPOPTIONSTRUCT FirstVisibleSelection;
    LPOPTIONSTRUCT CurrentSelection;
} SELECTSTRUCT, * LPSELECTSTRUCT;

typedef struct {
    int X;
    int Y;
    int LeftMargin;
    int RightMargin;
    int Size;
} TIPAREA, *LPTIPAREA;

extern const CHAR rghex[];  // "0123456789ABCDEF"

//
// Current Screen Paramaters
//
PCHAR ScreenAttributes;
static CHAR WhiteOnBlueAttributes[] = ";44;37m"; // normal text, white on blue
static CHAR BlackOnBlackAttributes[] = ";40;40m"; // normal text, black on black
int   ScreenX;
int   ScreenY;
int   ScreenBottom;
int   LeftMargin;
int   RightMargin;
LPKEY_RESPONSE EnterKey;
LPKEY_RESPONSE EscKey;
LPKEY_RESPONSE F1Key;
LPKEY_RESPONSE F3Key;
BOOLEAN PreformattedMode;
BOOLEAN LoginScreen;
BOOLEAN AutoEnter;
BOOLEAN InsertMode;
void * ScreenControls;
enum ACTIONS SpecialAction;
LPTIPAREA TipArea;

#if defined(PLEASE_WAIT)
PCHAR PleaseWaitMsg;
#endif

// 80 spaces, for padding out menu bar highlights.
static TCHAR SpaceString[] =
TEXT("                                                                                ");

VOID
RomDumpRawData (
    IN PUCHAR DataStart,
    IN ULONG DataLength,
    IN ULONG Offset
    );

//
// From regboot.c -- Column and Row are 1-based
//

VOID
BlpPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    );

VOID
BlpClearScreen(
    VOID
    );
//
// End from regboot.c
//



//
// Gets an integer, using PrevLoc and CurLoc as in BlProcessScreen.
//
UINT
GetInteger(
    PCHAR * InputString
    )
{
    UINT uint;
    PCHAR psz;

    TraceFunc( "BlpGetInteger()\n" );

    uint = 0;
    psz = *InputString;

    while ((*psz >= '0') && (*psz <= '9')) {
        uint = (uint*10) + *psz - '0';
        ++psz;
    }
    *InputString = psz;

    //DPRINT( OSC, ("Integer: '%u'\n", tmpInteger) );
    return uint;
}



#ifdef EFI
BlpShowCursor(
    IN BOOLEAN ShowCursor,
    IN TCHAR UnderCharacter
    )
{
    //bugbug handle "under character"
    BlEfiEnableCursor(ShowCursor);

}

VOID
BlpSendEscape(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen.

Arguments:

    None

Return Value:

    None.

--*/

{   
    BlEfiSetAttribute(DEFATT);
    BlEfiSetInverseMode(FALSE);
}


VOID
BlpSendEscapeReverse(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen that reverses the foreground and
    background colors of the Escape sequence. All special codes are
    retained (codes not in the ranges of 30-37 and 40-47).

Arguments:

    Escape - the escape sequence string.

Return Value:

    None.

--*/

{
    BlEfiSetAttribute(INVATT);
}

VOID
BlpSendEscapeBold(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen with the additional inverse code.

Arguments:

    None

Return Value:

    None.

--*/

{
    NOTHING;
}

VOID
BlpSendEscapeFlash(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen with the additional flash code.

Arguments:

    None

Return Value:

    None.

--*/

{
    NOTHING; //there is no flash attribute available under EFI.
}


#else

VOID
BlpSendEscape(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen.

Arguments:

    None

Return Value:

    None.

--*/

{
    TCHAR Buffer[16];
    ULONG Count;

#ifdef _TRACE_FUNC_
    TraceFunc("BlpSendEscape( ");
    DPRINT( OSC, ("Escape='%s' )\n", Escape) );
#endif

#ifdef UNICODE
    _stprintf(Buffer, TEXT("%s%S"), ASCI_CSI_OUT, Escape);
#else
    _stprintf(Buffer, TEXT("%s%s"), ASCI_CSI_OUT, Escape);
#endif

    PRINTL(Buffer);
}


VOID
BlpSendEscapeReverse(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen that reverses the foreground and
    background colors of the Escape sequence. All special codes are
    retained (codes not in the ranges of 30-37 and 40-47).

Arguments:

    Escape - the escape sequence string.

Return Value:

    None.

--*/

{
    TCHAR Buffer[20];
    PCHAR CurLoc = Escape;
    int   Color;

#ifdef _TRACE_FUNC_
    TraceFunc( "BlpSendEscapeReverse( " );
    DPRINT( OSC, ("Escape='%s' )\n", Escape) );
#endif

    if ( Escape == NULL ) {
        return; // abort
    }

    _tcscpy( Buffer, ASCI_CSI_OUT );

    //
    // Pre-pend the inverse video string for a vt100 terminal
    //
    if (BlIsTerminalConnected()) {
        _stprintf(Buffer, TEXT("%s7"), Buffer);
    }

    while ( *CurLoc && *CurLoc != 'm' ) {
        if ( !( *CurLoc >= '0' && *CurLoc <= '9' ) ) {
            CurLoc++;
        }

        Color = GetInteger( &CurLoc );

        if ( Color >=30 && Color <= 37) {
            Color += 10;
        } else if ( Color >= 40 && Color <= 47 ) {
            Color -= 10;
        }

        _stprintf( Buffer, TEXT("%s;%u"), Buffer, Color );
    }

    //
    // Add trailing 'm'
    //
    _stprintf( Buffer, TEXT("%sm"), Buffer );

    PRINTL( Buffer );
}

VOID
BlpSendEscapeBold(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen with the additional inverse code.

Arguments:

    None

Return Value:

    None.

--*/

{
    TCHAR Buffer[20];

#ifdef _TRACE_FUNC_
    TraceFunc( "BlpSendEscapeBold( " );
    DPRINT( OSC, ("Escape='%s' )\n", Escape) );
#endif

    _stprintf(Buffer, TEXT("%s;1%s"), ASCI_CSI_OUT, Escape);
    PRINTL(Buffer);
}

VOID
BlpSendEscapeFlash(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen with the additional flash code.

Arguments:

    None

Return Value:

    None.

--*/

{
    TCHAR Buffer[20];

#ifdef _TRACE_FUNC_
    TraceFunc( "BlpSendEscapeFlash( " );
    DPRINT( OSC, ("Escape='%s' )\n", Escape) );
#endif

    _stprintf(Buffer, TEXT("%s;5%s"), ASCI_CSI_OUT, Escape);
    PRINTL(Buffer);
}

//
// BlpShowCursor( )
//
VOID
BlpShowCursor(
    IN BOOLEAN ShowCursor,
    IN TCHAR UnderCharacter )
{
    TCHAR Buffer[20];
    
    if (ShowCursor) {   
        if(InsertMode){
            _stprintf(Buffer,TEXT("5%s"),ScreenAttributes);
            BlpSendEscapeReverse(Buffer);
        }
        else{
            _stprintf(Buffer,TEXT("5%s"),ScreenAttributes);
            BlpSendEscape(Buffer);
        }
    } else {
        _stprintf(Buffer,TEXT("0%s"),ScreenAttributes);
        BlpSendEscape(Buffer);
    }

    if (UnderCharacter) {
        PRINT( &UnderCharacter, sizeof(TCHAR));
    } else {
        if((InsertMode == FALSE )&& ShowCursor){
            PRINT(TEXT("_"),sizeof(TCHAR));
            return;
        }
        if(ShowCursor){
            PRINT(TEXT(""),sizeof(TCHAR));
            return;
        }
        PRINT(TEXT(" "),sizeof(TCHAR));
    }
}
#endif

//
// BlpGetKey()
//
// Calls BlGetKey(), but checks if this screen has "auto-enter"
// turned on in which case it will return an enter key once.
//
ULONG
BlpGetKey(
    VOID
)
{
    if (AutoEnter) {
        return ENTER_KEY;
        AutoEnter = FALSE;  // only return it once per screen
    } else {
        return BlGetKey();
    }
}

//
// BlpGetKeyWithBlink( )
//
// Displays a blinking cursor as the X,Y coordinates given and awaits
// a key press.
//
ULONG
BlpGetKeyWithBlink(
    IN ULONG XLocation,
    IN ULONG YLocation,
    IN TCHAR  UnderCharacter
    )
{
    ULONG Key = 0;

    TraceFunc("BlpGetKeyWithBlink()\n");

    BlpPositionCursor(XLocation, YLocation);
    BlpShowCursor( TRUE, UnderCharacter );

    do {

        Key = BlpGetKey();

    } while (Key == 0);

    BlpPositionCursor(XLocation, YLocation);
    BlpShowCursor( FALSE, UnderCharacter );

    return Key;
}

//
// BlpPrintString( )
//
// Prints out a large string to the display. It also wraps the text as
// needed.
//
void
BlpPrintString(
    IN PCHAR Start,
    IN PCHAR End
    )
{
    PTCHAR Scan;
    PTCHAR PrintBuf;
    PTCHAR pStart;
    PTCHAR pEnd;
    ULONG  i;
    TCHAR  TmpChar;
    int    Length = 0;


    DPRINT( OSC, ("BlpPrintString: Start = 0x%08x, End = 0x%08x, Length = %d\n", Start, End, (ULONG)(End - Start)) );
    DPRINT( OSC, ("[BlockPrint, Length=%u] '%s'\n", (ULONG)(End - Start), Start) );

    while ( Start < End && *Start == 32 )
        Start++;

    if ( Start == End )
        return; // NOP

    // Copy the buffer so if something goes wrong, the orginal
    // screen will still be intact.

    Length = (int)(End - Start);
    PrintBuf = (PTCHAR)OscHeapAlloc( Length*sizeof(TCHAR) );
    
    if (!PrintBuf) {
        return;
    }
        
    for (i = 0; i < (ULONG)Length; i++) {
        PrintBuf[i] = (TCHAR)Start[i];
        if (PrintBuf[i] & 0x80) {
            DPRINT( OSC, ("BlpPrintString: covering non-printable character %04lx\r\n", (USHORT)PrintBuf[i]) );
            PrintBuf[i] = (TCHAR)32;
        }
    }
   
    pStart = PrintBuf;
    pEnd = pStart + Length;

    BlpPositionCursor( ScreenX, ScreenY );

    // See if it is short enough to do the quick route
    if ( Length + ScreenX <= RightMargin ) {
#if DBG
        {
            TmpChar = *pEnd;
            *pEnd = 0;
            DPRINT( OSC, ("[BlockPrint, Short] '%s'\n", pStart) );
            *pEnd = TmpChar;
        }
#endif
        PRINT( pStart, Length*sizeof(TCHAR) );
        ScreenX += Length;
    } else {
        
        while( (pStart < pEnd) && (ScreenY <= ScreenBottom) )
        {
            DPRINT( 
                OSC, 
                ("BlpPrintString: About to print a line.\r\n") );
            DPRINT( 
                OSC, 
                ("                pStart: 0x%08lx    pEnd: 0x%08lx    PrintBuf: 0x%08lx\r\n", 
                 PtrToUint(pStart), 
                 PtrToUint(pEnd), 
                 PtrToUint(PrintBuf)) );
            
            //
            // Jump over NULL strings.
            //
            if( *pStart == TEXT('\0') ) {
                pStart++;
                break;
            }
            
            Length = (ULONG)(pEnd - pStart);
            DPRINT( OSC, ("BlpPrint: I think the length of this string is %d\n", Length) );

            // do nice wrapping
            if ( Length > RightMargin - ScreenX ) {

                Length = RightMargin - ScreenX;
                DPRINT( OSC, ("BlpPrint: I'm going to truncate the length because it's too big.  Now it's %d\n", Length) );
                
                // try to find a "break" character
                while ( Length && pStart[Length] != (TCHAR)32 ) {
                    Length--;
                }

                DPRINT( OSC, ("BlpPrint: After jumping over the whitespace, it's %d\n", Length) );


                // If we can't "break" it, just dump one line's worth
                if ( !Length ) {
                    DPRINT( OSC, ("[BlockPrint Length == 0, Dumping a lines worth]\n") );
                    Length = RightMargin - ScreenX;
                }
            }

#if DBG
        {
            TmpChar = pStart[Length];
            pStart[Length] = 0;
#ifdef UNICODE
            DPRINT( OSC, ("[BlockPrint, Length=%u] '%ws'\n", Length, pStart) );
#else
            DPRINT( OSC, ("[BlockPrint, Length=%u] '%s'\n", Length, pStart) );
#endif
            pStart[Length] = TmpChar;
        }
#endif
            BlpPositionCursor( ScreenX, ScreenY );
            PRINT( pStart, Length*sizeof(TCHAR) );

            pStart += Length;

            while ( pStart <= pEnd && *pStart == 32 )
                pStart++;

            ScreenX = LeftMargin;
            ScreenY++;
        }
        ScreenY--;

        ScreenX += Length;

        if ( ScreenY > ScreenBottom ) {
            ScreenY = ScreenBottom;
        }
    }

    // If the copy buffer was allocated, free it.
    if ( PrintBuf != NULL ) {
        OscHeapFree( (PVOID)PrintBuf );
    }
}

// **************************************************************************
//
// Lex section
//
// **************************************************************************

//
// Token list for screen parser
//
enum TOKENS {
    TOKEN_ENDTAG = 0,
    TOKEN_QUOTE,
    TOKEN_HTML,
    TOKEN_ENDHTML,
    TOKEN_META,
    TOKEN_SERVER,
    TOKEN_KEY,
    TOKEN_ENTER,
    TOKEN_ESC,
    TOKEN_F1,
    TOKEN_F3,
    TOKEN_HREF,
    TOKEN_TITLE,
    TOKEN_ENDTITLE,
    TOKEN_FOOTER,
    TOKEN_ENDFOOTER,
    TOKEN_BODY,
    TOKEN_ENDBODY,
    TOKEN_PRE,
    TOKEN_ENDPRE,
    TOKEN_FORM,
    TOKEN_ENDFORM,
    TOKEN_ACTION,
    TOKEN_INPUT,
    TOKEN_NAME,
    TOKEN_INPUTTYPE,
    TOKEN_VALUE,
    TOKEN_SIZE,
    TOKEN_TIP,
    TOKEN_MAXLENGTH,
    TOKEN_ENCODE,
    TOKEN_SELECT,
    TOKEN_MULTIPLE,
    TOKEN_NOAUTO,
    TOKEN_ENDSELECT,
    TOKEN_OPTION,
    TOKEN_SELECTED,
    TOKEN_HELP,
    TOKEN_BREAK,
    TOKEN_BOLD,
    TOKEN_ENDBOLD,
    TOKEN_FLASH,
    TOKEN_ENDFLASH,
    TOKEN_LEFT,
    TOKEN_RIGHT,
    TOKEN_TIPAREA,
    TOKEN_PARAGRAPH,
    TOKEN_ENDPARA,    
#if defined(PLEASE_WAIT)
    TOKEN_WAITMSG,
#endif
    TOKEN_INVALID,  // end of parsable tokens
    TOKEN_TEXT,
    TOKEN_START,
    TOKEN_EOF,      // End of file
};

static struct {
    PCHAR name;
    int   length;
} Tags[] = {
    { ">",            1 },
    { "\"",           1 },
    { "<OSCML",       0 },
    { "</OSCML>",     0 },
    { "<META",        0 },
    { "SERVER",       0 },
    { "KEY=",         0 },
    { "ENTER",        0 },
    { "ESC",          0 },
    { "F1",           0 },
    { "F3",           0 },
    { "HREF=",        0 },
    { "<TITLE",       0 },
    { "</TITLE>",     0 },
    { "<FOOTER",      0 },
    { "</FOOTER>",    0 },
    { "<BODY",        0 },
    { "</BODY>",      0 },
    { "<PRE",         0 },
    { "</PRE>",       0 },
    { "<FORM",        0 },
    { "</FORM>",      0 },
    { "ACTION=",      0 },
    { "<INPUT",       0 },
    { "NAME=",        0 },
    { "TYPE=",        0 },
    { "VALUE=",       0 },
    { "SIZE=",        0 },
    { "TIP=",         0 },
    { "MAXLENGTH=",   0 },
    { "ENCODE=",      0 },
    { "<SELECT",      0 },
    { "MULTIPLE",     0 },
    { "NOAUTO",       0 },
    { "</SELECT>",    0 },
    { "<OPTION",      0 },
    { "SELECTED",     0 },
    { "HELP=",        0 },
    { "<BR",          0 },
    { "<BOLD",        0 },
    { "</BOLD",       0 },
    { "<FLASH",       0 },
    { "</FLASH",      0 },
    { "LEFT=",        0 },
    { "RIGHT=",       0 },
    { "<TIPAREA",     0 },
    { "<P",           0 },
    { "</P",          0 },
#if defined(PLEASE_WAIT)
    { "WAITMSG=",     0 },
#endif
    { NULL,           0 },  // end of parsable tokens
    { "[TEXT]",       0 },
    { "[START]",      0 },
    { "[EOF]",        0 }
};

//
// Lexstrcmpni( )
//
// Impliments strcmpni( ) for the Lexer.
//
int
Lexstrcmpni(
    IN PCHAR pstr1,
    IN PCHAR pstr2,
    IN int iLength
    )
{
    while ( iLength && *pstr1 && *pstr2 )
    {
        CHAR ch1 = *pstr1;
        CHAR ch2 = *pstr2;

        if ( islower( ch1 ) )
        {
            ch1 = (CHAR)toupper(ch1);
        }

        if ( islower( ch2 ) )
        {
            ch2 = (CHAR)toupper(ch2);
        }

        if ( ch1 < ch2 )
            return -1;

        if ( ch1 > ch2 )
            return 1;

        pstr1++;
        pstr2++;
        iLength--;
    }

    return 0;
}

//
//  ReplaceSpecialCharacters( &psz );
//
void
ReplaceSpecialCharacters(
    IN PCHAR psz)
{
    TraceFunc( "ReplaceSpecialCharacters( )\n" );

    if ( Lexstrcmpni( psz, "&NBSP", 5 ) == 0 ) {
        *psz = CHAR_NBSP;                               // replace
        memmove( psz + 1, psz + 5, strlen(psz) - 4 );   // shift
    }
}


#if DBG
// #define LEX_SPEW
#endif

//
// Lex( )
//
// Parses the screen data moving the "InputString" pointer forward and
// returns the token for the text parsed. Spaces are ignored. Illegal
// characters are removed from the screen data. CRs are turned into
// spaces.
//
enum TOKENS
Lex(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_TEXT;
    PCHAR psz = *InputString;
    int   iCounter;

#if defined(LEX_SPEW) && defined(_TRACE_FUNC_)
    TraceFunc( "Lex( " );
    DPRINT( OSC, ("InputString = 0x%08x )\n", *InputString) );
#endif _TRACE_FUNC_

    // skip spaces and control characters
    if ( PreformattedMode == FALSE )
    {
        while ( *psz && *psz <= L' ' )
        {
            if (( *psz != 32 && *psz != '\n' )
               || ( psz != *InputString && (*(psz-1)) == 32 )) {
                // remove any CR or LFs and any bogus characters
                // also remove duplicate spaces in cases like:
                //
                // This is some text \n\r
                // and more text.
                //
                // If we left it alone it would be printed:
                //
                // This is some text  and more text.
                //
                memmove( psz, psz + 1, strlen(psz) );
            } else {
                *psz = 32;
                psz++;
            }
        }
    }

    if ( *psz == '&' ) {
        ReplaceSpecialCharacters( psz );
    }

    if ( *psz ) {
        for ( iCounter = 0; Tags[iCounter].name; iCounter++ )
        {
            if ( !Tags[iCounter].length ) {
                Tags[iCounter].length = strlen( Tags[iCounter].name );
            }

            if ( Lexstrcmpni( psz, Tags[iCounter].name, Tags[iCounter].length ) == 0 ) {
                psz += Tags[iCounter].length;
                Tag = iCounter;
                break;
            }
        }

        if ( Tag == TOKEN_TEXT )
            psz++;
    } else {
        Tag = TOKEN_EOF;
    }

#ifdef LEX_SPEW
    {
        CHAR tmp = *psz;
        *psz = '\0';
        DPRINT( OSC, ("[Lex] Parsed String: '%s' Result: %u - '%s'\n", *InputString, Tag, Tags[Tag].name) );
        *psz = tmp;
    }
#endif

    *InputString = psz;

    return Tag;
}

//
// GetString( )
//
// Finds and copies a string value from the screen data.
//
PCHAR
GetString(
    IN PCHAR * InputString
    )
{
    CHAR  StopChar = 32;
    PCHAR ReturnString = NULL;
    PCHAR pszBegin = *InputString;
    PCHAR pszEnd;
    UINT Length;
    CHAR tmp;

    TraceFunc( "GetString( )\n" );

    if ( !pszBegin )
        goto e0;

    // skip spaces
    while ( *pszBegin == 32 )
        pszBegin++;

    // Check for quoted string
    if ( *pszBegin == '\"' ) {
        // find the end quote
        pszBegin++;
        pszEnd = strchr( pszBegin, '\"' );

    } else {
        // look for a break (space) or end token (">")
        PCHAR pszSpace = strchr( pszBegin, ' ' );
        PCHAR pszEndToken = strchr( pszBegin, '>' );

        if ( !pszSpace ) {
            pszEnd = pszEndToken;
        } else if ( !pszEndToken ) {
            pszEnd = pszSpace;
        } else if ( pszEndToken < pszSpace ) {
            pszEnd = pszEndToken;
        } else {
            pszEnd = pszSpace;
        }
    }

    if ( !pszEnd )
        goto e0;

    tmp = *pszEnd;     // save
    *pszEnd = '\0';    // terminate

    Length = strlen( pszBegin ) + 1;
    ReturnString = OscHeapAlloc( Length );
    if ( ReturnString ) {
        strcpy( ReturnString, pszBegin );
    }
    *pszEnd = tmp;     // restore

    DPRINT( OSC, ("[String] %s<-\n", ReturnString) );

    *InputString = pszEnd;
e0:
    return ReturnString;
}

// **************************************************************************
//
// Parsing States Section
//
// **************************************************************************

//
// TitleTagState( )
//
enum TOKENS
TitleTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR  PageTitle = *InputString;

    TraceFunc( "TitleTagState( )\n" );

    // ignore tag arguments
    for( ; Tag != TOKEN_EOF && Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );

    PreformattedMode = TRUE;

    while ( Tag != TOKEN_EOF )
    {
        switch (Tag)
        {
        case TOKEN_EOF:
            // something went wrong, assume all this is text
            *InputString = PageTitle;
            PreformattedMode = FALSE;
            return TOKEN_TEXT;

        case TOKEN_ENDTAG:
            PageTitle = *InputString;
            break; // ignore

        case TOKEN_ENDTITLE:
            {
                PCHAR psz = *InputString;
                CHAR tmp;

                psz -= Tags[Tag].length;

                tmp = *psz;
                *psz = L'\0';

                BlpSendEscapeReverse(ScreenAttributes);
                BlpPositionCursor( 1, 1 );

#ifdef _IN_OSDISP_
                PRINT( SpaceString, sizeof(SpaceString) - sizeof(TCHAR) );
#else
                PRINT( SpaceString, sizeof(SpaceString) );
#endif

                if ( PageTitle ) {
                    BlpPositionCursor( 1, 1 );
                    DPRINT( OSC, ("[Title] '%s'\n", PageTitle) );
#ifdef UNICODE
                    { 
                        ULONG i;
                        WCHAR wc;
                        for (i = 0; i < strlen(PageTitle) ; i++) {
                            wc = (WCHAR)PageTitle[i];
                            PRINT( &wc, sizeof(WCHAR));
                        }
                    }                    
#else
                    PRINTL( PageTitle );
#endif
                }

                BlpSendEscape(ScreenAttributes);
                *psz = tmp;
                PreformattedMode = FALSE;
                return Tag; //exit state
            }
            break;
        }
        Tag = Lex( InputString );
    }

    PreformattedMode = FALSE;
    return Tag;
}

//
// FooterTagState( )
//
enum TOKENS
FooterTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR  PageFooter = *InputString;

    TraceFunc( "FooterTagState( )\n" );

    // ignore tag arguments
    for( ; Tag != TOKEN_EOF && Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );

    PreformattedMode = TRUE;

    while ( Tag != TOKEN_EOF )
    {
        switch (Tag)
        {
        case TOKEN_EOF:
            // something went wrong, assume all this is text
            *InputString = PageFooter;
            PreformattedMode = FALSE;
            return TOKEN_TEXT;

        case TOKEN_ENDTAG:
            PageFooter = *InputString;
            break; // ignore

        case TOKEN_ENDFOOTER:
            {
                PCHAR psz = *InputString;
                CHAR tmp;

                psz -= Tags[Tag].length;

                tmp = *psz;
                *psz = L'\0';

                BlpSendEscapeReverse(ScreenAttributes);
                BlpPositionCursor( 1, ScreenBottom );

#ifdef _IN_OSDISP_
                PRINT( SpaceString, sizeof(SpaceString) - sizeof(TCHAR) );
#else
                //
                // if we're writing to a terminal, we don't want to write into the lower
                // right corner as this would make us scroll.
                //
                PRINT( SpaceString, BlTerminalConnected 
                                      ? (sizeof(SpaceString) - sizeof(TCHAR))
                                      : sizeof(SpaceString) );
#endif

                if ( PageFooter ) {
                    ULONG iLen;
                    BlpPositionCursor( 1, ScreenBottom );
                    DPRINT( OSC, ("[Footer] '%s'\n", PageFooter) );
                    
                    iLen = strlen(PageFooter);
                    if (iLen > 79) {
                        iLen = 79;
                    }
#ifdef UNICODE
                    { 
                        ULONG i;
                        WCHAR wc;
                        for (i = 0; i < iLen ; i++) {
                            wc = (WCHAR)PageFooter[i];
                            PRINT( &wc, sizeof(WCHAR));
                        }
                    }
#else
                    PRINT( PageFooter, iLen );
#endif                    
                }

                BlpSendEscape(ScreenAttributes);
                *psz = tmp;
                PreformattedMode = FALSE;
                return Tag; //exit state
            }
            break;
        }
        Tag = Lex( InputString );
    }

    PreformattedMode = FALSE;
    return Tag;
}

//
// InputTagState( )
//
enum TOKENS
InputTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_INVALID;
    LPINPUTSTRUCT Input;

    TraceFunc( "InputTagState( )\n" );

    Input = (LPINPUTSTRUCT) OscHeapAlloc( sizeof(INPUTSTRUCT) );
    if ( !Input )
    {
        // get tag arguments
        for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );
        return TOKEN_INVALID;
    }

    RtlZeroMemory( Input, sizeof(INPUTSTRUCT) );
    Input->Type |= CT_TEXT;
    Input->Encoding = ET_NONE;
    Input->X = ScreenX;
    Input->Y = ScreenY;

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_NAME:
            Input->Name = GetString( InputString );
            if ( Input->Name )
                DPRINT( OSC, ("[Input Name] %s\n", Input->Name) );
            break;

        case TOKEN_VALUE:
            Input->Value = GetString( InputString );
            if ( Input->Value )
                DPRINT( OSC, ("[Input Value] %s\n", Input->Value) );
            break;

        case TOKEN_INPUTTYPE:
            {
                PCHAR pType = GetString( InputString );
                if ( !pType )
                    break;
                if ( Lexstrcmpni( pType, "PASSWORD", 8 ) == 0 ) {
                    Input->Type = CT_PASSWORD;
                    DPRINT( OSC, ("[Input Type] PASSWORD\n") );
                } else if ( Lexstrcmpni( pType, "RESET", 5 ) == 0 ) {
                    Input->Type = CT_RESET;
                    DPRINT( OSC, ("[Input Type] RESET\n") );
                } else if ( Lexstrcmpni( pType, "TEXT", 4 ) == 0 ) {
                    Input->Type = CT_TEXT;
                    DPRINT( OSC, ("[Input Type] TEXT\n") );
                } else if ( Lexstrcmpni( pType, "LOCAL", 5 ) == 0 ) {
                    DPRINT( OSC, ("[Input Type] LOCAL\n") );
                    Input->Type = CT_LOCAL;
                    if ( Lexstrcmpni( pType + 5, "PASSWORD", 8 ) == 0 ) {
                        Input->Type |= CT_PASSWORD;
                        DPRINT( OSC, ("[Input Type] PASSWORD\n") );
                    } else if ( Lexstrcmpni( pType + 5, "RESET", 5 ) == 0 ) {
                        Input->Type |= CT_RESET;
                        DPRINT( OSC, ("[Input Type] RESET\n") );
                    } else if ( Lexstrcmpni( pType + 5, "TEXT", 4 ) == 0 ) {
                        Input->Type |= CT_TEXT;
                        DPRINT( OSC, ("[Input Type] TEXT\n") );
                    }
                } else if ( Lexstrcmpni( pType, "VARIABLE", 8 ) == 0) {
                    Input->Type = CT_VARIABLE;
                    DPRINT( OSC, ("[Input Type] VARIABLE\n") );
                }
                                                         
                OscHeapFree( pType );
            }
            break;

        case TOKEN_SIZE:
            {
                PCHAR psz = GetString( InputString );
                if ( psz ) {
                    PCHAR pszOld = psz;  // save because GetInteger modifies
                    Input->Size = GetInteger( &psz );
                    OscHeapFree( pszOld );
                    DPRINT( OSC, ("[Input Size] %u\n", Input->Size) );
                }
            }
            break;

        case TOKEN_MAXLENGTH:
            {
                PCHAR psz = GetString( InputString );
                
                if ( psz ) {
                    PUCHAR pTmpSz = psz;

                    Input->MaxLength = GetInteger( &pTmpSz );

                    if ( Input->MaxLength > MAX_INPUT_BUFFER_LENGTH - 1 ) {
                        Input->MaxLength = MAX_INPUT_BUFFER_LENGTH - 1;
                    }
                    OscHeapFree( psz );
                    DPRINT( OSC, ("[Input MaxLength] %u\n", Input->MaxLength) );
                }
            }
            break;

        case TOKEN_ENCODE:
            {
                PCHAR pType = GetString( InputString );
                if ( !pType )
                    break;
                if ( Lexstrcmpni( pType, "YES", 3 ) == 0 ) {
                    Input->Encoding = ET_OWF;
                    DPRINT( OSC, ("[Encoding Type] OWF\n") );
                }
                OscHeapFree( pType );
            }
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    // add the control to the list of controls
    Input->Next = ScreenControls;
    ScreenControls = Input;

    if ( Input->Size + BRACKETS > RightMargin - ScreenX ) {
        Input->Size = 0;    // too big, so auto figure
    }

    // adjust screen coordinates
    if ( !Input->Size && Input->MaxLength ) {
        // figure out how much is left of the line, choose the smaller
        Input->Size = ( (RightMargin - ScreenX) - BRACKETS < Input->MaxLength ?
                        (RightMargin - ScreenX) - BRACKETS : Input->MaxLength );
    } else if ( !Input->Size ) {
        // assume the input is going to take the whole line
        Input->Size = (RightMargin - ScreenX) - BRACKETS;
    }

    if ( Input->Size > Input->MaxLength ) {
        Input->Size = Input->MaxLength;
    }

    ScreenX += Input->Size + BRACKETS + 1;

    if ( ScreenX >= RightMargin ) {
        ScreenX = LeftMargin;
        ScreenY++;
    }

    if ( ScreenY > ScreenBottom )
        ScreenY = ScreenBottom;

    // display any predefined values
    if ( Input->Value ) {
        int Length = strlen(Input->Value);
        if ((Input->Type & CT_VARIABLE) == 0) {
            if ( Length > Input->Size ) {
                Length = Input->Size;
            }
            if (Input->Type &  CT_PASSWORD) {
                    int i;
                    BlpPositionCursor( Input->X + 2, Input->Y );
                    for( i = 0; i < Length; i ++ )
                    {
                        PRINT( TEXT("*"), 1*sizeof(TCHAR) );
                    }
            } else {
                BlpPositionCursor( Input->X + 2, Input->Y );
#ifdef UNICODE
                {
                    int i;
                    WCHAR wc;
                    for (i = 0; i< Length; i++) {
                        wc = (WCHAR)(Input->Value)[i];
                        PRINT( &wc, 1*sizeof(WCHAR));
                    }
                }
#else
                PRINT( Input->Value, Length );
#endif
            }
        }
    }

    return Tag;
}

//
// OptionTagState( )
//
enum TOKENS
OptionTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_INVALID;
    LPOPTIONSTRUCT Option;
    PCHAR pszBegin, pszEnd;
    ULONG Length;

    TraceFunc( "OptionTagState( )\n" );

    Option = (LPOPTIONSTRUCT) OscHeapAlloc( sizeof(OPTIONSTRUCT) );
    if ( !Option )
    {
        // get tag arguments
        for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );
        return TOKEN_INVALID;
    }

    RtlZeroMemory( Option, sizeof(OPTIONSTRUCT) );
    Option->Type |= CT_OPTION;

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_VALUE:
            Option->Value = GetString( InputString );
            if ( Option->Value )
                DPRINT( OSC, ("[Options Value] %s\n", Option->Value) );
            break;

        case TOKEN_SELECTED:
            DPRINT( OSC, ("[Option] SELECTED\n") );
            Option->Flags = OF_SELECTED;
            break;

        case TOKEN_TIP:
            Option->Tip = GetString( InputString );
            if ( Option->Tip ) {
                PCHAR psz = Option->Tip;
                Option->EndTip = &Option->Tip[strlen(Option->Tip)];
                // strip CRs and LFs from tip
                while ( psz < Option->EndTip )
                {
                    if ( (*psz == '\r') ||
                         ((*psz < 32) && ((psz == Option->Tip) || (*(psz-1) == ' '))) )
                    {   // remove control codes that follows spaces and all CRs
                        memmove( psz, psz+1, strlen(psz) );
                        Option->EndTip--;
                    }
                    else
                    {
                        if ( *psz < 32 )
                        {   // turn control codes into spaces
                            *psz = 32;
                        }
                        psz++;
                    }
                }
                DPRINT( OSC, ("[Option Tip] %s\n", Option->Tip) );
            }
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    // get the option title - at this point Tag == TOKEN_ENDTAG
    pszBegin = *InputString;
    for(Tag = Lex( InputString ) ; Tag != TOKEN_EOF; Tag = Lex( InputString ) )
    {
        BOOLEAN ExitLoop = FALSE;
        switch( Tag )
        {
        case TOKEN_HTML:
        case TOKEN_ENDHTML:
        case TOKEN_META:
        case TOKEN_TITLE:
        case TOKEN_ENDTITLE:
        case TOKEN_FOOTER:
        case TOKEN_ENDFOOTER:
        case TOKEN_BODY:
        case TOKEN_ENDBODY:
        case TOKEN_PRE:
        case TOKEN_ENDPRE:
        case TOKEN_FORM:
        case TOKEN_ENDFORM:
        case TOKEN_INPUT:
        case TOKEN_SELECT:
        case TOKEN_ENDSELECT:
        case TOKEN_OPTION:
        case TOKEN_BREAK:
        case TOKEN_TIPAREA:
        case TOKEN_PARAGRAPH:
        case TOKEN_ENDPARA:
        case TOKEN_INVALID:
            ExitLoop = TRUE;
            break;
        }

        if ( ExitLoop == TRUE )
            break;
    }
    pszEnd = (*InputString) - Tags[Tag].length;

    // try to take the crud and extra spaces off the end
    while ( pszEnd > pszBegin && *pszEnd <= 32 )
        pszEnd--;

    if ( pszEnd == pszBegin ) {
        pszEnd = (*InputString) - Tags[Tag].length;
    }

    Length = PtrToUint((PVOID)(pszEnd - pszBegin));
    Option->Displayed = OscHeapAlloc( Length + 1 );
    if ( Option->Displayed ) {
        CHAR tmp = *pszEnd;     // save
        *pszEnd = '\0';         // terminate
        strcpy( Option->Displayed, pszBegin );
        *pszEnd = tmp;          // restore
        DPRINT( OSC, ("[Option Name] %s\n", Option->Displayed) );

        // add the control to the list of controls
        Option->Next = ScreenControls;
        ScreenControls = Option;

    } else {

        // remove it since there is nothing to display
        if ( Option->Tip )
            OscHeapFree( Option->Tip );
        if ( Option->Value )
            OscHeapFree( Option->Value );
        OscHeapFree( (void *)Option );
    }

    return Tag;
}

//
// SelectTagState( )
//
enum TOKENS
SelectTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_INVALID;
    LPSELECTSTRUCT Select;

    TraceFunc( "SelectTagState( )\n" );

    Select = (LPSELECTSTRUCT) OscHeapAlloc( sizeof(SELECTSTRUCT) );
    if ( !Select )
    {
        // get tag arguments
        for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );
        return TOKEN_INVALID;
    }

    RtlZeroMemory( Select, sizeof(SELECTSTRUCT) );
    Select->Type |= CT_SELECT;
    Select->X    = ScreenX;
    Select->Y    = ScreenY;
    Select->Size = 1;
    Select->AutoSelect = TRUE;

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_NAME:
            Select->Name = GetString( InputString );
            if ( Select->Name )
                DPRINT( OSC, ("[Select Name] %s\n", Select->Name) );
            break;

        case TOKEN_MULTIPLE:
            DPRINT( OSC, ("[Select] MULTIPLE\n") );
            Select->Flags = OF_MULTIPLE;
            break;

        case TOKEN_NOAUTO:
            DPRINT( OSC, ("[Select] NOAUTO\n") );
            Select->AutoSelect = FALSE;
            break;

        case TOKEN_SIZE:
            {
                PCHAR psz = GetString( InputString );
                if ( psz ) {
                    PCHAR pszOld = psz;  // save because GetInteger modifies
                    Select->Size = GetInteger( &psz );
                    OscHeapFree( pszOld );
                    DPRINT( OSC, ("[Select Size] %u\n", Select->Size) );
                }
            }
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    // add the control to the list of controls
    Select->Next = ScreenControls;
    ScreenControls = Select;

    while( Tag != TOKEN_ENDSELECT && Tag != TOKEN_EOF )
    {
        switch( Tag )
        {
        case TOKEN_OPTION:
            {
                LPOPTIONSTRUCT Option;

                Tag = OptionTagState( InputString );

                Option = ScreenControls;
                if ( Option->Type & CT_OPTION ) {
                    if ( Option->Displayed ) {
                        int Length = strlen( Option->Displayed ) + 1;
                        if ( Select->Width < Length ) {
                            Select->Width = Length;
                        }
                    }
                    if ( Option->Flags == OF_SELECTED ) {
                        Select->CurrentSelection = Option;
                        if ( Select->Flags != OF_MULTIPLE )
                        {
                            Option->Flags = 0;
                        }
                    }
                }
            }
            break;

        default:
            Tag = Lex( InputString );
        }
    }

    // adjust screen coordinates
    ScreenY += Select->Size;

    if ( ScreenY > ScreenBottom ) {
        Select->Size -= ScreenY - ScreenBottom;
        ScreenY = ScreenBottom;
    }

    return Tag;
}

//
// PreformattedPrint( )
//
void
PreformattedPrint(
    IN PCHAR Start,
    IN PCHAR End
    )
{
#ifdef _TRACE_FUNC_
    TraceFunc( "PreformattedPrint( " );
    DPRINT( OSC, ("Start = 0x%08x, End = 0x%08x )\n", Start, End) );
#endif

    BlpPositionCursor( ScreenX, ScreenY );

    while ( Start < End )
    {
        int Length, OldLength;

        while ( Start < End && (*Start == '\r' || *Start == '\n') )
        {
            if ( *Start == '\r' ) {
                ScreenX = LeftMargin;
            }
            if ( *Start == '\n' ) {
                ScreenY++;
                if ( ScreenY > ScreenBottom ) {
                    ScreenY = ScreenBottom;
                }
            }
            Start++;
        }

        Length = PtrToUint((PVOID)(End - Start));
        if ( !Length )
            continue; // nothing to print

        // trunk if needed
        if ( Length > RightMargin - ScreenX ) {

            Length = RightMargin - ScreenX;
        }

        // try to find a "break" character
        OldLength = Length;
        while ( Length && Start[Length] != '\r' && Start[Length] != '\n' )
            Length--;

        // If we can't "break" it, just dump one line's worth
        if ( !Length ) {
            DPRINT( OSC, ("[FormattedPrint, Length == 0, Dumping a lines worth]\n") );
            Length = OldLength;
        }
#if DBG
    {
        CHAR tmp = Start[Length];
        Start[Length] = 0;
        DPRINT( OSC, ("[FormattedPrint, Length=%u] '%s'\n", Length, Start) );
        Start[Length] = tmp;
    }
#endif
        BlpPositionCursor( ScreenX, ScreenY );
#ifdef UNICODE
        {
            int i;
            WCHAR wc;
            for (i = 0; i < Length; i++) {
                wc = (WCHAR) Start[i];
                PRINT( &wc, 1*sizeof(WCHAR));
            }
        }
#else
        PRINT( Start, Length );
#endif

        ScreenX += Length;

        while ( Start < End && *Start != '\r' && *Start != '\n' )
            Start++;
    }
}
//
// PreTagState( )
//
enum TOKENS
PreTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz = *InputString;

    TraceFunc( "PreTagState( )\n" );

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_LEFT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            LeftMargin = GetInteger( InputString );
            DPRINT( OSC, ("[LeftMargin = %u]\n", LeftMargin) );
            break;

        case TOKEN_RIGHT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            RightMargin = GetInteger( InputString );
            DPRINT( OSC, ("[RightMargin = %u]\n", RightMargin) );
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    if ( ScreenX >= RightMargin ) {
        ScreenY++;
        if ( ScreenY > ScreenBottom ) {
            ScreenY = ScreenBottom;
        }
    }
    if ( ScreenX >= RightMargin || ScreenX < LeftMargin ) {
        ScreenX = LeftMargin;
    }

    PreformattedMode = TRUE;
    psz = *InputString;
    while ( Tag != TOKEN_EOF )
    {
        switch (Tag)
        {
        case TOKEN_ENDPRE:
        case TOKEN_ENDHTML:
        case TOKEN_ENDBODY:
            PreformattedPrint( psz, (*InputString) - Tags[Tag].length );
            PreformattedMode = FALSE;
            return Tag; // exit state

        // just print everything else
        default:
            PreformattedPrint( psz, *InputString );
            psz = *InputString;
            Tag = Lex( InputString );
            break;
        }
    }

    PreformattedMode = FALSE;
    return Tag;
}

//
// TipAreaTagState( )
//
enum TOKENS
TipAreaTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz = *InputString;

    TraceFunc( "TipAreaTagState( )\n" );

    if ( !TipArea ) {
        TipArea = (LPTIPAREA) OscHeapAlloc( sizeof(TIPAREA) );
        if ( !TipArea )
        {
            // get tag arguments
            for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );
            return TOKEN_INVALID;
        }
    }

    TipArea->X = ScreenX;
    TipArea->Y = ScreenY;
    TipArea->LeftMargin = LeftMargin;
    TipArea->RightMargin = RightMargin;
    TipArea->Size = ScreenBottom - ScreenY;

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_LEFT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            TipArea->LeftMargin = GetInteger( InputString );
            DPRINT( OSC, ("[TipArea LeftMargin = %u]\n", TipArea->LeftMargin) );
            break;

        case TOKEN_RIGHT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            TipArea->RightMargin = GetInteger( InputString );
            DPRINT( OSC, ("[TipArea RightMargin = %u]\n", TipArea->RightMargin) );
            break;

        case TOKEN_SIZE:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            TipArea->Size = GetInteger( InputString ) - 1;
            if ( TipArea->Size < 1 ) {
                TipArea->Size = 1;
            }
            DPRINT( OSC, ("[TipArea Size = %u]\n", TipArea->Size) );
            ScreenY += TipArea->Size;
            break;

        case TOKEN_EOF:
            // imcomplete statement - so don't have a tiparea.
            TipArea = NULL;
            return Tag;
        }
    }

    if ( ScreenY > ScreenBottom ) {
        ScreenY = ScreenBottom;
    }

    return Tag;
}

int ParaOldLeftMargin = 0;
int ParaOldRightMargin = 0;

//
// ParagraphTagState( )
//
enum TOKENS
ParagraphTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz;

    TraceFunc( "ParagraphTagState( )\n" );

    ParaOldLeftMargin = LeftMargin;
    ParaOldRightMargin = RightMargin;

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_LEFT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            LeftMargin = GetInteger( InputString );
            DPRINT( OSC, ("[LeftMargin = %u]\n", LeftMargin) );
            break;

        case TOKEN_RIGHT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            RightMargin = GetInteger( InputString );
            DPRINT( OSC, ("[RightMargin = %u]\n", RightMargin) );
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    // always simulate a <BR>
    ScreenY++;
    if ( ScreenY > ScreenBottom ) {
        ScreenY = ScreenBottom;
    }
    ScreenX = LeftMargin;

    return Tag;
}

//
// FormTagState( )
//
enum TOKENS
FormTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz;

    TraceFunc( "FormTagState( )\n" );

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_ACTION:
            if ( !EnterKey ) {
                EnterKey = (LPKEY_RESPONSE) OscHeapAlloc( sizeof(KEY_RESPONSE) );
            }
            if ( !EnterKey )
                break;
            EnterKey->Action = ACTION_JUMP;
            EnterKey->ScreenName = GetString( InputString );
            if ( EnterKey->ScreenName )
                DPRINT( OSC, ("[Key Enter Action: JUMP to '%s.OSC']\n", EnterKey->ScreenName) );
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    psz = *InputString;

    while ( Tag != TOKEN_EOF && Tag != TOKEN_ENDFORM )
    {
        switch (Tag)
        {
        default:
            if ( !psz ) {
                psz = *InputString;
            }
            Tag = Lex( InputString );
            break;

        case TOKEN_SELECT:
        case TOKEN_INPUT:
        case TOKEN_PRE:
        case TOKEN_BOLD:
        case TOKEN_FLASH:
        case TOKEN_ENDFLASH:
        case TOKEN_ENDBOLD:
        case TOKEN_BREAK:
        case TOKEN_ENDBODY:
        case TOKEN_FORM:
        case TOKEN_TIPAREA:
        case TOKEN_EOF:
        case TOKEN_PARAGRAPH:
        case TOKEN_ENDPARA:
            if ( psz ) {
                BlpPrintString( psz, (*InputString) - Tags[Tag].length );
                psz = NULL; // reset
            }

            switch( Tag )
            {
            case TOKEN_SELECT:
                Tag = SelectTagState( InputString );
                break;

            case TOKEN_INPUT:
                Tag = InputTagState( InputString );
                break;

            case TOKEN_EOF:
                return Tag;

            case TOKEN_PRE:
                Tag = PreTagState( InputString );
                break;

            case TOKEN_BOLD:
                BlpSendEscapeBold(ScreenAttributes);
                DPRINT( OSC, ("[Bold]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_FLASH:
                BlpSendEscapeFlash(ScreenAttributes);
                DPRINT( OSC, ("[Flash]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_ENDFLASH:
            case TOKEN_ENDBOLD:
                BlpSendEscape(ScreenAttributes);
                DPRINT( OSC, ("[Normal]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_FORM:
                // ignore it
                Tag = Lex( InputString );
                break;

            case TOKEN_BREAK:
                ScreenX = LeftMargin;
                ScreenY++;
                if ( ScreenY > ScreenBottom ) {
                    ScreenY = ScreenBottom;
                }
                Tag = Lex( InputString );
                break;

            case TOKEN_TIPAREA:
                Tag = TipAreaTagState( InputString );
                break;

            case TOKEN_PARAGRAPH:
                Tag = ParagraphTagState( InputString );
                break;

            case TOKEN_ENDPARA:
                LeftMargin = ParaOldLeftMargin;
                RightMargin = ParaOldRightMargin;
                // Make sure the boundaries are realistic
                if ( LeftMargin < 1 ) {
                    LeftMargin = 1;
                }
                if ( RightMargin <= LeftMargin ) {
                    RightMargin = LeftMargin + 1;
                }
                if ( RightMargin < 1 ) {
                    RightMargin = 80;
                }
                // always simulate a <BR>
                ScreenY++;
                if ( ScreenY > ScreenBottom ) {
                    ScreenY = ScreenBottom;
                }
                ScreenX = LeftMargin;
                Tag = Lex( InputString );
                break;

            case TOKEN_ENDBODY:
                return Tag; // exit state

            }
            break;
        }
    }

    return Tag;
}

//
// ImpliedBodyTagState( )
//
enum TOKENS
ImpliedBodyTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz = *InputString;

    TraceFunc( "ImpliedBodyTagState( )\n" );

    while ( TRUE )
    {
        // KB: All items in this switch statment must have Tag returned
        //     to them from a function call or must call Lex( ) to get
        //     the next Tag.
        switch (Tag)
        {
        default:
            if ( !psz ) {
                psz = *InputString;
            }
            Tag = Lex( InputString );
            break;

        case TOKEN_PRE:
        case TOKEN_BOLD:
        case TOKEN_FLASH:
        case TOKEN_ENDFLASH:
        case TOKEN_ENDBOLD:
        case TOKEN_BREAK:
        case TOKEN_ENDBODY:
        case TOKEN_FORM:
        case TOKEN_TIPAREA:
        case TOKEN_EOF:
        case TOKEN_PARAGRAPH:
        case TOKEN_ENDPARA:
            if ( psz ) {
                BlpPrintString( psz, (*InputString) - Tags[Tag].length );
                psz = NULL; // reset
            }

            switch( Tag )
            {
            case TOKEN_EOF:
                return Tag;

            case TOKEN_PRE:
                Tag = PreTagState( InputString );
                break;

            case TOKEN_BOLD:
                BlpSendEscapeBold(ScreenAttributes);
                DPRINT( OSC, ("[Bold]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_FLASH:
                BlpSendEscapeFlash(ScreenAttributes);
                DPRINT( OSC, ("[Flash]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_ENDFLASH:
            case TOKEN_ENDBOLD:
                BlpSendEscape(ScreenAttributes);
                DPRINT( OSC, ("[Normal]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_FORM:
                Tag = FormTagState( InputString );
                break;

            case TOKEN_BREAK:
                ScreenX = LeftMargin;
                ScreenY++;
                if ( ScreenY > ScreenBottom ) {
                    ScreenY = ScreenBottom;
                }
                Tag = Lex( InputString );
                break;

            case TOKEN_TIPAREA:
                Tag = TipAreaTagState( InputString );
                break;

            case TOKEN_PARAGRAPH:
                Tag = ParagraphTagState( InputString );
                break;

            case TOKEN_ENDPARA:
                LeftMargin = ParaOldLeftMargin;
                RightMargin = ParaOldRightMargin;
                // Make sure the boundaries are realistic
                if ( LeftMargin < 1 ) {
                    LeftMargin = 1;
                }
                if ( RightMargin <= LeftMargin ) {
                    RightMargin = LeftMargin + 1;
                }
                if ( RightMargin < 1 ) {
                    RightMargin = 80;
                }
                // always simulate a <BR>
                ScreenY++;
                if ( ScreenY > ScreenBottom ) {
                    ScreenY = ScreenBottom;
                }
                ScreenX = LeftMargin;
                Tag = Lex( InputString );
                break;

            case TOKEN_ENDBODY:
                return Tag; // exit state

            }
            break;
        }
    }

    return Tag;
}

//
// BodyTagState( )
//
enum TOKENS
BodyTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz;

    TraceFunc( "BodyTagState( )\n" );

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_LEFT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            LeftMargin = GetInteger( InputString );
            DPRINT( OSC, ("[LeftMargin = %u]\n", LeftMargin) );
            break;

        case TOKEN_RIGHT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            RightMargin = GetInteger( InputString );
            DPRINT( OSC, ("[RightMargin = %u]\n", RightMargin) );
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    if ( ScreenX >= RightMargin ) {
        ScreenY++;
        if ( ScreenY > ScreenBottom ) {
            ScreenY = ScreenBottom;
        }
    }
    if ( ScreenX >= RightMargin || ScreenX < LeftMargin ) {
        ScreenX = LeftMargin;
    }

    return ImpliedBodyTagState( InputString );
}

//
// KeyTagState( )
//
enum TOKENS
KeyTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    LPKEY_RESPONSE Key = NULL;
    PCHAR ScreenName = NULL;

    TraceFunc( "KeyTagState( )\n" );

    // get arguments
    for ( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch (Tag)
        {
        case TOKEN_ENTER:
            DPRINT( OSC, ("[Key Enter]\n") );
            EnterKey = (LPKEY_RESPONSE) OscHeapAlloc( sizeof(KEY_RESPONSE) );
            if ( !EnterKey )
                break;
            Key = EnterKey;
            Key->ScreenName = NULL;
            Key->Action = ACTION_NOP;
            break;

        case TOKEN_F1:
            DPRINT( OSC, ("[Key F1]\n") );
            F1Key = (LPKEY_RESPONSE) OscHeapAlloc( sizeof(KEY_RESPONSE) );
            if ( !F1Key )
                break;
            Key = F1Key;
            Key->ScreenName = NULL;
            Key->Action = ACTION_NOP;
            break;

        case TOKEN_F3:
            DPRINT( OSC, ("[Key F3]\n") );
            F3Key = (LPKEY_RESPONSE) OscHeapAlloc( sizeof(KEY_RESPONSE) );
            if ( !F3Key )
                break;
            Key = F3Key;
            Key->ScreenName = NULL;
            Key->Action = ACTION_NOP;
            break;

        case TOKEN_ESC:
            DPRINT( OSC, ("[Key Escape]\n") );
            EscKey = (LPKEY_RESPONSE) OscHeapAlloc( sizeof(KEY_RESPONSE) );
            if ( !EscKey )
                break;
            Key = EscKey;
            Key->ScreenName = NULL;
            Key->Action = ACTION_NOP;
            break;

        case TOKEN_HREF:
            if ( Key ) {
                Key->Action = ACTION_JUMP;
                Key->ScreenName = GetString( InputString );
                if ( Key->ScreenName )
                    DPRINT( OSC, ("[Key Action: JUMP to '%s.OSC']\n", Key->ScreenName) );
            }
            break;

        case TOKEN_ACTION:
            if ( Key ) {
                PCHAR pAction = GetString( InputString );
                if ( !pAction )
                    break;
                if ( Lexstrcmpni( pAction, "REBOOT", 6 ) == 0 ) {
                    DPRINT( OSC, ("[Key Action: REBOOT]\n") );
                    Key->Action = ACTION_REBOOT;
                } else {
                    DPRINT( OSC, ("[Key Action?] %s\n", pAction) );
                }
                OscHeapFree( pAction );
            }
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    return Tag;
}

//
// MetaTagState( )
//
enum TOKENS
MetaTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;

    TraceFunc( "MetaTagState( )\n" );

    // get tag arguments
    while ( Tag != TOKEN_ENDTAG )
    {
        // KB: All items in this switch statment must have Tag returned
        //     to them from a function call or must call Lex( ) to get
        //     the next Tag.
        switch (Tag)
        {
        case TOKEN_EOF:
            return Tag;

        case TOKEN_KEY:
            Tag = KeyTagState( InputString );
            break;

        case TOKEN_SERVER:
            DPRINT( OSC, ("[Server Meta - ignored]\n") );
            // ignore server side METAs
            while ( Tag != TOKEN_EOF && Tag != TOKEN_ENDTAG )
            {
                Tag = Lex( InputString );
            }
            break;

#if defined(PLEASE_WAIT)
        case TOKEN_WAITMSG:
            {
                if ( PleaseWaitMsg )
                {
                    OscHeapFree( PleaseWaitMsg );
                }

                PleaseWaitMsg = GetString( InputString );
                if ( !PleaseWaitMsg )
                    break;
                Tag = Lex( InputString );

                DPRINT( OSC, ("[WaitMsg: '%s'\n", PleaseWaitMsg ) );
            }
            break;
#endif

        case TOKEN_ACTION:
            {
                PCHAR pAction = GetString( InputString );
                if ( !pAction )
                    break;
                if ( Lexstrcmpni( pAction, "LOGIN", 5 ) == 0 ) {
                    DPRINT( OSC, ("[Screen Action: LOGIN]\n") );
                    LoginScreen = TRUE;
                } else if ( Lexstrcmpni( pAction, "AUTOENTER", 9 ) == 0 ) {
                    DPRINT( OSC, ("[Screen Action: AUTOENTER]\n") );
                    AutoEnter = TRUE;
                } else {
                    DPRINT( OSC, ("[Screen Action?] %s\n", pAction) );
                }
                OscHeapFree( pAction );
            }
            // fall thru

        default:
            Tag = Lex( InputString );
            break;
        }

    }
    return Tag;
}

//
// OSCMLTagState( )
//
enum TOKENS
OSCMLTagState(
    IN PCHAR * InputString
    )
{
#ifdef HEADLESS_SRV
    ULONG y;
#endif
    enum TOKENS Tag = TOKEN_START;

    TraceFunc( "OSCMLTagState( )\n" );

    BlpSendEscape(ScreenAttributes);
    BlpClearScreen();

    ScreenX = LeftMargin;
    ScreenY = SCREEN_TOP;

    while ( Tag != TOKEN_EOF )
    {
        switch (Tag)
        {
        case TOKEN_TITLE:
            Tag = TitleTagState( InputString );
            break;

        case TOKEN_FOOTER:
            Tag = FooterTagState( InputString );
            break;

        case TOKEN_META:
            Tag = MetaTagState( InputString );
            break;

        case TOKEN_BODY:
            Tag = BodyTagState( InputString );
            break;

        case TOKEN_ENDHTML:
            return Tag; // exit state

        default:
            Tag = Lex( InputString );
            break;
        }
    }

    return Tag;
}

// **************************************************************************
//
// "User" Section
//
// **************************************************************************


//
// ProcessEmptyScreen( )
//
// Process a screen that has no input controls
//
CHAR
ProcessEmptyScreen(
    OUT PCHAR OutputString
    )
{
    ULONG Key;
    UCHAR KeyAscii;

    TraceFunc("ProcessEmptyScreen()\n");

    while (TRUE) {

        do {

            Key = BlpGetKey();

        } while (Key == 0);

        KeyAscii = (UCHAR)(Key & (ULONG)0xff);

        // If it is enter/esc/F1/F3, check if the screen expects that.

        if ( Key == F1_KEY ) {
            if ( F1Key ) {
                SpecialAction = F1Key->Action;
                if ( F1Key->ScreenName ) {
                    strcpy( OutputString, F1Key->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }

        } else if ( Key == F3_KEY ) {
            if ( F3Key ) {
                SpecialAction = F3Key->Action;
                if ( F3Key->ScreenName ) {
                    strcpy( OutputString, F3Key->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }

#if defined(_BUILDING_OSDISP_)
        } else if ( Key  == F5_KEY ) {
            SpecialAction = ACTION_REFRESH;
            return KeyAscii;
#endif

        } else if ( KeyAscii == (UCHAR)(ESCAPE_KEY & 0xFF) ) {
            if ( EscKey ) {
                SpecialAction = EscKey->Action;
                if ( EscKey->ScreenName ) {
                    strcpy( OutputString, EscKey->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }
        } else {
            // assume any other key is the Enter key
            if ( EnterKey ) {
                SpecialAction = EnterKey->Action;
                if ( EnterKey->ScreenName ) {
                    strcpy( OutputString, EnterKey->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }
        }
    }
}


//
// ProcessInputControl( )
//
ULONG
ProcessInputControl(
    LPINPUTSTRUCT Input
    )
{
    CHAR InputBuffer[ MAX_INPUT_BUFFER_LENGTH ];
    int MaxLength;
    int CurrentLength;
    ULONG Key;
    UCHAR KeyAscii;

    TraceFunc("ProcessInputControl()\n");

    //
    // variable types are not actually printed or processed.
    // return TAB_KEY to move to the next available input control
    //
    if ((Input->Type & CT_VARIABLE) == CT_VARIABLE) {
        return TAB_KEY;
    }

    if ( Input->Value ) {
        CurrentLength = strlen( Input->Value );
        strcpy( InputBuffer, Input->Value );
        OscHeapFree( Input->Value );
        Input->Value = NULL;
    } else {
        CurrentLength = 0;
        InputBuffer[0] = '\0';
    }

    MaxLength = Input->Size;
    if ( Input->MaxLength ) {
        MaxLength = Input->MaxLength;
    }

    // paranoid
    if ( CurrentLength > MaxLength ) {
        CurrentLength = MaxLength;
        InputBuffer[CurrentLength] = '\0';
    }

    if (Input->CurrentPosition > CurrentLength ) {
        Input->CurrentPosition = CurrentLength;
    }

    // paint the "[ .... ]"
    BlpSendEscapeBold( ScreenAttributes );
    BlpPositionCursor( Input->X, Input->Y );
    PRINT(TEXT("["), 1*sizeof(TCHAR));
    BlpPositionCursor( Input->X + Input->Size + BRACKETS, Input->Y );
    PRINT(TEXT("]") ,1*sizeof(TCHAR));
    BlpSendEscape( ScreenAttributes );

    //
    // Let the user type in a string, showing the text at the current
    // location. Returns the key used to exit (so we can distinguish
    // enter and tab).
    //

    while (TRUE) {
        int DrawSize;

        // Get a keystroke -- this returns (from exp.asm):
        //
        // If no key is available, returns 0 (which BlpGetKeyWithBlink hides)
        //
        // If ASCII character is available, LSB 0 is ASCII code
        //                                  LSB 1 is keyboard scan code
        // If extended character is available, LSB 0 is extended ASCII code
        //                                     LSB 1 is keyboard scan code
        //
        // NOTE: For extended keys LSB 0 seems to be 0, not the ASCII code
        // (which makes sense since they have no ASCII codes).

        if ( (Input->Type & CT_PASSWORD) && InputBuffer[Input->CurrentPosition] )
        {
            Key = BlpGetKeyWithBlink( Input->X + Input->CurrentPosition + 2 - Input->FirstVisibleChar,
                                      Input->Y,
                                      '*' );
        } else {
            Key = BlpGetKeyWithBlink( Input->X + Input->CurrentPosition + 2 - Input->FirstVisibleChar,
                                      Input->Y,
                                      InputBuffer[Input->CurrentPosition] );
        }

#if 0
        // TEMP: Show value of any key pressed near the bottom of the screen

        ARC_DISPLAY_INVERSE_VIDEO();
        ARC_DISPLAY_POSITION_CURSOR(0, 20);
        BlPrint(TEXT("%x\n"), Key);
        ARC_DISPLAY_ATTRIBUTES_OFF();
#endif

        KeyAscii = (UCHAR)(Key & (ULONG)0xff);

        // If it is enter/esc/tab/backtab/F1/F3, then we are done.

        if ((Key == BACKTAB_KEY) || (Key == F1_KEY) || (Key == F3_KEY) ||
            (KeyAscii == ENTER_KEY) || (KeyAscii == TAB_KEY) || 
            (KeyAscii == (UCHAR)(ESCAPE_KEY & 0xFF)) ||
            (Key == DOWN_ARROW) || (Key == UP_ARROW) || (Key == F5_KEY)) {
            break;
        }

        // If it is backspace, then go back one character.

        if ( KeyAscii == (UCHAR)(BKSP_KEY & 0xFF)
          && Input->CurrentPosition != 0
          && CurrentLength != 0 ) {
            Input->CurrentPosition--;
            memcpy( &InputBuffer[Input->CurrentPosition],
                    &InputBuffer[Input->CurrentPosition+1],
                    CurrentLength - Input->CurrentPosition + 1 );
            CurrentLength--;

            if ( Input->CurrentPosition <= Input->FirstVisibleChar ) {
                Input->FirstVisibleChar -= Input->Size / 2;
                if ( Input->FirstVisibleChar < 0 ) {
                    Input->FirstVisibleChar = 0;
                }
            }
        }

        if ( Key == LEFT_KEY ) {
            Input->CurrentPosition--;
            if ( Input->CurrentPosition < 0 ) {
                Input->CurrentPosition = 0;
            }
        }

        if ( Key == RIGHT_KEY && Input->CurrentPosition < CurrentLength ) {
            Input->CurrentPosition++;
        }

        if ( Key == END_KEY ) {
            Input->CurrentPosition = CurrentLength;
        }

        if ( Key == HOME_KEY ) {
            Input->CurrentPosition = 0;
        }

        if ( Key == DEL_KEY
          && CurrentLength != 0
          && Input->CurrentPosition != CurrentLength ) {
            memcpy( &InputBuffer[Input->CurrentPosition],
                    &InputBuffer[Input->CurrentPosition+1],
                    CurrentLength - Input->CurrentPosition + 1 );

            CurrentLength--;
        }

        if ( Key == INS_KEY ) {
            InsertMode = 1 - InsertMode;
        }

        // For now allow any printable character

        if ((KeyAscii >= ' ') && (KeyAscii <= '~')) {

            //
            // If we are at the maximum, then don't allow it.
            //
            if (Input->CurrentPosition > MaxLength || CurrentLength >= MaxLength ) {
                continue;
            }

            if ( !InsertMode ) {
                // add or replace a character
                InputBuffer[Input->CurrentPosition] = KeyAscii;
                Input->CurrentPosition++;
                if ( Input->CurrentPosition > CurrentLength ) {
                    CurrentLength++;
                    InputBuffer[CurrentLength] = '\0';
                }
            } else {
                // insert character
                memmove( &InputBuffer[Input->CurrentPosition+1],
                         &InputBuffer[Input->CurrentPosition],
                         CurrentLength - Input->CurrentPosition );
                CurrentLength++;
                InputBuffer[CurrentLength] = '\0';
                InputBuffer[Input->CurrentPosition] = KeyAscii;
                Input->CurrentPosition++;
            }
        }

        if ( Input->CurrentPosition > Input->FirstVisibleChar + Input->Size ) {
            Input->FirstVisibleChar = Input->CurrentPosition - Input->Size;
        }

        //
        // Scroll Adjuster Section
        //

        DrawSize = Input->Size + 1;

        // Paranoid
        if ( Input->CurrentPosition < Input->FirstVisibleChar ) {
            Input->FirstVisibleChar = Input->CurrentPosition;
        }

        BlpPositionCursor( Input->X + 1, Input->Y );
        if ( Input->FirstVisibleChar <= 0 ) {
            Input->FirstVisibleChar = 0;
            PRINT( SpaceString, 1*sizeof(TCHAR) );
        } else {
            PRINT( TEXT("<"), 1*sizeof(TCHAR) );
        }

        if ( DrawSize > CurrentLength - Input->FirstVisibleChar ) {
            DrawSize = CurrentLength - Input->FirstVisibleChar;
        }

        DPRINT( OSC, ("CurrentPosition: %u\tFirstVisibleChar:%u\tCurrentLength:%u\tDrawSize:%u\n",
            Input->CurrentPosition, Input->FirstVisibleChar, CurrentLength, DrawSize ) );

        if ( Input->Type & CT_PASSWORD ) {
            int i;

            for( i = Input->FirstVisibleChar; i < Input->FirstVisibleChar + DrawSize; i++ )
            {
                PRINT( TEXT("*"), 1*sizeof(TCHAR) );
            }

            PRINT( SpaceString, 1*sizeof(TCHAR) );
        } else {
#ifdef UNICODE
            int i;
            for (i = 0; i < DrawSize; i++) {
                WCHAR wc = (WCHAR)InputBuffer[Input->FirstVisibleChar+i];
                PRINT( &wc, 1*sizeof(WCHAR));
            }
#else
            PRINT( &InputBuffer[Input->FirstVisibleChar], DrawSize );
#endif
            PRINT( SpaceString, 1*sizeof(TCHAR) );
            break;
        }

        BlpPositionCursor( Input->X + Input->Size + BRACKETS - 1, Input->Y );
        if ( Input->FirstVisibleChar + DrawSize < CurrentLength
          && CurrentLength > Input->Size ) {
            PRINT( TEXT(">"), 1*sizeof(TCHAR) );
        } else {
            PRINT( SpaceString, 1*sizeof(TCHAR) );
        }
    }

    // copy the buffer
    Input->Value = OscHeapAlloc( CurrentLength + 1 );
    if ( Input->Value ) {
        memcpy( Input->Value, InputBuffer, CurrentLength + 1 );
    }

    // UN-paint the "[ .... ]"
    BlpPositionCursor( Input->X, Input->Y );
    PRINT(SpaceString, 1*sizeof(TCHAR));
    BlpPositionCursor( Input->X + Input->Size + BRACKETS, Input->Y );
    PRINT(TEXT(" ") ,1*sizeof(TCHAR));

    // If we exited on a standard key return the ASCII value, otherwise
    // the full key value.

    if (KeyAscii != 0) {
        return (ULONG)KeyAscii;
    } else {
        return Key;
    }
}

//
// ShowSelectedOptions( )
//
void
ShowSelectedOptions(
    LPSELECTSTRUCT Select,
    LPOPTIONSTRUCT Option,
    int            YPosition,
    BOOLEAN        Hovering
    )
{
    TraceFunc( "ShowSelectedOptions( )\n" );

    if ( Option->Flags == OF_SELECTED ) {
        BlpSendEscapeBold( ScreenAttributes );
    }

    if ( Hovering == TRUE ) {
        BlpSendEscapeReverse( ScreenAttributes );
    }

    // Erase
    BlpPositionCursor( Select->X, YPosition );
    PRINT( SpaceString, Select->Width*sizeof(TCHAR) );

    // Draw
    BlpPositionCursor( Select->X, YPosition );
    if ( Option->Displayed )
#ifdef UNICODE
        {
        ULONG i;
        WCHAR wc;
            for (i = 0; i< strlen(Option->Displayed); i++) {
                wc = (WCHAR)(Option->Displayed)[i];
                PRINT( &wc, sizeof(WCHAR));
            }
        }
#else
        PRINTL( Option->Displayed );
#endif

    if ( Option->Value )
        DPRINT( OSC, ("[Option Y=%u] %s %s\n", YPosition, Option->Value, (Hovering ? "HIGHLITED" : "")) );

    BlpSendEscape( ScreenAttributes );

    if ( TipArea && Hovering == TRUE ) {
        // Draw help area
        int SaveLeftMargin = LeftMargin;
        int SaveRightMargin = RightMargin;
        int SaveScreenY = ScreenY;
        int SaveScreenX = ScreenX;
        int SaveScreenBottom = ScreenBottom;

        // Set the drawing area
        ScreenX = TipArea->X;
        ScreenY = TipArea->Y;
        LeftMargin = TipArea->LeftMargin;
        RightMargin = TipArea->RightMargin;
        ScreenBottom = TipArea->Y + TipArea->Size;

        // Clear the old help text out
        BlpPositionCursor( TipArea->X, TipArea->Y );
        PRINT( SpaceString, (TipArea->RightMargin - TipArea->X)*sizeof(TCHAR) );

        for ( YPosition = TipArea->Y + 1; YPosition < ScreenBottom ; YPosition++ )
        {
            BlpPositionCursor( TipArea->LeftMargin, YPosition );
            PRINT( SpaceString, (TipArea->RightMargin - TipArea->LeftMargin)*sizeof(TCHAR) );
        }

        // Print it!
        DPRINT( OSC, ("[Options Tip X=%u Y=%u Left=%u Right=%u Bottom=%u] %s\n",
            ScreenX, ScreenY, LeftMargin, RightMargin, ScreenBottom, Option->Tip) );
        BlpPrintString( Option->Tip, Option->EndTip );

        // Restore
        ScreenX = SaveScreenX;
        ScreenY = SaveScreenY;
        RightMargin = SaveRightMargin;
        LeftMargin = SaveLeftMargin;
        ScreenBottom = SaveScreenBottom;;
    }
}

//
// DrawSelectControl( )
//
// Select controls get drawn from the bottom up.
//
void
DrawSelectControl(
    LPSELECTSTRUCT Select,
    int OptionCount
    )
{
    LPOPTIONSTRUCT Option = Select->FirstVisibleSelection;

    TraceFunc( "DrawSelectControl( )\n" );

    ScreenY = Select->Y + ( OptionCount < Select->Size ? OptionCount : Select->Size ) - 1;

    while ( Option )
    {
        if ( Option->Type & CT_OPTION ) {
            BOOLEAN b = (Select->CurrentSelection == Option);
            ShowSelectedOptions( Select, Option, ScreenY,  b );
            ScreenY--;
        }

        if ( ScreenY < Select->Y || Option->Next == Select )
            break;

        Option = Option->Next;
    }
}

//
// ProcessSelectControl( )
//
ULONG
ProcessSelectControl(
    LPSELECTSTRUCT Select
    )
{
    ULONG Key;
    int   OptionCount = 0;
    LPOPTIONSTRUCT Option;
    int   fMultipleControls = FALSE;

    TraceFunc("ProcessSelectControl()\n");

    // find out about the control
    Option = ScreenControls;
    while( Option )
    {
        if ( Option->Type & CT_OPTION ) {

            OptionCount++;

        } else if ( (Option->Type & CT_SELECT) == 0 ) {
            // not the only control on the screen
            DPRINT( OSC, ("[Select] Not the only control on the screen.\n") );
            fMultipleControls = TRUE;
        }

        if ( Option->Next == Select )
            break;

        Option = Option->Next;
    }

    // if this is the first thru and nothing else
    if ( !Select->CurrentSelection && Option ) {
        DPRINT( OSC, ("[Select] Setting CurrentSelection to the first item '%s'\n", Option->Value) );
        Select->CurrentSelection = Option;
    }

    // ensure the current selection is visible
EnsureSelectionVisible:
    if ( Select->Size < 2 ) {
        // single line - show the current selection
        Select->FirstVisibleSelection = Select->CurrentSelection;
    } else if ( OptionCount <= Select->Size ) {
        // the number of options is less than or equal to the size
        // of the dialog so simply set the first visible equal to
        // the last OPTION in the list.

        Select->FirstVisibleSelection = ScreenControls;
        while ( Select->FirstVisibleSelection )
        {
            if ( Select->FirstVisibleSelection->Type & CT_OPTION )
                break;

            Select->FirstVisibleSelection = Select->FirstVisibleSelection->Next;
        }

    } else {
    
        //
        // The number of options is greater than the display size so we
        // need to figure out the "best" bottom item.
        //
        ULONG Lines;
        ULONG Count;
        LPOPTIONSTRUCT TmpOption;

        //
        // Find the best FirstVisibleSelection if we already have previously chosen one.
        //
        Count = 0;
        if (Select->FirstVisibleSelection != NULL) {

            //
            // This code checks to see if the current selection is visible with the
            // current first visible selection.
            //
            TmpOption = ScreenControls;

            while (TmpOption->Next != Select) {

                if (TmpOption == Select->FirstVisibleSelection) {
                    Count++;
                } else if (Count != 0) {
                    Count++;
                }

                if (TmpOption == Select->CurrentSelection) {
                    break;
                }

                TmpOption = TmpOption->Next;


            }

            if (TmpOption->Next == Select) {
                Count++;
            }

            //
            // It is, so just display the list.
            //
            if ((Count != 0) && (Count <= (ULONG)(Select->Size))) {                
                goto EndFindVisibleSelection;
            }
            
            //
            // It is not visible, but since we have a FirstVisibleSelection, we can
            // move that around to make it visible.  
            //


            //
            // The current selection comes before the first visible one, so move
            // first visible to the current selection.
            //
            if (Count == 0) {
                Select->FirstVisibleSelection = Select->CurrentSelection;
                goto EndFindVisibleSelection;
            }

            //
            // Count is greater than the screen size, so we move up First visible
            // until count is the screen size.
            //
            TmpOption = ScreenControls;

            while (TmpOption->Next != Select) {

                if (TmpOption == Select->FirstVisibleSelection) {

                    Select->FirstVisibleSelection = TmpOption->Next;
                    Count--;

                    if (Count == (ULONG)(Select->Size)) {
                        break;
                    }

                }

                TmpOption = TmpOption->Next;

            }
            
            goto EndFindVisibleSelection;
        }

        //
        // There is no FirstVisibleSelection, so we choose one that places the current
        // selection near the top of the screen, displaying the first item, if possible.
        //

        TmpOption = Select->CurrentSelection;
        Lines = 0;
        Count = 0;

        //
        // Count the number of items before our current selection.
        //
        while (TmpOption->Next != Select) {

            TmpOption = TmpOption->Next;
            Lines++;

        }

        //
        // Subtract off that many items from what is left for below the selection.
        // 
        Lines = (ULONG)((Lines < (ULONG)(Select->Size)) ? Lines : Select->Size - 1);
        Lines = Select->Size - Lines - 1;

        //
        // If more than a screen before, make this the bottom and move on.
        //
        if (Lines == 0) {
            Select->FirstVisibleSelection = Select->CurrentSelection;
            goto EndFindVisibleSelection;
        }


        TmpOption = ScreenControls;

        //
        // Count the number of items below the current selection
        //
        while (TmpOption != Select->CurrentSelection) {

            TmpOption = TmpOption->Next;
            Count++;

        }

        if (Count < Lines) {
            
            //
            // Not enough items to fill the screen, use the last item.
            //
            Select->FirstVisibleSelection = ScreenControls;

        } else {
        
            //
            // Count back until we reach what will be our bottom item.
            //
            TmpOption = ScreenControls;

            while (Count != Lines) {

                TmpOption = TmpOption->Next;
                Count--;

            }

            Select->FirstVisibleSelection = TmpOption;

        }

    }

EndFindVisibleSelection:

    // paranoid
    if ( !Select->FirstVisibleSelection ) {
        Select->FirstVisibleSelection = ScreenControls;
    }

    while ( TRUE )
    {
        UCHAR KeyAscii = 0;

        DrawSelectControl( Select, OptionCount );
        Option = Select->CurrentSelection;  // remember this

        if ( OptionCount == 0
          || ( Select->AutoSelect == FALSE && OptionCount == 1 ))
        { // empty selection control or no AUTO select
            do {
                Key = BlpGetKey();
            } while ( Key == 0 );

            KeyAscii = (UCHAR)(Key & (ULONG)0xff);
        }
        else if ( OptionCount != 1 )
        { // more than one choice... do the usual
            ULONG CurrentTick, NewTick;
            int   TimeoutCounter = 0;

            // Show any help for this choice
            // BlpShowMenuHelp(psInfo, psInfo->Data[CurChoice].VariableName);

            CurrentTick = GET_COUNTER();
            do {
                Key = BlpGetKey();

                if ( Select->Timeout )
                {
                    NewTick = GET_COUNTER();
                    if ((NewTick < CurrentTick) || ((NewTick - CurrentTick) >= BLINK_RATE))
                    {
                        CHAR Buffer[4];
                        CurrentTick = NewTick;

                        TimeoutCounter++;

                        //
                        // TODO: Update the timer value displayed
                        //

                        if ( TimeoutCounter >= Select->Timeout )
                        {
                            Key = ENTER_KEY; // fake return
                            break;
                        }
                    }
                }

            } while (Key == 0);

            KeyAscii = (UCHAR)(Key & (ULONG)0xff);

            //
            // User pressed a key, so stop doing the timer
            //
            if ( Select->Timeout ) {

                Select->Timeout = 0;

                //
                // TODO: Erase the timer
                //
            }
        }
        else if ( !fMultipleControls ) // && OptionCount == 1
        { // only once choice... auto-accept it
            //
            // Fake return press....
            //
            DPRINT( OSC, ( "[Select] Auto accepting the only option available\n") );
            Key = KeyAscii = ENTER_KEY;
        }

        if ( Select->Flags & OF_MULTIPLE ) {
            if ( KeyAscii == 32 && Select->CurrentSelection) {
                if ( Select->CurrentSelection->Flags & OF_SELECTED ) {
                    Select->CurrentSelection->Flags &= ~OF_SELECTED;    // turn off
                } else {
                    Select->CurrentSelection->Flags |= OF_SELECTED;     // turn on
                }
            }
        } else {
            if ( KeyAscii == ENTER_KEY && Select->CurrentSelection ) {
                Select->CurrentSelection->Flags |= OF_SELECTED;         // turn on
            }
        }

        if ((Key == BACKTAB_KEY) || (Key == F1_KEY) || (Key == F3_KEY) ||
            (KeyAscii == ENTER_KEY) || (KeyAscii == TAB_KEY) || 
            (KeyAscii == (UCHAR)(ESCAPE_KEY & 0xFF)) ||
            (Key == F5_KEY)) {
            // Undraw the selection bar to give user feedback that something has
            // happened
            Select->CurrentSelection = NULL;
            DrawSelectControl( Select, OptionCount );
            break;
        }


        if ( OptionCount ) {

            if (Key == DOWN_ARROW) {

                DPRINT( OSC, ("[KeyPress] DOWN_ARROW\n") );

                Select->CurrentSelection = ScreenControls;

                while ( Select->CurrentSelection && Select->CurrentSelection->Next != Option )
                {
                    Select->CurrentSelection = Select->CurrentSelection ->Next;
                }

                if ( Select->CurrentSelection )
                    DPRINT( OSC, ("[Select] CurrentSelection = '%s'\n", Select->CurrentSelection->Value) );

                // paranoid
                if ( !Select->CurrentSelection )
                    Select->CurrentSelection = Option;

                goto EnsureSelectionVisible;

            } else if ( Key == UP_ARROW ) {

                DPRINT( OSC, ("[KeyPress] UP_ARROW\n") );

                if ( Select->CurrentSelection->Next != Select ) {
                    Select->CurrentSelection = Select->CurrentSelection->Next;
                    DPRINT( OSC, ("[Select] CurrentSelection = '%s'\n", Select->CurrentSelection->Value) );
                }

                // paranoid
                if ( !Select->CurrentSelection )
                    Select->CurrentSelection = Option;

                goto EnsureSelectionVisible;

            } else if ( Key == END_KEY ) {

                DPRINT( OSC, ("[KeyPress] END_KEY\n") );

                Select->CurrentSelection = ScreenControls;

                while( Select->CurrentSelection && (Select->CurrentSelection->Type & CT_OPTION) == 0 )
                {
                    Select->CurrentSelection = Select->CurrentSelection->Next;
                }
                if ( Select->CurrentSelection )
                    DPRINT( OSC, ("[Select] CurrentSelection = '%s'\n", Select->CurrentSelection->Value) );

                // paranoid
                if ( !Select->CurrentSelection )
                    Select->CurrentSelection = Option;

                goto EnsureSelectionVisible;

            } else if ( Key == HOME_KEY ) {

                DPRINT( OSC, ("[KeyPress] HOME_KEY\n") );

                Select->CurrentSelection = ScreenControls;

                while ( Select->CurrentSelection && Select->CurrentSelection->Next != Select )
                {
                    Select->CurrentSelection = Select->CurrentSelection ->Next;
                }

                if ( Select->CurrentSelection )
                    DPRINT( OSC, ("[Select] CurrentSelection = '%s'\n", Select->CurrentSelection->Value) );

                // paranoid
                if ( !Select->CurrentSelection )
                    Select->CurrentSelection = Option;

                goto EnsureSelectionVisible;

            }
        }
    }

    return Key;
}


//
// BlFixupLoginScreenInputs( )
//
// On an input screen, split a USERNAME that has an @ in it, keeping
// the part before the @ in USERNAME and moving the part after to
// USERDOMAIN.
//
void
BlFixupLoginScreenInputs(
    )
{
    LPCONTROLSTRUCT CurrentControl;
    LPINPUTSTRUCT UserNameControl = NULL;
    LPINPUTSTRUCT UserDomainControl = NULL;
    PCHAR AtSign;

    //
    // First loop through and find the USERNAME and USERDOMAIN input
    // controls.
    //

    CurrentControl = ScreenControls;
    while( CurrentControl ) {

        LPINPUTSTRUCT Input = (LPINPUTSTRUCT) CurrentControl;

        if ( ( Input->Type & CT_TEXT ) && ( Input->Name != NULL ) ) {
            if ( Lexstrcmpni( Input->Name, "USERNAME", 8 ) == 0 ) {
                UserNameControl = Input;
            } else if ( Lexstrcmpni( Input->Name, "USERDOMAIN", 10 ) == 0 ) {
                UserDomainControl = Input;
            }
        }
        CurrentControl = CurrentControl->Next;
    }

    //
    // If we found them, fix them up if necessary.
    //

    if ( ( UserNameControl != NULL ) &&
         ( UserNameControl->Value != NULL ) &&
         ( UserDomainControl != NULL) ) {

        AtSign = strchr(UserNameControl->Value, '@');
        if (AtSign != NULL) {
            *AtSign = '\0';   // terminate UserNameControl->Value before the @
            if ( UserDomainControl->Value != NULL ) {
                OscHeapFree( UserDomainControl->Value );  // throw away old domain
            }
            UserDomainControl->Value = OscHeapAlloc( strlen(AtSign+1) + 1 );
            if ( UserDomainControl->Value != NULL ) {
                strcpy(UserDomainControl->Value, AtSign+1);  // copy part after the @
            }
        }
    }
}


//
// ProcessControlResults( )
//
// Process a screen that has input controls
//
void
ProcessControlResults(
    IN PCHAR OutputString
    )
{
    LPCONTROLSTRUCT CurrentControl;
    LPCONTROLSTRUCT LastControl;

    BOOLEAN CheckAdminPassword_AlreadyChecked = FALSE;
    BOOLEAN CheckAdminPasswordConfirm_AlreadyChecked = FALSE;
    
    // start clean
    OutputString[0] = '\0';

    if ( EnterKey ) {
        SpecialAction = EnterKey->Action;
        if ( EnterKey->ScreenName ) {
            strcpy( OutputString, EnterKey->ScreenName );
            strcat( OutputString, "\n" );
        }
    }

    if ( LoginScreen == TRUE ) {
        SpecialAction = ACTION_LOGIN;
        UserName[0]   = '\0';
        Password[0]   = '\0';
        DomainName[0] = '\0';
        BlFixupLoginScreenInputs();  // split username with @ in it
    }

    CurrentControl = ScreenControls;
    while( CurrentControl ) {

        BOOLEAN CheckAdminPasswordConfirm = FALSE;
        BOOLEAN CheckAdminPassword = FALSE;
        
        switch( CurrentControl->Type & (CT_TEXT | CT_PASSWORD | CT_RESET | CT_SELECT | CT_OPTION | CT_VARIABLE))
        {
        case CT_TEXT:
        case CT_PASSWORD:
            {
                LPINPUTSTRUCT Input = (LPINPUTSTRUCT) CurrentControl;
                BOOLEAN LocalOnly;
                 
                DPRINT( OSC, ("About to check a password.\n") );
                
                if ( (Input->Type & (CT_PASSWORD)) &&
                     (Input->Type & (CT_LOCAL)) &&
                     Input->Name ) {

                    LocalOnly = TRUE;
                    
                    if( _strnicmp(Input->Name, "*ADMINISTRATORPASSWORDCONFIRM", 29) == 0 ) {
                        CheckAdminPasswordConfirm = TRUE;
                        CheckAdminPasswordConfirm_AlreadyChecked = TRUE;
                        DPRINT( OSC, ("About to check the ADMINISTRATORPASSWORDCONFIRM\n") );
                    } else if( _strnicmp( Input->Name, "*ADMINISTRATORPASSWORD", 22) == 0 ) {
                        CheckAdminPassword = TRUE;
                        CheckAdminPassword_AlreadyChecked = TRUE;
                        DPRINT( OSC, ("About to check the ADMINISTRATORPASSWORD\n") );
                    } else {
                        DPRINT( OSC, ("It's a local password, but not Admin or AdminConfirm.\n") );
                    }
                
                } else {
                    LocalOnly = FALSE;
                    DPRINT( OSC, ("It's NOT a local password.\n") );
                }

                DPRINT( 
                    OSC, 
                    ("variable %s will%sbe transmitted to the server.\n", 
                    Input->Name,
                    LocalOnly ? " not " : " " ) );
                

                if (Input->Name && !LocalOnly ) {               
                    strcat( OutputString, Input->Name );
                    strcat( OutputString, "=" );
                }

                if ( (Input->Value) && (Input->Encoding == ET_OWF)) {

                    PCHAR TmpLmOwfPassword = NULL;
                    PCHAR TmpNtOwfPassword = NULL;
                    CHAR TmpHashedPW[(LM_OWF_PASSWORD_SIZE+NT_OWF_PASSWORD_SIZE+2)*2];
                    
                    UNICODE_STRING TmpNtPassword;
                    PWCHAR UnicodePassword;
                    ULONG PasswordLen, i;
                    PCHAR OutputLoc;
                    CHAR c;

                    DPRINT( OSC, ("This entry has ET_OWF tagged.\n") );
                    
                    PasswordLen = strlen(Input->Value);

                    UnicodePassword = (PWCHAR)OscHeapAlloc(PasswordLen * sizeof(WCHAR));
                    TmpLmOwfPassword = (PCHAR)OscHeapAlloc(LM_OWF_PASSWORD_SIZE);
                    TmpNtOwfPassword = (PCHAR)OscHeapAlloc(NT_OWF_PASSWORD_SIZE);

                    if( (UnicodePassword != NULL) &&
                        (TmpLmOwfPassword != NULL) &&
                        (TmpNtOwfPassword != NULL) ) {

                        //
                        // Do a quick conversion of the password to Unicode.
                        //
                    
                        TmpNtPassword.Length = (USHORT)(PasswordLen * sizeof(WCHAR));
                        TmpNtPassword.MaximumLength = TmpNtPassword.Length;
                        TmpNtPassword.Buffer = UnicodePassword;
                    
                        for (i = 0; i < PasswordLen; i++) {
                            UnicodePassword[i] = (WCHAR)(Input->Value[i]);
                        }
                    


                        BlOwfPassword(Input->Value, &TmpNtPassword, TmpLmOwfPassword, TmpNtOwfPassword);



                        //
                        // Output the two OWF passwords as hex chars.  If
                        // the value is the administrator password and
                        // should only be stored locally, then
                        // save it in our global variable.  Otherwise put 
                        // it in the output buffer.
                        //
                        OutputLoc = TmpHashedPW;


                        for (i = 0; i < LM_OWF_PASSWORD_SIZE; i++) {
                            c = TmpLmOwfPassword[i];
                            *(OutputLoc++) = rghex [(c >> 4) & 0x0F] ;
                            *(OutputLoc++) = rghex [c & 0x0F] ;
                        }
                        for (i = 0; i < NT_OWF_PASSWORD_SIZE; i++) {
                            c = TmpNtOwfPassword[i];
                            *(OutputLoc++) = rghex [(c >> 4) & 0x0F] ;
                            *(OutputLoc++) = rghex [c & 0x0F] ;
                        }
                        *OutputLoc = '\0';

                        DPRINT( OSC, ("Hashed Password: %s\n", TmpHashedPW) );

                        if (!LocalOnly) {
                            strcat(OutputString,TmpHashedPW);
                        } else {
                            
                            
                            if( CheckAdminPassword ) {
                                strcpy( AdministratorPassword,  TmpHashedPW );
                                DPRINT( OSC, ("AdministratorPassword 1: %s\n", AdministratorPassword) );
                            }
    
                            if( CheckAdminPasswordConfirm ) {
                                strcpy( AdministratorPasswordConfirm,  TmpHashedPW );
                                DPRINT( OSC, ("AdministratorPasswordConfirm 1: %s\n", AdministratorPasswordConfirm) );

                            }
                            
                            
#if 0
                            if (AdministratorPassword[0] != '\0') {
                                if (strcmp(
                                      AdministratorPassword, 
                                      TmpHashedPW)) {
                                    //
                                    // the passwords didn't match.  make the server
                                    // display MATCHPW.OSC and reset the admin password
                                    // for the next time around
                                    //
                                    DPRINT( 
                                        OSC, 
                                        ("Administrator passwords didn't match, force MATCHPW.OSC.\n" ) );

                                    strcpy( OutputString, "MATCHPW\n" );
                                    AdministratorPassword[0] = '\0';
                                } else {
                                    strncpy( 
                                        AdministratorPassword, 
                                        TmpHashedPW, 
                                        sizeof(AdministratorPassword)-1 );
                                }
                            }
#endif
                            OutputLoc = OutputString + strlen(OutputString);
                        }

                        OscHeapFree((PCHAR)UnicodePassword);
                        OscHeapFree(TmpLmOwfPassword);
                        OscHeapFree(TmpNtOwfPassword);
                    }

                } else {
                        
                    
                    DPRINT( OSC, ("This entry does NOT have ET_OWF tagged.\n") );
                    
                    if( LocalOnly ) {
                        //
                        // Load the appropriate password.
                        //
                        if( CheckAdminPassword ) {
                            strcpy( AdministratorPassword, (Input->Value ? Input->Value : "") );
                            DPRINT( OSC, ("I'm setting the Administrator password to %s\n", AdministratorPassword) );
                        }

                        if( CheckAdminPasswordConfirm ) {
                            strcpy( AdministratorPasswordConfirm, (Input->Value ? Input->Value : "") );
                            DPRINT( OSC, ("I'm setting the AdministratorConfirm password to %s\n", AdministratorPasswordConfirm) );
                        }
                    } else  {
                        strcat( OutputString, (Input->Value ? Input->Value : "") );
                    }
                }
                            
                //
                // If both passwords have been processed, check them to see if they match.
                //
                if( CheckAdminPassword_AlreadyChecked &&
                    CheckAdminPasswordConfirm_AlreadyChecked ) {

                    DPRINT( OSC, ("Both Admin and AdminConfirm passwords are set.  About to check if they match.\n") );
                    
                    if( strcmp( AdministratorPassword, AdministratorPasswordConfirm ) ) {

                        //
                        // the passwords didn't match.  make the server
                        // display MATCHPW.OSC and reset the admin password
                        // for the next time around
                        //
                        DPRINT( OSC, ("Administrator passwords didn't match, force MATCHPW.OSC.\n" ) );

                        strcpy( OutputString, "MATCHPW\n" );
                        AdministratorPassword[0] = '\0';
                        AdministratorPasswordConfirm[0] = '\0';
                    
                    } else {
                        DPRINT( OSC, ("Administrator passwords match.\n" ) );

                        //
                        // See if the Admin password is empty.  If so, then put our
                        // super-secret tag on the end to show everyone that it's really
                        // empty, not just uninitialized.
                        //
                        if( AdministratorPassword[0] == '\0' ) {

                            DPRINT( OSC, ("Administrator password is empty, so set our 'it is null' flag.\n" ) );
                            AdministratorPassword[OSC_ADMIN_PASSWORD_LEN-1] = 0xFF;
                        }
                    }
                }
#if 0
                        if (LocalOnly) {
                            if (AdministratorPassword[0] != '\0') {
                                if (strcmp(
                                      AdministratorPassword, 
                                      Input->Value)) {
                                    //
                                    // the passwords didn't match.  make the server
                                    // display MATCHPW.OSC and reset the admin password
                                    // for the next time around
                                    //
                                    DPRINT( 
                                        OSC, 
                                        ("Administrator passwords didn't match, force MATCHPW.OSC.\n" ) );

                                    strcpy( OutputString, "MATCHPW\n" );
                                    AdministratorPassword[0] = '\0';
                                }
                            } else {
                                strncpy( 
                                    AdministratorPassword, 
                                    Input->Value, 
                                    sizeof(AdministratorPassword)-1 );
                            }
                        } else {
                            strcat( OutputString, Input->Value );
                        }
                    }
#endif

                if ( SpecialAction == ACTION_LOGIN 
                     && (Input->Name != NULL) 
                     && (Input->Value != NULL) ) {
                    if ( Lexstrcmpni( Input->Name, "USERNAME", 8 ) == 0 ) {
                        strncpy( UserName, Input->Value, sizeof(UserName)-1 );
                        UserName[sizeof(UserName)-1] = '\0';
                    } else if ( Lexstrcmpni( Input->Name, "*PASSWORD", 9 ) == 0 ) {
                        strncpy( Password, Input->Value, sizeof(Password)-1 );
                        Password[sizeof(Password)-1] = '\0';
                    } else if ( Lexstrcmpni( Input->Name, "USERDOMAIN", 10 ) == 0 ) {
                        strncpy( DomainName, Input->Value, sizeof(DomainName)-1 );
                        DomainName[sizeof(DomainName)-1] = '\0';
                    }
                }

                if (!LocalOnly) {
                    strcat( OutputString, "\n" );
                }
            }
            break;

        case CT_SELECT:
            {
                CHAR NotFirst = FALSE;
                LPOPTIONSTRUCT Option = ScreenControls;
                LPSELECTSTRUCT Select = (LPSELECTSTRUCT) CurrentControl;
                if ( Select->Name ) {
                    strcat( OutputString, Select->Name );
                    strcat( OutputString, "=" );
                }

                while( Option && Option->Type == CT_OPTION )
                {
                    if ( Option->Flags == OF_SELECTED ) {
                        if ( NotFirst ) {
                            strcat( OutputString, "+" );
                        }

                        if ( Option->Value ) {
                            strcat( OutputString, Option->Value );
                            NotFirst = TRUE;
                        }
                    }

                    Option = Option->Next;
                }
                strcat( OutputString, "\n" );
            }
            break;
        case CT_VARIABLE:
            {
                LPINPUTSTRUCT Input = (LPINPUTSTRUCT) CurrentControl;
                strcat( OutputString, Input->Name );
                strcat( OutputString, "=" );
                strcat( OutputString, Input->Value );
                strcat( OutputString, "\n" );
            }
            break;
        }

        CurrentControl = CurrentControl->Next;
    }
}

//
// ProcessScreenControls( )
//
// Process a screen that has input controls
//
CHAR
ProcessScreenControls(
    OUT PCHAR OutputString
    )
{
    ULONG Key;
    UCHAR KeyAscii;
    LPCONTROLSTRUCT CurrentControl;
    LPCONTROLSTRUCT LastControl;

    TraceFunc("ProcessScreenControls()\n");

    // find the first control
    LastControl = ScreenControls;
    while( LastControl ) {
        CurrentControl = LastControl;
        LastControl    = CurrentControl->Next;
    }

    while (TRUE) {

TopOfLoop:
        // show activation on the control
        switch( CurrentControl->Type & (CT_PASSWORD | CT_TEXT | CT_SELECT) )
        {
        case CT_PASSWORD:
        case CT_TEXT:
            Key = ProcessInputControl( (LPINPUTSTRUCT) CurrentControl );
            break;

        case CT_SELECT:
            Key = ProcessSelectControl( (LPSELECTSTRUCT) CurrentControl );
            break;

        default:
            // non-processing control - skip it
            CurrentControl = CurrentControl->Next;
            if ( !CurrentControl ) {
                CurrentControl = ScreenControls;
            }
            goto TopOfLoop;
        }

        LastControl = CurrentControl;

        KeyAscii = (UCHAR)(Key & (ULONG)0xff);

        // If it is enter/esc/F1/F3, check if the screen expects that.

        if ( Key == F1_KEY ) {

            DPRINT( OSC, ("[KeyPress] F1_KEY\n") );

            if ( F1Key ) {
                SpecialAction = F1Key->Action;
                if ( F1Key->ScreenName ) {
                    strcpy( OutputString, F1Key->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }

        } else if ( Key == F3_KEY ) {

            DPRINT( OSC, ("[KeyPress] F3_KEY\n") );

            if ( F3Key ) {
                SpecialAction = F3Key->Action;
                if ( F3Key->ScreenName ) {
                    strcpy( OutputString, F3Key->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }

#if defined(_BUILDING_OSDISP_)
        } else if ( Key == F5_KEY ) {
            SpecialAction = ACTION_REFRESH;
            return KeyAscii;
#endif

        } else if ( KeyAscii == (UCHAR)(ESCAPE_KEY & 0xFF) ) {

            DPRINT( OSC, ("[KeyPress] ESCAPE_KEY\n") );

            if ( EscKey ) {
                SpecialAction = EscKey->Action;
                if ( EscKey->ScreenName ) {
                    strcpy( OutputString, EscKey->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }

        } else if ( KeyAscii == TAB_KEY || Key == DOWN_ARROW ) {

            DPRINT( OSC, ("[KeyPress] TAB_KEY or DOWN_ARROW\n") );

            CurrentControl = ScreenControls;

            while ( CurrentControl->Next != LastControl &&  // next is current one, so stop
                    CurrentControl->Next != NULL )          // at end of list, so we must have been at
                                                            //  the start, so stop here to loop around
            {
                CurrentControl = CurrentControl->Next;
            }

        } else if ( Key == BACKTAB_KEY || Key == UP_ARROW ) {

            DPRINT( OSC, ("[KeyPress] BACKTAB_KEY or UP_ARROW\n") );

            CurrentControl = CurrentControl->Next;
            if (!CurrentControl) {
                CurrentControl = ScreenControls;   // loop around if needed
            }

        } else if ( KeyAscii == ENTER_KEY ) {

            DPRINT( OSC, ("[KeyPress] ENTER_KEY\n") );

            ProcessControlResults( OutputString );

            return KeyAscii;
        }

        if ( !CurrentControl ) {
            CurrentControl = LastControl;
        }
    }
}

//
// BlProcessScreen( )
//
CHAR
BlProcessScreen(
    IN PCHAR InputString,
    OUT PCHAR OutputString
    )
{
#ifdef HEADLESS_SRV
    ULONG y;
#endif
    CHAR chReturn;
    enum TOKENS Tag;

#ifdef _TRACE_FUNC_
    TraceFunc( "BlProcessScreen( " );
    DPRINT( OSC, ("InputString = 0x%08x, OutputString = 0x%08x )\n", InputString, OutputString) );
#endif

    // reset our "heap"
    OscHeapInitialize( );

    // reset the screen variables
    ScreenAttributes = WhiteOnBlueAttributes;
    SpecialAction    = ACTION_NOP;
    LeftMargin       = 1;
    RightMargin      = 80;
    ScreenX          = LeftMargin;
    ScreenY          = SCREEN_TOP;
    F1Key            = NULL;
    F3Key            = NULL;
    EnterKey         = NULL;
    EscKey           = NULL;
    ScreenControls   = NULL;
    PreformattedMode = FALSE;
    LoginScreen      = FALSE;
    AutoEnter        = FALSE;
    InsertMode       = FALSE;
    TipArea          = NULL;

    if (BlIsTerminalConnected()) {
        ScreenBottom     = HEADLESS_SCREEN_HEIGHT;
    } else {
        ScreenBottom     = SCREEN_BOTTOM;
    }
#if defined(PLEASE_WAIT)
    PleaseWaitMsg    = NULL;
#endif

    BlpSendEscape(ScreenAttributes);
    BlpClearScreen();

    Tag = Lex( &InputString );
    while (Tag != TOKEN_EOF )
    {
        switch (Tag)
        {
        case TOKEN_HTML:
            Tag = OSCMLTagState( &InputString );
            break;

        case TOKEN_ENDHTML:
            Tag = TOKEN_EOF;    // exit state
            break;

        default:
            Tag = ImpliedBodyTagState( &InputString );
            break;
        }
    }

    // Remove any buffered keys to prevent blipping thru the screens.
    // NOTE we call BlGetKey() directly, not BlpGetKey(), so we only
    // remove real keystrokes, not the "auto-enter" keystroke.
    while ( BlGetKey( ) != 0 )
        ; // NOP on purpose

    if ( ScreenControls ) {
        chReturn = ProcessScreenControls( OutputString );
    } else {
        chReturn = ProcessEmptyScreen( OutputString );
    }

    // Erase footer to give user feedback that the screen is being
    // processed.
    BlpSendEscapeReverse(ScreenAttributes);
    BlpPositionCursor( 1, ScreenBottom );

#ifdef _IN_OSDISP_
    PRINT( SpaceString, 79*sizeof(TCHAR) );
#else
    PRINT( SpaceString, BlTerminalConnected 
                            ? 79*sizeof(TCHAR)
                            : 80*sizeof(TCHAR) );
#endif

#if defined(PLEASE_WAIT)
    if ( PleaseWaitMsg ) {
        BlpPositionCursor( 1, ScreenBottom );
#ifdef UNICODE
        {
            ULONG i;
            WCHAR wc;
            for (i = 0; i< strlen(PleaseWaitMsg);i++) {
                wc = (WCHAR)PleaseWaitMsg[i];
                PRINT( &wc, 1*sizeof(WCHAR));
            }
        }
#else
        PRINTL( PleaseWaitMsg );
#endif
    }
#endif

    BlpSendEscape(ScreenAttributes);
    return chReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\oschoice\regboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regboot.c

Abstract:

    Provides a minimal registry implementation designed to be used by the
    osloader at boot time.  This includes loading the system hive
    ( <SystemRoot>\config\SYSTEM ) into memory, and computing the driver
    load list from it.

Author:

    John Vert (jvert) 10-Mar-1992

Revision History:

--*/
#include "bldr.h"
#include "msg.h"
#include "cmp.h"
#include "stdio.h"
#include "string.h"

ULONG ScreenWidth=80;
ULONG ScreenHeight=25;


//
// defines for doing console I/O
//
#define ASCII_CR 0x0d
#define ASCII_LF 0x0a
#define ESC 0x1B
#define SGR_INVERSE 7
#define SGR_INTENSE 1
#define SGR_NORMAL 0


//
// prototypes for console I/O routines
//

VOID
BlpClearScreen(
    VOID
    );

VOID
BlpClearToEndOfLine(
    VOID
    );

VOID
BlpPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    );

VOID
BlpSetInverseMode(
    IN BOOLEAN InverseOn
    );



VOID
BlpClearScreen(
    VOID
    )

/*++

Routine Description:

    Clears the screen.

Arguments:

    None

Return Value:

    None.

--*/

{
#if 0
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "2J");

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             strlen(Buffer),
             &Count);
#else
    BlClearScreen();
#endif
}



VOID
BlpClearToEndOfLine(
    VOID
    )
{
#if 0
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "K");
    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             strlen(Buffer),
             &Count);
#else
    BlClearToEndOfLine();
#endif
}


VOID
BlpPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    )

/*++

Routine Description:

    Sets the position of the cursor on the screen.

Arguments:

    Column - supplies new Column for the cursor position.

    Row - supplies new Row for the cursor position.

Return Value:

    None.

--*/

{
#if 0
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "%d;%dH", Row, Column);

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             strlen(Buffer),
             &Count);
#else
    BlPositionCursor( Column, Row );
#endif
}


VOID
BlpSetInverseMode(
    IN BOOLEAN InverseOn
    )

/*++

Routine Description:

    Sets inverse console output mode on or off.

Arguments:

    InverseOn - supplies whether inverse mode should be turned on (TRUE)
                or off (FALSE)

Return Value:

    None.

--*/

{
#if 0
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "%dm", InverseOn ? SGR_INVERSE : SGR_NORMAL);

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             strlen(Buffer),
             &Count);
#else
    BlSetInverseMode( InverseOn );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\oschoice\ia64\initia64.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initx86.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC osloader

Author:

    John Vert (jvert) 4-Nov-1993

Revision History:

--*/
#include "bldria64.h"
#include "msg.h"
#include "efi.h"
#include "stdio.h"

extern EFI_SYSTEM_TABLE        *EfiST;

VOID
BlInitializeTerminal(
    VOID
    );


UCHAR BootPartitionName[80];
UCHAR KernelBootDevice[80];
UCHAR OsLoadFilename[100];
UCHAR OsLoaderFilename[100];
UCHAR SystemPartition[100];
UCHAR OsLoadPartition[100];
UCHAR OsLoadOptions[100];
UCHAR ConsoleInputName[50];
UCHAR MyBuffer[SECTOR_SIZE+32];
UCHAR ConsoleOutputName[50];
UCHAR X86SystemPartition[sizeof("x86systempartition=") + sizeof(BootPartitionName)];


VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly presenting the boot.ini
    menu and running NTDETECT, then calls to the common osloader.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc = 0;
    PUCHAR Argv[10];
    ARC_STATUS Status;
    ULONG BootFileId;
    PCHAR BootFile;
    ULONG Read;
    PCHAR p;
    ULONG i;
    ULONG DriveId;
    ULONG FileSize;
    ULONG Count;
    LARGE_INTEGER SeekPosition;
    PCHAR LoadOptions = NULL;
    BOOLEAN UseTimeOut=TRUE;
    BOOLEAN AlreadyInitialized = FALSE;
    extern BOOLEAN FwDescriptorsValid;

    //
    // Initialize ARC StdIo functionality
    //

    strcpy(ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)");
    strcpy(ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)");
    Argv[0]=ConsoleInputName;
    Argv[1]=ConsoleOutputName;
    BlInitStdio (2, Argv);

    //
    // Initialize any dumb terminal that may be connected.
    //
    BlInitializeTerminal();

    //
    // The main functionality of the OS chooser.
    //
    BlOsLoader( Argc, Argv, NULL );


    //
    // If we ever come back here, just wait to reboot.
    //
    if (BlIsTerminalConnected()) {
        if (BlTerminalHandleLoaderFailure()) {
            ArcRestart();
        }    
    } else {
        REBOOT(0);
    }
}

VOID
BlInitializeTerminal(
    VOID
    )

/*++

Routine Description:

    Does initialization of a dumb terminal connected to a serial port.
    
Arguments:

    None.

Return Value:

    None.

--*/

{


    //
    // Try to initialize the headless port.
    //
    BlInitializeHeadlessPort();

    if( LoaderRedirectionInformation.PortNumber == 0 ) {

        //
        // we didn't get anything from the BIOS.  See if StartROM
        // was redirecting.
        //
#if 0
        if( (BOOLEAN)(BIOS_REDIRECT_SERVICE(1) != -1) ) {

            //
            // He is.  Pick up his settings.
            //
            RtlZeroMemory( LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );

            LoaderRedirectionInformation.PortNumber = (ULONG)BIOS_REDIRECT_SERVICE(1);
            LoaderRedirectionInformation.BaudRate = (ULONG)BIOS_REDIRECT_SERVICE(2);
            LoaderRedirectionInformation.Parity = (BOOLEAN)BIOS_REDIRECT_SERVICE(3);
            LoaderRedirectionInformation.StopBits = (UCHAR)BIOS_REDIRECT_SERVICE(4);

            //
            // Now try again, this time with feeling...
            //
            BlInitializeHeadlessPort();

        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\oschoice\i386\initx86.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initx86.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC osloader

Author:

    John Vert (jvert) 4-Nov-1993

Revision History:

--*/
#include "bldrx86.h"
#include "msg.h"
#include "stdio.h"

VOID
BlInitializeTerminal(
    VOID
    );


UCHAR BootPartitionName[80];
UCHAR KernelBootDevice[80];
UCHAR OsLoadFilename[100];
UCHAR OsLoaderFilename[100];
UCHAR SystemPartition[100];
UCHAR OsLoadPartition[100];
UCHAR OsLoadOptions[100];
UCHAR ConsoleInputName[50];
UCHAR MyBuffer[SECTOR_SIZE+32];
UCHAR ConsoleOutputName[50];
UCHAR X86SystemPartition[sizeof("x86systempartition=") + sizeof(BootPartitionName)];


VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly presenting the boot.ini
    menu and running NTDETECT, then calls to the common osloader.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc = 0;
    PUCHAR Argv[10];
    ARC_STATUS Status;
    ULONG BootFileId;
    PCHAR BootFile;
    ULONG Read;
    PCHAR p;
    ULONG i;
    ULONG DriveId;
    ULONG FileSize;
    ULONG Count;
    LARGE_INTEGER SeekPosition;
    PCHAR LoadOptions = NULL;
    BOOLEAN UseTimeOut=TRUE;
    BOOLEAN AlreadyInitialized = FALSE;
    extern BOOLEAN FwDescriptorsValid;

    //
    // Initialize ARC StdIo functionality
    //

    strcpy(ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)");
    strcpy(ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)");
    Argv[0]=ConsoleInputName;
    Argv[1]=ConsoleOutputName;
    BlInitStdio (2, Argv);

    //
    // Initialize any dumb terminal that may be connected.
    //
    BlInitializeTerminal();

    //
    // Announce the loader
    //
    BlPrint(OsLoaderVersion);
    

    //
    // The main functionality of the OS chooser.
    //
    BlOsLoader( Argc, Argv, NULL );

    //
    // If we ever come back here, just wait to reboot.
    //
    if (BlIsTerminalConnected()) {
        if (BlTerminalHandleLoaderFailure()) {
            ArcRestart();
        }    
    } else {
        REBOOT(0);
    }
}

VOID
BlInitializeTerminal(
    VOID
    )

/*++

Routine Description:

    Does x86-specific initialization of a dumb terminal connected to a serial port.
    
Arguments:

    None.

Return Value:

    None.

--*/

{


    //
    // Try to initialize the headless port.
    //
    BlInitializeHeadlessPort();

    if( LoaderRedirectionInformation.PortNumber == 0 ) {

        //
        // we didn't get anything from the BIOS.  See if StartROM
        // was redirecting.
        //
        if( (BOOLEAN)(BIOS_REDIRECT_SERVICE(1) != -1) ) {

            //
            // He is.  Pick up his settings.
            //

            RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );

            LoaderRedirectionInformation.PortNumber = (ULONG)BIOS_REDIRECT_SERVICE(1);
            LoaderRedirectionInformation.BaudRate = (ULONG)BIOS_REDIRECT_SERVICE(2);
            LoaderRedirectionInformation.Parity = (BOOLEAN)BIOS_REDIRECT_SERVICE(3);
            LoaderRedirectionInformation.StopBits = (UCHAR)BIOS_REDIRECT_SERVICE(4);

            //
            // Now try again, this time with feeling...
            //
            BlInitializeHeadlessPort();

        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\config.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    config.c

Abstract:

    This module contains code for interpreting and manipulating the ARC
    firmware configuration tree in various ways.

Author:

    John Vert (jvert) 7-Oct-1993

Environment:

    Runs in the ARC environment.

Revision History:

--*/
#include "setupldr.h"
#include "stdio.h"

#define MAX_FLOPPIES 4

PCONFIGURATION_COMPONENT_DATA FloppyData[MAX_FLOPPIES];
ULONG NumFloppies=0;

//
// definition for function callbacks
//

//
// Local prototypes
//

BOOLEAN
EnumerateFloppies(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    );



BOOLEAN
SlFindFloppy(
    IN ULONG FloppyNumber,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    Given a floppy number (0, 1, etc.) this routine computes the appropriate
    ARC name.

Arguments:

    FloppyNumber - Supplies the floppy number.

    ArcName - Returns the ARC name of the specified floppy device

Return Value:

    TRUE - Floppy exists in the ARC firmware tree.

    FALSE - Floppy was not found.

--*/

{
    if (NumFloppies==0) {
        BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                            PeripheralClass,
                            FloppyDiskPeripheral,
                            (ULONG)-1,
                            EnumerateFloppies);
    }

    if (FloppyNumber >= NumFloppies) {
        SlFatalError(SL_FLOPPY_NOT_FOUND,NumFloppies,FloppyNumber);
    }

    BlGetPathnameFromComponent(FloppyData[FloppyNumber],
                               ArcName);
    return(TRUE);
}


BOOLEAN
EnumerateFloppies(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    )

/*++

Routine Description:

    Callback routine for enumerating all the floppies in the ARC config tree.

Arguments:

    ConfigData - Supplies a pointer to the floppies ARC component data.

Return Value:

    TRUE - continue searching

    FALSE - stop searching tree.

--*/

{
    if (NumFloppies == MAX_FLOPPIES) {
        return(FALSE);
    }

    FloppyData[NumFloppies++] = ConfigData;

    return(TRUE);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\arcdtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    arcdtect.c

Abstract:

    Provides HAL and SCSI detection for ARC-compliant machines.

Author:

    John Vert (jvert) 21-Oct-1993

Revision History:

--*/
#include "setupldr.h"
#include <stdlib.h>

#if defined(_IA64_)

//
// Stuff used for detecting video
//
#define MAX_VIDEO_ADAPTERS 5
ULONG VideoAdapterCount;
PCONFIGURATION_COMPONENT_DATA VideoAdapter[MAX_VIDEO_ADAPTERS];

VOID
DecideVideoAdapter(
    VOID
    );

BOOLEAN FoundUnknownScsi;

//
// private function prototypes
//
BOOLEAN
EnumerateSCSIAdapters(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    );

BOOLEAN
EnumerateVideoAdapters(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    );



VOID
SlDetectScsi(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )
/*++

Routine Description:

    Detects SCSI adapters on an ARC machine by walking the ARC firmware tree.

    Fills in the appropriate entries in the setuploaderblock


Arguments:

    SetupBlock - Supplies a pointer to the setup loader block.

Return Value:

    None.

--*/

{
    FoundUnknownScsi = FALSE;

    BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                       AdapterClass,
                       ScsiAdapter,
                       (ULONG)-1,
                       EnumerateSCSIAdapters);
    if (FoundUnknownScsi) {
        //
        // We found at least one scsi device we didn't recognize,
        // so force the OEM selection menu.
        //
        PromptOemScsi=TRUE;
    }

    SetupBlock->ScalarValues.LoadedScsi = 1;
}


BOOLEAN
EnumerateSCSIAdapters(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    )

/*++

Routine Description:

    Callback function for enumerating SCSI adapters in the ARC tree.

    Adds the SCSI adapter that was found to the list of detected SCSI devices.

Arguments:

    ConfigData - Supplies a pointer to the ARC node of the SCSI adapter.

Return Value:

    TRUE - continue searching

    FALSE - some error, abort the search

--*/

{
    PDETECTED_DEVICE ScsiDevice;
    PCHAR AdapterName;
    ULONG Ordinal;
    PCHAR ScsiFileName;
    PTCHAR ScsiDescription;
    SCSI_INSERT_STATUS sis;

    AdapterName = SlSearchSection("Map.SCSI",ConfigData->ComponentEntry.Identifier);
    if (AdapterName==NULL) {
        //
        // We found an adapter in the ARC tree, but it is not one of the ones
        // specified in our INF file, so trigger the prompt for an OEM driver
        // disk.
        //

        FoundUnknownScsi = TRUE;
        return(TRUE);
    }

    //
    // Find this adapter's ordinal within the Scsi.Load section of txtsetup.sif
    //
    Ordinal = SlGetSectionKeyOrdinal(InfFile, "Scsi.Load", AdapterName);
    if(Ordinal == (ULONG)-1) {
        FoundUnknownScsi = TRUE;
        return(TRUE);
    }

    //
    // Find the driver filename
    //
    ScsiFileName = SlGetSectionKeyIndex(InfFile,
                                        "Scsi.Load",
                                        AdapterName,
                                        SIF_FILENAME_INDEX);
    if(!ScsiFileName) {
        FoundUnknownScsi = TRUE;
        return(TRUE);
    }

    //
    // Create a new detected device entry.
    //
    if((sis = SlInsertScsiDevice(Ordinal, &ScsiDevice)) == ScsiInsertError) {
        SlFriendlyError(ENOMEM, "SCSI detection", 0, NULL);
        return(FALSE);
    }

    if(sis == ScsiInsertExisting) {
#if DBG
        //
        // Sanity check to make sure we're talking about the same driver
        //
        if(_stricmp(ScsiDevice->BaseDllName, ScsiFileName)) {
            SlError(400);
            return FALSE;
        }
#endif
    } else {
        //
        // Find the driver description
        //
#ifdef UNICODE
        ScsiDescription = SlGetIniValueW(
#else
        ScsiDescription = SlGetIniValue(
#endif
                                    InfFile,
                                    "SCSI",
                                    AdapterName,
                                    AdapterName);

        ScsiDevice->IdString = AdapterName;
        ScsiDevice->Description = ScsiDescription;
        ScsiDevice->ThirdPartyOptionSelected = FALSE;
        ScsiDevice->FileTypeBits = 0;
        ScsiDevice->Files = NULL;
        ScsiDevice->BaseDllName = ScsiFileName;
    }

    return(TRUE);
}

VOID
SlDetectVideo(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )
/*++

Routine Description:

    Detects video adapters on an ARC machine by walking the ARC firmware tree.

    Fills in the appropriate entries in the setuploaderblock


Arguments:

    SetupBlock - Supplies a pointer to the setup loader block.

Return Value:

    None.

--*/

{
    //
    // On arc machines, there is no default video type.
    //
    SetupBlock->VideoDevice.Next = NULL;
    SetupBlock->VideoDevice.IdString = NULL;
    SetupBlock->VideoDevice.ThirdPartyOptionSelected = FALSE;
    SetupBlock->VideoDevice.FileTypeBits = 0;
    SetupBlock->VideoDevice.Files = NULL;
    SetupBlock->VideoDevice.BaseDllName = NULL;
    SetupBlock->Monitor = NULL;
    SetupBlock->MonitorId = NULL;

    BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                       ControllerClass,
                       DisplayController,
                       (ULONG)-1,
                       EnumerateVideoAdapters);

    DecideVideoAdapter();
}


BOOLEAN
EnumerateVideoAdapters(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    )

/*++

Routine Description:

    Callback function for enumerating video adapters in the ARC tree.

    Adds the video adapter that was found to the setup block.

Arguments:

    ConfigData - Supplies a pointer to the ARC node of the display adapter.

Return Value:

    TRUE - continue searching

    FALSE - some error, abort the search

--*/

{
    //
    // Just remember this guy for later.
    //
    if(VideoAdapterCount < MAX_VIDEO_ADAPTERS) {
        VideoAdapter[VideoAdapterCount++] = ConfigData;
    }
    return(TRUE);
}

VOID
DecideVideoAdapter(
    VOID
    )
{
    IN PCONFIGURATION_COMPONENT_DATA ConfigData;
    PCHAR AdapterName,MonitorId;
    PCONFIGURATION_COMPONENT_DATA MonitorData;
    PMONITOR_CONFIGURATION_DATA Monitor;
    CHAR ArcPath[256];
    CHAR ConsoleOut[256];
    PCHAR p,q;
    ULONG u;

    if(VideoAdapterCount) {
        //
        // The first thing we want to do is to see whether any of the
        // adapters we found match the value of the CONSOLEOUT nvram var.
        // If so then use that node for detection. Before comparing we have to
        // change all instances of () to (0) in the value of CONSOLEOUT.
        //
        ConfigData = NULL;
        if(p = ArcGetEnvironmentVariable("CONSOLEOUT")) {
            strncpy(ArcPath,p,sizeof(ArcPath)-1);
            ArcPath[sizeof(ArcPath)-1] = 0;
            ConsoleOut[0] = 0;
            for(p=ArcPath; q=strstr(p,"()"); p=q+2) {
                *q = 0;
                strcat(ConsoleOut,p);
                strcat(ConsoleOut,"(0)");
            }
            strcat(ConsoleOut,p);

            //
            // Finally, we need to truncate the consoleout variable after
            // the video adapter, if any.
            //
            _strlwr(ConsoleOut);
            if(p = strstr(ConsoleOut,")video(")) {
                *(p+sizeof(")video(")+1) = 0;
            }

            for(u=0; u<VideoAdapterCount; u++) {

                ArcPath[0] = 0;
                BlGetPathnameFromComponent(VideoAdapter[u],ArcPath);

                if(!_stricmp(ConsoleOut,ArcPath)) {
                    ConfigData = VideoAdapter[u];
                    break;
                }
            }
        }

        //
        // If we didn't find a match for CONSOLEOUT then use the last node
        // we found in the tree scan.
        //
        if(!ConfigData) {
            ConfigData = VideoAdapter[VideoAdapterCount-1];
        }

        AdapterName = SlSearchSection("Map.Display",ConfigData->ComponentEntry.Identifier);
        if (AdapterName==NULL) {
            //
            // We found a display adapter in the ARC tree, but it is not one of the ones
            // specified in our INF file, so trigger the prompt for an OEM driver
            // disk.
            //

            PromptOemVideo = TRUE;
            return;
        }

        BlLoaderBlock->SetupLoaderBlock->VideoDevice.IdString = AdapterName;
        BlLoaderBlock->SetupLoaderBlock->VideoDevice.Description = NULL;
        BlLoaderBlock->SetupLoaderBlock->VideoDevice.ThirdPartyOptionSelected = FALSE;
        BlLoaderBlock->SetupLoaderBlock->VideoDevice.FileTypeBits = 0;
        BlLoaderBlock->SetupLoaderBlock->VideoDevice.Files = NULL;
        BlLoaderBlock->SetupLoaderBlock->VideoDevice.BaseDllName = NULL;

        //
        // If there is a monitor peripheral associated with this device,
        // capture its configuration data.  Otherwise, let Setup assume an
        // appropriate default.
        //

        MonitorData = ConfigData->Child;
        if (MonitorData==NULL) {
            BlLoaderBlock->SetupLoaderBlock->Monitor = NULL;
            BlLoaderBlock->SetupLoaderBlock->MonitorId = NULL;
        } else {
            Monitor = BlAllocateHeap(MonitorData->ComponentEntry.ConfigurationDataLength);
            if (Monitor==NULL) {
                SlFriendlyError(ENOMEM, "video detection", 0, NULL);
                return;
            }
            MonitorId = BlAllocateHeap(MonitorData->ComponentEntry.IdentifierLength+1);
            if (MonitorId==NULL) {
                SlFriendlyError(ENOMEM, "video detection", 0, NULL);
                return;
            }

            strncpy(MonitorId,
                    MonitorData->ComponentEntry.Identifier,
                    MonitorData->ComponentEntry.IdentifierLength);

            MonitorId[MonitorData->ComponentEntry.IdentifierLength] = 0;

            RtlCopyMemory((PVOID)Monitor,
                          MonitorData->ConfigurationData,
                          MonitorData->ComponentEntry.ConfigurationDataLength);

            BlLoaderBlock->SetupLoaderBlock->Monitor = Monitor;
            BlLoaderBlock->SetupLoaderBlock->MonitorId = MonitorId;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\arcdisp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    arcdisp.c

Abstract:

    This module provides code for managing screen output on an ARC-compliant
    system.

Author:

    John Vert (jvert) 6-Oct-1993

Revision History:

    John Vert (jvert) 6-Oct-1993
        Taken from old 1.0 splib sources

--*/
#include "setupldr.h"
#include "parseini.h"
#include "stdio.h"
#include "hdlsterm.h"

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#if defined(EFI)
#include "bootefi.h"
#endif


//
// The screen is divided into 3 areas: the header area, the status area,
// and the client area.  The header area basically always says "Windows NT
// Setup".  The status area is always 1 line high and displayed using a
// different attribute (black on gray).
//


#define     HEADER_HEIGHT       3
#define     MAX_STATUS          200   // allow up to 1600 horizontal res.

#define     SCREEN_SIZE         (ScreenWidth*ScreenHeight)

BOOLEAN StatusBarEnabled = TRUE;
ULONG ScreenWidth=80;
ULONG ScreenHeight=25;
ULONG ScreenX=0,ScreenY=0;
UCHAR CurAttribute = (ATT_FG_WHITE | ATT_BG_BLACK);
TCHAR MessageBuffer[1024];

extern BOOLEAN ShowProgressBar;

//
// private function prototypes
//
VOID
SlpDrawMenu(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG TopItem,
    IN ULONG Height,
    IN PSL_MENU Menu
    );

VOID
SlpDrawMenuItem(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG TopItem,
    IN ULONG Height,
    IN ULONG Item,
    IN PSL_MENU Menu
    );

VOID
SlpSizeMessage(
    IN PTCHAR Message,
    OUT PULONG Lines,
    OUT PULONG MaxLength,
    OUT ULONG LineLength[],
    OUT PTCHAR LineText[]
    );



PSL_MENU
SlCreateMenu(
    VOID
    )

/*++

Routine Description:

    Allocates and initializes a new menu structure.

Arguments:

    None

Return Value:

    Pointer to the new menu structure if successful.

    NULL on failure

--*/
{
    PSL_MENU p;

    p=BlAllocateHeap(sizeof(SL_MENU));
    if (p==NULL) {
        return(NULL);
    }
    p->ItemCount = 0;
    p->Width = 0;
    InitializeListHead(&p->ItemListHead);
    return(p);
}


BOOLEAN
SlGetMenuItemIndex(
    IN PSL_MENU Menu,
    IN PTCHAR Text,
    OUT PULONG Index
    )

/*++

Routine Description:

    Given the text of a menu item, returns the index of that item.

Arguments:

    Menu - Supplies the menu

    Text - Supplies the text to search for.

    Index - Returns the index of the text in the menu

Return Value:

    TRUE - Item was found.

    FALSE - Item was not found

--*/

{
    ULONG i;
    PSL_MENUITEM Item;

    //
    // Find first item to display
    //
    Item = CONTAINING_RECORD(Menu->ItemListHead.Flink,
                             SL_MENUITEM,
                             ListEntry);

    i=0;
    while ( Item != CONTAINING_RECORD(&Menu->ItemListHead,
                                      SL_MENUITEM,
                                      ListEntry)) {
        if (_tcsicmp(Item->Text,Text)==0) {
            *Index = i;
            return(TRUE);
        }

        Item = CONTAINING_RECORD(Item->ListEntry.Flink,
                                 SL_MENUITEM,
                                 ListEntry);
        ++i;

    }
    return(FALSE);
}


PVOID
SlGetMenuItem(
    IN PSL_MENU Menu,
    IN ULONG Item
    )

/*++

Routine Description:

    Given an item index, returns the data associated with that item.

Arguments:

    Menu - Supplies the menu structure.

    Item - Supplies the item index.

Return Value:

    The data associated with the given item.

--*/

{
    ULONG i;
    PSL_MENUITEM MenuItem;

    //
    // Find item to return
    //
    MenuItem = CONTAINING_RECORD(Menu->ItemListHead.Flink,
                                 SL_MENUITEM,
                                 ListEntry);

    for (i=0;i<Item;i++) {
        MenuItem = CONTAINING_RECORD(MenuItem->ListEntry.Flink,
                                     SL_MENUITEM,
                                     ListEntry);

#if DBG
        if (&MenuItem->ListEntry == &Menu->ItemListHead) {
            SlError(Item);
            return(NULL);
        }
#endif
    }
    return(MenuItem->Data);

}


ULONG
SlAddMenuItem(
    PSL_MENU Menu,
    PTCHAR Text,
    PVOID Data,
    ULONG Attributes
    )

/*++

Routine Description:

    Adds an item to the menu

Arguments:

    Menu - Supplies a pointer to the menu the item will be added to

    Text - Supplies the text to be displayed in the menu

    Data - Supplies a pointer to the data to be returned when the item
           is selected.

    Attributes - Supplies any attributes for the item.

Return Value:

    The Selection index if successful

    -1 on failure

--*/
{
    PSL_MENUITEM NewItem;
    ULONG Length;

    NewItem = BlAllocateHeap(sizeof(SL_MENUITEM));
    if (NewItem==NULL) {
        SlError(0);
        return((ULONG)-1);
    }
    InsertTailList(&Menu->ItemListHead, &NewItem->ListEntry);
    Menu->ItemCount += 1;

    NewItem->Text = Text;
    NewItem->Data = Data;
    NewItem->Attributes = Attributes;
    Length = _tcslen(Text);
    if (Length > Menu->Width) {
        Menu->Width = Length;
    }
    return(Menu->ItemCount - 1);
}


ULONG
SlDisplayMenu(
    IN ULONG HeaderId,
    IN PSL_MENU Menu,
    IN OUT PULONG Selection
    )

/*++

Routine Description:

    Displays a menu and allows the user to pick a selection

Arguments:

    HeaderId - Supplies the message ID of the prompt header
                to be displayed above the menu.

    Menu - Supplies a pointer to the menu to be displayed

    Selection - Supplies the index of the default item.
                Returns the index of the selected item.

Return Value:

    Key that terminated the menu display.

--*/
{
    LONG X, Y;
    ULONG Height;
    ULONG Width;
    ULONG TopItem;
    ULONG c;
    ULONG PreviousSelection;
    ULONG Sel;
    PTCHAR Header;
    ULONG HeaderLines;
    ULONG MaxHeaderLength;
    PTCHAR HeaderText[20];
    ULONG HeaderLength[20];
    ULONG MaxMenuHeight;
    ULONG i;
    ULONG Count;

    Header = BlFindMessage(HeaderId);

    SlpSizeMessage(Header,
                   &HeaderLines,
                   &MaxHeaderLength,
                   HeaderLength,
                   HeaderText);

    X = (ScreenWidth-MaxHeaderLength)/2;
    for (i=0;i<HeaderLines;i++) {
        SlPositionCursor(X,i+4);
        ArcWrite(ARC_CONSOLE_OUTPUT,HeaderText[i],HeaderLength[i]*sizeof(TCHAR),&Count);
    }

    if (MaxHeaderLength > ScreenWidth) {
        MaxHeaderLength = ScreenWidth;
    }

    Width = Menu->Width+4;
    if (Width > ScreenWidth) {
        Width=ScreenWidth;
    }

    MaxMenuHeight = ScreenHeight-(HeaderLines+13);

    Height = Menu->ItemCount+2;
    if (Height > MaxMenuHeight) {
        Height = MaxMenuHeight;
    }

    X = ((ScreenWidth - Width)/2 > 0) ? (ScreenWidth-Width)/2 : 0;
    Y = (MaxMenuHeight - Height)/2 + HeaderLines + 4;

    TopItem = 0;
    Sel = *Selection;
    //
    // Make sure default item is in view;
    //
    if (Sel >= Height - 2) {
        TopItem = Sel - Height + 3;
    }

    SlpDrawMenu(X,Y,
                TopItem,
                Height,
                Menu);

    //
    // highlight default selection
    //
    SlSetCurrentAttribute(INVATT);
    SlpDrawMenuItem(X,Y,
                TopItem,
                Height,
                Sel,
                Menu);
    SlSetCurrentAttribute(DEFATT);
    SlFlushConsoleBuffer();
    do {
        c = SlGetChar();
        PreviousSelection = Sel;
        SlpDrawMenuItem(X, Y,
                    TopItem,
                    Height,
                    Sel,
                    Menu);

        switch (c) {
            case SL_KEY_UP:
                if(Sel > 0) {
                    Sel--;
                }
                break;

            case SL_KEY_DOWN:
                if(Sel < Menu->ItemCount - 1) {
                    Sel++;
                }
                break;

            case SL_KEY_HOME:
                Sel = 0;
                break;

            case SL_KEY_END:
                Sel = Menu->ItemCount - 1;
                break;

            case SL_KEY_PAGEUP:
                if (Menu->ItemCount > Height) {
                    if (Sel > Height) {
                        Sel -= Height;
                    } else {
                        Sel = 0;
                    }
                }
                break;

            case SL_KEY_PAGEDOWN:
                if (Menu->ItemCount > Height) {
                    Sel += Height;
                    if (Sel >= Menu->ItemCount) {
                        Sel = Menu->ItemCount - 1;
                    }
                }
                break;

            case SL_KEY_F1:
            case SL_KEY_F3:
            case ASCI_CR:
            case ASCI_ESC:
                *Selection = Sel;
                return(c);

        }

        if (Sel < TopItem) {
            TopItem = Sel;
            SlpDrawMenu(X, Y,
                        TopItem,
                        Height,
                        Menu);
        } else if (Sel > TopItem+Height-3) {
            TopItem = Sel - Height + 3;
            SlpDrawMenu(X, Y,
                        TopItem,
                        Height,
                        Menu);
        }
        //
        // highlight default selection
        //
        SlSetCurrentAttribute(INVATT);
        SlpDrawMenuItem(X,Y,
                    TopItem,
                    Height,
                    Sel,
                    Menu);
        SlSetCurrentAttribute(DEFATT);


    } while ( TRUE );

}



VOID
SlpDrawMenu(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG TopItem,
    IN ULONG Height,
    IN PSL_MENU Menu
    )

/*++

Routine Description:

    Displays the menu on the screen

Arguments:

    X - Supplies X coordinate of upper-left corner of menu

    Y - Supplies Y coordinate of upper-left corner of menu

    TopItem - Supplies index of item at the top of the menu

    Height - Supplies the height of the menu

    Menu - Supplies the menu to be displayed

Return Value:

    None.

--*/

{
    ULONG i;
    PSL_MENUITEM Item;
    ULONG Count;
    TCHAR Output[80];
    ULONG Length;
    ULONG MenuWidth;

    MenuWidth = Menu->Width+4;
    Output[0]=GetGraphicsChar(GraphicsCharDoubleRightDoubleDown);
    for (i=1;i<MenuWidth-1;i++) {
        Output[i]=GetGraphicsChar(GraphicsCharDoubleHorizontal);
    }
    Output[MenuWidth-1]=GetGraphicsChar(GraphicsCharDoubleLeftDoubleDown);
    SlPositionCursor(X,Y);
    ArcWrite(ARC_CONSOLE_OUTPUT,Output,MenuWidth*sizeof(TCHAR),&Count);
    //
    // Find first item to display
    //
    Item = CONTAINING_RECORD(Menu->ItemListHead.Flink,
                             SL_MENUITEM,
                             ListEntry);

    for (i=0;i<TopItem;i++) {
        Item = CONTAINING_RECORD(Item->ListEntry.Flink,
                                 SL_MENUITEM,
                                 ListEntry);
    }

    //
    // Display items
    //
    Output[0]=
    Output[MenuWidth-1]=GetGraphicsChar(GraphicsCharDoubleVertical);
    for (i=Y+1;i<Y+Height-1;i++) {
#ifdef UNICODE
        for (Count = 0 ; Count < MenuWidth-2;Count++) {
            Output[1+Count] = TEXT(' ');
        }
#else
        RtlFillMemory(Output+1,(MenuWidth-2)*sizeof(TCHAR),' ');
#endif
        SlPositionCursor(X, i);

        if (&Item->ListEntry != &Menu->ItemListHead) {
            Length = _tcslen(Item->Text);
            RtlCopyMemory(Output+2,Item->Text,Length*sizeof(TCHAR));
            Item = CONTAINING_RECORD(Item->ListEntry.Flink,
                                     SL_MENUITEM,
                                     ListEntry);
        }
        ArcWrite(ARC_CONSOLE_OUTPUT,Output,MenuWidth*sizeof(TCHAR),&Count);
    }
    Output[0]=GetGraphicsChar(GraphicsCharDoubleRightDoubleUp);
    for (i=1;i<MenuWidth-1;i++) {
        Output[i]=GetGraphicsChar(GraphicsCharDoubleHorizontal);
    }
    Output[MenuWidth-1]=GetGraphicsChar(GraphicsCharDoubleLeftDoubleUp);
    SlPositionCursor(X,Y+Height-1);
    ArcWrite(ARC_CONSOLE_OUTPUT,Output,MenuWidth*sizeof(TCHAR),&Count);
}


VOID
SlpDrawMenuItem(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG TopItem,
    IN ULONG Height,
    IN ULONG Item,
    IN PSL_MENU Menu
    )

/*++

Routine Description:

    Redraws the given item

Arguments:

    X - Supplies X coordinate of upper-left corner of menu

    Y - Supplies Y coordinate of upper-left corner of menu

    TopItem - Supplies index of item at the top of the menu

    Height - Supplies the height of the menu

    Item - Supplies the index of the item to be redrawn

    Menu - Supplies the menu to be displayed

Return Value:

    None.

--*/

{
    ULONG i;
    PSL_MENUITEM MenuItem;
    ULONG Count;
    TCHAR Width[80];

    //
    // Find item to display
    //
    MenuItem = CONTAINING_RECORD(Menu->ItemListHead.Flink,
                                 SL_MENUITEM,
                                 ListEntry);

    for (i=0;i<Item;i++) {
        MenuItem = CONTAINING_RECORD(MenuItem->ListEntry.Flink,
                                     SL_MENUITEM,
                                     ListEntry);

#if DBG
        if (&MenuItem->ListEntry == &Menu->ItemListHead) {
            SlError(Item);
        }
#endif
    }

#ifdef UNICODE
        for (Count = 0 ; Count < Menu->Width;Count++) {
            Width[Count] = TEXT(' ');
        }
#else
        RtlFillMemory(Width,(Menu->Width)*sizeof(TCHAR),' ');
#endif


    
    RtlCopyMemory(
            Width,
            MenuItem->Text,
            _tcslen(MenuItem->Text)*sizeof(TCHAR) );
    SlPositionCursor(X+2, Y+(Item-TopItem)+1);
    ArcWrite(ARC_CONSOLE_OUTPUT,Width,Menu->Width*sizeof(TCHAR),&Count);
}



VOID
SlInitDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the screen and does some initialization of global variables based
    on the ARC display information.

Arguments:

    None

Return Value:

    None.

--*/

{
    PARC_DISPLAY_STATUS DisplayStatus;

#ifndef EFI
    //
    // Check to see if this version of the ARC firmware is revision 2 or above.
    //
    // If not, we default to 80x25
    //
    if ((SYSTEM_BLOCK->Version > 1) ||
        ((SYSTEM_BLOCK->Version == 1) && (SYSTEM_BLOCK->Revision >= 2))) {

        //
        // Additional checks are required on 1.2 firmware, since some
        // 1.2 firmware does not implement ArcGetDisplayStatus
        //
        if ((SYSTEM_BLOCK->FirmwareVectorLength > (ULONG)GetDisplayStatusRoutine*sizeof(PVOID)) &&
            (SYSTEM_BLOCK->FirmwareVector[GetDisplayStatusRoutine] != NULL)) {
            DisplayStatus = ArcGetDisplayStatus(ARC_CONSOLE_OUTPUT);

            ScreenWidth = DisplayStatus->CursorMaxXPosition;
            ScreenHeight = DisplayStatus->CursorMaxYPosition;
        }
    }

#ifdef ARCI386
    SlPrint(ASCI_CSI_OUT "2J"); // Clears Screen
    
    SlSetCurrentAttribute(DEFATT);
//
//  This is a patch to setup VGA colors in the text port.
//  Otherwise screen colors and attributes are not the same as a PC
//
    // Write all the attributes to the textport
    {
    int row;
    TCHAR    text[MAX_STATUS+1];
    ULONG   Count,Length;
    _stprintf(text,TEXT("                                                                                "));
    //           012345678901234567890123456789012345678901234567890123456789012345678901234567890
    //                     1         2         3         4         5         6         7         8      
    for (row=0;  row< 48; row++)    // compensate for the long textport 48 versus 24 (VGA)
        ArcWrite(ARC_CONSOLE_OUTPUT,text,strlen(&text[0]),&Count);
    }
    // Position cursor at Top Left of screen
    SlPositionCursor(0,0);
#endif

#endif
    
#ifdef EFI
    //
    // On EFI, we won't be redirecting because setupldr.efi is an
    // EFI application.  If that's the case, then we can't use
    // BlIsTerminalConnected().  Instead, we're going to look
    // at the values in the LoaderRedirectionInformation structure
    // to see if we're really redirecting.
    //
    if( LoaderRedirectionInformation.PortAddress != 0 ) {
#else
    if (BlIsTerminalConnected()) {
#endif        
        ScreenHeight = HEADLESS_SCREEN_HEIGHT;
    }


    SlSetCurrentAttribute(DEFATT);
    SlClearDisplay();
}


VOID
SlPrint(
    IN PTCHAR FormatString,
    ...
    )
{
    va_list arglist;
    TCHAR    text[MAX_STATUS+1];
    ULONG   Count,Length;
    ULONG   MaxWidth = ScreenWidth - 2;

    if (MaxWidth > MAX_STATUS) {
        MaxWidth = MAX_STATUS;
    }

    va_start(arglist,FormatString);
    Length = _vsntprintf(text,MaxWidth*sizeof(TCHAR),FormatString,arglist);
    text[MaxWidth] = TEXT('\0');

    ArcWrite(ARC_CONSOLE_OUTPUT,text,Length,&Count);
    va_end(arglist);
}


VOID
SlClearDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the entire display, including header, client area, and status line.

Arguments:

    None

Return Value:

    None.

--*/

{
#if 1    
    BlClearScreen();
#else

    SlPositionCursor(0,0);

#ifdef EFI
    BlEfiClearToEndOfDisplay();
#else
    ARC_DISPLAY_CLEAR_TO_EOD();
#endif    

    if (!ShowProgressBar) {
        SlWriteStatusText(TEXT(""));
    }

#endif
}

ARC_STATUS
SlClearClientArea(
    VOID
    )

/*++

Routine Description:

    Clears the client area of the screen.  Does not disturb the header or
    status areas.

Arguments:

    None.

Return Value:

    always ESUCCESS

--*/

{
    USHORT i;

    for(i=HEADER_HEIGHT; i<ScreenHeight-1; i++) {
        SlPositionCursor(0,i);
        SlClearToEol();
    }

    //
    // home cursor
    //

    SlPositionCursor(0,0);
    return(ESUCCESS);
}


ARC_STATUS
SlClearToEol(
    VOID
    )
{
#ifdef EFI
    
    BlEfiClearToEndOfLine();
#else
    ARC_DISPLAY_CLEAR_TO_EOL();
#endif
    return(ESUCCESS);
}


VOID
SlGetCursorPosition(
    OUT unsigned *x,
    OUT unsigned *y
    )
{
    *x = ScreenX;
    *y = ScreenY;
}


ARC_STATUS
SlPositionCursor(
    IN unsigned x,
    IN unsigned y
    )
{
    //
    // clip to screen
    //

    if(x>=ScreenWidth) {
        x = ScreenWidth-1;
    }

    if(y>=ScreenHeight) {
        y = ScreenHeight-1;
    }

    ScreenX = x;
    ScreenY = y;

#ifdef EFI
    BlEfiPositionCursor(x, y );
#else
    ARC_DISPLAY_POSITION_CURSOR(x, y);
#endif

    
    return(ESUCCESS);
}


ARC_STATUS
SlWriteString(
    IN _PTUCHAR s
    )
{
    _PTUCHAR p = s,q;
    BOOLEAN done = FALSE;
    ULONG len,count;

    do {
        q = p;
        while((*q != TEXT('\0')) && (*q != TEXT('\n'))) {
            q++;
        }
        if(*q == TEXT('\0')) {
            done = TRUE;
        } else {
            *q = TEXT('\0');
        }
        len = (ULONG)(q - p);

        ArcWrite(ARC_CONSOLE_OUTPUT,p,len*sizeof(TCHAR),&count);

        ScreenX += len;

        if(!done) {
            ArcWrite(ARC_CONSOLE_OUTPUT,TEXT("\r\n"),2*sizeof(TCHAR),&count);
            ScreenX = 0;
            ScreenY++;
            if(ScreenY == ScreenHeight) {
                ScreenY = ScreenHeight-1;
            }
            *q = TEXT('\n');
        }
        p = q + 1;
    } while(!done);

    return(ESUCCESS);
}


VOID
SlSetCurrentAttribute(
    IN UCHAR Attribute
    )
{
    CurAttribute = Attribute;
#ifdef EFI
    BlEfiSetAttribute( CurAttribute );
#else

    SlPrint(ASCI_CSI_OUT);

    if (BlIsTerminalConnected() && 
        ((Attribute == DEFSTATTR) ||
         (Attribute == INVATT))) {
        SlPrint(TEXT("7"));
    } else {
        SlPrint(TEXT("0"));
    }

    SlPrint(TEXT(";%u;%um"), (Attribute &  0x7) + 30, ((Attribute >> 4) & 7) + 40);

    if(Attribute & ATT_FG_INTENSE) {
        SlPrint(ASCI_CSI_OUT TEXT("1m"));
    }
#endif
}


VOID
SlWriteHeaderText(
    IN ULONG MsgId
    )

/*++

Routine Description:

    Updates the header on the screen with a given string

Arguments:

    MsgId - Supplies the message ID of the new string to be displayed.  This should
            be just one line long.  If it is 0, the header is cleared.

Return Value:

    None.

--*/
{
    int i;

    for(i=HEADER_HEIGHT-1; i>=0; i--) {
        SlPositionCursor(0,i);
        SlClearToEol();
    }

    if (MsgId != 0) {
        SlWriteString(BlFindMessage(MsgId));
    }
}

//
// Stores the current status text.  The size is the screen width, plus the
// terminating nul char.
//
TCHAR StatusText[MAX_STATUS];

UCHAR StatusAttribute = DEFSTATTR;

VOID
SlSetStatusAttribute(
    IN UCHAR Attribute
    )
{
    StatusAttribute = Attribute;
}


BOOLEAN
SlGetStatusBarStatus(
    VOID
    )
/*++

Routine Description:

    Determines if status bar is enabled or not
    
Arguments:

    None.

Return Value:

    TRUE or FALSE
--*/    
{
    return StatusBarEnabled;
}

VOID
SlEnableStatusBar(
    IN  BOOLEAN Enable
    )
/*++

Routine Description:

    Enables or disables the status bar
    
Arguments:

    Enabled - Enable/Disable = TRUE/FALSE

Return Value:

    None.

--*/    
{
    StatusBarEnabled = Enable;
}

VOID
SlWriteStatusText(
    IN PTCHAR Text
    )

/*++

Routine Description:

    Updates the status area on the screen with a given string

Arguments:

    Text - Supplies the new text for the status area.

Return Value:

    None.

--*/
{
    UCHAR AttributeSave = CurAttribute;
    PTCHAR p;
    ULONG Count;
#ifdef EFI
    ULONG MaxWidth = ScreenWidth - 3;
#else
    ULONG MaxWidth = ScreenWidth - 2;
#endif

    //
    // Nop, if status bar is disabled
    //
    if (!StatusBarEnabled) {
        return;
    }

    //
    // if we're writing to a terminal, we don't want to write into the lower
    // right corner as this would make us scroll.
    //
    if (BlTerminalConnected) {
        MaxWidth -= 1;
    }

    if (MaxWidth > MAX_STATUS) {
        MaxWidth = MAX_STATUS;
    }

#ifdef UNICODE
    for (Count = 0 ; Count < sizeof(StatusText)/sizeof(TCHAR);Count++) {
        StatusText[Count] = TEXT(' ');
    }
#else
    RtlFillMemory(StatusText,sizeof(StatusText),' ');
#endif

    //
    // Strip cr/lf as we copy the status text into the status text buffer.
    //
    p = StatusText;
    Count = 0;
    while((Count < MaxWidth) && *Text) {
        if((*Text != TEXT('\r')) && (*Text != TEXT('\n'))) {
            *p++ = *Text;
            Count++;
        }
        Text++;
    }

    SlSetCurrentAttribute(StatusAttribute);
    SlPositionCursor(0,ScreenHeight-1);
    ArcWrite(ARC_CONSOLE_OUTPUT,TEXT("  "),2*sizeof(TCHAR),&Count);
    SlPositionCursor(2,ScreenHeight-1);
    ArcWrite(ARC_CONSOLE_OUTPUT,StatusText,MaxWidth*sizeof(TCHAR),&Count);
    SlSetCurrentAttribute(AttributeSave);
    SlPositionCursor(0,5);
}


VOID
SlGetStatusText(
    OUT PTCHAR Text
    )
{
    _tcscpy(Text,StatusText);
}



#if DBG
VOID
SlWriteDbgText(
    IN PTCHAR text
    )
{
    UCHAR SavedAttribute = CurAttribute;

    SlPositionCursor(0,0);
    CurAttribute = ATT_FG_YELLOW | ATT_BG_RED | ATT_FG_INTENSE;

    SlClearToEol();
    SlWriteString(text);

    CurAttribute = SavedAttribute;
}
#endif


VOID
SlFlushConsoleBuffer(
    VOID
    )

/*++

Routine Description:

    This routine flushes the console buffer, so that we don't have any
    pre-existing keypresses in the buffer when we prompt the user to
    'press any key to continue.'

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    UCHAR c;
    ULONG count;

    while(ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
        ArcRead(ARC_CONSOLE_INPUT, &c, 1, &count);
    }
}


ULONG
SlGetChar(
    VOID
    )
{
    UCHAR c;
    ULONG count;

    ArcRead(ARC_CONSOLE_INPUT,&c,1,&count);

    if(c == ASCI_CSI_IN) {
        if (ArcGetReadStatus(ARC_CONSOLE_INPUT) != ESUCCESS) {
            //
            // Just a single escape - return it
            //
            return (ASCI_ESC);
        }

        ArcRead(ARC_CONSOLE_INPUT,&c,1,&count);

        switch(c) {

        //
        // see ntos\fw\mips\fwsignal.c!TranslateScanCode() for these codes.
        // Additional codes that might be useful someday:
        // left=C, right=D, insert=@, delete=P
        //

        case 'A':                   // up arrow
            return(SL_KEY_UP);

        case 'B':                   // down arrow
            return(SL_KEY_DOWN);

        case 'H':                   // home
            return(SL_KEY_HOME);

        case 'K':                   // end
            return(SL_KEY_END);

        case '?':                   // page up
            return(SL_KEY_PAGEUP);

        case '/':                   // page down
            return(SL_KEY_PAGEDOWN);

        case 'O':                   // function keys

            ArcRead(ARC_CONSOLE_INPUT,&c,1,&count);

            //
            // F1=P, F2=Q, F3=w, F4 =x, F5 =t, F6 =u
            // F7=q, F8=r, F9=p, F10=m, F11=A, F12=B
            //
            // Note: as of 12/15/92, f11 and f12 were commented out in the
            // firmware sources so are probably never returned.
            //

            switch(c) {

            case 'P':
                return(SL_KEY_F1);

            case 'Q':
                return(SL_KEY_F2);

            case 'w':
                return(SL_KEY_F3);

            case 't':
                return(SL_KEY_F5);

            case 'u':
                return(SL_KEY_F6);

            case 'q':
                return(SL_KEY_F7);

            case 'm':
            case 'M':
                return  SL_KEY_F10;

            case 'A':
                return(SL_KEY_F11);

            case 'B':
                return(SL_KEY_F12);

            default:
                return(0);
            }

        default:
            return(0);
        }

    } else {
        if(c == ASCI_LF) {
            c = ASCI_CR;
        }
        return((ULONG)c);
    }
}


BOOLEAN
SlPromptForDisk(
    IN PTCHAR  DiskName,
    IN BOOLEAN IsCancellable
    )

/*++

Routine Description:

    This routine prompts a user to insert a given diskette #, or to abort the
    Setup process.

    The status line will be erased.

Arguments:

    DiskName - Supplies the name of the disk to be inserted.

    IsCancellable - Supplies flag indicating whether prompt may be cancelled.

Return Value:

    TRUE - The user has pressed OK

    FALSE - The user has pressed CANCEL

--*/

{
    ULONG msg;
    ULONG y;
    ULONG Key;
    PTCHAR StatusText;
    PTCHAR PleaseWait;
    ULONG i;
    TCHAR  DiskNameDisplayed[81];
    BOOLEAN Repaint=TRUE;

    SlWriteStatusText(TEXT(""));

    if(IsCancellable) {
        msg = SL_NEXT_DISK_PROMPT_CANCELLABLE;
    } else {
        msg = SL_NEXT_DISK_PROMPT;
    }
    StatusText = BlFindMessage(msg);
    if(StatusText == NULL) {
        SlError(msg);
        return(FALSE);
    }

    PleaseWait = BlFindMessage(SL_PLEASE_WAIT);
    if(PleaseWait == NULL) {
        SlError(SL_PLEASE_WAIT);
        return(FALSE);
    }

    //
    // Get first line of DiskName and save it in DiskNameDisplayed (limit to 80 chars)
    //
    for(i = 0;
        ((i < 80) && DiskName[i] && (DiskName[i] != TEXT('\r')) && (DiskName[i] != TEXT('\n')));
        i++)
    {
        DiskNameDisplayed[i] = DiskName[i];
    }
    DiskNameDisplayed[i] = TEXT('\0');

    do {
        if (Repaint) {
            SlClearClientArea();
            y = SlDisplayMessageBox(SL_MSG_INSERT_DISK);
            SlPositionCursor((ScreenWidth-i)/2,y+2);
            SlWriteString(DiskNameDisplayed);
            SlWriteStatusText(StatusText);
        }
        Repaint = FALSE;
        SlFlushConsoleBuffer();
        Key = SlGetChar();

        if (Key == ASCI_CR) {
            SlClearClientArea();
            SlWriteStatusText(PleaseWait);
            return(TRUE);
        } else if (Key == SL_KEY_F3) {
            SlConfirmExit();
            Repaint=TRUE;
        } else if((Key == ASCI_ESC) && IsCancellable) {
            SlWriteStatusText(TEXT(""));
            SlClearClientArea();
            return FALSE;
        }
    } while ( TRUE );
}


VOID
SlConfirmExit(
    VOID
    )

/*++

Routine Description:

    Routine to be called when user presses F3.  Confirms that he really wants
    to exit by popping up a dialog.  DOES NOT RETURN if user chooses to exit.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG c;

    //
    // if we use too much stack space the heap and stack can overlap and we can run into corruption problems
    // without any "stack overflow" exceptions; making large strings static helps prevent this
    //
    static TCHAR OldStatus[MAX_STATUS];
    PTCHAR StatusText;

    SlGetStatusText(OldStatus);

    SlClearClientArea();

    SlSetCurrentAttribute(DEFDLGATT);

    SlDisplayMessageBox(SL_MSG_EXIT_DIALOG);

    SlSetCurrentAttribute(DEFATT);

    SlFlushConsoleBuffer();

    while(1) {
        c = SlGetChar();
        if(c == ASCI_CR) {
            SlWriteStatusText(OldStatus);
            return;
        }
        if(c == SL_KEY_F3) {
            StatusText = BlFindMessage(SL_REBOOT_PROMPT);
            SlClearClientArea();
#ifdef i386
            SlDisplayMessageBox(SL_SCRN_TEXTSETUP_EXITED);
#else
            SlDisplayMessageBox(SL_SCRN_TEXTSETUP_EXITED_ARC);
#endif
            SlWriteStatusText(StatusText);

            SlFlushConsoleBuffer();
            while(SlGetChar() != ASCI_CR);
            ArcRestart();
        }
    }
}



VOID
SlFriendlyError(
    IN ULONG uStatus,
    IN PCHAR pchBadFile,
    IN ULONG uLine,
    IN PCHAR pchCodeFile
    )

/*++

Routine Description:

    This is called when an error occurs.  It puts up a
    message box, displays an informative message, and allows
    the user to continue.  It is intended to give friendlier
    messages than the SlError macro, in the cases where SlError
    gets passed ARC error codes.

    The status text line will be erased.

Arguments:

    uStatus     - ARC error code

    pchBadFile  - Name of file causing error (Must be given for handled
                  ARC codes.  Optional for unhandled codes.)

    uLine       - Line # in source code file where error occurred (only
                  used for unhandled codes.)

    pchCodeFile - Name of souce code file where error occurred (only
                  used for unhandled codes.)

Return Value:

    None.

--*/

{
    ULONG uMsg;
    PTSTR pBadFile;
    PTSTR pCodeFile;
#ifdef UNICODE
    WCHAR BadFileW[64];
    WCHAR CodeFileW[200];
    ANSI_STRING aString;
    UNICODE_STRING uString;

    RtlInitString( &aString, pchBadFile );
    uString.Buffer = BadFileW;
    uString.MaximumLength = sizeof(BadFileW);
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );

    RtlInitString( &aString, pchCodeFile );
    uString.Buffer = CodeFileW;
    uString.MaximumLength = sizeof(CodeFileW);
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );

    if (pchBadFile) {
        pBadFile = BadFileW;
    } else {
        pBadFile = NULL;
    }

    pCodeFile = CodeFileW;

#else
    pBadFile = pchBadFile;
    pCodeFile = pchCodeFile;
#endif

    SlClearClientArea();    
    switch(uStatus) {
       case EBADF:
       case EINVAL:  // image corrupt
          uMsg = SL_WARNING_IMG_CORRUPT;
          break;

       case EIO:     // i/o error
          uMsg = SL_WARNING_IOERR;
          break;

       case ENOENT:  // file not found
          uMsg = SL_WARNING_NOFILE;
          break;

       case ENOMEM:  // insufficient memory
          uMsg = SL_WARNING_NOMEM;
          break;

       case EACCES: // unrecognized file system
           uMsg = SL_WARNING_BAD_FILESYS;
           break;

       default:      // then get SlError() behavior (with optional bad file name)
          if(pBadFile) {  // include error-causing file's name
              SlMessageBox(
                  SL_WARNING_ERROR_WFILE,
                  pBadFile,
                  uStatus,
                  uLine,
                  pCodeFile
                  );
          } else {
              SlMessageBox(
                  SL_WARNING_ERROR,
                  uStatus,
                  uLine,
                  pCodeFile
                  );
          }
          return;
    }
    SlMessageBox(
        uMsg,
        pBadFile
        );
}

VOID
SlMessageBox(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    This is called when an error occurs.  It puts up a
    message box, displays an informative message, and allows
    the user to continue.

    The status text line will be erased.

Arguments:

    MessageId - Supplies ID of message box to be presented.

    any sprintf-compatible arguments to be inserted in the
    message box.

Return Value:

    None.

--*/

{
    va_list args;

    SlClearClientArea();
    va_start(args, MessageId);
    SlGenericMessageBox(MessageId, &args, NULL, NULL, NULL, NULL, TRUE);
    va_end(args);
    
    SlFlushConsoleBuffer();
    SlGetChar();
}


ULONG
SlDisplayMessageBox(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    Just puts a message box up on the screen and returns.

    The status text line will be erased.

Arguments:

    MessageId - Supplies ID of message box to be presented.

    any sprintf-compatible arguments to be inserted in the
    message box.

Return Value:

    Y position of top line of message box

--*/

{
    ULONG y;
    va_list args;

    va_start(args, MessageId);
    SlGenericMessageBox(MessageId, &args, NULL, NULL, &y, NULL, TRUE);
    va_end(args);

    return(y);
}


VOID
SlFatalError(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    This is called when a fatal error occurs.  It clears the client
    area, puts up a message box, displays the fatal error message, and
    allows the user to press a key to reboot.

    The status text line will be erased.

Arguments:

    MessageId - Supplies ID of message box to be presented.

    any sprintf-compatible arguments to be inserted in the
    message box.

Return Value:

    Does not return.

--*/

{
    va_list args;
    ULONG x,y;
    PTCHAR Text;

    SlClearClientArea();

    Text = BlFindMessage(MessageId);
    if(Text) {

        va_start(args, MessageId);

        _vsntprintf(MessageBuffer, sizeof(MessageBuffer), Text, args);

        //
        // Add a blank line, then concatenate the 'Can't continue' text.
        //
        _tcscat(MessageBuffer, TEXT("\r\n"));

        Text = BlFindMessage(SL_CANT_CONTINUE);
        if(Text) {
            _tcscat(MessageBuffer, Text);
        }

        Text = BlAllocateHeap((_tcslen(MessageBuffer)+1) * sizeof(TCHAR));
        _tcscpy(Text, MessageBuffer);

        //
        // Note that MessageId and args won't be used, since we're
        // passing in our Text pointer.
        //
        SlGenericMessageBox(MessageId, &args, Text, &x, NULL, &y, TRUE);

        va_end(args);

    } else {
        SlError(MessageId);
    }

    SlFlushConsoleBuffer();

    SlGetChar();

    ArcRestart();
    
}


VOID
SlGenericMessageBox(
    IN     ULONG   MessageId, OPTIONAL
    IN     va_list *args,     OPTIONAL
    IN     PTCHAR   Message,  OPTIONAL
    IN OUT PULONG  xLeft,     OPTIONAL
    IN OUT PULONG  yTop,      OPTIONAL
    OUT    PULONG  yBottom,   OPTIONAL
    IN     BOOLEAN bCenterMsg
    )

/*++

Routine Description:

    Formats and displays a message box.  The longest line in the string
    of characters will be centered on the screen if bCenterMsg is TRUE.

    The status text line will be erased.

Arguments:

    NOTE:  Either the MessageId/args pair or the Message string must be
           specified. Message string will be used if non-NULL.

    MessageId - Supplies the MessageId that will be looked up to provide
                a NULL-terminated string of characters.
                Each \r\n delimited string will be displayed on its own line.

    args - Supplies the argument list that will be passed to vsprintf.

    Message - Supplies the actual text of the message to be displayed

    xLeft - If bCenterMsg is FALSE, then xLeft is used for the starting x
            coordinate of the message (if specified, otherwise, x = 1).
            Also, if specified, it receives the x coordinate of the left edge
            of all lines that were displayed.

    yTop -  If bCenterMsg is FALSE, then yTop is used for the starting y
            coordinate of the message (if specified, otherwise, y = 3).
            Also, if specified, receives the y coordinate of the top line where
            the message box was displayed.

    yBottom - if specified, receives the y coordinate of the bottom line of
              the message box.

    bCenterMsg - if TRUE, center message on the screen.

Return Value:

    None.

--*/

{
    PTCHAR p;
    ULONG NumLines;
    ULONG MaxLength;
    ULONG x;
    ULONG y;
    ULONG i;
    PTCHAR Line[20];
    ULONG LineLength[20];
    ULONG Count;

    if(!Message) {    // then look up the message
        p=BlFindMessage(MessageId);
        if (p==NULL) {
            SlError(MessageId);
            x=3;
            y=ScreenHeight/2;
            NumLines=0;
        } else {
            _vsntprintf(MessageBuffer,sizeof(MessageBuffer),p,*args);
            Message = MessageBuffer;
        }
    } else {
        //
        // Just make p non-NULL, so we'll know it's OK to continue.
        //
        p = Message;
    }

    if(p) {

        SlWriteStatusText(TEXT(""));  // Clear status bar

        SlpSizeMessage(Message,
                       &NumLines,
                       &MaxLength,
                       LineLength,
                       Line);

        if (MaxLength > ScreenWidth) {
            MaxLength = ScreenWidth;
        }

        if(bCenterMsg) {
            x = (ScreenWidth-MaxLength)/2;
            y = (ScreenHeight-NumLines)/2;
        } else {
            if(xLeft) {
                x = *xLeft;
            } else {
                x = 1;
            }

            if(yTop) {
                y = *yTop;
            } else {
                y = 3;
            }
        }
    }

    for (i=0; i<NumLines; i++) {
        SlPositionCursor(x, y+i);
        ArcWrite(ARC_CONSOLE_OUTPUT,Line[i],LineLength[i]*sizeof(TCHAR),&Count);
    }

    if(xLeft) {
        *xLeft = x;
    }

    if(yTop) {
        *yTop = y;
    }

    if(yBottom) {
        *yBottom = NumLines ? y+NumLines-1 : 0;
    }
}


VOID
SlpSizeMessage(
    IN  PTCHAR Message,
    OUT PULONG Lines,
    OUT PULONG MaxLength,
    OUT ULONG LineLength[],
    OUT PTCHAR LineText[]
    )

/*++

Routine Description:

    This routine walks down a message and determines the number of
    lines and the maximum line length.

Arguments:

    Message - Supplies a pointer to a null-terminated message

    Lines - Returns the number of lines

    MaxLength - Returns the length of the longest line.

    LineLength - Supplies a pointer to an array of ULONGs
                 Returns a filled in array containing the
                 length of each line.

    LineText - Supplies a pointer to an array of PCHARs
               Returns a filled in array containing a
               pointer to the start of each line.

Return Value:

    None.

--*/

{
    PTCHAR p;
    ULONG NumLines;
    ULONG Length;

    p = Message;
    NumLines = 0;
    *MaxLength = 0;
    Length = 0;

    //
    // walk through the string, determining the number of lines
    // and the length of the longest line.
    //
    LineText[0]=p;
    while (*p != TEXT('\0')) {
        if ((*p == TEXT('\r')) && (*(p+1) == TEXT('\n'))) {
            //
            // End of a line.
            //

            if (Length > *MaxLength) {
                *MaxLength = Length;
            }
            LineLength[NumLines] = Length;
            ++NumLines;
            Length = 0;
            p += 2;
            LineText[NumLines] = p;

        } else {
            ++Length;
            ++p;

            if (*p == TEXT('\0')) {

                //
                // End of the message.
                //

                if (Length > *MaxLength) {
                    *MaxLength = Length;
                }
                LineLength[NumLines] = Length;
                ++NumLines;
            }
        }
    }

    *Lines = NumLines;

}

VOID
SlNoMemError(
    IN ULONG Line,
    IN PCHAR File
    )

/*++

Routine Description:

    Stub error routine for linking with boot\lib\parseini.c.  Just passes arguments thru.

Arguments:

    Line - Line number within the file the error occurred on.

    File - File name where the error occurred.

Return Value:

    None.

--*/
{
     SlFatalError(SL_NO_MEMORY, Line, SlCopyStringAT(File));
}

VOID
SlBadInfLineError(
    IN ULONG Line,
    IN PCHAR INFFile
    )

/*++

Routine Description:

    Stub error routine for linking with boot\lib\parseini.c.  Just passes arguments thru.

Arguments:

    Line - Line number within the inf file the error occurred on.
    
    INFFile - Supplies a pointer to the INF filename.

Return Value:

    None.

--*/
{
    SlFatalError(SL_BAD_INF_LINE, Line, SlCopyStringAT(INFFile));
}

VOID
SlErrorBox(
    IN ULONG MessageId,
    IN ULONG Line,
    IN PCHAR File
    )

/*++

Routine Description:

    Stub error routine for linking with boot\lib\parseini.c.  Just passes arguments thru.

Arguments:

    MessageId - Id of the message to display.

    Line - Line number within the file the error occurred on.

    File - File name where the error occurred.

Return Value:

    None.

--*/
{
    PTSTR pFile;
#ifdef UNICODE    
    WCHAR FileW[200];
    ANSI_STRING aString;
    UNICODE_STRING uString;

    RtlInitString( &aString, File );
    uString.Buffer = FileW;
    uString.MaximumLength = sizeof(FileW);
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
    
    pFile = FileW;

#else
    pFile = File;    
#endif


     SlMessageBox(SL_WARNING_ERROR, MessageId, Line, pFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\br\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\chs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\decomp.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    decomp.c

Abstract:

    Routines to handle reading of files compressed into single-file
    cabinet format.

Author:

    Ted Miller (tedm) 16 May 1997

Revision History:

--*/


#include "..\lib\bootlib.h"
#include "diamondd.h"
#include <stdio.h>
#include <fcntl.h>
#include <basetsd.h>
#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#if 0
#define TmErrOut(x) DbgPrint x
#define TmDbgOut(x) DbgPrint x
#define TmDbgPause() DbgBreakPoint()
#else
#define TmErrOut(x)
#define TmDbgOut(x)
#define TmDbgPause()
#endif

BOOLEAN Decompress;

//
// Global variable that points to a buffer used for decompressing the file
// being opened. After that, reads are satisfied from this buffer. The buffer
// holds exactly one file at a time. We rely on the ordering of stuff in the loader
// to ensure that only one file that needs to be decompressed is open at a time!
//
ULONG_PTR DecompressBufferBasePage;
PVOID DecompressBuffer;
ULONG DecompressBufferSize;
BOOLEAN DecompressBufferInUse;
ULONG SizeOfFileInDecompressBuffer;
ULONG DecompExpectedSize;
HFDI FdiContext;
ERF DecompErf;

//
// The diamond stuff allocates and frees blocks of memory
// for each file. There's no memory allocator in the boot loader that allows
// for memory frees. So we have to fake it.
//
PVOID DecompressHeap;
ULONG_PTR DecompressHeapPage;
#define DECOMP_HEAP_SIZE  ((128+2048)*1024)     // 128K work + 2MB window

typedef struct _DECOMP_HEAP_BLOCK {
    struct _DECOMP_HEAP_BLOCK *Next;
    ULONG BlockSize;
    BOOL Free;
} DECOMP_HEAP_BLOCK, *PDECOMP_HEAP_BLOCK;

VOID
ReinitializeDiamondMiniHeap(
    VOID
    );

//
// Bogus global variable used to track the device id for the device that
// the file we are currently decompressing lives on.
//
ULONG DecompDeviceId;
ARC_STATUS DecompLastIoError;

//
// This is the value we return to diamond when it asks us to create
// the target file.
//
#define DECOMP_MAGIC_HANDLE 0x87654

//
// Misc forward references.
//
ARC_STATUS
DecompAllocateDecompressBuffer (
    IN ULONG BufferSize
    );

VOID
DecompFreeDecompressBuffer (
    VOID
    );

ARC_STATUS
DecompClose(
    IN ULONG FileId
    );

ARC_STATUS
DecompRead(
    IN  ULONG  FileId,
    OUT VOID  * FIRMWARE_PTR Buffer,
    IN  ULONG  Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    );

ARC_STATUS
DecompSeek(
    IN ULONG          FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE      SeekMode
    );

ARC_STATUS
DecompGetFileInfo(
    IN  ULONG             FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR FileInfo
    );

PVOID
DIAMONDAPI
DiamondAlloc(
    IN ULONG Size
    );

VOID
DIAMONDAPI
DiamondFree(
    IN PVOID Block
    );

INT_PTR
DIAMONDAPI
DiamondOpen(
    IN LPSTR FileName,
    IN int   oflag,
    IN int   pmode
    );

UINT
DIAMONDAPI
DiamondRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    );

UINT
DIAMONDAPI
DiamondWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    );

int
DIAMONDAPI
DiamondClose(
    IN INT_PTR Handle
    );

long
DIAMONDAPI
DiamondSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    );

INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    );

//
// Device dispatch table for our pseudo-filesystem.
//
BL_DEVICE_ENTRY_TABLE DecompDeviceEntryTable = {    DecompClose,            // close
                                                    NULL,                   // mount
                                                    NULL,                   // open
                                                    DecompRead,             // read
                                                    NULL,                   // read status
                                                    DecompSeek,             // seek
                                                    NULL,                   // write
                                                    DecompGetFileInfo,      // get file info
                                                    NULL,                   // set file info
                                                    NULL,                   // rename
                                                    NULL,                   // get dirent
                                                    NULL                    // PBOOTFS_INFO, unused
                                               };


VOID
DecompEnableDecompression(
    IN BOOLEAN Enable
    )
{
#if defined(_X86_) || defined(_IA64_)
    //
    // Disable on alpha, since it doesn't seem to work.
    //
    Decompress = Enable;
#endif
}


BOOLEAN
DecompGenerateCompressedName(
    IN  LPCSTR Filename,
    OUT LPSTR  CompressedName
    )

/*++

Routine Description:

    This routine generates the "compressed-form" name of a file.
    The compressed form substitutes the last character of the extension
    with a _. If there is no extension then ._ is appended to the name.
    Only the final component is relevent; others are preserved in the
    compressed form name.

Arguments:

    Filename - supplies full pathname of file whose compressed form name
        is desired.

    CompressedName - receives compressed form of the full path. The caller must
        ensure that the buffer is large enough.

Return Value:

    TRUE - the caller should try to locate the compressed filename first.
    FALSE - the caller should not attempt to locate the compressed filename
        at all.

    This value depends on the state of the Decompress global.

--*/

{
    PCHAR p,q;

    if(!Decompress) {
        return(FALSE);
    }

    strcpy(CompressedName,Filename);
    p = strrchr(CompressedName,'.');
    q = strrchr(CompressedName,'\\');
    if(q < p) {
        //
        // If there are 0, 1, or 2 characters after the dot, just append
        // the underscore. p points to the dot so include that in the length.
        //
        if(strlen(p) < 4) {
            strcat(CompressedName,"_");
        } else {
            //
            // Assume there are 3 characters in the extension and replace
            // the final one with an underscore.
            //
            p[3] = '_';
        }
    } else {
        //
        // No dot, just add ._.
        //
        strcat(CompressedName,"._");
   }

    return(TRUE);
}

DECOMP_STRUCTURE_CONTEXT DecompStructureContext = {0};

ULONG
DecompPrepareToReadCompressedFile(
    IN LPCSTR Filename,
    IN ULONG  FileId
    )
{
    ULONG Status;
    BOOL b;
    int err;
    ULONGLONG x;
    FDICABINETINFO CabinetInfo;
    ULONG OldUsableBase, OldUsableLimit;

    //
    // On both x86 and alpha the allocation of our large decompress buffer
    // has an unfortunate tendency to place the block right where the
    // (non-relocatable) kernel wants to go. By allocating from the top
    // of memory we make this problem go away.
    //

    if(!Decompress) {
        return((ULONG)(-1));
    }

    //
    // If we're in the middle of FDICopy or FDIIsCabinet then
    // we don't want to do our special processing. Special return code
    // of -1 tells the caller that we didn't process it.
    //
    if(FdiContext) {
        return((ULONG)(-1));
    }

    //
    // If there's no decompression heap yet, allocate one.
    //
    if(!DecompressHeap) {

        //
        // Set allocatable range to the decompression-specific range
        //
        OldUsableBase = BlUsableBase;
        OldUsableLimit = BlUsableLimit;
        BlUsableBase  = BL_DECOMPRESS_RANGE_LOW;
        BlUsableLimit = BL_DECOMPRESS_RANGE_HIGH;

        Status = BlAllocateDescriptor(
                    LoaderOsloaderHeap,
                    0,
                    ROUND_TO_PAGES(DECOMP_HEAP_SIZE) >> PAGE_SHIFT,
                    (PULONG)&DecompressHeapPage
                    );

        //
        // Restore the previous alloc range.
        //
        BlUsableBase = OldUsableBase;
        BlUsableLimit = OldUsableLimit;

        if(Status != ESUCCESS) {
            TmErrOut(("Setup: couldn't allocate decompression heap (%u)\r\n",Status));
            DecompressHeap = NULL;
            return(Status);
        }

        DecompressHeap = (PVOID)(KSEG0_BASE | (DecompressHeapPage << PAGE_SHIFT));
    }

    //
    // We reinitialize diamond each time because of the way we deal with
    // the heap for alloc and free requests from diamond -- doing this
    // allows us to wipe our heap clean for each file.
    //
    ReinitializeDiamondMiniHeap();

    FdiContext = FDICreate(
                    DiamondAlloc,
                    DiamondFree,
                    DiamondOpen,
                    DiamondRead,
                    DiamondWrite,
                    DiamondClose,
                    DiamondSeek,
                    0,                  // cpu type flag is ignored
                    &DecompErf
                    );

    if(!FdiContext) {
        TmErrOut(("Setup: FDICreate failed\r\n"));
        return(ENOMEM);
    }

    //
    // Check if file is a cabinet and reset file pointer.
    //
    b = FDIIsCabinet(FdiContext,FileId,&CabinetInfo);

    x = 0;
    BlSeek(FileId,(PLARGE_INTEGER)&x,SeekAbsolute);

    if(!b) {
        //
        // Not a cabinet, we're done. Bail with return code of -1
        // which tells the caller that everything's OK.
        //
        TmDbgOut(("Setup: file %s is not a cabinet\r\n",Filename));
        FDIDestroy(FdiContext);
        FdiContext = NULL;
        return((ULONG)(-1));
    }

    TmDbgOut(("Setup: file %s is compressed, prearing it for read\r\n",Filename));

    DecompDeviceId = BlFileTable[FileId].DeviceId;
    DecompLastIoError = ESUCCESS;

    b = FDICopy(
            FdiContext,
            "",                         // filename part only
            (LPSTR)Filename,            // full path
            0,                          // no flags relevent
            DiamondNotifyFunction,      // routine to process control messages
            NULL,                       // no decryption
            NULL                        // no user-specified data
            );

    err = DecompErf.erfOper;

    FDIDestroy(FdiContext);
    FdiContext = NULL;

    if(b) {
        //
        // Everything worked.
        //
        // Get file information from the original file system so we can
        // return it later if someone wants it.
        //
        // Close the original file and switch context
        // structures so that read, seek, close, etc. requests come to us
        // instead of the original filesystem.
        //
        if(SizeOfFileInDecompressBuffer != DecompExpectedSize) {
            TmErrOut(("Setup: warning: expected size %lx, actual size = %lx\r\n",DecompExpectedSize,SizeOfFileInDecompressBuffer));
        }

        Status = BlGetFileInformation(FileId,&DecompStructureContext.FileInfo);
        if(Status != ESUCCESS) {
            TmErrOut(("DecompPrepareToReadCompressedFile: BlGetFileInfo returned %u\r\n",Status));
            DecompFreeDecompressBuffer();
            return(Status);
        }
        DecompStructureContext.FileInfo.EndingAddress.LowPart = SizeOfFileInDecompressBuffer;
        DecompStructureContext.FileInfo.EndingAddress.HighPart = 0;

        //
        // We don't handle files whose size doesn't fit in a DWORD.
        //
        if(DecompStructureContext.FileInfo.EndingAddress.HighPart) {
            TmErrOut(("DecompPrepareToReadCompressedFile: file too big\r\n"));
            DecompFreeDecompressBuffer();
            return(E2BIG);
        }

        BlClose(FileId);

        BlFileTable[FileId].Flags.Open = 1;
        BlFileTable[FileId].Position.QuadPart = 0;
        BlFileTable[FileId].DeviceEntryTable = &DecompDeviceEntryTable;

#ifdef CACHE_DEVINFO
        BlFileTable[FileId].StructureContext = &DecompStructureContext;
#else
        RtlCopyMemory(
            BlFileTable[FileId].StructureContext,
            &DecompStructureContext,
            sizeof(DECOMP_STRUCTURE_CONTEXT)
            );
#endif

        return(ESUCCESS);

    } else {
        //
        // Failure.
        //
        TmErrOut(("Setupldr: FDICopy failed (FDIERROR = %u, last io err = %u)\r\n",err,DecompLastIoError));
        TmDbgPause();
        return(EINVAL);
    }
}


ARC_STATUS
DecompAllocateDecompressBuffer (
    IN ULONG BufferSize
    )
{
    ARC_STATUS Status;
    ULONG OldUsableBase, OldUsableLimit;

    //
    // On both x86 and alpha the allocation of our large decompress buffer
    // has an unfortunate tendency to place the block right where the
    // (non-relocatable) kernel wants to go. By allocating from the top
    // of memory we make this problem go away.
    //

    DecompressBufferSize = BufferSize;

    //
    // Set allocatable range to the decompression-specific range
    //
    OldUsableBase = BlUsableBase;
    OldUsableLimit = BlUsableLimit;
    BlUsableBase  = BL_DECOMPRESS_RANGE_LOW;
    BlUsableLimit = BL_DECOMPRESS_RANGE_HIGH;

    Status = BlAllocateDescriptor(
                LoaderOsloaderHeap,
                0,
                (ULONG)(ROUND_TO_PAGES(DecompressBufferSize) >> PAGE_SHIFT),
                (PULONG)&DecompressBufferBasePage
                );

    //
    // Restore the previous alloc range.
    //
    BlUsableBase = OldUsableBase;
    BlUsableLimit = OldUsableLimit;

    if ( Status != ESUCCESS ) {
        TmErrOut(("Setup: couldn't allocate decompression buffer (%u)\r\n",Status));
        DecompressBuffer = NULL;
        return(Status);
    }

    DecompressBuffer = (PVOID)(KSEG0_BASE | (DecompressBufferBasePage << PAGE_SHIFT));

    DecompressBufferInUse = TRUE;

    return ESUCCESS;
}

VOID
DecompFreeDecompressBuffer (
    VOID
    )
{
    if ( DecompressBufferInUse ) {
        DecompressBufferInUse = FALSE;
        BlFreeDescriptor( (ULONG)DecompressBufferBasePage );
    }

    if(DecompressHeap) {
        BlFreeDescriptor( (ULONG)DecompressHeapPage );
        DecompressHeap = NULL;
    }

    return;
}

ARC_STATUS
DecompClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Close routine for decompression pseudo-filesystem.

    We mark the decompression buffer free and return success.

Arguments:

    FileId - supplies open file id to be closed.

Return Value:


--*/

{
    TmDbgOut(("DecompClose\r\n"));

    if(DecompressBufferInUse) {
        DecompFreeDecompressBuffer();
    } else {
        TmErrOut(("DecompClose: warning: no file buffered!\r\n"));
        TmDbgPause();
    }

    BlFileTable[FileId].Flags.Open = 0;

    return(ESUCCESS);
}


ARC_STATUS
DecompRead(
    IN  ULONG  FileId,
    OUT VOID  * FIRMWARE_PTR Buffer,
    IN  ULONG  Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    Read routine for the decompression pseudo-filesystem.

    Reads are satisfied out of the decompression buffer.

Arguments:

    FileId - supplies id for open file as returned by BlOpen().

    Buffer - receives data read from file.

    Length - supplies amount of data to be read, in bytes.

    Transfer - recieves number of bytes actually transferred
        into caller's buffer.

Return Value:

    ARC status indicating outcome.

--*/

{
    ARC_STATUS Status;
    ULONG length;

    if(DecompressBufferInUse) {
        //
        // Make sure we don't try to read past EOF.
        //
        if((Length + BlFileTable[FileId].Position.LowPart) > SizeOfFileInDecompressBuffer) {
            TmErrOut(("DecompRead: warning: attempt to read past eof; read trucated\r\n"));
            TmDbgPause();
            Length = SizeOfFileInDecompressBuffer - BlFileTable[FileId].Position.LowPart;
        }

        //
        // Transfer data into caller's buffer.
        //
        TmDbgOut(("DecompRead: %lx bytes at filepos %lx\r\n",Length,BlFileTable[FileId].Position.LowPart));

        RtlCopyMemory(
            Buffer,
            (PCHAR)DecompressBuffer + BlFileTable[FileId].Position.LowPart,
            Length
            );

        *Transfer = Length;

        BlFileTable[FileId].Position.QuadPart += Length;

        Status = ESUCCESS;

    } else {
        //
        // Should never get here.
        //
        TmErrOut(("DecompRead: no file buffered!\r\n"));
        TmDbgPause();
        Status = EACCES;
    }

    return(Status);
}


ARC_STATUS
DecompSeek(
    IN ULONG          FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE      SeekMode
    )

/*++

Routine Description:

    Seek routine for the decompression pseudo-filesystem.
    Sets pseudo-file pointer to given offset.

Arguments:

    FileId - supplies id for open file as returned by BlOpen().

    Offset - supplies new offset, whose interpretation depends on
        the SeekMode parameter.

    SeekMode - supplies type of seek. One of SeekAbsolute or SeekRelative.

Return Value:

    ARC status indicating outcome.

--*/

{
    LONGLONG NewPosition;

    TmDbgOut(("DecompSeek: mode %u, pos = %lx\r\n",SeekMode,Offset->LowPart));

    if(DecompressBufferInUse) {

        switch(SeekMode) {

        case SeekAbsolute:

            NewPosition = Offset->QuadPart;
            break;

        case SeekRelative:

            NewPosition = BlFileTable[FileId].Position.QuadPart + Offset->QuadPart;
            break;

        default:
            TmErrOut(("DecompSeek: invalid seek mode\r\n"));
            TmDbgPause();
            return(EINVAL);
        }

        //
        // Make sure we don't try to seek to a negative offset or past EOF.
        //
        if(NewPosition < 0) {
            TmErrOut(("DecompSeek: warning: attempt to seek to negative offset\r\n"));
            TmDbgPause();
            NewPosition = 0;
        } else {
            if((ULONGLONG)NewPosition > (ULONGLONG)SizeOfFileInDecompressBuffer) {
                TmErrOut(("DecompSeek: attempt to seek past eof\r\n"));
                TmDbgPause();
                return(EINVAL);
            }
        }

        //
        // Remember new position.
        //
        TmDbgOut(("DecompSeek: new position is %lx\r\n",NewPosition));
        BlFileTable[FileId].Position.QuadPart = NewPosition;

    } else {
        //
        // Should never get here.
        //
        TmErrOut(("DecompSeek: no file buffered!\r\n"));
        TmDbgPause();
        return(EACCES);
    }

    return(ESUCCESS);
}


ARC_STATUS
DecompGetFileInfo(
    IN  ULONG             FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR FileInfo
    )
{
    RtlCopyMemory(
        FileInfo,
        &((PDECOMP_STRUCTURE_CONTEXT)BlFileTable[FileId].StructureContext)->FileInfo,
        sizeof(FILE_INFORMATION)
        );

    TmDbgOut(("DecompGetFileInfo: size = %lx\r\n",FileInfo->EndingAddress.LowPart));

    return(ESUCCESS);
}


VOID
ReinitializeDiamondMiniHeap(
    VOID
    )
{
    PDECOMP_HEAP_BLOCK p;

    p = DecompressHeap;

    p->BlockSize = DECOMP_HEAP_SIZE - sizeof(DECOMP_HEAP_BLOCK);
    p->Next = NULL;
    p->Free = TRUE;
}


PVOID
DIAMONDAPI
DiamondAlloc(
    IN ULONG Size
    )
{
    PDECOMP_HEAP_BLOCK p,q;
    ULONG LeftOver;

    TmDbgOut(("DiamondAlloc: request %lx bytes\r\n",Size));

    //
    // Round size up to dword boundary.
    //
    if(Size % sizeof(ULONG_PTR)) {
        Size += sizeof(ULONG_PTR) - (Size % sizeof(ULONG_PTR));
    }

    //
    // Nothing fancy. First-fit algorithm, traversing all blocks
    // in the heap every time.
    //
    for(p=DecompressHeap; p; p=p->Next) {
        if(p->Free && (p->BlockSize >= Size)) {

            p->Free = FALSE;

            LeftOver = p->BlockSize - Size;

            if(LeftOver > sizeof(DECOMP_HEAP_BLOCK)) {
                //
                // Split the block.
                //
                p->BlockSize = Size;

                q = (PDECOMP_HEAP_BLOCK)((PUCHAR)(p+1) + Size);
                q->Next = p->Next;

                p->Next = q;

                q->Free = TRUE;
                q->BlockSize = LeftOver - sizeof(DECOMP_HEAP_BLOCK);
            }

            //
            // Return pointer to data area of the block.
            //
            TmDbgOut(("DiamondAlloc(%lx): %lx\r\n",Size,p+1));
            return(p+1);
        }
    }

    TmErrOut(("DiamondAlloc: out of heap space!\r\n"));
    TmDbgPause();
    return(NULL);
}


VOID
DIAMONDAPI
DiamondFree(
    IN PVOID Block
    )
{
    PDECOMP_HEAP_BLOCK p;

    TmDbgOut(("DiamondFree(%lx)\r\n",Block));

    //
    // Get pointer to header for block.
    //
    Block = (PUCHAR)Block - sizeof(DECOMP_HEAP_BLOCK);

    //
    // Nothing fancy, no coalescing free blocks.
    //
    for(p=DecompressHeap; p; p=p->Next) {

        if(p == Block) {

            if(p->Free) {
                TmErrOut(("DiamondFree: warning: freeing free block\r\n"));
                TmDbgPause();
                return;
            }

            p->Free = TRUE;
            return;
        }
    }

    TmErrOut(("DiamondFree: warning: freeing invalid block\r\n"));
    TmDbgPause();
}


INT_PTR
DIAMONDAPI
DiamondOpen(
    IN LPSTR FileName,
    IN int   oflag,
    IN int   pmode
    )
{
    ARC_STATUS Status;
    ULONG FileId;

    UNREFERENCED_PARAMETER(pmode);

    TmDbgOut(("DiamondOpen: %s\r\n",FileName));

    if(oflag & (_O_WRONLY | _O_RDWR | _O_APPEND | _O_CREAT | _O_TRUNC | _O_EXCL)) {

        TmErrOut(("DiamondOpen: invalid oflag %lx for %s\r\n",oflag,FileName));
        TmDbgPause();
        DecompLastIoError = EINVAL;
        return(-1);
    }

    Status = BlOpen(DecompDeviceId,FileName,ArcOpenReadOnly,&FileId);
    if(Status != ESUCCESS) {

        TmErrOut(("DiamondOpen: BlOpen %s returned %u\r\n",FileName,Status));
        TmDbgPause();
        DecompLastIoError = Status;
        return(-1);
    } else {
        TmDbgOut(("DiamondOpen: handle to %s is %lx\r\n",FileName,FileId));
    }

    return((INT_PTR)FileId);
}


UINT
DIAMONDAPI
DiamondRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )
{
    ARC_STATUS Status;
    ULONG n;

    TmDbgOut(("DiamondRead: %lx bytes, handle %lx\r\n",ByteCount,Handle));

    //
    // We should never be asked to read from the target file.
    //
    if(Handle == DECOMP_MAGIC_HANDLE) {
        TmErrOut(("DiamondRead: called for unexpected file!\r\n"));
        TmDbgPause();
        DecompLastIoError = EACCES;
        return((UINT)(-1));
    }

    Status = BlRead((ULONG)Handle,pv,ByteCount,&n);
    if(Status != ESUCCESS) {
        TmErrOut(("DiamondRead: BlRead failed %u\r\n",Status));
        TmDbgPause();
        DecompLastIoError = Status;
        n = (UINT)(-1);
    }

    return(n);
}


UINT
DIAMONDAPI
DiamondWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )
{
    TmDbgOut(("DiamondWrite: %lx bytes\r\n",ByteCount));

    //
    // This guy should be called ONLY to write decompressed data
    // into the decompress buffer.
    //
    if(Handle != DECOMP_MAGIC_HANDLE) {
        TmErrOut(("DiamondWrite: called for unexpected file!\r\n"));
        TmDbgPause();
        DecompLastIoError = EACCES;
        return((UINT)(-1));
    }

    //
    // Check for overflow.
    //
    if(SizeOfFileInDecompressBuffer+ByteCount > DecompressBufferSize) {
        TmErrOut(("DiamondWrite: decompressed file too big!\r\n"));
        TmDbgPause();
        DecompLastIoError = E2BIG;
        return((UINT)(-1));
    }

    RtlCopyMemory(
        (PCHAR)DecompressBuffer + SizeOfFileInDecompressBuffer,
        pv,
        ByteCount
        );

    SizeOfFileInDecompressBuffer += ByteCount;
    return(ByteCount);
}


int
DIAMONDAPI
DiamondClose(
    IN INT_PTR Handle
    )
{
    TmDbgOut(("DiamondClose, handle=%lx\r\n",Handle));

    if(Handle != DECOMP_MAGIC_HANDLE) {
        BlClose((ULONG)Handle);
    }

    return(0);
}


long
DIAMONDAPI
DiamondSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    )
{
    ARC_STATUS Status;
    LARGE_INTEGER Offset;

    TmDbgOut(("DiamondSeek: type=%u, dist=%lx, handle=%lx\r\n",SeekType,Distance,Handle));

    //
    // We should never be asked to seek in the output file.
    //
    if(Handle == DECOMP_MAGIC_HANDLE) {
        TmErrOut(("DiamondSeek: asked to seek target file!\r\n"));
        TmDbgPause();
        DecompLastIoError = EACCES;
        return(-1);
    }

    //
    // We can't handle seek from end of file.
    //
    if(SeekType == SEEK_END) {
        TmErrOut(("DiamondSeek: asked to seek relative to end of file!\r\n"));
        TmDbgPause();
        DecompLastIoError = EACCES;
        return(-1);
    }

    Offset.QuadPart = Distance;

    Status = BlSeek((ULONG)Handle,&Offset,SeekType);
    if(Status != ESUCCESS) {
        TmErrOut(("DiamondSeek: BlSeek(%lx,%x) returned %u\r\n",Distance,SeekType,Status));
        TmDbgPause();
        DecompLastIoError = Status;
        return(-1);
    }

    TmDbgOut(("DiamondSeek: BlSeek(%lx,%x) new file position is %lx\r\n",Distance,SeekType,BlFileTable[Handle].Position.LowPart));
    return((long)BlFileTable[Handle].Position.LowPart);
}


INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    ARC_STATUS Status;

    switch(Operation) {

    case fdintCABINET_INFO:
        //
        // Nothing interesting here. Return 0 to continue.
        //
        return(0);

    case fdintCOPY_FILE:

        //
        // The file was obviously a cabinet so we're going to extract
        // the file out of it. Rememember that the decompression buffer
        // is in use. If it's already in use, then a fundamental
        // principle of our implementation has been violated and we
        // must bail now.
        //
        if(DecompressBufferInUse) {
            TmErrOut(("DiamondNotifyFunction: opens overlap (%s)!\r\n",Parameters->psz1));
            DecompLastIoError = EACCES;
            return(-1);
        }

        DecompExpectedSize = Parameters->cb;

        Status = DecompAllocateDecompressBuffer( DecompExpectedSize );
        if (Status != ESUCCESS) {
            TmErrOut(("DiamondNotifyFunction: unable to allocate decompress buffer!\r\n"));
            return(-1);
        }

        SizeOfFileInDecompressBuffer = 0;
        return(DECOMP_MAGIC_HANDLE);

    case fdintCLOSE_FILE_INFO:
        //
        // Diamond is asking to close the target handle. There's nothing we really
        // care about here, just return success as long as we recognize the handle.
        //
        if(Parameters->hf == DECOMP_MAGIC_HANDLE) {
            return(TRUE);
        } else {
            TmErrOut(("DiamondNotifyFunction: asked to close unexpected file!\r\n"));
            TmDbgPause();
            DecompLastIoError = EINVAL;
            return(FALSE);
        }

    default:
        //
        // Disregard any other messages
        //
        return(0);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

#
# BOOT_LIB_DIR is the relative path to boot.lib.
#
$(O)\msgs.mc : ..\msgs.$(LANGUAGE)
    copy $** $@

!IF $(386)

!IFNDEF BOOT_LIB_DIR
ENTRYPOINT=-entry:NtProcessStartup@4
LDR_NAME=setupldr$(DBG_LDR).exe
BOOT_LIB_DIR=daytona$(DBG_LDR)
!ENDIF


SETUPLDR_LIBS= \
    $(O)\setupldr.lib \
    $(O)\setupldr.res \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\fdi.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \


$(O)\link.rsp : ..\makefile.inc
    type << > $@
-base:0x300000
-debug
$(ENTRYPOINT)
-fixed
-ignore:4001
-incremental:no
-map
-nodefaultlib
-opt:ref
-opt:icf
-subsystem:native
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(SETUPLDR_LIBS)
<<NOKEEP

$(O)\setupldr.res: $(O)\msgs.mc

$(O)\$(LDR_NAME): $(SETUPLDR_LIBS) makefile.inc $(O)\link.rsp
    $(LINK_NAME) -out:$@ @$(O)\link.rsp

!IFNDEF NTVERSION
STARTUP=i386\startup\a20.asm     \
        i386\startup\abios.inc   \
        i386\startup\abiosa.asm  \
        i386\startup\backend.asm \
        i386\startup\constant.h  \
        i386\startup\display.c   \
        i386\startup\eisac.c     \
        i386\startup\eisaa.asm   \
        i386\startup\eisa.h      \
        i386\startup\eisa.inc    \
        i386\startup\exp.asm     \
        i386\startup\global.h    \
        i386\startup\macro.inc   \
        i386\startup\main.c      \
        i386\startup\memmap.h    \
        i386\startup\memmap.inc  \
        i386\startup\su.asm      \
        i386\startup\su.h        \
        i386\startup\su.inc      \
        i386\startup\sudata.asm  \
        i386\startup\trap.asm    \
        i386\startup\trapdump.c  \
        i386\startup\types.h

!ENDIF

#
# STARTUP_DIR is the relative path to startup.com.
# All languages use their own startup.com,
# except FE langauges which use the US version when
# creating setupldr.bin.
#
!IFNDEF STARTUP_DIR
STARTUP_DIR=$(ALT_PROJECT)
!ENDIF

$(O)\setupldr$(DBG_LDR).bin: $(O)\setupldr$(DBG_LDR).exe ..\..\startup\$(STARTUP_DIR)\$(_OBJ_DIR)\i386\startup.com makefile.inc
    -copy $(O)\setupldr$(DBG_LDR).exe $(O)\setupldr.spl
    splitsym -a $(O)\setupldr.spl
    -copy /b ..\..\startup\$(STARTUP_DIR)\$(_OBJ_DIR)\i386\startup.com+$(O)\setupldr.spl $@
    -del /q $(O)\setupldr.dbg

!ELSE IF $(IA64)
EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

#Add in -fixed if debugging with an ITP to get a known base

SETUPLDR_LIBS=\
    $(O)\setupldr.lib \
    $(O)\setupldr.res \
    $(PROJECT_ROOT)\boot\lib\daytona$(DBG_LDR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\efi\daytona$(DBG_LDR)\$(O)\efi.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\ex\up\$(O)\ex.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\fdi.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
    $(DDK_LIB_PATH)\hal.lib
                
$(O)\link.rsp : ..\makefile.inc
    type << > $@
-subsystem:EFI_APPLICATION
-nodefaultlib
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-machine:IA64
-base:0x1040000
-opt:ref
-opt:icf
-entry:main
-map
-ignore:4049,4001,4217
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(SETUPLDR_LIBS)
<<NOKEEP

$(O)\setupldr.res: $(O)\msgs.mc

$(O)\setupldr$(DBG_LDR).efi: $(SETUPLDR_LIBS) makefile.inc $(O)\link.rsp
    -$(LINK_NAME) -out:$@ @$(O)\link.rsp

$(O)\setupldr.dbg: $(O)\setupldr$(DBG_LDR).efi
    -pe2dbg $? $@

SETUP_LIB_COMPONENTS = \
    $(PROJECT_ROOT)\boot\lib\daytona$(DBG_LDR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\efi\daytona$(DBG_LDR)\$(O)\efi.lib

!ELSE

SETUPLDR_LIBS=\
    $(O)\setupldr.lib \
    $(O)\setupldr.res \
    $(PROJECT_ROOT)\boot\lib\daytona$(DBG_LDR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\fdi.lib \
    $(SDK_LIB_PATH)\libcntpr.lib

$(O)\link.rsp : ..\makefile.inc
    type << >$@
-rom
-nodefaultlib
-debugtype:cv
-debug:full
-align:0x200
-fixed
!if $(ALPHA)
-base:0x80600000
!elseif $(AXP64)
-base:0xFFFFFFFF80600000
!endif
-entry:SlInit
-map
-opt:noicf
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(SETUPLDR_LIBS)
<<NOKEEP

$(O)\setupldr.res: $(O)\msgs.mc

$(O)\setupldr$(DBG_LDR): $(SETUPLDR_LIBS) makefile.inc $(O)\link.rsp
    -$(LINK_NAME) -out:$@ @$(O)\link.rsp
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\msgs.cs ===
;/*++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    msgs.h
;
;Abstract:
;
;    This file contains the message definitions for setupldr
;
;Author:
;
;    John Vert (jvert) 12-Nov-1993
;
;Revision History:
;
;Notes:
;
;    This file is generated from msgs.mc
;
;--*/
;
;#ifndef _SETUPLDR_MSG_
;#define _SETUPLDR_MSG_
;
;

MessageID=9000 SymbolicName=SL_MSG_FIRST
Language=English
.


MessageID=9001 SymbolicName=SL_SCRN_WELCOME
Language=English
Vt vs instalan program systmu Windows

           Pokraujte klvesou ENTER

         Instalaci ukonte klvesou F3
.

MessageID=9002 SymbolicName=SL_WELCOME_HEADER
Language=English

 Instalace systmu Windows

.

MessageID=9003 SymbolicName=SL_TOTAL_SETUP_DEATH
Language=English
Instalace se nepodaila. Libovolnou klvesou restartujte pota.
.

MessageID=9004 SymbolicName=SL_FILE_LOAD_MESSAGE
Language=English
Instalan program nat soubory (%s)...
.

MessageID=9005 SymbolicName=SL_OTHER_SELECTION
Language=English
Jin (vyaduje disketu s ovladaem OEM)
.

MessageID=9006 SymbolicName=SL_SELECT_DRIVER_PROMPT
Language=English
ENTER=Vybrat  F3=Konec
.

MessageID=9007 SymbolicName=SL_NEXT_DISK_PROMPT_CANCELLABLE
Language=English
ENTER=Pokraovat  ESC=Storno  F3=Konec
.

MessageID=9008 SymbolicName=SL_OEM_DISK_PROMPT
Language=English
Podprn disketa dodan vrobcem hardwaru
.

MessageID=9009 SymbolicName=SL_MSG_INSERT_DISK
Language=English
  Vlote disketu, oznaenou jako



           do jednotky A:

*  Potvrte vloen klvesou ENTER.
.

MessageID=9010 SymbolicName=SL_MSG_EXIT_DIALOG
Language=English
ͻ
  Systm Windows nen na potai zcela               
  nainstalovn. Ukonte-li nyn instalan program,  
  budete jej muset spustit znovu, aby se systm       
  Windows nainstaloval.                               
                                                      
     * Stisknete-li ENTER, instalace bude pokraovat. 
     * Stisknutm klvesy F3 instalaci ukonte.      
͹
     F3=Konec  ENTER=Pokraovat                       
ͼ
.

MessageID=9011 SymbolicName=SL_NEXT_DISK_PROMPT
Language=English
ENTER=Pokraovat  F3=Konec
.

MessageID=9012 SymbolicName=SL_NTDETECT_PROMPT
Language=English

Instalan program zjiuje hardwarovou konfiguraci potae...

.

MessageID=9013 SymbolicName=SL_KERNEL_NAME
Language=English
Vkonn jdro systmu Windows
.

MessageID=9014 SymbolicName=SL_HAL_NAME
Language=English
Vrstva HAL
.

MessageID=9015 SymbolicName=SL_PAL_NAME
Language=English
Doplky procesoru systmu Windows
.

MessageID=9016 SymbolicName=SL_HIVE_NAME
Language=English
Konfiguran data systmu Windows
.

MessageID=9017 SymbolicName=SL_NLS_NAME
Language=English
Jazykov zvisl data
.

MessageID=9018 SymbolicName=SL_OEM_FONT_NAME
Language=English
Psmo instalanho programu
.

MessageID=9019 SymbolicName=SL_SETUP_NAME
Language=English
Instalace systmu Windows
.

MessageID=9020 SymbolicName=SL_FLOPPY_NAME
Language=English
Ovlada disketov jednotky
.

MessageID=9021 SymbolicName=SL_KBD_NAME
Language=English
Ovlada klvesnice
.

MessageID=9121 SymbolicName=SL_FAT_NAME
Language=English
Systm soubor FAT
.

MessageID=9022 SymbolicName=SL_SCSIPORT_NAME
Language=English
Ovlada rozhran SCSI
.

MessageID=9023 SymbolicName=SL_VIDEO_NAME
Language=English
Grafick ovlada
.

MessageID=9024 SymbolicName=SL_STATUS_REBOOT
Language=English
Restartujte pota stisknutm libovoln klvesy.
.

MessageID=9025 SymbolicName=SL_WARNING_ERROR
Language=English
Nastala neoekvan chyba (%d)
na dku %d v souboru %s.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9026 SymbolicName=SL_FLOPPY_NOT_FOUND
Language=English
Bylo nalezeno pouze %d disketovch jednotek,
systm se snail nalzt jednotku %d.
.

MessageID=9027 SymbolicName=SL_NO_MEMORY
Language=English
Systmu dola veker voln pam؜
na dku %d v souboru %s.
.

MessageID=9028 SymbolicName=SL_IO_ERROR
Language=English
V systmu dolo k V/V chyb
pi pstupu k souboru %s.
.

MessageID=9029 SymbolicName=SL_BAD_INF_SECTION
Language=English
Sekce %s souboru INF je neplatn.
.

MessageID=9030 SymbolicName=SL_BAD_INF_LINE
Language=English
dek %d souboru INF %s je neplatn
.

MessageID=9031 SymbolicName=SL_BAD_INF_FILE
Language=English
Soubor %s (INF) je pokozen nebo chyb, stav %d.
.

MessageID=9032 SymbolicName=SL_FILE_LOAD_FAILED
Language=English
Soubor %s se nepodailo nast.

Kd chyby je %d
.

MessageID=9033 SymbolicName=SL_INF_ENTRY_MISSING
Language=English
Poloka "%s" v sekci [%s]
souboru INF je pokozena nebo chyb.
.

MessageID=9034 SymbolicName=SL_PLEASE_WAIT
Language=English
Pokejte prosm...
.

MessageID=9035 SymbolicName=SL_CANT_CONTINUE
Language=English
Instalace neme pokraovat. Ukonete instalaci libovolnou klvesou.
.

MessageID=9036 SymbolicName=SL_PROMPT_SCSI
Language=English
Vyberte poadovan adaptr SCSI ze seznamu, nebo zvolte "Jin",
mte-li disketu s podporou danho zazen od vrobce adaptru.

.

MessageID=9037 SymbolicName=SL_PROMPT_OEM_SCSI
Language=English
Zvolili jste monost konfigurovat adaptr SCSI pro pouit v systmu 
Windows pomoc diskety s podporou zazen od vrobce adaptru.

Vyberte poadovan adaptr SCSI z nsledujcho seznamu, nebo se
stisknutm klvesy ESC vrate na pedchoz obrazovku.

.
MessageID=9038 SymbolicName=SL_PROMPT_HAL
Language=English
Instalanmu programu se nepodailo urit typ potae, nebo byla 
zvolena monost typ potae zadat run.

Vyberte typ potae z nsledujcho seznamu, nebo zvolte "Jin",
mte-li disketu s podporou zazen od vrobce potae.

K posouvn mezi polokami nabdky pouijte klvesy ipka nahoru a dol.

.

MessageID=9039 SymbolicName=SL_PROMPT_OEM_HAL
Language=English
Zvolili jste monost konfigurovat pota pro systm Windows
pomoc diskety s podporou zazen od vrobce potae.

Zadejte typ potae z nsledujcho seznamu, nebo se stisknutm
tlatka ESC vrate na pedchoz obrazovku.

K posouvn mezi polokami nabdky pouijte klvesy ipka nahoru a dol.

.

MessageID=9040 SymbolicName=SL_PROMPT_VIDEO
Language=English
Instalanmu programu se nepodailo urit typ nainstalovanho 
grafickho adaptru.

Vyberte grafick adaptr ze seznamu, nebo zvolte "Jin",
mte-li disketu s podporou zazen od vrobce adaptru.

.

MessageID=9041 SymbolicName=SL_PROMPT_OEM_VIDEO
Language=English
Zvolili jste monost konfigurovat grafick adaptr pro systm Windows
pomoc diskety s podporou zazen od vrobce adaptru.

Vyberte grafick adaptr z nsledujcho seznamu, nebo se stisknutm
tlatka ESC vrate na pedchoz obrazovku.

.


MessageID=9042 SymbolicName=SL_WARNING_ERROR_WFILE
Language=English
Soubor %s zpsobil neoekvanou chybu (%d)
na dku %d v %s.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9043 SymbolicName=SL_WARNING_IMG_CORRUPT
Language=English
Soubor %s je pokozen.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9044 SymbolicName=SL_WARNING_IOERR
Language=English
Pi pstupu k souboru %s dolo k V/V chyb.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9045 SymbolicName=SL_WARNING_NOFILE
Language=English
Soubor %s nebyl nalezen.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9046 SymbolicName=SL_WARNING_NOMEM
Language=English
Nedostatek pamti pro %s.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9047 SymbolicName=SL_DRIVE_ERROR
Language=English
SETUPLDR: Jednotku %s nelze otevt
.

MessageID=9048 SymbolicName=SL_NTDETECT_MSG
Language=English

Instalan program zjiuje hardwarovou konfiguraci potae...

.

MessageID=9049 SymbolicName=SL_NTDETECT_FAILURE
Language=English
NTDETECT selhal
.

MessageId=9050 SymbolicName=SL_SCRN_TEXTSETUP_EXITED
Language=English
Systm Windows nebyl nainstalovn.

Pokud je v jednotce A: vloena disketa, vyjmte ji.

Restartujte pota stisknutm klvesy ENTER.
.

MessageId=9051 SymbolicName=SL_SCRN_TEXTSETUP_EXITED_ARC
Language=English
Systm Windows nebyl nainstalovn.

Restartujte pota stisknutm klvesy ENTER.
.

MessageID=9052 SymbolicName=SL_REBOOT_PROMPT
Language=English
ENTER=Restartovat pota
.

MessageID=9053 SymbolicName=SL_WARNING_SIF_NO_DRIVERS
Language=English
Instalan program nenalezl dn ovladae spojen se zadanou volbou.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9054 SymbolicName=SL_WARNING_SIF_NO_COMPONENT
Language=English
Vloen disketa neobsahuje dn odpovdajc soubory podpory.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9055 SymbolicName=SL_WARNING_BAD_FILESYS
Language=English
Tuto disketu nelze pest, protoe obsahuje nerozpoznan systm soubor.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9056 SymbolicName=SL_BAD_UNATTENDED_SCRIPT_FILE
Language=English
Poloka

"%s"

souboru skriptu bezobslun instalace
v sekci [%s] souboru INF %s neexistuje.
.

MessageID=9057 SymbolicName=SL_MSG_PRESS_F5_OR_F6
Language=English
Chcete-li nainstalovat jin ovladae zazen SCSI nebo RAID, stisknte F6...
.

;//
;// The following three messages are used to provide the same mnemonic
;// keypress as is used in the Additional SCSI screen in setupdd.sys
;// (see setup\textmode\user\msg.mc--SP_MNEMONICS and SP_MNEMONICS_INFO)
;// The single character specified in SL_SCSI_SELECT_MNEMONIC must be
;// the same as that listed in the status text of SL_SCSI_SELECT_PROMPT
;// (and also referenced in the SL_SCSI_SELECT_MESSAGE_2).
;//
MessageID=9060 SymbolicName=SL_SCSI_SELECT_MNEMONIC
Language=English
S
.

MessageID=9061 SymbolicName=SL_SCSI_SELECT_PROMPT
Language=English
S=Specifikovat dal zazen   ENTER=Pokraovat   F3=Konec
.

MessageID=9062 SymbolicName=SL_SCSI_SELECT_MESSAGE_2
Language=English
  * Chcete-li specifikovat dal adaptry SCSI, jednotky CD-ROM, nebo 
    speciln adie disk pro pouit v systmu Windows, 
    vetn tch, pro nا mte disketu s podporou zazen od vrobce 
    velkokapacitnch ukldacch zazen, stisknte klvesu S.

  * Pokud nemte disketu s podporou zazen od vrobce velkokapacitnch
    zazen, nebo nechcete specifikovat dn dal zazen pro 
    pouit v systmu Windows, stisknte klvesu ENTER.
.

MessageID=9063 SymbolicName=SL_SCSI_SELECT_MESSAGE_1
Language=English
Instalan program nemohl urit typ jednoho nebo vce velkokapacitnch
zazen, nainstalovanch v systmu, nebo byla zvolena monost urit 
adaptr run. Instalan program nyn nate podporu nsledujcch 
velkokapacitnch ukldacch zazen:
.

MessageID=9064 SymbolicName=SL_SCSI_SELECT_MESSAGE_3
Language=English
Instalan program nate podporu nsledujcch velkokapacitnch 
ukldacch zazen:
.

MessageID=9065 SymbolicName=SL_SCSI_SELECT_ERROR
Language=English
Instalan program nemohl nast podporu pro uren velkokapacitn
ukldac zazen. Instalan program nyn nate podporu nsledujcch 
velkokapacitnch ukldacch zazen:
.

MessageID=9066 SymbolicName=SL_TEXT_ANGLED_NONE
Language=English
<dn>
.

MessageID=9067 SymbolicName=SL_TEXT_SCSI_UNNAMED
Language=English
<nepojmenovan adaptr>
.

MessageID=9068 SymbolicName=SL_TEXT_OTHER_DRIVER
Language=English
Jin
.

MessageID=9069 SymbolicName=SL_TEXT_REQUIRES_486
Language=English
Systm Windows vyaduje procesor 80486 nebo vy.
.

MessageID=9070 SymbolicName=SL_NTPNP_NAME
Language=English
Exportn ovlada Plug & Play
.

MessageID=9071 SymbolicName=SL_PCI_IDE_EXTENSIONS_NAME
Language=English
Ovlada rozen PCI IDE
.

MessageID=9072 SymbolicName=SL_HW_FW_CFG_CLASS
Language=English
Systm Windows se nepodailo spustit z dvodu nsledujcho
problmu spoutc konfigurace firmwaru ARC:
.

MessageID=9073 SymbolicName=DIAG_SL_FW_GET_BOOT_DEVICE
Language=English
Nastaven parametru 'osloadpartition' je neplatn.
.

MessageID=9074 SymbolicName=LOAD_HW_FW_CFG_ACT
Language=English
Monosti konfigurace ARC naleznete v dokumentaci k systmu Windows
Dal informace naleznete v prukch k hardwaru.
.
MessageID=9075 SymbolicName=SL_NETADAPTER_NAME
Language=English
Ovlada sovho adaptru
.
MessageID=9076 SymbolicName=SL_TCPIP_NAME
Language=English
Sluba TCP/IP
.
MessageID=9077 SymbolicName=SL_NETBT_NAME
Language=English
Sluba WINS Client(TCP/IP)
.
MessageID=9078 SymbolicName=SL_MRXSMB_NAME
Language=English
Mini-pesmrova MRXSMB
.
MessageID=9079 SymbolicName=SL_MUP_NAME
Language=English
Systm soubor UNC
.
MessageID=9080 SymbolicName=SL_NDIS_NAME
Language=English
Ovlada NDIS
.
MessageID=9081 SymbolicName=SL_RDBSS_NAME
Language=English
Systm soubor SMB Redirector
.
MessageID=9082 SymbolicName=SL_NETBOOT_CARD_ERROR
Language=English
Sov karta ve vaem potai obsahuje star verzi pamti ROM
a nelze ji pout pro vzdlenou instalaci systmu Windows.
Obrate se na sprvce systmu nebo vrobce potae s dost
o inovaci pamti ROM.
.
MessageID=9083 SymbolicName=SL_NETBOOT_SERVER_ERROR
Language=English
Vybran obraz operanho systmu neobsahuje nezbytn ovladae
sovho adaptru. Pokuste se vybrat jin obraz operanho
systmu. Pokud problm trv, obrate se na sprvce systmu.
.
MessageID=9084 SymbolicName=SL_IPSEC_NAME
Language=English
Zabezpeen protokolu IP 
.
MessageID=9085 SymbolicName=SL_CMDCONS_MSG
Language=English
Konzola pro zotaven systmu Windows
.
MessageID=9086 SymbolicName=SL_KERNEL_TRANSITION
Language=English
Instalan program spout systm Windows
.
;#ifdef _WANT_MACHINE_IDENTIFICATION
MessageID=9087 SymbolicName=SL_BIOSINFO_NAME
Language=English
Data pro identifikaci potae
.
;#endif
MessageID=9088 SymbolicName=SL_KSECDD_NAME
Language=English
Sluba Zabezpeen jdra
.
MessageID=9089 SymbolicName=SL_WRONG_PROM_VERSION
Language=English
Systmov pam؜ PROM (obsahujc firmware) je na ni rovni revize
ne je poadovno. Obrate se na technickou podporu spolenosti SGI nebo
navtivte webov server spolenosti SGI a podejte o aktualizaci pamti PROM
a instrukce k proveden aktualizace.

Poznmka: Vbrem pslun poloky spoutc obrazovky msto vchoz
poloky Instalace systmu Windows mete spustit pedchoz instalace
systmu Microsoft(R) Windows(R) NT nebo Windows(R) XP.
.
MessageID=9090 SymbolicName=SIGNATURE_CHANGED
Language=English
Instalan program zjistil v potai vce disk, kter nelze rozliit.
Instalan program problm opravil, ale je nutno restartovat pota.
.
MessageID=9091 SymbolicName=SL_KDDLL_NAME
Language=English
Kernel Debugger DLL
.

MessageID=9092 SymbolicName=SL_OEM_DRIVERINFO
Language=English
%s

Systm Windows ji m ovlada pro "%s".

Pokud vrobce nedoporuuje jinak, mli byste pout ovlada systmu Windows.
.

MessageID=9093 SymbolicName=SL_CONFIRM_OEMDRIVER
Language=English
S=Pout ovlada na disket  ENTER=Pout vchoz ovlada systmu Windows
.

MessageID=9094 SymbolicName=SL_OEMDRIVER_NEW
Language=English
Poskytnut ovlada je pravdpodobn novj ne vchoz ovlada systmu Windows.
.

MessageID=9095 SymbolicName=SL_INBOXDRIVER_NEW
Language=English
Poskytnut ovlada je pravdpodobn star ne vchoz ovlada systmu Windows
.

MessageID=9096 SymbolicName=SL_CMDCONS_STARTING
Language=English
Spoutn konzoly pro obnoven...
.

MessageID=9097 SymbolicName=SL_NTDETECT_CMDCONS
Language=English
Modul NTDETECT kontroluje hardware...
.

MessageID=9098 SymbolicName=SL_MSG_PRESS_ASR
Language=English
Stisknutm kvesy F2 spustte Automatick obnoven systmu (ASR)...
.

MessageID=9099 SymbolicName=SL_MSG_WARNING_ASR
Language=English
        Vlote disketu oznaenou:


Disketa pro automatick obnoven systmu Windows


            do disketov jednotky.



          Pak stisknte libovolnou klvesu.
.


MessageID=9100 SymbolicName=SL_TEXT_REQUIRED_FEATURES_MISSING
Language=English

Systm Windows poaduje urit funkce procesoru,
kter nejsou v procesoru tohoto potae k dispozici.
Systm Windows zejmna poaduje instrukce:

    CPUID
    CMPXCHG8B
.

MessageID=9101 SymbolicName=SL_MSG_PREPARING_ASR
Language=English
Pprava Automatickho obnoven systmu (ASR) (zruit mete klvesou ESC)...
.

MessageID=9102 SymbolicName=SL_MSG_ENTERING_ASR
Language=English
Spoutn Automatickho obnoven systmu...
.

MessageID=9103 SymbolicName=SL_MOUSE_NAME
Language=English
Ovlada myi
.

MessageID=9104 SymbolicName=SL_SETUP_STARTING
Language=English
Spoutn instalace systmu Windows...
.

MessageID=9105 SymbolicName=SL_MSG_INVALID_ASRPNP_FILE
Language=English
Soubor ASRPNP.SIF na disket Automatickho obnoven systmu je neplatn.
.

MessageID=9106 SymbolicName=SL_SETUP_STARTING_WINPE
Language=English
Spoutn pedinstalanho prosted systmu Windows...
.

MessageID=9107 SymbolicName=SL_NTDETECT_ROLLBACK
Language=English

Odinstalace kontroluje hardware...


.

MessageID=9108 SymbolicName=SL_ROLLBACK_STARTING
Language=English
Spoutn odinstalace systmu Windows...
.

MessageID=9109 SymbolicName=SL_NO_FLOPPY_DRIVE
Language=English
Instalan program nenalezl v potai disketovou jednotku k naten
ovlada z diskety od vrobce OEM.

    * Natn ovlada vrobce OEM zrute stisknutm klvesy ESC 
    
    * Instalaci ukonte stisknutm klvesy F3.
.

MessageID=9110 SymbolicName=SL_UPGRADE_IN_PROGRESS
Language=English
Tento pota je aktualizovn systmem Microsoft Windows.
Jak chcete pokraovat?

    * Stisknutm klvesy ENTER.bude pokraovat aktualizace

    * Chcete-li aktualizaci zruit a nainstalovat novou verzi
      systmu Microsoft Windows, stisknte klvesu F10.

    * Chcete-li instalan program ukonit bez instalace 
      systmu Microsoft Windows, stisknte klvesu F3.
.

MessageID=9111 SymbolicName=SL_DRVMAINSDB_NAME
Language=English
Data k identifikaci ovladae
.

MessageID=9112 SymbolicName=SL_OEM_FILE_LOAD_FAILED
Language=English
Naten ovlada vrobce OEM se nezdailo.

Pokraujte stisknutm libovoln klvesy.
.


; //
; // NOTE : donot change the Message ID values for SL_CMDCONS_PROGBAR_FRONT
; // and SL_CMDCONS_PROGBAR_BACK from 11513 & 11514
; //

;
; // The character used to draw the foregound in percent-complete bar
;
;
MessageID=11513 SymbolicName=SL_CMDCONS_PROGBAR_FRONT
Language=English

.

;
; // The character used to draw the background in percent-complete bar
;
;
MessageID=11514 SymbolicName=SL_CMDCONS_PROGBAR_BACK
Language=English

.

;
; //
; // Ramdisk related messages. DO NOT CHANGE the message numbers
; // as they are kept in sync with \base\boot\inc\ramdisk.h.
; //
; // Note that some message numbers are skipped in order to retain
; // consistency with the .NET source base.
; //
;

MessageID=15000 SymbolicName=BL_RAMDISK_GENERAL_FAILURE
Language=English
Pi spoutn systmu z ramdisku dolo k chyb. Systm Windows nelze spustit.
.

MessageID=15003 SymbolicName=BL_RAMDISK_BOOT_FAILURE
Language=English
Oteven bitov kopie ramdisku se nezdailo.
.

MessageID=15010 SymbolicName=BL_RAMDISK_DOWNLOAD
Language=English
Natn bitov kopie ramdisku...
.

;#endif // _SETUPLDR_MSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\cht\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\oemdisk.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    oemdisk.c

Abstract:

    Provides routines for handling OEM disks for video, SCSI miniport, and HAL.

    Currently used only on ARC machines.

Author:

    John Vert (jvert) 4-Dec-1993

Revision History:

    John Vert (jvert) 4-Dec-1993
        created

--*/
#include <setupbat.h>
#include "setupldr.h"
#include "stdio.h"
#include <ctype.h>

#ifdef i386
#include <bldrx86.h>
#endif

#if DBG

#define DIAGOUT(x) SlPrint x

#else

#define DIAGOUT(x)

#endif

BOOLEAN PromptOemHal=FALSE;
BOOLEAN PromptOemScsi=FALSE;
BOOLEAN PromptOemVideo=FALSE;
PVOID PreInstallOemInfHandle = NULL;

//
// Floppy disks which need to be treated as
// as virtual floppies
//
const static ULONG VirtualFloppyStart = 1;
const static ULONG MinimumFloppiesToScan = 2;   


#ifdef ARCI386
BOOLEAN PromptOemKeyboard=FALSE;
#endif

PCHAR FloppyDiskPath;
ULONG FloppyNumber=0;
ULONG IsSuperFloppy=0;

extern PCHAR BootPath;
extern PCHAR BootDevice;
extern ULONG BootDeviceId;
extern PVOID InfFile;

typedef struct _MENU_ITEM_DATA {
    PVOID InfFile;
    PCHAR SectionName;
    ULONG Index;
    PTCHAR Description;
    PCHAR Identifier;
} MENU_ITEM_DATA, *PMENU_ITEM_DATA;

typedef enum _OEMFILETYPE {
    OEMSCSI,
    OEMHAL,
    OEMOTHER
    } OEMFILETYPE, *POEMFILETYPE;

//
// Define how many lines of SCSI adapters we can list.
//
#define MAX_SCSI_MINIPORT_COUNT 4


//
// private function prototypes
//
ULONG
SlpAddSectionToMenu(
    IN PVOID    InfHandle,
    IN PCHAR    SectionName,
    IN PSL_MENU Menu
    );

BOOLEAN
SlpOemDiskette(
    IN POEM_SOURCE_DEVICE OemSourceDevice,
    IN PCHAR              ComponentName,
    IN OEMFILETYPE        ComponentType,
    IN ULONG              MenuHeaderId,
    OUT PDETECTED_DEVICE  DetectedDevice,
    OUT PVOID *           ImageBase,
    OUT OPTIONAL PCHAR *  ImageName,
    OUT OPTIONAL PTCHAR * DriverDescription,
    IN BOOLEAN            AllowUserSelection,
    IN PTCHAR             PreInstallComponentDescription,
    OUT PPNP_HARDWARE_ID* HardwareIdDatabase,
    IN PCHAR DriverDir,
    IN BOOLEAN InsertDevice
    );

BOOLEAN
SlpSelectHardware(
    IN POEM_SOURCE_DEVICE SourceDevice,
    IN PCHAR             ComponentName,
    IN OEMFILETYPE        ComponentType,
    IN TYPE_OF_MEMORY     MemoryType,
    IN ULONG              MenuHeaderId,
    IN ULONG              OemMenuHeaderId,
    OUT PDETECTED_DEVICE  DetectedDevice,
    OUT PVOID *           ImageBase,
    OUT OPTIONAL PCHAR *  ImageName,
    OUT OPTIONAL PTCHAR * DriverDescription,
    IN BOOLEAN            AllowUserSelection,
    IN PTCHAR             PreInstallComponentDescription,
    IN BOOLEAN            PreInstallOemComponent,
    OUT PPNP_HARDWARE_ID* HardwareIdDatabase
    );

BOOLEAN
SlpOemInfSelection(
    IN  POEM_SOURCE_DEVICE OemSourceDevice,
    IN  PVOID   OemInfHandle,
    IN  PCHAR   ComponentName,
    IN  PCHAR   SelectedId,
    IN  PTCHAR  ItemDescription,
    OUT PDETECTED_DEVICE    Device,
    OUT PPNP_HARDWARE_ID*   HardwareIdDatabase,
    IN  PCHAR   DriverDir
    );

VOID
SlpInitDetectedDevice(
    IN PDETECTED_DEVICE Device,
    IN PCHAR            IdString,
    IN PTCHAR           Description,
    IN BOOLEAN          ThirdPartyOptionSelected
    );

PDETECTED_DEVICE_REGISTRY
SlpInterpretOemRegistryData(
    IN PVOID            InfHandle,
    IN PCHAR            SectionName,
    IN ULONG            Line,
    IN HwRegistryType   ValueType
    );

BOOLEAN
FoundFloppyDiskCallback(
    IN PCONFIGURATION_COMPONENT_DATA Component
    );

BOOLEAN
SuperFloppyCallback(
    IN PCONFIGURATION_COMPONENT_DATA Component
    );

int
SlpFindStringInTable(
    IN PCHAR String,
    IN PCHAR *StringTable
    );

//
// FileTypeNames -- keep in sync with HwFileType enum!
//
PCHAR FileTypeNames[HwFileMax] = { "driver", "port"  , "class", "inf",
                                   "dll"   , "detect", "hal", "catalog"
                                 };

//
// RegistryTypeNames -- keep in sync with HwRegistryType enum!
//
PCHAR RegistryTypeNames[HwRegistryMax] = { "REG_DWORD", "REG_BINARY", "REG_SZ",
                                           "REG_EXPAND_SZ", "REG_MULTI_SZ"
                                         };

ULONG RegistryTypeMap[HwRegistryMax] = { REG_DWORD, REG_BINARY, REG_SZ,
                                         REG_EXPAND_SZ, REG_MULTI_SZ
                                       };


VOID
SlPromptOemScsi(
    IN POEM_SOURCE_DEVICE ScsiSourceDevice,
    IN BOOLEAN AllowUserSelection,        
    OUT POEMSCSIINFO *pOemScsiInfo
    )
/*++

Routine Description:

    Provides the user interface and logic for allowing the user to manually select
    SCSI adapters from the main INF file or the INF file on an OEM driver disk.

Arguments:

    ScsiSourceDevice - The OEM_SOURCE_DEVICE from which the the drivers need to 
        be loaded.
        
    AllowUserSelection - Whether user can interact while selecting the driver
        from txtsetup.oem driver list.

    pOemScsiInfo - Returns a linked list containing info about any third-party scsi
                   drivers selected.

Return Value:

    none.

--*/

{
    PVOID        OemScsiBase;
    PTCHAR       MessageString, ScsiDescription, MnemonicText;
    PCHAR        OemScsiName;
    BOOLEAN      Success, bFirstTime = TRUE, bRepaint;
    ULONG        x, y1, y2, ScsiDriverCount, NumToSkip;
    ULONG        c;
    TCHAR         Mnemonic;
    POEMSCSIINFO NewOemScsi, CurOemScsi;
    PDETECTED_DEVICE ScsiDevice;
    ULONG        OemScsiDriverCount = 0;
    PPREINSTALL_DRIVER_INFO CurrentDriver;
                         
    CurrentDriver = PreinstallDriverList;

    *pOemScsiInfo = CurOemScsi = NULL;

    MnemonicText = BlFindMessage(SL_SCSI_SELECT_MNEMONIC);
    Mnemonic = (TCHAR)_totupper(MnemonicText[0]);

    bRepaint = TRUE;
    
    while(1) {

        if( AllowUserSelection ) {
            if(bRepaint) {
                
                SlClearClientArea();

                if(bFirstTime) {
                    MessageString = BlFindMessage(SL_SCSI_SELECT_MESSAGE_1);
                } else if(Success) {
                    MessageString = BlFindMessage(SL_SCSI_SELECT_MESSAGE_3);
                } else {
                    MessageString = BlFindMessage(SL_SCSI_SELECT_ERROR);
                }
                x = 1;
                y1 = 4;
                SlGenericMessageBox(0, NULL, MessageString, &x, &y1, &y2, FALSE);
                y1 = y2 + 1;
                x = 4;

                //
                // Count all currently 'detected' SCSI devices.
                //
                for(ScsiDriverCount = 0, OemScsiDriverCount = 0, ScsiDevice = BlLoaderBlock->SetupLoaderBlock->ScsiDevices;
                    ScsiDevice;
                    ScsiDevice = ScsiDevice->Next) {
                    ScsiDriverCount++;
                    if( ScsiDevice->ThirdPartyOptionSelected ) {
                        OemScsiDriverCount++;
                    }
                }

                //
                // Display each loaded OEM miniport driver description.
                //
                if(OemScsiDriverCount) {

                    if(OemScsiDriverCount > MAX_SCSI_MINIPORT_COUNT) {
                        NumToSkip = ScsiDriverCount - (OemScsiDriverCount - MAX_SCSI_MINIPORT_COUNT);
                        //
                        // Display ellipses to indicate that top entries have scrolled out of view
                        //
                        SlGenericMessageBox(0,
                                            NULL,
                                            TEXT("..."),
                                            &x,
                                            &y1,
                                            &y2,
                                            FALSE
                                            );

                        y1 = y2 + 1;

                    } else {
                        NumToSkip = ScsiDriverCount - OemScsiDriverCount;
                        y1++;
                    }

                    ScsiDevice = BlLoaderBlock->SetupLoaderBlock->ScsiDevices;
                    while(NumToSkip && ScsiDevice) {
                        ScsiDevice = ScsiDevice->Next;
                        NumToSkip--;
                    }

                    while(ScsiDevice) {

                        SlGenericMessageBox(0,
                                            NULL,
                                            ScsiDevice->Description,
                                            &x,
                                            &y1,
                                            &y2,
                                            FALSE
                                            );

                        y1 = y2 + 1;
                        ScsiDevice = ScsiDevice->Next;
                    }
                } else {

                    y1++;
                    SlGenericMessageBox(0,
                                        NULL,
                                        BlFindMessage(SL_TEXT_ANGLED_NONE),
                                        &x,
                                        &y1,
                                        &y2,
                                        FALSE
                                        );
                    y1 = y2 + 1;
                }

                x = 1;
                y1++;
                SlGenericMessageBox(0,
                                    NULL,
                                    BlFindMessage(SL_SCSI_SELECT_MESSAGE_2),
                                    &x,
                                    &y1,
                                    &y2,
                                    FALSE
                                    );

                SlWriteStatusText(BlFindMessage(SL_SCSI_SELECT_PROMPT));

                bRepaint = FALSE;
            }
            c = SlGetChar();
        } else {
            c = ( CurrentDriver != NULL )? Mnemonic : ASCI_CR;
        }
        switch (c) {
            case SL_KEY_F3:
                SlConfirmExit();
                bRepaint = TRUE;
                break;

            case ASCI_CR:
                return;

            default:
                if(toupper(c) == Mnemonic) {
                    bFirstTime = FALSE;
                    bRepaint = TRUE;
                    
                    Success = SlpSelectHardware(ScsiSourceDevice,
                                    "SCSI",
                                    OEMSCSI,
                                    LoaderBootDriver,
                                    SL_PROMPT_SCSI,
                                    SL_PROMPT_OEM_SCSI,
                                    NULL,
                                    &OemScsiBase,
                                    &OemScsiName,
                                    &ScsiDescription,
                                    AllowUserSelection,
                                    (AllowUserSelection)? NULL  : CurrentDriver->DriverDescription,
                                    (BOOLEAN)((AllowUserSelection)? FALSE : CurrentDriver->OemDriver),
                                    &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase);

                    if(!AllowUserSelection) {
                        CurrentDriver  = CurrentDriver->Next;
                    }

                    if(Success) {
                        //
                        // Check to see if the driver loaded was an OEM SCSI driver.  If so,
                        // then add an OemScsiInfo entry onto the end of our list.
                        //
                        if(OemScsiBase) {

                            NewOemScsi = BlAllocateHeap(sizeof(OEMSCSIINFO));
                            if(!NewOemScsi) {
                                SlNoMemoryError();
                            }

                            if(CurOemScsi) {
                                CurOemScsi->Next = NewOemScsi;
                            } else {
                                *pOemScsiInfo = NewOemScsi;
                            }
                            CurOemScsi = NewOemScsi;

                            NewOemScsi->ScsiBase = OemScsiBase;
                            NewOemScsi->ScsiName = OemScsiName;
                            NewOemScsi->Next     = NULL;
                        }
                    }
                }
        }
    }
}


BOOLEAN
SlLoadOemScsiDriversUnattended(
    IN  POEM_SOURCE_DEVICE  OemSourceDevice,
    IN  PVOID               InfHandle,
    IN  PCHAR               ParamsSectionName,
    IN  PCHAR               RootDirKeyName,
    IN  PCHAR               BootDriversKeyName,
    IN  POEMSCSIINFO*       ScsiInfo,
    OUT PPNP_HARDWARE_ID*   HardwareIdDatabase    
    )
/*++

Routine Description:

    Loads the boot drivers (SCSI miniport only) specified in inf file
    in an unattended fashion

Arguments:

    OemSourceDevice - The OEM_SOURCE_DEVICE which contains the scsi
        mass storage drivers that need to be loaded.

    InfHandle - Handle to inf file (e.g. winnt.sif)

    ParamsSectionName - The section name which contains the boot driver
                        keys and values.

    RootDirKeyName - The key name whose value points to the root directory
                     under which all the different directories are present

    BootDriversKeyName - The key name which consits of multiple values of
                         one level subdirectory name which are present under
                         the specified root directory.

    ScsiInfo - Returns a linked list containing info about any third-party scsi
               drivers loaded.               

    HardwareIdDatabase - Hardware Ids of the device which the loaded driver supports

Return Value:

    TRUE, if successful otherwise FALSE

--*/
{
    BOOLEAN LoadResult = FALSE;

    if (InfHandle) {
        POEMSCSIINFO    CurrOemScsi = NULL;
        ULONG           Index = 0;
        PCHAR           DriverDir = SlGetSectionKeyIndex(InfHandle,
                                        ParamsSectionName,
                                        BootDriversKeyName,
                                        Index);
        PCHAR           DriverRoot = SlGetSectionKeyIndex(InfHandle,
                                        ParamsSectionName,
                                        RootDirKeyName,
                                        0); 
        ULONG           RootLength = DriverRoot ? strlen(DriverRoot) : 0;

        //
        // DriverRoot and DriverDir need to have valid values 
        // in specified ParamsSectionName
        //
        LoadResult = (DriverDir && DriverRoot);                                

        while (DriverDir && LoadResult) {
            CHAR            FullDriverDir[256];
            DETECTED_DEVICE DetectedDevice = {0};
            PVOID           ImageBase = NULL;
            PCHAR           ImageName = NULL;
            PTCHAR          DriverDescription = NULL;

            //
            // Create the full path of the driver directory relative
            // to the boot directory
            //
            if (RootLength) {
                strcpy(FullDriverDir, DriverRoot);
                strcat(FullDriverDir, "\\");
            } else {
                FullDriverDir[0] = 0;
            }

            strcat(FullDriverDir, DriverDir);

            //
            // Load the driver and related files, in an unattended manner
            //
            LoadResult = SlpOemDiskette(OemSourceDevice,
                            "SCSI",
                            OEMSCSI,
                            0,
                            &DetectedDevice,
                            &ImageBase,
                            &ImageName,
                            &DriverDescription,
                            FALSE,
                            NULL,
                            HardwareIdDatabase,
                            FullDriverDir,
                            TRUE);

            if (LoadResult) {        
                //
                // If the load was successful, then create and add the information
                // ScsiInfo
                //
                if (ImageBase && ScsiInfo) {
                    POEMSCSIINFO    NewScsi = (POEMSCSIINFO)BlAllocateHeap(sizeof(OEMSCSIINFO));

                    if (!NewScsi) {
                        SlNoMemoryError();
                    }

                    RtlZeroMemory(NewScsi, sizeof(OEMSCSIINFO));
                    NewScsi->ScsiBase = ImageBase;
                    NewScsi->ScsiName = ImageName;

                    if (CurrOemScsi) {
                        CurrOemScsi->Next = NewScsi;
                    } else {
                        *ScsiInfo = NewScsi;
                    }

                    CurrOemScsi = NewScsi;                    
                }

                //
                // Get the next driver directory to process
                //
                Index++;
                DriverDir = SlGetSectionKeyIndex(InfHandle,
                                ParamsSectionName,
                                BootDriversKeyName,
                                Index);
            }                                
        }
    }

    return LoadResult;
}


VOID
SlPromptOemHal(
    IN POEM_SOURCE_DEVICE HalSourceDevice,
    IN BOOLEAN AllowUserSelection,
    OUT PVOID *HalBase,
    OUT PCHAR *HalName
    )

/*++

Routine Description:

    Provides the user interface and logic for allowing the user to manually select
    a HAL from the main INF file or the INF file on an OEM driver disk.

Arguments:

    HalSourceDevice - The OEM_SOURCE_DEVICE which contains the HAL that needs
        to be loaded.

    AllowUserSelection - Indicates whether user can interact while selecting the
        OEM hal from the list specified in txtsetup.oem.

    HalBase - Returns the address where the HAL was loaded into memory.

    HalName - Returns the name of the HAL that was loaded.

Return Value:

    ESUCCESS - HAL successfully loaded.

--*/

{
    BOOLEAN Success;
    
    do {
        Success = SlpSelectHardware(HalSourceDevice,
                        "Computer",
                        OEMHAL,
                        LoaderHalCode,
                        SL_PROMPT_HAL,
                        SL_PROMPT_OEM_HAL,
                        &BlLoaderBlock->SetupLoaderBlock->ComputerDevice,
                        HalBase,
                        HalName,
                        NULL,
                        AllowUserSelection,
                        ComputerType,
                        OemHal,
                        &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase);

    } while ( !Success );

}


VOID
SlPromptOemVideo(
    IN POEM_SOURCE_DEVICE VideoSourceDevice,
    IN BOOLEAN AllowUserSelection,
    OUT PVOID *VideoBase,
    OUT PCHAR *VideoName
    )

/*++

Routine Description:

    Provides the user interface and logic for allowing the user to manually select
    a video adapter from the main INF file or the INF file on an OEM driver disk.

Arguments:

    VideoSourceDevice - The OEM_SOURCE_DEVICE which contains the video driver that 
        needs to be loaded.

    AllowUserSelection - Indicates whether user can interact while selecting the
        driver from the list specified in txtsetup.oem.
        
    VideoBase - Returns the address where the video driver was loaded

    VideoName - Returns a pointer to the name of the video driver

Return Value:

    None.

--*/

{
    BOOLEAN Success;

    do {
        Success = SlpSelectHardware(VideoSourceDevice,
                        "display",
                        OEMOTHER,
                        LoaderBootDriver,
                        SL_PROMPT_VIDEO,
                        SL_PROMPT_OEM_VIDEO,
                        &BlLoaderBlock->SetupLoaderBlock->VideoDevice,
                        VideoBase,
                        VideoName,
                        NULL,
                        AllowUserSelection,
                        NULL,
                        FALSE,
                        &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase);

    } while ( !Success );

}


BOOLEAN
SlpSelectHardware(
    IN POEM_SOURCE_DEVICE SourceDevice,
    IN PCHAR ComponentName,
    IN OEMFILETYPE ComponentType,
    IN TYPE_OF_MEMORY MemoryType,
    IN ULONG MenuHeaderId,
    IN ULONG OemMenuHeaderId,
    OUT OPTIONAL PDETECTED_DEVICE DetectedDevice,
    OUT PVOID *ImageBase,
    OUT OPTIONAL PCHAR *ImageName,
    OUT OPTIONAL PTCHAR *DriverDescription,
    IN BOOLEAN AllowUserSelection,
    IN PTCHAR PreInstallComponentDescription,
    IN BOOLEAN PreInstallOemComponent,
    OUT PPNP_HARDWARE_ID* HardwareIdDatabase
    )

/*++

Routine Description:

    Present the user with a menu of options for the selected device class.
    This menu will consist of options listed in the main inf plus a single
    oem option if one is currently selected, plus additional items in the
    system partition inf for the component if specified (ARC machines).

    When the user makes a selection, forget any previous OEM option (except
    for SCSI).  If the user selects an option supplied by us, set up the
    SELECTED_DEVICE structure and return. Otherwise prompt for a manufacturer-
    supplied diskette.

Arguments:

    SourceDevice - The device which contains the driver/hal that needs to 
        be loaded.
    
    ComponentName - Supplies the name of the component to be presented.

    ComponentType - Supplies the type of the component (HAL, SCSI, or Other)

    MemoryType - Supplies the type of memory used to load the image.

    MenuHeaderId - Supplies the ID of the menu header to be displayed

    OemMenuHeaderId - Supplies the ID of the menu header to be displayed
            when an OEM selection is to be made.

    DetectedDevice - returns the DeviceId of the selected device.  If an
            OEM diskette is required, the necessary OEM structures will
            be allocated and filled in.  (This field is ignored for SCSI
            components.)

    ImageBase - Returns the base of the image that was loaded.

    ImageName - Returns the filename of the image.

    DriverDescription - If specified, returns the description of the loaded
                        device.

    AllowUserSelection - Indicates whether or not user is allowed to select
                         a driver. This flag is typically set to FALSE when
                         pre-installing components defined in unattend.txt.

    PreInstallComponentDescription - In the pre-install mode, points to the string
                                     that identifies the component to pre-install.
                                     It is NULL if AllowUserSelction is TRUE.

    PreInstallOemComponent - In the pre-install mode, this flag indicates
                             whether or not the component to pre-install is
                             an OEM or RETAIL component.


Return Value:

    TRUE - Success

    FALSE - The user has escaped out of the dialog

--*/

{
    PSL_MENU Menu;
    LONG Selection;
    LONG OtherSelection = 0;
    TCHAR OtherSelectionName[80];
    PTCHAR p;
    ULONG c, i;
    PCHAR AdapterName;
    CHAR Buffer[80];
    PCHAR FileName;
    PTCHAR FileDescription;
    ARC_STATUS Status;
    BOOLEAN b;
    ULONG Ordinal;
    SCSI_INSERT_STATUS sis;

    if( AllowUserSelection ) {
        if(ComponentType != OEMSCSI) {
            Menu = SlCreateMenu();
            if (Menu==NULL) {
                SlNoMemoryError();
                return(FALSE);
            }

            //
            // Build a list of options containing the drivers we ship and the
            // currently selected OEM option (if any).
            //

            c = SlpAddSectionToMenu(InfFile,
                                    ComponentName,
                                    Menu);
            //
            // Add selection for "other"
            //
            _tcsncpy(OtherSelectionName,
                    BlFindMessage(SL_TEXT_OTHER_DRIVER),
                    80
                    );
            OtherSelectionName[79] = TEXT('\0');
            //
            // Use text up to the first CR or LF.
            //
            for(p = OtherSelectionName; *p; p++) {
                if((*p == TEXT('\n')) || (*p == TEXT('\r'))) {
                    *p = TEXT('\0');
                    break;
                }
            }

            OtherSelection = SlAddMenuItem(Menu,
                                           OtherSelectionName,
                                           (PVOID)-1,
                                           0);

            //
            // Default is "other"
            //
            Selection = OtherSelection;
        } else {
            //
            //  For SCSI devices we don't display any list of drivers for the user to choose.
            //  We just prompt for the OEM disk, this is because we always load all SCSI drivers
            //  in the NT product, due to pnp requirements.
            //
            //
            // Default is "other"
            //
            Selection = OtherSelection;
        }            
    } else {
        //
        //  This is a pre-install. Find out if the component to pre-install
        //  is RETAIL or OEM.
        //
        OtherSelection = SlCountLinesInSection( InfFile,
                                                ComponentName );
        if( PreInstallOemComponent ) {
            //
            //  Pre-installing an OEM component
            //
            Selection = OtherSelection;
        } else {
            //
            //  Pre-installing a RETAIL component
            //
            PCHAR   q;
            q = SlPreInstallGetComponentName( InfFile,
                                              ComponentName,
                                              PreInstallComponentDescription );
            if (q==NULL) {
                //
                // we have enumerated the entire section without finding a
                // match, return failure.
                //
                SlFatalError(SL_BAD_UNATTENDED_SCRIPT_FILE,
                             PreInstallComponentDescription,
                             SlCopyStringAT(ComponentName),
                             TEXT("txtsetup.sif"));
                goto SelectionAbort;
            }

            Selection = SlGetSectionKeyOrdinal( InfFile,
                                                ComponentName,
                                                q );
        }
    }

    //
    // Allow the user to interact with the menu
    //
    while (1) {
        if( AllowUserSelection ) {
            SlClearClientArea();
            p = BlFindMessage(SL_SELECT_DRIVER_PROMPT);
            if (p) {
                SlWriteStatusText(p);
            }

            if(ComponentType != OEMSCSI) {
                c = SlDisplayMenu(MenuHeaderId,
                                  Menu,
                                  &Selection);
            } else {
                //
                //  For SCSI devices, we don't display any list of driver for the user to chose
                //
                c = ASCI_CR;
            }
        } else {
            c = ASCI_CR;
        }
        switch (c) {
            case SL_KEY_F3:
                SlConfirmExit();
                break;

            case ASCI_ESC:
                goto SelectionAbort;

            case ASCI_CR:
                if (Selection == OtherSelection) {
                    //
                    // User selected "other"  Prompt for OEM diskette
                    //
                    b = SlpOemDiskette(SourceDevice,
                            ComponentName,
                            ComponentType,
                            OemMenuHeaderId,
                            DetectedDevice,
                            ImageBase,
                            ImageName,
                            DriverDescription,
                            AllowUserSelection,
                            PreInstallComponentDescription,
                            HardwareIdDatabase,
                            NULL,
                            TRUE);


                    SlClearClientArea();
                    SlWriteStatusText(TEXT(""));
                    return(b);

                } else {
                    //
                    // User selected a built-in.  Go ahead and load
                    // it here.
                    //

                    if(ComponentType == OEMHAL) {
                        //
                        // We are looking for a HAL. If we're doing a remote
                        // boot, look in the [Hal] section. Otherwise, look in
                        // the [Hal.Load] section. (Local setup has a separate
                        // section to minimize the number of HAL binaries that
                        // need to be on the boot floppies.)
                        //
                        strcpy(Buffer, BlBootingFromNet ? "Hal" : "Hal.Load");
                    } else {
                        sprintf(Buffer, "%s.Load", ComponentName );
                    }

                    AdapterName = SlGetKeyName(InfFile,
                                               ComponentName,
                                               Selection
                                               );
                    if(AdapterName==NULL) {
                        SlFatalError(SL_BAD_INF_FILE, TEXT("txtsetup.sif"), ENODEV);
                        goto SelectionAbort;
                    }

                    FileName = SlGetIniValue(InfFile,
                                             Buffer,
                                             AdapterName,
                                             NULL);

                    if((FileName==NULL) && (ComponentType == OEMHAL)) {
                        FileName = SlGetIniValue(InfFile,
                                                 "Hal",
                                                 AdapterName,
                                                 NULL);
                        FileDescription = SlCopyString(BlFindMessage(SL_HAL_NAME));
                    } else {              
#ifdef UNICODE
                        FileDescription = SlGetIniValueW(
#else
                        FileDescription = SlGetIniValue(
#endif
                                                        InfFile,
                                                        ComponentName,
                                                        AdapterName,
                                                        NULL);
                    }

                    if(FileName==NULL) {
                        SlFatalError(SL_BAD_INF_FILE, TEXT("txtsetup.sif"), EBADF);
                        goto SelectionAbort;
                    }

                    if(ARGUMENT_PRESENT(ImageName)) {
                        *ImageName = FileName;
                    }

                    if(ARGUMENT_PRESENT(DriverDescription)) {
                        *DriverDescription = FileDescription;
                    }

                    //
                    // If we're doing OEM SCSI, then get a properly-inserted
                    // DETECTED_DEVICE structure
                    //
                    if(ComponentType == OEMSCSI) {
                        //
                        // Find this adapter's ordinal within the Scsi.Load section of txtsetup.sif
                        //
                        Ordinal = SlGetSectionKeyOrdinal(InfFile, Buffer, AdapterName);
                        if(Ordinal == (ULONG)-1) {
                            SlFatalError(SL_BAD_INF_FILE, TEXT("txtsetup.sif"), EINVAL);
                            goto SelectionAbort;
                        }

                        //
                        // Create a new detected device entry.
                        //
                        if((sis = SlInsertScsiDevice(Ordinal, &DetectedDevice)) == ScsiInsertError) {
                            SlFriendlyError(ENOMEM, "SCSI detection", __LINE__, __FILE__);
                            goto SelectionAbort;
                        }


                        if(sis == ScsiInsertExisting) {
#if DBG
                            //
                            // Sanity check to make sure we're talking about the same driver
                            //
                            if(_stricmp(DetectedDevice->BaseDllName, FileName)) {
                                SlError(400);
                                goto SelectionAbort;
                            }
#endif
                        }
                    }

                    DetectedDevice->IdString = AdapterName;
                    DetectedDevice->Description = FileDescription;
                    DetectedDevice->ThirdPartyOptionSelected = FALSE;
                    DetectedDevice->FileTypeBits = 0;
                    DetectedDevice->Files = NULL;
                    DetectedDevice->BaseDllName = FileName;

                    //
                    // We only want to load the image if we're not doing SCSI.
                    //
                    if(ComponentType != OEMSCSI) {
                        sprintf(Buffer, "%s%s", BootPath, FileName);
                        SlGetDisk(FileName);

#ifdef i386
retryhal:
#endif
                        BlOutputLoadMessage(BootDevice, FileName, FileDescription);
                        Status = BlLoadImage(BootDeviceId,
                                             LoaderHalCode,
                                             Buffer,
                                             TARGET_IMAGE,
                                             ImageBase
                                             );
#ifdef i386
                        //
                        // If the HAL didn't fit in the preferred range, reset the range to
                        // all of memory and try again.
                        //
                        if ((Status == ENOMEM) &&
                            ((BlUsableBase != 0) ||
                             (BlUsableLimit != _16MB))) {
                            BlUsableBase = 0;
                            BlUsableLimit = _16MB;

                            goto retryhal;
                        }
#endif
                    } else {
                        *ImageBase = NULL;
                        Status = ESUCCESS;
                    }
                }

                if (Status != ESUCCESS) {
                    SlMessageBox(SL_FILE_LOAD_FAILED,Buffer,Status);
                    goto SelectionAbort;
                }

                SlClearClientArea();
                SlWriteStatusText(TEXT(""));
                return(TRUE);

            default:
                break;
        }
    }

SelectionAbort:
    SlClearClientArea();
    SlWriteStatusText(TEXT(""));
    return FALSE;
}


ARC_STATUS
SlGetDriverTimeStampFromFile(
  IN ULONG DeviceId,
  IN PCHAR DriverPath,
  OUT PULONG TimeDateStamp
  )
/*++

Routine Description:

  Gets the driver's link time stamp from the the image
  header.

Arguments:

  DeviceId : Device on which the driver file resides (e.g. floppy)

  DriverPath : Full qualified path of the driver file

  TimeDateStamp : Place holder to return the image header time stamp

Return Value:

  ESUCCESS if successful, otherwise appropriate error code.

--*/
{
  ARC_STATUS  Status = EINVAL;

  if (DriverPath && TimeDateStamp) {
    UCHAR UBuffer[SECTOR_SIZE * 2 + 256] = {0};
    UCHAR *Buffer = ALIGN_BUFFER(UBuffer);
    ULONG FileId = 0;

    //
    // open the file
    //
    Status = BlOpen(DeviceId, DriverPath, ArcOpenReadOnly, &FileId);

    if (Status == ESUCCESS) {
      ULONG BytesToRead = SECTOR_SIZE * 2;
      ULONG BytesRead = 0;

      //
      // read the first two sectors of the file
      //
      Status = BlRead(FileId, Buffer, BytesToRead, &BytesRead);

      if ((Status == ESUCCESS) && (BytesToRead == BytesRead)) {
        PIMAGE_NT_HEADERS ImgHdr = RtlImageNtHeader(Buffer);
        Status = EINVAL;

        if (ImgHdr) {
          *TimeDateStamp = ImgHdr->FileHeader.TimeDateStamp;
          Status = ESUCCESS;
        }
      }

      BlClose(FileId);
    }
  }

  return Status;
}

BOOLEAN
SlRemoveInboxDriver(
  IN PCHAR DriverToRemove
  )
/*++

Routine Description:

  Removes the given driver name from list of the
  SCSI miniport devices that need to be loaded as default
  boot driver.

Arguments:

  DriverToRemove : Driver base name, that needs to be removed

Return Value:

  TRUE, if the driver was found and removed otherwise FALSE

--*/
{
  BOOLEAN Result = FALSE;

  if (DriverToRemove) {
    PDETECTED_DEVICE NodePtr = BlLoaderBlock->SetupLoaderBlock->ScsiDevices;
    PDETECTED_DEVICE PrevNode = NULL;

    while (NodePtr) {
      if (NodePtr->BaseDllName && !_stricmp(NodePtr->BaseDllName, DriverToRemove))
        break;

      PrevNode = NodePtr;
      NodePtr = NodePtr->Next;
    }

    if (NodePtr) {
      if (PrevNode) {
        PrevNode->Next = NodePtr->Next;
        Result = TRUE;
      } else {
        if (NodePtr == BlLoaderBlock->SetupLoaderBlock->ScsiDevices) {
          BlLoaderBlock->SetupLoaderBlock->ScsiDevices = NULL;
          Result = TRUE;
        }
      }
    }
  }

  return Result;
}

ARC_STATUS
SlConstructDriverPath(
  IN PDETECTED_DEVICE Device,
  IN PCHAR DefaultPath,
  OUT PCHAR FullPath
  )
/*++

Routine Description:

  Constructs a fully qualified driver path given the device node.

Arguments:

  Device : The device for which the path needs to be created.

  Defaultpath : Directory path to use, if device does not has file list.

  FullPath : Placeholder to return the constructed path

Return Value:

  ESUCCESS if path is constructed, otherwise a proper error code.

--*/
{
  ARC_STATUS  Status = EINVAL;

  if (Device && FullPath) {
    PDETECTED_DEVICE_FILE  Node = Device->Files;

    //
    // locate the driver file
    //
    while (Node) {
      HwFileType  FileType = Node->FileType;

      if((FileType == HwFilePort) || (FileType == HwFileClass) ||
          (FileType == HwFileDriver) || (FileType == HwFileHal)) {
        break;
      }

      Node = Node->Next;
    }

    if (Node && Node->Filename) {
      *FullPath = '\0';

      if (Node->Directory)
        strcat(FullPath, Node->Directory);

      //
      // append separator only if directory-name does not have
      // trailing separator or the the filename does
      // not have a leading separator
      //
      if ((Node->Filename[0] != '\\') && (*FullPath) &&
          (FullPath[strlen(FullPath) - 1] != '\\')) {
        strcat(FullPath, "\\");
      }

      strcat(FullPath, Node->Filename);
      Status = ESUCCESS;
    } else {
      if (DefaultPath && Device->BaseDllName) {
        //
        // default path has a valid trailing separator
        //
        strcpy(FullPath, DefaultPath);
        strcat(FullPath, Device->BaseDllName);
        Status = ESUCCESS;
      }
    }

    if (Status != ESUCCESS)
      *FullPath = '\0';
  }


  return Status;
}

VERSION_COMP_RESULT
SlCompareDriverVersion(
  IN ULONG InboxDeviceId,
  IN PDETECTED_DEVICE InboxDriver,
  IN ULONG OemDeviceId,
  IN PDETECTED_DEVICE OemDriver
  )
/*++

Routine Description:

  Compares the version of an inbox driver and  oem driver
  based on the link date-time stamp present in the image
  header.

Arguments:

  InboxDeviceId : Boot device ID

  InboxDriver : Device containing inbox driver details

  OemDeviceId : Oem device ID (either floppy or boot device)

  OemDriver : Device containing OEM driver details

Return Value:

  VersionErr if not able to get version information for the
  drivers, otherwise one of the following appropriately :
  VersionSame, VersionOemNew, VersionInboxNew

--*/
{
  VERSION_COMP_RESULT Result = VersionError;

  if (InboxDriver && OemDriver) {
    CHAR  FullPath[256];
    ULONG InboxDateTime = 0, OemDateTime = 0;
    ARC_STATUS Status;

    Status = SlConstructDriverPath(InboxDriver, BootPath, FullPath);

    if (Status == ESUCCESS) {
      Status = SlGetDriverTimeStampFromFile(InboxDeviceId,
                  FullPath, &InboxDateTime);

      if (Status == ESUCCESS) {
        Status = SlConstructDriverPath(OemDriver, NULL, FullPath);

        if (Status == ESUCCESS) {
          Status = SlGetDriverTimeStampFromFile(OemDeviceId,
                      FullPath, &OemDateTime);
        }
      }
    }

    if ((Status == ESUCCESS) && InboxDateTime && OemDateTime) {
      if (InboxDateTime != OemDateTime) {
        Result = (InboxDateTime > OemDateTime) ?
            VersionInboxNew : VersionOemNew;
      } else {
        Result = VersionSame;
      }
    }
  }

  return Result;
}

BOOLEAN
SlConfirmInboxDriverReplacement(
  IN PTCHAR DriverName,
  IN PTCHAR AdditionalInfo
  )
/*++

Routine Description:

  Puts up a dialog box on the screen giving information about
  the same inbox driver and oem driver being loaded, asking
  for user selection i.e. either OEM or INBOX driver.

Arguments:

  DriverName : Driver name which is same for inbox and OEM

  AdditionalInfo : Which driver is newer i.e. either OEM or
  Inbox or nothing if could not determine which driver is
  newer.

Return Value:

  TRUE if the user selected to replace default driver with OEM
  driver, otherwise return FALSE indicating that user wants
  to use inbox driver.

--*/
{
  ULONG KeyPressed = 0;
  PTCHAR MnemonicText = BlFindMessage(SL_SCSI_SELECT_MNEMONIC);
  ULONG Mnemonic = MnemonicText ? toupper(MnemonicText[0]) : 'S';

  if (AdditionalInfo) {
    ULONG Len = _tcslen(AdditionalInfo);

    if ((Len >= 2) && (AdditionalInfo[Len-2] == TEXT('\r')) &&
         (AdditionalInfo[Len-1] == TEXT('\n'))) {
      AdditionalInfo[Len-2] = TEXT('\0');
    }
  }

  if (DriverName) {
    SlClearClientArea();
    SlDisplayMessageBox(SL_OEM_DRIVERINFO, AdditionalInfo, DriverName);
    SlWriteStatusText(BlFindMessage(SL_CONFIRM_OEMDRIVER));

    do {
      KeyPressed = SlGetChar();
      KeyPressed = toupper(KeyPressed);
    }
    while ((KeyPressed != ASCI_CR) && (KeyPressed != Mnemonic));

    SlClearClientArea();
    SlWriteStatusText(TEXT(""));
  }

  return (KeyPressed == Mnemonic);
}

PDETECTED_DEVICE
SlCheckForInboxDriver(
  IN PCHAR DriverToCheck
  )
/*++

Routine Description:

  Searches the inbox SCSI miniport list to see if a driver
  of the given name exists.

Arguments:

  DriverToCheck : Base driver name to look for, in the list

Return Value:

  Pointer to device node containing driver information, if the
  given driver name is found, otherwise NULL

--*/
{
  PDETECTED_DEVICE  NodePtr = NULL;

  if (DriverToCheck) {
    NodePtr = BlLoaderBlock->SetupLoaderBlock->ScsiDevices;

    while (NodePtr) {
      if (NodePtr->BaseDllName && !_stricmp(NodePtr->BaseDllName, DriverToCheck)) {
        break;
      }

      NodePtr = NodePtr->Next;
    }
  }

  return NodePtr;
}



BOOLEAN
SlpOemDiskette(
    IN POEM_SOURCE_DEVICE OemSourceDevice,
    IN PCHAR ComponentName,
    IN OEMFILETYPE ComponentType,
    IN ULONG MenuHeaderId,
    OUT OPTIONAL PDETECTED_DEVICE DetectedDevice,
    OUT PVOID *ImageBase,
    OUT OPTIONAL PCHAR *ImageName,
    OUT OPTIONAL PTCHAR *DriverDescription,
    IN BOOLEAN  AllowUserSelection,
    IN PTCHAR    PreInstallComponentDescription,
    OUT PPNP_HARDWARE_ID* HardwareIdDatabase,
    IN PCHAR    DriverDir,
    IN BOOLEAN  InsertDevice
    )

/*++

Routine Description:

    Prompt for an oem driver diskette and read the oem text inf file
    from it.  Present the choices for the device class to the user and
    allow him to select one.

    Remember information about the selection the user has made.

Arguments:

    OemSourceDevice - The device which contains the driver/hal that 
        needs to be loaded.
        
    ComponentName - Supplies name of component to look for.

    ComponentType - Supplies the type of the component (HAL, SCSI, or Other)

    MenuHeaderId - Supplies ID of menu header to be displayed

    DetectedDevice - Returns information about the device seleceted

    ImageBase - Returns image base of loaded image

    ImageName - Returns filename of loaded image

    DriverDescription - If specified, returns description of loaded driver

    AllowUserSelection - Indicates whether or not user is allowed to select
                         a driver. This flag is typically set to FALSE when
                         pre-installing components defined in unattend.txt.

    PreInstallComponentDescription - In the pre-install mode, points to the string
                                     that identifies the component to pre-install.
                                     It is NULL if AllowUserSelction is TRUE.

    HardwareIdDatabase - The hardware IDs what were loaded for the particular
        driver.
    
    DriverDir - The driver directory which has the dynamic update driver. The 
                path is relative to the boot directory. This value indicates
                that the driver to be loaded is dyamic update boot driver.

    InsertDevice - Indicates whether to insert the device into the detected
        device list or not. Currently only valid for SCSI mass storage device
        drivers.
        
Return Value:

    TRUE if the user made a choice, FALSE if the user cancelled/error occurred.

--*/

{
    static CHAR LoadDeviceName[128];
    ULONG LoadDeviceId = -1;
    PVOID OemInfHandle = NULL;
    ULONG Error;
    ARC_STATUS Status;
    ULONG Count;
    ULONG DefaultSelection;
    PTCHAR DefaultSelText = NULL;
    PCHAR p;
    PSL_MENU Menu;
    ULONG c;
    PMENU_ITEM_DATA Data;
    PDETECTED_DEVICE_FILE FileStruct;
    BOOLEAN bDriverLoaded;
    HwFileType filetype;
    PDETECTED_DEVICE prev, cur;
    static CHAR FullDriverPath[256];
    ULONG DirectoryLength;
    BOOLEAN SeparatorNeeded;
    static CHAR FilePath[256];
    PCHAR OemComponentId = NULL;
    PTCHAR OemComponentDescription;
    DETECTED_DEVICE TempDevice;
    static TCHAR ScratchBuffer[256] = {0};
    PDETECTED_DEVICE InboxDevice;
    BOOLEAN DynamicUpdate = FALSE;
    BOOLEAN Preinstallation = FALSE;
    BOOLEAN DeviceOpened = FALSE;

    //
    // If source device is specified, then probe it and
    // extract some required state information
    //
    if (OemSourceDevice) {
        if (SL_OEM_SOURCE_DEVICE_TYPE(OemSourceDevice,
                SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE)) {
            DynamicUpdate = TRUE;                
        }                            

        if (SL_OEM_SOURCE_DEVICE_TYPE(OemSourceDevice,
                SL_OEM_SOURCE_DEVICE_TYPE_PREINSTALL)) {
            Preinstallation = TRUE;                
        }
        
        //
        // Is the inf already opened ?
        //
        if (!DynamicUpdate && OemSourceDevice->InfHandle &&
            !SL_OEM_SOURCE_DEVICE_STATE(OemSourceDevice,
                SL_OEM_SOURCE_DEVICE_PROCESSED)) {
            OemInfHandle = OemSourceDevice->InfHandle;
        }            

        LoadDeviceId = OemSourceDevice->DeviceId;        
    }                                

    if (AllowUserSelection) {
        SlClearClientArea();
    }        

    if (AllowUserSelection) {
        //
        // Only try to detect floppy 0 if no source device
        // specified
        //
        if (OemSourceDevice) {
            strcpy(LoadDeviceName, OemSourceDevice->ArcDeviceName);
            LoadDeviceId = OemSourceDevice->DeviceId;
        } else {
            //
            // Compute the name of the A: drive
            //
            if (!SlpFindFloppy(0, LoadDeviceName)) {
                ULONG UserInput;
                
                //
                // No floppy drive available, bail out.
                //
                SlClearClientArea();
                SlDisplayMessageBox(SL_NO_FLOPPY_DRIVE);

                do {
                    UserInput = SlGetChar();
                } 
                while ((UserInput != ASCI_ESC) && (UserInput != SL_KEY_F3));

                if (UserInput == SL_KEY_F3) {
                    ArcRestart();
                }

                SlClearClientArea();
                
                return  FALSE;
            }
        }

        //
        // Open the device if its not already done
        //
        if (LoadDeviceId == -1) {
            //
            // Prompt for the disk.
            //
            while(1) {
                if (!SlPromptForDisk(BlFindMessage(SL_OEM_DISK_PROMPT), TRUE)) {
                    return(FALSE);
                }

                Status = ArcOpen(LoadDeviceName, ArcOpenReadOnly, &LoadDeviceId);

                if(Status == ESUCCESS) {
                    DeviceOpened = TRUE;
                    break;
                }
            }
        }            
    }

    //
    // Load the OEM INF file
    //
    if( AllowUserSelection ) {
        *FilePath = *FullDriverPath = '\0';
    } else {
        PCHAR   p;

        if (DynamicUpdate || Preinstallation) {
            strcpy(FilePath, BootPath);
        } else {
            *FilePath = '\0';
        }
        
        if (DynamicUpdate && DriverDir) {
            //
            // In case of dynamic update boot drivers
            // the path to txtsetup.oem needs to be fully
            // qualified from the boot directory
            //
            strcat(FilePath, DriverDir);
        } 

        if (PreInstall) {
#if defined(_X86_)
            if ( BlBootingFromNet ) {
#endif
                //
                //  On RISC platforms and on x86 remote boot clients,
                //  remove the platform specific directory from the path.
                //
                p =  (FilePath + strlen(FilePath) - 1);

                if( *p == '\\' ) {
                    *p = '\0';
                }
                
                p = strrchr(FilePath, '\\');
                
                *(p+1) = '\0';
#if defined(_X86_)
            }
#endif
        
            //
            //  Note that on x86 the path to txtsetup.oem is going to be:
            //      $win_nt$.~bt\$OEM$
            //  while on non-x86 platforms, the path is going to be:
            //      $win_nt$.~ls\$OEM$\TEXTMODE
            //  but on remote boot clients, the path is going to be:
            //      \device\lanmanredirector\server\reminst\setup\language\images\build\$OEM$\TEXTMODE
            //
            strcat(
                FilePath,
#if defined(_X86_)
                BlBootingFromNet ? WINNT_OEM_TEXTMODE_DIR_A : WINNT_OEM_DIR_A
#else
                WINNT_OEM_TEXTMODE_DIR_A
#endif
              );
        }             
        
        //
        //  Save the path to the directory that contains txtsetup.oem.
        //  It will be used later on, when we load the driver.
        //
        strcpy(FullDriverPath, FilePath);
        strcat(FilePath, "\\");
    }
    
    //
    //  Now form the path to txtsetup.oem
    //
    strcat(FilePath, "txtsetup.oem");

    //
    // Note : Reload the txtsetup.oem again in dynamic update boot driver case
    //        since for each driver the txtsetup.oem is different in its own
    //        downloaded directory
    //
    if (!OemInfHandle) {
        if (DriverDir || AllowUserSelection || (PreInstallOemInfHandle == NULL)) {        
            Status = SlInitIniFile(NULL,
                                   LoadDeviceId,
                                   FilePath,
                                   &OemInfHandle,
                                   NULL,
                                   NULL,
                                   &Error);
                                   
            if (Status != ESUCCESS) {
                SlFriendlyError(Status, "txtsetup.oem", __LINE__, __FILE__);
                goto OemLoadFailed;
            }
            
            if( !AllowUserSelection ) {
                PreInstallOemInfHandle = OemInfHandle;
            }
        } else {
            OemInfHandle = PreInstallOemInfHandle;
        }
    }        

    Count = SlCountLinesInSection(OemInfHandle, ComponentName);
    
    if(Count == (ULONG)(-1)) {
        SlMessageBox(SL_WARNING_SIF_NO_COMPONENT);
        goto OemLoadFailed;
    }

    //
    // Get the text of the default choice
    //
    if (!PreInstallComponentDescription) {
        if(p = SlGetSectionKeyIndex(OemInfHandle, "Defaults",ComponentName, 0)) {
#ifdef UNICODE
            DefaultSelText = SlGetSectionKeyIndexW(
#else
            DefaultSelText = SlGetSectionKeyIndex(
#endif                        
                                                OemInfHandle,
                                                ComponentName,
                                                p,
                                                0);

            //
            // Save away the component id
            //
            OemComponentId = p;                                                
        } else {
            DefaultSelText = NULL;
        }            
    } else {
        DefaultSelText = PreInstallComponentDescription;
    }

    //
    // In case of dynamic update drivers, if the defaults is not set then
    // use the first entry in the section as the default !!!
    //
    if (DynamicUpdate && !AllowUserSelection && !DefaultSelText) {
        OemComponentId = SlGetKeyName(
                            OemInfHandle, 
                            ComponentName, 
                            0);
    }    

    if( AllowUserSelection ) {
        //
        // Build menu
        //
        Menu = SlCreateMenu();
        
        if (Menu==NULL) {
            SlNoMemoryError();
        }
        
        SlpAddSectionToMenu(OemInfHandle,ComponentName,Menu);

        //
        // Find the index of the default choice
        //
        if(!DefaultSelText ||
           !SlGetMenuItemIndex(Menu,DefaultSelText,&DefaultSelection)) {
            DefaultSelection=0;
        }
    }

    //
    // Allow the user to interact with the menu
    //
    while (1) {
        if( AllowUserSelection ) {
            SlClearClientArea();
            SlWriteStatusText(BlFindMessage(SL_SELECT_DRIVER_PROMPT));

            c = SlDisplayMenu(MenuHeaderId,
                              Menu,
                              &DefaultSelection);
        } else {
            c = ASCI_CR;
        }
        
        switch (c) {
            case SL_KEY_F3:
                SlConfirmExit();
                break;

            case ASCI_ESC:
                return(FALSE);
                break;

            case ASCI_CR:
                //
                // User selected an option, fill in the detected
                // device structure with the information from the
                // INF file.
                //

                if (!DetectedDevice) {
                  RtlZeroMemory(&TempDevice, sizeof(DETECTED_DEVICE));
                  DetectedDevice = &TempDevice;
                }
                                               
                //
                // We create a new device using SlInsertScsiDevice(...) only if we load
                // the requested SCSI miniport successfully
                //
                if (ComponentType == OEMSCSI) {
                  DetectedDevice->Ordinal= (ULONG)-1;
                }

                if( AllowUserSelection ) {
                    Data = SlGetMenuItem(Menu, DefaultSelection);
                    OemComponentId = Data->Identifier;
                    OemComponentDescription = Data->Description;
                } else {
                    if (PreInstallComponentDescription) {
                        OemComponentId = SlPreInstallGetComponentName( OemInfHandle,
                                                                       ComponentName,
                                                                       PreInstallComponentDescription );
                        if( OemComponentId == NULL ) {
                            SlFatalError(SL_BAD_UNATTENDED_SCRIPT_FILE,
                                         PreInstallComponentDescription,
                                         SlCopyStringAT(ComponentName),
                                         "txtsetup.oem");

                        }
                        
                        OemComponentDescription = PreInstallComponentDescription;
                    } else {
#ifdef UNICODE
                        OemComponentDescription = SlGetSectionKeyIndexW(
                                                        OemInfHandle,
                                                        ComponentName,
                                                        OemComponentId,
                                                        0);
#else
                        OemComponentDescription = SlGetSectionKeyIndex(
                                                        OemInfHandle,
                                                        ComponentName,
                                                        OemComponentId,
                                                        0);
#endif                                                        
                    }
                }
                

                if(SlpOemInfSelection(OemSourceDevice,
                        OemInfHandle,
                        ComponentName,
                        OemComponentId,
                        OemComponentDescription,
                        DetectedDevice,
                        HardwareIdDatabase,
                        FullDriverPath)) {
                    //
                    // Go load the driver.  The correct disk must
                    // already be in the drive, since we just read
                    // the INF file off it.
                    //
                    // We step down the linked list, and load the first driver we find.
                    //
                    for(FileStruct = DetectedDevice->Files, bDriverLoaded = FALSE;
                            (FileStruct && !bDriverLoaded);
                            FileStruct = FileStruct->Next) {

                        filetype = FileStruct->FileType;

                        if((filetype == HwFilePort) || (filetype == HwFileClass) ||
                                (filetype == HwFileDriver) || (filetype == HwFileHal)) {
                            ULONG DirLength;
                            
                            BlOutputLoadMessage(
                                LoadDeviceName,
                                FileStruct->Filename,
                                OemComponentDescription // Data->Description
                                );


                            //
                            // Reconstruct the FullDriverPath 
                            //
                            strcpy(FullDriverPath, FileStruct->Directory);                                                
                            DirLength = strlen(FullDriverPath);

                            if (DirLength && (FullDriverPath[DirLength - 1] != '\\')) {
                                strcat(FullDriverPath, "\\");
                            }                                    
                            
                            strcat(FullDriverPath, FileStruct->Filename);

                            if (ComponentType == OEMSCSI) {
                              PTCHAR FmtStr = 0;

                              //
                              // Verify that we don't have an in-box driver
                              //
                              InboxDevice = SlCheckForInboxDriver(FileStruct->Filename);

                              if (InboxDevice) {
                                VERSION_COMP_RESULT VerResult;
                                PTCHAR AdditionalInfo;
                                PTCHAR DriverName = OemComponentDescription;
#ifdef UNICODE
                                WCHAR FileNameW[100];
#endif

                                if(DriverName == NULL) {
#ifdef UNICODE
                                    UNICODE_STRING uString;
                                    ANSI_STRING aString;
                                    RtlInitAnsiString(&aString, FileStruct->Filename);
                                    uString.Buffer = FileNameW;
                                    uString.MaximumLength = sizeof(FileNameW);
                                    RtlAnsiStringToUnicodeString(&uString, &aString, FALSE);
                                    //
                                    // the converted string is NULL-terminated
                                    //
                                    DriverName = FileNameW;
#else
                                    DriverName = FileStruct->Filename;
#endif
                                }

                                //
                                // Compare the drivers version's using link time stamp
                                //
                                VerResult = SlCompareDriverVersion(
                                                BootDeviceId,
                                                InboxDevice,
                                                LoadDeviceId,
                                                DetectedDevice
                                                );

                                //
                                // Show additional message to the user about the driver
                                // version mismatch
                                //
                                switch (VerResult) {
                                  case VersionOemNew:
                                    AdditionalInfo = BlFindMessage(SL_OEMDRIVER_NEW);
                                    break;

                                  case VersionInboxNew:
                                    AdditionalInfo = BlFindMessage(SL_INBOXDRIVER_NEW);
                                    break;

                                  default:
                                    AdditionalInfo = TEXT("");
                                    break;
                                }

                                //
                                // Show the message and get confirmation from user
                                // only in attended case. In case of dynamic update
                                // boot drivers just use the inbox driver itself
                                //
                                if (AllowUserSelection && 
                                    SlConfirmInboxDriverReplacement(DriverName,
                                        AdditionalInfo)) {
                                  //
                                  // Remove the driver node from inbox SCSI miniport
                                  // list
                                  //
                                  SlRemoveInboxDriver(FileStruct->Filename);
                                } else {
                                    //
                                    // User selected to use inbox driver
                                    //
                                    if (AllowUserSelection) {

                                        if (DeviceOpened) {
                                            ArcClose(LoadDeviceId);
                                        }
                                        
                                        return FALSE;
                                    }

                                    if (DynamicUpdate) {
                                        //
                                        // NOTE: Use the inbox driver instead
                                        // of dynamic update driver
                                        //
                                        return TRUE;    
                                    }                                        

                                    //
                                    // If user already loaded another third party
                                    // driver then honor that
                                    //
                                    if (InboxDevice->ThirdPartyOptionSelected) {
                                        return FALSE;
                                    }
                                    
                                    //
                                    // NOTE : For other autoload features we
                                    // use the OEM driver, instead of inbox
                                    // driver to make auto load feature
                                    // meaningful.
                                }
                              }

                              //
                              // Inform the user that the driver is being loaded
                              //
                              FmtStr = BlFindMessage(SL_FILE_LOAD_MESSAGE);

                              if (FmtStr && !WinPEBoot) {
                                  PTSTR pFileName;
#ifdef UNICODE
                                  WCHAR FileNameW[64];
                                  ANSI_STRING aString;
                                  UNICODE_STRING uString;
                                    
                                  RtlInitString( &aString, FileStruct->Filename );
                                  uString.Buffer = FileNameW;
                                  uString.MaximumLength = sizeof(FileNameW);
                                  RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
                                    
                                  pFileName = FileNameW;
                                    
#else
                                  pFileName = FileStruct->Filename;
                                    
#endif
                                  _stprintf(ScratchBuffer, FmtStr, pFileName);
                                  SlWriteStatusText(ScratchBuffer);
                              }
                            }

                            Status = BlLoadImage(LoadDeviceId,
                                               LoaderHalCode,
                                               FullDriverPath,
                                               TARGET_IMAGE,
                                               ImageBase);

                            if (Status == ESUCCESS) {

                                DetectedDevice->BaseDllName = FileStruct->Filename;

                                if(ARGUMENT_PRESENT(ImageName)) {
                                    *ImageName = FileStruct->Filename;
                                }

                                if(ARGUMENT_PRESENT(DriverDescription)) {
                                    *DriverDescription = OemComponentDescription; // Data->Description;
                                }

                                bDriverLoaded = TRUE;

                            } else {

                                if( !PreInstall ) {
                                    SlFriendlyError(
                                        Status,
                                        FullDriverPath,
                                        __LINE__,
                                        __FILE__
                                        );

                                    //
                                    // If one of the drivers causes an error, then we abort
                                    //
                                    if (DeviceOpened) {
                                        ArcClose(LoadDeviceId);
                                    }                                            

                                    return FALSE;
                                } else {
                                    SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(FullDriverPath), Status);
                                }
                            }
                        }
                    }

                    if (DeviceOpened) {
                        ArcClose(LoadDeviceId);
                    }                            

                    if(bDriverLoaded) {
                      if ((ComponentType == OEMSCSI) && InsertDevice) {
                        PDETECTED_DEVICE  NewScsiDevice = NULL;

                        //
                        // Insert the device in SCSI miniport list
                        //
                        if(SlInsertScsiDevice((ULONG)-1, &NewScsiDevice) == ScsiInsertError) {
                          SlNoMemoryError();
                        }

                        //
                        // update the node information we just created
                        //
                        *NewScsiDevice = *DetectedDevice;
                      }

                      return TRUE;
                    } else {
                        //
                        // We didn't find any drivers, so inform the user.
                        //
                        SlMessageBox(SL_WARNING_SIF_NO_DRIVERS);
                        break;
                    }

                } else {
                    SlFriendlyError(
                        0,
                        "",
                        __LINE__,
                        __FILE__
                        );

                    //
                    // Treat the invalid txtsetup.oem files cases as
                    // user cancellation
                    //
                    goto OemLoadFailed;                        
                }
                break;
        }
    }

OemLoadFailed:
    
    if (DeviceOpened){
        ArcClose(LoadDeviceId);
    }
    return(FALSE);
}


ULONG
SlpAddSectionToMenu(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PSL_MENU Menu
    )
/*++

Routine Description:

    Adds the entries in an INF section to the given menu

Arguments:

    InfHandle - Supplies a handle to the INF file

    SectionName - Supplies the name of the section.

    Menu - Supplies the menu to add the items in the section to.

Return Value:

    Number of items added to the menu.

--*/
{
    ULONG i;
    ULONG LineCount;
    PTCHAR Description;
    PMENU_ITEM_DATA Data;

    if (InfHandle==NULL) {
        //
        // nothing to add
        //
        return(0);
    }

    LineCount = SlCountLinesInSection(InfHandle,SectionName);
    if(LineCount == (ULONG)(-1)) {
        LineCount = 0;
    }
    for (i=0;i<LineCount;i++) {
        Data = BlAllocateHeap(sizeof(MENU_ITEM_DATA));
        if (Data==NULL) {
            SlError(0);
            return(0);
        }

        Data->InfFile = InfHandle;
        Data->SectionName = SectionName;
        Data->Index = i;

#ifdef UNICODE
        Description = SlGetSectionLineIndexW(
#else
        Description = SlGetSectionLineIndex(
#endif
                                        InfHandle,
                                        SectionName,
                                        i,
                                        0);
        if (Description==NULL) {
            Description=TEXT("BOGUS!");
        }

        Data->Description = Description;
        Data->Identifier = SlGetKeyName(InfHandle,SectionName,i);

        SlAddMenuItem(Menu,
                      Description,
                      Data,
                      0);
    }

    return(LineCount);
}


BOOLEAN
SlpFindFloppy(
    IN ULONG Number,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    Determines the ARC name for a particular floppy drive.

Arguments:

    Number - Supplies the floppy drive number

    ArcName - Returns the ARC name of the given floppy drive.

Return Value:

    TRUE - Drive was found.

    FALSE - Drive was not found.

--*/

{

    FloppyDiskPath = ArcName;
    FloppyDiskPath[0] = '\0';

    BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                       PeripheralClass,
                       FloppyDiskPeripheral,
                       Number,
                       FoundFloppyDiskCallback);

    if (ArcName[0]=='\0') {
        return(FALSE);
    } else {
        return(TRUE);
    }

}

BOOLEAN
FoundFloppyDiskCallback(
    IN PCONFIGURATION_COMPONENT_DATA Component
    )

/*++

Routine Description:

    Callback routine called by SlpFindFloppy to find a given floppy
    drive in the ARC tree.

    Check to see whether the parent is disk controller 0.

Arguments:

    Component - Supplies the component.

Return Value:

    TRUE if search is to continue.
    FALSE if search is to stop.

--*/

{
    PCONFIGURATION_COMPONENT_DATA ParentComponent;

    //
    // A floppy disk peripheral was found.  If the parent was disk(0),
    // we've got a floppy disk drive.
    //

    if((ParentComponent = Component->Parent)
    && (ParentComponent->ComponentEntry.Type == DiskController))
    {

        //
        // Store the ARC pathname of the floppy
        //
        BlGetPathnameFromComponent(Component,FloppyDiskPath);
        return(FALSE);
    }

    return(TRUE);               // keep searching
}
BOOLEAN
SlpIsOnlySuperFloppy(
    void
    )

/*++

Routine Description:

    Determines if we only have ATAPI super floppies

Arguments:


Return Value:

    TRUE - only super floppies

    FALSE - > 0 regular floppies

--*/

{

    BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                       PeripheralClass,
                       FloppyDiskPeripheral,
                       0,
                       SuperFloppyCallback);

    return(IsSuperFloppy == FloppyNumber);

}

BOOLEAN
SuperFloppyCallback(
    IN PCONFIGURATION_COMPONENT_DATA Component
    )

/*++

Routine Description:

    Callback routine called by SlpIsOnlySuper to find if we only have ATAPI floppy
    drives in the ARC tree.

    Check to see whether the parent is disk controller 0.

Arguments:

    Component - Supplies the component.

Return Value:

    TRUE if search is to continue.
    FALSE if search is to stop.

--*/

{
    PCONFIGURATION_COMPONENT_DATA ParentComponent;
    PCM_FLOPPY_DEVICE_DATA FloppyData;
    PCM_PARTIAL_RESOURCE_LIST DescriptorList;

    if(Component->ComponentEntry.Type==FloppyDiskPeripheral) {
       //
       // A floppy disk peripheral was found.
       //

       FloppyNumber++;

       //
       // Crack the CM descriptors. This is a reversal of the storage from
       // ..\detect\i386\diskc.c. The data is in the 2nd, not the 1st descriptor
       //
       DescriptorList = (PCM_PARTIAL_RESOURCE_LIST)Component->ConfigurationData;
       FloppyData = (PCM_FLOPPY_DEVICE_DATA)(DescriptorList +1);

       if (FloppyData->MaxDensity & 0x80000000) {
           //
           // Is it a special removeable ATAPI device?
           //
           IsSuperFloppy++;
       }
    }

    return(TRUE);               // keep searching
}


BOOLEAN
SlpReplicatePnpHardwareIds(
    IN PPNP_HARDWARE_ID ExistingIds,
    OUT PPNP_HARDWARE_ID *NewIds
    )
/*++

Routine Description:

    Replicates the input PNP_HARDWARE_ID list.

Arguments:

    ExistingIds -   The input PNP_HARDWARE_ID list

    NewIds - Placeholder for the the new replicated hardware
        ID linked list.

Return Value:

    TRUE if successful, otherwise FALSE.

--*/
{
    BOOLEAN Result = FALSE;

    if (ExistingIds && NewIds) {
        PPNP_HARDWARE_ID SrcNode = ExistingIds;
        PPNP_HARDWARE_ID HeadNode = NULL;
        PPNP_HARDWARE_ID PrevNode = NULL;
        PPNP_HARDWARE_ID CurrNode = NULL;

        do {             
            CurrNode = BlAllocateHeap(sizeof(PNP_HARDWARE_ID));

            if (CurrNode) {            
                *CurrNode = *SrcNode;
                CurrNode->Next = NULL;
                                
                if (!HeadNode) {
                    HeadNode = CurrNode;
                }

                if (PrevNode) {
                    PrevNode->Next = CurrNode;
                }
                
                PrevNode = CurrNode;                    
                SrcNode = SrcNode->Next;
            }                            
        }
        while (SrcNode && CurrNode);

        if (CurrNode) {
            Result = TRUE;
            *NewIds = HeadNode;
        }            
    }

    return Result;
}
    


BOOLEAN
SlpOemInfSelection(
    IN  POEM_SOURCE_DEVICE OemSourceDevice,
    IN  PVOID             OemInfHandle,
    IN  PCHAR             ComponentName,
    IN  PCHAR             SelectedId,
    IN  PTCHAR            ItemDescription,
    OUT PDETECTED_DEVICE  Device,
    OUT PPNP_HARDWARE_ID* HardwareIdDatabase,
    IN  PCHAR   DriverDir
    )
{
    PCHAR FilesSectionName,ConfigSectionName,HardwareIdsSectionName;
    ULONG Line,Count,Line2,Count2;
    BOOLEAN rc = FALSE;
    PDETECTED_DEVICE_FILE FileList = NULL, FileListTail;
    PDETECTED_DEVICE_REGISTRY RegList = NULL, RegListTail;
    PPNP_HARDWARE_ID IdList = NULL, IdListTail;
    PPNP_HARDWARE_ID PrivateIdList = NULL;
    ULONG FileTypeBits = 0;

    //
    // Validate the parameters
    //
    if (!ComponentName || !SelectedId) {
        return FALSE;
    }
    
    //
    // Iterate through the files section, remembering info about the
    // files to be copied in support of the selection.
    //

    FilesSectionName = BlAllocateHeap(strlen(ComponentName) + strlen(SelectedId) + sizeof("Files.") + 1);
    if (!FilesSectionName) {
        return FALSE; // out of memory
    }
    strcpy(FilesSectionName,"Files.");
    strcat(FilesSectionName,ComponentName);
    strcat(FilesSectionName,".");
    strcat(FilesSectionName,SelectedId);
    Count = SlCountLinesInSection(OemInfHandle,FilesSectionName);
    if(Count == (ULONG)(-1)) {
        SlMessageBox(SL_BAD_INF_SECTION,FilesSectionName);
        goto sod0;
    }

    for(Line=0; Line<Count; Line++) {

        PCHAR Disk,Filename,Filetype,Tagfile,Directory,ConfigName;
        PTCHAR Description;
        HwFileType filetype;
        PDETECTED_DEVICE_FILE FileStruct;

        //
        // Get the disk specification, filename, and filetype from the line.
        //

        Disk = SlGetSectionLineIndex(OemInfHandle,FilesSectionName,Line,OINDEX_DISKSPEC);

        Filename = SlGetSectionLineIndex(OemInfHandle,FilesSectionName,Line,OINDEX_FILENAME);
        Filetype = SlGetKeyName(OemInfHandle,FilesSectionName,Line);

        if(!Disk || !Filename || !Filetype) {
#ifdef UNICODE
            DIAGOUT((
                TEXT("SlpOemDiskette: Disk=%S, Filename=%S, Filetype=%S"),
                Disk ? Disk : "(null)",
                Filename ? Filename : "(null)",
                Filetype ? Filetype : "(null)"));
#else
            DIAGOUT((
                TEXT("SlpOemDiskette: Disk=%s, Filename=%s, Filetype=%s"),
                Disk ? Disk : "(null)",
                Filename ? Filename : "(null)",
                Filetype ? Filetype : "(null)"));
#endif            
            SlError(Line);
//            SppOemInfError(ErrorMsg,&SptOemInfErr2,Line+1,FilesSectionName);

            goto sod0;
        }

        //
        // Parse the filetype.
        //
        filetype = SlpFindStringInTable(Filetype,FileTypeNames);
        if(filetype == HwFileMax) {
//            SppOemInfError(ErrorMsg,&SptOemInfErr4,Line+1,FilesSectionName);
            goto sod0;
        }

        //
        // Fetch the name of the section containing configuration information.
        // Required if file is of type port, class, or driver.
        //
        if((filetype == HwFilePort) || (filetype == HwFileClass) || (filetype == HwFileDriver)) {
            ConfigName = SlGetSectionLineIndex(OemInfHandle,FilesSectionName,Line,OINDEX_CONFIGNAME);
            if(ConfigName == NULL) {
//                SppOemInfError(ErrorMsg,&SptOemInfErr8,Line+1,FilesSectionName);
                goto sod0;
            }
        } else {
            ConfigName = NULL;
        }

        //
        // Using the disk specification, look up the tagfile, description,
        // and directory for the disk.
        //

        Tagfile     = SlGetSectionKeyIndex(OemInfHandle,"Disks",Disk,OINDEX_TAGFILE);
        
#ifdef UNICODE
        Description = SlGetSectionKeyIndexW(
#else
        Description = SlGetSectionKeyIndex(
#endif
                                        OemInfHandle,
                                        "Disks",
                                        Disk,
                                        OINDEX_DISKDESCR);

        Directory   = SlGetSectionKeyIndex(OemInfHandle,"Disks",Disk,OINDEX_DIRECTORY);
        if((Directory == NULL) || !strcmp(Directory,"\\")) {
            Directory = SlCopyStringA("");
        }

        if(!Tagfile || !Description) {
            DIAGOUT((
                TEXT("SppOemDiskette: Tagfile=%s, Description=%s"),
                Tagfile ? Tagfile : "(null)",
                Description ? Description : TEXT("(null)")));
//            SppOemInfError(ErrorMsg,&SptOemInfErr5,Line+1,FilesSectionName);
            goto sod0;
        }

        FileStruct = BlAllocateHeap(sizeof(DETECTED_DEVICE_FILE));
        memset(FileStruct, 0, sizeof(DETECTED_DEVICE_FILE));

        //
        // Use the fully qualified path, for dynamic update drivers
        // if any
        //
        if (DriverDir && DriverDir[0]) {
            PCHAR   FullDir = BlAllocateHeap(256);

            if (FullDir) {
                *FullDir = '\0';

                //
                // Do we need a starting '\' ?
                //
                if (DriverDir[0] != '\\') {
                    strcat(FullDir, "\\");
                }
                
                strcat(FullDir, DriverDir);

                //
                // Do we need to append another '\' between
                // the paths ?
                //
                if ((FullDir[strlen(FullDir) - 1] != '\\') &&
                        (*Directory != '\\')) {
                    strcat(FullDir, "\\");                        
                }                    
                
                strcat(FullDir, Directory);

                //
                // Do we need a terminating '\'?
                //
                if (FullDir[strlen(FullDir) - 1] != '\\') {
                    strcat(FullDir, "\\");
                }                    
                
                Directory = FullDir;
            } else {
                return  FALSE;  // ran out of memory
            }                
        }

        FileStruct->Directory = Directory;
        FileStruct->Filename = Filename;
        FileStruct->DiskDescription = Description;
        FileStruct->DiskTagfile = Tagfile;
        FileStruct->FileType = filetype;
        //
        // Insert at tail of list so we preserve the order in the Files section
        //
        if(FileList) {
            FileListTail->Next = FileStruct;
            FileListTail = FileStruct;
        } else {
            FileList = FileListTail = FileStruct;
        }
        FileStruct->Next = NULL;

        if(ConfigName) {
            FileStruct->ConfigName = ConfigName;
        } else {
            FileStruct->ConfigName = NULL;
        }
        FileStruct->RegistryValueList = NULL;

        if((filetype == HwFilePort) || (filetype == HwFileDriver)) {
            SET_FILETYPE_PRESENT(FileTypeBits,HwFilePort);
            SET_FILETYPE_PRESENT(FileTypeBits,HwFileDriver);
        } else {
            SET_FILETYPE_PRESENT(FileTypeBits,filetype);
        }

        //
        // If this is a dynamic update driver, then mark the
        // the device file type bits to indicate this. Textmode
        // setup needs this to construct a valid source path.
        //
        if (OemSourceDevice && 
            SL_OEM_SOURCE_DEVICE_TYPE(OemSourceDevice, SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE)){
            SET_FILETYPE_PRESENT(FileTypeBits, HwFileDynUpdt);
        }            

        //
        // Now go look in the [Config.<ConfigName>] section for registry
        // information that is to be set for this driver file.
        //
        if(ConfigName) {
            ConfigSectionName = BlAllocateHeap(strlen(ConfigName) + sizeof("Config."));
            strcpy(ConfigSectionName,"Config.");
            strcat(ConfigSectionName,ConfigName);
            Count2 = SlCountLinesInSection(OemInfHandle,ConfigSectionName);
            if(Count2 == (ULONG)(-1)) {
                Count2 = 0;
            }

            for(Line2=0; Line2<Count2; Line2++) {

                PCHAR KeyName,ValueName,ValueType;
                PDETECTED_DEVICE_REGISTRY Reg;
                HwRegistryType valuetype;

                //
                // Fetch KeyName, ValueName, and ValueType from the line.
                //

                KeyName   = SlGetSectionLineIndex(OemInfHandle,ConfigSectionName,Line2,OINDEX_KEYNAME);
                ValueName = SlGetSectionLineIndex(OemInfHandle,ConfigSectionName,Line2,OINDEX_VALUENAME);
                ValueType = SlGetSectionLineIndex(OemInfHandle,ConfigSectionName,Line2,OINDEX_VALUETYPE);

                if(!KeyName || !ValueName || !ValueType) {
                    DIAGOUT((
                        TEXT("SlpOemDiskette: KeyName=%s, ValueName=%s, ValueType=%s"),
                        KeyName   ? KeyName   : "(null)",
                        ValueName ? ValueName : "(null)",
                        ValueType ? ValueType : "(null)"));
//                    SppOemInfError(ErrorMsg,&SptOemInfErr2,Line2+1,ConfigSectionName);
                    goto sod0;
                }

                //
                // Parse the value type and associated values.
                //
                valuetype = SlpFindStringInTable(ValueType,RegistryTypeNames);
                if(valuetype == HwRegistryMax) {
//                    SppOemInfError(ErrorMsg,&SptOemInfErr6,Line2+1,ConfigSectionName);
                    goto sod0;
                }

                Reg = SlpInterpretOemRegistryData(OemInfHandle,ConfigSectionName,Line2,valuetype);
                if(Reg) {

                    Reg->KeyName = KeyName;
                    Reg->ValueName = ValueName;
                    //
                    // Insert at tail of list so as to preserve the order given in the config section
                    //
                    if(RegList) {
                        RegListTail->Next = Reg;
                        RegListTail = Reg;
                    } else {
                        RegList = RegListTail = Reg;
                    }
                    Reg->Next = NULL;

                } else {
//                    SppOemInfError(ErrorMsg,&SptOemInfErr7,Line2+1,ConfigSectionName);
                    goto sod0;
                }
            }

            FileStruct->RegistryValueList = RegList;
            RegList = NULL;
        }

        //
        // Save away the arc device name also
        //
        if (OemSourceDevice && OemSourceDevice->ArcDeviceName) {
            FileStruct->ArcDeviceName = SlCopyStringA(OemSourceDevice->ArcDeviceName);
        } else {
            FileStruct->ArcDeviceName = NULL;
        }                        
    }
    
    //
    //  Get the hardware ids if such a section exist
    //
    HardwareIdsSectionName = BlAllocateHeap(strlen(ComponentName) + strlen(SelectedId) + sizeof("HardwareIds.") + 1);
    strcpy(HardwareIdsSectionName,"HardwareIds.");
    strcat(HardwareIdsSectionName,ComponentName);
    strcat(HardwareIdsSectionName,".");
    strcat(HardwareIdsSectionName,SelectedId);
    Count = SlCountLinesInSection(OemInfHandle,HardwareIdsSectionName);
    if(Count == (ULONG)(-1)) {
        //
        //  If the section doesn't exist, the assume it is empty
        //
        Count = 0;
    }
    IdList = IdListTail = NULL;
    for(Line=0; Line<Count; Line++) {
        PCHAR   Id;
        PCHAR   DriverName;
        PCHAR   ClassGuid;
        PPNP_HARDWARE_ID TempIdElement;

        Id          = SlGetSectionLineIndex(OemInfHandle,HardwareIdsSectionName,Line,OINDEX_HW_ID);
        DriverName  = SlGetSectionLineIndex(OemInfHandle,HardwareIdsSectionName,Line,OINDEX_DRIVER_NAME);
        ClassGuid   = SlGetSectionLineIndex(OemInfHandle,HardwareIdsSectionName,Line,OINDEX_CLASS_GUID);
        if( !Id || !DriverName ) {
            SlMessageBox(SL_BAD_INF_SECTION,HardwareIdsSectionName);
            goto sod0;
        }
        TempIdElement = BlAllocateHeap(sizeof(PNP_HARDWARE_ID));
        if(IdListTail == NULL) {
            IdListTail = TempIdElement;
        }
        TempIdElement->Id         = Id;
        TempIdElement->DriverName = DriverName;
        TempIdElement->ClassGuid  = ClassGuid;
        TempIdElement->Next = IdList;
        IdList = TempIdElement;
    }
    
    if( IdList != NULL ) {
        //
        // Replicate the PNP hardware Id list
        //
        if (!SlpReplicatePnpHardwareIds(IdList, &PrivateIdList)) {
            goto sod0;  // ran out of memory
        }
        
        IdListTail->Next = *HardwareIdDatabase;
        *HardwareIdDatabase = IdList;
    }

    //
    // Everything is OK so we can place the information we have gathered
    // into the main structure for the device class.
    //

    SlpInitDetectedDevice( Device,
                           SelectedId,
                           ItemDescription,
                           TRUE
                         );

    Device->Files = FileList;
    Device->FileTypeBits = FileTypeBits;
    Device->HardwareIds = PrivateIdList;    
    rc = TRUE;

    //
    // Clean up and exit.
    //

sod0:
    return(rc);
}

int
SlpFindStringInTable(
    IN PCHAR String,
    IN PCHAR *StringTable
    )

/*++

Routine Description:

    Locate a string in an array of strings, returning its index.  The search
    is not case sensitive.

Arguments:

    String - string to locate in the string table.

    StringTable - array of strings to search in.  The final element of the
        array must be NULL so we can tell where the table ends.

Return Value:

    Index into the table, or some positive index outside the range of valid
    indices for the table if the string is not found.

--*/

{
    int i;

    for(i=0; StringTable[i]; i++) {
        if(_stricmp(StringTable[i],String) == 0) {
            return(i);
        }
    }

    return(i);
}


VOID
SlpInitDetectedDevice(
    IN PDETECTED_DEVICE Device,
    IN PCHAR            IdString,
    IN PTCHAR           Description,
    IN BOOLEAN          ThirdPartyOptionSelected
    )
{
    Device->IdString = IdString;
    Device->Description = Description;
    Device->ThirdPartyOptionSelected = ThirdPartyOptionSelected;
    Device->FileTypeBits = 0;
    Device->Files = NULL;
}


PDETECTED_DEVICE_REGISTRY
SlpInterpretOemRegistryData(
    IN PVOID            InfHandle,
    IN PCHAR            SectionName,
    IN ULONG            Line,
    IN HwRegistryType   ValueType
    )
{
    PDETECTED_DEVICE_REGISTRY Reg;
    PCHAR Value;
    unsigned i,len;
    ULONG Dword;
    ULONG BufferSize;
    PVOID Buffer = NULL;
    PUCHAR BufferUchar;

    //
    // Perform appropriate action based on the type
    //

    switch(ValueType) {

    case HwRegistryDword:
//  case REG_DWORD_LITTLE_ENDIAN:
//  case REG_DWORD_BIG_ENDIAN:

        Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Make sure it's really a hex number
        //

        len = strlen(Value);
        if(len > 8) {
            goto x1;
        }
        for(i=0; i<len; i++) {
            if(!isxdigit(Value[i])) {
                goto x1;
            }
        }

        //
        // convert it from ascii to a hex number
        //

        sscanf(Value,"%lx",&Dword);

    #if 0
        //
        // If big endian, perform appropriate conversion
        //

        if(VaueType == REG_DWORD_BIG_ENDIAN) {

            Dword =   ((Dword << 24) & 0xff000000)
                    | ((Dword <<  8) & 0x00ff0000)
                    | ((Dword >>  8) & 0x0000ff00)
                    | ((Dword >> 24) & 0x000000ff);
        }
    #endif

        //
        // Allocate a 4-byte buffer and store the dword in it
        //

        Buffer = BlAllocateHeap(BufferSize = sizeof(ULONG));
        *(PULONG)Buffer = Dword;
        break;

    case HwRegistrySz:
    case HwRegistryExpandSz:

        Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Allocate a buffer of appropriate size for the string
        //

        Buffer = BlAllocateHeap(BufferSize = strlen(Value)+1);
        if (Buffer == NULL) {
        goto x1;
        }

        strcpy(Buffer, Value);
        break;

    case HwRegistryBinary:

        Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Figure out how many byte values are specified
        //

        len = strlen(Value);
        if(len & 1) {
            goto x1;            // odd # of characters
        }

        //
        // Allocate a buffer to hold the byte values
        //

        Buffer = BlAllocateHeap(BufferSize = len / 2);
        BufferUchar = Buffer;

        //
        // For each digit pair, convert to a hex number and store in the
        // buffer
        //

        for(i=0; i<len; i+=2) {

            UCHAR byte;
            unsigned j;

            //
            // Convert the current digit pair to hex
            //

            for(byte=0,j=i; j<i+2; j++) {

                byte <<= 4;

                if(isdigit(Value[j])) {

                    byte |= (UCHAR)Value[j] - (UCHAR)'0';

                } else if((Value[j] >= 'a') && (Value[j] <= 'f')) {

                    byte |= (UCHAR)Value[j] - (UCHAR)'a' + (UCHAR)10;

                } else if((Value[j] >= 'A') && (Value[j] <= 'F')) {

                    byte |= (UCHAR)Value[j] - (UCHAR)'A' + (UCHAR)10;

                } else {

                    goto x1;
                }
            }

            BufferUchar[i/2] = byte;
        }

        break;

    case HwRegistryMultiSz:

        //
        // Calculate size of the buffer needed to hold all specified strings
        //

        for(BufferSize=1,i=0;
            Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE+i);
            i++)
        {
            BufferSize += strlen(Value)+1;
        }

        //
        // Allocate a buffer of appropriate size
        //

        Buffer = BlAllocateHeap(BufferSize);
        BufferUchar = Buffer;

        //
        // Store each string in the buffer, converting to wide char format
        // in the process
        //

        for(i=0;
            Value = SlGetSectionLineIndex(InfHandle,SectionName,Line,OINDEX_FIRSTVALUE+i);
            i++)
        {
            strcpy(BufferUchar,Value);
            BufferUchar += strlen(Value) + 1;
        }

        //
        // Place final terminating nul in the buffer
        //

        *BufferUchar = 0;

        break;

    default:
    x1:

        //
        // Error - bad type specified or maybe we detected bad data values
        // and jumped here
        //

        return(NULL);
    }

    Reg = BlAllocateHeap(sizeof(DETECTED_DEVICE_REGISTRY));

    Reg->ValueType = RegistryTypeMap[ValueType];
    Reg->Buffer = Buffer;
    Reg->BufferSize = BufferSize;

    return(Reg);
}


PCHAR
SlPreInstallGetComponentName(
    IN PVOID  Inf,
    IN PCHAR  SectionName,
    IN PTCHAR TargetName
    )

/*++

Routine Description:

    Determines the canonical short name for a component to be loaded for
    this machine.

Arguments:

    Inf - Handle to an inf file (retail or OEM).

    SectionName - Supplies the name of the section (eg. [Computer])

    TargetName - Supplies the ARC string to be matched (eg. "Digital DECpc AXP 150")

Return Value:

    NULL - No match was found.

    PCHAR - Pointer to the canonical shortname of the component.

--*/

{
    ULONG i;
    PTCHAR SearchName;

    //
    // If this is not an OEM component, then enumerate the entries in the
    // section in txtsetup.sif
    //
    for (i=0;;i++) {
#ifdef UNICODE
        SearchName = SlGetSectionLineIndexW(
#else
        SearchName = SlGetSectionLineIndex(
#endif
                                           Inf,
                                           SectionName,
                                           i,
                                           0 );
        if (SearchName==NULL) {
            //
            // we have enumerated the entire section without finding a
            // match, return failure.
            //
            return(NULL);
        }

        if (_tcsicmp(TargetName, SearchName) == 0) {
            //
            // we have a match
            //
            break;
        }
    }
    //
    // i is the index into the section of the short machine name
    //
    return(SlGetKeyName(Inf,
                        SectionName,
                        i));
}


ARC_STATUS
SlLoadWinPESection(
    IN  POEM_SOURCE_DEVICE OemSourceDevice,
    IN  PVOID   OemInfHandle,        
    IN  PCSTR   OemSectionName,
    IN  PVOID   InboxInfHandle,
    IN  PCSTR   InboxSectionName,
    IN  BOOLEAN IsScsiSection,
    IN  POEMSCSIINFO*       ScsiInfo,           OPTIONAL
    OUT PPNP_HARDWARE_ID*   HardwareIdDatabase  OPTIONAL
    )
/*++

Routine Description:

    Loads the oem drivers from the specified section in the
    given OEM file name

Arguments:

    OemSourceDevice : The device that has the drivers that need to
        be loaded for WinPE.

    OemInfHandle   : Handle to the oem inf file

    OemSectionName : The section name that needs to be loaded.                

    InboxInfHandle : The original setup inf handle (txtsetup.sif)

    InboxSectionName : The section name, whose drivers are to be loaded

    IsScsiSection : Indicates whether the driver being loaded is SCSI
                    miniport or not.

    ScsiInfo - Returns a linked list containing info about any third-party scsi
               drivers loaded.               

    HardwareIdDatabase - Hardware Ids of the device which the loaded driver supports
    
Return Value:

    Appropriate ARC_STATUS

--*/
{
    ARC_STATUS  Status = EINVAL;

    if (OemSourceDevice && OemInfHandle && OemSectionName && InboxInfHandle && InboxSectionName) {        
        CHAR    Buffer[128];
        ULONG   EntryCount;
        BOOLEAN Append = TRUE;
        PCHAR   SectionName = Buffer;
        ULONG   InsertIndex = 0;

        Status = ESUCCESS;
        
        strcpy(SectionName, OemSectionName);
        strcat(SectionName, WINPE_REPLACE_SUFFIX_A);

        //
        // check if there is a .replace section
        //
        EntryCount = SlCountLinesInSection(OemInfHandle,
                            SectionName);

        if (EntryCount && (EntryCount != (-1))) {                
            Append = FALSE;
        } else {
            //
            // check if there is a .append section
            //
            strcpy(SectionName, OemSectionName);
            strcat(SectionName, WINPE_APPEND_SUFFIX_A);
            
            EntryCount = SlCountLinesInSection(OemInfHandle,
                                SectionName);
       }                      

        //
        // if append was requested then load the inbox
        // drivers first
        //
        if (Append) {
            Status = SlLoadSection(InboxInfHandle,
                        InboxSectionName,
                        IsScsiSection,
                        TRUE,
                        &InsertIndex);
        }

        //
        // load the non-pnp oem drivers if any
        //
        if ((Status == ESUCCESS) && EntryCount && (EntryCount != (-1))) {
            Status = SlLoadSection(OemInfHandle,
                        SectionName,
                        IsScsiSection,
                        FALSE,
                        &InsertIndex);
        }

        //
        // load the pnp oem drivers
        // 
        if (IsScsiSection && ScsiInfo && HardwareIdDatabase) {
            EntryCount = SlCountLinesInSection(OemInfHandle,
                                WINPE_OEMDRIVER_PARAMS_A);

            //
            // Try to load the driver only if present
            //
            if (EntryCount && (EntryCount != (-1))) {                        
                BOOLEAN Result;
                ULONG OldDeviceType = OemSourceDevice->DeviceType;

                //
                // We mark the device type as dynupdate device type
                // so that the fully qualified driver root directory is
                // used while loading MSDs
                //
                SL_OEM_SET_SOURCE_DEVICE_TYPE(OemSourceDevice,
                    (SL_OEM_SOURCE_DEVICE_TYPE_LOCAL |
                     SL_OEM_SOURCE_DEVICE_TYPE_FIXED |
                     SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE));

                Result = SlLoadOemScsiDriversUnattended(OemSourceDevice,
                                    OemInfHandle,
                                    WINPE_OEMDRIVER_PARAMS_A,
                                    WINPE_OEMDRIVER_ROOTDIR_A,
                                    WINPE_OEMDRIVER_DIRS_A,
                                    ScsiInfo,
                                    HardwareIdDatabase);

                //
                // Restore the old device type
                //
                SL_OEM_SET_SOURCE_DEVICE_TYPE(OemSourceDevice,
                    OldDeviceType);

                if (!Result) {
                    Status = EINVAL;
                }
            }        
        }            
    }        
    
    return Status;    
}

ARC_STATUS
SlInitOemSourceDevices(
    OUT POEM_SOURCE_DEVICE *OemSourceDevices,
    OUT POEM_SOURCE_DEVICE *DefaultSourceDevice
    )
/*++

Routine Description:

    This routine scans the devices to figure out which
    are the OEM source devices and creates a list of
    such devices.

Arguments:

    OemSourceDevices - Place holder for receiving the
        linked list of OEM source devices.

    DefaultSourceDevice - Place holder for the OEM source
        device which will be used as the default device
        while trying to load OEM drivers / HAL -- generally
        floppy(0).

Return Value:

    Returns the appropriate ARC_STATUS error code.
    
--*/
{
    ARC_STATUS Status = EINVAL;

    if (OemSourceDevices && DefaultSourceDevice) {    
        ULONG   FloppyCount = 0;
        ULONG   Index = 0;
        CHAR    ArcDeviceName[128];
        POEM_SOURCE_DEVICE OemDevices = NULL;

        ArcDeviceName[0] = '\0';
        Status = ESUCCESS;

        //
        // We may not find any devices 
        //
        *OemSourceDevices = *DefaultSourceDevice = NULL;

        //
        // Iterate through all the floppy drives and make them
        // oem source devices
        //

        while (ESUCCESS == Status) {
            POEM_SOURCE_DEVICE  NewDevice;

            //
            // Scan for atleast minimum number for floppies
            //
            if (!SlpFindFloppy(Index, ArcDeviceName)) {
                if ((Index + 1) < MinimumFloppiesToScan) {
                    Index++;
                    
                    continue;
                } else {
                    break;
                }                    
            }
            
            NewDevice = BlAllocateHeap(sizeof(OEM_SOURCE_DEVICE));

            if (!NewDevice) {            
                Status = ENOMEM;
            } else {                
                ARC_STATUS  OpenStatus;
                ULONG   DeviceId;                
                ULONG   DeviceType = (SL_OEM_SOURCE_DEVICE_TYPE_LOCAL | 
                                      SL_OEM_SOURCE_DEVICE_TYPE_REMOVABLE);
                
                memset(NewDevice, 0, sizeof(OEM_SOURCE_DEVICE));
                strcpy(NewDevice->ArcDeviceName, ArcDeviceName);                

                //
                // Assume we are not going to use device id
                //
                NewDevice->DeviceId = -1;

                //
                // Treat all the floppy drives which are greater than 0
                // as virtual floppy drives
                //
                if (Index >= VirtualFloppyStart) {
                    DeviceType |= SL_OEM_SOURCE_DEVICE_TYPE_VIRTUAL;
                }

                //
                // Currently we only use local removable media for
                // OEM drivers
                //
                SL_OEM_SET_SOURCE_DEVICE_TYPE(NewDevice, DeviceType);

                SL_OEM_SET_SOURCE_DEVICE_STATE(NewDevice, 
                    SL_OEM_SOURCE_DEVICE_NOT_PROCESSED);

                OpenStatus = ArcOpen(ArcDeviceName,
                                ArcOpenReadOnly,
                                &DeviceId);

                if (ESUCCESS == OpenStatus) {
                    CHAR        InfPath[128];
                    ULONG       FileId;
                    ULONG       MediaType = SL_OEM_SOURCE_MEDIA_PRESENT;
                    
                    strcpy(InfPath, "\\");
                    strcat(InfPath, TXTSETUP_OEM_FILENAME);

                    //
                    // Verify if the file is present
                    //
                    OpenStatus = BlOpen(DeviceId,
                                    InfPath,
                                    ArcOpenReadOnly,
                                    &FileId);

                    if (ESUCCESS == OpenStatus) {
                        PVOID   InfHandle = NULL;    
                        ULONG   ErrorLine = 0;

                        //
                        // We don't need file handle any more
                        //
                        BlClose(FileId);

                        //
                        // Open and parse the txtsetup.oem file
                        //
                        OpenStatus = SlInitIniFile(NULL,
                                        DeviceId,
                                        InfPath,
                                        &InfHandle,
                                        NULL,
                                        0,
                                        &ErrorLine);

                        if (ESUCCESS == OpenStatus) {
                            PCHAR   StrValue;
                            
                            MediaType |= SL_OEM_SOURCE_MEDIA_HAS_DRIVERS;
                            NewDevice->InfHandle = InfHandle;
                            NewDevice->DeviceId = DeviceId;

                            StrValue = SlGetSectionKeyIndex(InfHandle,
                                            TXTSETUP_OEM_DEFAULTS,
                                            TXTSETUP_OEM_DEFAULTS_COMPUTER,
                                            0);

                            if (StrValue) {
                                MediaType |= (SL_OEM_SOURCE_MEDIA_HAS_DEFAULT |
                                              SL_OEM_SOURCE_MEDIA_HAS_HAL);
                            }

                            StrValue = SlGetSectionKeyIndex(InfHandle,
                                            TXTSETUP_OEM_DEFAULTS,
                                            TXTSETUP_OEM_DEFAULTS_SCSI,
                                            0);

                            if (StrValue) {
                                MediaType |= (SL_OEM_SOURCE_MEDIA_HAS_DEFAULT |
                                              SL_OEM_SOURCE_MEDIA_HAS_MSD);
                            }                  
                        } else {
                            //
                            // Inform the user about the error & abort ?
                            //
                            MediaType |= SL_OEM_SOURCE_MEDIA_NO_DRIVERS;
                        }

                        //
                        // close the device if not needed
                        //
                        if (NewDevice->DeviceId != DeviceId) {
                            ArcClose(DeviceId);
                        }                        

                        //
                        // Mark the device state as scanned
                        //
                        SL_OEM_SET_SOURCE_DEVICE_STATE(NewDevice, 
                            SL_OEM_SOURCE_DEVICE_SCANNED);                        
                    }

                    SL_OEM_SET_SOURCE_MEDIA_TYPE(NewDevice,
                        MediaType);                        
                } else {
                    SL_OEM_SET_SOURCE_MEDIA_TYPE(NewDevice,
                        SL_OEM_SOURCE_MEDIA_ABSENT);
                }                    

                //
                // insert the new device at the head of the linked list
                //
                if (!OemDevices) {
                    OemDevices = NewDevice;
                } else {
                    NewDevice->Next = OemDevices;
                    OemDevices = NewDevice;
                }                    

                //
                // Currently floppy0 is the default OEM source device
                //
                if (Index == 0) {
                    *DefaultSourceDevice = NewDevice;
                }                    

                //
                // Process next floppy drive
                //
                Index++;
                ArcDeviceName[0] = '\0';                
            }                
        }

        if (ESUCCESS == Status) {
            *OemSourceDevices = OemDevices;
        }            
    }

    return Status;
}


ARC_STATUS
SlLoadOemScsiDriversFromOemSources(
    IN POEM_SOURCE_DEVICE OemSourceDevices,
    IN OUT PPNP_HARDWARE_ID *HardwareIds,
    OUT POEMSCSIINFO *OemScsiInfo
    )
/*++

Routine Description:

    Goes through each of the OEM source device and loads the
    default drivers, if any.

Arguments:

    OemSourceDevices - List of OEM source devices.

    HardwareIds - List of all the hardware IDs of the devices which
        are controlled by the drivers which were loaded.

    OemScsiInfo - Placeholder for receiving the list OEMSCSIINFO
        list, which has the driver base and driver name for each
        driver loaded.

Return Value:

    Returns the appropriate ARC_STATUS error code.
    
--*/
{
    ARC_STATUS Status = EINVAL;

    if (OemSourceDevices && OemScsiInfo) {    
        POEM_SOURCE_DEVICE CurrDevice = OemSourceDevices;
        POEMSCSIINFO DeviceOemScsiInfo = NULL;
        POEMSCSIINFO LastOemScsiNode = NULL;

        Status = ESUCCESS;
        
        while (CurrDevice) {
            //
            // Only process those devices which are not processed yet
            // and which are not dynamic update source devices
            //
            if (!SL_OEM_SOURCE_DEVICE_STATE(CurrDevice,
                    SL_OEM_SOURCE_DEVICE_PROCESSED) &&
                !SL_OEM_SOURCE_DEVICE_TYPE(CurrDevice,
                    SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE)) {                    

                //
                // Does the device has MSD with default entry ?
                //
                if (SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                        SL_OEM_SOURCE_MEDIA_HAS_DRIVERS) &&
                    SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                        SL_OEM_SOURCE_MEDIA_HAS_DEFAULT) &&
                    SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                         SL_OEM_SOURCE_MEDIA_HAS_MSD)) {

                    PPNP_HARDWARE_ID HardwareIdDatabase = NULL;
                    POEMSCSIINFO CurrentOemScsiInfo = NULL;                    
                    DETECTED_DEVICE DetectedDevice = {0};
                    PVOID ImageBase = NULL;
                    PCHAR ImageName = NULL;
                    PTCHAR DriverDescription = NULL;
                    BOOLEAN LoadResult;
                                        
                    //
                    // Load the driver and related files, in an unattended manner
                    //
                    LoadResult = SlpOemDiskette(CurrDevice,
                                    "SCSI",
                                    OEMSCSI,
                                    0,
                                    &DetectedDevice,
                                    &ImageBase,
                                    &ImageName,
                                    &DriverDescription,
                                    FALSE,
                                    NULL,
                                    &HardwareIdDatabase,
                                    NULL,
                                    TRUE);

                    if (LoadResult) {        
                        CurrentOemScsiInfo = BlAllocateHeap(sizeof(OEMSCSIINFO));

                        if (CurrentOemScsiInfo) {
                            memset(CurrentOemScsiInfo, 0, sizeof(OEMSCSIINFO));
                            CurrentOemScsiInfo->ScsiBase = ImageBase;
                            CurrentOemScsiInfo->ScsiName = ImageName;

                            //
                            // Insert the ids into main hardware Id database
                            //
                            if (HardwareIdDatabase) {                            
                                while (HardwareIdDatabase->Next) {
                                    HardwareIdDatabase = HardwareIdDatabase->Next;
                                }

                                HardwareIdDatabase->Next = *HardwareIds;
                                *HardwareIds = HardwareIdDatabase;
                            }
                        }

                        //
                        // Mark the oem source device state, as processed
                        //
                        SL_OEM_SET_SOURCE_DEVICE_STATE(CurrDevice,
                            SL_OEM_SOURCE_DEVICE_PROCESSED);
                    } else {
                        //
                        // Make the oem source device state as skipped so that
                        // we don't create virtual oem source device for it
                        //
                        SL_OEM_SET_SOURCE_DEVICE_STATE(CurrDevice,
                            SL_OEM_SOURCE_DEVICE_SKIPPED);
                    }                        
                        
                    if (CurrentOemScsiInfo) {                        
                        //
                        // Initialize head if necessary
                        //
                        if (!DeviceOemScsiInfo) {
                            DeviceOemScsiInfo = CurrentOemScsiInfo;
                        }
                        
                        //
                        // Merge the current linked list with the
                        // full OEM source device linked list
                        //
                        if (LastOemScsiNode) {
                            LastOemScsiNode->Next = CurrentOemScsiInfo;
                        } else {
                            LastOemScsiNode = CurrentOemScsiInfo;
                        }

                        //
                        // NOTE : We need to maintain the linked list
                        // in the order the drivers were loaded so 
                        // search for the last node in the current list
                        // and keep last node pointer around for the
                        // merge for next iteration.
                        //
                        while (LastOemScsiNode->Next) {
                            LastOemScsiNode = LastOemScsiNode->Next;
                        }
                    }
                }                         
            }                    
            
            CurrDevice = CurrDevice->Next;
        }

        //
        // Initialize the return argument irrespective of
        // status code since we might have loaded some drivers
        // and would like to use it anyway
        //
        *OemScsiInfo = DeviceOemScsiInfo;
    }

    return Status;
}            

ARC_STATUS
SlInitVirtualOemSourceDevices(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    IN POEM_SOURCE_DEVICE OemSourceDevices
    )
/*++

Routine Description:

    Goes through each of the OEM source devices and creates
    another linked list of virtual OEM source devices.
    
    This list is put in the loader block for setupdd.sys
    to inform the RAM disk driver to create virtual devices
    under NT to read drivers of this device.

    NOTE : Currently we allocate memory for the whole virtual
    device and replicate its contents into the allocated memory.
    We do this because we don't want OEMs to write separate
    NT driver to read from the virtual device under NT.
    We also limit the size of each virtual device to be 3MB
    at the max.
    
Arguments:

    SetupLoaderBlock - Setup loader block

    OemSourceDevices - The list of OEM source devices identified
        by the setupldr.
        
Return Value:

    Returns the appropriate ARC_STATUS error code.
    
--*/
{
    ARC_STATUS Status = EINVAL;

    if (SetupLoaderBlock && OemSourceDevices) {
        PDETECTED_OEM_SOURCE_DEVICE OemVirtualDevices = NULL;
        PDETECTED_OEM_SOURCE_DEVICE NewVirtualDevice = NULL;
        POEM_SOURCE_DEVICE CurrentDevice = OemSourceDevices;

        Status = ESUCCESS;

        while (CurrentDevice) {
            //
            // Process only those devices which are virtual
            // and have drivers in them and which were not skipped
            //
            if (SL_OEM_SOURCE_DEVICE_TYPE(CurrentDevice,
                    SL_OEM_SOURCE_DEVICE_TYPE_VIRTUAL) &&
                SL_OEM_SOURCE_MEDIA_TYPE(CurrentDevice,
                    SL_OEM_SOURCE_MEDIA_HAS_DRIVERS) &&
                !SL_OEM_SOURCE_DEVICE_STATE(CurrentDevice,
                    SL_OEM_SOURCE_DEVICE_SKIPPED)) {

                ULONGLONG ImageSize = 0;
                PVOID ImageBase = NULL;
                ULONG DeviceId = -1;
                FILE_INFORMATION FileInfo = {0};
                LARGE_INTEGER Start = {0};

                //
                // Open the device, only if needed
                //
                if (CurrentDevice->DeviceId == -1) {
                    Status = ArcOpen(CurrentDevice->ArcDeviceName,
                                ArcOpenReadOnly,
                                &DeviceId);
                } else {
                    DeviceId = CurrentDevice->DeviceId;
                }                    

                if (Status != ESUCCESS) {
                    break;
                }        

                //
                // Rewind the device
                //
                Status = ArcSeek(DeviceId, &Start, SeekAbsolute);

                if (Status != ESUCCESS) {
                    break;
                }                    

                //
                // Get the device size
                //
                Status = ArcGetFileInformation(DeviceId,
                            &FileInfo);

                if (Status != ESUCCESS) {
                    break;
                }

                //
                // NOTE : At the max we only allow 3MB per 
                // virtual device (should be only one device
                // in most of the cases)
                //
                if (FileInfo.EndingAddress.QuadPart > 0x300000) {
                    Status = E2BIG;
                } else {
                    ULONG   PageCount = 0;
                    ULONG   HeapPage = 0;
                    
                    //
                    // Allocate the memory for the disk image
                    //
                    ImageSize = FileInfo.EndingAddress.QuadPart;

#ifdef _X86_
                    //
                    // NOTE : Allocate "LoaderFirmwarePermanent" memory
                    // so that memory manager while initializing doesn't
                    // reclaim this memory. This also helps us to avoid 
                    // double copy -- i.e. this is the only location
                    // where we read the device contents into memory and 
                    // this memory is valid through out the textmode setup. 
                    //                        
                    // If we didn't allocate loader firmware permanent memory
                    // then setupdd.sys would have to allocate paged pool memory
                    // and replicate the contents from the loader block during
                    // initialization.
                    //                    
                    Status = BlAllocateDescriptor(
                                LoaderFirmwarePermanent,
                                0,
                                (ULONG)(ROUND_TO_PAGES(ImageSize) >> PAGE_SHIFT),
                                (PULONG)&HeapPage);                    

                    if (Status == ESUCCESS) {
                        ImageBase = (PVOID)(KSEG0_BASE | (HeapPage << PAGE_SHIFT));
                    }                                                
                        
#else
                    //
                    // NOTE : 05/13/2001 LoaderFirmwarePermanent doesn't seem to work on non
                    // x86 platforsm (particularly IA64). Till this issue is resolved
                    // we have to allocate memory from regular heap and we have to 
                    // replicate the memory in setupdd!SpInitialize0(..)
                    //
                    ImageBase = BlAllocateHeap((ULONG)ImageSize);

                    if (!ImageBase) {
                        Status = ENOMEM;
                    }                        
#endif

                    if (Status != ESUCCESS) {
                        break;
                    }
                    
                    if (ImageBase) {
                        ULONG BytesRead = 0;
                        
                        RtlZeroMemory(ImageBase, (ULONG)ImageSize);

                        //
                        // Read the whole device image in a single call
                        //
                        Status = ArcRead(DeviceId,
                                    ImageBase, 
                                    (ULONG)ImageSize,
                                    &BytesRead);

                        //
                        // NOTE : The approximate device size may 
                        // be bigger than the media size. So if we
                        // read atleast some bytes then we assume
                        // we are fine.
                        //
                        if ((BytesRead > 0) && (Status != ESUCCESS)) {
                            Status = ESUCCESS;
                        }
                    } else {
                        Status = ENOMEM;
                    }
                }                            

                if (Status != ESUCCESS) {
                    break;
                }

                //
                // Create a new virtual device node and put it in the 
                // list of virtual devices
                //
                NewVirtualDevice = BlAllocateHeap(sizeof(DETECTED_OEM_SOURCE_DEVICE));
                
                RtlZeroMemory(NewVirtualDevice, sizeof(DETECTED_OEM_SOURCE_DEVICE));

                if (NewVirtualDevice == NULL) {
                    Status = ENOMEM;

                    break;
                }                    
                    
                NewVirtualDevice->ArcDeviceName = SlCopyStringA(CurrentDevice->ArcDeviceName);
                NewVirtualDevice->ImageBase = ImageBase;
                NewVirtualDevice->ImageSize = ImageSize;

                DbgPrint("SETUPLDR: Virtual Device => %s (base:%p, size:%d)\n", 
                    NewVirtualDevice->ArcDeviceName,
                    ImageBase, 
                    (ULONG)ImageSize);
                
                //
                // Add the new device at the head of the linked list
                //
                if (!OemVirtualDevices) {
                    OemVirtualDevices = NewVirtualDevice;
                } else {
                    NewVirtualDevice->Next = OemVirtualDevices;
                    OemVirtualDevices = NewVirtualDevice;
                }                    
            }                    

            //
            // go on to next OEM source device
            //
            CurrentDevice = CurrentDevice->Next;
        }

        if (Status == ESUCCESS) {
            SetupLoaderBlock->OemSourceDevices = OemVirtualDevices;
        }            
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\cs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\setup.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    setup.c

Abstract:

    This module contains the code that implements the NT setup loader

Author:

    John Vert (jvert) 6-Oct-1993

Environment:

    ARC Environment

Revision History:

--*/
#include <setupbat.h>
#include "setupldr.h"
#include "stdio.h"
#include "string.h"
#include "stdlib.h"
#include <dockinfo.h>
#include <netboot.h>
#include <ramdisk.h>
#include "acpitabl.h"

#ifdef i386
#include <bldrx86.h>
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#if defined(EFI)
#include "bootefi.h"
#endif

#if defined(_IA64_)
UCHAR OsLoaderName[] = "setupldr.efi";
#else
UCHAR OsLoaderName[] = "setupldr.exe";
#endif

#if defined(_WIN64) && defined(_M_IA64)
#pragma section(".base", long, read, write)
__declspec(allocate(".base"))
extern
PVOID __ImageBase;
#else
extern
PVOID __ImageBase;
#endif

#define BlDiagLoadMessage(x,y,z)

#define DRIVER_DATABASE_FILENAME L"drvmain.sdb"
#define KERNEL_UP_IMAGE_FILENAME "ntoskrnl.exe"
#define KERNEL_MP_IMAGE_FILENAME "ntkrnlmp.exe"
CHAR KernelImage[13];
BOOLEAN UseCommandConsole = FALSE;
BOOLEAN g_RollbackEnabled = FALSE;
BOOLEAN TryASRViaNetwork = FALSE;

CHAR KdFileName[8+1+3+1]="KDCOM.DLL";
BOOLEAN UseAlternateKdDll = FALSE;
#define KD_ALT_DLL_PREFIX_CHARS 2
#define KD_ALT_DLL_REPLACE_CHARS 6


#define DBG_OUT(x)

/*
//
//  For debugging purposes
//  Example:
//
//        DBG_OUT("Testing")
//
#define DBG_OUT(x) {                                                            \
    if (x) {                                                                    \
        BlPositionCursor(5, 10);                                                \
        BlPrint("                                                        ");    \
        BlPositionCursor(5, 10);                                                \
        BlPrint(x);                                                             \
        while (!SlGetChar());                                                   \
    }                                                                           \
}

//
//  For debugging purposes
//  Example:
//
//      DebugOutput("Calling SlDetectScsi(). Line = %d. %s\n",__LINE__,"")
//
//
#define DebugOutput(X,Y,Z) {                                      \
    if (ARC_CONSOLE_OUTPUT) {                                      \
        CHAR _b[128];                                                \
        ULONG _c;                                                    \
        sprintf(&_b[0], X, Y, Z);                                    \
        ArcWrite(ARC_CONSOLE_OUTPUT, &_b[0], strlen(&_b[0]), &_c); \
        SlGetChar();                                                \
    }                                                                \
}
*/

//
// Define external static data.
//

ULONG BlConsoleOutDeviceId = ARC_CONSOLE_OUTPUT;
ULONG BlConsoleInDeviceId = ARC_CONSOLE_INPUT;

//
// Global string constants.
//
PCHAR FilesSectionName = "SourceDisksFiles";
PCHAR MediaSectionName = "SourceDisksNames";

#if defined(_AXP64_)
PCHAR PlatformExtension = ".axp64";
#elif defined(_ALPHA_)
PCHAR PlatformExtension = ".alpha";
#elif defined(_IA64_)
PCHAR PlatformExtension = ".ia64";
#elif defined(_X86_)
PCHAR PlatformExtension = ".x86";
#endif

//
// Global data
//

ULONG BlDcacheFillSize = 32;
ULONG BlVirtualBias = 0;

//
// Global setupldr control values
//
MEDIA_TYPE BootMedia;
MEDIA_TYPE InstallMedia;
PCHAR BootDevice;
ULONG BootDeviceId;
BOOLEAN BootDeviceIdValid = FALSE;
PCHAR BootPath;
ULONG BootDriveNumber;
ULONG InstallDriveNumber;
PCHAR HalName;
PCHAR HalDescription;
PCHAR AnsiCpName;
PCHAR OemHalFontName;
UNICODE_STRING AnsiCodepage;
UNICODE_STRING OemCodepage;
UNICODE_STRING UnicodeCaseTable;
UNICODE_STRING OemHalFont;

#ifdef _WANT_MACHINE_IDENTIFICATION
UNICODE_STRING BiosInfo;
#endif

BOOLEAN LoadScsiMiniports;
BOOLEAN LoadDiskClass;
BOOLEAN LoadCdfs;
BOOLEAN FixedBootMedia = FALSE;
BOOLEAN FloppyBoot = FALSE;

PVOID InfFile;
PVOID WinntSifHandle;
PVOID MigrateInfHandle;
ULONG BootFontImageLength = 0;
PVOID UnsupDriversInfHandle;
BOOLEAN IgnoreMissingFiles;
BOOLEAN BlUsePae;
BOOLEAN UseRegularBackground = TRUE;
BOOLEAN IsUpgrade = FALSE;

//
// OEM related variables
//
POEM_SOURCE_DEVICE OemSourceDevices = NULL;
POEM_SOURCE_DEVICE DefaultOemSourceDevice = NULL;
POEM_SOURCE_DEVICE AutoLoadOemHalDevice = NULL;
BOOLEAN AutoLoadOemScsi = FALSE;

//
//  Pre-install stuff
//

PCHAR   OemTag = "OEM";
PTCHAR   _TOemTag = TEXT("OEM");
BOOLEAN PreInstall = FALSE;
PTCHAR  ComputerType = NULL;
BOOLEAN OemHal = FALSE;
PPREINSTALL_DRIVER_INFO PreinstallDriverList = NULL;
POEM_SOURCE_DEVICE PreInstallOemSourceDevice = NULL;
PCHAR PreInstallSourcePath = NULL;

//
// Dynamic update variables
//
static BOOLEAN DynamicUpdate = FALSE;
static PCSTR   DynamicUpdateRootDir = NULL;
static POEM_SOURCE_DEVICE DynamicUpdateSourceDevice = NULL;

//
// WinPE (aka MiniNT) global variables
//
BOOLEAN WinPEBoot = FALSE;
BOOLEAN WinPEAutoBoot = FALSE;

PCTSTR  StartupMsg = NULL;

//
// Is used by HALACPI.DLL
//
BOOLEAN DisableACPI = FALSE;

BOOLEAN isOSCHOICE = FALSE;

//
// Primarily used by floppy boot support to key track 
// of the last disk read
// 
PCHAR LastDiskTag = NULL;



#if defined(ELTORITO)
extern BOOLEAN ElToritoCDBoot;
#endif

//
// Define transfer entry of loaded image.
//

typedef
VOID
(*PTRANSFER_ROUTINE) (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

#if defined(_IA64_)

VOID
BuildArcTree();

#endif

//
// Local function prototypes
//
VOID
SlGetSetupValuesBeforePrompt(
    IN PSETUP_LOADER_BLOCK SetupBlock
    );

VOID
SlGetSetupValuesAfterPrompt(
    IN PSETUP_LOADER_BLOCK SetupBlock
    );

ARC_STATUS
SlLoadDriver(
    IN PTCHAR  DriverDescription,
    IN PCHAR   DriverName,
    IN ULONG   DriverFlags,
    IN BOOLEAN InsertIntoDriverList,
    IN BOOLEAN MigratedDriver
    );

ARC_STATUS
SlLoadOemDriver(
    IN PCHAR  ExportDriver OPTIONAL,
    IN PCHAR  DriverName,
    IN PVOID  BaseAddress,
    IN PTCHAR LoadMessage
    );

PBOOT_DRIVER_LIST_ENTRY
SlpCreateDriverEntry(
    IN PCHAR DriverName
    );

    
ARC_STATUS
SlDetectMigratedScsiDrivers(
    IN PVOID Inf
    );

ARC_STATUS
SlGetMigratedHardwareIds(
    IN PSETUP_LOADER_BLOCK SetupBlock,
    IN PVOID               Inf
    );

BOOLEAN
SlpIsDiskVacant(
    IN PARC_DISK_SIGNATURE DiskSignature
    );

ARC_STATUS
SlpStampFTSignature(
    IN PARC_DISK_SIGNATURE DiskSignature,
    IN BOOLEAN  GenerateNewSignature
    );

VOID
SlpMarkDisks(
    IN BOOLEAN Reboot
    );


VOID
SlCheckOemKeypress(
    IN ULONG WaitTime
    );

VOID
SlCheckASRKeypress(
    VOID
    );

ARC_STATUS
SlLoadPnpDriversSection(
    IN PVOID Inf,
    IN PCHAR SectionName,
    IN OUT PDETECTED_DEVICE* DetectedDeviceList OPTIONAL
    );

BOOLEAN
SlIsUpgrade(
    IN PVOID SifHandle
    );

BOOLEAN
SlIsCdBootUpgrade(
    IN  PCHAR   InstallDirectory,
    IN  PCHAR   SetupFileName,
    IN  ULONG   MaxDisksToScan,
    IN  ULONG   MaxPartitionsPerDisk,
    OUT PCHAR   SetupDevice
    );

BOOLEAN
SlRemoveOsLoadOption(
    IN PSTR LoadOptions,
    IN PCSTR OptionToRemove
    );

ARC_STATUS
SlLoadBootFontFile(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    IN ULONG DiskId,
    IN ULONG BootFontImageLength
    );

//
// Dynamic update function prototypes
//
BOOLEAN
SlpIsDynamicUpdate(
    IN  PVOID   InfHandle,
    OUT PCSTR   *DynamicUpdateRootDir
    );


ARC_STATUS
SlInit(
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Envp
    )

/*++

Routine Description:

    The main startup routine for the NT Setup Loader.  This is the entrypoint
    called by the ARC firmware.

    If successful, this routine will never return, it will start NT directly.

Arguments:

    Argc - Supplies the number of arguments that were provided on the
        command that invoked this program.

    Argv - Supplies a pointer to a vector of pointers to null terminated
        argument strings.

    Envp - Supplies a pointer to a vector of pointers to null terminated
        environment variables.

Return Value:

    ARC_STATUS if unsuccessful.


--*/

{
    //
    // if we use too much stack space the heap and stack can overlap and we can run into corruption problems
    // without any "stack overflow" exceptions; making large strings static helps prevent this
    //

    PCONFIGURATION_COMPONENT_DATA DataCache;
    ARC_STATUS Status;
    ULONG LinesPerBlock;
    ULONG CacheLineSize;
    static CHAR SetupDevice[128];
    static CHAR SetupDirectory[128];
    static CHAR BadFileName[128];
    static CHAR CanonicalName[128];
    static CHAR HalDirectoryPath[256];
    static CHAR KernelDirectoryPath[256];
    PCHAR NetSetupServerShare;
    PCHAR NetSetupPath;
    PCHAR p;
    ULONG ErrorLine=0;
    ULONG DontCare;
    PVOID SystemBase;
    PVOID HalBase;
    PVOID LoaderBase;
    PVOID ScsiBase;
    PVOID VideoBase;
    PCHAR FileName;
    PVOID KdDllBase;
    static CHAR KdDllName[256];
    ULONG i;
    PKLDR_DATA_TABLE_ENTRY SystemDataTableEntry;
    PKLDR_DATA_TABLE_ENTRY HalDataTableEntry;
    PKLDR_DATA_TABLE_ENTRY KdDataTableEntry;
    PTRANSFER_ROUTINE SystemEntry;
    PIMAGE_NT_HEADERS NtHeaders;
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    PSETUP_LOADER_BLOCK SetupBlock;
    PDETECTED_DEVICE ScsiDevice;
    PCHAR VideoFileName;
    PTCHAR VideoDescription;
    PCHAR OemScsiName;
    POEMSCSIINFO OemScsiInfo = NULL;
    PCHAR OemVideoName;
    PVOID   OemInfHandle = NULL;
    BOOLEAN LoadedAVideoDriver = FALSE;
    static CHAR NetbootCardDriverName[24];
    static CHAR NetbootUser[64];
    static CHAR NetbootDomain[64];
    static CHAR NetbootPassword[64];
    static CHAR NetbootAdministratorPassword[OSC_ADMIN_PASSWORD_LEN];
    static CHAR NetbootSifFile[128];
    DOCKING_STATION_INFO dockInfo = { 0, 0, 0, FW_DOCKINFO_DOCK_STATE_UNKNOWN };
    PCONFIGURATION_COMPONENT_DATA dockInfoData;
    extern ULONG BlProgressBarShowTimeOut;
    ULONG OemKeypressTimeout = 5;   //secs

#if defined(REMOTE_BOOT)
    BOOLEAN RemoteBootEnableIpsec = FALSE;
#endif // defined(REMOTE_BOOT)
#if defined(_X86_) || defined(_IA64_)
    BOOLEAN Win9xUnsupHdc = FALSE;
#endif
    static FULL_PATH_SET PathSet;
    UNICODE_STRING DrvMainSdb;

#if DBG
    ULONG   StartTime = 0;
#endif

    //
    // Disable progress bar, by default.
    //
    BlProgressBarShowTimeOut = -1;

    //
    // Initialize the boot debugger for platforms that directly load the
    // OS Loader.
    //
    // N.B. This must occur after the console input and output have been
    //      initialized so debug messages can be printed on the console
    //      output device.
    //
    
#if defined(_ALPHA_) || defined(ARCI386) || defined(_IA64_)

    LoaderBase = &__ImageBase;

    //
    // Initialize traps and the boot debugger.
    //

#if defined(ENABLE_LOADER_DEBUG)

#if defined(_ALPHA_)

    BdInitializeTraps();

#endif
    
    BdInitDebugger(OsLoaderName, LoaderBase, ENABLE_LOADER_DEBUG);

#else

    BdInitDebugger(OsLoaderName, 0, NULL);

#endif

#endif
    
#if 0 && !defined(_IA64_)
//
// AJR bugbug -- do we really need to do this twice? we already call in SuMain()
//
// ChuckL -- Turned this code off because it screws up remote boot, which
//           does some allocations before we get here.
//
    //
    // Initialize the memory descriptor list, the OS loader heap, and the
    // OS loader parameter block.
    //    

    Status = BlMemoryInitialize();
    if (Status != ESUCCESS) {
        BlDiagLoadMessage(LOAD_HW_MEM_CLASS,
                          DIAG_BL_MEMORY_INIT,
                          LOAD_HW_MEM_ACT);
        goto LoadFailed;
    }

#endif

#if defined(_IA64_)
    //
    // Build required portion of ARC tree since we are not doing NTDETECT
    // anymore.
    //
    BuildArcTree();
#endif

    SetupBlock = BlAllocateHeap(sizeof(SETUP_LOADER_BLOCK));
    if (SetupBlock==NULL) {
        SlNoMemoryError();
        goto LoadFailed;
    }
    BlLoaderBlock->SetupLoaderBlock = SetupBlock;
    SetupBlock->ScsiDevices = NULL;
    SetupBlock->BootBusExtenders = NULL;
    SetupBlock->BusExtenders = NULL;
    SetupBlock->InputDevicesSupport = NULL;
    SetupBlock->Flags |= SETUPBLK_FLAGS_IS_TEXTMODE;

    SetupBlock->ScalarValues.SetupFromCdRom = FALSE;
    SetupBlock->ScalarValues.SetupOperation = SetupOperationSetup;
    SetupBlock->ScalarValues.LoadedScsi = 0;
    SetupBlock->ScalarValues.LoadedCdRomDrivers = 0;
    SetupBlock->ScalarValues.LoadedDiskDrivers = 0;
    SetupBlock->ScalarValues.LoadedFloppyDrivers = 0;
    SetupBlock->ScalarValues.LoadedFileSystems = 0;

    //
    // Initialize the NT configuration tree.
    //

    BlLoaderBlock->ConfigurationRoot = NULL;


    Status = BlConfigurationInitialize(NULL, NULL);
    if (Status != ESUCCESS) {
        BlDiagLoadMessage(LOAD_HW_FW_CFG_CLASS,
                          DIAG_BL_CONFIG_INIT,
                          LOAD_HW_FW_CFG_ACT);
        goto LoadFailed;
    }

    //
    // Compute the data cache fill size. This value is used to align
    // I/O buffers in case the host system does not support coherent
    // caches.
    //
    // If a combined secondary cache is present, then use the fill size
    // for that cache. Otherwise, if a secondary data cache is present,
    // then use the fill size for that cache. Otherwise, if a primary
    // data cache is present, then use the fill size for that cache.
    // Otherwise, use the default fill size.
    //

    DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                         CacheClass,
                                         SecondaryCache,
                                         NULL);

    if (DataCache == NULL) {
        DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                             CacheClass,
                                             SecondaryDcache,
                                             NULL);

        if (DataCache == NULL) {
            DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                                 CacheClass,
                                                 PrimaryDcache,
                                                 NULL);
        }
    }

    if (DataCache != NULL) {
        LinesPerBlock = DataCache->ComponentEntry.Key >> 24;
        CacheLineSize = 1 << ((DataCache->ComponentEntry.Key >> 16) & 0xff);
        BlDcacheFillSize = LinesPerBlock * CacheLineSize;
    }

    //
    // Initialize the OS loader I/O system.
    //

    Status = BlIoInitialize();
    if (Status != ESUCCESS) {
        BlDiagLoadMessage(LOAD_HW_DISK_CLASS,
                          DIAG_BL_IO_INIT,
                          LOAD_HW_DISK_ACT);
        goto LoadFailed;
    }

#if DBG
      StartTime = ArcGetRelativeTime();
#endif

    SlPositionCursor(5,3);

#if !defined(_IA64_)
    //
    // Initialize the message resources
    //
    Status = BlInitResources(Argv[0]);
    if (Status != ESUCCESS) {
       // if this fails, then we can't print out any messages,
       // so we just exit.
        return(Status);
    }
#endif

    //
    // If there is an ImageType parameter, this is a command console or rollback.
    //
    p = BlGetArgumentValue(Argc, Argv, "ImageType");
    if (p) {
        if (!strcmp (p, "cmdcons")) {
            UseCommandConsole = TRUE;
        } else if (!strcmp (p, "rollback")) {
            g_RollbackEnabled = TRUE;
        }
    }

#ifdef FORCE_CD_BOOT
    g_RollbackEnabled = FALSE;
#endif


    //
    // See if we're redirecting.
    //
    if( LoaderRedirectionInformation.PortAddress ) {

        //
        // Yes, we are redirecting right now.  Use these settings.
        //
        BlLoaderBlock->Extension->HeadlessLoaderBlock = BlAllocateHeap(sizeof(HEADLESS_LOADER_BLOCK));

        RtlCopyMemory( BlLoaderBlock->Extension->HeadlessLoaderBlock,
                       &LoaderRedirectionInformation,
                       sizeof(HEADLESS_LOADER_BLOCK) );

    } else {

        BlLoaderBlock->Extension->HeadlessLoaderBlock = NULL;

    }



    //
    // Initialize the display and announce ourselves
    //
    SlInitDisplay();

#if defined(_X86_) && !defined(ALLOW_386)
    //
    // Disallow installation on a 386 or any processor which
    // does not support CPUID and CMPXCHG8B instructions.
    //
    {
        extern BOOLEAN BlIs386(VOID);
        extern ULONG   BlGetFeatureBits(VOID);

        if(BlIs386()) {
            SlFatalError(SL_TEXT_REQUIRES_486);
        }

        //
        // CMPXCHG8B is required on Whistler and above.  This
        // implies a requirement for CPUID which is used to
        // determine the presence of CMPXCHG8B.
        //

        if ((BlGetFeatureBits() & 0x100) == 0) {
            SlFatalError(SL_TEXT_REQUIRED_FEATURES_MISSING);
        }
    }
#endif


#ifdef _IA64_
    //
    // Is this automated WinPE boot?
    //
    p = BlGetArgumentValue(Argc, Argv, "systempartition");

    if (p && SlIsWinPEAutoBoot(p)) {
        WinPEAutoBoot = TRUE;

        //
        // get the WinPE device & directory
        //
        if (ESUCCESS != SlGetWinPEStartupParams(SetupDevice, SetupDirectory)) {
            SlFriendlyError(
                Status,
                "SETUPLDR:Cannot find WinPE installation",
                __LINE__,
                __FILE__
                );

            goto LoadFailed;
        }     
    } 
#endif    

    if (!WinPEAutoBoot) {
        //
        // If this is a winnt setup, then we want to behave as if
        // we were started from the location specified by the
        // OSLOADPARTITION and OSLOADFILENAME nv-ram variables.
        //
        p = BlGetArgumentValue(Argc,Argv,"osloadoptions");

        if(p && !_stricmp(p,"winnt32")) {

            p = BlGetArgumentValue(Argc,Argv,"osloadpartition");
            if(!p) {
                SlError(100);
                goto LoadFailed;
            }

            Status = BlGenerateDeviceNames(p,SetupDevice,NULL);
            if (Status != ESUCCESS) {
                SlError(110);
                goto LoadFailed;
            }

            p = BlGetArgumentValue(Argc,Argv,"osloadfilename");
            if(!p || !(*p)) {
                SlError(120);
                goto LoadFailed;
            }

            strcpy(SetupDirectory,p);

            //
            // Make sure directory is terminated with a \.
            //
            if(SetupDirectory[strlen(SetupDirectory)-1] != '\\') {
                strcat(SetupDirectory,"\\");
            }
        } else {
            //
            // extract device name from our startup path
            //
            p=strrchr(Argv[0],')');
            if (p==NULL) {
                SlError(0);
                goto LoadFailed;
            }

            strncpy(SetupDevice, Argv[0], (int)(p-Argv[0]+1));
            SetupDevice[p-Argv[0]+1] = '\0';

            Status = BlGenerateDeviceNames(SetupDevice,CanonicalName,NULL);
            if (Status != ESUCCESS) {
                SlFriendlyError(
                    Status,
                    SetupDevice,
                    __LINE__,
                    __FILE__
                    );
                goto LoadFailed;
            }
            strcpy(SetupDevice,CanonicalName);

            //
            // If this is a remote boot, load winnt.sif. If we were passed
            // a path through the soft reboot use that, if not then look
            // in the same place that the loader was loaded from. Once we
            // have read winnt.sif we get the SetupSourceDevice path.
            //
            if (BlBootingFromNet) {

                NetGetRebootParameters(
                    NULL,
                    NULL,
                    NetbootSifFile,
                    NetbootUser,
                    NetbootDomain,
                    NetbootPassword,
                    NetbootAdministratorPassword,
                    TRUE);

                if (NetbootSifFile[0] != '\0') {
                    strcpy(BadFileName, NetbootSifFile);
                } else {
                    strcpy(BadFileName,NetBootPath);
                    strcat(BadFileName,WINNT_SIF_FILE_A);
                }


                if (NetbootAdministratorPassword[0] != '\0') {
                    //
                    // It's possible that the string contained in NetbootAdministratorPassword
                    // may not be terminated.  Just block copy the entire 64-bytes into the loader
                    // block, then we'll treat the data carefully in setupdd.sys when we read it
                    // back out.
                    //
                    RtlMoveMemory(BlLoaderBlock->SetupLoaderBlock->NetBootAdministratorPassword,
                                  NetbootAdministratorPassword,
                                  OSC_ADMIN_PASSWORD_LEN );
                }


                BlLoaderBlock->SetupLoaderBlock->WinntSifFile = NULL;
                BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength = 0;
                Status = SlInitIniFile(SetupDevice,
                                       0,
                                       BadFileName,
                                       &WinntSifHandle,
                                       &BlLoaderBlock->SetupLoaderBlock->WinntSifFile,
                                       &BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength,
                                       &DontCare);
                if(Status != ESUCCESS) {
                    if (NetbootSifFile[0] != '\0') {
                        SlFatalError(
                            SL_BAD_INF_FILE,
                            SlCopyStringAT(NetbootSifFile),
                            Status);
                    } else {
                        SlFatalError(
                            SL_BAD_INF_FILE,
                            WINNT_SIF_FILE,
                            Status);
                    }
                    goto LoadFailed;
                }

                //
                // Get the SetupSourceDevice parameter from winnt.sif.
                //
                // SetupSourceDevice is of the form "\Device\LanmanRedirector\server\share\setup\nt5".
                //

                NetSetupServerShare = SlGetSectionKeyIndex(WinntSifHandle,
                                                           "SetupData",
                                                           "SetupSourceDevice",
                                                           0);

#if DBG
                if ((strlen(NetSetupServerShare) + 1) > sizeof(SetupBlock->NetBootIMirrorFilePath)) {
                    DbgPrint("The UNC name is too long!\n");
                    goto LoadFailed;
                }
#endif

                strcpy(SetupBlock->NetBootIMirrorFilePath, NetSetupServerShare);

                if(NetSetupServerShare != NULL) {
                    // must start with '\'
                    if (*NetSetupServerShare != '\\') {
                        NetSetupServerShare = NULL;
                    } else {
                        // skip to '\' after Device
                        NetSetupServerShare = strchr(NetSetupServerShare+1,'\\');
                        if (NetSetupServerShare != NULL) {
                            // skip to '\' after LanmanRedirector (before server)
                            NetSetupServerShare = strchr(NetSetupServerShare+1,'\\');
                            if (NetSetupServerShare != NULL) {
                                // skip to '\' after server
                                NetSetupPath = strchr(NetSetupServerShare+1,'\\');
                                if (NetSetupPath != NULL) {
                                    // skip to '\' after share (path part)
                                    NetSetupPath = strchr(NetSetupPath+1,'\\');
                                }
                            }
                        }
                    }
                }
                if ((NetSetupServerShare == NULL) || (NetSetupPath == NULL)) {
                    SlFatalError(SL_INF_ENTRY_MISSING,TEXT("SetupSourceDevice"),TEXT("SetupData"));

                    goto LoadFailed;
                }
                *NetSetupPath = 0;                  // terminate server\share part
                NetSetupPath++;                     // remainder is path part

                //
                // If the TargetNtPartition parameter exists in winnt.sif, then
                // the target is remote, and this is a remote boot setup. Otherwise,
                // this is a remote installation setup.
                //

                if (SlGetSectionKeyIndex(WinntSifHandle,
                                         "SetupData",
                                         "TargetNtPartition",
                                         0) == NULL) {
                    PUCHAR pTmp, pTmp2;

                    pTmp = SlGetSectionKeyIndex(WinntSifHandle,
                                                "OSChooser",
                                                "ImageType",
                                                0);

                    if (pTmp != NULL) {

                        pTmp2 = pTmp;
                        while (*pTmp != '\0') {
                            *pTmp = (UCHAR)toupper(*pTmp);
                            pTmp++;
                        }

                        if (!strcmp(pTmp2, "SYSPREP")) {

                            pTmp = SlGetSectionKeyIndex(WinntSifHandle,
                                                        "SetupData",
                                                        "SysPrepDevice",
                                                        0);

                            if (pTmp != NULL) {
                                strcpy(SetupBlock->NetBootIMirrorFilePath, pTmp);
                            } else {
                                memset(SetupBlock->NetBootIMirrorFilePath,
                                       0x0,
                                       sizeof(SetupBlock->NetBootIMirrorFilePath)
                                      );
                            }
                            SetupBlock->Flags |= SETUPBLK_FLAGS_SYSPREP_INSTALL;
                        } else {
                            SetupBlock->Flags |= SETUPBLK_FLAGS_REMOTE_INSTALL;
                        }
                    } else {
                        SetupBlock->Flags |= SETUPBLK_FLAGS_REMOTE_INSTALL;
                    }
                }
            }

            //
            // extract directory from our startup path.
            //
            if (BlBootingFromNet) {
                strcpy(SetupDirectory, "\\");
                strcat(SetupDirectory, NetSetupPath);
            } else if (UseCommandConsole) {
                strcpy(SetupDirectory,"\\cmdcons");
            } else if(*(p+1) != '\\') {
                //
                // directory must begin at root
                //
                strcpy(SetupDirectory, "\\");
            } else {
                *SetupDirectory = '\0';
            }
            strcat(SetupDirectory, p+1);
            p=strrchr(SetupDirectory, '\\');
            *(p+1) = '\0';
        }
    }        


#if defined(ELTORITO)
    if (ElToritoCDBoot && !WinPEAutoBoot) {
        //
        // Use the i386 directory for setup files when we boot from an El Torito CD
        //                
        PCHAR   SetupDirectoryOnDisk = "\\$WIN_NT$.~BT";        
        CHAR    SetupBootDevice[128] = {0};
        ULONG   MaxDisksToScan = 1;         // on x86 only the first disk
        ULONG   MaxPartitionsToScan = 4;    // on x86 check only primary partitions
        BOOLEAN CheckUpgrades = TRUE;
        
#if defined(_IA64_)
        strcat(SetupDirectory, "ia64\\");

        /*
        //
        // Values for IA64 installation, currently not used
        //
        SetupDirectoryOnDisk = "\\$WIN_NT$.~LS\\ia64";
        MaxDisksToScan = 4;         // NOTE : arbitrary limit
        MaxPartitionsToScan = 4;    // NOTE : arbitrary limit
        */
        
        CheckUpgrades = FALSE;      // NOTE : Currently disabled on IA64
#else
        strcat(SetupDirectory, "i386\\");
#endif    

        //
        // If WinPE boot then disable check for CD boot upgrade
        // NOTE: We check for the presence of system32\\drivers directory
        // rather than relying on /minint flag in txtsetup.sif since we
        // have not yet loaded txtsetup.sif file
        //
        if (CheckUpgrades) {
            CHAR        DriversDir[128];
            ARC_STATUS  DirStatus;
            ULONG       DeviceId, DirId;            

            strcat(DriversDir, SetupDirectory);
            strcat(DriversDir, "system32\\drivers");

            DirStatus = ArcOpen(SetupDevice, ArcOpenReadOnly, &DeviceId);

            if (ESUCCESS == DirStatus) {
                DirStatus = BlOpen(DeviceId, DriversDir, ArcOpenDirectory, &DirId);

                if (ESUCCESS == DirStatus) {
                    CheckUpgrades = FALSE;      // looks like a WinPE boot
                    BlClose(DirId);
                }

                ArcClose(DeviceId);
            }                
        }            

        
        //
        // Figure out if user was already trying to upgrade
        // using winnt32.exe. If user confirms he is
        // wants to continue upgrading then switch to
        // harddisk
        //
        if (CheckUpgrades && 
            SlIsCdBootUpgrade(SetupDirectoryOnDisk,
                            WINNT_SIF_FILE_A,
                            MaxDisksToScan,
                            MaxPartitionsToScan,
                            SetupBootDevice)) {
            strcpy(SetupDevice, SetupBootDevice);
            strcpy(SetupDirectory, SetupDirectoryOnDisk);
            strcat(SetupDirectory, "\\");
            ElToritoCDBoot = FALSE;
        }                    
    }
#endif

    //
    // Turn on ability to load compressed files.
    //
    DecompEnableDecompression(TRUE);


    ///////////////////////////////////////////////////////////////////
    //
    //  On x86, the files loaded from now on are on boot floppy #1
    //  HALs may be on floppy #1 or floppy #2
    //
    ///////////////////////////////////////////////////////////////////

    strcpy(KernelDirectoryPath, SetupDirectory);
    strcat(KernelDirectoryPath, "txtsetup.sif");

    BlLoaderBlock->SetupLoaderBlock->IniFile = NULL;

    Status = SlInitIniFile(SetupDevice,
                           0,
                           KernelDirectoryPath,
                           &InfFile,
                           &BlLoaderBlock->SetupLoaderBlock->IniFile,
                           &BlLoaderBlock->SetupLoaderBlock->IniFileLength,
                           &ErrorLine);
    if (Status != ESUCCESS) {

        //
        // See if we can get the txtsetup.sif out of the WinPE boot
        // directory.
        //
        if( (strcmp( SetupDirectory, "\\") == 0) &&
            (!ElToritoCDBoot) &&
            (!BlBootingFromNet) ) {
            //
            // We're not booting off CD and we're not booting off the
            // net and we're about to fail because we didn't find \txtsetup.sif
            // Try in the MiniNT directory...
            //
            Status = SlInitIniFile(SetupDevice,
                       0,
                       "\\minint\\txtsetup.sif",
                       &InfFile,
                       &BlLoaderBlock->SetupLoaderBlock->IniFile,
                       &BlLoaderBlock->SetupLoaderBlock->IniFileLength,
                       &ErrorLine);
        }

        if( Status != ESUCCESS ) {
            SlFatalError(SL_BAD_INF_FILE,
                TEXT("txtsetup.sif"),
                Status);
            
            goto LoadFailed;
        }
    }

    SlGetSetupValuesBeforePrompt(SetupBlock);

    //
    // Find out if we are starting the MiniNT boot or rollback
    // (mutually exclusive options)
    //
    if (BlLoaderBlock->LoadOptions) {
        CHAR    Option[256];
        PCHAR   NextOption = strchr(BlLoaderBlock->LoadOptions, '/');
        PCHAR   OptionEnd = NULL;


        while (NextOption) {
            OptionEnd = strchr(NextOption, ' ');

            if (OptionEnd) {
                strncpy(Option, NextOption, OptionEnd - NextOption);
                Option[OptionEnd - NextOption] = 0;
            } else {
                strcpy(Option, NextOption);
            }

            if (!_stricmp(Option, "/minint")) {
                WinPEBoot = TRUE;
                break;
            }

            NextOption++;
            NextOption = strchr(NextOption, '/');
        }
    }

    //
    // Fix up the setup directory path to include system32 also
    // if this is a MiniNT boot
    //
    if (WinPEBoot) {
        strcat(SetupDirectory, "system32\\");

        // 
        // find out if a different load message has been specified
        //
#ifdef UNICODE        
        StartupMsg = SlGetIniValueW(InfFile,
#else        
        StartupMsg = (PCTSTR)SlGetIniValue(InfFile,
#endif        
                        "setupdata",
                        "loaderprompt",
                        NULL);

        //
        // Reduce the OEM key press time out
        //
        OemKeypressTimeout = 2; // secs
    }

    //
    // Now we know everything we should load, compute the ARC name to load
    // from and start loading things.
    //
    if (BootDevice==NULL) {
        //
        // No device was explicitly specified, so use whatever device
        // setupldr was started from.
        //

        BootDevice = SlCopyStringA(SetupDevice);
    }

    Status = ArcOpen(BootDevice, ArcOpenReadOnly, &BootDeviceId);

    if (Status != ESUCCESS) {
        SlFatalError(SL_IO_ERROR,SlCopyStringAT(BootDevice));
        goto LoadFailed;
    } else {
        BootDeviceIdValid = TRUE;
    }

#ifdef _X86_
    //
    // Load the bootfont.bin into memory
    //
    SlLoadBootFontFile(BlLoaderBlock->SetupLoaderBlock,
        BootDeviceId,
        BootFontImageLength);
#endif // _X86_

    _strlwr(BootDevice);
    FixedBootMedia = (strstr(BootDevice,")rdisk(") != NULL);
    FloppyBoot = (strstr(BootDevice, ")fdisk(") != NULL);

    //
    // If we are booting from fixed media, we better load disk class drivers.
    //
    if(FixedBootMedia) {
        LoadDiskClass = TRUE;
    }

    if(!BlGetPathMnemonicKey(BootDevice,"disk",&DontCare)
    && !BlGetPathMnemonicKey(BootDevice,"fdisk",&BootDriveNumber))
    {
        //
        // boot was from floppy, canonicalize the ARC name.
        //
        BlLoaderBlock->ArcBootDeviceName = BlAllocateHeap(80);
        sprintf(BlLoaderBlock->ArcBootDeviceName, "multi(0)disk(0)fdisk(%d)",BootDriveNumber);
    } else {
        BlLoaderBlock->ArcBootDeviceName = BootDevice;
    }
    if (BootPath==NULL) {
        //
        // No explicit boot path given, default to the directory setupldr was started
        // from.
        //
#if defined(_X86_)
        //
        // Increadibly nauseating hack:
        //
        // If we are booting from hard drive on x86, we will assume this is
        // the 'floppyless' winnt/winnt32 scenario, in which case the actual
        // boot path is \$win_nt$.~bt.
        //
        // This lets us avoid having winnt and winnt32 attempt to modify
        // the BootPath value in the [SetupData] section of txtsetup.sif.
        //
        if( (FixedBootMedia) || (WinPEBoot && FloppyBoot) ) {
            CHAR SetupPath[256];
            
            if( WinPEBoot ) {
                strcpy(SetupPath, "\\minint\\system32\\");
            } else if( UseCommandConsole ) {
               strcpy(SetupPath, "\\CMDCONS\\");
            } else {
               strcpy(SetupPath, "\\$WIN_NT$.~BT\\");
            }
            BootPath = SlCopyStringA(SetupPath);
        } else
#endif
        BootPath = SlCopyStringA(SetupDirectory);
    }


    //
    // Load the WinPE inf, if present.
    //
    if (WinPEBoot) {
        CHAR    FullPath[128];

        strcpy(FullPath, BootPath);
        strcat(FullPath, WINPE_OEM_FILENAME_A);
        
        Status = SlInitIniFile(NULL,
                       BootDeviceId,
                       FullPath,
                       &OemInfHandle,
                       NULL,
                       0,
                       &ErrorLine);

        if (Status != ESUCCESS) {
            OemInfHandle = NULL;
            Status = ESUCCESS;
        }
    }        

#ifdef _WANT_MACHINE_IDENTIFICATION

    BlLoaderBlock->Extension->InfFileImage = NULL;
    BlLoaderBlock->Extension->InfFileSize = 0;
    if (BiosInfo.Buffer) {

        if (Status == ESUCCESS) {

            Status = BlLoadBiosinfoInf( BootDeviceId,
                                        BlFindMessage(SL_BIOSINFO_NAME),
                                        BootPath,
                                        &BiosInfo,
                                        &BlLoaderBlock->Extension->InfFileImage,
                                        &BlLoaderBlock->Extension->InfFileSize,
                                        BadFileName);
        }


        if (Status != ESUCCESS) {
            SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(BadFileName), Status);
            goto LoadFailed;
        }
    }

#endif

    //
    // Let the kernel deal with failure to load this driver database.
    //

    BlLoaderBlock->Extension->DrvDBImage = NULL;
    BlLoaderBlock->Extension->DrvDBSize = 0;
    DrvMainSdb.Buffer = DRIVER_DATABASE_FILENAME;
    DrvMainSdb.Length = DrvMainSdb.MaximumLength = sizeof(DRIVER_DATABASE_FILENAME) - sizeof(UNICODE_NULL);
    BlLoadDrvDB(    BootDeviceId,
                    NULL, // BlFindMessage(SL_DRVMAINSDB_NAME),
                    BootPath,
                    &DrvMainSdb,
                    &BlLoaderBlock->Extension->DrvDBImage,
                    &BlLoaderBlock->Extension->DrvDBSize,
                    BadFileName);

    //
    // Attempt to load winnt.sif from the path where we are
    // loading setup files. Borrow the BadFileName buffer
    // for temporary use.
    //
    if (!BlBootingFromNet) {
        CHAR FloppyName[80];
        ULONG FloppyId;
        BOOLEAN FloppyUsed = FALSE;

        if (SlpFindFloppy(0,FloppyName)) {
            Status = ArcOpen(FloppyName,ArcOpenReadOnly,&FloppyId);

            if (Status == ESUCCESS) {
                strcpy(BadFileName,"\\");
                strcat(BadFileName,WINNT_SIF_FILE_A);
                BlLoaderBlock->SetupLoaderBlock->WinntSifFile = NULL;
                BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength = 0;
                Status = SlInitIniFile(
                    NULL,
                    FloppyId,
                    BadFileName,
                    &WinntSifHandle,
                    &BlLoaderBlock->SetupLoaderBlock->WinntSifFile,
                    &BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength,
                    &DontCare
                    );
                if (Status == ESUCCESS) {
                    FloppyUsed = TRUE;
                }

                ArcClose(FloppyId);
            }
        }

        if (!FloppyUsed) {
            strcpy(BadFileName,BootPath);
            strcat(BadFileName,WINNT_SIF_FILE_A);
            BlLoaderBlock->SetupLoaderBlock->WinntSifFile = NULL;
            BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength = 0;
            Status = SlInitIniFile(
                NULL,
                BootDeviceId,
                BadFileName,
                &WinntSifHandle,
                &BlLoaderBlock->SetupLoaderBlock->WinntSifFile,
                &BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength,
                &DontCare
                );
        }

    }

    IsUpgrade = SlIsUpgrade(WinntSifHandle);
    UseRegularBackground = (UseCommandConsole || IsUpgrade || WinPEBoot);

    //
    // If the BIOS told us to redirect, we'd be doing it right now.  However,
    // the user may have told us some specific settings.  If that's the case,
    // override anything we're doing now with the settings from the user.
    //
    if( WinntSifHandle ) {

        UCHAR   UnattendTerminalPortNumber = 0;
        PUCHAR  UnattendTerminalPortAddress = NULL;
        ULONG   UnattendBaudRate = (ULONG)BD_9600;


        p = SlGetSectionKeyIndex(WinntSifHandle, WINNT_DATA_A, WINNT_U_HEADLESS_REDIRECT_A, 0);

        if (p != NULL) {

            BlLoaderBlock->Extension->HeadlessLoaderBlock = BlAllocateHeap(sizeof(HEADLESS_LOADER_BLOCK));
            if (BlLoaderBlock->Extension->HeadlessLoaderBlock == NULL) {
                SlNoMemoryError();
                goto LoadFailed;
            }

            RtlZeroMemory( BlLoaderBlock->Extension->HeadlessLoaderBlock, sizeof(HEADLESS_LOADER_BLOCK) );

            if (!_strnicmp(p, "com", 3)) {

                UnattendTerminalPortNumber = (UCHAR)atoi( (PCHAR)(p+3) );
                switch( UnattendTerminalPortNumber ) {
                    case 4:
                        UnattendTerminalPortAddress = (PUCHAR)COM4_PORT;
                        break;
                    case 3:
                        UnattendTerminalPortAddress = (PUCHAR)COM3_PORT;
                        break;
                    case 2:
                        UnattendTerminalPortAddress = (PUCHAR)COM2_PORT;
                        break;
                    default:
                        UnattendTerminalPortAddress = (PUCHAR)COM1_PORT;
                        break;
                }

                //
                // See if they want to give us a baudrate.
                //
                p = SlGetSectionKeyIndex( WinntSifHandle, WINNT_DATA_A, WINNT_U_HEADLESS_REDIRECTBAUDRATE_A, 0 );
                if( p ) {
                    UnattendBaudRate = (ULONG)atoi( (PCHAR)(p) );
                }

                //
                // Make sure the baudrate is something we recognize.
                //
                if( (UnattendBaudRate != BD_115200) &&
                    (UnattendBaudRate != BD_57600) &&
                    (UnattendBaudRate != BD_19200) ) {

                    UnattendBaudRate = (ULONG)BD_9600;
                }               


                //
                // Time to fill up the loader block with all the information we
                // just retrieved from the unattend file.
                //
                BlLoaderBlock->Extension->HeadlessLoaderBlock->PortNumber = UnattendTerminalPortNumber;
                BlLoaderBlock->Extension->HeadlessLoaderBlock->BaudRate = UnattendBaudRate;
                BlLoaderBlock->Extension->HeadlessLoaderBlock->Parity = 0;
                BlLoaderBlock->Extension->HeadlessLoaderBlock->StopBits = 1;
                BlLoaderBlock->Extension->HeadlessLoaderBlock->UsedBiosSettings = FALSE;
                BlLoaderBlock->Extension->HeadlessLoaderBlock->PortAddress = UnattendTerminalPortAddress;

                RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );
                RtlCopyMemory( &LoaderRedirectionInformation,
                               BlLoaderBlock->Extension->HeadlessLoaderBlock,
                               sizeof(HEADLESS_LOADER_BLOCK) );

                BlInitializeHeadlessPort();
                SlClearDisplay();

            } else if( !_stricmp(p, "usebiossettings" ) ) {


                //
                // Now we get to dig up all the information from the
                // ACPI table.
                //
                if( BlRetrieveBIOSRedirectionInformation() ) {

                    RtlCopyMemory( BlLoaderBlock->Extension->HeadlessLoaderBlock,
                                   &LoaderRedirectionInformation,
                                   sizeof(HEADLESS_LOADER_BLOCK) );


                    //
                    // No need to call off to BlInitializeHeadlessPort here because
                    // if there are any BIOS settings, we would have already picked
                    // them up by now and would already be redirecting.
                    //

                } else {

                    //
                    // We can't retrieve the information we need.
                    //
                    BlLoaderBlock->Extension->HeadlessLoaderBlock = NULL;
                }

            } else if( !_stricmp(p, "noncomport" ) ) {

                //
                // It's something other than serial.  Go load a file off the floppy
                // and get the driver from there.
                //

                //
                // Currently not implemented.
                //
                BlLoaderBlock->Extension->HeadlessLoaderBlock = NULL;


            } else {

                //
                // We got something we didn't recognize.
                //
                BlLoaderBlock->Extension->HeadlessLoaderBlock = NULL;
            }

        }

    }


    if (UseRegularBackground) {
        extern BOOLEAN BlOutputDots;
        extern int BlMaxFilesToLoad;

        SlSetCurrentAttribute(DEFATT);
        SlSetStatusAttribute(DEFATT);
        SlClearDisplay();
        SlPositionCursor(0,0);

        if (UseCommandConsole) {
            SlPrint(BlFindMessage(SL_CMDCONS_MSG));
        }

        BlOutputDots = TRUE;

        //
        // To reset BlShowProgress bar correctly
        //
        BlProgressBarShowTimeOut = 0;   

        //
        // Note : We can compute the real number of drivers to be loaded
        // from various INF sections and manually counting all the
        // different SlLoadDriver(...) calls. But the code/effort required
        // to do this is not worth the feature, since we just want to
        // replace the old "..." with progress bar to make the recovery
        // console starting look similar to windows starting. So we make
        // an assumption here about the maximum files to be loaded.
        //
        BlMaxFilesToLoad = 80;

        BlSetProgBarCharacteristics(SL_CMDCONS_PROGBAR_FRONT,
                        SL_CMDCONS_PROGBAR_BACK);

        if (WinPEBoot) {
            StartupMsg ? BlOutputStartupMsgStr(StartupMsg) :
                         BlOutputStartupMsg(SL_SETUP_STARTING_WINPE);
        } else if (UseCommandConsole) {
            BlOutputStartupMsg(SL_CMDCONS_STARTING);
        } else if (g_RollbackEnabled) {
            BlOutputStartupMsg(SL_ROLLBACK_STARTING);
        } else if (IsUpgrade) {
            BlOutputStartupMsg(SL_SETUP_STARTING);
        }
    } else {
        extern ULONG BlProgressBarShowTimeOut;
        
        BlProgressBarShowTimeOut = -1;
        SlSetCurrentAttribute(DEFATT);
        SlSetStatusAttribute(DEFSTATTR);
        SlClearDisplay();
        SlWriteHeaderText(SL_WELCOME_HEADER);
        SlClearClientArea();
    }

    //
    // remove the /noguiboot option so what we show the logo
    // and switch the video adapter into graphics mode
    // early on during initialization
    //
    if (IsUpgrade) {
        PSTR LoadOptions = SlCopyStringA(BlLoaderBlock->LoadOptions);
        
        if (SlRemoveOsLoadOption(LoadOptions, "/noguiboot")) {
            BlLoaderBlock->LoadOptions = LoadOptions;
        }
    }

    //
    // Figure out all the OEM drivers source devices
    //
    RamdiskInitialize(BlLoaderBlock->LoadOptions, FALSE);
    SlInitOemSourceDevices(&OemSourceDevices, &DefaultOemSourceDevice);

    //
    // If we found at least one valid OEM source device with proper
    // txtsetup.oem and no default driver then bump up the timeout to
    // 20 secs
    //
    if (OemSourceDevices) {
        POEM_SOURCE_DEVICE  CurrDevice = OemSourceDevices;

        while(CurrDevice) {
            if (SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice, 
                    SL_OEM_SOURCE_MEDIA_HAS_DRIVERS) &&
                !SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                    SL_OEM_SOURCE_MEDIA_HAS_DEFAULT)) {
                OemKeypressTimeout = 20;

                break;
            }         

            CurrDevice = CurrDevice->Next;
        }
    }

    //
    // We need to check to see if the user pressed any keys to force OEM HAL,
    // OEM SCSI, or both. Do this before getting the settings in the sif file,
    // so that we won't try to detect the machine if OEM HAL is needed.    
    //
    SlCheckOemKeypress(OemKeypressTimeout);


#if defined(_X86_) || defined(_IA64_)
    //
    // We need to check to see if the user pressed any keys to force loading,
    // an ASR pnp repair disk.  Only do this if the user didn't select
    // anything in the SlCheckOemKeypress function.
    //
    if(!UseCommandConsole && !WinPEBoot && !IsUpgrade && !BlBootingFromNet) {

        PCHAR pTmp;

        pTmp = SlGetSectionKeyIndex(InfFile,
                                    "SetupData",
                                    "DisableAsr",
                                     0);

        if ((pTmp == NULL) || (atoi(pTmp) == 0)) {
            SlCheckASRKeypress();
        }
    }    

    if (BlBootingFromNet && TryASRViaNetwork) {
        PVOID ASRPNPSifHandle = NULL;
        ULONG c;
        PCHAR FileNameFromSif;

        FileNameFromSif = SlGetIniValue( 
                                WinntSifHandle,
                                "OSChooser",
                                "ASRFile",
                                "generic.sif" );

        Status = SlInitIniFile( SetupDevice,
                                0,
                                FileNameFromSif,
                                &ASRPNPSifHandle,
                                &BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFile,
                                &BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFileLength,
                                &c );

        if(Status != ESUCCESS) {
            SlFatalError(SL_BAD_INF_FILE,SlCopyStringAT(FileNameFromSif),Status);
            goto LoadFailed;
        }        
    }

#endif

    SlGetSetupValuesAfterPrompt(SetupBlock);


    //
    // Are there any dyamic update boot drivers which we need
    // to process
    //
    DynamicUpdate = SlpIsDynamicUpdate(WinntSifHandle, &DynamicUpdateRootDir);

    //
    // Add the dynamic update source device as OEM source device since it could
    // have F6 
    //
    if (DynamicUpdate) {
        DynamicUpdateSourceDevice = BlAllocateHeap(sizeof(OEM_SOURCE_DEVICE));

        if (DynamicUpdateSourceDevice) {
            memset(DynamicUpdateSourceDevice, 0, sizeof(OEM_SOURCE_DEVICE));
            
            strcpy(DynamicUpdateSourceDevice->ArcDeviceName,
                    BootDevice);
                    
            DynamicUpdateSourceDevice->DriverDir = DynamicUpdateRootDir;

            SL_OEM_SET_SOURCE_DEVICE_TYPE(DynamicUpdateSourceDevice,
                (SL_OEM_SOURCE_DEVICE_TYPE_LOCAL |
                 SL_OEM_SOURCE_DEVICE_TYPE_FIXED |
                 SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE));

            SL_OEM_SET_SOURCE_MEDIA_TYPE(DynamicUpdateSourceDevice,
                (SL_OEM_SOURCE_MEDIA_PRESENT |
                 SL_OEM_SOURCE_MEDIA_HAS_DRIVERS |
                 SL_OEM_SOURCE_MEDIA_HAS_MSD |
                 SL_OEM_SOURCE_MEDIA_HAS_DEFAULT));

            SL_OEM_SET_SOURCE_DEVICE_STATE(DynamicUpdateSourceDevice,
                SL_OEM_SOURCE_DEVICE_NOT_PROCESSED);

            DynamicUpdateSourceDevice->DeviceId = BootDeviceId;

            //
            // Insert it at the head of the linked list
            //
            DynamicUpdateSourceDevice->Next = OemSourceDevices;
            OemSourceDevices = DynamicUpdateSourceDevice;
        }
    }


    if (BlBootingFromNet || (Status == ESUCCESS)) {


        //
        //  Find out if this is a pre-install, by looking at OemPreinstall key
        //  in [unattended] section of winnt.sif
        //
        p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_UNATTENDED_A,WINNT_U_OEMPREINSTALL_A,0);
        if(p && !_stricmp(p,"yes")) {
            PreInstall = TRUE;
        }

        //
        //  If this is a pre-install, find out which hal to load, by looking
        //  at ComputerType key in [unattended] section of winnt.sif.
        //
        if( PreInstall && !DynamicUpdate) {
#ifdef UNICODE
            ComputerType = (PTCHAR)SlGetSectionKeyIndexW(
#else
            ComputerType = (PTCHAR)SlGetSectionKeyIndex(      
#endif
                                            WinntSifHandle,
                                            WINNT_UNATTENDED_A,
                                            WINNT_U_COMPUTERTYPE_A,
                                            0);
            if(ComputerType) {
                //
                // If the hal to load is an OEM one, then set OemHal to TRUE
                //
                p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_UNATTENDED_A,WINNT_U_COMPUTERTYPE_A,1);
                if(p && !_stricmp(p, OemTag)) {
                    OemHal = TRUE;
                } else {
                    OemHal = FALSE;
                }
                //
                //  In the pre-install mode, don't let the user specify
                //  an OEM hal, if one was specified in unattend.txt
                //
                PromptOemHal = FALSE;
            }

            //
            //  Find out which SCSI drivers to load, by looking at
            //  [MassStorageDrivers] in winnt.sif
            //
            if( SpSearchINFSection( WinntSifHandle, WINNT_OEMSCSIDRIVERS_A ) ) {
                ULONG   i;
                PPREINSTALL_DRIVER_INFO TempDriverInfo;
                PTSTR  pOem;
#ifdef UNICODE
                CHAR DriverDescriptionA[100];
                UNICODE_STRING uString;
                ANSI_STRING aString;                
#endif

                PreinstallDriverList = NULL;
                for( i = 0;
#ifdef UNICODE
                     ((pOem = SlGetKeyNameW( 
#else
                     ((pOem = SlGetKeyName(
#endif
                                WinntSifHandle, 
                                WINNT_OEMSCSIDRIVERS_A, 
                                i )) != NULL);
                     i++ ) {
                    TempDriverInfo = BlAllocateHeap(sizeof(PREINSTALL_DRIVER_INFO));
                    if (TempDriverInfo==NULL) {
                        SlNoMemoryError();
                        goto LoadFailed;
                    }
                    TempDriverInfo->DriverDescription = pOem;
#ifdef UNICODE
                    RtlInitUnicodeString( &uString, TempDriverInfo->DriverDescription);
                    aString.Buffer = DriverDescriptionA;
                    aString.MaximumLength = sizeof(DriverDescriptionA);
                    RtlUnicodeStringToAnsiString( &aString, &uString, FALSE );
                    pOem = SlGetIniValueW( 
                                WinntSifHandle,
                                WINNT_OEMSCSIDRIVERS_A,
                                DriverDescriptionA,
                                NULL );                    
#else
                    pOem = SlGetIniValue( 
                                WinntSifHandle,
                                WINNT_OEMSCSIDRIVERS_A,
                                TempDriverInfo->DriverDescription,
                                NULL );                                        
#endif
                    TempDriverInfo->OemDriver = (pOem && !_tcsicmp(pOem, _TOemTag))? TRUE : FALSE;
                    TempDriverInfo->Next = PreinstallDriverList;
                    PreinstallDriverList = TempDriverInfo;
                }
                if( PreinstallDriverList != NULL ) {
                    //
                    //  In the pre-install mode, don't let the user specify
                    //  an OEM scsi, if at least one was specified in unattend.txt
                    //
                    PromptOemScsi = FALSE;
                }
            }
        }

        p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_SETUPPARAMS_A,WINNT_S_SKIPMISSING_A,0);
        if(p && (*p != '0')) {
            IgnoreMissingFiles = TRUE;
        }

#if defined(_X86_) || defined(_IA64_)
        //
        //  Find out if this is a Win9x upgrade
        //
        Win9xUnsupHdc = FALSE;
        p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_DATA_A,WINNT_D_WIN95UPGRADE_A,0);
        if(p && !_stricmp(p, WINNT_A_YES_A)) {
            //
            //  If it is an Win9x upgrade, find out if winnt32 found an unsupported
            //  hard disk controller.
            //
            p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_DATA_A,WINNT_D_WIN95UNSUPHDC_A,0);
            if(p && (*p != '0')) {
                Win9xUnsupHdc = TRUE;
            }
        }
#endif

        //
        //  At this point, we know that we wre able to read winnt.sif.
        //  So attempt to read migrate.inf. Borrow the BadFileName buffer
        //  for temporary use.
        //
        strcpy(BadFileName,BootPath);
        strcat(BadFileName,WINNT_MIGRATE_INF_FILE_A);
        if( SlInitIniFile(NULL,
                          BootDeviceId,
                          BadFileName,
                          &MigrateInfHandle,
                          &BlLoaderBlock->SetupLoaderBlock->MigrateInfFile,
                          &BlLoaderBlock->SetupLoaderBlock->MigrateInfFileLength,
                          &DontCare) != ESUCCESS ) {
            MigrateInfHandle = NULL;
            BlLoaderBlock->SetupLoaderBlock->MigrateInfFile = NULL;
            BlLoaderBlock->SetupLoaderBlock->MigrateInfFileLength = 0;
        }
        //
        //  Attempt also to read unsupdrv.inf. Borrow the BadFileName buffer
        //  for temporary use.
        //
        strcpy(BadFileName,BootPath);
        strcat(BadFileName,WINNT_UNSUPDRV_INF_FILE_A);
        if( SlInitIniFile(NULL,
                          BootDeviceId,
                          BadFileName,
                          &UnsupDriversInfHandle,
                          &BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFile,
                          &BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFileLength,
                          &DontCare) != ESUCCESS ) {
            UnsupDriversInfHandle = NULL;
            BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFile = NULL;
            BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFileLength = 0;
        }
        SlGetMigratedHardwareIds(SetupBlock, UnsupDriversInfHandle);

    } else {
        WinntSifHandle = NULL;
        //
        //  If winnt.sif doesn't exist, then we don't bother to read migrate.inf and unsupdrv.inf,
        //  since we are booting from the retail boot floppies or the CD, and in this
        //  case there is no migrate.inf or unsupdrv.inf.
        //
        MigrateInfHandle = NULL;
        BlLoaderBlock->SetupLoaderBlock->MigrateInfFile = NULL;
        BlLoaderBlock->SetupLoaderBlock->MigrateInfFileLength = 0;

        UnsupDriversInfHandle = NULL;
        BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFile = NULL;
        BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFileLength = 0;
    }

    //
    // Store the boot path in the loader block.
    //

    if (UseCommandConsole) {
        SetupBlock->Flags |= SETUPBLK_FLAGS_CONSOLE;
    }

    if (g_RollbackEnabled) {
        SetupBlock->Flags |= SETUPBLK_FLAGS_ROLLBACK;
    }

    if ( !BlBootingFromNet ) {

        BlLoaderBlock->NtBootPathName = BootPath;

    } else {

        ANSI_STRING aString;
        UNICODE_STRING uString;
        ULONG length;
        ARC_STATUS ArcStatus;
        ULONG FileId;
#if defined(REMOTE_BOOT)
        PCHAR TempEnableIpsec;
#endif // defined(REMOTE_BOOT)

        SetupBlock->Flags |= SETUPBLK_FLAGS_IS_REMOTE_BOOT;

        BlLoaderBlock->NtBootPathName =
                            BlAllocateHeap( strlen(NetSetupServerShare) + strlen(BootPath) + 1 );
        if ( BlLoaderBlock->NtBootPathName == NULL ) {
            SlNoMemoryError();
            goto LoadFailed;
        }
        strcpy( BlLoaderBlock->NtBootPathName, NetSetupServerShare );
        strcat( BlLoaderBlock->NtBootPathName, BootPath );

        //
        // NetSetupServerShare is of the form \server\IMirror. NetBootPath
        // is of the form Clients\machine\ (note trailing \). We need to
        // insert a \ between the two and add BootDrive to yield
        // \server\IMirror\Clients\machine\BootDrive.
        //

        length = strlen(NetSetupServerShare) + 1 + strlen(NetBootPath) + strlen("BootDrive") + 1;
        SetupBlock->MachineDirectoryPath = BlAllocateHeap( length );
        if ( SetupBlock->MachineDirectoryPath == NULL ) {
            SlNoMemoryError();
            goto LoadFailed;
        }
        strcpy( SetupBlock->MachineDirectoryPath, NetSetupServerShare );
        SetupBlock->MachineDirectoryPath[strlen(NetSetupServerShare)] = '\\';
        SetupBlock->MachineDirectoryPath[strlen(NetSetupServerShare) + 1] = 0;
        strcat(SetupBlock->MachineDirectoryPath, NetBootPath);
        strcat(SetupBlock->MachineDirectoryPath, "BootDrive");

        //
        // Save the path to the SIF file so it can be deleted later.
        //
        if (((SetupBlock->Flags & (SETUPBLK_FLAGS_REMOTE_INSTALL|SETUPBLK_FLAGS_SYSPREP_INSTALL)) != 0) &&
            (NetbootSifFile[0] != '\0')) {
            length = strlen(NetSetupServerShare) + 1 + strlen(NetbootSifFile) + 1;
            SetupBlock->NetBootSifPath = BlAllocateHeap( length );
            if ( SetupBlock->NetBootSifPath == NULL ) {
                SlNoMemoryError();
                goto LoadFailed;
            }
            strcpy( SetupBlock->NetBootSifPath, NetSetupServerShare );
            SetupBlock->NetBootSifPath[strlen(NetSetupServerShare)] = '\\';
            SetupBlock->NetBootSifPath[strlen(NetSetupServerShare) + 1] = 0;
            strcat(SetupBlock->NetBootSifPath, NetbootSifFile);
        }

        //
        // NetSetupServerShare was read from winnt.sif and we replaced
        // the '\' at the end with a NULL -- put this back for when
        // winnt.sif is re-parsed by the kernel (the only modification
        // that the kernel parser can really accept is replacing a
        // final " with a NULL, which SlInitIniFile does).
        //

        NetSetupServerShare[strlen(NetSetupServerShare)] = '\\';

        //
        // Get the computer name from winnt.sif.
        //
        p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_USERDATA_A,WINNT_US_COMPNAME_A,0);
        if(!p || (*p == 0)) {
            SlFatalError(SL_INF_ENTRY_MISSING,WINNT_US_COMPNAME,WINNT_USERDATA);
            goto LoadFailed;
        }

        RtlInitString( &aString, p );
        uString.Buffer = SetupBlock->ComputerName;
        uString.MaximumLength = 64 * sizeof(WCHAR);
        RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );

        //
        // Save these from the global variables.
        //

        SetupBlock->IpAddress = NetLocalIpAddress;
        SetupBlock->SubnetMask = NetLocalSubnetMask;
        SetupBlock->DefaultRouter = NetGatewayIpAddress;
        SetupBlock->ServerIpAddress = NetServerIpAddress;

        //
        // Get information about the net card and do an exchange with the
        // server to get information we need to load it properly.
        //

        SetupBlock->NetbootCardInfo = BlAllocateHeap(sizeof(NET_CARD_INFO));
        if ( SetupBlock->NetbootCardInfo == NULL ) {
            SlNoMemoryError();
            goto LoadFailed;
        }
        SetupBlock->NetbootCardInfoLength = sizeof(NET_CARD_INFO);

        Status = NetQueryCardInfo(
                     (PNET_CARD_INFO)SetupBlock->NetbootCardInfo
                     );

        if (Status != STATUS_SUCCESS) {
            SlFatalError(SL_NETBOOT_CARD_ERROR);
            goto LoadFailed;
        }

        //
        // This call may allocate SetupBlock->NetbootCardRegistry
        //

        Status = NetQueryDriverInfo(
                     (PNET_CARD_INFO)SetupBlock->NetbootCardInfo,
                     NetSetupServerShare,
                     NULL,
                     SetupBlock->NetbootCardHardwareId,
                     sizeof(SetupBlock->NetbootCardHardwareId),
                     SetupBlock->NetbootCardDriverName,
                     NetbootCardDriverName,
                     sizeof(SetupBlock->NetbootCardDriverName),
                     SetupBlock->NetbootCardServiceName,
                     sizeof(SetupBlock->NetbootCardServiceName),
                     &SetupBlock->NetbootCardRegistry,
                     &SetupBlock->NetbootCardRegistryLength);

        if (Status == STATUS_INSUFFICIENT_RESOURCES) {
            SlNoMemoryError();
            goto LoadFailed;
        } else if (Status != STATUS_SUCCESS) {
            SlFatalError(SL_NETBOOT_SERVER_ERROR);
            goto LoadFailed;
        }

#if 0
        DbgPrint("HardwareID is <%ws>, DriverName is <%ws>, Service <%ws>\n",
            SetupBlock->NetbootCardHardwareId,
            SetupBlock->NetbootCardDriverName,
            SetupBlock->NetbootCardServiceName);
        DbgPrint("NetbootCardRegistry at %lx, length %d\n",
            SetupBlock->NetbootCardRegistry,
            SetupBlock->NetbootCardRegistryLength);
        DbgBreakPoint();
#endif

#if defined(REMOTE_BOOT)
        //
        // See if we should enable remote boot security (IPSEC).
        //

        TempEnableIpsec = SlGetSectionKeyIndex(WinntSifHandle,
                                               "RemoteBoot",
                                               "EnableIpSecurity",
                                               0);
        if ((TempEnableIpsec != NULL) &&
            ((TempEnableIpsec[0] == 'Y') ||
             (TempEnableIpsec[0] == 'y'))) {

            RemoteBootEnableIpsec = TRUE;
        }

        if ((SetupBlock->Flags & (SETUPBLK_FLAGS_REMOTE_INSTALL |
                                  SETUPBLK_FLAGS_SYSPREP_INSTALL)) == 0) {

            //
            // Read the secret off the disk, if there is one, and store it
            // in the loader block.
            //

            ArcStatus = BlOpenRawDisk(&FileId);

            if (ArcStatus == ESUCCESS) {

                SetupBlock->NetBootSecret = BlAllocateHeap(sizeof(RI_SECRET));
                if (SetupBlock->NetBootSecret == NULL) {
                    SlNoMemoryError();
                    BlCloseRawDisk(FileId);
                    goto LoadFailed;
                }

                ArcStatus = BlReadSecret(FileId, (PRI_SECRET)(SetupBlock->NetBootSecret));
                if (ArcStatus != ESUCCESS) {
                    SlNoMemoryError();
                    BlCloseRawDisk(FileId);
                    goto LoadFailed;
                }

                ArcStatus = BlCloseRawDisk(FileId);

                //
                // By now we have TFTPed some files so this will be TRUE if it
                // is ever going to be.
                //

                SetupBlock->NetBootUsePassword2 = NetBootTftpUsedPassword2;
            }

        } else
#endif // defined(REMOTE_BOOT)
        {

            //
            // Construct a secret to pass to the redirector, based on what
            // was passed to use across the reboot. For the moment only
            // user/domain/password matters.
            //

            WCHAR UnicodePassword[64];
            UNICODE_STRING TmpNtPassword;
            CHAR LmOwfPassword[LM_OWF_PASSWORD_SIZE];
            CHAR NtOwfPassword[NT_OWF_PASSWORD_SIZE];
            CHAR GarbageSid[RI_SECRET_SID_SIZE];
            ULONG i;

            SetupBlock->NetBootSecret = BlAllocateHeap(sizeof(RI_SECRET));
            if (SetupBlock->NetBootSecret == NULL) {
                SlNoMemoryError();
                goto LoadFailed;
            }

            //
            // Do a quick conversion of the password to Unicode.
            //

            TmpNtPassword.Length = strlen(NetbootPassword) * sizeof(WCHAR);
            TmpNtPassword.MaximumLength = sizeof(UnicodePassword);
            TmpNtPassword.Buffer = UnicodePassword;

            for (i = 0; i < sizeof(NetbootPassword); i++) {
                UnicodePassword[i] = (WCHAR)(NetbootPassword[i]);
            }

            BlOwfPassword(NetbootPassword, &TmpNtPassword, LmOwfPassword, NtOwfPassword);

            BlInitializeSecret(
                NetbootDomain,
                NetbootUser,
                LmOwfPassword,
                NtOwfPassword,
#if defined(REMOTE_BOOT)
                NULL,             // no password2
                NULL,             // no password2
#endif // defined(REMOTE_BOOT)
                GarbageSid,
                SetupBlock->NetBootSecret);

        }

    }

    //
    // Initialize the debugging system.
    //

    BlLogInitialize(BootDeviceId);

    //
    // Do PPC-specific initialization.
    //

#if defined(_PPC_)

    Status = BlPpcInitialize();
    if (Status != ESUCCESS) {
        goto LoadFailed;
    }

#endif // defined(_PPC_)

    //
    // Check for an alternate Kernel Debugger DLL, i.e.,
    // /debugport=1394 (kd1394.dll), /debugport=usb (kdusb.dll), etc...
    //

    if (BlLoaderBlock->LoadOptions != NULL) {
        FileName = strstr(BlLoaderBlock->LoadOptions, "DEBUGPORT=");
        if (FileName == NULL) {
            FileName = strstr(BlLoaderBlock->LoadOptions, "debugport=");
        }
    }

    if (FileName != NULL) {
        _strupr(FileName);
        if (strstr(FileName, "COM") == NULL) {
            UseAlternateKdDll = TRUE;
            FileName += strlen("DEBUGPORT=");
            for (i = 0; i < KD_ALT_DLL_REPLACE_CHARS; i++) {
                if (FileName[i] == ' ') {
                    break;
                }

                KdFileName[KD_ALT_DLL_PREFIX_CHARS + i] = FileName[i];
            }
            KdFileName[KD_ALT_DLL_PREFIX_CHARS + i] = '\0';
            strcat(KdFileName, ".DLL");
        }
    }

    //
    // If this is a preinstall case then add another
    // OEM source device
    //
    if (PreInstall || WinPEBoot) {
        PreInstallOemSourceDevice = BlAllocateHeap(sizeof(OEM_SOURCE_DEVICE));
        PreInstallSourcePath = BlAllocateHeap(256);

        if (PreInstallOemSourceDevice && PreInstallSourcePath) {
            strcpy(PreInstallOemSourceDevice->ArcDeviceName,
                    BootDevice);

            strcpy(PreInstallSourcePath, BootPath);
            strcat(PreInstallSourcePath, WINNT_OEM_DIR_A);
            
            PreInstallOemSourceDevice->DriverDir = PreInstallSourcePath;

            SL_OEM_SET_SOURCE_DEVICE_TYPE(PreInstallOemSourceDevice,
                (SL_OEM_SOURCE_DEVICE_TYPE_LOCAL |
                 SL_OEM_SOURCE_DEVICE_TYPE_FIXED |
                 SL_OEM_SOURCE_DEVICE_TYPE_PREINSTALL));

            //
            // Mark the device as containing preinstall drivers only if they
            // specified any F6 mass storage drivers
            //
            if (!WinPEBoot && PreinstallDriverList) {
                SL_OEM_SET_SOURCE_MEDIA_TYPE(PreInstallOemSourceDevice,
                    (SL_OEM_SOURCE_MEDIA_PRESENT |
                     SL_OEM_SOURCE_MEDIA_HAS_DRIVERS |
                     SL_OEM_SOURCE_MEDIA_HAS_MSD |
                     SL_OEM_SOURCE_MEDIA_HAS_DEFAULT));
            }                

            SL_OEM_SET_SOURCE_DEVICE_STATE(PreInstallOemSourceDevice,
                SL_OEM_SOURCE_DEVICE_NOT_PROCESSED);

            PreInstallOemSourceDevice->DeviceId = BootDeviceId;

            //
            // Insert it at the head of the linked list
            //
            PreInstallOemSourceDevice->Next = OemSourceDevices;
            OemSourceDevices = PreInstallOemSourceDevice;                
        } else {
            SlNoMemoryError();
            goto LoadFailed;
        }            
    }                


    if (!BlBootingFromNet) {
        //
        // Figure out if there are any OEM hal/drivers which need to 
        // be autoloaded.
        // NOTE: We skip the dynamic update OEM source device since it's
        // drivers will be autoloaded later.
        //
        POEM_SOURCE_DEVICE  CurrDevice = OemSourceDevices;

        while (CurrDevice && !(AutoLoadOemHalDevice && AutoLoadOemScsi)) {
            if ((SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                        SL_OEM_SOURCE_MEDIA_HAS_DRIVERS) &&
                  SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                        SL_OEM_SOURCE_MEDIA_HAS_DEFAULT)) &&
                !SL_OEM_SOURCE_DEVICE_TYPE(CurrDevice,
                        SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE)) {

                if (!AutoLoadOemHalDevice && 
                    SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice, SL_OEM_SOURCE_MEDIA_HAS_HAL)) {
                    AutoLoadOemHalDevice = CurrDevice;
                }

                if (!AutoLoadOemScsi && 
                    SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice, SL_OEM_SOURCE_MEDIA_HAS_MSD)) {
                    AutoLoadOemScsi = TRUE;
                }
            }
            
            CurrDevice = CurrDevice->Next;
        }

        //
        // Set allocatable range to the kernel-specific range
        //
        BlUsableBase  = BL_KERNEL_RANGE_LOW;
        BlUsableLimit = BL_KERNEL_RANGE_HIGH;

        //
        // Load the kernel.
        //
        SlGetDisk(KERNEL_MP_IMAGE_FILENAME);

        strcpy(KernelDirectoryPath, BootPath);
        strcat(KernelDirectoryPath,KERNEL_MP_IMAGE_FILENAME);
        strcpy(KernelImage,KERNEL_MP_IMAGE_FILENAME);
#ifdef i386
retrykernel:
#endif
        BlOutputLoadMessage(BootDevice, KernelDirectoryPath, BlFindMessage(SL_KERNEL_NAME));
        Status = BlLoadImage(BootDeviceId,
                             LoaderSystemCode,
                             KernelDirectoryPath,
                             TARGET_IMAGE,
                             &SystemBase);
#ifdef i386
        //
        // If the kernel didn't fit in the preferred range, reset the range to
        // all of memory and try again.
        //
        if ((Status == ENOMEM) &&
            ((BlUsableBase != 0) ||
             (BlUsableLimit != _16MB))) {
            BlUsableBase = 0;
            BlUsableLimit = _16MB;

            goto retrykernel;
        }
#endif
        if (Status != ESUCCESS) {
            SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(KernelDirectoryPath),Status);
            goto LoadFailed;
        }

        BlUpdateBootStatus();

        //
        // Load the HAL.
        //

        strcpy(HalDirectoryPath, BootPath);

        if (PromptOemHal || (PreInstall && (ComputerType != NULL))) {
            if(PreInstall && OemHal) {
                //
                //  This is a pre-install and an OEM hal was specified
                //
                strcat( HalDirectoryPath,
#if defined(_X86_) || defined(_IA64_)
                        WINNT_OEM_DIR_A
#else
                        WINNT_OEM_TEXTMODE_DIR_A
#endif
                      );
                strcat( HalDirectoryPath, "\\" );
            }
            
            SlPromptOemHal((PreInstall ? PreInstallOemSourceDevice : DefaultOemSourceDevice),
                (!PreInstall || (ComputerType == NULL)),
                &HalBase, 
                &HalName);
                
            strcat(HalDirectoryPath,HalName);

            //
            // Reset the last disk tag for floopy boot             
            //
            if (FloppyBoot) {
                LastDiskTag = NULL;
            }
        } else {
            //
            //  Note that on x86, the HAL may be on floppy #1 or floppy #2
            //
            strcat(HalDirectoryPath,HalName);
            SlGetDisk(HalName);
            BlOutputLoadMessage(BootDevice, HalDirectoryPath, BlFindMessage(SL_HAL_NAME));

#ifdef i386
        retryhal:
#endif
            Status = BlLoadImage(BootDeviceId,
                                 LoaderHalCode,
                                 HalDirectoryPath,
                                 TARGET_IMAGE,
                                 &HalBase);
#ifdef i386
            //
            // If the HAL didn't fit in the preferred range, reset the range to
            // all of memory and try again.
            //
            if ((Status == ENOMEM) &&
                ((BlUsableBase != 0) ||
                 (BlUsableLimit != _16MB))) {
                BlUsableBase = 0;
                BlUsableLimit = _16MB;

                goto retryhal;
            }
#endif
            if (Status != ESUCCESS) {
                SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(HalDirectoryPath),Status);
                goto LoadFailed;
            }

            BlUpdateBootStatus();
        }

        //
        // Set allocatable range to the driver-specific range
        //
        BlUsableBase  = BL_DRIVER_RANGE_LOW;
        BlUsableLimit = BL_DRIVER_RANGE_HIGH;

    } else {

        PCHAR id;
        ULONG idLength;

        //
        // This is a remote boot setup. Load the HAL first, so that we
        // can determine whether to load the UP or MP kernel.
        //
        // Note that we cannot load the HAL first on local boots
        // because that would break floppy boot, where the kernel
        // is on floppy #1 and the HALs are on floppy #2.
        //


        //
        // Set allocatable range to the kernel-specific range
        //
        // Don't do this for RIS right now. (matth 4/18/2001)
        //
//        BlUsableBase  = BL_KERNEL_RANGE_LOW;
//        BlUsableLimit = BL_KERNEL_RANGE_HIGH;



        strcpy(HalDirectoryPath, BootPath);

        if (PromptOemHal || (PreInstall && (ComputerType != NULL))) {
            if(PreInstall && OemHal) {
                //
                //  This is a pre-install and an OEM hal was specified
                //
                strcat( HalDirectoryPath,
#if defined(_X86_) || defined(_IA64_)
                        WINNT_OEM_DIR_A
#else
                        WINNT_OEM_TEXTMODE_DIR_A
#endif
                      );
                strcat( HalDirectoryPath, "\\" );
            }
            
            SlPromptOemHal((PreInstall ? PreInstallOemSourceDevice : DefaultOemSourceDevice), 
                (!PreInstall || (ComputerType == NULL)),
                &HalBase, 
                &HalName);
                
            strcat(HalDirectoryPath,HalName);

            //
            // Reset the last disk tag for floopy boot             
            //
            if (FloppyBoot) {
                LastDiskTag = NULL;
            }
        } else {
            strcat(HalDirectoryPath,HalName);
            BlOutputLoadMessage(BootDevice, HalDirectoryPath, BlFindMessage(SL_HAL_NAME));
            Status = BlLoadImage(BootDeviceId,
                                 LoaderHalCode,
                                 HalDirectoryPath,
                                 TARGET_IMAGE,
                                 &HalBase);
            if (Status != ESUCCESS) {
                SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(HalDirectoryPath),Status);
                goto LoadFailed;
            }

            BlUpdateBootStatus();
        }

        //
        // Load the kernel, loading ntoskrnl.exe or ntkrnlmp.exe based on
        // whether the HAL is UP or MP. This is important for remote boot
        // because the networking code's spin lock usage pattern requires
        // the kernel and HAL to be matched.
        //
        // If the computer ID string ends in "_mp", load the MP kernel.
        // Otherwise, load the UP kernel. The code is modeled after similar
        // code in setup\textmode\kernel\sphw.c\SpInstallingMp().
        //

        id = SetupBlock->ComputerDevice.IdString;
        idLength = strlen(id);

        //
        // load ntkrnlmp always in MiniNT network boot
        //
#if defined(EFI)
        strcpy( KernelImage, KERNEL_MP_IMAGE_FILENAME );
#else
        if (WinPEBoot || ((idLength >= 3) && (_stricmp(id+idLength-3,"_mp") == 0))) {
            strcpy(KernelImage,KERNEL_MP_IMAGE_FILENAME);
        } else {
            strcpy(KernelImage,KERNEL_UP_IMAGE_FILENAME);
        }
#endif


#if defined(REMOTE_BOOT)
#if DBG
        if ((strlen(id) + 1) > sizeof(SetupBlock->NetBootHalName)) {
            DbgPrint("The HAL name is too long!\n");
            goto LoadFailed;
        }
#endif

        strcpy(SetupBlock->NetBootHalName, id);
#endif // defined(REMOTE_BOOT)

        SlGetDisk(KernelImage);

        strcpy(KernelDirectoryPath, BootPath);
        strcat(KernelDirectoryPath,KernelImage);
        BlOutputLoadMessage(BootDevice, KernelDirectoryPath, BlFindMessage(SL_KERNEL_NAME));
        Status = BlLoadImage(BootDeviceId,
                             LoaderSystemCode,
                             KernelDirectoryPath,
                             TARGET_IMAGE,
                             &SystemBase);
        if (Status != ESUCCESS) {
            SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(KernelDirectoryPath),Status);
            goto LoadFailed;
        }

        BlUpdateBootStatus();
    
    
        //
        // Set allocatable range to the driver-specific range
        //
        BlUsableBase  = BL_DRIVER_RANGE_LOW;
        BlUsableLimit = BL_DRIVER_RANGE_HIGH;    
    
    }

    //
    // Load Kernel Debugger DLL
    //
    
    strcpy(KdDllName, BootPath);
    strcat(KdDllName, KdFileName);
    SlGetDisk(KdFileName);
    BlOutputLoadMessage(BootDevice, KdDllName, BlFindMessage(SL_KDDLL_NAME));
    Status = BlLoadImage(BootDeviceId,
                         LoaderHalCode,
                         KdDllName,
                         TARGET_IMAGE,
                         &KdDllBase);

    if ((Status != ESUCCESS) && (UseAlternateKdDll == TRUE)) {
        UseAlternateKdDll = FALSE;

        strcpy(KdDllName, BootPath);
        strcpy(KdFileName, "KDCOM.DLL");
        strcat(KdDllName, KdFileName);

        Status = BlLoadImage(BootDeviceId,
                             LoaderHalCode,
                             KdDllName,
                             TARGET_IMAGE,
                             &KdDllBase);
    }

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(KdDllName), Status);
        goto LoadFailed;
    }

    //
    // Generate a loader data entry for the system image.
    //

    Status = BlAllocateDataTableEntry("ntoskrnl.exe",
                                      KernelDirectoryPath,
                                      SystemBase,
                                      &SystemDataTableEntry);

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(KernelDirectoryPath),Status);
        goto LoadFailed;
    }

    //
    // Generate a loader data entry for the HAL DLL.
    //

    Status = BlAllocateDataTableEntry("hal.dll",
                                      HalDirectoryPath,
                                      HalBase,
                                      &HalDataTableEntry);

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(HalDirectoryPath),Status);
        goto LoadFailed;
    }

    //
    // Generate a loader data entry for the Kernel Debugger DLL.
    //

    Status = BlAllocateDataTableEntry("kdcom.dll",
                                      KdDllName,
                                      KdDllBase,
                                      &KdDataTableEntry);

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(KdDllName), Status);
        goto LoadFailed;
    }

#if defined(_ALPHA_)
    {
        CHAR PalFileName[32];
        CHAR FloppyName[80];
        PTCHAR DiskDescription;
        ULONG FloppyId;
        PDETECTED_DEVICE OemPal;
        PDETECTED_DEVICE_FILE OemPalFile;

        //
        // Get the name of the pal file we are suppose to load.
        //

        Status = BlGeneratePalName(PalFileName);

        //
        // If we get an error from BlGenereatePalName, something is
        // really wrong with the firmware or the ARC tree.  Abort and
        // bail out.
        //

        if (Status != ESUCCESS) {
            SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(PalFileName),Status);
            goto LoadFailed;
        }

        //
        // Try loading the pal file from the boot device.
        //

        //
        // NOTE John Vert (jvert) 4-Feb-1994
        //  Below call assumes all the PALs are on
        //  the same floppy.  We really should check the SIF
        //  file and go immediately to the diskette prompt
        //  if it's not in the SIF file, otherwise get
        //  the appropriate disk.
        //
        SetupBlock->OemPal = NULL;
#if defined(_AXP64_)
        SlGetDisk("a121165.p64");
#else
        SlGetDisk("A321064.PAL");
#endif


        Status = BlLoadPal(BootDeviceId,
                           LoaderSystemCode,
                           BootPath,
                           TARGET_IMAGE,
                           &BlLoaderBlock->u.Alpha.PalBaseAddress,
                           BlFindMessage(SL_PAL_NAME));

        //
        // If we have failed, prompt the user for a floppy that contains
        // the pal code and load it from floppy. We keep looping until
        // either we get the right disk, or we get an error other than
        // 'file not found'.
        //

        if(Status == ENOENT) {
            DiskDescription = BlFindMessage(SL_OEM_DISK_PROMPT);
        }

        while (Status == ENOENT) {

            SlClearClientArea();

            //
            // Compute the name of the A: drive.
            //

            if (!SlpFindFloppy(0,FloppyName)) {

                //
                // No floppy drive available, bail out.
                //

                SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(PalFileName),Status);
                goto LoadFailed;
            }

            //
            // Prompt for the disk.
            //
            SlPromptForDisk(DiskDescription, FALSE);

            //
            // Open the floppy.
            //

            Status = ArcOpen(FloppyName, ArcOpenReadOnly, &FloppyId);
            if (Status != ESUCCESS) {

                //
                // We want to give the user another chance if they didn't
                // have a floppy inserted.
                //
                if(Status != ENOENT) {
                    Status = (Status == EIO) ? ENOENT : Status;
                }
                continue;
            }

            //
            // Load the pal file from the root of the floppy.
            //

            Status = BlLoadPal(FloppyId,
                               LoaderSystemCode,
                               "\\",
                               TARGET_IMAGE,
                               &BlLoaderBlock->u.Alpha.PalBaseAddress,
                               BlFindMessage(SL_PAL_NAME));

            ArcClose(FloppyId);

            //
            // if we found the PAL, then record DETECTED_DEVICE info
            //
            if(Status == ESUCCESS) {
                OemPal = BlAllocateHeap(sizeof(DETECTED_DEVICE));
                if(!OemPal) {
                    SlNoMemoryError();
                }
                SetupBlock->OemPal = OemPal;

                OemPal->Next = NULL;
                OemPal->IdString = NULL;
                OemPal->Description = NULL;
                OemPal->ThirdPartyOptionSelected = TRUE;
                OemPal->FileTypeBits = 0;
                OemPal->MigratedDriver = FALSE;

                OemPalFile = BlAllocateHeap(sizeof(DETECTED_DEVICE_FILE));
                if(!OemPalFile) {
                    SlNoMemoryError();
                }
                OemPal->Files = OemPalFile;

                OemPalFile->Next = NULL;
                OemPalFile->Filename = SlCopyStringA(PalFileName);
                OemPalFile->FileType = HwFileMax;
                OemPalFile->ConfigName = NULL;
                OemPalFile->RegistryValueList = NULL;
                OemPalFile->DiskDescription = SlCopyString(DiskDescription);
                OemPalFile->DiskTagfile = NULL;
                OemPalFile->Directory = SlCopyStringA("");
            }
        }

        if(Status != ESUCCESS) {
            SlFriendlyError(
                Status,
                PalFileName,
                __LINE__,
                __FILE__
                );
            goto LoadFailed;
        }

    }

#endif  // ifdef _ALPHA_

    PathSet.PathCount = 1;
    PathSet.AliasName = "\\SystemRoot";
    PathSet.PathOffset[0] = '\0';
    PathSet.Source[0].DeviceId = BootDeviceId;
    PathSet.Source[0].DeviceName = BootDevice;
    PathSet.Source[0].DirectoryPath = BootPath;

    Status = BlScanImportDescriptorTable(&PathSet,
                                         SystemDataTableEntry,
                                         LoaderSystemCode
                                         );

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(KernelImage),Status);
    }

    //
    // Scan the import table for the HAL DLL and load all referenced DLLs.
    //

    Status = BlScanImportDescriptorTable(&PathSet,
                                         HalDataTableEntry,
                                         LoaderHalCode);

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT("hal.dll"),Status);
        goto LoadFailed;
    }

    //
    // Scan the import table for the Kernel Debugger DLL and load all
    // referenced DLLs.
    //

    Status = BlScanImportDescriptorTable(&PathSet,
                                         KdDataTableEntry,
                                         LoaderSystemCode);


    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(KdFileName), Status);
        goto LoadFailed;
    }

    //
    // Relocate the system entry point and set system specific information.
    //

    NtHeaders = RtlImageNtHeader(SystemBase);
    SystemEntry = (PTRANSFER_ROUTINE)((ULONG_PTR)SystemBase +
                                NtHeaders->OptionalHeader.AddressOfEntryPoint);

#if defined(_MIPS_)

    BlLoaderBlock->u.Mips.GpBase = (ULONG)SystemBase +
        NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress;

#endif

#if defined(_ALPHA_) || defined(_AXP64_)

    BlLoaderBlock->u.Alpha.GpBase = (ULONG_PTR)SystemBase +
        NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress;

#endif

#if defined(_IA64_)

    BlLoaderBlock->u.Ia64.KernelVirtualBase = (ULONG_PTR)SystemBase;
    BlLoaderBlock->u.Ia64.KernelPhysicalBase = (ULONG_PTR)SystemBase & 0x7fffffff;

#endif

    ///////////////////////////////////////////////////////////////////
    //
    //  On x86, the files loaded from now on are on boot floppy #2
    //
    ///////////////////////////////////////////////////////////////////

    //
    // Load registry's SYSTEM hive
    //
    SlGetDisk("SETUPREG.HIV");
    Status = BlLoadSystemHive(BootDeviceId,
                              NULL, // BlFindMessage(SL_HIVE_NAME), UNREFERENCED_PARAMETER
                              BootPath,
                              "SETUPREG.HIV");
    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT("SETUPREG.HIV"),Status);
        goto LoadFailed;
    }

    //
    // Pull the Docking information from the hardware tree.
    //

    dockInfoData = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                            PeripheralClass,
                                            DockingInformation,
                                            NULL);

    if (NULL == dockInfoData) {
        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNKNOWN;
        BlLoaderBlock->Extension->Profile.Capabilities = 0;
        BlLoaderBlock->Extension->Profile.DockID = 0;
        BlLoaderBlock->Extension->Profile.SerialNumber = 0;

    } else if (sizeof (dockInfo) <=
               dockInfoData->ComponentEntry.ConfigurationDataLength) {

        RtlCopyMemory (
            &dockInfo,
            (PUCHAR) (dockInfoData->ConfigurationData) + sizeof(CM_PARTIAL_RESOURCE_LIST),
            sizeof (dockInfo));

        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_FAILURE;

        switch (dockInfo.ReturnCode) {
        case FW_DOCKINFO_SUCCESS:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_DOCKED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_SYSTEM_NOT_DOCKED:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNDOCKED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_DOCK_STATE_UNKNOWN:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNKNOWN;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_FUNCTION_NOT_SUPPORTED:
        case FW_DOCKINFO_BIOS_NOT_CALLED:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        default:
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNSUPPORTED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;
        }

    } else {
        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        BlLoaderBlock->Extension->Profile.Capabilities = 0;
        BlLoaderBlock->Extension->Profile.DockID = 0;
        BlLoaderBlock->Extension->Profile.SerialNumber = 0;
    }

    if (BlLoaderBlock->Extension->Profile.Status == HW_PROFILE_STATUS_SUCCESS) {
        //
        // We don't match profiles in textmode setup so just pretend that we did.
        //
        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_TRUE_MATCH;
    }

    //
    // Allocate structure for NLS data.
    //

    BlLoaderBlock->NlsData = BlAllocateHeap(sizeof(NLS_DATA_BLOCK));
    if (BlLoaderBlock->NlsData == NULL) {
        Status = ENOMEM;
        SlNoMemoryError();
        goto LoadFailed;
    }

    //
    // Load the OEM font
    //
    SlGetDisk(OemHalFontName);
    Status = BlLoadOemHalFont(BootDeviceId,
                              NULL, // BlFindMessage(SL_OEM_FONT_NAME), UNREFERENCED_PARAMETER
                              BootPath,
                              &OemHalFont,
                              BadFileName);

    if(Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(BadFileName), Status);
        goto LoadFailed;
    }

    //
    // Load the NLS data.
    //
    // For now, we ensure that the disk containing the ansi
    // codepage file is in the drive and hope that the rest of the
    // nls files (oem codepage, unicode table) are on the same disk.
    //
    SlGetDisk(AnsiCpName);
    Status = BlLoadNLSData(BootDeviceId,
                           NULL, // BlFindMessage(SL_NLS_NAME), UNREFERENCED_PARAMETER
                           BootPath,
                           &AnsiCodepage,
                           &OemCodepage,
                           &UnicodeCaseTable,
                           BadFileName);

    if(Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(BadFileName), Status);
        goto LoadFailed;
    }

    //
    // Load the system drivers we will need here
    //

    InitializeListHead(&BlLoaderBlock->BootDriverListHead);

    //
    // Load setupdd.sys next. Setupdd.sys needs to be loaded before any other
    // driver, because it will need to prep the rest of the system.
    //
    Status = SlLoadDriver(BlFindMessage(SL_SETUP_NAME),
                          "setupdd.sys",
                          0,
                          TRUE,
                          FALSE
                          );
    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT("setupdd.sys"),Status);
        goto LoadFailed;
    }

    //
    // Fill in its registry key -- setupdd fills these in for all the other
    // drivers (unless we do it here), but we have to do it here for setupdd
    // itself.
    //
    DriverEntry = (PBOOT_DRIVER_LIST_ENTRY)(BlLoaderBlock->BootDriverListHead.Flink);
    DriverEntry->RegistryPath.Buffer = BlAllocateHeap(256);
    if (DriverEntry->RegistryPath.Buffer == NULL) {
        SlNoMemoryError();
        goto LoadFailed;
    }
    DriverEntry->RegistryPath.Length = 0;
    DriverEntry->RegistryPath.MaximumLength = 256;
    RtlAppendUnicodeToString(&DriverEntry->RegistryPath,
                             L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\setupdd");

#if 0
#ifdef i386
    //
    // Note that if pciide.sys, intelide.sys and pciidex.sys are on the same
    // boot floppy (x86 only), then we don't need to load pciidex.sys.
    // The driver will be automatically loaded when pciide.sys or intelide.sys
    // (both listed on [BusExtenders.Load] is loaded.
    //
    Status = SlLoadDriver(BlFindMessage(SL_PCI_IDE_EXTENSIONS_NAME),
                          "PCIIDEX.SYS",
                          0,
                          FALSE,
                          FALSE
                          );
#endif
#endif
    //
    //  Load boot bus extenders.
    //  It has to be done before scsiport.sys
    //
    Status = SlLoadPnpDriversSection( InfFile,
                                      "BootBusExtenders",
                                      &(SetupBlock->BootBusExtenders) );
    if (Status!=ESUCCESS) {
        goto LoadFailed;
    }

    //
    //  Load bus extenders.
    //  It has to be done before scsiport.sys
    //
    Status = SlLoadPnpDriversSection( InfFile,
                                      "BusExtenders",
                                      &(SetupBlock->BusExtenders) );
    if (Status!=ESUCCESS) {
        goto LoadFailed;
    }

    //
    //  Load input device related drivers.
    //
    Status = SlLoadPnpDriversSection( InfFile,
                                      "InputDevicesSupport",
                                      &(SetupBlock->InputDevicesSupport) );
    if (Status!=ESUCCESS) {
        goto LoadFailed;
    }

    //
    //  Detect video
    //
    SlDetectVideo(SetupBlock);
    
    //
    // On x86, the video type is always set to VGA in i386\x86dtect.c.
    // On non-x86, the video type is either recognized, in which case
    // we don't unconditionally need vga.sys (the Display.Load section
    // tells us what to load), or it's not recognized,
    // in which case we will prompt the user for an oem disk.
    // If there is no display controller node at all, then PromptOemDisk
    // will be false and there will be no video device. In this case
    // we load vga.sys.
    //

    if (SetupBlock->VideoDevice.IdString != NULL) {
        VideoFileName = SlGetSectionKeyIndex(InfFile,
                                             "Display.Load",
                                             SetupBlock->VideoDevice.IdString,
                                             SIF_FILENAME_INDEX);
        if (VideoFileName != NULL) {
#ifdef ARCI386
            VideoDescription = SlGetIniValue(InfFile,
                                             "Display",
                                             SetupBlock->VideoDevice.IdString,
                                             BlFindMessage(SL_VIDEO_NAME));
#else
            //
            // With the new video detection mechanism, the description
            // for the video driver is likely to be something like
            // "Windows NT Compatible" which looks funny when displayed
            // in the status bar.
            //
            VideoDescription = BlFindMessage(SL_VIDEO_NAME);
#endif
            if (!WinPEBoot) {
                Status = SlLoadDriver(VideoDescription,
                                      VideoFileName,
                                      0,
                                      TRUE,
                                      FALSE
                                      );
            }

            if (Status == ESUCCESS) {
                SetupBlock->VideoDevice.BaseDllName = SlCopyStringA(VideoFileName);
            } else {
                SlFriendlyError(
                    Status,
                    VideoFileName,
                    __LINE__,
                    __FILE__
                    );
                goto LoadFailed;
            }

            LoadedAVideoDriver = TRUE;
        }
    } else if (PromptOemVideo) {

        SlPromptOemVideo(DefaultOemSourceDevice, 
            TRUE,
            &VideoBase, 
            &OemVideoName);

        Status = SlLoadOemDriver(
                    "VIDEOPRT.SYS",
                    OemVideoName,
                    VideoBase,
                    BlFindMessage(SL_VIDEO_NAME)
                    );

        if(Status==ESUCCESS) {

            LoadedAVideoDriver = TRUE;
            SetupBlock->VideoDevice.BaseDllName = SlCopyStringA(OemVideoName);
        }

        //
        // Reset the last disk tag for floopy boot             
        //
        if (FloppyBoot) {
            LastDiskTag = NULL;
        }        
    }

    if(!LoadedAVideoDriver) {
        Status = SlLoadDriver(BlFindMessage(SL_VIDEO_NAME),
                              VGA_DRIVER_FILENAME,
                              0,
                              TRUE,
                              FALSE
                              );
        if(Status == ESUCCESS) {
            SetupBlock->VideoDevice.BaseDllName = SlCopyStringA(VGA_DRIVER_FILENAME);
        } else {
            SlFriendlyError(
                Status,
                VGA_DRIVER_FILENAME,
                __LINE__,
                __FILE__
                );
            goto LoadFailed;
        }
    }

    if(SetupBlock->VideoDevice.IdString == NULL) {
        SetupBlock->VideoDevice.IdString = SlCopyStringA(VIDEO_DEVICE_NAME);
    }

    //
    //  Load keyboard drivers.
    //
    Status = SlLoadPnpDriversSection( InfFile,
                                      "Keyboard",
                                      &(SetupBlock->KeyboardDevices) );
    if (Status!=ESUCCESS) {
        goto LoadFailed;
    }


    Status = SlLoadDriver(BlFindMessage(SL_KBD_NAME),
                          "kbdclass.sys",
                          0,
                          TRUE,
                          FALSE
                          );
    if(Status != ESUCCESS) {
        SlFriendlyError(
             Status,
             "kbdclass.sys",
             __LINE__,
             __FILE__
             );
        goto LoadFailed;
    }

    //
    // We would need mouse support also in minint environment
    //
    if (WinPEBoot) {
        Status = SlLoadSection(InfFile,
                              "MouseDrivers",
                              FALSE,
                              TRUE,
                              NULL);

        if(Status != ESUCCESS) {
            SlFriendlyError(
                 Status,
                 "MouseDrivers",
                 __LINE__,
                 __FILE__
                 );
                 
            goto LoadFailed;
        }
    }


    ///////////////////////////////////////////////////////////////////
    //
    //  On x86, the files loaded from now on are on boot floppy #3
    //
    ///////////////////////////////////////////////////////////////////

    //
    // Load scsiport.sys next, so it'll always be around for any scsi miniports we may load
    //

    Status = SlLoadDriver(BlFindMessage(SL_SCSIPORT_NAME),
                          "SCSIPORT.SYS",
                          0,
                          FALSE,
                          FALSE
                          );


    //
    // Detect scsi
    //
    // (If the user wants to select their own SCSI devices, we won't
    // do any detection)
    //
    if(!PromptOemScsi  && (PreinstallDriverList == NULL) ) {
        SlDetectScsi(SetupBlock);
#if defined(_X86_) || defined(_IA64_)
        if( Win9xUnsupHdc ) {
            //
            // If this is a Win9x upgrade and winnt32 detected an unsupported
            // SCSI controller, then the user needs to be prompted for an OEM SCSI driver
            //
            PromptOemScsi = TRUE;
        }
#endif
    }

#if defined(ELTORITO) && !defined(ARCI386)
    //
    // If this is an El Torito CD-ROM install, then we want to load all SCSI miniports
    // and disk class drivers.
    // BUT we do not want to load all the disk class drivers for an ARC
    // machine which knows what drivers it wants to install from its tree
    //
    if(ElToritoCDBoot) {
        LoadScsiMiniports = TRUE;
    }
#endif

    //
    // If the LoadScsi flag is set, enumerate all the known SCSI miniports and load each
    // one.
    //
    if(LoadScsiMiniports) {
        if (WinPEBoot && OemInfHandle) {
            Status = SlLoadWinPESection(PreInstallOemSourceDevice,
                        OemInfHandle,
                        WINNT_OEMSCSIDRIVERS_A,
                        InfFile,
                        "Scsi",
                        TRUE,
                        &OemScsiInfo,
                        &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase);
        } else {
            Status = SlLoadSection(InfFile,"Scsi",TRUE, TRUE, NULL);
        }
        
        if (Status!=ESUCCESS) {
            goto LoadFailed;
        }
        
        SetupBlock->ScalarValues.LoadedScsi = 1;
    }

    //
    // Pick the the dynamic update boot drivers, if any
    //
    if (DynamicUpdate) {
        SlLoadOemScsiDriversUnattended(DynamicUpdateSourceDevice,
            WinntSifHandle,
            WINNT_SETUPPARAMS_A,
            WINNT_SP_DYNUPDTBOOTDRIVERROOT_A,           
            WINNT_SP_DYNUPDTBOOTDRIVERS_A,
            &OemScsiInfo,
            &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase);
    }

    //
    // Allow the user to pick an OEM SCSI driver here
    //
    if (PromptOemScsi || (PreinstallDriverList != NULL)) {
        POEMSCSIINFO    DynUpdtScsiInfo = OemScsiInfo;

        SlPromptOemScsi(((PreinstallDriverList == NULL) ? 
                                DefaultOemSourceDevice : PreInstallOemSourceDevice),
            (!PreInstall || (PreinstallDriverList == NULL)),
            &OemScsiInfo);

        //
        // Mark the default OEM source device as processed, 
        // if the user manually pressed F6
        //
        if (PromptOemScsi && DefaultOemSourceDevice) {
            SL_OEM_SET_SOURCE_DEVICE_STATE(DefaultOemSourceDevice,
                SL_OEM_SOURCE_DEVICE_PROCESSED);
        }

        //
        // Reset the last disk tag for floopy boot             
        //
        if (FloppyBoot) {
            LastDiskTag = NULL;
        }

        //
        // Merge the dynamic update SCSI driver list with oem SCSI
        // driver list
        //
        if (DynUpdtScsiInfo) {
            if (OemScsiInfo) {
                POEMSCSIINFO    CurrNode = DynUpdtScsiInfo;

                while (CurrNode && CurrNode->Next) {
                    CurrNode = CurrNode->Next;
                }

                if (CurrNode) {
                    CurrNode->Next = OemScsiInfo;
                    OemScsiInfo = DynUpdtScsiInfo;
                }
            } else {
                OemScsiInfo = DynUpdtScsiInfo;
            }
        }

        // Cleanup here needed for all installation - ARCI386
        if (UseRegularBackground) {
          SlClearDisplay();

          if (WinPEBoot) {
            StartupMsg ? BlOutputStartupMsgStr(StartupMsg) :
                         BlOutputStartupMsg(SL_SETUP_STARTING_WINPE);
          } else {
            if (UseCommandConsole) {
                BlOutputStartupMsg(SL_CMDCONS_STARTING);
            } else if (g_RollbackEnabled) {
                BlOutputStartupMsg(SL_ROLLBACK_STARTING);
            } else {
                BlOutputStartupMsg(SL_SETUP_STARTING);
            }
          }

          BlRedrawProgressBar();
        } else {
          SlClearClientArea();
          SlWriteStatusText(TEXT(""));
        }
    } 

    //
    // If we found any valid txtsetup.oem with valid default MSD
    // in any OEM source device which is not yet processed, then
    // go and autoload the drivers from these devices.
    //
    if (OemSourceDevices && AutoLoadOemScsi) {
        POEMSCSIINFO DeviceOemScsiInfo = NULL;
        POEMSCSIINFO LastOemScsiNode = NULL;

        SlLoadOemScsiDriversFromOemSources(OemSourceDevices,
            &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase,
            &DeviceOemScsiInfo);            
        
        //
        // Merge the full OEM source device list with the 
        // global OEM scsi information
        //        
        if (DeviceOemScsiInfo) {
            if (OemScsiInfo) {
                LastOemScsiNode = OemScsiInfo;

                while (LastOemScsiNode->Next) {
                    LastOemScsiNode = LastOemScsiNode->Next;
                }

                LastOemScsiNode->Next = DeviceOemScsiInfo;
            } else {
                OemScsiInfo = DeviceOemScsiInfo;
            }                
        }        
    }

    //
    // Load all the disk images for the virtual devices
    // into memory
    //
    if (OemSourceDevices) {
        Status = SlInitVirtualOemSourceDevices(BlLoaderBlock->SetupLoaderBlock,
                        OemSourceDevices);           

        if (Status != ESUCCESS) {                        
            SlFatalError(SL_OEM_FILE_LOAD_FAILED);
        
            goto LoadFailed;
        }            
    }                

   
    //
    //  Add unsupported SCSI drivers, if any, to the list
    //

    if( UnsupDriversInfHandle != NULL ) {
        Status = SlDetectMigratedScsiDrivers( UnsupDriversInfHandle );
        if (Status!=ESUCCESS) {
            goto LoadFailed;
        }
    }

    //
    // Walk the list of detected SCSI miniports and load each one.
    //
    ScsiDevice = SetupBlock->ScsiDevices;
    while (ScsiDevice != NULL) {

        if(ScsiDevice->ThirdPartyOptionSelected) {

            if(!OemScsiInfo) {
                SlError(500);
                goto LoadFailed;
            }

            Status = SlLoadOemDriver(
                        NULL,
                        OemScsiInfo->ScsiName,
                        OemScsiInfo->ScsiBase,
                        BlFindMessage(SL_SCSIPORT_NAME)
                        );
            OemScsiInfo = OemScsiInfo->Next;
        } else if(ScsiDevice->MigratedDriver) {
            Status = SlLoadDriver(ScsiDevice->Description,
                                  ScsiDevice->BaseDllName,
                                  0,
                                  TRUE,
                                  TRUE
                                  );
            if( Status != ESUCCESS ) {
//                DebugOutput("Status = %d %s \n",Status,"");
            }
        } else {
            Status = SlLoadDriver(ScsiDevice->Description,
                                  ScsiDevice->BaseDllName,
                                  0,
                                  TRUE,
                                  FALSE
                                  );
        }

        if((Status == ESUCCESS)
        || ((Status == ENOENT) && IgnoreMissingFiles && !ScsiDevice->ThirdPartyOptionSelected)) {

            SetupBlock->ScalarValues.LoadedScsi = 1;

        } else {
            SlFriendlyError(
                Status,
                ScsiDevice->BaseDllName,
                __LINE__,
                __FILE__
                );
            goto LoadFailed;
        }

        ScsiDevice = ScsiDevice->Next;
    }

    //
    // If the LoadDiskClass flag is set, enumerate all the monolithic disk class drivers
    // and load each one.  Note that we also do this if we've "detected" any scsi drivers,
    // so that we preserve the drive order.
    //

    if((LoadDiskClass) || (SetupBlock->ScalarValues.LoadedScsi == 1)) {
        Status = SlLoadSection(InfFile, "DiskDrivers", FALSE, TRUE, NULL);
        if (Status == ESUCCESS) {
            SetupBlock->ScalarValues.LoadedDiskDrivers = 1;
        } else {
            goto LoadFailed;
        }
    }


#if !defined(_IA64_)
    //
    // There is currently no floppy support on IA64 systems.
    //

    //
    // Load the floppy driver (flpydisk.sys)
    //
#if !defined (ARCI386) && defined(_X86_)
    Status=ESUCCESS;

    //
    // If there are only SFLOPPY devices (such as the LS-120 ATAPI super floppy)
    // DON'T load flpydisk.sys on them. It will collide with SFLOPPY.SYS
    //
    if (!SlpIsOnlySuperFloppy()) {
#endif
        Status = SlLoadDriver(BlFindMessage(SL_FLOPPY_NAME),
                              "flpydisk.sys",
                              0,
                              TRUE,
                              FALSE
                              );
#if !defined (ARCI386) && defined(_X86_)
    }
#endif
    if (Status == ESUCCESS) {
        SetupBlock->ScalarValues.LoadedFloppyDrivers = 1;
    }
#endif
#ifdef i386
    else {
        SlFriendlyError(
             Status,
             "flpydisk.sys",
             __LINE__,
             __FILE__
             );
        goto LoadFailed;
    }
#endif

    if(SetupBlock->ScalarValues.LoadedScsi == 1) {
        //
        // Enumerate the entries in the scsi class section and load each one.
        //
        Status = SlLoadSection(InfFile, "ScsiClass",FALSE, TRUE, NULL);
        if (Status != ESUCCESS) {
            goto LoadFailed;
        }
    }


    if((LoadDiskClass) || (SetupBlock->ScalarValues.LoadedScsi == 1)) {
        Status = SlLoadSection(InfFile, "FileSystems", FALSE, TRUE, NULL);
        if (Status == ESUCCESS) {
            SetupBlock->ScalarValues.LoadedFileSystems = 1;
        } else {
            goto LoadFailed;
        }
    } else {

        //
        // Load FAT
        //
        Status = SlLoadDriver(BlFindMessage(SL_FAT_NAME),
                              "fastfat.sys",
                              0,
                              TRUE,
                              FALSE
                              );
#ifdef i386
        if(Status != ESUCCESS) {
            SlFriendlyError(
                 Status,
                 "fastfat.sys",
                 __LINE__,
                 __FILE__
                 );
            goto LoadFailed;
        }
#endif
    }

    //
    // Load CDFS if setupldr was started from a cdrom, or if ForceLoadCdfs is set.
    //
    if (LoadCdfs || (!BlGetPathMnemonicKey(SetupDevice,
                                          "cdrom",
                                          &BootDriveNumber))) {
        Status = SlLoadSection(InfFile, "CdRomDrivers",FALSE, TRUE, NULL);
        if (Status == ESUCCESS) {
            SetupBlock->ScalarValues.LoadedCdRomDrivers = 1;
        } else {
            goto LoadFailed;
        }
    }

    if (BlBootingFromNet || WinPEBoot) {

        //
        // Load the network stack.
        //

        Status = SlLoadDriver(BlFindMessage(SL_KSECDD_NAME),
                              "ksecdd.sys",
                              0,
                              TRUE,
                              FALSE
                              );
        if(Status != ESUCCESS) {
            SlFriendlyError(
                 Status,
                 "ksecdd.sys",
                 __LINE__,
                 __FILE__
                 );
            goto LoadFailed;

        }

        Status = SlLoadDriver(BlFindMessage(SL_NDIS_NAME),
                              "ndis.sys",
                              0,
                              TRUE,
                              FALSE
                              );
        if(Status != ESUCCESS) {
            SlFriendlyError(
                 Status,
                 "ndis.sys",
                 __LINE__,
                 __FILE__
                 );
            goto LoadFailed;

        }

        if (BlBootingFromNet) {

            Status = SlLoadDriver(BlFindMessage(SL_IPSEC_NAME),
                                  "ipsec.sys",
                                  0,
                                  TRUE,
                                  FALSE
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     "ipsec.sys",
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }

            Status = SlLoadDriver(BlFindMessage(SL_TCPIP_NAME),
                                  "tcpip.sys",
                                  0,
                                  TRUE,
                                  FALSE
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     "tcpip.sys",
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }

            Status = SlLoadDriver(BlFindMessage(SL_NETBT_NAME),
                                  "netbt.sys",
                                  0,
                                  TRUE,
                                  FALSE
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     "netbt.sys",
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }

            Status = SlLoadDriver(BlFindMessage(SL_NETADAPTER_NAME),
                                  NetbootCardDriverName,
                                  0,
                                  TRUE,
                                  FALSE
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     NetbootCardDriverName,
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }

            //
            // Fill in the registry key for the netboot card because its service name
            // may be different from the driver name.
            //
            DriverEntry = (PBOOT_DRIVER_LIST_ENTRY)(BlLoaderBlock->BootDriverListHead.Blink);   // SlLoadDriver inserts at the tail
            DriverEntry->RegistryPath.Buffer = BlAllocateHeap(256);
            if (DriverEntry->RegistryPath.Buffer == NULL) {
                SlNoMemoryError();
                goto LoadFailed;
            }
            DriverEntry->RegistryPath.Length = 0;
            DriverEntry->RegistryPath.MaximumLength = 256;
            RtlAppendUnicodeToString(&DriverEntry->RegistryPath,
                                     L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\");
            RtlAppendUnicodeToString(&DriverEntry->RegistryPath,
                                     SetupBlock->NetbootCardServiceName);

            Status = SlLoadDriver(BlFindMessage(SL_RDBSS_NAME),
                                  "rdbss.sys",
                                  0,
                                  TRUE,
                                  FALSE
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     "rdbss.sys",
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }
        }

        Status = SlLoadDriver(BlFindMessage(SL_MUP_NAME),
                              "mup.sys",
                              0,
                              TRUE,
                              FALSE
                              );

        if(Status != ESUCCESS) {
            SlFriendlyError(
                 Status,
                 "mup.sys",
                 __LINE__,
                 __FILE__
                 );
            goto LoadFailed;
        }

        if (BlBootingFromNet) {
            Status = SlLoadDriver(BlFindMessage(SL_MRXSMB_NAME),
                                  "mrxsmb.sys",
                                  0,
                                  TRUE,
                                  FALSE
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     "mrxsmb.sys",
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }
        }
    }

    if (!UseRegularBackground) {
        SlWriteStatusText (BlFindMessage (SL_KERNEL_TRANSITION));
    }

    //
    // Finally, make sure the appropriate disk containing NTDLL.DLL is in
    // the drive.
    //
    SlGetDisk("ntdll.dll");

    //
    // Fill in the SETUPLDR block with relevant information
    //
    SetupBlock->ArcSetupDeviceName = BlLoaderBlock->ArcBootDeviceName;

    SetupBlock->ScalarValues.SetupFromCdRom = FALSE;
    SetupBlock->ScalarValues.SetupOperation = SetupOperationSetup;

    //
    // Get the NTFT drive signatures to allow the kernel to create the
    // correct ARC name <=> NT name mappings.
    //
    //
    // X86Only : Go enumerate all the disks and record their ability to
    // support xint13.
    //
    BlGetArcDiskInformation(TRUE);
    
    //
    // ntdetect has already run.  Although it's awful to have
    // 2 disks that look just alike, stamping a signature on one
    // after ntdetect has run will also break us.  Rather err on
    // the side of caution and not write to the disks.
    //
    // This is much safer on x86 because we've ensured that the
    // boot disk has a signature before we get here.  On Alpha,
    // we can't do that.  So it's ugly, but call this guy for
    // BIOS-based x86 machines.

    //
    // don't reboot after stamping signatures
    // the first time
    //
    SlpMarkDisks(FALSE);
 
    //
    // If setup was started from a CD-ROM, generate an entry in the ARC disk
    // information list describing the cd-rom.
    //
    if (!BlGetPathMnemonicKey(SetupDevice,
                              "cdrom",
                              &BootDriveNumber)) {
        BlReadSignature(SetupDevice,TRUE);
    }

    //
    // Close the ARC device.
    //

    ArcClose(BootDeviceId);


#if 0
  {
        ULONG   EndTime = ArcGetRelativeTime();
        char    szTemp[256];
        extern ULONG BlFilesOpened;

        BlPositionCursor(1, 10);
        sprintf(szTemp, "BootTime : %d secs, FilesOpened : %d\r\n",
                  EndTime - StartTime, BlFilesOpened );

        BlPrint(szTemp);
  }
#endif

    if (UseRegularBackground) {
      BlOutputStartupMsg(SL_PLEASE_WAIT);
      BlUpdateProgressBar(100);
    }
       
    //
    // Remove system32 from the boot path if we added it
    //
    if (WinPEBoot) {
        PCHAR Sys32 = BlLoaderBlock->NtBootPathName +
                        strlen(BlLoaderBlock->NtBootPathName) -
                        strlen("system32\\");

        if (Sys32 && !_stricmp(Sys32, "system32\\")) {
            *Sys32 = 0;
        }
    }


    //
    // Close down the remote boot network file system.
    //
    // NOTE: If BlBootingFromNet, don't do anything after this point
    // that would cause access to the boot ROM.
    //

    if ( BlBootingFromNet ) {
        NetTerminate();
    }

    //
    //
    // Execute the architecture specific setup code.
    //
    // NOTE: If BlBootingFromNet, don't do anything after this point
    // that would cause access to the boot ROM.
    //

    Status = BlSetupForNt(BlLoaderBlock);
    if (Status != ESUCCESS) {
        SlFriendlyError(
            Status,
            "\"Windows NT Executive\"",
             __LINE__,
             __FILE__
            );
        goto LoadFailed;
    }

    //
    // Turn off the debugging system.
    //

    BlLogTerminate();

    //
    // Inform boot debugger that the boot phase is complete.
    //

#if defined(ENABLE_LOADER_DEBUG) || DBG

#if (defined(_X86_) || defined(_ALPHA_)) && !defined(ARCI386)

    if (BdDebuggerEnabled == TRUE) {
        DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);
    }

#endif

#endif

    //
    // Transfer control to loaded image.
    //

    (SystemEntry)(BlLoaderBlock);

    Status = EBADF;
    SlFriendlyError(
        Status,
        "\"Windows NT Executive\"",
        __LINE__,
        __FILE__
        );

LoadFailed:
    SlWriteStatusText(BlFindMessage(SL_TOTAL_SETUP_DEATH));
    SlFlushConsoleBuffer();
    SlGetChar();
    ArcRestart();
    return(Status);
}


VOID
SlpTruncateMemory(
    IN ULONG MaxMemory
    )

/*++

Routine Description:

    Eliminates all the memory descriptors above a given boundary

Arguments:

    MaxMemory - Supplies the maximum memory boundary in megabytes

Return Value:

    None.

--*/

{
    PLIST_ENTRY NextEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
    ULONG MaxPage = MaxMemory * 256;        // Convert Mb to pages

    if (MaxMemory == 0) {
        return;
    }

    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while ( NextEntry != &BlLoaderBlock->MemoryDescriptorListHead ) {
        MemoryDescriptor = CONTAINING_RECORD(NextEntry,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);
        NextEntry = NextEntry->Flink;
        if ( (MemoryDescriptor->MemoryType != LoaderFree) &&
             (MemoryDescriptor->MemoryType != LoaderFirmwareTemporary) ) {
            continue;
        }
        if (MemoryDescriptor->BasePage >= MaxPage) {
            //
            // This memory descriptor lies entirely above the boundary,
            // eliminate it.
            //
            BlRemoveDescriptor(MemoryDescriptor);
        } else if (MemoryDescriptor->BasePage + MemoryDescriptor->PageCount > MaxPage) {
            //
            // This memory descriptor crosses the boundary, truncate it.
            //
            MemoryDescriptor->PageCount = MaxPage - MemoryDescriptor->BasePage;
        }
    }
}

VOID
SlGetSetupValuesBeforePrompt(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )

/*++

Routine Description:

    Reads the setup control values out of the given .INI file.
    Also supplies reasonable defaults for values that don't exist.

Arguments:

    SetupBlock - Supplies a pointer to the Setup loader block

Return Value:

    None.  Global variables are initialized to reflect the
    contents of the INI file

--*/

{
    PCHAR NlsName;
    ANSI_STRING NlsString;
    PCHAR Options="1";
    ULONG MaxMemory;

    if (BlBootingFromNet) {
        BlLoaderBlock->LoadOptions = SlGetIniValue(WinntSifHandle,
                                                   "setupdata",
                                                   "osloadoptions",
                                                   NULL);
    } else {
        BlLoaderBlock->LoadOptions = NULL;
    }

    if (BlLoaderBlock->LoadOptions == NULL) {
        BlLoaderBlock->LoadOptions = SlGetIniValue(InfFile,
                                                   "setupdata",
                                                   "osloadoptions",
                                                   NULL);
    }

    AnsiCpName = SlGetIniValue(InfFile,
                               "nls",
                               "AnsiCodepage",
                               "c_1252.nls");

    NlsString.Buffer = AnsiCpName;
    NlsString.Length = (USHORT) strlen(AnsiCpName);
    AnsiCodepage.MaximumLength = strlen(AnsiCpName)*sizeof(WCHAR)+sizeof(UNICODE_NULL);
    AnsiCodepage.Buffer = BlAllocateHeap(AnsiCodepage.MaximumLength);
    if (AnsiCodepage.Buffer == NULL) {
        SlNoMemoryError();
    }
    RtlAnsiStringToUnicodeString(&AnsiCodepage, &NlsString, FALSE);

    NlsName = SlGetIniValue(InfFile,
                            "nls",
                            "OemCodepage",
                            "c_437.nls");

    NlsString.Buffer = NlsName;
    NlsString.Length = (USHORT) strlen(NlsName);
    OemCodepage.MaximumLength = strlen(NlsName)*sizeof(WCHAR)+sizeof(UNICODE_NULL);
    OemCodepage.Buffer = BlAllocateHeap(OemCodepage.MaximumLength);
    if (OemCodepage.Buffer == NULL) {
        SlNoMemoryError();
    }
    RtlAnsiStringToUnicodeString(&OemCodepage, &NlsString, FALSE);

    NlsName = SlGetIniValue(InfFile,
                            "nls",
                            "UnicodeCasetable",
                            "l_intl.nls");

    NlsString.Buffer = NlsName;
    NlsString.Length = (USHORT) strlen(NlsName);
    UnicodeCaseTable.MaximumLength = strlen(NlsName)*sizeof(WCHAR)+sizeof(UNICODE_NULL);
    UnicodeCaseTable.Buffer = BlAllocateHeap(UnicodeCaseTable.MaximumLength);
    if (UnicodeCaseTable.Buffer == NULL) {
        SlNoMemoryError();
    }
    RtlAnsiStringToUnicodeString(&UnicodeCaseTable, &NlsString, FALSE);

    OemHalFontName = SlGetIniValue(InfFile,
                                   "nls",
                                   "OemHalFont",
                                   "vgaoem.fon");

    NlsString.Buffer = OemHalFontName;
    NlsString.Length = (USHORT) strlen(OemHalFontName);
    OemHalFont.MaximumLength = strlen(OemHalFontName)*sizeof(WCHAR)+sizeof(UNICODE_NULL);
    OemHalFont.Buffer = BlAllocateHeap(OemHalFont.MaximumLength);
    if (OemHalFont.Buffer == NULL) {
        SlNoMemoryError();
    }
    RtlAnsiStringToUnicodeString(&OemHalFont, &NlsString, FALSE);

#ifdef _WANT_MACHINE_IDENTIFICATION

    BiosInfo.Buffer = NULL;
    NlsString.Buffer = SlGetIniValue(InfFile,
                                     "BiosInfo",
                                     "InfName",
                                     NULL);

    if (NlsString.Buffer) {

        NlsString.Length = (USHORT) strlen(NlsString.Buffer);
        BiosInfo.MaximumLength = NlsString.Length*sizeof(WCHAR)+sizeof(UNICODE_NULL);
        BiosInfo.Buffer = BlAllocateHeap(BiosInfo.MaximumLength);
        RtlAnsiStringToUnicodeString(&BiosInfo, &NlsString, FALSE);

    }

 #endif

    //
    // Loading all the miniport will exhaust all free mem <16Mb - ArcSetup dies.
    //
#ifndef ARCI386
    LoadScsiMiniports = (atoi(SlGetIniValue(InfFile,
                                            "SetupData",
                                            "ForceScsi",
                                            "0")) == 1);
#endif

    LoadDiskClass = (atoi(SlGetIniValue(InfFile,
                                        "setupdata",
                                        "ForceDiskClass",
                                        "0")) == 1);

    LoadCdfs = (atoi(SlGetIniValue(InfFile,
                                   "setupdata",
                                   "ForceCdRom",
                                   "0")) == 1);


    BootPath = SlGetIniValue(InfFile,
                             "setupdata",
                             "BootPath",
                             NULL);
    BootDevice = SlGetIniValue(InfFile,
                               "setupdata",
                               "BootDevice",
                               NULL);

    //
    //  Build a linked list with all the P&P hardware ids.
    //  listed on [HardwareIdsDatabase]. This list will be used
    //  during the initialization phase of setupdd.sys
    //
    SetupBlock->HardwareIdDatabase = NULL;

    if( SpSearchINFSection( InfFile, "HardwareIdsDatabase" ) ) {
        ULONG   i;
        PPNP_HARDWARE_ID TempHardwareId;
        PCHAR   p;

        for( i = 0;
             ((p = SlGetKeyName( InfFile, "HardwareIdsDatabase", i )) != NULL);
             i++ ) {
            TempHardwareId = BlAllocateHeap(sizeof(PNP_HARDWARE_ID));

            if (TempHardwareId==NULL) {
                SlNoMemoryError();
            }

            TempHardwareId->Id = p;
            p = SlGetSectionKeyIndex( InfFile,
                                      "HardwareIdsDatabase",
                                      TempHardwareId->Id,
                                      0 );
            TempHardwareId->DriverName = p;
            p = SlGetSectionKeyIndex( InfFile,
                                      "HardwareIdsDatabase",
                                      TempHardwareId->Id,
                                      1 );
            TempHardwareId->ClassGuid = p;

            TempHardwareId->Next = SetupBlock->HardwareIdDatabase;
            SetupBlock->HardwareIdDatabase = TempHardwareId;
        }
    }

    if (BlLoaderBlock->LoadOptions) {
        _strupr(BlLoaderBlock->LoadOptions);

        if ( Options = strstr(BlLoaderBlock->LoadOptions,"/MAXMEM") ) {
            MaxMemory = atoi(Options+8);
            SlpTruncateMemory( MaxMemory );
        }
    }
}


VOID
SlGetSetupValuesAfterPrompt(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )
/*++

Routine Description:

    Reads the setup control values out of the given .INI file.  Also supplies
    reasonable defaults for values that don't exist.

    Note : This is called after the user is prompted for F5,
           F6 & F7 behavior.

Arguments:

    SetupBlock - Supplies a pointer to the Setup loader block

Return Value:

    None.  Global variables are initialized to reflect the contents
    of the INI file

--*/
{
    PCHAR MachineName = NULL;

    //
    // Determine which HAL to load.  If the appropriate HAL cannot be
    // determined, or if we are to prompt for an OEM HAL, then set the
    // 'PromptOemHal' flag (may have already been set by the user's
    // keypress).
    //
    if(!PromptOemHal) {
        PromptOemHal = (atoi(SlGetIniValue(InfFile,
                                       "setupdata",
                                       "ForceOemHal",
                                       "0")) == 1);
    }

    if(!PromptOemHal) {
        MachineName = SlDetectHal();
    }

    SetupBlock->ComputerDevice.Files = 0;
    SetupBlock->ComputerDevice.Next = NULL;
    SetupBlock->ComputerDevice.Description = NULL;
    SetupBlock->ComputerDevice.ThirdPartyOptionSelected = FALSE;
    SetupBlock->ComputerDevice.FileTypeBits = 0;
    SetupBlock->ComputerDevice.Files = 0;
    SetupBlock->ComputerDevice.BaseDllName = SlCopyStringA("");

    if(MachineName!=NULL) {
        SetupBlock->ComputerDevice.IdString = SlCopyStringA(MachineName);
        //
        // Map the machine name to a HAL name. If we're doing a remote boot,
        // look in the [Hal] section. Otherwise, look in the [Hal.Load]
        // section. (Local setup has a separate section to minimize the
        // number of HAL binaries that need to be on the boot floppies.)
        //
        HalName = SlGetIniValue(InfFile,
                                BlBootingFromNet ? "Hal" : "Hal.Load",
                                MachineName,
                                NULL);
        HalDescription = SlGetIniValue(InfFile,
                                       "Computer",
                                       MachineName,
                                       NULL);
    }

    if(!(MachineName && HalName && HalDescription)) {
        PromptOemHal = TRUE;
    }

    //
    // If we haven't already been instructed to prompt for an OEM SCSI disk (by
    // the user's keypress), then get this value from the inf file.
    //
    if(!PromptOemScsi) {
        PromptOemScsi = (atoi(SlGetIniValue(InfFile,
                                       "setupdata",
                                       "ForceOemScsi",
                                       "0")) == 1);
    }
}



VOID
BlOutputLoadMessage (
    IN PCHAR DeviceName,
    IN PCHAR FileName,
    IN PTCHAR FileDescription OPTIONAL
    )

/*++

Routine Description:

    This routine outputs a loading message on the status line

Arguments:

    DeviceName - Supplies a pointer to a zero terminated device name.

    FileName - Supplies a pointer to a zero terminated file name.

    FileDescription - Friendly name of the file in question.

Return Value:

    None.

--*/

{
    static int dots = 0;
    TCHAR OutputBuffer[256];
    PTCHAR FormatString;
#ifdef UNICODE
    WCHAR OutputBufferUnicode[256];
    UNICODE_STRING us;
    ANSI_STRING as;
#endif
    PTCHAR p;

    UNREFERENCED_PARAMETER( DeviceName );

    //
    // Construct and output loading file message.
    //

    if (!UseRegularBackground) {
        FormatString = BlFindMessage(SL_FILE_LOAD_MESSAGE);

        if (FileDescription) {
            _stprintf(OutputBuffer,FormatString,FileDescription);
            SlWriteStatusText(OutputBuffer);
        }            
    }

    return;
}



ARC_STATUS
SlLoadDriver(
    IN PTCHAR DriverDescription,
    IN PCHAR DriverName,
    IN ULONG DriverFlags,
    IN BOOLEAN InsertIntoDriverList,
    IN BOOLEAN MigratedDriver
    )

/*++

Routine Description:

    Attempts to load a driver from the device identified by the global
    variable BootDeviceId.

Arguments:

    DriverDescription - Supplies a friendly description of the driver being
                        loaded.

    DriverName - Supplies the name of the driver.

    DriverFlags - Flags to set in the LDR_DATA_TABLE_ENTRY.

    InsertIntoDriverList - Flag specifying whether this 'driver' should be
                           placed into the BootDriveListHead list (eg, scsiport.sys
                           is not a true driver, and should not be placed in this list)

    MigratedDriver - Flag specifying whther this driver was migrated from an NT system.

Return Value:

    ESUCCESS - Driver successfully loaded

--*/

{
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    NTSTATUS Status;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    FULL_PATH_SET PathSet;

    if(BlCheckForLoadedDll(DriverName,&DataTableEntry)) {
        return(ESUCCESS);
    }

    DriverEntry = SlpCreateDriverEntry(DriverName);
    if(DriverEntry == NULL) {
        SlNoMemoryError();
        return(ENOMEM);
    }

    if( !WinPEBoot && !MigratedDriver ) {
        SlGetDisk(DriverName);
    }

    PathSet.PathCount = 1;
    PathSet.AliasName = "\\SystemRoot";
    PathSet.PathOffset[0] = '\0';
    PathSet.Source[0].DeviceId = BootDeviceId;
    PathSet.Source[0].DeviceName = BootDevice;

    if (WinPEBoot) {
        static PCHAR Path = NULL;

        if (!Path) {
            CHAR Buffer[256];

            strcpy(Buffer, BootPath);
            strcat(Buffer, "drivers\\");
            Path = SlCopyStringA(Buffer);
        }

        PathSet.Source[0].DirectoryPath = Path;
    } else {
        PathSet.Source[0].DirectoryPath = BootPath;
    }

    Status = BlLoadDeviceDriver(
                &PathSet,
                DriverName,
                DriverDescription,
                DriverFlags,
                &DriverEntry->LdrEntry
                );

    if((Status == ESUCCESS) && InsertIntoDriverList) {
        InsertTailList(&BlLoaderBlock->BootDriverListHead,&DriverEntry->Link);
    }

    return(Status);
}



ARC_STATUS
SlLoadOemDriver(
    IN PCHAR ExportDriver OPTIONAL,
    IN PCHAR DriverName,
    IN PVOID BaseAddress,
    IN PTCHAR LoadMessage
    )
{
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    ARC_STATUS Status;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    FULL_PATH_SET PathSet;

    UNREFERENCED_PARAMETER(LoadMessage);

    if(BlCheckForLoadedDll(DriverName,&DataTableEntry)) {
        return(ESUCCESS);
    }

    if(ExportDriver) {
        SlGetDisk(ExportDriver);
    }

    DriverEntry = SlpCreateDriverEntry(DriverName);
    if (DriverEntry==NULL) {
        return(ENOMEM);
    }

    Status = BlAllocateDataTableEntry(
                DriverName,
                DriverName,
                BaseAddress,
                &DriverEntry->LdrEntry
                );

    if (Status == ESUCCESS) {

        PathSet.PathCount = 1;
        PathSet.AliasName = "\\SystemRoot";
        PathSet.PathOffset[0] = '\0';
        PathSet.Source[0].DeviceId = BootDeviceId;
        PathSet.Source[0].DeviceName = BootDevice;
        PathSet.Source[0].DirectoryPath = BootPath;

        Status = BlScanImportDescriptorTable(
                    &PathSet,
                    DriverEntry->LdrEntry,
                    LoaderBootDriver
                    );

        if(Status == ESUCCESS) {

            InsertTailList(&BlLoaderBlock->BootDriverListHead,&DriverEntry->Link);
        }
    }

    return(Status);
}




PBOOT_DRIVER_LIST_ENTRY
SlpCreateDriverEntry(
    IN PCHAR DriverName
    )

/*++

Routine Description:

    Allocates and initializes a boot driver list entry structure.

Arguments:

    DriverName - Supplies the name of the driver.

Return Value:

    Pointer to the initialized structure.

--*/

{
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    ANSI_STRING String;

    DriverEntry = BlAllocateHeap(sizeof(BOOT_DRIVER_LIST_ENTRY));
    if (DriverEntry==NULL) {
        SlNoMemoryError();
        return(NULL);
    }
    DriverEntry->FilePath.MaximumLength = strlen(DriverName)*sizeof(WCHAR)+sizeof(WCHAR);
    DriverEntry->FilePath.Buffer = BlAllocateHeap(DriverEntry->FilePath.MaximumLength);
    if (DriverEntry->FilePath.Buffer==NULL) {
        SlNoMemoryError();
        return(NULL);
    }
    String.Length = (USHORT) strlen(DriverName);
    String.Buffer = DriverName;
    RtlAnsiStringToUnicodeString(&DriverEntry->FilePath, &String, FALSE);

    return(DriverEntry);
}


BOOLEAN
SlGetDisk(
    IN PCHAR Filename
    )

/*++

Routine Description:

    Given a filename, this routine ensures that the correct disk is
    in the drive identified by the global variables BootDevice and
    BootDeviceId. The user may be prompted to change disks.

Arguments:

    Filename - Supplies the name of the file to be loaded.

Return Value:

    TRUE - Disk was successfully loaded.

    FALSE - User has cancelled out of Setup.

--*/

{
    PCHAR DiskNumber;
    PTCHAR DiskName;
    PCHAR DiskTag;
    ULONG FileId;
    CHAR PlatformSpecificSection[128];
    PCHAR  DiskTagSection = NULL;

    //
    // If the media is fixed, the user can't change disks.
    // Just return TRUE indicating that the disk is in the drive.
    //
    if(FixedBootMedia || BlBootingFromNet) {
       return(TRUE);
    }

    //
    // Look up filename to get the disk number. Look in the platform-specific
    // directory first.
    //
    strcpy(PlatformSpecificSection,FilesSectionName);
    strcat(PlatformSpecificSection,PlatformExtension);

#if defined(ELTORITO)
    if (ElToritoCDBoot) {
        // for Cd boot we use the setup media path instead of a boot-media-specific path
        DiskNumber = SlGetSectionKeyIndex(InfFile,PlatformSpecificSection,Filename,0);
    } else {
#endif

    DiskNumber = SlGetSectionKeyIndex(InfFile,PlatformSpecificSection,Filename,6);

#if defined(ELTORITO)
    }
#endif

    if(DiskNumber == NULL) {

#if defined(ELTORITO)
        if (ElToritoCDBoot) {
            // for Cd boot we use the setup media path instead of a boot-media-specific path
            DiskNumber = SlGetSectionKeyIndex(InfFile,FilesSectionName,Filename,0);
        } else {
#endif

        DiskNumber = SlGetSectionKeyIndex(InfFile,FilesSectionName,Filename,6);

#if defined(ELTORITO)
        }
#endif

    }

    if((DiskNumber==NULL) || !(*DiskNumber)) {
        SlFatalError(SL_INF_ENTRY_MISSING,SlCopyStringAT(Filename),FilesSectionName);
        return(FALSE);
    }

    //
    // Look up disk number to get the diskname and tag.
    // Look in platform-specific directory first.
    //
    strcpy(PlatformSpecificSection,MediaSectionName);
    strcat(PlatformSpecificSection,PlatformExtension);

#ifdef UNICODE
    if(DiskName = (PTCHAR)SlGetSectionKeyIndexW(
#else
    if(DiskName = (PTCHAR)SlGetSectionKeyIndex(
#endif
                                        InfFile,
                                        PlatformSpecificSection,
                                        DiskNumber,
                                        0)) {
        DiskTag = SlGetSectionKeyIndex(InfFile,PlatformSpecificSection,DiskNumber,1);
        DiskTagSection = PlatformSpecificSection;
    } else {
#ifdef UNICODE
        if(DiskName = (PTCHAR)SlGetSectionKeyIndexW(
#else
        if(DiskName = (PTCHAR)SlGetSectionKeyIndex(
#endif
                                        InfFile,
                                        MediaSectionName,
                                        DiskNumber,
                                        0)) {
            DiskTag = SlGetSectionKeyIndex(InfFile,MediaSectionName,DiskNumber,1);
            DiskTagSection = MediaSectionName;
        } else {
            SlFatalError(SL_INF_ENTRY_MISSING,SlCopyStringAT(DiskNumber),SlCopyStringAT(MediaSectionName));
            return(FALSE);
        }
    }

    if (!DiskTag) {
        SlFatalError(SL_INF_ENTRY_MISSING,SlCopyStringAT(DiskNumber), SlCopyStringAT(DiskTagSection));
        return FALSE;
    }

    //
    // If this disk is known to be in the drive, don't look again
    //
    if ((LastDiskTag != NULL) && (!strcmp(DiskTag, LastDiskTag))) {
        return(TRUE);
    }

    LastDiskTag = NULL;


    while(1) {

        //
        // Open a new device id onto the disk.
        //
        if(BootDeviceIdValid) {
            ArcClose(BootDeviceId);
            BootDeviceIdValid = FALSE;
        }

        if(ArcOpen(BootDevice,ArcOpenReadOnly,&BootDeviceId) == ESUCCESS) {

            BootDeviceIdValid = TRUE;
            //
            // Check for existence of the disk tag.
            //
            if(BlOpen(BootDeviceId,DiskTag,ArcOpenReadOnly,&FileId) == ESUCCESS) {

                //
                // Disk is in the drive.  Return success.
                // Leave BootDeviceId open onto the device.
                //
                BlClose(FileId);
                LastDiskTag = DiskTag;
                return(TRUE);

            } else {

                //
                // Prompt for the user to change disks.
                //
                ArcClose(BootDeviceId);
                BootDeviceIdValid = FALSE;

                SlPromptForDisk(DiskName, FALSE);

            }
        } else {
            //
            // Can't open device. Prompt for the disk.
            //
            SlPromptForDisk(DiskName, FALSE);
        }
    }
}


PTCHAR
SlCopyString(
    IN PTCHAR String
    )

/*++

Routine Description:

    Copies a tchar string into the loader heap so it can be passed to the
    kernel.

Arguments:

    String - Supplies the string to be copied.

Return Value:

    PTCHAR - pointer into the loader heap where the string was copied to.

--*/

{
    PTCHAR Buffer;

    if (String==NULL) {
        SlNoMemoryError();
    }
    Buffer = BlAllocateHeap((_tcslen(String)+1)*sizeof(TCHAR));
    if (Buffer==NULL) {
        SlNoMemoryError();
    } else {
        _tcscpy(Buffer, String);
    }

    return(Buffer);
}


PCHAR
SlCopyStringA(
    IN PCSTR String
    )

/*++

Routine Description:

    Copies an ANSI string into the loader heap so it can be passed to the
    kernel.

Arguments:

    String - Supplies the string to be copied.

Return Value:

    PCHAR - pointer into the loader heap where the string was copied to.

--*/

{
    PCHAR Buffer;

    if (String==NULL) {
        SlNoMemoryError();
    }
    Buffer = BlAllocateHeap(strlen(String)+1);
    if (Buffer==NULL) {
        SlNoMemoryError();
    } else {
        strcpy(Buffer, String);
    }

    return(Buffer);
}



ARC_STATUS
SlLoadSection(
    IN PVOID Inf,
    IN PCSTR SectionName,
    IN BOOLEAN IsScsiSection,
    IN BOOLEAN AppendLoadSuffix,
    IN OUT PULONG  StartingInsertIndex OPTIONAL
    )

/*++

Routine Description:

    Enumerates all the drivers in a section and loads them.

Arguments:

    Inf - Supplies a handle to the INF file.

    SectionName - Supplies the name of the section.

    IsScsiSection - Flag specifying whether this is the Scsi.Load section.
                    If so, we create the DETECTED_DEVICE linked list, but
                    don't actually load the drivers.

    AppendLoadSuffix - Indicates whether to append the ".load" suffix to the
                       section name or not.

    StartingInsertIndex - The position index in the linked list at which
                          the device needs to be inserted. The output value
                          contains the next available index.

Return Value:

    ESUCCESS if all drivers were loaded successfully/no errors encountered

--*/

{
    ULONG i;
    CHAR LoadSectionName[100];
    PCHAR DriverFilename;
    PCHAR DriverId;
    PTCHAR DriverDescription;
    PCHAR NoLoadSpec;
    PCHAR p;
    ARC_STATUS Status;
    PDETECTED_DEVICE ScsiDevice;
    SCSI_INSERT_STATUS sis;
    ULONG  InsertIndex;

    strcpy(LoadSectionName, SectionName);
    
    if (AppendLoadSuffix) {
        strcat(LoadSectionName, ".Load");
    }                

    //
    // Use the specified insert index, if its valid
    //
    if (StartingInsertIndex && ((*StartingInsertIndex) != (-1))) {
        InsertIndex = *StartingInsertIndex;
    } else {
        InsertIndex = 0;
    }        

    i=0;
    do {
        DriverFilename = SlGetSectionLineIndex(Inf,LoadSectionName,i,SIF_FILENAME_INDEX);
        NoLoadSpec = SlGetSectionLineIndex(Inf,LoadSectionName,i,2);

        if(DriverFilename && ((NoLoadSpec == NULL) || _stricmp(NoLoadSpec,"noload"))) {

            if(!IsScsiSection) {
                //
                // We only want to load the drivers if they aren't scsi miniports
                //
                DriverId = SlGetKeyName(Inf,LoadSectionName,i);
#ifdef UNICODE
                DriverDescription = SlGetIniValueW( 
                                            Inf, 
                                            (PSTR)SectionName,
                                            DriverId, 
                                            SlCopyStringAW(DriverId));
#else
                DriverDescription = SlGetIniValue( 
                                            Inf, 
                                            (PSTR)SectionName,
                                            DriverId, 
                                            DriverId);
#endif

                Status = SlLoadDriver(DriverDescription,
                                      DriverFilename,
                                      0,
                                      TRUE,
                                      FALSE
                                      );

                if((Status == ENOENT) && IgnoreMissingFiles) {
                    Status = ESUCCESS;
                }
            } else {
                Status = ESUCCESS;
            }

            if (Status == ESUCCESS) {

                if(IsScsiSection) {

                    //
                    // Create a new detected device entry.
                    //
                    if((sis = SlInsertScsiDevice(InsertIndex, &ScsiDevice)) == ScsiInsertError) {
                        return(ENOMEM);
                    }

                    if(sis == ScsiInsertExisting) {
#if DBG
                        //
                        // Sanity check to make sure we're talking about the same driver
                        //
                        if(_stricmp(ScsiDevice->BaseDllName, DriverFilename)) {
                            SlError(400);
                            return EINVAL;
                        }
#endif
                    } else {
                        InsertIndex++;
                        p = SlGetKeyName(Inf,LoadSectionName,i);

                        //
                        // Find the driver description
                        //
                        if(p) {
#ifdef UNICODE
                            DriverDescription = SlGetIniValueW( 
                                                        Inf,
                                                        (PSTR)SectionName,
                                                        p,
                                                        SlCopyStringAW(p));
#else
                            DriverDescription = SlGetIniValue(
                                                        Inf,
                                                        (PSTR)SectionName,
                                                        p,
                                                        p);
#endif                                                        
                        } else {
                            DriverDescription = SlCopyString(BlFindMessage(SL_TEXT_SCSI_UNNAMED));
                        }

                        ScsiDevice->IdString = p ? p : SlCopyStringA("");
                        ScsiDevice->Description = DriverDescription;
                        ScsiDevice->ThirdPartyOptionSelected = FALSE;
                        ScsiDevice->MigratedDriver = FALSE;
                        ScsiDevice->FileTypeBits = 0;
                        ScsiDevice->Files = NULL;
                        ScsiDevice->BaseDllName = DriverFilename;
                    }
                }
            } else {
                SlFriendlyError(
                    Status,
                    DriverFilename,
                    __LINE__,
                    __FILE__
                    );
                return(Status);
            }
        }

        i++;

    } while ( DriverFilename != NULL );

    if (StartingInsertIndex) {
        *StartingInsertIndex = InsertIndex;
    }                

    return(ESUCCESS);

}



VOID
SlpMarkDisks(
    IN BOOLEAN Reboot
    )

/*++

Routine Description:

    This routine ensures that there is not more than one disk with the
    same checksum, a signature of zero, and a valid partition table.

    If it finds a disk with a signature of zero, it searches the rest
    of the list for any other disks with a zero signature and the same
    checksum.  If it finds one, it stamps a unique signature on the
    first disk.

    We also use a heuristic to determine if the disk is 'vacant', and if
    so, we stamp a unique signature on it (unless it's the first one we
    found).

Arguments:

    Reboot - Indicates whether to reboot after stamping signatures

Return Value:

    None.

--*/

{
    PARC_DISK_INFORMATION DiskInfo;
    PLIST_ENTRY     Entry;
    PLIST_ENTRY     CheckEntry;
    PARC_DISK_SIGNATURE DiskSignature;
    PARC_DISK_SIGNATURE CheckDiskSignature;
    ARC_STATUS      Status = ESUCCESS;
    BOOLEAN         VacantDiskFound = FALSE;
    BOOLEAN         SignatureStamped = FALSE;
    ULONG           DiskCount = 0;
    ULONG           DisksStamped = 0;

    DiskInfo = BlLoaderBlock->ArcDiskInformation;
    Entry = DiskInfo->DiskSignatures.Flink;

    while (Entry != &DiskInfo->DiskSignatures) {

        DiskSignature = CONTAINING_RECORD(Entry,ARC_DISK_SIGNATURE,ListEntry);

        //
        // Make sure there are no other disks with this same
        // signature.
        //
        CheckEntry = Entry->Flink;
        while( CheckEntry != &DiskInfo->DiskSignatures ) {

            CheckDiskSignature = CONTAINING_RECORD(CheckEntry,ARC_DISK_SIGNATURE,ListEntry);

            if( (CheckDiskSignature->Signature == DiskSignature->Signature) ) {

                //
                // We found another disk with the same disk signature.
                // Stamp a new signature on the disk.
                //
                Status = SlpStampFTSignature(CheckDiskSignature, TRUE);
                SignatureStamped = TRUE;
                DisksStamped++;

                if (Status != ESUCCESS) {
                    SlError(Status);
                }
            }

            CheckEntry = CheckEntry->Flink;
        }

        //
        // Now look for disk with no signature.
        //
        if (DiskSignature->ValidPartitionTable) {
            if (DiskSignature->Signature == 0) {
                Status = SlpStampFTSignature(DiskSignature, TRUE);
                SignatureStamped = TRUE;
                DisksStamped++;

                if (Status != ESUCCESS) {
                    SlError(Status);
                }
            }                
        } else {
            //
            // See if the disk is vacant.
            //
            if (SlpIsDiskVacant(DiskSignature)) {
                //
                // If disk has the signature then use it otherwise
                // stamp a new signature
                //
                Status = SlpStampFTSignature(DiskSignature,
                              (DiskSignature->Signature == 0));
                              
                SignatureStamped = TRUE;
                DisksStamped++;

                if (Status != ESUCCESS) {
                    SlError(Status);
                }
            }
        }

        DiskCount++;
        Entry = Entry->Flink;
    }

    //
    // We've just changed the signatures on a disk.  It might be
    // okay to continue with the boot, but may not. Lets not reboot
    // as textmode setup will bugcheck if the signatures
    // are not stamped correctly.
    //
    if( SignatureStamped) {

        if (Reboot) {
            SlFatalError(SIGNATURE_CHANGED);
        } else {
            //
            // Don't bother rescanning the disks if there is only
            // one disk or we just stamped only one disk
            //
            if ((DiskCount > 1) && (DisksStamped > 1)) {
                
                Status = BlGetArcDiskInformation(TRUE);

                if (Status != ESUCCESS) {                    
                    SlFatalError(SIGNATURE_CHANGED);
                }else {
                    //
                    // Reboot if first time signature
                    // stamping failed to update the disks
                    // correctly
                    //
                    SlpMarkDisks(TRUE);
                }
            }
        }
    }
}


BOOLEAN
SlpIsDiskVacant(
    IN PARC_DISK_SIGNATURE DiskSignature
    )

/*++

Routine Description:

    This routine attempts to determine if a disk is 'vacant' by
    checking to see if the first half of its MBR has all bytes set
    to the same value.

Arguments:

    DiskSignature - Supplies a pointer to the existing disk
                    signature structure.

Return Value:

    TRUE  - The disk is vacant.
    FALSE - The disk is not vacant (ie, we can't determine if it
            is vacant using our heuristic)

--*/
{
    UCHAR Partition[100];
    ULONG DiskId;
    ARC_STATUS Status;
    UCHAR SectorBuffer[512+256];
    PUCHAR Sector;
    LARGE_INTEGER SeekValue;
    ULONG Count, i;
    BOOLEAN IsVacant;

    //
    // Open partition0.
    //
    strcpy(Partition, DiskSignature->ArcName);
    strcat(Partition, "partition(0)");
    Status = ArcOpen(Partition, ArcOpenReadOnly, &DiskId);
    if (Status != ESUCCESS) {
        return(FALSE);
    }

    //
    // Read in the first sector
    //
    Sector = ALIGN_BUFFER(SectorBuffer);
    SeekValue.QuadPart = 0;
    Status = ArcSeek(DiskId, &SeekValue, SeekAbsolute);
    if (Status == ESUCCESS) {
        Status = ArcRead(DiskId, Sector, 512, &Count);
    }
    if (Status != ESUCCESS) {
        ArcClose(DiskId);
        return(FALSE);
    }

    //
    // See if 1st 256 bytes are identical
    //
    for(i = 1, IsVacant = TRUE; i<256; i++) {
        if(Sector[i] - *Sector) {
            IsVacant = FALSE;
            break;
        }
    }

    ArcClose(DiskId);

    return(IsVacant);
}



ARC_STATUS
SlpStampFTSignature(
    IN PARC_DISK_SIGNATURE DiskSignature,
    IN BOOLEAN GenerateNewSignature
    )

/*++

Routine Description:

    This routine stamps a given drive with a unique signature.
    It traverses the list of disk signatures to ensure that it
    stamps a signature that is not already present in the
    disk list.  Then it writes the new disk signature to the
    disk and recomputes the checksum.

Arguments:

    DiskSignature - Supplies a pointer to the existing disk
        signature structure. 

    GenerateNewSignature - Indicates whether to generate a new
        signature or use the one in DiskSignature. When TRUE
        this will also disable the check of duplicate signatures. 
        This argument is ignored when the DiskSignature->Signature
        field is 0, since 0 is not a valid signature
                           

Return Value:

    None.

--*/
{
    ULONG NewSignature;
    PLIST_ENTRY ListEntry;
    UCHAR SectorBuffer[SECTOR_SIZE * 2];
    PUCHAR Sector;
    LARGE_INTEGER SeekValue;
    UCHAR Partition[100];
    PARC_DISK_SIGNATURE Signature;
    ULONG DiskId;
    ARC_STATUS Status;
    ULONG i;
    ULONG Sum;
    ULONG Count;
    

    if (GenerateNewSignature || (DiskSignature->Signature == 0)) {
        //
        // Get a reasonably unique seed to start with.
        //
        NewSignature = ArcGetRelativeTime();
        NewSignature = (NewSignature & 0xFFFF) << 16;
        NewSignature += ArcGetRelativeTime();

        //
        // Scan through the list to make sure it's unique.
        //
    ReScan:
        ListEntry = BlLoaderBlock->ArcDiskInformation->DiskSignatures.Flink;
        while (ListEntry != &BlLoaderBlock->ArcDiskInformation->DiskSignatures) {
            Signature = CONTAINING_RECORD(ListEntry,ARC_DISK_SIGNATURE,ListEntry);
            if (Signature->Signature == NewSignature) {
                //
                // Found a duplicate, pick a new number and
                // try again.
                //
                if (++NewSignature == 0) {
                    //
                    // zero signatures are what we're trying to avoid
                    // (like this will ever happen)
                    //
                    NewSignature = 1;
                }
                goto ReScan;
            }
            ListEntry = ListEntry->Flink;
        }
    } else {
        NewSignature = DiskSignature->Signature;
    }        
   

    //
    // Now we have a valid new signature to put on the disk.
    // Read the sector off disk, put the new signature in,
    // write the sector back, and recompute the checksum.
    //
    strcpy(Partition,DiskSignature->ArcName);
    strcat(Partition,"partition(0)");

    Status = ArcOpen(Partition, ArcOpenReadWrite, &DiskId);

    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Read in the first sector
    //
    Sector = ALIGN_BUFFER_WITH_SIZE(SectorBuffer, SECTOR_SIZE);
    SeekValue.QuadPart = 0;

    Status = ArcSeek(DiskId, &SeekValue, SeekAbsolute);

    if (Status == ESUCCESS) {
        Status = ArcRead(DiskId,Sector,512,&Count);
    }

    if (Status != ESUCCESS) {
        ArcClose(DiskId);
        return(Status);
    }

    //
    // If partition table is not valid then initialize it with BOOT_RECORD_SIGNATURE and
    // fill partition entries with zeros
    //  
    if (((USHORT UNALIGNED *)Sector)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
        memset(Sector + (PARTITION_TABLE_OFFSET * 2),
            0,
            SECTOR_SIZE - (PARTITION_TABLE_OFFSET * 2));

        ((USHORT UNALIGNED *)Sector)[BOOT_SIGNATURE_OFFSET] = BOOT_RECORD_SIGNATURE;
    }

    ((ULONG UNALIGNED *)Sector)[PARTITION_TABLE_OFFSET/2-1] = NewSignature;

    Status = ArcSeek(DiskId, &SeekValue, SeekAbsolute);

    if (Status == ESUCCESS) {
        Status = ArcWrite(DiskId,Sector,512,&Count);
    }

    ArcClose(DiskId);

    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // We have successfully written back out the new signature,
    // recompute the checksum.
    //
    DiskSignature->Signature = NewSignature;
    DiskSignature->ValidPartitionTable = TRUE;

    Sum = 0;
    for (i=0;i<128;i++) {
        Sum += ((PULONG)Sector)[i];
    }
    DiskSignature->CheckSum = 0-Sum;

    return(ESUCCESS);
}


VOID
SlCheckOemKeypress(
    IN ULONG WaitTime
    )
{

    ULONG StartTime;
    ULONG EndTime;
    ULONG c;
    PTCHAR StatusText;

    //
    // For no particular reason some machines occasionally leave F7s
    // in their keyboard buffer. Drain them out here.
    //
    while (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
        c = SlGetChar();
        switch (c) {
            case SL_KEY_F5:          // Force OEM HAL prompt
                PromptOemHal = TRUE;
                break;

            case SL_KEY_F6:          // Force OEM SCSI prompt
                PromptOemScsi = TRUE;
                break;

        }

    }

    //
    // HACK alert:  The oem hal and SCSI stuff doesn't make sense in an RIS
    // environment.  Instead, the administrator should put the oem drivers
    // on the RIS server.  So we don't display the OEM drivers prompt, instead
    // we hide it with some bogus "please wait" text.  We do this instead of
    // just skipping the check altogether so that the user will still have a
    // chance to press F7 to disable ACPI.
    //
    StatusText = BlFindMessage(
                    BlBootingFromNet 
                     ? SL_PLEASE_WAIT 
                     : SL_MSG_PRESS_F5_OR_F6);
    if( StatusText != NULL ) {
        SlWriteStatusText(StatusText);
    }

    StartTime = ArcGetRelativeTime();

    if (WinPEBoot) {
        EndTime = StartTime + WaitTime;
    } else {
        EndTime = StartTime + WaitTime;
    }

    do {
        if(ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
            //
            // There is a key pending, so see what it is.
            //
            c = SlGetChar();

            switch(c) {                
                case SL_KEY_F5:          // Force OEM HAL prompt
                    PromptOemHal = TRUE;
                    break;

                case SL_KEY_F6:          // Force OEM SCSI prompt
                    PromptOemScsi = TRUE;
                    break;

                case SL_KEY_F7:
                    DisableACPI = TRUE;  // Force ACPI disabled
                    break;                        

                case SL_KEY_F10:
                    UseCommandConsole = TRUE;  // User wants to use cmdcons
                    break;
            }

        }

    } while (EndTime > ArcGetRelativeTime());

    //
    // see comment above -- we reset these values back to FALSE in the RIS
    // scenario because they don't make sense
    //
    if (BlBootingFromNet) {
        PromptOemHal = FALSE;
        PromptOemScsi = FALSE;
    } else {
        SlWriteStatusText(TEXT(""));
    }
}

VOID
SlCheckASRKeypress(
    VOID
    )
/*++

Routine Description:

    See if the user is doing an ASR.  If so, see if he's got a floppy
    with asrpnp.sif on it.  We'll ask him to press F5 for this.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ARC_STATUS Status;
    #define     ASR_FILE "asrpnp.sif"
    ULONG       StartTime;
    ULONG       EndTime;
    ULONG       c;
    PTCHAR      StatusText;
    CHAR        FloppyName[80];
    ULONG       FloppyId;
    CHAR        FileName[128];
    PVOID       ASRPNPSifHandle = NULL;
    BOOLEAN     PromptASR = FALSE;
    BOOLEAN     Done = FALSE;
    BOOLEAN     FirstTry = TRUE;

#if defined(EFI)
    //
    // Turn off the EFI Watchdog
    //
    DisableEFIWatchDog();
#endif

    do {
        SlClearClientArea();

        //
        // Drain the keyboard buffer.
        //
        while (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
            c = SlGetChar();
        }

        if (FirstTry) {
            StatusText = BlFindMessage(SL_MSG_PRESS_ASR);
            FirstTry = FALSE;
        }
        else {
            StatusText = BlFindMessage(SL_MSG_PREPARING_ASR);
        }


        if( StatusText != NULL ) {
            SlWriteStatusText(StatusText);
        }

        StartTime = ArcGetRelativeTime();
        EndTime = StartTime + 5;

        do {
            if(ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
                //
                // There is a key pending, so see what it is.
                //
                c = SlGetChar();

                switch(c) {

                    case SL_KEY_F2:          // Force ASR prompt
                        PromptASR = TRUE;
                        Done = TRUE;
                        break;

                    case ASCI_ESC:
                        PromptASR = FALSE;
                        Done = TRUE;
                        break;
                }
            }

        } while( !Done && (EndTime > ArcGetRelativeTime()) );

        SlWriteStatusText(TEXT(""));

        if( PromptASR ) {
            Done = FALSE;

            StatusText = BlFindMessage(SL_MSG_ENTERING_ASR);
            if( StatusText != NULL ) {
              SlWriteStatusText(StatusText);
            }
            //
            // Build the filename we're looking for.
            //
            strcpy( FileName, "\\" );
            strcat( FileName, ASR_FILE );


            //
            // Initialize pointers in loader block.
            //
            BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFile = NULL;
            BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFileLength = 0;
            Status = ESUCCESS;


            //
            // Build the path to the floppy.
            //
            if (SlpFindFloppy(0,FloppyName)) {
                Status = ArcOpen(FloppyName,ArcOpenReadOnly,&FloppyId);

                //
                // We found the floppy and opened him.  See if he's
                // got our file.
                //
                if( Status == ESUCCESS ) {
                    ASRPNPSifHandle = NULL;

                    Status = SlInitIniFile( NULL,
                                            FloppyId,
                                            FileName,
                                            &ASRPNPSifHandle,
                                            &BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFile,
                                            &BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFileLength,
                                            &c );

                    ArcClose(FloppyId);
                }
            }


            //
            // See if we successfully loaded the file off the
            // floppy.
            //

            SlWriteStatusText(TEXT(""));

            if( (Status != ESUCCESS) ||
                (BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFile == NULL) ) {

                //
                // Missed.  Inform the user and we'll try again.
                //
                SlMessageBox(SL_MSG_WARNING_ASR);

            } else if (BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFileLength == 0) {
                //
                // Invalid ASR file: inform user and we'll try again
                //

                StatusText = BlFindMessage(SL_MSG_INVALID_ASRPNP_FILE);

                //
                // First display the ASR insert floppy message
                //
                SlDisplayMessageBox(SL_MSG_WARNING_ASR);
                //
                // Populate status area with the error
                //
                if( StatusText != NULL ) {
                  SlWriteStatusText(StatusText);
                }
                //
                // Now wait for user to hit a key
                //
                SlFlushConsoleBuffer();
                SlGetChar();
                //
                // Clear status just in case ...
                //
                if( StatusText != NULL ) {
                  SlWriteStatusText(TEXT(""));
                }

            } else {
                Done = TRUE;
            }
        }
    } while( PromptASR && !Done );

}


SCSI_INSERT_STATUS
SlInsertScsiDevice(
    IN  ULONG Ordinal,
    OUT PDETECTED_DEVICE *pScsiDevice
    )
/*++

Routine Description:

    This routine

Arguments:

    Ordinal - Supplies the 0-based ordinal of the Scsi device
              to insert (based on order listed in [Scsi.Load]
              section of txtsetup.sif).  If the Scsi device is a third party
              driver, then Ordinal is -1.

    pScsiDevice - Receives a pointer to the inserted DETECTED_DEVICE structure,
                  the existing structure, or NULL.
Return Value:

    ScsiInsertError    - Not enough memory to allocate a new DETECTED_DEVICE.
    ScsiInsertNewEntry - A new entry was inserted into the DETECTED_DEVICE list.
    ScsiInsertExisting - An existing entry was found that matched the specified
                         ordinal, so we returned this entry.

--*/
{
    PDETECTED_DEVICE prev, cur;

    if(Ordinal == (ULONG)-1) {
        //
        // This is a third-party driver, so find the end of the linked list
        // (we want to preserve the order in which the user specifies the drivers).
        //
        for(prev=BlLoaderBlock->SetupLoaderBlock->ScsiDevices, cur = NULL;
            prev && prev->Next;
            prev=prev->Next);
    } else {
        //
        // Find the insertion point in the linked list for this driver,
        // based on its ordinal.  (Note that we will insert all supported drivers
        // before any third-party ones, since (ULONG)-1 = maximum unsigned long value)
        //
        for(prev = NULL, cur = BlLoaderBlock->SetupLoaderBlock->ScsiDevices;
            cur && (Ordinal > cur->Ordinal);
            prev = cur, cur = cur->Next);
    }

    if(cur && (cur->Ordinal == Ordinal)) {
        //
        // We found an existing entry for this driver
        //
        *pScsiDevice = cur;
        return ScsiInsertExisting;
    }

    if(!(*pScsiDevice = BlAllocateHeap(sizeof(DETECTED_DEVICE)))) {
        return ScsiInsertError;
    }

    (*pScsiDevice)->Next = cur;
    if(prev) {
        prev->Next = *pScsiDevice;
    } else {
        BlLoaderBlock->SetupLoaderBlock->ScsiDevices = *pScsiDevice;
    }

    (*pScsiDevice)->Ordinal = Ordinal;

    return ScsiInsertNewEntry;
}


ARC_STATUS
SlLoadPnpDriversSection(
    IN PVOID Inf,
    IN PCHAR SectionName,
    IN OUT PDETECTED_DEVICE* DetectedDeviceList OPTIONAL
    )

/*++

Routine Description:

    Enumerates all pnp drivers listed in [<section name>.Load], loads them, and puts
    a list with all the the drivers loaded, in the setup loader block.

Arguments:

    Inf - Supplies a handle to the INF file.

    SectionName - Name of the section in the inf file that contains the list of
                  drivers to be loaded.

    DetectedDeviceList - Address of the variable in Setup loader block that will contain
                         the list of drivers loaded. If this argument is NULL, then the list of
                         loaded devices will not be created.

Return Value:

    ESUCCESS if all drivers were loaded successfully/no errors encountered

--*/

{
    ULONG i;
    CHAR LoadSectionName[100];
    PCHAR DriverFilename;
    PCHAR DriverId;
    PTCHAR DriverDescription;
    PCHAR NoLoadSpec;
    PCHAR p;
    ARC_STATUS Status;
    PDETECTED_DEVICE TempDevice;

    sprintf(LoadSectionName, "%s.Load",SectionName);

    i=0;
    do {
        DriverFilename = SlGetSectionLineIndex(Inf,LoadSectionName,i,SIF_FILENAME_INDEX);
        NoLoadSpec = SlGetSectionLineIndex(Inf,LoadSectionName,i,2);

        if(DriverFilename && ((NoLoadSpec == NULL) || _stricmp(NoLoadSpec,"noload"))) {
            DriverId = SlGetKeyName(Inf,LoadSectionName,i);
            
#ifdef UNICODE
            DriverDescription = SlGetIniValueW(
                                        Inf, 
                                        SectionName, 
                                        DriverId, 
                                        SlCopyStringAW(DriverId));
#else
            DriverDescription = SlGetIniValue(
                                        Inf, 
                                        SectionName, 
                                        DriverId, 
                                        DriverId);
#endif                                        

            Status = SlLoadDriver(DriverDescription,
                                  DriverFilename,
                                  0,
                                  TRUE,
                                  FALSE
                                  );

//            if((Status == ENOENT) && IgnoreMissingFiles) {
//                Status = ESUCCESS;
//            }

            if (Status == ESUCCESS) {
                if( DetectedDeviceList != NULL ) {
                    //
                    // if the enumerator loaded, then record DETECTED_DEVICE info
                    //
                    TempDevice = BlAllocateHeap(sizeof(DETECTED_DEVICE));
                    
                    if(!TempDevice) {
                        SlNoMemoryError();

                        return ENOMEM;
                    }
                    
                    TempDevice->IdString = SlCopyStringA(DriverId);
                    TempDevice->Description = DriverDescription;
                    TempDevice->ThirdPartyOptionSelected = FALSE;
                    TempDevice->MigratedDriver = FALSE;
                    TempDevice->FileTypeBits = 0;
                    TempDevice->BaseDllName = SlCopyStringA(DriverFilename);
                    TempDevice->Next = *DetectedDeviceList;
                    *DetectedDeviceList = TempDevice;
                }
            } else {
                SlFriendlyError(
                    Status,
                    DriverFilename,
                    __LINE__,
                    __FILE__
                    );
                return(Status);
            }
        }
        i++;

    } while ( DriverFilename != NULL );

    return(ESUCCESS);
}


ARC_STATUS
SlDetectMigratedScsiDrivers(
    IN PVOID Inf
    )

/*++

Routine Description:

    Create an entry in the ScsiDevice list for each migrated SCSI driver.

Arguments:

    Inf - Supplies a handle to the INF file.

Return Value:

    ESUCCESS if all drivers were added to the ScsiDevice list.

--*/

{
    ULONG i;
    CHAR LoadSectionName[100];
    PCHAR DriverFilename;
    PCHAR DriverId;
    PTCHAR DriverDescription;
    ARC_STATUS Status;
    PDETECTED_DEVICE ScsiDevice;
    SCSI_INSERT_STATUS sis;

    i=0;
    do {
        DriverId = SlGetSectionLineIndex(Inf,"Devices",i,0);
        if( DriverId ) {
            sprintf(LoadSectionName, "Files.%s", DriverId);

            DriverFilename = SlGetSectionLineIndex(Inf,LoadSectionName,0,0);
            if(DriverFilename) {

                //
                // Remove inbox drivers with the same name as a winnt32-migrated OEM driver (if any)
                //
                SlRemoveInboxDriver (DriverFilename);

                //
                // Create a new detected device entry.
                //
                if((sis = SlInsertScsiDevice(-1, &ScsiDevice)) == ScsiInsertError) {
                    return(ENOMEM);
                }

                if(sis == ScsiInsertExisting) {
#if DBG
                    //
                    // Sanity check to make sure we're talking about the same driver
                    //
                    if(_stricmp(ScsiDevice->BaseDllName, DriverFilename)) {
                        SlError(400);
                        return EINVAL;
                    }
#endif
                } else {
                    DriverDescription = SlCopyString(BlFindMessage(SL_TEXT_SCSI_UNNAMED));

                    ScsiDevice->IdString = DriverId;
                    ScsiDevice->Description = DriverDescription;
                    ScsiDevice->ThirdPartyOptionSelected = FALSE;
                    ScsiDevice->MigratedDriver = TRUE;
                    ScsiDevice->FileTypeBits = 0;
                    ScsiDevice->Files = NULL;
                    ScsiDevice->BaseDllName = DriverFilename;
                }
            }
        }
        i++;

    } while ( DriverId != NULL );

    return(ESUCCESS);
}



ARC_STATUS
SlGetMigratedHardwareIds(
    IN PSETUP_LOADER_BLOCK SetupBlock,
    IN PVOID               Inf
    )

/*++

Routine Description:

    Add the hardware ids for the migrated scsi drivers, to the hardware id list.

Arguments:

    SetupBlock - Supplies a pointer to the Setup loader block

Return Value:

    ESUCCESS if all hardware ids were added to the hardware id list

--*/

{

    PCHAR DriverId;
    ULONG i, j;
    PPNP_HARDWARE_ID TempHardwareId;
    PCHAR   p;

    for( j = 0;
         (DriverId = SlGetSectionLineIndex(Inf,"Devices",j,0)) != NULL;
         j++ ) {
        CHAR  SectionName[100];

        sprintf(SectionName, "HardwareIds.%s", DriverId);
        for( i = 0;
             ((p = SlGetKeyName( Inf, SectionName, i )) != NULL);
             i++ ) {
            TempHardwareId = BlAllocateHeap(sizeof(PNP_HARDWARE_ID));

            if (TempHardwareId==NULL) {
                SlNoMemoryError();

                return ENOMEM;
            }
            
            TempHardwareId->Id = p;
            p = SlGetSectionKeyIndex( Inf,
                                      SectionName,
                                      TempHardwareId->Id,
                                      0 );
            TempHardwareId->DriverName = p;
            p = SlGetSectionKeyIndex( Inf,
                                      SectionName,
                                      TempHardwareId->Id,
                                      1 );
            TempHardwareId->ClassGuid = p;

            TempHardwareId->Next = SetupBlock->HardwareIdDatabase;
            SetupBlock->HardwareIdDatabase = TempHardwareId;
        }
    }
    return( ESUCCESS );
}


BOOLEAN
SlIsCdBootUpgrade(
    IN  PCHAR   InstallDirectory,
    IN  PCHAR   SetupFileName,
    IN  ULONG   MaxDisksToScan,
    IN  ULONG   MaxPartitionsPerDisk,
    OUT PCHAR   NewSetupDevice
    )
/*++

Routine Description:

    Finds out by looking into the hard disk if the specified
    directory exists and if the the user was indeed
    trying to uprgade

Arguments:

    InstallDirectory - Directory used on the hard disk
                       for installation

    SetupFileName    - Inf file name which has the key which
                       indicates if upgrade was in progress or
                       not

    MaxDisksToScan   - Maximum number of disks to scan

    MaxPartitionsPerDisk - Maximum partitions per disk to look into
                           for the install directory.

    NewSetupDevice - Place holder for arc name for the device 
                     if user wants to switch to harddisk boot.
                       

Return Value:

    TRUE if upgrade was in progress and user selected to continue on
    otherwise FALSE.

--*/
{
    BOOLEAN     Result = FALSE;    
    CHAR        DeviceName[128];
    ARC_STATUS  Status;
    ULONG       CurrentPartition;
    ULONG       CurrentDisk;

    //
    // Go through each disk 
    //
    for (CurrentDisk = 0; 
        (!Result && (CurrentDisk < MaxDisksToScan)); 
        CurrentDisk++) {

        Status = ESUCCESS;

        //
        // Go through each valid partition
        // for the current disk
        //
        for (CurrentPartition = 1; 
            (!Result && (Status == ESUCCESS));
            CurrentPartition++) {
            
            ULONG   DiskId;
            
            sprintf(DeviceName, 
                "multi(0)disk(0)rdisk(%d)partition(%d)",
                CurrentDisk,
                CurrentPartition);

            Status = ArcOpen(DeviceName, ArcOpenReadOnly, &DiskId);

            if (Status == ESUCCESS) {
                CHAR    FullName[128];
                PVOID   SifHandle = NULL;
                ULONG   ErrorLine = 0;
                ARC_STATUS  FileStatus;

                strcpy(FullName, InstallDirectory);
                strcat(FullName, "\\");
                strcat(FullName, SetupFileName);

                FileStatus = SlInitIniFile(NULL,
                                       DiskId,
                                       FullName,
                                       &SifHandle,
                                       NULL,
                                       NULL,
                                       &ErrorLine);

                if ((FileStatus == ESUCCESS) && SifHandle) {
                    Result = SlIsUpgrade(SifHandle);
                }

                ArcClose(DiskId);
            } else {            
                //
                // Ignore the error till the maximum number of
                // partitions are searched for
                //
                if (CurrentPartition < MaxPartitionsPerDisk) {
                    Status = ESUCCESS;
                }                    
            }
        }                
    }        

    if (Result) {
        ULONG   UserInput;
        BOOLEAN OldStatus = SlGetStatusBarStatus();

        //
        // Reset the result based on user input
        //
        Result = FALSE;

        SlEnableStatusBar(FALSE);        
        SlClearClientArea();
        SlDisplayMessageBox(SL_UPGRADE_IN_PROGRESS);

        do {            
            SlFlushConsoleBuffer();
            UserInput = SlGetChar();
        } 
        while ((UserInput != ASCI_CR) && 
               (UserInput != SL_KEY_F3) &&
               (UserInput != SL_KEY_F10));

        SlClearClientArea();    
               
        if (UserInput == SL_KEY_F3) {
            ArcRestart();
        } else if (UserInput == ASCI_CR) {
            Result = TRUE;
            strcpy(NewSetupDevice, DeviceName);
        }

        SlEnableStatusBar(OldStatus);
    }                
    
    return Result;
}


BOOLEAN
SlIsUpgrade(
    IN PVOID SifHandle
    )
/*++

Routine Description:

    Finds out by looking into the SIF file if upgrade is
    in progress or not

Arguments:

    InfHandle - Handle to winnt.sif file

Return Value:

    TRUE if upgrade  is in progress otherwise FALSE

--*/
{
    BOOLEAN Result = FALSE;

    if (SifHandle) {
        PCHAR   NtUpgrade = SlGetSectionKeyIndex(SifHandle,
                                WINNT_DATA_A,
                                WINNT_D_NTUPGRADE_A,
                                0);

        if (NtUpgrade) {
            Result = (_stricmp(NtUpgrade, WINNT_A_YES_A) == 0);
        }

        if (!Result) {
            PCHAR   Win9xUpgrade = SlGetSectionKeyIndex(SifHandle,
                                        WINNT_DATA_A,
                                        WINNT_D_WIN95UPGRADE_A,
                                        0);


            if (Win9xUpgrade) {
                Result = (_stricmp(Win9xUpgrade, WINNT_A_YES_A) == 0);
            }
        }
    }

    return Result;
}



BOOLEAN
SlpIsDynamicUpdate(
    IN  PVOID   InfHandle,
    OUT PCSTR   *DynamicUpdateRootDir
    )
/*++

Routine Description:

    Finds out whether there are any dynamic update boot drivers
    to process or not.

Arguments:

    InfHandle - Handle to winnt.sif file

    DynamicUpdateRootDir - Receives the root directory under which all
        the dynamic update boot driver packages are present.

Return Value:

    TRUE, if there are dynamic update boot drivers otherwise
    FALSE

--*/
{
    BOOLEAN Result = FALSE;

    if (InfHandle) {
        PCHAR   DynUpdateKey = SlGetSectionKeyIndex(InfHandle,
                                        WINNT_SETUPPARAMS_A,
                                        WINNT_SP_DYNUPDTBOOTDRIVERPRESENT_A,
                                        0);

        PCHAR   DynUpdateRoot = SlGetSectionKeyIndex(InfHandle,
                                        WINNT_SETUPPARAMS_A,
                                        WINNT_SP_DYNUPDTBOOTDRIVERROOT_A,
                                        0);

        //
        // DynamicUpdateBootDriverPresent and DynamicUpateBootDriverRoot
        // should have valid values
        //
        Result = (DynUpdateKey && DynUpdateRoot &&
                    !_stricmp(DynUpdateKey, "yes"));

        if (Result && DynamicUpdateRootDir) {
            *DynamicUpdateRootDir = SlCopyStringA(DynUpdateRoot);
        }
    }

    return Result;
}

UCHAR
SlGetDefaultAttr(
  VOID
  )
{
  return (UCHAR)((UseRegularBackground) ? (ATT_FG_WHITE | ATT_BG_BLACK) : (ATT_FG_WHITE | ATT_BG_BLUE));
}

UCHAR
SlGetDefaultInvAttr(
  VOID
  )
{
  return (UCHAR)((UseRegularBackground) ? (ATT_FG_BLACK | ATT_BG_WHITE) : (ATT_FG_BLUE | ATT_BG_WHITE));
}

BOOLEAN
SlRemoveOsLoadOption(
    IN OUT PSTR LoadOptions,
    IN PCSTR OptionToRemove
    )
/*++

Routine Description:

    Removes the first occurance of the requested option from
    the load options.

Arguments:

    LoadOptions - Pointer to the OS load options.

    OptionToRemove - The option that needs to be removed from the
        given OS load options. NOTE : This needs to start with "/"
        character.
        

Return Value:

    TRUE, if the requested option was removed otherwise FALSE.

--*/
{
    BOOLEAN Result = FALSE;

    //
    // verify arguments
    //
    if (LoadOptions && OptionToRemove && (OptionToRemove[0] == '/')) {
        CHAR Option[256];
        PSTR CurrentOption = strchr(LoadOptions, '/');

        while (CurrentOption && (*CurrentOption)) {
            //
            // get hold of the next load
            //
            PSTR EndPtr = strchr(CurrentOption + 1, '/');
            ULONG TokenLength;

            if (!EndPtr) {
                EndPtr = CurrentOption + strlen(CurrentOption);
            }                

            //
            // replicate the token into local buffer
            //
            TokenLength = (ULONG)(ULONG_PTR)(EndPtr - CurrentOption);
            strncpy(Option, CurrentOption, TokenLength);
            Option[TokenLength] = '\0';

            //
            // remove trailing whitespaces from the token
            //
            TokenLength--;
            while (TokenLength && (Option[TokenLength] == ' ')) {
                Option[TokenLength] = '\0';
                TokenLength--;
            }

            //
            // Is this the token we are looking for ?
            //
            if (_stricmp(Option, OptionToRemove) == 0) {
                //
                // remove the token from orginal string
                //
                strcpy(CurrentOption, EndPtr);
                Result = TRUE;

                break;
            }

            CurrentOption = EndPtr;
        }
    }

    return Result;
}


#ifdef _IA64_

BOOLEAN
SlIsWinPEAutoBoot(
    IN PSTR LoaderDeviceName
    )
/*++

Routine Description:

    Determines if this is an automated WinPE boot.

    NOTE : Automated WinPE boot is determined by the presence
    of the $WINPE$.$$$ file at the same location where
    setupldr.efi was started from.

Arguments:

    LoaderDeviceName : Arcname of the device where setupldr
        was started from.

Return Value:

    TRUE if this is WinPE auto boot, otherwise FALSE.

--*/
{
    BOOLEAN Result = FALSE;
    
    if (LoaderDeviceName) {
        ULONG   DiskId;
        ARC_STATUS Status;
        
        //
        // open the partition
        //
        Status = ArcOpen(LoaderDeviceName, ArcOpenReadOnly, &DiskId);

        //
        // try ATAPI device name in case SCSI device name fails
        //
        if (ESUCCESS != Status) {
            CHAR    Buffer[128];

            strcpy(Buffer, LoaderDeviceName);
            _strlwr(Buffer);

            if (NULL != strstr(Buffer, "scsi")) {
                CHAR    AtapiDeviceName[128];
                PCSTR   AdapterStart;
                PSTR    AdapterEnd;
                
                AdapterStart = strstr(Buffer, "scsi(");

                if (AdapterStart) {
                    AdapterStart += strlen("scsi(");
                    AdapterEnd = strchr(AdapterStart, ')');                

                    if (AdapterEnd) {
                        *AdapterEnd = '\0';

                        sprintf(AtapiDeviceName, 
                            "multi(%s)%s",
                            AdapterStart,
                            AdapterEnd + 1);

                        Status = ArcOpen(AtapiDeviceName, 
                                        ArcOpenReadOnly,
                                        &DiskId);
                    }
                }
            }                
        }

        if (Status == ESUCCESS) {
            CHAR        FileName[128];
            ARC_STATUS  FileStatus;
            ULONG       FileId;

            //
            // check for the existence of \$WINPE$.$$$
            //
            strcpy(FileName, "\\");
            strcat(FileName, WINPE_AUTOBOOT_FILENAME);
            
            FileStatus = BlOpen(DiskId, FileName, ArcOpenReadOnly, &FileId);

            if (FileStatus == ESUCCESS) {
                BlClose(FileId);
                Result = TRUE; 
            }

            ArcClose(DiskId);                    
        }                            
    }

    return Result;
}

ARC_STATUS
SlGetWinPEStartupParams(
    IN OUT PSTR StartupDeviceName,
    IN OUT PSTR StartupDirectory
    )
/*++

Routine Description:

    Searches for the WinPE installation on the available
    partitions on the first 4 disks. 
    
Arguments:

    StartupDeviceName - place holder for receiving device name 
        where WinPE installation was found.

    StartupDirectory - place holder for receiving WinPE installation
        directory.
            
Return Value:

    Appropriate ARC_STATUS error code.    

--*/
{
    ARC_STATUS Status = EINVAL;

    //
    // validate arguments
    //
    if (StartupDeviceName && StartupDirectory) {
        BOOLEAN     Found = FALSE;    
        CHAR        DeviceName[128];
        ULONG       CurrentPartition;
        ULONG       CurrentDisk;

        //
        // Go through each disk (at the max 4)
        //
        for (CurrentDisk = 0; 
            (!Found && (CurrentDisk < 4)); 
            CurrentDisk++) {
            
            //
            // Go through each valid partition
            // for the current disk
            //
            for (CurrentPartition = 1, Status = ESUCCESS; 
                (!Found && (Status == ESUCCESS));
                CurrentPartition++) {
                
                ULONG   DiskId;
                
                sprintf(DeviceName, 
                    "multi(0)disk(0)rdisk(%d)partition(%d)",
                    CurrentDisk,
                    CurrentPartition);

                //
                // open the disk
                //
                Status = ArcOpen(DeviceName, ArcOpenReadOnly, &DiskId);

                if (Status == ESUCCESS) {
                    CHAR        FullName[128];
                    ARC_STATUS  FileStatus;
                    ULONG       DirId;

                    //
                    // check for the existence of \\winpe\\ia64\\system32 directory
                    //
                    strcpy(FullName, "\\WINPE\\ia64\\system32");

                    FileStatus = BlOpen(DiskId, FullName, ArcOpenDirectory, &DirId);

                    if (FileStatus == ESUCCESS) {
                        BlClose(DirId);
                        Found = TRUE; 
                    }

                    ArcClose(DiskId);                    
                }                    
            }                
        }            

        //
        // update return arguments
        //
        if (Found && (ESUCCESS == Status)) {
            strcpy(StartupDeviceName, DeviceName);
            strcpy(StartupDirectory, "\\WINPE\\ia64\\");
        }

        if (!Found) {
            Status = EBADF;
        }
    }            

    return Status;
}

#endif // _IA64_

    
#ifdef _X86_

ARC_STATUS
SlLoadBootFontFile(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    IN ULONG DiskId,
    IN ULONG BootFontImageLength
    )
/*++

Routine Description:

    Loads the bootfont.bin into memory and initializes
    relevant fields in setup loader block.
    
Arguments:

    SetupLoaderBlock - pointer to setup loader block.

    DiskId - Disk ID where bootfont.bin resides on the root

    BootFontImageLength - The length of the bootfont.bin file.
            
Return Value:

    Appropriate ARC_STATUS error code.    

--*/
{
    ARC_STATUS Status = EINVAL;

    //
    // verify arguments
    //
    if (SetupLoaderBlock && BootFontImageLength) {
        ULONG FileId;
        PVOID Image = NULL;

        //
        // open the bootfont.bin file
        //
        if (BlBootingFromNet
#if defined(REMOTE_BOOT)
            && NetworkBootRom
#endif // defined(REMOTE_BOOT)
            ) {
            CHAR Buffer[129];
        
            strcpy(Buffer, NetBootPath);
            strcat(Buffer, "BOOTFONT.BIN");
            
            Status = BlOpen(DiskId, 
                        Buffer, 
                        ArcOpenReadOnly, 
                        &FileId);                    
        } else {
            Status = BlOpen(DiskId,
                        "\\BOOTFONT.BIN",
                        ArcOpenReadOnly,
                        &FileId);
        }

        //
        // allocate memory and read the contents of the file
        // into memory
        //
        if (ESUCCESS == Status) {        
            Image = BlAllocateHeap(BootFontImageLength);

            if (Image) {
                ULONG BytesRead = 0;
                
                Status = BlRead(FileId, Image, BootFontImageLength, &BytesRead);

                if ((ESUCCESS == Status) && (BytesRead != BootFontImageLength)) {
                    Status = EIO;
                }                    
            } else {
                Status = ENOMEM;
            }

            BlClose(FileId);
        }  

        if (Image && (ESUCCESS == Status)) {
            SetupLoaderBlock->BootFontFile = Image;
            SetupLoaderBlock->BootFontFileLength = BootFontImageLength;
        }
    }

    return Status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\da\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=setupldr

!IF "$(BUILD_DEBUG_LOADER)" != ""
DBG_LDR=_dbg
!ELSE
DBG_LDR=
!ENDIF

!include $(PROJECT_ROOT)\boot\loader$(DBG_LDR).inc

TARGETNAME=setupldr
TARGETPATH=obj
TARGETTYPE=LIBRARY


INCLUDES=\
    $(PROJECT_ROOT)\boot\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\ntos\config;\
    $(PROJECT_ROOT)\ntos\nthals;\
    $(PROJECT_ROOT)\fs\fastfat;\
    $(PROJECT_ROOT)\fs\udfs;\
    ..;\
    $(O)

!IF 0
NOTE : To force CD/DVD boot while starting setupldr from harddisk use
       FORCE_CD_BOOT
C_DEFINES=$(C_DEFINES) -DFORCE_CD_BOOT
!ENDIF

SOURCES=..\arcdisp.c       \
        ..\config.c        \
        ..\decomp.c        \
        ..\oemdisk.c       \
        ..\setup.c         \
        $(O)\msgs.mc       \
        ..\setupldr.rc
        
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
NTTARGETFILE0=$(O)\msgs.mc

!IF $(386)
MC_FLAGS=-A
!ENDIF

UMRES=$(O)\setupldr.res
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\daytona_dbg\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\fi\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\el\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\setupldr.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    setupldr.h

Abstract:

    Common header file for the setupldr module

Author:

    John Vert (jvert) 6-Oct-1993

Environment:

    ARC environment

Revision History:

--*/
#include "bldr.h"
#include "haldtect.h"
#include "setupblk.h"
#include "msgs.h"
#include "stdio.h"
#include "stdarg.h"


//
// OEM source device types
//
#define SL_OEM_SOURCE_DEVICE_TYPE_LOCAL         0x00008000
#define SL_OEM_SOURCE_DEVICE_TYPE_REMOVABLE     0x00000001
#define SL_OEM_SOURCE_DEVICE_TYPE_FIXED         0x00000002
#define SL_OEM_SOURCE_DEVICE_TYPE_PREINSTALL    0x10000000
#define SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE    0x20000000
#define SL_OEM_SOURCE_DEVICE_TYPE_VIRTUAL       0x40000000
#define SL_OEM_SOURCE_DEVICE_TYPE_REMOTE        0x80000000

//
// OEM source device media states
//
#define SL_OEM_SOURCE_MEDIA_ABSENT          0x00000001
#define SL_OEM_SOURCE_MEDIA_NO_DRIVERS      0x00000002
#define SL_OEM_SOURCE_MEDIA_HAS_MSD         0x00000004
#define SL_OEM_SOURCE_MEDIA_HAS_HAL         0x00000008
#define SL_OEM_SOURCE_MEDIA_HAS_DEFAULT     0x20000000
#define SL_OEM_SOURCE_MEDIA_HAS_DRIVERS     0x40000000
#define SL_OEM_SOURCE_MEDIA_PRESENT         0x80000000

//
// OEM source device processing states
//
#define SL_OEM_SOURCE_DEVICE_NOT_PROCESSED  0x00000000
#define SL_OEM_SOURCE_DEVICE_PROCESSED      0x00000001
#define SL_OEM_SOURCE_DEVICE_SKIPPED        0x00000002
#define SL_OEM_SOURCE_DEVICE_SCANNED        0x00000004
#define SL_OEM_SOURCE_DEVICE_HAL_LOADED     0x00000008
#define SL_OEM_SOURCE_DEVICE_MSD_LOADED     0x00000010
#define SL_OEM_SOURCE_DEVICE_DRIVERS_LOADED 0x40000000
#define SL_OEM_SOURCE_DEVICE_PROCESSING     0x80000000

typedef struct _OEM_SOURCE_DEVICE {
    CHAR    ArcDeviceName[128];
    ULONG   DeviceType;
    ULONG   MediaType;
    ULONG   DeviceState;
    ULONG   DeviceId;
    PVOID   InfHandle;
    PCSTR   DriverDir;
    struct _OEM_SOURCE_DEVICE *Next;   
} OEM_SOURCE_DEVICE, *POEM_SOURCE_DEVICE;


#define SL_OEM_SOURCE_DEVICE_TYPE(DevicePtr, Type)          \
            ((DevicePtr)->DeviceType & (Type))
            
#define SL_OEM_SET_SOURCE_DEVICE_TYPE(DevicePtr, Type)      \
            ((DevicePtr)->DeviceType = (Type))
            
#define SL_OEM_SOURCE_MEDIA_TYPE(DevicePtr, Type)           \
            ((DevicePtr)->MediaType & (Type))

#define SL_OEM_SET_SOURCE_MEDIA_TYPE(DevicePtr, Type)       \
            ((DevicePtr)->MediaType = (Type))

#define SL_OEM_SOURCE_DEVICE_STATE(DevicePtr, Type)         \
            ((DevicePtr)->DeviceState & (Type))

#define SL_OEM_SET_SOURCE_DEVICE_STATE(DevicePtr, Type)     \
            ((DevicePtr)->DeviceState = (Type))

ARC_STATUS
SlInitOemSourceDevices(
    IN OUT POEM_SOURCE_DEVICE *OemSourceDevices,
    IN OUT POEM_SOURCE_DEVICE *DefaultSourceDevice
    );

//
//
// Functions for managing the display
//
//

VOID
SlSetCurrentAttribute(
    IN UCHAR Attribute
    );

ARC_STATUS
SlWriteString(
    IN _PTUCHAR s
    );

ARC_STATUS
SlPositionCursor(
    IN unsigned x,
    IN unsigned y
    );

VOID
SlGetCursorPosition(
    OUT unsigned *x,
    OUT unsigned *y
    );

ARC_STATUS
SlClearClientArea(
    VOID
    );

ARC_STATUS
SlClearToEol(
    VOID
    );

VOID
SlInitDisplay(
    VOID
    );

VOID
SlWriteHeaderText(
    IN ULONG MsgId
    );

VOID
SlSetStatusAttribute(
    IN UCHAR Attribute
    );

BOOLEAN
SlGetStatusBarStatus(
    VOID
    );

VOID
SlEnableStatusBar(
    IN  BOOLEAN Enable
    );

VOID
SlWriteStatusText(
    IN PTCHAR Text
    );

VOID
SlGetStatusText(
    OUT PTCHAR Text
    );

VOID
SlClearDisplay(
    VOID
    );

VOID
SlPrint(
    IN PTCHAR FormatString,
    ...
    );

VOID
SlConfirmExit(
    VOID
    );


BOOLEAN
SlPromptForDisk(
    IN PTCHAR  DiskName,
    IN BOOLEAN IsCancellable
    );

BOOLEAN
SlGetDisk(
    IN PCHAR Filename
    );

//
// Menuing support
//
typedef struct _SL_MENU {
    ULONG ItemCount;
    ULONG Width;
    LIST_ENTRY ItemListHead;
} SL_MENU, *PSL_MENU;

typedef struct _SL_MENUITEM {
    LIST_ENTRY ListEntry;
    PTCHAR Text;
    PVOID Data;
    ULONG Attributes;
} SL_MENUITEM, *PSL_MENUITEM;

PSL_MENU
SlCreateMenu(
    VOID
    );

ULONG
SlAddMenuItem(
    PSL_MENU Menu,
    PTCHAR Text,
    PVOID Data,
    ULONG Attributes
    );

PVOID
SlGetMenuItem(
    IN PSL_MENU Menu,
    IN ULONG Item
    );

ULONG
SlDisplayMenu(
    IN ULONG HeaderId,
    IN PSL_MENU Menu,
    IN OUT PULONG Selection
    );

BOOLEAN
SlGetMenuItemIndex(
    IN PSL_MENU Menu,
    IN PTCHAR Text,
    OUT PULONG Index
    );

//
// Bullet character and macro to make a beep at the console
//
#ifndef EFI
#define BULLET "*"
#define BEEP { ULONG c; ArcWrite(ARC_CONSOLE_OUTPUT,"",1,&c); }

#if 0
#define BULLET ""
#define BEEP HWCURSOR(0x80000000,0xe07);     // int 10 func e, char 7
#endif
#endif

//
// Character attributes used for various purposes.
//

UCHAR
SlGetDefaultAttr(
  VOID
  );  

UCHAR
SlGetDefaultInvAttr(
  VOID
  );  


#define ATT_FG_BLACK        0
#define ATT_FG_RED          1
#define ATT_FG_GREEN        2
#define ATT_FG_YELLOW       3
#define ATT_FG_BLUE         4
#define ATT_FG_MAGENTA      5
#define ATT_FG_CYAN         6
#define ATT_FG_WHITE        7

#define ATT_BG_BLACK       (ATT_FG_BLACK   << 4)
#define ATT_BG_BLUE        (ATT_FG_BLUE    << 4)
#define ATT_BG_GREEN       (ATT_FG_GREEN   << 4)
#define ATT_BG_CYAN        (ATT_FG_CYAN    << 4)
#define ATT_BG_RED         (ATT_FG_RED     << 4)
#define ATT_BG_MAGENTA     (ATT_FG_MAGENTA << 4)
#define ATT_BG_YELLOW      (ATT_FG_YELLOW  << 4)
#define ATT_BG_WHITE       (ATT_FG_WHITE   << 4)

#define ATT_FG_INTENSE      8
#define ATT_BG_INTENSE     (ATT_FG_INTENSE << 4)

#define DEFATT    SlGetDefaultAttr()
#define INVATT    SlGetDefaultInvAttr()

#define DEFIATT   (ATT_FG_WHITE | ATT_BG_BLUE | ATT_FG_INTENSE)
// intense red on blue doesn't show up on all monitors.
//#define DEFERRATT (ATT_FG_RED   | ATT_BG_BLUE | ATT_FG_INTENSE)
#define DEFERRATT DEFATT
#define DEFSTATTR (ATT_FG_BLACK | ATT_BG_WHITE)
#define DEFDLGATT (ATT_FG_RED   | ATT_BG_WHITE)


//
// Function to flush keyboard buffer
//

VOID
SlFlushConsoleBuffer(
    VOID
    );


//
// Function to retrieve a keystroke
//

ULONG
SlGetChar(
    VOID
    );


//
// Virtualized contants for various keystrokes
//
#define ASCI_BS         8
#define ASCI_CR         13
#define ASCI_LF         10
#define ASCI_ESC        27
#define SL_KEY_UP       0x00010000
#define SL_KEY_DOWN     0x00020000
#define SL_KEY_HOME     0x00030000
#define SL_KEY_END      0x00040000
#define SL_KEY_PAGEUP   0x00050000
#define SL_KEY_PAGEDOWN 0x00060000
#define SL_KEY_F1       0x01000000
#define SL_KEY_F2       0x02000000
#define SL_KEY_F3       0x03000000
#define SL_KEY_F5       0x05000000
#define SL_KEY_F6       0x06000000
#define SL_KEY_F7       0x07000000
#define SL_KEY_F8       0x08000000
#define SL_KEY_F9       0x09000000
#define SL_KEY_F10      0x0A000000
#define SL_KEY_F11      0x0B000000
#define SL_KEY_F12      0x0C000000


//
// Standard error handling functions
//

extern TCHAR MessageBuffer[1024];

VOID
SlFriendlyError(
    IN ULONG uStatus,
    IN PCHAR pchBadFile,
    IN ULONG uLine,
    IN PCHAR pchCodeFile
    );

ULONG
SlDisplayMessageBox(
    IN ULONG MessageId,
    ...
    );

VOID
SlGenericMessageBox(
    IN     ULONG   MessageId, OPTIONAL
    IN     va_list *args,     OPTIONAL
    IN     PTCHAR  Message,   OPTIONAL
    IN OUT PULONG  xLeft,     OPTIONAL
    IN OUT PULONG  yTop,      OPTIONAL
    OUT    PULONG  yBottom,   OPTIONAL
    IN     BOOLEAN bCenterMsg
    );

VOID
SlMessageBox(
    IN ULONG MessageId,
    ...
    );

VOID
SlFatalError(
    IN ULONG MessageId,
    ...
    );

//
// Routines for parsing the setupldr.ini file
//

#define SIF_FILENAME_INDEX 0

extern PVOID InfFile;
extern PVOID WinntSifHandle;

ARC_STATUS
SlInitIniFile(
   IN  PCHAR   DevicePath,
   IN  ULONG   DeviceId,
   IN  PCHAR   INFFile,
   OUT PVOID  *pINFHandle,
   OUT PVOID  *pINFBuffer OPTIONAL,
   OUT PULONG  INFBufferSize OPTIONAL,
   OUT PULONG  ErrorLine
   );

PCHAR
SlGetIniValue(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PCHAR KeyName,
    IN PCHAR Default
    );

PCHAR
SlGetKeyName(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );

ULONG
SlGetSectionKeyOrdinal(
    IN  PVOID INFHandle,
    IN  PCHAR SectionName,
    IN  PCHAR Key
    );

PCHAR
SlGetSectionKeyIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key,
   IN ULONG ValueIndex
   );

PCHAR
SlCopyStringA(
    IN PCSTR String
    );

PTCHAR
SlCopyString(
    IN PTCHAR String
    );


PCHAR
SlGetSectionLineIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN ULONG LineIndex,
   IN ULONG ValueIndex
   );

ULONG
SlCountLinesInSection(
    IN PVOID INFHandle,
    IN PCHAR SectionName
    );

BOOLEAN
SpSearchINFSection (
   IN PVOID INFHandle,
   IN PCHAR SectionName
   );

PCHAR
SlSearchSection(
    IN PCHAR SectionName,
    IN PCHAR TargetName
    );

//
// functions for querying the ARC configuration tree
//
typedef
BOOLEAN
(*PNODE_CALLBACK)(
    IN PCONFIGURATION_COMPONENT_DATA FoundComponent
    );

BOOLEAN
SlSearchConfigTree(
    IN PCONFIGURATION_COMPONENT_DATA Node,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN ULONG Key,
    IN PNODE_CALLBACK CallbackRoutine
    );

BOOLEAN
SlFindFloppy(
    IN ULONG FloppyNumber,
    OUT PCHAR ArcName
    );

//
// Routines for detecting various hardware
//
VOID
SlDetectScsi(
    IN PSETUP_LOADER_BLOCK SetupBlock
    );

VOID
SlDetectVideo(
    IN PSETUP_LOADER_BLOCK SetupBlock
    );

//
// Routines for dealing with OEM disks.
//
extern BOOLEAN PromptOemHal;
extern BOOLEAN PromptOemScsi;
extern BOOLEAN PromptOemVideo;


//
// Variable indicating whether we are booting into
// WinPE (aka MiniNT) or not
//
extern BOOLEAN WinPEBoot;

typedef struct _OEMSCSIINFO {

    struct _OEMSCSIINFO *Next;

    //
    // Address where the SCSI driver was loaded
    //
    PVOID ScsiBase;

    //
    // Name of the SCSI driver
    //
    PCHAR ScsiName;

} OEMSCSIINFO, *POEMSCSIINFO;

VOID
SlPromptOemVideo(
    IN POEM_SOURCE_DEVICE VideoSourceDevice,
    IN BOOLEAN AllowUserSelection,
    OUT PVOID *VideoBase,
    OUT PCHAR *VideoName
    );

VOID
SlPromptOemHal(
    IN POEM_SOURCE_DEVICE HalSourceDevice,
    IN BOOLEAN AllowUserSelection,
    OUT PVOID *HalBase,
    OUT PCHAR *ImageName    
    );


VOID
SlPromptOemScsi(
    IN POEM_SOURCE_DEVICE ScsiSourceDevice,
    IN BOOLEAN AllowUserSelection,
    OUT POEMSCSIINFO *pOemScsiInfo
    );

BOOLEAN
SlLoadOemScsiDriversUnattended(
    IN  POEM_SOURCE_DEVICE  OemSourceDevice,
    IN  PVOID               InfHandle,
    IN  PCHAR               ParamsSectionName,
    IN  PCHAR               RootDirKeyName,
    IN  PCHAR               BootDriversKeyName,
    IN  POEMSCSIINFO*       ScsiInfo,
    OUT PPNP_HARDWARE_ID*   HardwareIdDatabase    
    );    


#if defined(_X86_) || defined(_IA64_)
VOID
BlInitializeTerminal(
    VOID
    );
#endif


//
// Routine to find the ARC name of a floppy
//
BOOLEAN
SlpFindFloppy(
    IN ULONG Number,
    OUT PCHAR ArcName
    );

//
// Are all the floppies only removable ATAPI super floppies
//
BOOLEAN
SlpIsOnlySuperFloppy(
    void
    );

//
// Enums for controlling setupldr process
//
typedef enum _SETUP_TYPE {
    SetupInteractive,
    SetupRepair,
    SetupCustom,
    SetupUpgrade,
    SetupExpress
} SETUP_TYPE;

typedef enum _MEDIA_TYPE {
    MediaInteractive,
    MediaFloppy,
    MediaCdRom,
    MediaDisk
} MEDIA_TYPE;

//
// Enum for status of inserting a new SCSI device
//
typedef enum _SCSI_INSERT_STATUS {
    ScsiInsertError,
    ScsiInsertNewEntry,
    ScsiInsertExisting
} SCSI_INSERT_STATUS;

//
// Routine to insert a DETECTED_DEVICE into its
// correct position in the ScsiDevices linked list.
//
SCSI_INSERT_STATUS
SlInsertScsiDevice(
    IN  ULONG Ordinal,
    OUT PDETECTED_DEVICE *pScsiDevice
    );

BOOLEAN
SlRemoveInboxDriver(
  IN PCHAR DriverToRemove
  );

PDETECTED_DEVICE
SlCheckForInboxDriver(
  IN PCHAR DriverToCheck
  );

BOOLEAN
SlConfirmInboxDriverReplacement(
  IN PTCHAR DriverName,
  IN PTCHAR AdditionalInfo
  );

typedef enum _VERSION_COMP_RESULT {
  VersionError,
  VersionOemNew,
  VersionInboxNew,
  VersionSame
} VERSION_COMP_RESULT;  


VERSION_COMP_RESULT
SlCompareDriverVersion(
  IN ULONG InboxDeviceId,
  IN PDETECTED_DEVICE InboxDriver,
  IN ULONG OemDeviceId,
  IN PDETECTED_DEVICE OemDriver
  );

//
// Variables dealing with pre-installation.
//

typedef struct _PREINSTALL_DRIVER_INFO {

    struct _PREINSTALL_DRIVER_INFO *Next;

    //
    // String that describes the driver to preinstall
    //
    PTCHAR DriverDescription;

    //
    // Name of the SCSI driver
    //
    BOOLEAN OemDriver;

} PREINSTALL_DRIVER_INFO, *PPREINSTALL_DRIVER_INFO;



extern BOOLEAN PreInstall;
extern PTCHAR  ComputerType;
extern BOOLEAN OemHal;
// extern PCHAR   OemBootPath;
extern PPREINSTALL_DRIVER_INFO PreinstallDriverList;

PCHAR
SlPreInstallGetComponentName(
    IN PVOID    Inf,
    IN PCHAR    SectionName,
    IN PTCHAR   TargetName
    );

ARC_STATUS
SlLoadSection(
    IN PVOID Inf,
    IN PCSTR SectionName,
    IN BOOLEAN IsScsiSection,
    IN BOOLEAN AppendLoadSuffix,
    IN OUT PULONG StartingIndexInsert
    );    

#define WINPE_AUTOBOOT_FILENAME     "$WINPE$.$$$"

BOOLEAN
SlIsWinPEAutoBoot(
    IN PSTR LoaderDeviceName
    );

ARC_STATUS
SlGetWinPEStartupParams(
    IN PSTR DeviceName,
    IN PSTR StartupDirectory
    );

ARC_STATUS
SlLoadWinPESection(
    IN  POEM_SOURCE_DEVICE OemSourceDevice,
    IN  PVOID   OemInfHandle,        
    IN  PCSTR   OemSectionName,
    IN  PVOID   InboxInfHandle,
    IN  PCSTR   InboxSectionName,
    IN  BOOLEAN IsScsiSection,
    IN  POEMSCSIINFO*       ScsiInfo,           OPTIONAL
    OUT PPNP_HARDWARE_ID*   HardwareIdDatabase  OPTIONAL
    );

ARC_STATUS
SlLoadOemScsiDriversFromOemSources(
    IN POEM_SOURCE_DEVICE OemSourceDevices,
    IN OUT PPNP_HARDWARE_ID *HardwareIds,
    OUT POEMSCSIINFO *OemScsiInfo
    );   

ARC_STATUS
SlInitVirtualOemSourceDevices(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    IN POEM_SOURCE_DEVICE OemSourceDevices
    );
    

#if defined(ARCI386)
BOOLEAN
SlDetectSifPromVersion(
    IN PSETUP_LOADER_BLOCK SetupBlock
    );
#endif

#define VGA_DRIVER_FILENAME "vga.sys"
#define VIDEO_DEVICE_NAME   "VGA"

extern ULONG BootFontImageLength;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\es\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\fr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\ger\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\hu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\it\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\jpn\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\kor\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\nl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\no\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\pl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\psu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\pt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\ia64\ia64dtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    detecthw.c

Abstract:

    Routines for determining which drivers/HAL need to be loaded.

Author:

    John Vert (jvert) 20-Oct-1993

Revision History:

--*/
#include "setupldr.h"


//
// NOTE: SlHalDetect() has been moved to boot\lib\i386\haldtect.c
//


VOID
SlDetectScsi(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )

/*++

Routine Description:

    SCSI detection routine for x86 machines.

Arguments:

    SetupBlock - Supplies the Setup loader block

Return Value:

    None.

--*/

{
    PVOID SifHandle;
    PCHAR p;
    ULONG LineCount,u;
    PDETECTED_DEVICE ScsiDevice;
    ULONG Ordinal;
    PCHAR ScsiFileName;
    PTCHAR ScsiDescription;
    SCSI_INSERT_STATUS sis;

    extern BOOLEAN LoadScsiMiniports;

    //
    // If winnt.sif wasn't loaded, assume it's not a winnt setup
    // and therefore not unattended setup, and we detect no scsi
    // in this case on x86.
    //
    if(WinntSifHandle == NULL) {
        return;
    } else {
        SifHandle = WinntSifHandle;
    }

    //
    // If it's a floppyless setup, then the default is to load all
    // known scsi miniports. If it's not a floppyless setup,
    // the default is to load no miniports.
    //
    p = SlGetSectionKeyIndex(SifHandle,"Data","Floppyless",0);
    if(p && (*p != '0')) {

        //
        // Even if no miniport drivers are loaded, we want to indicate that
        // we "detected scsi".
        //
        SetupBlock->ScalarValues.LoadedScsi = 1;

        LineCount = SlCountLinesInSection(SifHandle,"DetectedMassStorage");
        if(LineCount == (ULONG)(-1)) {
            //
            // Section does not exist -- load all known miniports.
            // Setting this flag will cause all known miniports to be loaded
            // (see ..\setup.c).
            //
            LoadScsiMiniports = TRUE;
        } else {

            for(u=0; u<LineCount; u++) {

                if(p = SlGetSectionLineIndex(SifHandle,"DetectedMassStorage",u,0)) {
                    //
                    // Find this adapter's ordinal within the Scsi.Load section of txtsetup.sif
                    //
                    Ordinal = SlGetSectionKeyOrdinal(InfFile, "Scsi.Load", p);
                    if(Ordinal == (ULONG)-1) {
                        continue;
                    }

                    //
                    // Find the driver filename
                    //
                    ScsiFileName = SlGetSectionKeyIndex(InfFile,
                                                        "Scsi.Load",
                                                        p,
                                                        SIF_FILENAME_INDEX);
                    if(!ScsiFileName) {
                        continue;
                    }

                    //
                    // Create a new detected device entry.
                    //
                    if((sis = SlInsertScsiDevice(Ordinal, &ScsiDevice)) == ScsiInsertError) {
                        SlFriendlyError(ENOMEM, "SCSI detection", 0, NULL);
                        return;
                    }

                    if(sis == ScsiInsertExisting) {
#if DBG
                        //
                        // Sanity check to make sure we're talking about the same driver
                        //
                        if(_stricmp(ScsiDevice->BaseDllName, ScsiFileName)) {
                            SlError(400);
                            return;
                        }
#endif
                    } else {
                        //
                        // Find the driver description
                        //
#ifdef UNICODE
                        ScsiDescription = SlGetIniValueW(
                                                    InfFile,
                                                    "SCSI",
                                                    p,
                                                    SlCopyStringAW(p));
#else
                        ScsiDescription = (PTCHAR)SlGetIniValue(
                                                    InfFile,
                                                    "SCSI",
                                                    p,
                                                    p);
#endif

                        ScsiDevice->IdString = p;
                        ScsiDevice->Description = ScsiDescription;
                        ScsiDevice->ThirdPartyOptionSelected = FALSE;
                        ScsiDevice->FileTypeBits = 0;
                        ScsiDevice->Files = NULL;
                        ScsiDevice->BaseDllName = ScsiFileName;
                    }
                }
            }
        }
    }
}


VOID
SlDetectVideo(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )

/*++

Routine Description:

    Video detection routine for x86 machines.

    Currently, no video detection is done on x86 machines, this just fills
    in the appropriate fields in the setuploaderblock that say "VGA"

Arguments:

    SetupBlock - Supplies the Setup loader block

Return Value:

    None.

--*/

{

    SetupBlock->VideoDevice.Next = NULL;
    SetupBlock->VideoDevice.IdString = SlCopyStringA(VIDEO_DEVICE_NAME);
    SetupBlock->VideoDevice.ThirdPartyOptionSelected = FALSE;
    SetupBlock->VideoDevice.FileTypeBits = 0;
    SetupBlock->VideoDevice.Files = NULL;
    SetupBlock->VideoDevice.BaseDllName = NULL;
    SetupBlock->Monitor = NULL;
    SetupBlock->MonitorId = NULL;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\i386\initx86.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initx86.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC setupldr

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

--*/
#include "setupldr.h"
#include "bldrx86.h"
#include "msgs.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <netboot.h>

ARC_STATUS
SlInit(
    IN ULONG Argc,
    IN PCHAR Argv[],
    IN PCHAR Envp[]
    );

BOOLEAN
BlDetectHardware(
    IN ULONG DriveId,
    IN PCHAR LoadOptions
    );


VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly running NTDETECT, then
    calls to the common setupldr.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc;
    PCHAR Argv[10];
    CHAR SetupLoadFileName[129];
    CHAR LoadOptions[100];
    ARC_STATUS Status;
    ULONG DriveId;
    ULONGLONG NetRebootParameter;
    BOOLEAN UseCommandConsole = FALSE;
    BOOLEAN RollbackEnabled = FALSE;
    extern BOOLEAN FwDescriptorsValid;
    extern BOOLEAN TryASRViaNetwork;


    if (BlBootingFromNet) {

        //
        // Go retrieve all the information passed to us from StartROM.
        // Once we have that, we'll call BlGetHeadlessRestartBlock and
        // get all the port settings that StartROM sent us.  These,
        // in turn, will then be used in BlInitializeTerminal(), which
        // we'are about to call.
        //
        NetGetRebootParameters(
            &NetRebootParameter,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            FALSE
            );

        if (NetRebootParameter == NET_REBOOT_COMMAND_CONSOLE_ONLY) {
            UseCommandConsole = TRUE;
        }

        if (NetRebootParameter == NET_REBOOT_ASR) {
            TryASRViaNetwork = TRUE;            
        }
    }

    //
    // Initialize any dumb terminal that may be connected.
    //
    BlInitializeHeadlessPort();

    //
    // Open the boot partition so we can load NTDETECT off it.
    //
    Status = ArcOpen(PartitionName, ArcOpenReadOnly, &DriveId);
    if (Status != ESUCCESS) {
        BlPrint(BlFindMessage(SL_DRIVE_ERROR),PartitionName);
        return;
    }

    if (_stricmp( (PCHAR)(0x7c03), "cmdcons" ) == 0) {
        UseCommandConsole = TRUE;
    } else if (strcmp ((PCHAR)(0x7c03), "undo") == 0) {
        //
        // NTLDR wrote the exact text "undo" (including the nul
        // terminator). We know the address this text was written
        // to -- 0x7C03. If we find the token, then enable rollback
        // mode. This triggers an argument to be passed to textmode
        // setup, plus a different boot message.
        //

        RollbackEnabled = TRUE;
    }

    //
    // Initialize dbcs font and display.
    //
    TextGrInitialize(DriveId, &BootFontImageLength);

    if (UseCommandConsole) {
        BlPrint(BlFindMessage(SL_NTDETECT_CMDCONS));
    } else if (RollbackEnabled) {
        BlPrint(BlFindMessage(SL_NTDETECT_ROLLBACK));
    } else {
        BlPrint(BlFindMessage(SL_NTDETECT_MSG));
    }

    //
    // See if we need to send /noirqscan to ntdetect
    //
    Argv[0] = NULL;
    if(WinntSifHandle != NULL) {
        Argv[0] = SlGetSectionKeyIndex(WinntSifHandle,"SetupData","OsLoadOptionsVar",0);
    }

    //
    // detect HAL here.
    //
    if (!BlDetectHardware(DriveId, Argv[0])) {
        BlPrint(BlFindMessage(SL_NTDETECT_FAILURE));
        return;
    }

    FwDescriptorsValid = FALSE;
    BlKernelChecked=TRUE;
    //
    // NOTE:
    // If you are testing the changes on read only Jaz drive uncomment this line
    // and put the correct value for rdisk(?). You also need to make sure
    // that SCSI BIOS emulation for the jaz drive is turned on for this trick
    // to work.
    //

    //strcpy(PartitionName, "multi(0)disk(0)rdisk(1)partition(1)");

    //
    // Close the drive, the loader will re-open it.
    //

    ArcClose(DriveId);

    //
    // Create arguments, call off to setupldr
    //
    if (BlBootingFromNet) {
        strcpy(SetupLoadFileName, PartitionName);
        strcat(SetupLoadFileName, "\\i386\\SETUPLDR");
    } else {
        strcpy(SetupLoadFileName, PartitionName);
        strcat(SetupLoadFileName, "\\SETUPLDR");
    }
    Argv[0] = SetupLoadFileName;
    Argc = 1;

    if (UseCommandConsole) {
        Argv[Argc++] = "ImageType=cmdcons";
    }

    if (RollbackEnabled) {
        //
        // Rollback is a special case where we know there can be no
        // OsLoadOptions.
        //

        Argv[Argc++] = "ImageType=rollback";
    }


    Status = SlInit( Argc, Argv, NULL );

    //
    // We should never return here, something
    // horrible has happened.
    //

    while (TRUE) {
        if (BlTerminalHandleLoaderFailure()) {
            ArcRestart();
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\ru\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\sv\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\ia64\initia64.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initia64.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC setupldr

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

    Allen Kay (akay) 19-Mar-1998

--*/
#include "setupldr.h"
#include "bldria64.h"
#include "msgs.h"
#include <netboot.h>
#include "parsebnvr.h"

#if defined(ELTORITO)
extern BOOLEAN ElToritoCDBoot;
#endif

UCHAR MyBuffer[SECTOR_SIZE+32];

ARC_STATUS
SlInit(
    IN ULONG Argc,
    IN PCHAR Argv[],
    IN PCHAR Envp[]
    );

BOOLEAN
BlDetectHardware(
    IN ULONG DriveId,
    IN PCHAR LoadOptions
    );

VOID
KiProcessorWorkAround(
ULONG Arg1
);

ARC_STATUS
BlGetEfiBootOptions(
    OUT PUCHAR Argv0String OPTIONAL,
    OUT PUCHAR SystemPartition OPTIONAL,
    OUT PUCHAR OsLoaderFilename OPTIONAL,
    OUT PUCHAR OsLoadPartition OPTIONAL,
    OUT PUCHAR OsLoadFilename OPTIONAL,
    OUT PUCHAR FullKernelPath OPTIONAL,
    OUT PUCHAR OsLoadOptions OPTIONAL
    );


VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly running NTDETECT, then
    calls to the common setupldr.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc = 0;
    PCHAR Argv[10];
    CHAR SetupLoadFileName[129], szOSLoadOptions[100], szOSLoadFilename[129], szOSLoadPartition[129];
    CHAR SystemPartition[129];
    ARC_STATUS Status;

    SetupLoadFileName[0] = '\0';
    szOSLoadOptions[0] = '\0';
    szOSLoadFilename[0] = '\0';
    szOSLoadPartition[0] = '\0';


    //
    // Initialize any dumb terminal that may be connected.
    //
    BlInitializeHeadlessPort();

    if (!BlBootingFromNet) {
    
        //
        // Try to read the NVRAM first. This will fail if we were
        // boot from the EFI shell, in which case we need to read
        // boot.nvr.
        //
        Status = BlGetEfiBootOptions(
                    SetupLoadFileName,
                    NULL,
                    NULL,
                    szOSLoadPartition,
                    szOSLoadFilename,
                    NULL,
                    szOSLoadOptions
                    );
        if ( Status != ESUCCESS ) {
#if DBG
            BlPrint(TEXT("Couldn't get EFI boot options\r\n"));
#endif   
            //
            // It's expected that this fails if we're booting off of CDROM
            // since there isn't any windows information in the EFI cdrom boot
            // entry
            //
            if (ElToritoCDBoot ) { 
                strcpy(SetupLoadFileName, PartitionName);
                strcat(SetupLoadFileName, "\\setupldr.efi");                
                
                //
                // the code was setting these options on a CDBOOT, but I don't
                // think these options are at all necessary.
                //
//                strcpy(szOSLoadOptions, "OSLOADOPTIONS=WINNT32" );
//                strcpy(szOSLoadFilename, "OSLOADFILENAME=\\$WIN_NT$.~LS\\IA64"  );
//                strcpy(szOSLoadPartition, "OSLOADPARTITION=" );
//                strcat(szOSLoadPartition, PartitionName);

            } else { 
                //
                // uh-oh.  no information on this build. we either guess or
                // we have to bail out.  Let's guess.
                //
                strcpy(SetupLoadFileName, "multi(0)disk(0)rdisk(0)partition(1)\\setupldr.efi");
                strcpy(szOSLoadOptions, "OSLOADOPTIONS=WINNT32" );
                strcpy(szOSLoadFilename, "OSLOADFILENAME=\\$WIN_NT$.~LS\\IA64"  );
                strcpy(szOSLoadPartition, "OSLOADPARTITION=multi(0)disk(0)rdisk(0)partition(3)" );
            }               
        }
    } else {

#if DBG               
        BlPrint(TEXT("setting os load options for PXE boot\r\n"));
#endif

        strcpy(SetupLoadFileName, PartitionName);
        strcat(SetupLoadFileName, "\\ia64\\setupldr.efi");
               
    }

    //
    // detect HAL here.
    //

    //
    // Create arguments, call off to setupldr
    //
    Argv[Argc++]=SetupLoadFileName;

    //
    // A0 processor workarounds
    //
    KiProcessorWorkAround(0);

    _strlwr(PartitionName);

    
    if( strstr(PartitionName, "rdisk") || (BlBootingFromNet) ) {        
        Argv[Argc++] = szOSLoadOptions;
        Argv[Argc++] = szOSLoadFilename;
        Argv[Argc++] = szOSLoadPartition;
    }

    //
    // System partition is needed for automated WinPE boot
    //
    strcpy(SystemPartition, "systempartition=");
    strcat(SystemPartition, PartitionName);
    Argv[Argc++] = SystemPartition;

    Status = SlInit(Argc, Argv, NULL);

    //
    // We should never return here, something
    // horrible has happened.
    //
    while (TRUE) {
        if (BlTerminalHandleLoaderFailure()) {
            ArcRestart();
        }    
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\i386\x86dtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    detecthw.c

Abstract:

    Routines for determining which drivers/HAL need to be loaded.

Author:

    John Vert (jvert) 20-Oct-1993

Revision History:

--*/
#include "setupldr.h"


//
// NOTE: SlHalDetect() has been moved to boot\lib\i386\haldtect.c
//


VOID
SlDetectScsi(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )

/*++

Routine Description:

    SCSI detection routine for x86 machines.

Arguments:

    SetupBlock - Supplies the Setup loader block

Return Value:

    None.

--*/

{
    PVOID SifHandle;
    PCHAR p;
    ULONG LineCount,u;
    PDETECTED_DEVICE ScsiDevice;
    ULONG Ordinal;
    PCHAR ScsiFileName;
    PCHAR ScsiDescription;
    SCSI_INSERT_STATUS sis;

    extern BOOLEAN LoadScsiMiniports;

    //
    // If winnt.sif wasn't loaded, assume it's not a winnt setup
    // and therefore not unattended setup, and we detect no scsi
    // in this case on x86.
    //
    if(WinntSifHandle == NULL) {
        return;
    } else {
        SifHandle = WinntSifHandle;
    }

    //
    // If it's a floppyless setup, then the default is to load all
    // known scsi miniports. If it's not a floppyless setup,
    // the default is to load no miniports.
    //
    p = SlGetSectionKeyIndex(SifHandle,"Data","Floppyless",0);
    if(p && (*p != '0')) {

        //
        // Even if no miniport drivers are loaded, we want to indicate that
        // we "detected scsi".
        //
        SetupBlock->ScalarValues.LoadedScsi = 1;

        LineCount = SlCountLinesInSection(SifHandle,"DetectedMassStorage");
        if(LineCount == (ULONG)(-1)) {
            //
            // Section does not exist -- load all known miniports.
            // Setting this flag will cause all known miniports to be loaded
            // (see ..\setup.c).
            //
            LoadScsiMiniports = TRUE;
        } else {

            for(u=0; u<LineCount; u++) {

                if(p = SlGetSectionLineIndex(SifHandle,"DetectedMassStorage",u,0)) {
                    //
                    // Find this adapter's ordinal within the Scsi.Load section of txtsetup.sif
                    //
                    Ordinal = SlGetSectionKeyOrdinal(InfFile, "Scsi.Load", p);
                    if(Ordinal == (ULONG)-1) {
                        continue;
                    }

                    //
                    // Find the driver filename
                    //
                    ScsiFileName = SlGetSectionKeyIndex(InfFile,
                                                        "Scsi.Load",
                                                        p,
                                                        SIF_FILENAME_INDEX);
                    if(!ScsiFileName) {
                        continue;
                    }

                    //
                    // Create a new detected device entry.
                    //
                    if((sis = SlInsertScsiDevice(Ordinal, &ScsiDevice)) == ScsiInsertError) {
                        SlFriendlyError(ENOMEM, "SCSI detection", 0, NULL);
                        return;
                    }

                    if(sis == ScsiInsertExisting) {
#if DBG
                        //
                        // Sanity check to make sure we're talking about the same driver
                        //
                        if(_stricmp(ScsiDevice->BaseDllName, ScsiFileName)) {
                            SlError(400);
                            return;
                        }
#endif
                    } else {
                        //
                        // Find the driver description
                        //
                        ScsiDescription = SlGetIniValue(InfFile,
                                                        "SCSI",
                                                        p,
                                                        p);

                        ScsiDevice->IdString = p;
                        ScsiDevice->Description = ScsiDescription;
                        ScsiDevice->ThirdPartyOptionSelected = FALSE;
                        ScsiDevice->FileTypeBits = 0;
                        ScsiDevice->Files = NULL;
                        ScsiDevice->BaseDllName = ScsiFileName;
                    }
                }
            }
        }
    }
}


VOID
SlDetectVideo(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )

/*++

Routine Description:

    Video detection routine for x86 machines.

    Currently, no video detection is done on x86 machines, this just fills
    in the appropriate fields in the setuploaderblock that say "VGA"

Arguments:

    SetupBlock - Supplies the Setup loader block

Return Value:

    None.

--*/

{

    SetupBlock->VideoDevice.Next = NULL;
    SetupBlock->VideoDevice.IdString = SlCopyString(VIDEO_DEVICE_NAME);
    SetupBlock->VideoDevice.ThirdPartyOptionSelected = FALSE;
    SetupBlock->VideoDevice.FileTypeBits = 0;
    SetupBlock->VideoDevice.Files = NULL;
    SetupBlock->VideoDevice.BaseDllName = NULL;
    SetupBlock->Monitor = NULL;
    SetupBlock->MonitorId = NULL;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\ia64\parsebnvr.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initia64.c

Abstract:

    Gets boot environment vars from c:\boot.nvr

    -- This will go away once we r/w the vars directly to/fro nvram

Author:

    Mudit Vats (v-muditv) 11-02-99

Revision History:

--*/
#ifndef _PARSEBNVR_
#define _PARSEBNVR_

#include "ntos.h"

VOID
BlGetBootVars(
    IN PCHAR szBootNVR, 
    IN ULONG nLengthBootNVR 
    );

PCHAR
BlSelectKernel(
    );

VOID
BlGetVarSystemPartition(
    OUT PCHAR szSystemPartition
    );

VOID
BlGetVarOsLoader(
    OUT PCHAR szOsLoader
    );

VOID
BlGetVarOsLoaderShort(
    OUT PCHAR szOsLoadFilenameShort
    );

VOID
BlGetVarOsLoadPartition(
    OUT PCHAR szOsLoadPartition
    );

VOID
BlGetVarOsLoadFilename(
    OUT PCHAR szOsLoadFilename
    );

VOID
BlGetVarLoadIdentifier(
    OUT PCHAR szLoadIdentifier
    );

VOID
BlGetVarOsLoadOptions(
    OUT PCHAR szLoadOptions
    );

VOID
BlGetVarCountdown(
    OUT PCHAR szCountdown
    );

VOID
BlGetVarAutoload(
    OUT PCHAR szAutoload
    );

VOID
BlGetVarLastKnownGood(
    OUT PCHAR szLastKnownGood
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\ia64\parsebnvr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initia64.c

Abstract:

    Gets boot environment vars from c:\boot.nvr

    -- This will go away once we r/w the vars directly to/fro nvram

Author:

    Mudit Vats (v-muditv) 11-02-99

Revision History:

--*/
#include "parsebnvr.h"
#include "stdio.h"
#include "string.h"

#define SYSTEMPARTITION     0
#define OSLOADER            1
#define OSLOADPARTITION     2
#define OSLOADFILENAME      3
#define LOADIDENTIFIER      4
#define OSLOADOPTIONS       5
#define COUNTDOWN           6
#define AUTOLOAD            7
#define LASTKNOWNGOOD       8

#define MAXBOOTVARS         9
#define MAXBOOTVARSIZE      1024

CHAR g_szBootVars[MAXBOOTVARS][MAXBOOTVARSIZE];

CHAR szSelectKernelString[MAXBOOTVARSIZE];


VOID
BlGetBootVars( 
    IN PCHAR szBootNVR, 
    IN ULONG nLengthBootNVR 
    )
/*++

Routine Description:

    Parses the boot.txt file and determines the fully-qualified name of
    the kernel to be booted.

Arguments:
    szBootNVR      - pointer "boot.nvr" image in memory

    nLengthBootNVR - lenghth, in bytes, of szBootNVR

Return Value:

    none

--*/
{
    ULONG i=0, j;
    ULONG nbootvar;

    if (*szBootNVR == '\0') {
        //
        // No boot.nvr file, so we boot the default.
        //
        strcpy( g_szBootVars[ SYSTEMPARTITION ],  "multi(0)disk(0)rdisk(0)partition(1)" );
        strcpy( g_szBootVars[ OSLOADER        ],  "multi(0)disk(0)rdisk(0)partition(1)\\setupldr.efi" );
        strcpy( g_szBootVars[ OSLOADPARTITION ],  "multi(0)disk(0)rdisk(0)partition(2)" );
        strcpy( g_szBootVars[ OSLOADFILENAME  ],  "\\$WIN_NT$.~LS\\IA64" );
        strcpy( g_szBootVars[ LOADIDENTIFIER  ],  "Windows 2000 Setup" );
        strcpy( g_szBootVars[ OSLOADOPTIONS   ],  "WINNT32" );
        strcpy( g_szBootVars[ COUNTDOWN       ], "10" );
        strcpy( g_szBootVars[ AUTOLOAD        ], "YES" );
        strcpy( g_szBootVars[ LASTKNOWNGOOD   ], "FALSE" );
    } else {
        //
        // Get the boot vars
        //
        // BOOTVAR    ::= =<VARVALUE>
        // <VARVALUE> ::= null | {;} | <VALUE>{;} | <VALUE>;<VARVALUE>
        // 
        for( nbootvar = SYSTEMPARTITION; nbootvar<=LASTKNOWNGOOD; nbootvar++ ) {

            // read to '='
            while( (szBootNVR[i] != '=') && (i<nLengthBootNVR) )
                i++;

            // read past '='
            i++;        
            j = 0;

            // get env var from '=' to CR or ';'
            while( (szBootNVR[i] != '\r') && (szBootNVR[i] != ';') && (i<nLengthBootNVR) )
                g_szBootVars[nbootvar][j++] = szBootNVR[i++];

            g_szBootVars[nbootvar][j++] = '\0';

            // if ';' read to CR
            if( szBootNVR[i] == ';' ) {
                while( (szBootNVR[i] != '\r') && (i<nLengthBootNVR) )
                    i++;
            }
        }
    }
}


PCHAR
BlSelectKernel( 
	)
/*++

Routine Description:

    Parses the boot.txt file and determines the fully-qualified name of
    the kernel to be booted.

Arguments:


Return Value:

    Pointer to the name of a kernel to boot.

--*/

{
    sprintf( szSelectKernelString, "%s%s", g_szBootVars[OSLOADPARTITION], g_szBootVars[OSLOADFILENAME] );
    return szSelectKernelString;
}


/*++

Routine Descriptions:

    The following are access functions to GET boot env vars

Arguments:

     PCHAR XXX - where the env var is copied to


Return Value:
    
--*/
VOID
BlGetVarSystemPartition(
    OUT PCHAR szSystemPartition
    )
{
    sprintf( szSystemPartition, "SYSTEMPARTITION=%s", g_szBootVars[SYSTEMPARTITION] );
}

VOID
BlGetVarOsLoader(
    OUT PCHAR szOsLoader
    )
{
    sprintf( szOsLoader, "OSLOADER=%s", g_szBootVars[OSLOADER] );
}

VOID
BlGetVarOsLoadPartition(
    OUT PCHAR szOsLoadPartition
    )
{
    sprintf( szOsLoadPartition, "OSLOADPARTITION=%s", g_szBootVars[OSLOADPARTITION] );
}

VOID
BlGetVarOsLoadFilename(
    OUT PCHAR szOsLoadFilename
    )
{
    sprintf( szOsLoadFilename, "OSLOADFILENAME=%s", g_szBootVars[OSLOADFILENAME] );
}

VOID
BlGetVarOsLoaderShort(
    OUT PCHAR szOsLoaderShort
    )
{
    sprintf( szOsLoaderShort, "%s", g_szBootVars[OSLOADER] );
}

VOID
BlGetVarLoadIdentifier(
    OUT PCHAR szLoadIdentifier
    )
{
    sprintf( szLoadIdentifier, "LOADIDENTIFIER=%s", g_szBootVars[LOADIDENTIFIER] );
}

VOID
BlGetVarOsLoadOptions(
    OUT PCHAR szLoadOptions
    )
{
    sprintf( szLoadOptions, "OSLOADOPTIONS=%s", g_szBootVars[OSLOADOPTIONS] );
}

VOID
BlGetVarCountdown(
    OUT PCHAR szCountdown
    )
{
    sprintf( szCountdown, "COUNTDOWN=%s", g_szBootVars[COUNTDOWN] );
}

VOID
BlGetVarAutoload(
    OUT PCHAR szAutoload
    )
{
    sprintf( szAutoload, "AUTOLOAD=%s", g_szBootVars[AUTOLOAD] );
}

VOID
BlGetVarLastKnownGood(
    OUT PCHAR szLastKnownGood
    )
{
    sprintf( szLastKnownGood, "LASTKNOWNGOOD=%s", g_szBootVars[LASTKNOWNGOOD] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\tst\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\setup\tr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\daytona.n12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\hdlscom1\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\hdlscom1.n12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\hdlscom2\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\hdlscom2.n12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\hdlstst1.n12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\hdlstst2.n12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\constant.h ===
/*--

    Module Name

        constant.h

    Author

        Thomas Parslow  (tomp)

--*/

//
// Debugging Level defines
//

#ifdef DEBUG0
#define DBG0(x)     x
#define DBG1(x)
#elif defined  DEBUG1
#define DBG0(x)     x
#define DBG1(x)     x
#else
#define DBG0(x)
#define DBG1(x)
#endif

#define WAITFOREVER while(1);
#define BUGCHECK    while(1);


#define ENTRIES_PER_PAGETABLE       1024
#define PAGE_SIZE                   0x1000
#define ENABLING                    0
#define RE_ENABLING                 1



//
// Define page-table-entry bit definitions
//
//     Dir       Table
//  ----------==========
//  00000000000000000000xxxxxxxxxxxx
//                           ::::::+--- Present    = 1 - Not Present = 0
//                           :::::+---- ReadWrite  = 1 - Read only   = 0
//                           ::::+----- UserAccess = 1 - Supervisor  = 0
//                           :::+------ Reserved
//                           ::+------- Reserved
//                           :+-------- Dirty      = 1 - Not written = 0
//                           +--------- Accessed   = 1 - No accessed = 0

#define  PAGE_SUPERVISOR     0x0000
#define  PAGE_READ_ONLY      0x0000
#define  PAGE_PRESENT        0x0001
#define  PAGE_NOT_PRESENT    0x0000
#define  PAGE_READ_WRITE     0x0002
#define  PAGE_USER_ACCESS    0x0004
#define  PAGE_PERSIST        0x0200 // Tells kernel maintain
//
//  Define RWSP (Read, Write, Supervisor, Present)
//

#define  PAGE_RWSP      0L | PAGE_READ_WRITE | PAGE_SUPERVISOR | PAGE_PRESENT
#define  PAGE_ROSP      0L | PAGE_READ_ONLY | PAGE_SUPERVISOR | PAGE_PRESENT
// Since the entire boot process occurs at ring 0, the only way we can
// protext areas that we don't want trashed is too mark them not present
#define  PAGE_NO_ACCESS    0L | PAGE_READ_ONLY  | PAGE_SUPERVISOR | PAGE_NOT_PRESENT


//
// Page-entry macros
//

#define PD_Entry(x)     (USHORT)((x)>>22) & 0x3ff
#define PT_Entry(x)     (USHORT)((x)>>12) & 0x3ff
#define PAGE_Count(x)     (USHORT)((x)/PAGE_SIZE) + (((x) % PAGE_SIZE) ? 1 : 0)
#define PhysToSeg(x)    (USHORT)((x) >> 4) & 0xffff
#define PhysToOff(x)    (USHORT)((x) & 0x0f)
#define MAKE_FP(p,a)    FP_SEG(p) = (USHORT)((a) >> 4) & 0xffff; FP_OFF(p) = (USHORT)((a) & 0x0f)
#define MAKE_FLAT_ADDRESS(fp) ( ((ULONG)FP_SEG(fp) * 16 ) +  (ULONG)FP_OFF(fp) )

//
// Machine type definitions.
// N.B.  All the constants defined here
//       must match the ones defined in ntos\inc\i386.h
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\a20.asm ===
;  NOTICE
;  This was taken from the os2 bios sources and was slightly modified to
;  enable the a20 line. There's still some work to do and much clean-up to
;  bring the file upto coding standards. I'll do this when time permits.
;  TomP


;* _EnableA20
;* Description:                                                               *
;*      This routine enables and disables the A20 address line, depending on  *
;*      the value in ax                                                       *
;*                                                                            *
;*      In general when in real mode we want the A20 line disabled,           *
;*      when in protected mode enabled. However if there is no high           *
;*      memory installed we can optimise out unnecessary switching            *
;*      of the A20 line. Unfortunately the PC/AT ROM does not allow           *
;*      us to completely decouple mode switching the 286 from gating          *
;*      the A20 line.                                                         *
;*                                                                            *
;*      In real mode we would want A20 enabled if we need to access           *
;*      high memory, for example in a device driver. We want it               *
;*      disabled while running arbitrary applications because they            *
;*      may rely on the 1 meg address wrap feature which having the           *
;*      A20 line off provides.                                                *
;*                                                                            *
;*      This code is largely duplicated from the PC/AT ROM BIOS.              *
;*      See Module "BIOS1" on page 5-155 of the PC/AT tech ref.               *
;*                                                                            *
;*      WARNING:                                                              *
;*                                                                            *
;*      The performance characteristics of these routines                     *
;*      are not well understood. There may be worst case                      *
;*      scenarios where the routine could take a relatively                   *
;*      long time to complete.                                                *
;*                                                                            *
;* Linkage:                                                                   *
;*      far call                                                              *
;*                                                                            *
;* Input:                                                                     *
;*                                                                            *
;* Exit:                                                                      *
;*      A20 line enabled/disabled                                             *
;*                                                                            *
;* Uses:                                                                      *
;*      ax                                                                    *
;*                                                                            *
;* Internal References:                                                       *
;*      empty_8042  --  waits for 8042 input buffer to drain                  *

.386p
include su.inc

IODelay macro
        jmp     $+2
        endm

extrn  _puts:near
extrn  _Empty_8042Failed:near


; Equates for cmos

CMOS_DATA       equ     71h             ; I/O word for cmos chip
SHUT_ADDR       equ     8fh             ; shutdown byte address in cmos
SHUT_CODE       equ     9               ; block copy return code we use


; equates for 8042
STATUS_PORT     equ     64h             ; 8042 com port
PORT_A          equ     60h             ; 8042 data port
BUF_FULL        equ     2               ; 8042 busy bit


SHUT_CMD        equ     0feh            ; RESET 286 command

MSW_VIRTUAL     equ     1               ; protected mode bit of MSW

MASTER_IMR      equ     21h             ; mask port for master 8259


;CONST   SEGMENT WORD USE16 PUBLIC 'CONST'
;CONST   ENDS

;_BSS   SEGMENT WORD USE16 PUBLIC 'BSS'
;_BSS   ENDS

;DGROUP  GROUP   CONST, _BSS, _DATA
;        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP


;++
;
;VOID
;EnableA20(
;    VOID
;    )
;
;Routine Description:
;
;    Enables the A20 line for any machine.  
;
;Arguments:
;
;    None
;
;Return Value:
;
;    None.
;
;    The A20 line is enabled.
;
;--
        public  _EnableA20

_EnableA20      proc    near

;            Check if empty_8042 has failed before
;            If so, skip this function.  This would occur
;            on legacy free systems.

         mov   di,offset DGROUP:_Empty_8042Failed
         cmp   byte ptr [di],1
         jz   EA2
         
;         cmp   byte ptr [di],0
        
        call    empty_8042              ; ensure 8042 input buffer empty
        jnz     EA2                     ; 8042 error return


;            Enable or disable the A20 line

        mov     al,0d1h                 ; 8042 cmd to write output port
        out     STATUS_PORT,al          ; send cmd to 8042
        call    empty_8042              ; wait for 8042 to accept cmd
        jnz     EA2                     ; 8042 error return
        mov     al,0dfh                 ; 8042 port data
        out     PORT_A,al               ; output port data to 8042
        call    empty_8042

;       We must wait for the a20 line to settle down, which (on an AT)
;       may not happen until up to 20 usec after the 8042 has accepted
;       the command.  We make use of the fact that the 8042 will not
;       accept another command until it is finished with the last one.
;       The 0FFh command does a NULL 'Pulse Output Port'.  Total execution
;       time is on the order of 30 usec, easily satisfying the IBM 8042
;       settling requirement.  (Thanks, CW!)

        mov     al,0FFh                 ;* Pulse Output Port (pulse no lines)
        out     STATUS_PORT,al          ;* send cmd to 8042
        call    empty_8042              ;* wait for 8042 to accept cmd

EA2:
        ret

_EnableA20   endp


;++
;
;VOID
;DisableA20(
;    VOID
;    )
;
;Routine Description:
;
;    Disables the A20 line for any machine. 
;
;Arguments:
;
;    None
;
;Return Value:
;
;    None.
;
;    The A20 line is disabled.
;
;--
        public  _DisableA20

_DisableA20      proc    near

;            Check if empty_8042 has failed before
;            If so, skip this function.  This would occur
;            on legacy free systems.

         mov   di,offset DGROUP:_Empty_8042Failed
         cmp   byte ptr [di],1
         jz   EA2
         
         cmp   byte ptr [di],0
            
DA1:
        call    empty_8042              ; ensure 8042 input buffer empty
        jnz     DA2                     ; 8042 error return


;            Disable the A20 line

        mov     al,0d1h                 ; 8042 cmd to write output port
        out     STATUS_PORT,al          ; send cmd to 8042
        call    empty_8042              ; wait for 8042 to accept cmd
        jnz     DA2                     ; 8042 error return
        mov     al,0ddh                 ; 8042 port data
        out     PORT_A,al               ; output port data to 8042
        call    empty_8042

;       We must wait for the a20 line to settle down, which (on an AT)
;       may not happen until up to 20 usec after the 8042 has accepted
;       the command.  We make use of the fact that the 8042 will not
;       accept another command until it is finished with the last one.
;       The 0FFh command does a NULL 'Pulse Output Port'.  Total execution
;       time is on the order of 30 usec, easily satisfying the IBM 8042
;       settling requirement.  (Thanks, CW!)

        mov     al,0FFh                 ;* Pulse Output Port (pulse no lines)
        out     STATUS_PORT,al          ;* send cmd to 8042
        call    empty_8042              ;* wait for 8042 to accept cmd

DA2:
        ret

_DisableA20   endp
;**
; empty_8042 -- wait for 8042 input buffer to drain
;
; Input:
;      interrupts disabled
;
; Exit:
;      al=0, z=0   => 8042 input buffer empty
;
; Uses:
;      ax, flags

        public  Empty8042
Empty8042     proc    near
empty_8042:
        sub     cx,cx                   ; cx = 0, timeout loop counter

emp1:   in      al,STATUS_PORT          ; read 8042 status port
        IODelay
        IODelay
        IODelay
        IODelay
        and     al,BUF_FULL             ; test buffer full bit
        loopnz  emp1

        cmp     cx,0                    ; see if buffer is full
        jnz     emp2
        

        ; if we reached this point this indicates an error
        
        mov   di,offset DGROUP:_Empty_8042Failed
        mov   byte ptr [di],1
        
        
        
;        mov     [_Empty_8042Failed],1                    ; set Empty_8042Failed global to "TRUE"
;        mov     _Empty_8042Failed,1                    ; set Empty_8042Failed global to "TRUE"
;        mov     cx, offset _Empty_8042Failed
;        mov     [cx],ah
                

emp2:
        and   al,BUF_FULL                               ; reset the Z flag
        ret

Empty8042     endp

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Author:

    Thomas Parslow (tomp) Mar-01-90

Abstract:

    Video support routines.

    The SU module only need to be able to write to the video display
    in order to report errors, traps, etc.

    The routines in this file all write to a video buffer assumed to be
    at realmode address b800:0000, and 4k bytes in length. The segment
    portion of the far pointers used to access the video buffer are stamped
    with a protmode selector value when we switch to protect mode. This is
    done in the routine "ProtMode" in "misc386.asm".


--*/

#include "su.h"


#define ZLEN_BYTE(x)  (x < 0x10)
#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))

#ifdef DEBUG1
#define ROWS 43
#else
#define ROWS 25
#endif
#define COLUMNS 80
#define SCREEN_WIDTH COLUMNS
#define SCREEN_SIZE ROWS * COLUMNS
#define NORMAL_ATTRIB 0x07
#define REVERSE_ATTRIB 0x70
#define SCREEN_START 0xb8000000

#define VIDEO_BIOS   0x10
#define LINES_400_CONFIGURATION  0x1202
#define SELECT_SCAN_LINE 0x301
#define SET_80X25_16_COLOR_MODE  0x3
#define LOAD_8X8_CHARACTER_SET   0x1112

//
// Internal routines
//

static
VOID
tab(
    VOID
    );

static
VOID
newline(
    VOID
    );

static
VOID
putzeros(
    USHORT,
    USHORT
    );


USHORT
Redirect = 0;

VOID
InitializeVideoSubSystem(
    VOID
    )
/*++

Routine Description:

    Initializes the video mode to 80x50 alphanumeric mode with 400 lines
    vertical resolution.

Arguments:

    None

Returns:

    Nothing


--*/

{
    BIOSREGS ps;
    UCHAR _far *BiosArea;

    //
    // Set 40:10 to indicate color is the default display
    //   *(40:10) &= ~0x30;
    //   *(40:10) |= 0x20;
    //
    // Fixes obscure situation where both monochrome and VGA adapters
    // are installed and the monochrome is the default display.
    //
    BiosArea = (UCHAR _far *)(0x410L);

    *BiosArea &= ~0x30;
    *BiosArea |= 0x20;

    //
    // Establish 80x25 alphanumeric mode with 400-lines vertical resolution
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = LINES_400_CONFIGURATION;
    ps.bx = SELECT_SCAN_LINE;
    biosint(&ps);

    ps.fn = VIDEO_BIOS;
    ps.ax = SET_80X25_16_COLOR_MODE;
    biosint(&ps);

    DBG1(
        ps.ax = LOAD_8X8_CHARACTER_SET;
        ps.bx = 0;
        biosint(&ps);
    )

    //
    // HACK-O-RAMA - Make some random video BIOS calls here to make sure the
    // BIOS is initialized and warmed up and ready to go.  Otherwise,
    // some Number 9 S3 cards don't quite work right later in the game.
    //  John Vert (jvert) 9-Jun-1993
    //

    //
    // set cursor position to 0,0
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = 0x2000;
    ps.bx = 0;
    ps.dx = 0;
    biosint(&ps);

    //
    // write character (' ' in this case)
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = 0x0a00 | (USHORT)' ';
    ps.bx = 0;
    ps.cx = 1;
    biosint(&ps);

    clrscrn();
    return ;
}


//
// Used by all BlPrint subordinate routines for padding computations.
//

CHAR sc=0;
ULONG fw=0;



VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex
     %b      - byte in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.


Returns:

    Nothing


--*/

{
    UCHAR uc;
    USHORT b,c,w,len;
    PUCHAR ap;
    ULONG l;

    //
    // Cast a pointer to the first word on the stack
    //

    ap = (PUCHAR)&cp + sizeof(PCHAR);
    sc = ' '; // default padding char is space

    //
    // Process the arguments using the descriptor string
    //


    while (b = *cp++)
        {
        if (b == '%')
            {
            c = *cp++;

            switch (c)
                {
                case 'd':
                    puti((long)*((int *)ap));
                    ap += sizeof(int);
                    break;

                case 's':
                    puts(*((PCHAR *)ap));
                    ap += sizeof (char *);
                    break;

                case 'c':
                    putc(*((char *)ap));
                    ap += sizeof(int);
                    break;

                case 'x':
                    w = *((USHORT *)ap);
                    len = ZLEN_SHORT(w);
                    while(len--) putc('0');
                    putx((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'u':
                    putu((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'b':
                    uc = *((UCHAR *)ap);
                    len = ZLEN_BYTE(uc);
                    while(len--) putc('0');
                    putx((ULONG)uc);
                    ap += sizeof(int);
                    break;

                case 'l':
                    c = *cp++;

                switch(c) {

                    case 'u':
                        putu(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'x':
                        l = *((ULONG *)ap);
                        len = ZLEN_LONG(l);
                        while(len--) putc('0');
                        putx(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'd':
                        puti(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                }
                break;

                default :
                    putc((char)b);
                    putc((char)c);
                }
            }
        else
            putc((char)b);
        }

}

FPUCHAR vp = (FPUCHAR)SCREEN_START;
FPUCHAR ScreenStart = (FPUCHAR)SCREEN_START;

static int lcnt = 0;
static int row  = 0;


VOID puts(
    PCHAR cp
    )
/*++

Routine Description:

    Writes a string on the display at the current cursor position

Arguments:

    cp - pointer to ASCIIZ string to display.


Returns:

    Nothing



--*/


{
    char c;

    while(c = *cp++)
        putc(c);
}


//
// Write a hex short to display
//


VOID putx(
    ULONG x
    )
/*++

Routine Description:

    Writes hex long to the display at the current cursor position.

Arguments:

    x  - ulong to write.

Returns:

    Nothing


--*/

{
    ULONG j;

    if (x/16)
        putx(x/16);

    if((j=x%16) > 9) {
        putc((char)(j+'A'- 10));
    } else {
        putc((char)(j+'0'));
    }
}


VOID puti(
    LONG i
    )
/*++

Routine Description:

    Writes a long integer on the display at the current cursor position.

Arguments:

    i - the integer to write to the display.

Returns:

    Nothing


--*/


{
    if (i<0)
        {
        i = -i;
        putc((char)'-');
        }

    if (i/10)
        puti(i/10);

    putc((char)((i%10)+'0'));
}



VOID putu(
    ULONG u
    )
/*++

Routine Description:

    Write an unsigned long to display

Arguments:

    u - unsigned


--*/

{
    if (u/10)
        putu(u/10);

    putc((char)((u%10)+'0'));

}


VOID putc(
    CHAR c
    )
/*++

Routine Description:

    Writes a character on the display at the current position.

Arguments:

    c - character to write


Returns:

    Nothing


--*/

{
    switch (c)
        {
        case '\n':
            newline();
            break;

        case '\t':
            tab();
            break;

        default :
            if (FP_OFF(vp) >= (SCREEN_SIZE * 2)) {
                vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
                scroll();
            }
            *vp = c;
            vp += 2;
            ++lcnt;
      }
}


VOID newline(
    VOID
    )
/*++

Routine Description:

    Moves the cursor to the beginning of the next line. If the bottom
    of the display has been reached, the screen is scrolled one line up.

Arguments:

    None


Returns:

    Nothing


--*/

{
    vp += (SCREEN_WIDTH - lcnt)<<1;

    if (++row > ROWS-1) {

        vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
        scroll();

    }

    lcnt = 0;

}


VOID scroll(
    VOID
    )
/*++

Routine Description:

    Scrolls the display UP one line.

Arguments:

    None

Returns:

    Nothing

Notes:

    Currently we scroll the display by reading and writing directly from
    and to the video display buffer. We optionally switch to real mode
    and to int 10s

--*/

{
    USHORT i,j;
    USHORT far *p1 = (USHORT far *)ScreenStart;
    USHORT far *p2 = (USHORT far *)(ScreenStart + 2*SCREEN_WIDTH) ;

    for (i=0; i < ROWS - 1; i++)
        for (j=0; j < SCREEN_WIDTH; j++)
            *p1++ = *p2++;

    for (i=0; i < SCREEN_WIDTH; i++)
        *p1++ = REVERSE_ATTRIB*256 + ' ';

}


static
VOID tab(
    VOID
    )
/*++

Routine Description:


    Computes the next tab stop and moves the cursor to that location.


Arguments:


    None


Returns:

    Nothing

--*/

{
    int inc;

    inc = 8 - (lcnt % 8);
    vp += inc<<1;
    lcnt += inc;
}


VOID clrscrn(
    VOID
    )
/*++

Routine Description:

    Clears the video display by writing blanks with the current
    video attribute over the entire display.


Arguments:

    None

Returns:

    Nothing


--*/

{
    int i,a;
    unsigned far *vwp = (unsigned far *)ScreenStart;
    a = NORMAL_ATTRIB*256 + ' ';

    for (i = SCREEN_SIZE ; i ; i--)
        *vwp++ = a;

    row  = 0;
    lcnt = 0;
    vp = (FPUCHAR)ScreenStart;

}

// END OF FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\eisa.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisa.h

Abstract:

    This module contains the i386 EISA bus specific header file.

Author:

    Shie-Lin Tzong (shielint) 6-June-1991

Revision History:

--*/

//
// SU module's version of the memory descriptor
//
typedef struct _MEMORY_LIST_ENTRY {
    ULONG BlockBase;
    ULONG BlockSize;
} MEMORY_LIST_ENTRY, *PMEMORY_LIST_ENTRY;


//
// SU module's version of the address space parameters for int-15 E820 calls
//

typedef struct {
    ULONG       ErrorFlag;
    ULONG       Key;
    ULONG       Size;
    struct {
        ULONG       BaseAddrLow;
        ULONG       BaseAddrHigh;
        ULONG       SizeLow;
        ULONG       SizeHigh;
        ULONG       MemoryType;
    } Descriptor;
} E820Frame;


//
// Misc. definitions
//

#define _16MEGB                  ((ULONG)16 * 1024 * 1024)
#define _64MEGB                  ((ULONG)64 * 1024 * 1024)

typedef CM_EISA_SLOT_INFORMATION BTEISA_SLOT_INFORMATION;
typedef CM_EISA_SLOT_INFORMATION *PBTEISA_SLOT_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION BTEISA_FUNCTION_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION *PBTEISA_FUNCTION_INFORMATION;
typedef EISA_MEMORY_CONFIGURATION BTEISA_MEMORY_CONFIGURATION;
typedef EISA_MEMORY_CONFIGURATION *PBTEISA_MEMORY_CONFIGURATION;

BOOLEAN
FindFunctionInformation (
    IN UCHAR SlotFlags,
    IN UCHAR FunctionFlags,
    OUT PBTEISA_FUNCTION_INFORMATION Buffer,
    IN BOOLEAN FromBeginning
    );

USHORT
CountMemoryBlocks (
    VOID
    );

ULONG
EisaConstructMemoryDescriptors (
    VOID
    );

UCHAR
BtGetEisaSlotInformation (
   PBTEISA_SLOT_INFORMATION SlotInformation,
   UCHAR Slot
   );

UCHAR
BtGetEisaFunctionInformation (
   PBTEISA_FUNCTION_INFORMATION FunctionInformation,
   UCHAR Slot,
   UCHAR Function
   );

BOOLEAN
BtIsEisaSystem (
   VOID
   );

//
// External References
//

extern MEMORY_LIST_ENTRY _far *MemoryDescriptorList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

!ENDIF

MAJORCOMP=ntos
MINORCOMP=startrom
TARGETPATH=obj

!if $(ALPHA) || $(AXP64)

TARGETNAME=startrom
TARGETTYPE=LIBRARY

SOURCES=

!endif

!if $(IA64)

TARGETNAME=startrom
TARGETTYPE=LIBRARY

SOURCES=

!endif

!IF $(386)

TARGETNAME=startrom.com
TARGETTYPE=UMAPPL_NOLIB

INCLUDES=$(SDK_INC_PATH);..\..\inc;..\..\..\inc;..\..\..\config;..\..\..\nthals

SOURCES=

i386_SOURCES=..\i386\su.asm         \
             ..\i386\exp.asm        \
             ..\i386\sudata.asm     \
             ..\i386\eisaa.asm      \
             ..\i386\eisac.c        \
             ..\i386\main.c         \
             ..\i386\mtftp.c        \
             ..\i386\a20.asm        \
             ..\i386\trap.asm       \
             ..\i386\trapdump.c     \
             ..\i386\display.c      
!ENDIF

!IF $(386)

NTTARGETFILES=$(_OBJ_DIR)\i386\startrom.com
!IFNDEF ALT_TARGETNAME
MISCFILES=$(_OBJ_DIR)\i386\startrom.com
!ELSE
MISCFILES=$(_OBJ_DIR)\i386\$(ALT_TARGETNAME)
!ENDIF

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\eisa.inc ===
;++
;
;   Copyright (c) 1989	Microsoft Corporation
;
;   Module Name:
;
;	eisa.inc
;
;   Abstract:
;
;	This module contains the assembly structures and definitions
;       for making 16-bit real mode EISA BIOS calls.
;
;   Author:
;
;	Shie-Lin (shielint) 7-June-1991
;
;   Revision History:
;
;--

;
; EISA BIOS call function number.
;

GET_EISA_SLOT_INFORMATION     equ 0D800h
GET_EISA_FUNCTION_INFORMATION equ 0D801h

;
; Length of EISA information block
;

EISA_INFORMATION_BLOCK_LENGTH equ 320

;
; Structure for EISA slot information block
;

EISA_SLOT_INFORMATION   struc

    SlotReturn                  db      0
    SlotFlags                   db      0
    SlotMajorRevision           db      0
    SlotMinorRevision           db      0
    SlotChecksum                dw      0
    SlotNumberFunctions         db      0
    SlotFunctionInformation     db      0
    SlotCompressedId            dd      0

EISA_SLOT_INFORMATION   ends

;
; Structure for EISA function information block
;

EISA_FUNCTION_INFORMATION       struc

    FunctionReturn      db      0
    FunctionInformation db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

EISA_FUNCTION_INFORMATION       ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\makefile.inc ===
# Copyright (C) by Microsoft Corporation.
#
# MAKEFILE for NT SU.X86
#
# Created:
#               91.01.18
#
# Author:
#               Thomas Parslow
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

.SUFFIXES:       .com .exe .obj .lst .c .asm .def .lnk .inc


#
#       C Compiler Definitions
#       ~~~~~~~~~~~~~~~~~~~~~~

!IFDEF ALT_PROJECT_MAKE
ALT_PROJECT_FLAGS=-D$(ALT_PROJECT)
!ENDIF

PATH= $(PATH_TOOLS16);$(PATH)

CC=     cl16
CFLAGS= -WX -W3 -G2s -Zelp $(LOADER_DEBUG)  $(BLFLAGS) $(ALT_PROJECT_FLAGS)
CINC=   $(PROJECT_INC_PATH);$(SDK_INC_PATH);..\i386;..\i386\$(LANGUAGE);..\..\inc


#
#       Assembler Definitions
#       ~~~~~~~~~~~~~~~~~~~~~

ASM=    masm386
AFLAGS= -Mx  -z $(LOADER_DEBUG) $(GAFLAGS) $(ALT_PROJECT_FLAGS)
AINC=  -I\nt\public\sdk\inc -I..\i386


#
#       Linker Definitions
#       ~~~~~~~~~~~~~~~~~~

LINK=link16
LIBS=..\..\startup\long.lib
DEF=


#
#       Rules for generating objects
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~



{..\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
        $(ASM) $(AFLAGS) $(AINC) $< $@;

{..\i386\}.asm.lst:
        $(ASM) -l -n $(AFLAGS) $(AINC) $<;

#        $(CC) $(CFLAGS) $(CINC) -c $<

{..\i386\}.c{$(_OBJ_DIR)\i386\}.obj:
    set INCLUDE=$(CINC)
    @echo $(CC) $(CFLAGS) -Fo$@ -c $<
    @$(CC) $(CFLAGS) -Fo$@ -c $< | findstr /v 4011
    set INCLUDE=

{..\}.c{$(_OBJ_DIR)\i386\}.obj:
    set INCLUDE=$(CINC)
    @echo $(CC) $(CFLAGS) -Fo$@ -c $<
    @$(CC) $(CFLAGS) -Fo$@ -c $< | findstr /v 4011
    set INCLUDE=

{..\i386\}.c.lst:
    set INCLUDE=$(CINC)
    $(CC) $(CFLAGS) -Fc$*.cod -Fo$*.obj -dos -c $<
    set INCLUDE=


#
#       List of object files required
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OBJ= $(_OBJ_DIR)\i386\su.obj  $(_OBJ_DIR)\i386\exp.obj  $(_OBJ_DIR)\i386\sudata.obj \
$(_OBJ_DIR)\i386\eisaa.obj  $(_OBJ_DIR)\i386\a20.obj  $(_OBJ_DIR)\i386\trap.obj  $(_OBJ_DIR)\i386\eisac.obj \
$(_OBJ_DIR)\i386\main.obj  $(_OBJ_DIR)\i386\trapdump.obj $(_OBJ_DIR)\i386\display.obj \
$(_OBJ_DIR)\i386\mtftp.obj


#
#       Dependencies
#       ~~~~~~~~~~~~


$(_OBJ_DIR)\i386\startrom.com: $(OBJ)

$(_OBJ_DIR)\i386\exp.obj         exp.lst:        ..\i386\exp.asm ..\i386\su.inc ..\i386\macro.inc

$(_OBJ_DIR)\i386\eisaa.obj       eisaa.lst:      ..\i386\eisa.inc ..\i386\eisaa.asm

$(_OBJ_DIR)\i386\eisac.obj       eisac.lst:      ..\i386\eisa.h ..\i386\eisac.c

$(_OBJ_DIR)\i386\su.obj          su.lst:         ..\i386\su.asm ..\i386\su.inc

$(_OBJ_DIR)\i386\sudata.obj      sudata.lst:     ..\i386\sudata.asm ..\i386\su.inc ..\i386\memmap.inc

$(_OBJ_DIR)\i386\main.obj        main.lst:       ..\i386\main.c ..\i386\global.h ..\i386\types.h ..\i386\constant.h

$(_OBJ_DIR)\i386\trap.obj        trap.lst:       ..\i386\trap.asm ..\i386\su.inc

$(_OBJ_DIR)\i386\trapdump.obj    trapdump.lst:   ..\i386\trapdump.c ..\i386\types.h ..\i386\constant.h

$(_OBJ_DIR)\i386\display.obj     display.lst:    ..\i386\display.c ..\i386\types.h ..\i386\constant.h ..\i386\global.h

$(_OBJ_DIR)\i386\mtftp.obj       mtftp.lst:      ..\i386\mtftp.c

$(_OBJ_DIR)\i386\startrom.com: $(OBJ) $(DOBJ) $(LIBS)
        $(LINK) /tiny /nod /noi /map:full @<<
$(OBJ: = +^
)
$(_OBJ_DIR)\i386\startrom.com
startrom.map
$(LIBS)

<<

$(_OBJ_DIR)\i386\startrom.n12: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\startrom.n12

$(_OBJ_DIR)\i386\hdlscom1.com: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlscom1.com

$(_OBJ_DIR)\i386\hdlscom2.com: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlscom2.com

$(_OBJ_DIR)\i386\hdlscom1.n12: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlscom1.n12

$(_OBJ_DIR)\i386\hdlscom2.n12: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlscom2.n12

$(_OBJ_DIR)\i386\hdlstst1.n12: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlstst1.n12

$(_OBJ_DIR)\i386\hdlstst2.n12: $(_OBJ_DIR)\i386\startrom.com
    -copy $(_OBJ_DIR)\i386\startrom.com $(_OBJ_DIR)\i386\hdlstst2.n12
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\eisaa.asm ===
title  "EISA bus Support Assembley Code"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    eisaa.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to get configuration
;    information on EISA machines.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 7-June-1991
;
; Environment:
;
;    Real Mode 16-bit code.
;
; Revision History:
;
;
;--


.386p
        .xlist
include eisa.inc
        .list

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

        public  _FunctionInformation
_FunctionInformation     db      0
                         db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT

;++
;
; VOID
; BtGetEisaSlotInformation (
;    PBTEISA_SLOT_INFORMATION SlotInformation,
;    UCHAR Slot
;    )
;
; Routine Description:
;
;    This function retrieves the slot information for the specified slot.
;
; Arguments:
;
;    SlotInformation - Supplies a pointer to the structure which will
;                      receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
; Return Value:
;
;    None.
;
;--

BgesSlotInformation     equ     [bp + 4]
BgesSlot                equ     [bp + 6]

        public  _BtGetEisaSlotInformation
_BtGetEisaSlotInformation       proc

        push    bp                      ; The following INT 15H destroies
        mov     bp, sp                  ;   ALL the general registers.
        push    si
        push    di
        push    bx

        mov     cl, BgesSlot
        mov     ax, GET_EISA_SLOT_INFORMATION
        int     15h

        push    bx                      ; Save revision level
        mov     bx, BgesSlotInformation

        ;
        ; fill values into eisa slot info structure.
        ;

        mov     [bx].SlotReturn, ah
        mov     [bx].SlotFlags, al
        pop     ax                      ; [ax] = revision level
        mov     [bx].SlotMajorRevision, ah
        mov     [bx].SlotMinorRevision, al
        mov     [bx].SlotChecksum, cx
        mov     [bx].SlotNumberFunctions, dh
        mov     [bx].SlotFunctionInformation, dl
        mov     word ptr [bx].SlotCompressedId, di
        mov     word ptr [bx+2].SlotCompressedId, si

        pop     bx
        pop     di
        pop     si
        pop     bp
        ret

_BtGetEisaSlotInformation       endp

;++
;
; UCHAR
; BtGetEisaFunctionInformation (
;    PBTEISA_FUNCTION_INFORMATION FunctionInformation,
;    UCHAR Slot,
;    UCHAR Function
;    )
;
; Routine Description:
;
;    This function retrieves function information for the specified slot
;    and function.
;
; Arguments:
;
;    FunctionInformation - Supplies a pointer to the structure which will
;           receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
;    Function - Supplies the function number of the desired slot.
;
; Return Value:
;
;    Return code of the EISA function call.
;
;--

BgefFunctionInformation equ     [bp + 4]
BgefSlot                equ     [bp + 6]
BgefFunction            equ     [bp + 8]

        public  _BtGetEisaFunctionInformation
_BtGetEisaFunctionInformation     proc

        push    bp
        mov     bp, sp
        push    si

        mov     ax, GET_EISA_FUNCTION_INFORMATION
        mov     cl, BgefSlot            ; [cl] = slot, [ch]=function
        mov     ch, BgefFunction
        mov     si, BgefFunctionInformation
                                        ; (ds:si)->Function information
        int     15h

        mov     al, ah                  ; move the return code to AL

        pop     si
        pop     bp
        ret
_BtGetEisaFunctionInformation     endp

;++
;
; BOOLEAN
; BtIsEisaSystem (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines if the target machines is EISA based machines.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE - if this is EISA machine.  Otherwise, a value of FALSE is returned.
;--

        public _BtIsEisaSystem
_BtIsEisaSystem proc

        push    es
        push    bx

;
;       Check for an EISA system.  If "EISA" is at F000:FFD9h then it
;       is an EISA system.
;

        mov     ax,0f000h               ; segment
        mov     es,ax
        mov     bx,0ffd9h               ; offset in the ROM
        mov     eax, "ASIE"
        cmp     eax, es:[bx]
        jne     short bies00            ; if ne, Not EISA system, go bies00

        mov     ax, 1                   ; set return value to TRUE
        jmp     short bies10

bies00:
        mov     ax, 0
bies10:
        pop     bx
        pop     es
        ret
_BtIsEisaSystem endp

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\exp.asm ===
;++
;
; Module name
;
;       exp.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Feb-26-91
;
; Description
;
;       Entry points exported to OS loader by SU module. Exported
;       routines provide basic machine dependent i/o funtions needed
;       by the OS loader. Providing these routines decouples the
;       OS loader from the h/w. Note that the OS loader will
;       refer to these exported routines as the "external services".
;
;
; Exported Procedures
;
;       RebootProcessor - Reboots the machine
;       GetSector - Read one or more sectors from the boot device.
;       PutChar - Puts a character on the video display.
;       GetKey - Gets a key from the keyboard
;       GetKeyEx - Gets an extended key from the keyboard or the comport (headless)
;       GetCounter - Reads the Tick Counter
;       Reboot - Transfers control to a loaded boot sector.
;       HardwareCursor - set position of hardware cursor
;       GetDateTime - gets date and time
;       ComPort - int14 functions
;       GetStallCount - calculates processor stall count
;
;
; Notes
;
;       When adding a new exported routine note that you must manually add the
;       entry's name to the BootRecord in "sudata.asm".
;
;--

include su.inc
include macro.inc

DISK_TABLE_VECTOR       equ     01Eh * 4

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

        extrn   _DiskBaseTable:near
        extrn   _RomDiskBasePointer:near
        extrn   _EddsAddressPacket:near
        extrn   _NetPcRomEntry:near
        extrn   _EnableA20:near


;++
;
; Exported Name:
;
;       RebootProcessor
;
; Arguments:
;
;       None
;
; Description:
;
;       Reboot the processor using INT 19h
;
;
;
;--
;
; ExportEntry takes us from a 32bit cs to a 16bit cs, inits 16bit stack
; and ds segments and saves the callers esp and ebp.
;
;--

EXPORT_ENTRY_MACRO    RebootProcessor
;
; Switch to real mode so we can take interrupts
;

        ENTER_REALMODE_MACRO

;
; int 19h doesn't do what you would expect on BIOS Boot Specification machines.
; It either goes on to the next boot device or goes back to the first boot
; device. In both cases, it does not properly reset the machine. So we write
; to the keyboard port instead (as does HalpReboot).
;

        mov     ax, 040h
        mov     ds, ax
        mov     word ptr ds:[72h], 1234h        ; set location 472 to 1234 to indicate warm reboot
        mov     al, 0feh
        out     64h, al                         ; write to keyboard port to cause reboot

;
; Loop forever and wait to ctrl-alt-del (should never get here)
;

        WAIT_FOREVER_MACRO

;EXPORT_EXIT_MACRO


;++
;
; Name:
;
;       GetSector
;
; Description:
;
;       Reads the requested number of sectors from the specified drive into
;       the specified buffer.
;
; Arguments:
;
;             ULONG Virtual address into which to read data
;             ULONG Number of sectors to read
;             ULONG Physical sector number
;             ULONG Drive Number
;             ULONG Function Number
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

EXPORT_ENTRY_MACRO    GetSector
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetSectorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Put the buffer pointer into es:bx. Note that and buffer
; addresses passed to this routine MUST be in the lower one
; megabyte of memory to be addressable in real mode.
;

        mov      eax,[bp].BufferPointer
        mov      bx,ax
        and      bx,0fh
        shr      eax,4
        mov      es,ax
;
; Place the upper 2 bits of the 10bit track/cylinder number
; into the uppper 2 bits of the SectorNumber as reguired by
; the bios.
;
        mov      cx,word ptr [bp].TrackNumber
        xchg     ch,cl
        shl      cl,6
        add      cl,byte ptr [bp].SectorNumber

;
; Get the rest of the arguments
;
        mov      ah,byte ptr [bp].FunctionNumber
        mov      al,byte ptr [bp].NumberOfSectors
        mov      dh,byte ptr [bp].HeadNumber
        mov      dl,byte ptr [bp].DriveNumber

;
; Check to see if we are trying to reset/read/write/verify off the second
; floppy drive.  If so, we need to go change the disk-base vector.
;
        cmp     dl,1
        jne     gs3
        cmp     ah,4
        jg      gs3
        cmp     ah,0
        je      gs1
        cmp     ah,2
        jl      gs3

gs1:
;
; We need to point the BIOS disk-table vector to our own table for this
; drive.
;
        push    es
        push    bx
        push    di

        push    0
        pop     es

        mov     di, offset DGROUP:_RomDiskBasePointer

        mov     bx,es:[DISK_TABLE_VECTOR]
        mov     [di],bx
        mov     bx,es:[DISK_TABLE_VECTOR+2]
        mov     [di+2],bx

        mov     bx,offset DGROUP:_DiskBaseTable
        mov     es:[DISK_TABLE_VECTOR],bx
        mov     bx,ds
        mov     es:[DISK_TABLE_VECTOR+2],bx

        pop     di
        pop     bx
        pop     es

        int     BIOS_DISK_INTERRUPT

        push    es
        push    bx
        push    di

        push    0
        pop     es

        mov     di, offset DGROUP:_RomDiskBasePointer

        mov     bx, [di]
        mov     es:[DISK_TABLE_VECTOR],bx
        mov     bx, [di+2]
        mov     es:[DISK_TABLE_VECTOR+2],bx

        pop     di
        pop     bx
        pop     es

        jc      gs5
        xor     eax,eax
        jmp     short gs5

gs3:

;
; Call the bios to read the sector now
;
if 0
        push     ax
        push     dx
        push     cx
        push     bx
        push     es
extrn _DisplayArgs:near
        call     _DisplayArgs
        pop      es
        pop      bx
        pop      cx
        pop      dx
        pop      ax
endif

        int      BIOS_DISK_INTERRUPT
        jc       gs5

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor     eax,eax
gs5:
if 0
        push     ax
        push     dx
        push     cx
        push     bx
        push     es
extrn _DisplayArgs:near
        call     _DisplayArgs
        pop      es
        pop      bx
        pop      cx
        pop      dx
        pop      ax
endif

;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and      eax,0000ffffh

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetSectorFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

; move cx into high 16-bits of ecx, and dx into cx.  This is so the loader
; can get at interesting values in dx, even though edx gets munged by the
; random real-mode macros.

        shl     ecx, 16
        mov     cx,dx
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax
;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; Name:
;
;       GetEddsSector
;
; Description:
;
;       Reads the requested number of sectors from the specified drive into
;       the specified buffer based on the Phoenix Enhanced Disk Drive Spec.
;
; Arguments:
;
;             ULONG xint13 function number (42 = read, 43 = write)
;             ULONG Virtual address into which to read data
;             ULONG Number of logical blocks to read (word)
;             ULONG Logical block number (High dword)
;             ULONG Logical block number (Low dword)
;             ULONG Drive Number (byte)
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

EXPORT_ENTRY_MACRO    GetEddsSector
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetEddsSectorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

        push     ds
        push     si
        push     bx

;
; Set up DS:SI -> Disk Address Packet
;
        push    0
        pop     ds
        mov     si, offset DGROUP:_EddsAddressPacket
        mov     ds:[si],word ptr 10h             ; Packet size = 10h, plus reserved byte
        mov     ax,word ptr [bp].NumberOfBlocks
        mov     ds:[si][2],ax                    ; Num blocks to transfer
        mov     eax,[bp].BufPointer
        mov     bx,ax
        and     bx,0fh
        mov     ds:[si][4],bx                    ; Transfer buffer address (low word=offset)
        shr     eax,4
        mov     ds:[si][6],ax                    ; Transfer buffer address (high word=segment)
        mov     eax,[bp].LBNLow
        mov     ds:[si][8],eax                   ; Starting logical block number (low dword)
        mov     eax,[bp].LBNHigh
        mov     ds:[si][12],eax                  ; Starting logical block number (high dword)

;
; Call the bios to read the sector now (DS:SI -> Disk address packet)
;
       mov      ah,byte ptr [bp].FunctionNum    ; function
       xor      al,al                           ; force verify on write off
       mov      dl,byte ptr [bp].DriveNum       ; DL = drive number
       int      BIOS_DISK_INTERRUPT
       jc       geserror1

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor      eax,eax
geserror1:

;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and      eax,0000ffffh

        pop      bx
        pop      si
        pop      ds

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetEddsSectorFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

; move cx into high 16-bits of ecx, and dx into cx.  This is so the loader
; can get at interesting values in dx, even though edx gets munged by the
; random real-mode macros.

        shl      ecx, 16
        mov      cx,dx
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax
;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetKey
;
; Description:
;
;       Checks the keyboard to see if a key is available.
;
; Arguments:
;
;       None.
;
; Returns:
;
;       If no key is available, returns 0
;
;       If ASCII character is available, LSB 0 is ASCII code
;                                        LSB 1 is keyboard scan code
;       If extended character is available, LSB 0 is extended ASCII code
;                                           LSB 1 is keyboard scan code
;
;--

EXPORT_ENTRY_MACRO      GetKey
;
; Go into real mode.  We still have the same stack and sp
; but we'll be executing in real mode.
;

        ENTER_REALMODE_MACRO

;
; Set up registers to call BIOS and check to see if a key is available
;

        mov     ax,0100h
        int     BIOS_KEYBOARD_INTERRUPT

        jnz     GkKeyAvail
        mov     eax, 0
        jmp     GkDone

GkKeyAvail:
;
; Now we call BIOS again, this time to get the key from the keyboard buffer
;
        mov     ax,0h
        int     BIOS_KEYBOARD_INTERRUPT
        and     eax,0000ffffh

;
; Save return code on 16bit stack
; Re-enable protect mode and paging
;
GkDone:
        push    eax
        RE_ENABLE_PAGING_MACRO
        pop     eax

;
; Return to caller and the 32-bit universe
;
EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetKeyEx
;
; Description:
;
;       Checks the keyboard to see if a (possibly extended) key is available.
;
; Arguments:
;
;       None.
;
; Returns:
;
;       If no key is available, returns 0
;
;       If ASCII character is available, LSB 0 is ASCII code
;                                        LSB 1 is keyboard scan code
;       If extended character is available, LSB 0 is extended ASCII code
;                                           LSB 1 is keyboard scan code
;
;--

        public  GetKeyEx
GetKeyEx        proc    near

IFDEF HEADLESS_SRV
;
; Give priority to Com I/O
;
        push    edi

        call    GetCounterReal   ; get starting RTC value
        mov     edi,eax          ; calculate RTC value for now + 2 secs.
        add     edi,37           ; (RTC clicks 18.2 times per second)

TopComPortRead:
        mov     ah, 03h          ; Query status
        mov     al, 0
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h

        mov     bh, ah           ; There seems to be a problem where the transmitter shift
        and     ah, 40h          ;  register status bit gets stuck on.  When this is
        jz      XmitterOk1       ;  the case, it blocks all other status bits.  To resolve it
                                 ;  we write out a NULL character

        mov     ah, 01h          ; Write character
        mov     al, 0            ; NULL character
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h

        call    GetCounterReal   ; get current RTC value
        cmp     eax, edi         ; is it higher than end value?
        jb      TopComPortRead   ; loop if current < end
        jmp     NoComPortKey

XmitterOk1:

        mov     ah, bh
        and     ah, 1            ; Data ready
        jz      NoComPortKey

        mov     ah, 02h          ; Read character
        mov     al, 0
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h

        cmp     al, 1bh          ; If this is the ESC character, process Function key (if any)
        jne     ExitComPortRead

        call    GetCounterReal   ; get starting RTC value
        mov     edi,eax          ; calculate RTC value for now + 2 secs.
        add     edi,37           ; (RTC clicks 18.2 times per second)

EscLoop:
        mov     ah, 03h          ; Query status
        mov     al, 0
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h

        mov     bh, ah           ; There seems to be a problem where the transmitter shift
        and     ah, 40h          ;  register status bit gets stuck on.  When this is
        jz      XmitterOk2       ;  the case, it blocks all other status bits.  To resolve it
                                 ;  we write out a NULL character

        mov     ah, 01h          ; Write character
        mov     al, 0            ; NULL character
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h
        jmp     EscLoop

XMitterOk2:
        mov     ah, bh
        and     ah, 1            ; Data ready
        jnz     NextKeyPressed

        call    GetCounterReal   ; get current RTC value
        cmp     eax, edi         ; is it higher than end value?
        jb      EscLoop          ; loop if current < end
        jmp     ComPortEscapeKey

NextKeyPressed:
        mov     ah, 02h          ; Read character
        mov     al, 0
        mov     dx, HEADLESS_COMPORT ; Com port
        int     14h

        cmp     al, 40h          ; '@' key
        jne     CheckMinusSign
        mov     eax, 0DA00h      ; F12 key
        jmp     GkxDone

CheckMinusSign:
        cmp     al, 21h          ; '!' key
        jne     CheckNumbers
        mov     eax, 0D900h      ; F11 key
        jmp     GkxDone

CheckNumbers:
        cmp     al, 30h
        jl      ComPortEscapeKey
        cmp     al, 39h
        jg      ComPortEscapeKey
        add     al, 10
        mov     ah, 0
        shl     eax, 8
        cmp     eax, 3a00h        ; Check for miscomputation on F10 key (aka Esc-0)
        jne     GkxDone
        mov     eax, 4400h
        jmp     GkxDone

ComPortEscapeKey:
        mov     eax, 011bh        ; ESCAPE key
        jmp     GkxDone

ExitComPortRead:
        movzx   edx, al
        mov     eax, edx
        jmp     GkxDone

NoComPortKey:

endif

;
; Set up registers to call BIOS and check to see if a key is available
;

        mov     ax,01100h
        int     BIOS_KEYBOARD_INTERRUPT

        jnz     GkxKeyAvail
        mov     eax, 0
        jmp     GkxDone

GkxKeyAvail:

;
; Now we call BIOS again, this time to get the key from the keyboard buffer
;
        mov     ax,01000h
        int     BIOS_KEYBOARD_INTERRUPT

        and     eax,0000ffffh

GkxDone:

IFDEF HEADLESS_SRV
        pop     edi
endif

        ret

GetKeyEx        endp

;++
;
; Routine Name:
;
;       GetCounter
;
; Description:
;
;       Reads the tick counter (incremented 18.2 times per second)
;
; Arguments:
;
;       None
;
; Returns:
;
;       The current value of the tick counter
;
;--

EXPORT_ENTRY_MACRO      GetCounter
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

        call    GetCounterReal

        push    eax
        RE_ENABLE_PAGING_MACRO
        pop     eax

EXPORT_EXIT_MACRO

        public  GetCounterReal
GetCounterReal proc near

        mov     ah,0
        int     01ah
        mov     ax,cx           ; high word of count
        shl     eax,16
        mov     ax,dx           ; low word of count

        ret

GetCounterReal endp

;++
;
; Routine Name:
;
;       Reboot
;
; Description:
;
;       Switches to real-mode and transfers control to a loaded boot sector
;
; Arguments:
;
;       unsigned BootType
;           0 = FAT. Just jump to 0:7c00.
;           1 = HPFS. Assumes boot code and super+spare areas (20 sectors)
;                  are already loaded at 0xd000; jumps to d00:200.
;           2 = NTFS. Assumes boot code is loaded (16 sectors) at 0xd000.
;                  Jumps to d00:256.
;           3 = SDI. Boot from downloaded SDI image. Assumes boot code
;                  (startrom.com) has been copied from the SDI image to
;                  0x7c00. Changes low byte of argument from 0x03 to 0x41
;                  to tell startrom that this is an SDI boot. The upper 3
;                  bytes of the argument are the upper 3 bytes of the
;                  page-aligned address at which the SDI image was loaded.
;
; Returns:
;       Does not return
;
; Environment:
;
;       Boot sector has been loaded at 7C00
;--

EXPORT_ENTRY_MACRO      Reboot
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <RebootFrame>, ebx
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

;
; Get the BootType argument.  Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;

        push     bp
        mov      bp,sp
        add      bp,2
        mov      edx, [bp].BootType

;
; Zero out the firmware heaps, 3000:0000 - 4000:ffff.
;

        xor     eax,eax         ; prepare for stosd
        mov     bx,3000h
        mov     es,bx
        mov     di,ax           ; es:di = physical address 30000
        mov     cx,4000h        ; cx = rep count, # dwords in 64K
        cld
        rep stosd
        mov     cx,4000h        ; rep count
        mov     es,cx           ; es:di = physical address 40000
        rep stosd

;
; Disable the A20 line.  Some things (like EMM386 and OS/2 on PS/2 machines)
; hiccup or die if we don't do this.
;

extrn   _DisableA20:near
        call    _DisableA20

;
; Put the video adapter back in 80x25 mode
;
        push    edx
        mov     ax, 0003h
        int     010h
        pop     edx

;
; Reset all the segment registers and setup the original stack
;
        mov     ax,0
        mov     ds,ax
        mov     es,ax
        mov     fs,ax
        mov     gs,ax

        mov     ax,30
        mov     ss,ax
        mov     esp,0100h
        mov     ebp,0
        mov     esi,0
        mov     edi,0

;
; Check for FAT boot or SDI boot and jump as appropriate.
;

        test    dx,-1
        jz      FatBoot

        cmp     dl,3
        je      SdiBoot

;
; Setup the registers the way the second sector of the OS/2 HPFS boot code
; expects them.  We skip the first sector entirely, as that just loads in
; the rest of the sectors.  Since the rest of the sectors are ours and not
; OS/2's, this would cause great distress.
;
        mov     ax,07c0h
        mov     ds, ax
        mov     ax, 0d00h
        mov     es, ax

        cli
        xor     ax,ax
        mov     ss,ax
        mov     sp, 07c00h
        sti

        push    0d00h
        push    0256h
        jmp     RebootDoit

;
; SDI boot. Set up to jump to startrom at 0:7c00. Change the 0x03 in DL
; to 0x41 to indicate SDI boot. Leave the upper three bytes of EDX as is.
;

SdiBoot:
        push    0
        push    07c00h
        mov     dl,041h
        jmp     RebootDoit

;
; FAT boot. Set up to jump to startup at 0:7c00. Put 0x80 in DX to indicate
; the boot drive.
;

FatBoot:
        push    0            ; set up for branch to boot sector
        push    07c00h
        mov     dx,080h

;
; And away we go!
;
RebootDoit:
        retf

        RE_ENABLE_PAGING_MACRO

        REMOVE_STACK_FRAME_MACRO  <RebootFrame>

EXPORT_EXIT_MACRO

;++
;
; Name:
;
;       HardwareCursor
;
; Description:
;
;       Positions the hardware cursor and performs other display stuff.
;
; Arguments:
;
;             ULONG Y coord (0 based)
;             ULONG X coord (0 based)
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;       If X = 0x80000000, then Y contains values that get placed into
;           ax (low word of Y) and bx (hi word of y).
;       Otherwise X,Y = coors for cursor
;
;
;--

EXPORT_ENTRY_MACRO    HardwareCursor
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <HardwareCursorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Put the row (y coord) in dh and the column (x coord) in dl.
;

        mov      eax,[bp].YCoord
        mov      edx,[bp].XCoord
        cmp      edx,80000000h
        jne      gotxy

        mov      ebx,eax
        shr      ebx,16
        jmp      doint10

    gotxy:
        mov      dh,al
        mov      ah,2
        mov      bh,0

    doint10:
        int      10h

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <HardwareCursorFrame>

;
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; Name:
;
;       GetDateTime
;
; Description:
;
;       Gets date and time
;
; Arguments:
;
;             ULONG Virtual address of a dword in which to place time.
;             ULONG Virtual address of a dword in which to place date.
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

BCD_TO_BIN  macro
    xor ah,ah
    rol ax,4
    ror al,4
    aad
endm

EXPORT_ENTRY_MACRO    GetDateTime
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetDateTimeFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Get the time
;

        mov      ah,2
        int      1ah

;
; Convert BIOS time format into our format and place in caller's dword
; bits 0-5 are the second
; bits 6-11 are the minute
; bits 12-16 are the hour
;
        xor      eax,eax
        mov      al,dh      ; BCD seconds
        BCD_TO_BIN
        movzx    edx,ax
        mov      al,cl      ; BCD minutes
        BCD_TO_BIN
        shl      ax,6
        or       dx,ax
        mov      al,ch      ; BCD hours
        BCD_TO_BIN
        shl      eax,12
        or       edx,eax

        mov      eax,[bp].TimeDword
        mov      bx,ax
        and      bx,0fh
        shr      eax,4
        mov      es,ax

        mov      es:[bx],edx

;
; Get the date
;

        mov      ah,4
        int      1ah

;
; Convert BIOS date format into our format and place in caller's dword
; bits 0-4  are the day
; bits 5-8  are the month
; bits 9-31 are the year
;

        xor     eax,eax
        mov     al,dl       ; BCD day
        BCD_TO_BIN
        mov     bl,dh
        movzx   edx,ax
        mov     al,bl       ; BCD month
        BCD_TO_BIN
        shl     ax,5
        or      dx,ax
        mov     al,cl       ; BCD year
        BCD_TO_BIN
        mov     cl,al
        mov     al,ch       ; BCD century
        BCD_TO_BIN
        mov     ah,100
        mul     ah
        xor     ch,ch
        add     ax,cx
        shl     eax,9
        or      edx,eax

        mov     eax,[bp].DateDword
        mov     bx,ax
        and     bx,0fh
        shr     eax,4
        mov     es,ax

        mov     es:[bx],edx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetDateTimeFrame>

;
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; VOID
; DetectHardware (
;    IN PDETECTION_RECORD DetectionRecord
;    )
;
; Routine Description:
;
;    This routine invokes x86 16 bit real mode detection code from
;    osloader 32 bit flat mode.
;
; Arguments:
;
;    DetectionRecord - Supplies a pointer to a detection record structure.
;
; Return Value:
;
;    None.
;
;--


EXPORT_ENTRY_MACRO    DetectHardware

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <DetectionFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Call the Hardware Detection code
;

        push    cs
        push    offset _TEXT:DetectionDone      ; push far return addr

        push    DETECTION_ADDRESS_SEG
        push    DETECTION_ADDRESS_OFFSET
        retf

DetectionDone:

;
; Restore bp and remove stack-frame from stack
;

        REMOVE_STACK_FRAME_MACRO <DetectionFrame>

;
; No return code, so we don't save return code around page enabling code
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO

;++
;
; VOID
; ComPort (
;    IN LONG  Port,
;    IN ULONG Function,
;    IN UCHAR Arg
;    )
;
; Routine Description:
;
;    Invoke int14 on com1.
;
; Arguments:
;
;    Port - port # (0 = com1, etc).
;
;    Function - int 14 function (for ah)
;
;    Arg - arg for function (for al)
;
; Return Value:
;
;    None.
;
;--


EXPORT_ENTRY_MACRO    ComPort

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <ComPortFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Get args and call int14
;

        mov      ah,byte ptr [bp].ComPortFunction
        mov      al,byte ptr [bp].ComPortArg
        mov      dx,word ptr [bp].ComPortPort
        int      14h

;
; Restore bp and remove stack-frame from stack
;

        pop      bp

        REMOVE_STACK_FRAME_MACRO <ComPortFrame>

;
; No return code, so we don't save return code around page enabling code
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO

;++
;
; ULONG
; GetStallCount (
;    VOID
;    )
;
; Routine Description:
;
;    Calculates how many increments are required to stall for one microsecond
;
;    The way this routine works is to set up an ISR on the BIOS vector 1C.
;    This routine will get called 18.2 times a second.  The location where
;    IP will be stored when the interrupt occurs is computed and stashed in
;    the code segment.  When the ISR fires, the IP on the stack is changed
;    to point to the next chunk of code to execute.  So we can spin in a
;    very tight loop and automatically get blown out of the loop when the
;    interrupt occurs.
;
;    This is all pretty sleazy, but it allows us to calibrate accurately
;    without relying on the 8259 or 8254 (just BIOS).  It also does not
;    depend on whether the ISR can affect the CPU registers or not.  (some
;    BIOSes, notably Olivetti, will preserve the registers for you)
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Number of increments required to stall for one microsecond
;
;--

EXPORT_ENTRY_MACRO    GetStallCount
;
; Go into real mode.
;


        ENTER_REALMODE_MACRO

        cli

        push    di
        push    si
        push    ds
        mov     ax,0
        mov     ds,ax

;
; save previous vector
;
        mov     di, 01ch*4
        mov     cx, [di]
        mov     dx, [di+2]

;
; insert our vector
;
        mov     ax, offset GscISR
        mov     [di], ax
        push    cs
        pop     ax
        mov     [di+2], ax

        mov     eax,0
        mov     ebx,0
        mov     si,sp
        sub     si,6
        mov     cs:savesp,si
        mov     cs:newip,offset GscLoop2
        sti

;
; wait for first tick.
;
GscLoop1:
        cmp     ebx,0
        je      GscLoop1

;
; start counting
;
;
; We spin in this loop until the ISR fires.  The ISR will munge the return
; address on the stack to blow us out of the loop and into GscLoop3
;
GscLoop2:
        mov     cs:newip,offset GscLoop4

GscLoop3:

        add     eax,1
        jnz     short GscLoop3

;
GscLoop4:
;
; stop counting
;

;
; replace old vector
;
        cli
        mov     [di],cx
        mov     [di+2],dx
        sti

        pop     ds
        pop     si
        pop     di
        jmp     GscDone

newip   dw      ?
savesp  dw      ?

GscISR:
;
; blow out of loop
;
        push    bp
        push    ax
        mov     bp,cs:savesp
        mov     ax,cs:newip
        mov     ss:[bp],ax
        pop     ax
        pop     bp

GscISRdone:
        iret


GscDone:
        mov     edx, eax
        mov     ecx,16
        shr     edx,cl                  ; (dx:ax) = dividend
        mov     cx,0D6A6h               ; (cx) = divisor

        div     cx

        and     eax,0ffffh
        inc     eax                     ; round loopcount up (prevent 0)

;
; Re-enable protect-mode and paging.
;
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       InitializeDisplayForNt
;
; Description:
;
;       Puts the display into 50 line mode
;
; Arguments:
;
;       None
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      InitializeDisplayForNt
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

        mov     ax, 1112h       ; Load 8x8 font
        mov     bx, 0
        int     10h

        RE_ENABLE_PAGING_MACRO

EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetMemoryDescriptor
;
; Description:
;
;       Returns a memory descriptor
;
; Arguments:
;
;       pointer to MemoryDescriptorFrame
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      GetMemoryDescriptor

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <MemoryDescriptorFramePointer>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2


        mov     eax,[bp].E820FramePointer
        mov     bp,ax
        and     bp,0fh
        shr     eax,4
        mov     es,ax                   ; (es:bp) = E820 Frame

        mov     ebx, es:[bp].Key
        mov     ecx, es:[bp].DescSize
        lea     di, [bp].BaseAddrLow
        mov     eax, 0E820h
        mov     edx, 'SMAP'             ; (edx) = signature

        INT     15h
        mov     es:[bp].Key, ebx        ; update callers ebx
        mov     es:[bp].DescSize, ecx   ; update callers size

        sbb     ecx, ecx                ; ecx = -1 if carry, else 0
        sub     eax, 'SMAP'             ; eax = 0 if signature matched
        or      ecx, eax
        mov     es:[bp].ErrorFlag, ecx  ; return 0 or non-zero

;
; Restore bp and remove stack-frame from stack
;

        pop     bp
        REMOVE_STACK_FRAME_MACRO <MemoryDescriptorFramePointer>
        RE_ENABLE_PAGING_MACRO

EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetElToritoStatus
;
; Description:
;
;       Get El Torito Disk Emulation Status
;
; Arguments:
;
;       None
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      GetElToritoStatus
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetElToritoStatusFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2

        push    dx
        push    bx
        push    ds
        push    si

;
; Put the Specification Packet pointer into DS:SI, and the Drive
; Number on DL. Note that and buffer
; addresses passed to this routine MUST be in the lower one
; megabyte of memory to be addressable in real mode.
;

        mov     eax,[bp].SpecPacketPointer
        mov     bx,ax
        and     bx,0fh
        mov     si,bx
        shr     eax,4
        mov     ds,ax

        mov     dl,byte ptr [bp].ETDriveNum

        mov     ax,04B01h                       ; Function = Return Disk Emulation status
        int     BIOS_DISK_INTERRUPT

        jc      etstatuserr

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor     eax,eax

etstatuserr:
;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and     eax,0000ffffh

        pop     si
        pop     ds
        pop     bx
        pop     dx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetElToritoStatusFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       GetExtendedInt13Params
;
; Description:
;
;       Determine if extended int13 services are available for a drive
;       and if so retrieve extended disk parameters.
;
; Arguments:
;
;       - 32-bit flat pointer to 26-byte param packet filled by this routine
;
;       - int 13 unit number
;
; Returns:
;
;       ax = 0 means extended int13 not supported on the given drive
;       ax = 1 means extended int13 supported and param packet filled in
;
;--

EXPORT_ENTRY_MACRO      GetExtendedInt13Params
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetExtendedInt13ParamsFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2

        push    dx
        push    bx
        push    ds
        push    si

;
; Check for support for this drive.
;
        mov     ah,41h
        mov     bx,55aah
        mov     dl,byte ptr [bp].Int13UnitNumber
        int     BIOS_DISK_INTERRUPT
        jc      noxint13                        ; carry set means no xint13
        cmp     bx,0aa55h                       ; check signature
        jnz     noxint13                        ; not present, no xint13
        test    cl,1                            ; bit 0 clear means no xint13
        jz      noxint13

;
; If we get here it looks like we have xint13 support.
; Some BIOSes are broken though so we do some validation while we're
; asking for the extended int13 drive parameters for the drive.
; Note that and buffer addresses passed to this routine
; MUST be in the lower one megabyte of memory to be addressable in real mode.
;
        mov     eax,[bp].ParamPacketPointer
        mov     bx,ax
        and     bx,0fh
        mov     si,bx
        shr     eax,4
        mov     ds,ax                           ; DS:SI -> param packet
        mov     word ptr [si],26                ; initialize packet with size
                                                ; some bioses helpfully zero out
                                                ; the whole buffer according to
                                                ; this size, so make SURE the
                                                ; entire word is initialized and
                                                ; there's no junk in the high byte.

        mov     dl,byte ptr [bp].Int13UnitNumber
        mov     ah,48h
        int     BIOS_DISK_INTERRUPT
        jc      noxint13
;
; If we get here then everything's cool and we have xint13 parameters.
; We also know carry isn't set.
;
        mov     al,1
        jnc     xint13done

noxint13:
        xor     al,al

xint13done:
        movzx   eax,al

        pop     si
        pop     ds
        pop     bx
        pop     dx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetExtendedInt13ParamsFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; ULONG
; NetPcRomServices (
;    ULONG FunctionNumber
;    PVOID CommandPacket
;    )
;
; Routine Name:
;
;       NetPcRomServices
;
; Description:
;
;       Invoke a NetPC ROM service
;
; Arguments:
;
;       FunctionNumber - NetPC ROM function number
;       CommandPacket - 32-bit flat pointer to command packet (must be in
;                       low megabyte of physical memory)
;
; Returns:
;
;       NetPC ROM status code
;
;--

EXPORT_ENTRY_MACRO      NetPcRomServices
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <NetPcRomServicesFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2

;
; Put the CommandPacket pointer into ES:DI, and the Function Number into BX.
;

        mov     eax,dword ptr [bp].NetPcRomCommandPacketPointer
        mov     bx,ax
        and     bx,0fh
        mov     di,bx
        shr     eax,4
        mov     es,ax

        mov     bx,word ptr [bp].NetPcRomFunctionNumber

        push    ds

        lds     si,dword ptr _NetPcRomEntry
        mov     ax,ds
        shl     eax,16
        mov     ax,si

        push    cs
        push    offset _TEXT:RomServiceDone

        push    ds
        push    si

if 0
        push    ds
        push    si
        push    0b800h
        pop     ds
        mov     si, 20*(80*2)+(2*40)
        mov     byte ptr ds:[si],02bh
        pop     si
        pop     ds
endif

        retf

RomServiceDone:

if 0
        push    ds
        push    si
        push    0b800h
        pop     ds
        mov     si, 20*(80*2)+(2*40)
        mov     byte ptr ds:[si],02dh
        pop     si
        pop     ds
endif

        pop     ds

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <NetPcRomServicesFrame>

;
; Save return code on 16bit stack.  Turn the A20 gate back on,
; in case the BIOS turned it off in int 15h, op 87h.
; Re-enable protect-mode and paging.
;

        push     eax

        cli
        call    _EnableA20
        sti

        RE_ENABLE_PAGING_MACRO

        pop      eax

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO



;++
;
; ULONG
; BiosRedirectService (
;    ULONG Command
;    )
;
; Routine Name:
;
;       BiosRedirectService
;
; Description:
;
;       Get parameters of bios redirection.
;
; Arguments:
;
;       Command - 1: Get Com Port Number
;                 2: Get Baud Rate
;                 3: Get Parity
;                 4: Get Stop Bits
;
; Returns:
;
;       Value, or -1 if an error.
;
;--

EXPORT_ENTRY_MACRO      BiosRedirectService
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <BiosRedirectServiceFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2


;
; Get the Command and do it.
;

        mov     eax,dword ptr [bp].Command

        cmp     eax, 1
        je      GetComPort

        cmp     eax, 2
        je      GetBaudRate

        cmp     eax, 3
        je      GetParity

        cmp     eax, 4
        je      GetStopBits

        mov     eax, -1
        jmp     Done



GetStopBits:
        mov     eax, 1
        jmp     Done

GetParity:
        mov     eax, 0
        jmp     Done

GetBaudRate:
IFDEF HDLS_HISPEED
        mov     eax, 115200
else
        mov     eax, 9600
endif
        jmp     Done

GetComPort:
IFDEF HEADLESS_SRV
        mov     eax, HEADLESS_COMPORT
        add     eax, 1
else
        mov     eax, -1
endif

Done:

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <BiosRedirectServiceFrame>

;
; Save return code on 16bit stack.  Turn the A20 gate back on,
; in case the BIOS turned it off in int 15h, op 87h.
; Re-enable protect-mode and paging.
;

        push     eax

        cli
        call    _EnableA20
        sti

        RE_ENABLE_PAGING_MACRO

        pop      eax
;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\memmap.inc ===
PAGE_DIR_ADDRESS        equ     99000h
PAGE_TABLE_ADDRESS      equ     9A000h

;;
;; Address Mappings
;;


PhysAddressVideo        equ     0b8000h
PhysSizeVideo           equ     2000h

SYSTEM_PAGE_PA          equ     17000h
SYSTEM_PAGE_VA          equ     80420000h
GDT_LOC                 equ     0
IDT_LOC                 equ     400h
TSS_LOC                 equ     0C00h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\macro.inc ===
;++
;
; File Name:
;
;       macro.inc
;
; Author:
;
;       Thomas Parslow [tomp]
;
; Created:
;
;       27-Feb-91
;
; Abstract:
;
;       The macros used for creating the exported entry points the
;       OS loader will use for basic h/w dependent services. These
;       services are:
;
;       o       Disk I/O
;       o       Character I/O
;
;
;--


;++
;
; EXPORT_ENTRY_MACRO
; We arrive here from the OS loader with a 32bit CS. That is, we're
; executing the code with cs:eip where cs contains a selector for a
; 32bit flat segment. We want to get to a 16bit cs. That is, cs:ip.
; The entry points are exported as 32bit near pointers to the OS loader.
; All code in the SU module is identity mapped so the flat 32bit offset
; is equal to the physical address.
;
; Therefore, we export the 32bit physical address as the
; entry point and the code may be executed with either the 32bit
; flat cs or the SU module's 16bit based cs.  Before we can switch
; modes we must load all of the segment registers with selectors for
; 16bit segments.  We start by pushing a far pointer to a label in
; the macro and then doing a retf. This allows us to fall through
; to the next instruction, but we're now executing through cs:ip
; with a 16bit CS.
;
; Output:
;
;       (ebx) = pointer to stack frame (and top of 32bit stack).
;

EXPORT_ENTRY_MACRO  macro entryname
        LOCAL    exp1
_TEXT32 segment para use32 public 'CODE'
        ASSUME CS:_TEXT32
ALIGN 4
Public  EntryName
EntryName LABEL near
;
; We've go a 32bit CS:EIP - go to a 16bit CS:IP

        push     dword ptr SuCodeSelector
        push     dword ptr (offset exp1)

        retf
_TEXT32 ends
        ASSUME CS:_TEXT
ALIGN 4
exp1:
;
; Save caller's EBP register and stack pointer (ESP)
;

        push     ebp
        push     ebx
        push     esi
        push     edi
        mov      ebx,esp
;
; Load all the segment registers with 16bit segment selectors
;
        mov      ax,SuDataSelector
        mov      ds,ax
        mov      ss,ax
;
; Set the stack to the top of the segment. We can do this now since
; all of the OS loader's code has already be relocated. Also, we need
; plenty of stack since we'll be calling BIOS routines.
;
        mov      esp,EXPORT_STACK
        push     ebx                  ; save the caller's esp
        endm
;
; EXPORT_ENTRY_MACRO end
;



;++
;
; Name:
;
;       ExportExit
;
; Arguments:
;
;
; Notes:
;
;       EAX = return code and MUST be preserved by this macro.
;
;--

EXPORT_EXIT_MACRO macro
;
; Next get caller's esp that we saved upon entry on the 16bit stack
;
        pop      ebx                    ; get caller's esp
;
; Restore flat selectors in segment registers.
;
        mov      dx,KeDataSelector
        mov      ds,dx
        mov      ss,dx
        mov      es,dx
        mov      esp,ebx


;
; Restore callers' ebp that we saved on the 32bit stack
;
        pop      edi
        pop      esi
        pop      ebx
        pop      ebp      ; (ebp) = caller's ebp

;
; Pull callers flat return address off stack and push the
; flat code selector followed by the return offset, then
; execute a far return and we'll be back in the OS loaders code space.
;
        pop      edx      ; (edx) = caller's return address
        push     dword ptr KeCodeSelector
        push     edx
        db OVERRIDE
        retf
        endm

;++
;
;
;
;--

RE_ENABLE_PAGING_MACRO macro
extrn _EnableProtectPaging:near
        push     RE_ENABLING
        call     _EnableProtectPaging
        add      sp,2
        endm

ENTER_REALMODE_MACRO macro
extrn _RealMode:near
        call    _RealMode
        endm



WAIT_FOREVER_MACRO macro
        LOCAL wf1
wf1:    jmp     wf1
        endm

;++
;
; MAKE_STACK_FRAME_MACRO
;
; Arguments:
;
;    _FrameName_ - is the name of the structure defining the
;                  stack frame layout.
;
;    _PointerRegister_ - is the register containing the linear pointer to
;                        the top of the stack frame.
; ProtectMode ONLY
;
;--

MAKE_STACK_FRAME_MACRO macro _FrameName_ , _PointerRegister_
Local msf1
        mov     ecx, (size _FrameName_)/2
        mov     esi,_PointerRegister_   ; (esi) = offset of argument frame
        add     esi,20                  ; account for ebp, ebx, esi, edi and
                                        ; return address
        push    KeDataSelector          ; (ax) = Flat 32bit segment selector
        pop     ds                      ; (ds:esi) points to argument frame
        push    ss                      ;
        pop     es                      ; (es) = 16bit stack selector
        sub     sp, size _FrameName_    ; make room for the arguments
        xor     edi,edi                 ; clear out upper 16bits of edi
        mov     di,sp                   ; (es:edi) points to top of stack
msf1:
        mov     ax,[esi]
        mov     es:[edi],ax
        add     esi,2
        add     edi,2
        loop    msf1
        push    es                      ;
        pop     ds                      ; put 16bit selector back into ds
        endm


REMOVE_STACK_FRAME_MACRO macro _FrameName_

        add     sp, size _FrameName_
        endm


;BuildDescriptor macro   Base,Limit,Access,Dpl,Stype
;        dw       (Limit AND 0ffffh)
;        dw       (Base AND 0ffffh)
;        db       ((Base SHR 16) AND 0ffh)
;        db       (Gran + Dpl + Stype)
;        db       ((Limit SHR 16) AND 0ffh)
;        db       ((Base SHR 24) AND 0ffh)
;        endm



;
;
;
RETURNCODE_IN_EAX_MACRO macro

        shl      edx,16
        mov      dx,ax
        mov      eax,edx
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\memmap.h ===
//
// The following memory address definitions apply to
// indentity mapped objects for the x86 environment.
//

#define RM_PROTECT_BASE_VA          0x000000
#define RM_PROTECT_BASE_PA          0x000000
#define RM_PROTECT_SIZE             0x001000
#define RM_PROTECT_ATTRIBUTES       PAGE_ROSP

#define BPB_BASE_VA                 0x007000
#define BPB_BASE_PA                 0x007000
#define BPB_SIZE                    0x001000
#define BPB_ATTRIBUTES              PAGE_ROSP

#define SU_MODULE_BASE_VA           0x020000
#define SU_MODULE_BASE_PA           0x020000
#define SU_MODULE_SIZE              0x020000
#define SU_MODULE_ATTRIBUTES        PAGE_RWSP

#define LOADER_BASE_VA              0x040000
#define LOADER_BASE_PA              0x040000
#define LOADER_SIZE                 0x020000
#define LOADER_ATTRIBUTES           PAGE_RWSP

#define SYSTEM_STRUCTS_BASE_VA      0x80420000
#define SYSTEM_STRUCTS_BASE_PA      0x00017000
#define SYSTEM_STRUCTS_SIZE         0x002000
#define SYSTEM_STRUCTS_ATTRIBUTES   PAGE_RWSP + PAGE_PERSIST

#define PAGE_TABLE_AREA_BASE_VA     0x00099000
#define PAGE_TABLE_AREA_BASE_PA     0x00099000
#define PAGE_TABLE_AREA_SIZE        0x002000
#define PAGE_TABLE_AREA_ATTRIBUTES  PAGE_RWSP + PAGE_PERSIST

#define LDR_STACK_BASE_VA           0x09b000
#define LDR_STACK_BASE_PA           0x09b000
#define LDR_STACK_SIZE              0x001000
#define LDR_STACK_ATTRIBUTES        PAGE_RWSP
#define LDR_STACK_POINTER           0x09bffe // in su.inc also

#define VIDEO_BUFFER_BASE_VA        0x0B8000
#define VIDEO_BUFFER_BASE_PA        0x0B8000
#define VIDEO_BUFFER_SIZE           0x004000
#define VIDEO_BUFFER_ATTRIBUTES     PAGE_RWSP


#define HYPER_PAGE_DIRECTORY        0xC0300C00
#define HYPER_SPACE_BEGIN           0xC0000000  // points to 1st page table
#define HYPER_SPACE_SIZE            0x8000L
#define HYPER_SPACE_ENTRY           768
#define PAGE_TABLE1_ADDRESS         0xC0000000L
#define PD_PHYSICAL_ADDRESS         PAGE_TABLE_AREA_BASE_PA  // in su.inc also.
#define PT_PHYSICAL_ADDRESS         PAGE_TABLE_AREA_BASE_PA + PAGE_SIZE
#define VIDEO_ENTRY                 0xB8

/*



Switching to Realmode
~~~~~~~~~~~~~~~~~~~~~

When switching to realmode "sp" will be initialized to
0xfffe and (ss) will be set to the base of the SU module's
data segment. This has several effects.

 1) The stack will remain withing the 0x20000 - 0x3ffff range
    reserved for the original SU module and loader image prior to
    relocation, and since the loader will already have been relocated
    it is no longer necessary to preserve this area.

 2) This will preserve the SU module's small model character which
    requires that offsets can be used interchangably through (ss) or (ds).

 3) This allows for the maximum stack size for small model apps (which is
    what the SU module is). Bios calls should not be tromping on any
    data or code while in realmode.

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\global.h ===
/*++

Copyright (c) 1990  Microsoft Corporation


File Name:

   global.h


Abstract:

     Prototypes for all global functions defined for the 386 NT bootloader


Author

    Thomas Parslow  (TomP) 2-Jan-90



--*/


VOID
SuMain(
    IN ULONG BtBootDrive
    );

extern
USHORT
Debugger;


/////
///// IN sumain.c
/////


VOID
SetupPageTables(
    VOID
    );


//
// in Supage.c
//

extern
VOID
InitializePageTables(
    VOID
    );

VOID
ZeroMemory(
    ULONG,
    ULONG
);



USHORT DebuggerPresent;

VOID
PrintBootMessage(
    VOID
    );

/*
VOID
DoGlobalInitialization(
    IN FPVOID,
    IN FPDISKBPB,
    IN USHORT
    );


VOID
MoveMemory(
    IN ULONG,
    IN PUCHAR,
    IN USHORT
    );


/////
///// IN disk.c
/////

VOID
InitializeDiskSubSystem(
    IN FPDISKBPB,
    IN USHORT
    );

/*

VOID
InitializePageSets(
    IN PIMAGE_FILE_HEADER
    );

VOID
EnableA20(
    VOID
    );


extern IDT IDT_Table;

*/

/////
///// IN su.asm
/////


VOID
EnableProtectPaging(
    USHORT
    );


SHORT
biosint(
    IN BIOSREGS far *
    );

extern
VOID
TransferToLoader(
    ULONG
    );


/////
///// IN video.c
/////

VOID
InitializeVideoSubSystem(
    VOID
    );

VOID
putc(
    IN CHAR
    );
VOID
putu(
    IN ULONG
    );

VOID
puts(
    IN PCHAR
    );

VOID
puti(
    IN LONG
    );

VOID
putx(
    IN ULONG
    );

VOID
scroll(
    VOID
    );

VOID
clrscrn(
    VOID
    );

VOID
BlPrint(
    IN PCHAR,
    ...
    );


// END OF FILE //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\eisac.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisac.c

Abstract:

    This module implements routines to get EISA configuration information.

Author:

    Shie-Lin Tzong (shielint) 10-June-1991

Environment:

    16-bit real mode.


Revision History:

    John Vert (jvert) 5-Sep-1991
        Moved into the SU module of portable bootloader

--*/
#include "su.h"
#include "eisa.h"

//
// HACKHACK - John Vert (jvert) 12-Sep-1991
//      We have to initialize this or else it gets stuck in our BSS section
//      which is right in the middle of the osloader.exe header
//
extern BTEISA_FUNCTION_INFORMATION FunctionInformation;


BOOLEAN
FindFunctionInformation (
    IN UCHAR SlotFlags,
    IN UCHAR FunctionFlags,
    OUT PBTEISA_FUNCTION_INFORMATION Buffer,
    IN BOOLEAN FromBeginning
    )

/*++

Routine Description:

    This routine finds function information that matches the specified
    flags.  It starts, either where it left off last time, or at the
    beginning (slot 0, function 0)

Arguments:

    Flags - Flags to check against EISA function and slot information.

    Buffer - pointer to buffer to store EISA information in.

    FromBeginning - if TRUE, search starts at slot 0, function 0.
                    else continue from where it left off last time.

Return Value:

    TRUE - If the operation is success (Buffer is filled in.)
    FALSE - Request fails.

    Notes: The buffer is always changed, reguardless of the success
    of the function.  When failure is returned, the info is invalid.

--*/

{
    static UCHAR Slot=0;
    static UCHAR Function=0;
    BTEISA_SLOT_INFORMATION  SlotInformation;
    UCHAR Flags;
    UCHAR ReturnCode;

    if (FromBeginning) {
        Slot = 0;
        Function = 0;
    }
    BtGetEisaSlotInformation(&SlotInformation, Slot);
    while (SlotInformation.ReturnCode != EISA_INVALID_SLOT) {

        //
        // insure that the slot is not empty, and all of the flags are set.
        // the flags are tested by performing the following logic:
        //
        // -- (RequestSlotFlags XOR (SlotFlags AND RequestSlotFlags)) --
        //
        // if all the requested flags are set, the result will be zero
        //

        if ((SlotInformation.ReturnCode != EISA_EMPTY_SLOT) &&
            (!(SlotFlags ^ (SlotInformation.FunctionInformation & SlotFlags)))) {

            while (SlotInformation.NumberFunctions > Function) {
                ReturnCode = BtGetEisaFunctionInformation(Buffer, Slot, Function);
                Function++;

                //
                // if function call succeeded
                //

                if (!ReturnCode){

                    Flags = Buffer->FunctionFlags;

                    //
                    // Function Enable/Disable bit reversed.
                    //

                    Flags |= (~Flags & EISA_FUNCTION_ENABLED);

                    //
                    // insure that all the function flags are set.
                    // the flags are tested by performing the following logic:
                    //
                    // -- (ReqFuncFlags XOR (FuncFlags AND ReqFuncFlags)) --
                    //
                    // if all the requested flags are set, the result will
                    // be zero
                    //

                    if (!(FunctionFlags ^ (Flags & FunctionFlags))) {
                        return TRUE;
                    }
                }

            }
        }
        Slot++;
        Function = 0;
        BtGetEisaSlotInformation(&SlotInformation, Slot);
    }

    Slot = 0;
    Function = 0;
    return FALSE;
}

VOID
InsertDescriptor (
    ULONG Address,
    ULONG Size
    )

/*++

Routine Description:

    This routine inserts a descriptor into the correct place in the
    memory descriptor list.

Arguments:

    Address - Starting address of the memory block.

    Size - Size of the memory block to be inserted.

Return Value:

    None.

--*/

{
    MEMORY_LIST_ENTRY _far *CurrentEntry;

#ifdef DEBUG1
    BlPrint("Inserting descriptor %lx at %lx\n",Size,Address);
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif
    //
    // Search the spot to insert the new descriptor.
    //

    CurrentEntry = MemoryDescriptorList;

    while (CurrentEntry->BlockSize > 0) {
        //
        // Check to see if this memory descriptor is contiguous with
        // the current one.  If so, coalesce them.  (yes, some machines
        // will return memory descriptors that look like this.  Compaq
        // Prosignia machines)
        //
        if (Address+Size == CurrentEntry->BlockBase) {
#ifdef DEBUG1
            BlPrint("  coalescing with descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            CurrentEntry->BlockBase = Address;
            CurrentEntry->BlockSize += Size;
#ifdef DEBUG1
            BlPrint("  new descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            break;
        }
        if (Address == (CurrentEntry->BlockBase + CurrentEntry->BlockSize)) {
#ifdef DEBUG1
            BlPrint("  coalescing with descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            CurrentEntry->BlockSize += Size;
#ifdef DEBUG1
            BlPrint("  new descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            break;
        }

        CurrentEntry++;
    }

    if (CurrentEntry->BlockSize == 0) {
        //
        // If CurrentEntry->BlockSize == 0, we  have reached the end of the list
        // So, insert the new descriptor here, and create a new end-of-list entry
        //
        CurrentEntry->BlockBase = Address;
        CurrentEntry->BlockSize = Size;

        ++CurrentEntry;
        //
        // Create a new end-of-list marker
        //
        CurrentEntry->BlockBase = 0L;
        CurrentEntry->BlockSize = 0L;
    }
#ifdef DEBUG1
    //
    // Wait for a keypress
    //
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif

}

ULONG
EisaConstructMemoryDescriptors (
    VOID
    )

/*++

Routine Description:

    This routine gets the information EISA memory function above 16M
    and creates entries in the memory Descriptor array for them.

Arguments:

    None.

Return Value:

    Number of pages of usable memory.

--*/

{
    BOOLEAN Success;
    PBTEISA_MEMORY_CONFIGURATION MemoryConfiguration;
    ULONG Address;
    ULONG EndAddress;
    ULONG Size;
    ULONG MemorySize=0;
    ULONG IsaMemUnder1Mb=0xffffffff;
    MEMORY_LIST_ENTRY _far *CurrentEntry;

    //
    // HACKHACK John Vert (jvert) 5-Mar-1993
    //
    // See if there is already a memory descriptor for the 640k under
    // 1Mb.  If so, we will believe it instead of the EISA routine.  This
    // is because many EISA routines will always return 640k, even if
    // the disk parameter table is in the last 1k.  The ISA routines will
    // always account for the disk parameter tables.  If we believe the
    // EISA routines, we can overwrite the disk parameter tables, causing
    // much grief.
    //
    CurrentEntry = MemoryDescriptorList;
    while (CurrentEntry->BlockSize > 0) {
        if (CurrentEntry->BlockBase == 0) {
            //
            // found a descriptor starting at zero with a size > 0, so
            // this is the one we want to override the EISA information.
            //
            IsaMemUnder1Mb = CurrentEntry->BlockSize;
            break;
        }
        ++CurrentEntry;
    }

    //
    // Initialize the first entry in the list to zero (end-of-list)
    //

    MemoryDescriptorList->BlockSize = 0;
    MemoryDescriptorList->BlockBase = 0;

    Success = FindFunctionInformation(
                              EISA_HAS_MEMORY_ENTRY,
                              EISA_FUNCTION_ENABLED | EISA_HAS_MEMORY_ENTRY,
                              &FunctionInformation,
                              TRUE
                              );

    //
    // while there are more memory functions, and more free descriptors
    //

    while (Success) {

        MemoryConfiguration = &FunctionInformation.EisaMemory[0];

        do {

            //
            // Get physical address of the memory.
            // Note: physical address is stored divided by 100h
            //

            Address = (((ULONG)MemoryConfiguration->AddressHighByte << 16)
                      + MemoryConfiguration->AddressLowWord) * 0x100;

            //
            // Get the size of the memory block.
            // Note: Size is stored divided by 400h with the value of 0
            //       meaning a size of 64M
            //

            if (MemoryConfiguration->MemorySize) {
                Size = ((ULONG)MemoryConfiguration->MemorySize) * 0x400;
            } else {
                Size = (_64MEGB);
            }

#ifdef DEBUG1
            BlPrint("EISA memory at %lx  Size=%lx  Type=%x ",
                    Address,
                    Size,
                    MemoryConfiguration->ConfigurationByte);

            if ((MemoryConfiguration->ConfigurationByte.Type == EISA_SYSTEM_MEMORY) &&
                (MemoryConfiguration->ConfigurationByte.ReadWrite == EISA_MEMORY_TYPE_RAM) ) {

                BlPrint("  (USED BY NT)\n");
            } else {
                BlPrint("  (not used)\n");
            }
#endif

            //
            // Compute end address to determine if any part of the block
            // is above 16M
            //

            EndAddress = Address + Size;

            //
            // If it is SYSTEM memory and RAM, add the descriptor to the list.
            //

            if ((MemoryConfiguration->ConfigurationByte.Type == EISA_SYSTEM_MEMORY) &&
                (MemoryConfiguration->ConfigurationByte.ReadWrite == EISA_MEMORY_TYPE_RAM) ) {

                if (Address==0) {
                    //
                    // This is the descriptor for the memory under 1Mb.
                    // Compare it with the ISA routine's result, and see
                    // if the ISA one is smaller.  If it is, use the ISA
                    // answer.
                    //
                    if (Size > IsaMemUnder1Mb) {
                        Size = IsaMemUnder1Mb;
                    }
                }
                InsertDescriptor(Address, Size);
                MemorySize += (Size >> 12);
            }

        } while (MemoryConfiguration++->ConfigurationByte.MoreEntries);

        Success = FindFunctionInformation(
                                  EISA_HAS_MEMORY_ENTRY,
                                  EISA_FUNCTION_ENABLED | EISA_HAS_MEMORY_ENTRY,
                                  &FunctionInformation,
                                  FALSE
                                  );
    }
#ifdef DEBUG1
    //
    // Wait for a keypress
    //
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif
    return(MemorySize);
}

BOOLEAN
Int15E820 (
    E820Frame       *Frame
    );


BOOLEAN
ConstructMemoryDescriptors (
    VOID
    )
/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    ULONG           BAddr, EAddr;
    E820Frame       Frame;

    //
    // Initialize the first entry in the list to zero (end-of-list)
    //

    MemoryDescriptorList->BlockSize = 0;
    MemoryDescriptorList->BlockBase = 0;

    //
    // Any entries returned for E820?
    //

    Frame.Key = 0;
    Frame.Size = sizeof (Frame.Descriptor);
    Int15E820 (&Frame);
    if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {
        return FALSE;
    }

    //
    // Found memory in table, use the reported memory
    //

    Frame.Key = 0;
    do {
        Frame.Size = sizeof (Frame.Descriptor);
        Int15E820 (&Frame);
        if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {
            break ;
        }

#ifdef DEBUG1
        BlPrint("E820: %lx  %lx:%lx %lx:%lx %lx %lx\n",
            Frame.Size,
            Frame.Descriptor.BaseAddrHigh,  Frame.Descriptor.BaseAddrLow,
            Frame.Descriptor.SizeHigh,      Frame.Descriptor.SizeLow,
            Frame.Descriptor.MemoryType,
            Frame.Key
            );

            _asm {
                push    ax
                mov     ax, 0
                int     16h
                pop     ax
            }
#endif

        BAddr = Frame.Descriptor.BaseAddrLow;
        EAddr = Frame.Descriptor.BaseAddrLow + Frame.Descriptor.SizeLow - 1;

        //
        // All the processors we have right now only support 32 bits
        // If the upper 32 bits of the Base Address is non-zero, then
        // this range is entirely above the 4g mark and can be ignored
        //

        if (Frame.Descriptor.BaseAddrHigh == 0) {

            if (EAddr < BAddr) {
                //
                // address wrapped - truncate the Ending address to
                // 32 bits of address space
                //

                EAddr = 0xFFFFFFFF;
            }

            //
            // Based upon the address range descriptor type, find the
            // available memory and add it to the descriptor list
            //

            switch (Frame.Descriptor.MemoryType) {
                case 1:
                    //
                    // This is a memory descriptor
                    //

                    InsertDescriptor (BAddr, EAddr - BAddr + 1);
                    break;
            }
        }

    } while (Frame.Key) ;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\mtftp.c ===
#include "su.h"
#include "pxe_cmn.h"
#include "pxe_api.h"
#include "tftp_api.h"
#include "udp_api.h"
#include "dhcp.h"
#include "pxe.h"



#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))


//
// packet - Work buffer used to hold DHCP ACK and BINL REPLY packets.
//          These packets will be read into this buffer using the
//          PXENV API service PXENV_GET_BINL_INFO.
//

BOOTPLAYER packet;

//
// PxenvApiCall() - see su.asm for details
//

extern UINT16
PxenvApiCall(
    UINT16 service,
    void far *param
);


//
// GetPacket()
//
// Description:
//  Get cached packet from PXENV API.
//
// Passed:
//  packet := Far pointer to packet buffer
//  packet_type := see pxe_api.h for PXENV_PACKET_TYPE_xxx #defines
//
// Returns:
//  -1 := Packet could not be transfered to buffer
//  size := Number of bytes transfered into packet buffer
//
// Warning:
//  No check is made to see if buffer is actually large enough to
//  hold the entire packet.  The buffer should be of type BOOTPLAYER.
//

SHORT
GetPacket(
    void far *packet,
    UINT16 packet_type
)
{
    t_PXENV_GET_BINL_INFO gbi;

    //
    // Check for invalid parameters
    //

    if (packet == NULL) {
        BlPrint("\nGetPacket()  NULL pointers\n");
        return -1;
    }

    //
    // Request size of packet by sending a size of zero.
    //

    gbi.packet_type = packet_type;
    gbi.buffer_size = 0;

    if (PxenvApiCall(PXENV_GET_BINL_INFO, &gbi) != PXENV_EXIT_SUCCESS) {
        BlPrint("\nGetPacket()  PXENV API FAILURE #1\n");
        return -1;
    }

    //
    // Transfer cached packet into buffer.
    //

    gbi.buffer_offset = FP_OFF(packet);
    gbi.buffer_segment = FP_SEG(packet);

    if (PxenvApiCall(PXENV_GET_BINL_INFO, &gbi) != PXENV_EXIT_SUCCESS) {
        BlPrint("\nGetPacket()  PXENV API FAILURE #2\n");
        return -1;
    }

    return (SHORT)gbi.buffer_size;
}


//
// FindOption()
//
// Description:
//  Find the subnet mask option in a DHCP packet.
//
// Passed:
//  Packet := IN Pointer to DHCP packet.
//  PacketLength := IN Length of DHCP packet.
//  pLength := OUT Length of option.
//
// Returns:
//  pointer to option data; NULL if not present
//

UINT32 *
FindOption(
    UINT8 Option,
    BOOTPLAYER *Packet,
    UINT16 PacketLength,
    UINT8 * pLength
    )
{
    UINT8 *options;
    UINT8 *end;

    //
    // Verify parameters
    //

    if (pLength != NULL) {
        *pLength = 0;
    }

    if ( *((ULONG *)Packet->vendor.v.magic) != VM_RFC1048 ) {
        return NULL;
    }

    end = (UINT8 *)Packet + PacketLength;

    for ( options = (UINT8 *)&Packet->vendor.v.flags;
          options < end; ) {

        if ( *options == Option ) {
            if (pLength != NULL) {
                *pLength = *(UINT8*)(options + 1);
            }
            return (UINT32 *)(options + 2);
        }

        if ( *options == 0xFF ) {
            return NULL;
        }

        if ( *options == DHCP_PAD ) {
            options++;
        } else {
            options += 2 + options[1];
        }
    }

    return NULL;
}


UCHAR *
FindVendorOption(
    UINT8 Option,
    UINT8 VendorOption,
    BOOTPLAYER *Packet,
    UINT16 PacketLength,
    UINT8 * pLength
    )
{
    UINT8 *start;
    UINT8 *options;
    UINT8 *end;
    UCHAR cb;

    if (pLength != NULL) {
        *pLength = 0;
    }

    start = (UINT8*)FindOption( Option, Packet, PacketLength, &cb );
    if (start == NULL) {
        return NULL;
    }

    end = (UINT8 *)start + cb;

    for ( options = start;
          options < end; ) {

        if ( *options == VendorOption ) {
            if (pLength != NULL) {
                *pLength = *(UINT8*)(options + 1);
            }
            return (UCHAR *)(options + 2);
        }

        if ( *options == 0xFF ) {
            return NULL;
        }

        if ( *options == DHCP_PAD ) {
            options++;
        } else {
            options += 2 + options[1];
        }
    }

    return NULL;
}


//
// strlen()
//
// Description:
//  Works like std C.
//

int
strlen(UCHAR *s1)
{
    int n = 0;

    if (s1 != NULL)
        while (*s1++)
            ++n;

    return n;
}


//
// strcpy()
//
// Description:
//  Works like std C.
//

UCHAR *
strcpy(UCHAR *s1, UCHAR *s2)
{
    UCHAR *s = s1;

    if (s1 != NULL && s2 != NULL)
        while ((*s1++ = *s2++) != 0)
            ;

    return s;
}


//
// strncpy()
//
// Description:
//  Works like std C.
//

UCHAR *
strncpy(UCHAR *s1, UCHAR *s2, int n)
{
    UCHAR *s = s1;

    if (s1 != NULL && s2 != NULL && n > 0)
        while (n--)
            if ((*s1++ = *s2++) == 0)
                break;

    return s;
}


//
// memset()
//
// Description:
//  Works like std C.
//

PUCHAR
memset(
    PUCHAR Destination,
    UCHAR Value,
    int Length
    )
{
    while (Length--) {
        *Destination++ = Value;
    }

    return Destination;
}


//
// PxenvTftp()
//
// Description:
//  Try to transfer the protect-mode loader using information from
//  DHCP ACK and BINL REPLY packets.
//
// Passed:
//  DownloadAddr := Physical address, in client machine, to transfer to.
//  FileName := File name sent down in BINL REPLY packet.
//

BOOLEAN
PxenvTftp(
)
{
    UINT16 status;
    UINT16 packetLength;
    t_PXENV_TFTP_READ_FILE tftp;
    int pathLength;
    UINT32 clientIp;
    UINT32 serverIp;
    UINT32 gatewayIp;
    UINT32 *optionPtr;
    UINT32 subnetMask;
    UCHAR *FileName;
    UCHAR cb;
    UCHAR *optionVendor;


    //
    // Get the DHCP ACK packet.
    //

    if ((packetLength = GetPacket(&packet, PXENV_PACKET_TYPE_DHCP_ACK)) == -1) {
        return TRUE;
    }

    //
    // Get client IP address, server IP address, default gateway IP address,
    // and subnet mask from the DHCP ACK packet.
    //

    clientIp = *(UINT32 *)packet.yip;
    serverIp = *(UINT32 *)packet.sip;
    //BlPrint("PxenvTftp:  DHCP ACK yip = %lx, sip = %lx\n", *(UINT32 *)packet.yip, *(UINT32 *)packet.sip);

    optionPtr = FindOption( DHCP_ROUTER, &packet, packetLength, NULL );
    if ( optionPtr != NULL ) {
        //BlPrint("PxenvTftp:  DHCP ACK router = %lx\n", *optionPtr);
        gatewayIp = *optionPtr;
    } else {
        //BlPrint("PxenvTftp:  DHCP ACK gip = %lx\n", *(UINT32 *)packet.gip);
        gatewayIp = *(UINT32 *)packet.gip;
    }

    optionPtr = FindOption( DHCP_SUBNET, &packet, packetLength, NULL );
    if ( optionPtr != NULL ) {
        //BlPrint("PxenvTftp:  DHCP ACK subnet = %lx\n", *optionPtr);
        subnetMask = *optionPtr;
    } else {
        //BlPrint("PxenvTftp:  DHCP ACK subnet not specified\n");
        subnetMask = 0;
    }

    //
    // Get the BINL REPLY packet.
    //

    if ((packetLength = GetPacket(&packet, PXENV_PACKET_TYPE_BINL_REPLY)) == -1) {
        return TRUE;
    }

    //
    // Values for client IP address, server IP address, default gateway IP address,
    // and subnet mask that are present in the BINL REPLY packet override those
    // in the DHCP ACK packet.
    //

    if ( *(UINT32 *)packet.yip != 0 ) {
        clientIp = *(UINT32 *)packet.yip;
    }
    if ( *(UINT32 *)packet.sip != 0 ) {
        serverIp = *(UINT32 *)packet.sip;
    }
    //BlPrint("PxenvTftp:  BINL REPLY yip = %lx, sip = %lx\n", *(UINT32 *)packet.yip, *(UINT32 *)packet.sip);

    optionPtr = FindOption( DHCP_ROUTER, &packet, packetLength, NULL );
    if ( optionPtr != NULL ) {
        //BlPrint("PxenvTftp:  BINL REPLY router = %lx\n", *optionPtr);
        gatewayIp = *optionPtr;
    } else if ( *(UINT32 *)packet.gip != 0 ) {
        //BlPrint("PxenvTftp:  BINL REPLY router = %lx\n", *(UINT32 *)packet.gip);
        gatewayIp = *(UINT32 *)packet.gip;
    }

    optionPtr = FindOption( DHCP_SUBNET, &packet, packetLength, NULL );
    if ( optionPtr != NULL ) {
        //BlPrint("PxenvTftp:  BINL REPLY subnet = %lx\n", *optionPtr);
        subnetMask = *optionPtr;
    }

    //
    // Determine whether we need to send packets via the gateway.
    //

    //BlPrint("PxenvTftp:  clientIp = %lx, serverIp = %lx, subnet = %lx\n", clientIp, serverIp, subnetMask);
    //BlPrint("            router = %lx\n", gatewayIp);
    if ( (clientIp & subnetMask) == (serverIp & subnetMask) ) {
        //BlPrint("PxenvTftp:  subnets match. clearing router address\n");
        gatewayIp = 0;
    }
    //PxenvApiCall(-1, NULL);


    //
    // Now fill in the TFTP TRANSFER parameter structure
    //

    memset( (PUCHAR)&tftp, 0, sizeof( tftp ) );

    //
    // Find the name and path of the NTLDR that we are going to download.
    // This is specified by a DHCP Vendor option tag. If this tag
    // is missing we will default to NTLDR and the same path as 
    // startrom.com.
    //
    FileName = (UCHAR*)FindOption( DHCP_LOADER_PATH, &packet, packetLength, &cb );
    if ( FileName == NULL || cb > 128 ) {
        //
        // We could not find the DHCP_LOADER_PATH or it was longer 
        // than we expected. We will use the default name of 
        // <path>\NTLDR where the <path> is the same as that used 
        // to download startrom.com
        //

        pathLength = strlen(packet.bootfile);
        while (pathLength > 0) {
            --pathLength;
            if (packet.bootfile[pathLength] == '\\') {
                ++pathLength;  // advance it past the '\'
                break;
            }
        }

        strncpy(tftp.FileName, packet.bootfile, pathLength);
        strcpy(tftp.FileName + pathLength, "NTLDR");

    } else {

        // We found the DHCP_LOADER_PATH option. We will use that 
        // as is to download the loader
        strncpy(tftp.FileName, FileName, cb);
        
    }

    //
    // Loader will be transfered to 1MB region and must not be more 
    // than to 2MB in length.
    //

    tftp.BufferSize = 0x200000L;
    tftp.BufferOffset = 0x100000L; 

    //
    // Set the Server and gateway address
    //
    *((UINT32 *)tftp.ServerIPAddress) = serverIp;
    *((UINT32 *)tftp.GatewayIPAddress) = gatewayIp;

    //
    // Check whether we are going to use multicast download or not. The 
    // multicast options are set in a DHCP option tag (DHCP_LOADER_MCAST_OPTIONS).
    // These are encapsulated options and work the same way as Vendor options.
    // If these are missing then unicast transfer will be used.
    //
    optionVendor = FindVendorOption( DHCP_LOADER_MCAST_OPTIONS, PXE_MTFTP_IP, &packet, packetLength, &cb );
    if ( optionVendor != NULL && cb == 4 ) {

        *(UINT32*)tftp.McastIPAddress = *(UINT32*)optionVendor;

        optionVendor = FindVendorOption( DHCP_LOADER_MCAST_OPTIONS, PXE_MTFTP_CPORT, &packet, packetLength, &cb );
        if (optionVendor == NULL || cb != 2) {
            return TRUE;
        }

        tftp.TFTPClntPort = htons( *(UINT16*)optionVendor );

        optionVendor = FindVendorOption( DHCP_LOADER_MCAST_OPTIONS, PXE_MTFTP_SPORT, &packet, packetLength, &cb );
        if (optionVendor == NULL || cb != 2) {
            return TRUE;
        }

        tftp.TFTPSrvPort = htons( *(UINT16*)optionVendor );

        optionVendor = FindVendorOption( DHCP_LOADER_MCAST_OPTIONS, PXE_MTFTP_TMOUT, &packet, packetLength, &cb );
        if (optionVendor == NULL || cb != 1) {
            return TRUE;
        }

        tftp.TFTPOpenTimeOut = *(UINT8*)optionVendor;

        optionVendor = FindVendorOption( DHCP_LOADER_MCAST_OPTIONS, PXE_MTFTP_DELAY, &packet, packetLength, &cb );
        if (optionVendor == NULL || cb != 1) {
            return TRUE;
        }

        tftp.TFTPReopenDelay = *(UINT8*)optionVendor;
    }
    

#if DBG

    BlPrint("Downloading Loader:\n");
    BlPrint("FileName = %s\n", tftp.FileName );
    BlPrint("BufferSize = %lx\n", tftp.BufferSize );
    BlPrint("BufferOffset = %lx\n", tftp.BufferOffset );
    BlPrint("ServerIPAddress = %d.%d.%d.%d\n", 
        tftp.ServerIPAddress[0], 
        tftp.ServerIPAddress[1], 
        tftp.ServerIPAddress[2], 
        tftp.ServerIPAddress[3] );
    BlPrint("GatewayIPAddress = %d.%d.%d.%d\n", 
        tftp.GatewayIPAddress[0], 
        tftp.GatewayIPAddress[1], 
        tftp.GatewayIPAddress[2], 
        tftp.GatewayIPAddress[3] );
    BlPrint("McastIPAddress = %d.%d.%d.%d\n", 
        tftp.McastIPAddress[0], 
        tftp.McastIPAddress[1], 
        tftp.McastIPAddress[2], 
        tftp.McastIPAddress[3] );
    BlPrint("TFTPClntPort = %d\n", htons( tftp.TFTPClntPort ) );
    BlPrint("TFTPSrvPort = %d\n", htons( tftp.TFTPSrvPort ) );
    BlPrint("TFTPOpenTimeOut = %d\n", tftp.TFTPOpenTimeOut );
    BlPrint("TFTPReopenDelay = %d\n", tftp.TFTPReopenDelay );

    BlPrint("\n\nPress any key to start download...\n" );

    _asm {
        push    ax
        mov     ax, 0
        int     16h
        pop     ax
    }

#endif

    //
    // Transfer image from TFTP server
    //
    status = PxenvApiCall(PXENV_TFTP_READ_FILE, &tftp);
    if (status != PXENV_EXIT_SUCCESS) {
        return TRUE;
    }

    return FALSE;
}

/* EOF - mtftp.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\main.c ===
/*++

Copyright (c) 1991  Microsoft Corporation


Module Name:

    main.c

Abstract:

    Main for the SU (startup) module for the OS loader. The SU module
    must take the x86 from a real-mode 16bit state to a FLAT model,
    32bit protect/paging enabled state.

Author:

    Thomas Parslow (tomp) Created 20-Dec-90


Revision History:

--*/


int _acrtused = 0;

#define NTAPI

#include "su.h"
#include "eisa.h"

#define _SYS_GUID_OPERATORS_
#include <guiddef.h>
// Prevent ntimage.h from defining the COM+ IL structs and enums.  The enum
// has a value > 16 bits so the 16-bit build fails.  The startrom code doesn't
// need to know about COM+ IL.
#define __IMAGE_COR20_HEADER_DEFINED__
#include "ntimage.h"

#include "strings.h"

#include "pxe_cmn.h"
#include "pxe_api.h"
#include "undi_api.h"

#include <sdistructs.h>

extern VOID RealMode(VOID);
extern USHORT IDTregisterZero;
extern IMAGE_DOS_HEADER edata;
extern VOID MoveMemory(ULONG,ULONG,ULONG);
extern USHORT SuStackBegin;
extern UCHAR Beginx86Relocation;
extern UCHAR Endx86Relocation;
extern USHORT BackEnd;
extern ULONG FileStart;
extern BOOLEAN IsNpxPresent(VOID);
extern USHORT HwGetProcessorType(VOID);
extern USHORT HwGetCpuStepping(USHORT);
extern ULONG MachineType;
extern ULONG OsLoaderStart;
extern ULONG OsLoaderEnd;
extern ULONG ResourceDirectory;
extern ULONG ResourceOffset;
extern ULONG OsLoaderBase;
extern ULONG OsLoaderExports;
extern ULONG NetPcRomEntry;
extern ULONG BootFlags;
extern ULONG NtDetectStart;
extern ULONG NtDetectEnd;
extern ULONG SdiAddress;

extern
TurnMotorOff(
    VOID
    );

extern
EnableA20(
    VOID
    );

extern
BOOLEAN
ConstructMemoryDescriptors(
    VOID
    );

extern
USHORT
IsaConstructMemoryDescriptors(
    VOID
    );

VOID
Relocatex86Structures(
    VOID
    );

ULONG
RelocateLoaderSections(
    OUT PULONG Start,
    OUT PULONG End
    );

t_PXENV_ENTRY far *
PxenvGetEntry(
    VOID
);

BOOLEAN
PxenvVerifyEntry(
    t_PXENV_ENTRY far *entry
);

extern UINT16
PxenvApiCall(
    UINT16 service,
    void far *param
);

BOOLEAN
PxenvTftp(
);

VOID 
Reboot(
    VOID
    );

VOID 
Wait(
    IN ULONG WaitTime
    );

ULONG
GetTickCount(
    VOID
    );
    
extern
FSCONTEXT_RECORD
FsContext;

#define REVISION_NUMBER "1.1"
#define DISK_TABLE_VECTOR (0x1e*4)

VOID
SuMain(
    IN ULONG BtBootDrive
    )
/*++

Routine Description:

    Main entrypoint of the SU module. Control is passed from the boot
    sector to startup.asm which does some run-time fixups on the stack
    and data segments and then passes control here.

Arguments:

    BtBootDrive - The low byte contains the drive that we booted from (int13
        unit number). If 0x41, this is an SDI boot, and the upper three bytes
        of BtBootDrive contain the upper three bytes of the physical address
        of the SDI image (which must be page aligned)

Returns:

    Does not return. Passes control to the OS loader

--*/
{
    ULONG LoaderEntryPoint;
    ULONG EisaNumPages;
    USHORT IsaNumPages;
    MEMORY_LIST_ENTRY _far *CurrentEntry;
    IMAGE_OPTIONAL_HEADER far *OptionalHeader;
    ULONG BlockEnd;
    ULONG ImageSize;
    ULONG ImageBase;
    UCHAR bootDrive;

    //
    // Get the boot drive out of the input argument. If this is an SDI boot,
    // store the SDI address in the boot context record.
    //

    bootDrive = (UCHAR)BtBootDrive;
    if ( bootDrive == 0x41 ) {
        SdiAddress = BtBootDrive & ~(PAGE_SIZE - 1);
    }

    //
    // Save fs context info
    //
    FsContext.BootDrive = bootDrive;

    //
    // Set the NTLDR boot flags that are passed in the BootContext.
    //
#ifdef DEFAULT_BOOTFLAGS
    BootFlags = DEFAULT_BOOTFLAGS;
#endif

    //
    // Initialize the video subsystem first so that
    // errors end exceptions can be displayed.
    //

    InitializeVideoSubSystem();

    //
    // In case we booted from a floppy, turn the drive motor off.
    //

    TurnMotorOff();

    //
    // Set up machine type based on its Bus type.
    //

    if (BtIsEisaSystem()) {
        MachineType = MACHINE_TYPE_EISA;
    } else {
        MachineType = MACHINE_TYPE_ISA;
    }

    if (!ConstructMemoryDescriptors()) {
        //
        // If INT 15 E802h fails...
        //
        if (MachineType == MACHINE_TYPE_EISA) {

            //
            // HACKHACK John Vert (jvert)
            //    This is completely bogus.  Since there are a number of EISA
            //    machines which do not let you correctly configure the EISA
            //    NVRAM, and even MORE machines which are improperly configured,
            //    we first check to see how much memory the ISA routines say
            //    exists.  Then we check what the EISA routines tell us, and
            //    compare the two.  If the EISA number is much lower (where "much"
            //    is a completely random fudge factor) than the ISA number, we
            //    assume the machine is improperly configured and we throw away
            //    the EISA numbers and use the ISA ones.  If not, we assume that
            //    the machine is actually configured properly and we trust the
            //    EISA numbers..
            //

            IsaNumPages = IsaConstructMemoryDescriptors();
            EisaNumPages = EisaConstructMemoryDescriptors();
            if (EisaNumPages + 0x80 < IsaNumPages) {
                IsaConstructMemoryDescriptors();
            }

        } else {
            IsaConstructMemoryDescriptors();
        }
    }

    //
    // Search for memory descriptor describing low memory
    //
    CurrentEntry = MemoryDescriptorList;
    while ((CurrentEntry->BlockBase != 0) &&
           (CurrentEntry->BlockSize != 0)) {
        CurrentEntry++;
    }

    if ((CurrentEntry->BlockBase == 0) &&
        (CurrentEntry->BlockSize < (ULONG)512 * (ULONG)1024)) {

        BlPrint(SU_NO_LOW_MEMORY,CurrentEntry->BlockSize/1024);
        goto StartFailed;
    }

    //
    // Is this a network boot?
    //

    if (bootDrive == 0x40) {

        t_PXENV_ENTRY far *entry;

        //
        // Get the address of the NetPC ROM entry point.
        //

        entry = PxenvGetEntry( );
        if ( PxenvVerifyEntry(entry) != 0 ) {
            BlPrint( "\nUnable to verify NetPC ROM entry point.\n" );
            goto StartFailed;
        }

        FP_SEG(NetPcRomEntry) = entry->rm_entry_seg;
        FP_OFF(NetPcRomEntry) = entry->rm_entry_off;

#if 0
        //
        // Disable broadcast reception.
        //
        // chuckl: Don't do this. We added it to solve a problem with DEC cards
        // and the boot floppy, but we need to have broadcasts enabled in case
        // the server needs to ARP us. We tried enabling/disabling broadcasts
        // during the receive loop, but that seems to put Compaq cards to sleep.
        // So we need to leave broadcasts enabled. The DEC card problem will
        // have to be fixed another way.
        //

        {
            t_PXENV_UNDI_SET_PACKET_FILTER UndiSetPF;
            UndiSetPF.Status = 0;
            UndiSetPF.filter = FLTR_DIRECTED;
            if (PxenvApiCall(PXENV_UNDI_SET_PACKET_FILTER, &UndiSetPF) != PXENV_EXIT_SUCCESS) {
                BlPrint("\nSet packet filter failed.\n");
                goto StartFailed;
            }
        }
#endif
        if ( PxenvTftp() ) {
            BlPrint("\nTFTP download failed.\n");
            goto StartFailed;
        }

    }

    //
    // Enable the A20 line for protect mode
    //

    EnableA20();

    //
    // Relocate x86 structures. This includes the GDT, IDT,
    // page directory, and first level page table.
    //

    Relocatex86Structures();

    //
    // Enable protect and paging modes for the first time
    //

    EnableProtectPaging(ENABLING);

    //
    // If this is an SDI boot, copy the OS loader from the SDI image to 0x100000.
    //

    if ( bootDrive == 0x41 ) {

        int i;
        ULONG osloaderOffset;
        ULONG osloaderLength;
        SDI_HEADER *sdiHeader;
        UCHAR *sig1;
        UCHAR *sig2;

        //
        // In the code below, edata is a near pointer to the end of
        // startrom.com. Since we are using 16-bit selectors here,
        // edata is the only thing we can directly reference. FileStart
        // is a 32-bit linear pointer to edata. MoveMemory() uses this
        // pointer.
        //
        // First, copy the SDI header to edata so that we can look at it.
        // Verify that it's really an SDI image.
        //

        MoveMemory(SdiAddress,
                   FileStart,                   
                   sizeof(SDI_HEADER));

        //
        // Verify that the SDI header looks right by checking the signature.
        //

        sdiHeader = (SDI_HEADER *)&edata;

        sig1 = sdiHeader->Signature;
        sig2 = SDI_SIGNATURE;

        for ( i = 0; i < SDI_SIZEOF_SIGNATURE; i++ ) {
            if ( *sig1++ != *sig2++ ) {
                BlPrint("\nSDI image format corrupt.\n");
                goto StartFailed;
            }
        }

        //
        // Scan the TOC looking for a LOAD entry.
        //

        for ( i = 0; i < SDI_TOCMAXENTRIES; i++ ) {
            if ( sdiHeader->ToC[i].dwType == SDI_BLOBTYPE_LOAD ) {
                break;
            }
        }

        if ( i >= SDI_TOCMAXENTRIES ) {
            BlPrint("\nSDI image missing LOAD entry.\n");
            goto StartFailed;
        }

        //
        // Copy the loader to 0x100000.
        //

        osloaderOffset = (ULONG)sdiHeader->ToC[i].llOffset.LowPart;
        osloaderLength = (ULONG)sdiHeader->ToC[i].llSize.LowPart;

        MoveMemory(SdiAddress + osloaderOffset,
                   (ULONG)0x100000,
                   osloaderLength);
    }

    //
    // If this is a network boot or an SDI boot, copy the section headers from
    // the loader image (at 0x100000) down into low memory (at &edata).
    //

    if ((bootDrive == 0x40) || (bootDrive == 0x41)) {

        //
        // This is a tricky bit of code. The only pointer that can be dereferenced
        // is edata. edata is the near pointer which can be used here. FileStart is
        // the far pointer which must be passed to MoveMemory. 
        // 
        IMAGE_DOS_HEADER far *src = (IMAGE_DOS_HEADER far*)0x100000;
        IMAGE_DOS_HEADER far *dst = (IMAGE_DOS_HEADER far*)FileStart;
        
        //
        // Copy the fixed part of the header so we can find the start of the optional
        // header.
        //
        MoveMemory((ULONG)src,
                   (ULONG)dst,                   
                   sizeof(IMAGE_DOS_HEADER));

        //
        // Copy the optional header so we can find the size of all the headers
        //          
        OptionalHeader = &((IMAGE_NT_HEADERS far *) ((UCHAR far *) src + edata.e_lfanew))->OptionalHeader;
        MoveMemory((ULONG)OptionalHeader,
                   (ULONG)&((IMAGE_NT_HEADERS far *) ((UCHAR far *) dst + edata.e_lfanew))->OptionalHeader,
                   sizeof(IMAGE_OPTIONAL_HEADER));

        //
        // Now we know the size of all the headers, so just recopy the entire first chunk
        // that contains all the headers.
        ///
        MoveMemory((ULONG)src,
                   (ULONG)dst,
                   ((PIMAGE_NT_HEADERS)((PUCHAR)&edata + edata.e_lfanew))->OptionalHeader.SizeOfHeaders);

        FileStart = (ULONG)src;
    }

    //
    // Ensure there is a memory descriptor to contain osloader image
    //
    OptionalHeader = &((PIMAGE_NT_HEADERS) ((PUCHAR) &edata + edata.e_lfanew))->OptionalHeader;
    ImageBase = OptionalHeader->ImageBase;
    ImageSize = OptionalHeader->SizeOfImage;
    OsLoaderBase = ImageBase;
    OsLoaderExports = ImageBase + OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    CurrentEntry = MemoryDescriptorList;
    while (ImageSize > 0) {
        while (CurrentEntry->BlockSize != 0) {
            BlockEnd = CurrentEntry->BlockBase + CurrentEntry->BlockSize;

            if ((CurrentEntry->BlockBase <= ImageBase) &&
                (BlockEnd > ImageBase)) {

                //
                // this descriptor at least partially contains a chunk
                // of the osloader.
                //
                if (BlockEnd-ImageBase > ImageSize) {
                    ImageSize = 0;
                } else {
                    ImageSize -= (BlockEnd-ImageBase);
                    ImageBase = BlockEnd;
                }

                //
                // look for remaining part (if any) of osloader
                //
                CurrentEntry = MemoryDescriptorList;
                break;
            }
            CurrentEntry++;
        }
        if (CurrentEntry->BlockSize == 0) {
            break;
        }
    }

    if (ImageSize > 0) {
        //
        // We could not relocate the osloader to high memory.  Error out
        // and display the memory map.
        //
        BlPrint(SU_NO_EXTENDED_MEMORY);

        CurrentEntry = MemoryDescriptorList;
        while (CurrentEntry->BlockSize != 0) {
            BlPrint("    %lx - %lx\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockBase + CurrentEntry->BlockSize);

            CurrentEntry++;
        }
        goto StartFailed;
    }

    //
    // Go relocate loader sections and build page table entries
    //

    LoaderEntryPoint = RelocateLoaderSections(&OsLoaderStart, &OsLoaderEnd);

    //
    // Search for memory descriptor containing the osloader and
    // change it.
    //

    //
    // Transfer control to the OS loader
    //

    TransferToLoader(LoaderEntryPoint);

StartFailed:

    if (BootFlags & 1) { // BOOTFLAG_REBOOT_ON_FAILURE == 1 from bldr.h
        ULONG WaitTime = 5;
        BlPrint("\nRebooting in %d seconds...\n", WaitTime);
        Wait(WaitTime);
        Reboot();
    }

    WAITFOREVER
}

ULONG
RelocateLoaderSections(
    OUT PULONG Start,
    OUT PULONG End
    )
/*++

Routine Description:

    The SU module is prepended to the OS loader file. The OS loader file
    is a coff++ file. This routine computes the beginning of the OS loader
    file, then relocates the OS loader's sections as if it were just
    loading the file from disk file.

Arguments:

    Start - Returns the address of the start of the image
    End   - Returns the address of the end of the image

Returns:

    Entry point of loader


--*/
{
    USHORT Section;
    ULONG Source,Destination;
    ULONG VirtualSize;
    ULONG SizeOfRawData;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER SectionHeader;

    //
    // Make a pointer to the beginning of the loader's coff header
    //

    FileHeader = &((PIMAGE_NT_HEADERS) ((PUCHAR) &edata + edata.e_lfanew))->FileHeader;

    //
    // Validate the appended loader image by checking signatures.
    //   1st - is it an executable image?
    //   2nd - is the target environment the 386?
    //

    if ((FileHeader->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) {
        puts(SU_NTLDR_CORRUPT);
        WAITFOREVER;
    }

    if (FileHeader->Machine != IMAGE_FILE_MACHINE_I386) {
        puts(SU_NTLDR_CORRUPT);
        WAITFOREVER;
    }

    //
    // Make a pointer to the optional header in the header-buffer
    //

    OptionalHeader = (PIMAGE_OPTIONAL_HEADER)((PUCHAR)FileHeader +
        sizeof(IMAGE_FILE_HEADER));

    //
    // Make a pointer to the first section in the header buffer
    //

    SectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)OptionalHeader +
        FileHeader->SizeOfOptionalHeader);

    *Start = OptionalHeader->ImageBase+SectionHeader->VirtualAddress;
    *End   = *Start + SectionHeader->SizeOfRawData;

    //
    // Display some debug stuff for now
    //

    DBG1(
    BlPrint("Machine = %x\n",FileHeader->Machine);
    BlPrint("NumberOfSections = %x\n",FileHeader->NumberOfSections);
    BlPrint("TimeDateStamp %lx\n",FileHeader->TimeDateStamp);
    BlPrint("PointerToSymbolTable = %lx\n",FileHeader->PointerToSymbolTable);
    BlPrint("NumberOfSymbols %lx\n",FileHeader->NumberOfSymbols);
    BlPrint("SizeOfOptionalHeader = %x\n",FileHeader->SizeOfOptionalHeader);
    BlPrint("Characteristics = %x\n",FileHeader->Characteristics);
    )

    //
    // Loop and relocate each section with a non-zero RawData size
    //

    for (Section=FileHeader->NumberOfSections ; Section-- ; SectionHeader++) {

        //
        // Compute source, destination, and count arguments
        //

        Source = FileStart  + SectionHeader->PointerToRawData;
        Destination = OptionalHeader->ImageBase + SectionHeader->VirtualAddress;

        VirtualSize = SectionHeader->Misc.VirtualSize;
        SizeOfRawData = SectionHeader->SizeOfRawData;

        if (VirtualSize == 0) {
            VirtualSize = SizeOfRawData;
        }

        if (SectionHeader->PointerToRawData == 0) {
            //
            // SizeOfRawData can be non-zero even if PointerToRawData is zero
            //

            SizeOfRawData = 0;
        } else if (SizeOfRawData > VirtualSize) {
            //
            // Don't load more from image than is expected in memory
            //

            SizeOfRawData = VirtualSize;
        }

        if (Destination < *Start) {
            *Start = Destination;
        }

        if (Destination+VirtualSize > *End) {
            *End = Destination+VirtualSize;
        }

        DBG1(BlPrint("src=%lx  dest=%lx raw=%lx\n",Source,Destination,SizeOfRawData);)

        if (SizeOfRawData != 0) {
            //
            // This section is either a code (.TEXT) section or an
            // initialized data (.DATA) section.
            // Relocate the section to memory at the virtual/physical
            // addresses specified in the section header.
            //
            MoveMemory(Source,Destination,SizeOfRawData);
        }

        if (SizeOfRawData < VirtualSize) {
            //
            // Zero the portion not loaded from the image
            //

            DBG1( BlPrint("Zeroing destination %lx\n",Destination+SizeOfRawData); )
            ZeroMemory(Destination+SizeOfRawData,VirtualSize - SizeOfRawData);
        }

        //
        // Check if this is the resource section.  If so, we need
        // to pass its location to the osloader.
        //
        if ((SectionHeader->Name[0] == '.') &&
            (SectionHeader->Name[1] == 'r') &&
            (SectionHeader->Name[2] == 's') &&
            (SectionHeader->Name[3] == 'r') &&
            (SectionHeader->Name[4] == 'c')) {
            ResourceDirectory = Destination;
            ResourceOffset = SectionHeader->VirtualAddress;
        }

        //
        // look for the .detect section that will contain the contents
        // of ntdetect.com. This is optional.
        //
        if ((SectionHeader->Name[0] == '.') &&
            (SectionHeader->Name[1] == 'd') &&
            (SectionHeader->Name[2] == 'e') &&
            (SectionHeader->Name[3] == 't') &&
            (SectionHeader->Name[4] == 'e') &&
            (SectionHeader->Name[5] == 'c') &&
            (SectionHeader->Name[6] == 't')) {
            NtDetectStart = Destination;
            NtDetectEnd = NtDetectStart + SizeOfRawData;
        }

    }

    DBG1( BlPrint("RelocateLoaderSections done - EntryPoint == %lx\n",
            OptionalHeader->AddressOfEntryPoint + OptionalHeader->ImageBase);)
    return(OptionalHeader->AddressOfEntryPoint + OptionalHeader->ImageBase);

}

VOID
Relocatex86Structures(
    VOID
    )
/*++

Routine Description:

    The gdt and idt are statically defined and imbedded in the SU modules
    data segment. This routine moves then out of the data segment and into
    a page mapped at a defined location.

Arguments:

    None

Returns:

    Nothing


--*/
{
    FPUCHAR Fpsrc, Fpdst;
    USHORT Count;

    //
    // Make pointers to the data and compute the size
    // of the block to use.
    //

    Fpsrc = (FPUCHAR)&Beginx86Relocation;
    MAKE_FP(Fpdst,SYSTEM_STRUCTS_BASE_PA);
    Count = (&Endx86Relocation - &Beginx86Relocation);

    //
    // Move the data to its new location
    //

    while (Count--) {
        *Fpdst++ = *Fpsrc++;

    }

}

VOID
DisplayArgs(
    USHORT es,
    USHORT bx,
    USHORT cx,
    USHORT dx,
    USHORT ax
    )
/*++

Routine Description:

    Just a debugging routine to dump some registers.

Arguments:

    The x86 registers es, bx, cx, dx, and ax are pushed on the stack
    before this routine is called.


Returns:

    Nothing


Environment:

    Real Mode ONLY


--*/
{
    BlPrint("ax:%x dx:%x cx:%x bx:%x es:%x\n",
                (USHORT) ax,
                (USHORT) dx,
                (USHORT) cx,
                (USHORT) bx,
                (USHORT) es);

    return;
}


//
// PxenvVerifyEntry()
//
// Description:
//  Verify that the contents of the PXENV Entry Point structure are
//  valid.
//
// Passed:
//  entry := Far pointer to PXENV Entry Point structure
//
// Returns:
//  TRUE := Structure is invalid
//  FALSE := Structure is valid
//

BOOLEAN
PxenvVerifyEntry(
    t_PXENV_ENTRY far *entry
)
{
    unsigned n;
    UINT8 cksum = 0;

    //
    // Is structure pointer NULL?
    //

    if (entry == NULL) {
        BlPrint("\nNULL PXENV Entry Point structure\n");
        return TRUE;
    }

    //
    // Is real-mode API entry point NULL?
    //

    if (!(entry->rm_entry_off | entry->rm_entry_seg)) {
        BlPrint("\nNULL PXENV API Entry Point\n");
        return TRUE;
    }

    //
    // Verify structure signature
    //

    for (n = sizeof entry->signature; n--; ) {
        if (entry->signature[n] != (UINT8)(PXENV_ENTRY_SIG[n])) {
            BlPrint("\nBad PXENV Entry Point signature\n");
            return TRUE;
        }
    }

    //
    // Verify structure signature
    //

    if (entry->length < sizeof(t_PXENV_ENTRY) ) {
        BlPrint("\nBad PXENV Entry Point size\n");
        return TRUE;
    }

    //
    // Verify structure checksum
    //

#if 0
    for (n = 0; n < entry->length; n++ ) {
        BlPrint( "%x ", ((UINT8 far *)entry)[n] );
        if ((n & 15) == 15) {
            BlPrint( "\n" );
        }
    }
#endif

    for (n = entry->length; n--; ) {
        cksum += ((UINT8 far *)entry)[n];
    }

    if (cksum) {
        BlPrint("\nBad PXENV Entry Point structure checksum\n");
        return TRUE;
    }

    return FALSE;
}


VOID 
Reboot(
    VOID
    )
/*++

Routine Description:

    Reboots the machine using the keyboard port.
    
Arguments:

    None

Returns:

    Nothing

--*/
{
    RealMode();

    __asm {
        mov     ax, 040h
        mov     ds, ax
        mov     word ptr ds:[72h], 1234h        // set location 472 to 1234 to indicate warm reboot
        mov     al, 0feh
        out     64h, al                         // write to keyboard port to cause reboot
    }
}


VOID 
Wait(
    IN ULONG WaitTime
    )
/*++

Routine Description:

    Waits for the requested number of seconds.
    
Arguments:

    WaitTime - in seconds

Returns:

    Nothing

--*/
{
    ULONG startTime = GetTickCount();
    while ( (((GetTickCount() - startTime) * 10) / 182) < WaitTime ) {
    }
}

// END OF FILE //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\ntmisc.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ntmisc.h

Abstract:

    This module contains the misc. definitions in \nt\public\sdk\inc
    directory.  Note, we created this file because ntdetect uses 16 bit
    compiler and various new C compiler switches/pragamas are not recognized
    by the 16 bit C compiler.

Author:

    Shie-Lin Tzong (shielint) 11-Nov-1992


Revision History:


--*/
//
// PHYSICAL_ADDRESS
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

//
// Note all the definitions defined below are used to make compiler shut up.
// Ntdetect.com does not rely on the correctness of the structures.
//

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY far *Flink;
   struct _LIST_ENTRY far *Blink;
} LIST_ENTRY, far *PLIST_ENTRY;

#define PTIME_FIELDS    PVOID


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\pxe_cmn.inc ===
;
; Modifications:   $Header:   W:/LCS/ARCHIVES/preboot/lsa2/base/iputil.asv   1.3   Apr 04 1997 10:05:58   GRGUSTAF  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;


;* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;* Result codes returned in AX by a PXE API service.
;*
PXENV_EXIT_SUCCESS	equ	0
PXENV_EXIT_FAILURE	equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally


;* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;* CPU types
;*
PXENV_CPU_X86		equ	0
PXENV_CPU_ALPHA		equ	1
PXENV_CPU_PPC		equ	2


;* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;* Bus types
;*
PXENV_BUS_ISA		equ	0
PXENV_BUS_EISA		equ	1
PXENV_BUS_MCA		equ	2
PXENV_BUS_PCI		equ	3
PXENV_BUS_VESA		equ	4
PXENV_BUS_PCMCIA		equ	5


;* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;* Status codes returned in the status word of PXE API parameter structures.
;*
PXENV_STATUS_SUCCESS	equ	0
PXENV_STATUS_FAILURE	equ	1	; general failure
PXENV_STATUS_BAD_FUNC	equ	2	; invalid function number
PXENV_STATUS_UNSUPPORTED equ	3	; Function is not yet supported. 
PXENV_STATUS_1A_HOOKED	 equ	4	; Int 1Ah cannot be unhooked. 


; ARP errors 
PXENV_STATUS_ARP_TIMEOUT			equ 11h

; TFTP errors 
PXENV_STATUS_TFTP_CANNOT_ARP_ADDRESS	equ 30h
PXENV_STATUS_TFTP_OPEN_TIMEOUT			equ 32h
PXENV_STATUS_TFTP_UNKNOWN_OPCODE		equ 33h
PXENV_STATUS_TFTP_ERROR_OPCODE			equ 34h
PXENV_STATUS_TFTP_READ_TIMEOUT			equ 35h
PXENV_STATUS_TFTP_WRITE_TIMEOUT			equ 37h
PXENV_STATUS_TFTP_CANNOT_OPEN_CONNECTION		equ 38h
PXENV_STATUS_TFTP_CANNOT_READ_FROM_CONNECTION	equ 39h
PXENV_STATUS_TFTP_CANNOT_WRITE_TO_CONNECTION	equ 3Ah

; BOOTP errors 
PXENV_STATUS_BOOTP_TIMEOUT					equ 41h
PXENV_STATUS_BOOTP_NO_CLIENT_OR_SERVER_IP	equ 42h
PXENV_STATUS_BOOTP_NO_BOOTFILE_NAME			equ 43h
PXENV_STATUS_BOOTP_CANNOT_ARP_REDIR_SRVR	equ 44h

; DHCP errors 
PXENV_STATUS_DHCP_TIMEOUT			equ 	51h

; UNDI Errors
PXENV_STATUS_UNDI_MEDIATEST_FAILED 	equ	 61h


; MTFTP errors 
PXENV_STATUS_MTFTP_CANNOT_ARP_ADDRESS	equ 90h
PXENV_STATUS_MTFTP_OPEN_TIMEOUT			equ 92h
PXENV_STATUS_MTFTP_UNKNOWN_OPCODE		equ 93h
PXENV_STATUS_MTFTP_READ_TIMEOUT			equ 95h
PXENV_STATUS_MTFTP_WRITE_TIMEOUT		equ 97h
PXENV_STATUS_MTFTP_CANNOT_OPEN_CONNECTION		equ 98h
PXENV_STATUS_MTFTP_CANNOT_READ_FROM_CONNECTION	equ 99h
PXENV_STATUS_MTFTP_CANNOT_WRITE_TO_CONNECTION	equ 9Ah
PXENV_STATUS_MTFTP_CANNOT_INIT_NIC_FOR_MCAST	equ 9Bh
PXENV_STATUS_MTFTP_TOO_MANY_PACKAGES			equ 9Ch
PXENV_STATUS_MTFTP_MCOPY_PROBLEM				equ 9Dh


; EOF - $Workfile:   pxe_api.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\su.asm ===
;++ 
;
; Module name
;
;       su.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Jan-15-91
;
; Description
;
;       Startup module for the 386 NT OS loader.
;
; Exported Procedures
;
;       EnableProtectPaging
;
; Notes
;       NT386 Boot Loader program. This assembly file is required in
;       order to link C modules into a "/TINY"  (single segment) memory
;       model.
;
;
; This file does the following:
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 1) Defines the entry point for the boot loader's startup program
; 2) Computes what values should actually be in the DS and SS registers.
; 3) Provides the int bios functionality
; 4) Provides 386/486 mode (protect/paging) switching code.
;
; The OS/2 bootstrap routine (boot sector) loads the boot loader program at
; real-mode address 2000:0000 with the following register values:
;
;       CS = 2000
;       IP = 0000
;       DS = 07C0
;       ES = 1000
;       SS = 0000
;       SP = 7C00
;
; The PXE boot PROM loads the boot loader program at real-mode address
; 0000:7C00 with the following register values:
;
;       CS = 0000
;       IP = 7C00
;       DS = Data segment of PXE boot PROM
;       SS = Stack segment of PXE boot PROM
;       SP = Stack pointer of PXE boot PROM (at least 1K free)
;       ES = 16-bit, real-mode, segment of PXENV Entry Point structure
;       BX = 16-bit, real-mode, offset of PXENV Entry Point structure
;       EDX = 32-bit, physical, address of PXENV Entry Point structure
;
; For a boot from an SDI image, startrom is loaded at real-mode address
; 0000:7C00 with the following register values:
;
;       CS = 0000
;       IP = 7C00
;       DS = don't care
;       SS = Caller-defined stack segment
;       SP = Caller-defined stack pointer
;       EDX = physical address of page-aligned SDI image ORed with 0x41
;
; This startup module relocates itself to 2000:0 and changes the CS and IP
; register values to:
;
;       CS = 2000
;       IP = 0000
;
; Build Notes:
; ~~~~~~~~~~~~
; The microsoft C compiler will not produce "tiny" model programs. In the
; tiny model, the entire program consists of only one segment. The small
; model produced by our compilers consists of two segments: DGROUP and _TEXT.
; If you convert a small model program into a tiny model program, DS (which
; should point to DGROUP (bss,const,data) will always be wrong. For this reason
; we need an assembly module to do a simple run-time fixup on SS and DS. To
; guarantee that DS will point to DGROUP no matter where os2ldr is loaded,
; the paragraph (shifted right four bits) offset of DGROUP from _TEXT must
; be added to the value in CS to compute DS and SS.
;
; We get the linker to fixup the offset of the beginning of the dgroup segment
; relative to the beginning of the code segment and it's this value added
; to the value in CS that allows us to build a "tiny" model program in C
; without a lot of munging around in order to get the data reference offsets
; in the code correct.
;
; If the _TEXT:DGROUP fixup appears in other files (which it does), the linker
; will not compute the correct value unless the accumulated data pointer is
; zero when it gets there. Therefore, no data should be placed in the data segment
; until after all instances of _TEXT:DGROUP have been encountered by the linker.
; The linker processes files from right to left on the command line.
;
; A Note About Stacks
; Initially we run on our internal stack (SuStack) which is only 160 bytes deep
; but seems to do the trick. Then we have to have a separate double fault stack.
; This stack can be in the middle of the stack/data segment. It will step on
; the loader image, but that's ok since the fault was either caused by 16bit
; code (which won't be in the loader image) or, it was caused by the 32bit
; loader (which has already been relocated) so we won't be stepping on code
; that may have caused the fault. And finally, we have the "call back" stack
; which  starts at the top of the stack/data segment. We use this during
; all call backs since the original loader source is no longer needed and
; this'll give us plenty of stack for bios calls etc.
;
;--

DoubleWord      struc
lsw     dw      ?
msw     dw      ?
DoubleWord      ends

;
; This is the structure used to pass all shared data between the boot sector
; and NTLDR.
;

SHARED  struc
        ReadClusters            dd      ?               ; function pointer
        ReadSectors             dd      ?               ; function pointer

        SectorBase              dd      ?               ; starting sector
                                                        ; for ReadSectors
                                                        ; callback
SHARED  ends


BPB     struc
        BytesPerSector          dw      ?
        SectorsPerCluster       db      ?
        ReservedSectors         dw      ?
        Fats                    db      ?
        DirectoryEntries        dw      ?
        Sectors                 dw      ?
        Media                   db      ?
        FatSectors              dw      ?
        SectorsPerTrack         dw      ?
        Heads                   dw      ?
        HiddenSectors           dd      ?
        SectorsLong             dd      ?
;
; The following byte is NOT part of the BPB but is set by SYS and format
;

        BootDriveNumber         db      ?
BPB     ends

SU_CODEMODULE    equ      1        ; Identifies this module to "su.inc"
include su.inc
include macro.inc

extrn _BootRecord:word
extrn _puts:near
extrn _MemoryDescriptorList:near
extrn _InsertDescriptor:near
extrn _NetPcRomEntry:near
extrn GetKeyEx:near
extrn GetCounterReal:near

include pxe_api.inc                     ; Included for PXENV Entry Point
                                        ; structure.  Also includes
                                        ; pxe_cmn.inc file.

MAXREAD     EQU 10000h
MAXSECTORS  EQU MAXREAD/0200h

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

;
; Run-time fixups for stack and data segment
;

public Start
Start:
;
; The FAT boot sector only reads in the first 512 bytes of NTLDR.  This is
; the module that contains those 512 bytes, so we are now responsible for
; loading the rest of the file.  Other filesystems (i.e. HPFS, NTFS, RIPL)
; will load the whole file, so the default entrypoint branches around the
; FAT-specific code.
;
        jmp     RealStart

FatBegin:
.386
;
; If we're here, we've booted off a FAT system and we must load the rest
; of NTLDR at 2000:0200 (right behind this sector)  NTLDR passes us the
; following:
;       BX = Starting Cluster Number of NTLDR
;       DL = INT 13h drive number we've booted from
;       DS:SI -> boot media's BPB
;       DS:DI -> argument structure (see above struc definition)
;
;
; Save away the boot drive and the starting cluster number
;
        push    dx
        push    bx

;
; Blast the FAT into memory at 6000:0000 - 8000:0000
;

.386
        push    06000h
.8086
        pop     es
        xor     bx,bx                           ; (es:bx) = 6000:0000
        mov     cx,ds:[si].ReservedSectors
        mov     ds:[di].SectorBase.msw,0
        mov     ds:[di].SectorBase.lsw,cx       ; set up Sector Base

        mov     ax,ds:[si].FatSectors           ; (al) = # Sectors to read
        cmp     ax,080h
        jbe     FatLt64k

;  The FAT is > 64k, so we read the first 64k chunk, then the rest.
;  (A 16-bit FAT can't be bigger than 128k)

        push    cx
        mov     ax,080h         ; (al) = # of sectors to read
        call    ds:[di].ReadSectors
        pop     cx                      ; (cx) = previous SectorBase
.386
        push    07000h
.8086
        pop     es
        xor     bx,bx                   ; (es:bx) = 7000:0000
        mov     ax,ds:[si].FatSectors
        sub     ax,080h                 ; (ax) = # Sectors left to read
        add     cx,080h                 ; (cx) = SectorBase for next read
        mov     ds:[di].SectorBase.lsw,cx
        adc     ds:[di].SectorBase.msw,0        ; set up SectorBase

;
; (al) = # of sectors to read
;
FatLt64k:
        call    ds:[di].ReadSectors

;
; FAT is in memory, now we restore our starting cluster number
;
        pop     dx                      ; (dx) = starting cluster number
        xor     bx,bx

;
; set up FS and GS for reading the FAT
;
.386
        mov     ax,6000h
        mov     fs,ax
        mov     ax,7000h
        mov     gs,ax
.8086

;
; set up ES for reading in the rest of us
;
        push    cs
        pop     es

        mov     ah,MAXSECTORS           ; (ah) = number of sectors we can read
                                        ;        until boundary
FatLoop:
;
; (dx) = next cluster to load
;
        push    dx
        mov     al,ds:[si].SectorsPerCluster    ; (al) = number of contiguous sectors
                                                ;        found
        sub     ah,ds:[si].SectorsPerCluster                                                    ;        can read before 64k

;
; Check to see if we've reached the end of the file
;
        cmp     dx,0ffffh
        jne     Fat10

;
; The entire file has been loaded.  Throw away the saved next cluster,
; restore the boot drive, and let NTLDR do its thing.
;
        pop     dx
        pop     dx
        jmp     RealStart

Fat10:
        mov     cx,dx
;
; (dx) = (cx) = last contiguous cluster
; (al) = # of contiguous clusters found
;

        call    NextFatEntry
;
; (dx) = cluster following last contiguous cluster

;
; Check to see if the next cluster is contiguous.  If not, go load the
; contiguous block we've found.
;
        inc     cx
        cmp     dx,cx

        jne     LncLoad

;
; Check to see if we've reached the 64k boundary.  If so, go load the
; contiguous block so far.  If not, increment the number of contiguous
; sectors and loop again.
;
        cmp     ah,0
        jne     Lnc20
        mov     ah,MAXSECTORS           ; (ah) = number of sectors until
                                        ;        boundary reached again
        jmp     short LncLoad

Lnc20:
        add     al,ds:[si].SectorsPerCluster
        sub     ah,ds:[si].SectorsPerCluster
        jmp     short Fat10


LncLoad:
;
; (TOS) = first cluster to load
; (dx)  = first cluster of next group to load
; (al)  = number of contiguous sectors
;
        pop     cx
        push    dx
        mov     dx,cx
        mov     cx,10                   ; (cx) = retry count

;
; N.B.
;       This assumes that we will never have more than 255 contiguous clusters.
;       Since that would get broken up into chunks that don't cross the 64k
;       boundary, this is ok.
;
; (dx) = first cluster to load
; (al) = number of contiguous sectors
; (TOS) = first cluster of next group to load
; (es:bx) = address where clusters should be loaded
;
FatRetry:
        push    bx
        push    ax
        push    dx
        push    cx

if 0
        push    dx
        call    PrintDbg
        mov     dx,ax
        call    PrintDbg
        pop     dx
endif

        call    [di].ReadClusters
        jnc     ReadOk
;
; error in the read, reset the drive and try again
;
if 0
        mov     dx, ax
        call    PrintDbg
endif
        mov     ax,01h
        mov     al,ds:[si].BootDriveNumber
        int     13h
if 0
        mov     dx,ax
        call    PrintDbg
endif
        xor     ax,ax
        mov     al,ds:[si].BootDriveNumber
        int     13h

;
; pause for a while
;
        xor     ax,ax
FatPause:
        dec     ax
        jnz     FatPause

        pop     cx
        pop     dx
        pop     ax
        pop     bx

        dec     cx
        jnz     FatRetry

;
; we have re-tried ten times, it still doesn't work, so punt.
;
        push    cs
        pop     ds
        mov     si,offset FAT_ERROR
FatErrPrint:
        lodsb
        or      al,al
        jz      FatErrDone
        mov     ah,14           ; write teletype
        mov     bx,7            ; attribute
        int     10h             ; print it
        jmp     FatErrPrint

FatErrDone:
        jmp     $
        ; This should be replaced by a mechanism to get a pointer
        ; passed to us in the param block. since the boot sector msg itself
        ; is properly localized but this one isn't.
FAT_ERROR       db      13,10,"Disk I/O error",0dh,0ah,0


ReadOk:
        pop     cx
        pop     dx
        pop     ax
        pop     bx
        pop     dx                      ; (dx) = first cluster of next group
                                        ;        to load.

.386
;
; Convert # of sectors into # of bytes.
;
        mov     cl,al
        xor     ch,ch
        shl     cx,9
.8086
        add     bx,cx
        jz      FatLoopDone
        jmp     FatLoop

FatLoopDone:
;
; (bx) = 0
;   This means we've just ended on a 64k boundary, so we have to
;   increment ES to continue reading the file.  We are guaranteed to
;   always end on a 64k boundary and never cross it, because we
;   will reduce the number of contiguous clusters to read
;   to ensure that the last cluster read will end on the 64k boundary.
;   Since we start reading at 0, and ClusterSize will always be a power
;   of two, a cluster will never cross a 64k boundary.
;
        mov     ax,es
        add     ax,01000h
        mov     es,ax
        mov     ah,MAXSECTORS
        jmp     FatLoop

;++
;
; NextFatEntry - This procedure returns the next cluster in the FAT chain.
;                It will deal with both 12-bit and 16-bit FATs.  It assumes
;                that the entire FAT has been loaded into memory.
;
; Arguments:
;    (dx)   = current cluster number
;    (fs:0) = start of FAT in memory
;    (gs:0) = start of second 64k of FAT in memory
;
; Returns:
;    (dx)   = next cluster number in FAT chain
;    (dx)   = 0ffffh if there are no more clusters in the chain
;
;--
NextFatEntry    proc    near
        push    bx

;
; Check to see if this is a 12-bit or 16-bit FAT.  The biggest FAT we can
; have for a 12-bit FAT is 4080 clusters.  This is 6120 bytes, or just under
; 12 sectors.
;
; A 16-bit FAT that's 12 sectors long would only hold 3072 clusters.  Thus,
; we compare the number of FAT sectors to 12.  If it's greater than 12, we
; have a 16-bit FAT.  If it's less than or equal to 12, we have a 12-bit FAT.
;
        call    IsFat12
        jnc     Next16Fat

Next12Fat:
        mov     bx,dx                   ; (fs:bx) => temporary index
        shr     dx,1                    ; (dx) = offset/2
                                        ; (CY) = 1  need to shift
        pushf                           ;      = 0  don't need to shift
        add     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        popf
        jc      shift                   ; carry flag tells us whether to
        and     dx,0fffh                ; mask
        jmp     short N12Tail
shift:
.386
        shr     dx,4                    ; or shift
.8086

N12Tail:
;
; Check for end of file
;
        cmp     dx,0ff8h                ; If we're at the end of the file,
        jb      NfeDone                 ; convert to canonical EOF.
        mov     dx,0ffffh
        jmp     short NfeDone

Next16Fat:
        add     dx,dx                   ; (dx) = offset
        jc      N16high

        mov     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        jmp     short N16Tail

N16high:
        mov     bx,dx
.386
        mov     dx,gs:[bx]
.8086

N16Tail:
        cmp     dx,0fff8h
        jb      NfeDone
        mov     dx,0ffffh               ; If we're at the end of the file
                                        ; convert to canonical EOF.

NfeDone:
        pop     bx
        ret
NextFatEntry    endp

;++
;
; IsFat12 - This function determines whether the BPB describes a 12-bit
;           or 16-bit FAT.
;
; Arguments - ds:si supplies pointer to BPB
;
; Returns
;       CY set -   12-bit FAT
;       CY clear - 16-bit FAT
;
;--
IsFat12 proc    near

.386
        push    eax
        push    ebx
        push    ecx
        push    edx

        movzx   ecx, ds:[si].Sectors
        or      cx,cx
        jnz     if10
        mov     ecx, ds:[si].SectorsLong
if10:
;
; (ecx) = number of sectors
;
        movzx   ebx, byte ptr ds:[si].Fats
        movzx   eax, word ptr ds:[si].FatSectors
        mul     ebx
        sub     ecx,eax

;
; (ecx) = (#sectors)-(sectors in FATs)
;
        movzx   eax, word ptr ds:[si].DirectoryEntries
        shl     eax, 5
;
; (eax) = #bytes in root dir
;
        mov     edx,eax
        and     edx,0ffff0000h
        div     word ptr ds:[si].BytesPerSector
        sub     ecx,eax

;
; (ecx) = (#sectors) - (sectors in fat) - (sectors in root dir)
;
        movzx   eax, word ptr ds:[si].ReservedSectors
        sub     ecx, eax
        mov     eax, ecx
        movzx   ecx, byte ptr ds:[si].SectorsPerCluster
        xor     edx,edx
        div     ecx

        cmp     eax, 4087
        jae     if20
        stc
        jmp     short if30
if20:
        clc
if30:
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        ret
.8086
IsFat12 endp



PrintDbg       proc    near
        push    ax
        push    bx
        push    cx

        mov     cx,4
pd10:
.386
        rol     dx,4
.8086
        mov     ah,0eh
        mov     bx,7
        mov     al,dl
        and     al,0fh
        add     al,'0'
        cmp     al,'9'
        jbe     pd15
        add     al,'A'-('9'+1)

pd15:
        int     010h
        loop    pd10

        mov     ah,0eh
        mov     al,' '
        mov     bx,7
        int     010h
        pop     cx
        pop     bx
        pop     ax

        ret

PrintDbg      endp

IFDEF HEADLESS_SRV
TerminalStatus          dw      0
endif


Free    EQU     512-($-Start)
if Free lt 0
        %out FATAL PROBLEM: FAT-specific startup code is greater than
        %out 512 bytes.  Fix it!
        .err
endif

RealStart:
.386p
;
; Compute the paragraph needed for DS
;
if 0
        mov     ax,0
        int     16h
endif
;
; If this is a network boot (known by CS == 0 and IP ~= 7C00), then
; move the startup module to 2000:0.
;

        call    near ptr pxe_boot_check ; *(SP -= 2) = IP

pxe_boot_check:
        pop     ax                      ; AX := IP

        cmp     ax, 7c00h + pxe_boot_check - Start
        jne     not_pxe_boot
        mov     ax, cs
        cmp     ax, 0
        jne     not_pxe_boot

        push    ds
        push    es

        xor     ax,ax
        mov     cx,7c0h                 ; move from 7C0:0
        mov     ds,cx
        mov     si,ax
        mov     cx,2000h                ; move to 2000:0
        mov     es,cx
        mov     di,ax

        mov     ecx,offset _TEXT:DGROUP ; get length of text segment
        add     ecx,offset DGROUP:_edata ; add length of data segment

        cld                             ; move forward
        rep     movsb                   ; relocate to 2000:0

        pop     es
        pop     ds

        db      0EAh                    ; Far jump to 2000h:CS_IP_adjust
        dw      offset CS_IP_adjust     ; to change CS:IP and flush
        dw      2000h                   ; prefetch.

CS_IP_adjust:


IFDEF HEADLESS_SRV
        push    edx
        mov     ax, 00e3h               ; Initialize, 9600 baud, no parity, 1 stop bit, 8 data bits
        mov     dx, HEADLESS_COMPORT    ; com port
        int     14h
        mov     cs:TerminalStatus, ax   ; Save the status for later
        pop     edx
endif

;
; Check DL as set by our caller. If it is 0x41, this implies that we're doing
; an SDI boot. Our caller is a different initial boot program that has loaded
; into memory an SDI image containing a ramdisk image, startrom.com and
; osloader.exe. The caller has copied startrom.com to 0:7c00 and jumped to it.
; We are to do the normal PXE bootstrap things here, except that we don't have
; to download the loader, because it's already here. We do have to move it into
; the right place from where it exists in the SDI image.
;
; If this is an SDI boot, the top three bytes of the page-aligned physical
; address of the SDI image are in the top three bytes of EDX. This address is
; passed to SuMain().
;
        cmp     dl, 41h                 ; SDI boot?
        je      sdi_boot                ; Jump if yes (skip wait for F12,
                                        ; leave dl == 0x41 to indicate boot
                                        ; drive, and leave the SDI address in
                                        ; the upper part of edx.

;
; Give the user a chance to press F12 to request a network boot. If F12 is not
; pressed, then return from the boot code. This causes the BIOS to try the next
; boot device (usually the disk).
;

ifndef ALWAYS_BOOT_FROM_NET
        call    CheckForF12
        cmp     ax,0
        jnz     do_remote_boot

        retf

do_remote_boot:
endif

        mov     dx, 0040h               ; Default boot disk (0x40 == PXE boot)

sdi_boot:
not_pxe_boot:

;
; Compute the paragraph needed for DS
;
        mov     bx,offset _TEXT:DGROUP  ; first calculate offset to data
        shr     bx,4                    ; must be para aligned

        mov     ax,cs                   ; get base of code
        add     ax,bx                   ; add paragraph offset to data

        mov     ss,ax                      ; ints disabled for next instruct
        mov     sp,offset DGROUP:SuStack   ; (sp) = top of internal stack

;
; Build C stack frame for _SuMain
;
        push    edx                     ; pass bootdisk to main
;
; Make DS point to the paragraph address of DGROUP
;
        mov     ds,ax                   ; ds now points to beginning of DGROUP
        mov     es,ax                   ; es now points to beginning of DGROUP
;
; Compute the physical address of the end of the data segment (which
; will be the beginning of the prepended loader file).
;

        movzx    edx,ax
        shl      edx,4
        add      edx,offset DGROUP:_edata
        mov      dword ptr _FileStart,edx

;
; Force the upper parts of
; of EBP and ESP to be zero in real mode.
;

        xor      bp,bp
        movzx    ebp,bp
        movzx    esp,sp
        mov      [saveDS],ds

        call    _SuMain                 ; go to C code to do everything else.


;++
; _EnableProtectPaging
;
; Loads 386 protect mode registers.
; Enables 386 protection h/w
; Loads pagings registers
; Enables 386 paging h/w
;
;--

public _EnableProtectPaging
_EnableProtectPaging  proc near
;
; Sanitize ES and GS and clean out any junk in the upper 16bits
; of the flags that may have been left by the bios, before we go protected
;
        push     dword ptr 0
        popfd
        mov      bx,sp
        mov      dx,[bx+2]  ; are we enabling prot/paging for the first time?
        xor      ax,ax
        mov      gs,ax
        mov      es,ax


;
; FS must contain the selector of the PCR when we call the kernel
;
        push    PCR_Selector
        pop     fs
;
; Load the gdtr and idtr.
; We disable interrupts here since we can't handle interrups with the
; idt loaded while were in real mode and before we switch to protmode.

        cli
        lgdt     fword ptr [_GDTregister]
        lidt     fword ptr [_IDTregister]


;
; We have to stamp the segment portion of any real-mode far pointer with
; the corresponding selector values before we go protected.
;
        mov      si,offset _ScreenStart
        mov      word ptr [si+2],VideoSelector
        mov      si,offset _vp
        mov      word ptr [si+2],VideoSelector
        mov      si,offset _MemoryDescriptorList
        mov      word ptr [si+2],MdlSelector

;
; Enable protect and paging mode
;
        mov      eax,cr0

; If we're enabling protect mode for the first time, don't turn on paging
; because the osloader does all that.  However, if we're returning to
; protected mode, the page tables are already setup, therefore we do want
; to turn paging on.
        cmp     dx,1
        jnz     only_prot
        or      eax,PROT_MODE + ENABLE_PAGING
        mov     cr0,eax

;
; The following JMP must be DWORD-aligned in order to avoid an obscure i386
; hardware bug.  If not, it is possible (albeit unlikely) that the prefetch
; queue can get trashed.
;

ALIGN 4
        jmp     flush


only_prot:
        or       eax,PROT_MODE
        mov      cr0,eax
;
; Flush the prefetch queue
;

ALIGN 4
        jmp     flush
flush:


;
; Load CS with the SU module's code selector
;
        push    SuCodeSelector
        push    offset cs:restart
        retf
;
; Now load DS and SS with the SU module's protect mode data selector.
;

restart:
        mov      ax,SuDataSelector
        mov      ds,ax
        mov      ss,ax

;
; Load LDT with zero since it will never be used.
;
        xor      bx,bx
        lldt     bx

;
; Load the Task Register and return to the boot SU module.
;
        or       dx,dx
        jnz      epp10


        mov      bx,TSS_Selector
        ltr      bx


epp10:
        ret

_EnableProtectPaging endp

.286p
;** _biosint
;
;   Rom bios interrupt dispatcher
;

public _biosint
_biosint proc    near

        enter   0,0
        push    di
        push    si
        push    ds
        push    es

;       Get pointer to register parameter frame

        les     di,[bp+4]

;       Get requested interrupt number

        mov     ax,es:[di].intnum

;       Check that requested bios interrupt is supported

        sub     ax,10h          ; sub lowest int number supported
        jnc     short bios1
        mov     es:[di].intnum,FUNCTION_ERROR
        jmp     short biosx
bios1:
        shl     ax,1            ; shift if to make it a word offset
        cmp     ax,bios_cnt     ; offset beyond end of table?
        jb      short bios2

;       Error: requested interrupt not supported

        mov     es:[di].sax,FUNCTION_ERROR
        jmp     short biosx

bios2:  mov     bx,ax
        mov     ax,word ptr cs:bios_table[bx]
        push    es              ; save seg of address frame
        push    di              ; save stack register frame pointer
        push    ax              ; address of bios int

        mov     ax,es:[di].sax
        mov     bx,es:[di].sbx
        mov     cx,es:[di].scx
        mov     dx,es:[di].sdx
        mov     si,es:[di].ssi
        mov     es,es:[di].ses
        ret                     ; this sends us to the "int #" instruction

;       We return here from the jmp instruction following the int

bios_ret:

        pop     di              ; get address of register parameter frame
        pop     es              ; restore segment of parameter frame


bios5:  pushf
        pop     es:[di].sfg
        mov     es:[di].sax,ax
        mov     es:[di].sbx,bx
        mov     es:[di].scx,cx
        mov     es:[di].sdx,dx
        mov     es:[di].ssi,si
        mov     es:[di].ses,es

;       Restore original registers and return to caller

biosx:
        pop     es
        pop     ds
        pop     si
        pop     di
        leave
        ret

_biosint endp

;** Bios Interrupt Table
;


bios10: int     10h
        jmp     short bios_ret
bios11: int     11h
        jmp     short bios_ret
bios12: int     12h
        jmp     short bios_ret
bios13: int     13h
        jmp     short bios_ret
bios14: int     14h
        jmp     short bios_ret
bios15: int     15h
        jmp     short bios_ret
bios16: int     16h
        jmp     short bios_ret
bios17: int     17h
        jmp     short bios_ret
bios18: int     18h
        jmp     short bios_ret
bios19: int     19h
        jmp     short bios_ret

bios_table dw      bios10,bios11,bios12,bios13,bios14,bios15,bios16,bios17,bios18,bios19

bios_cnt        equ     $ - bios_table

.386p

;++
;
; _MoveMemory
;
; Routine Description
;
;       Moves dwords in memory from source to destination.
;
; Arguments
;
;       (TOS+4)  =  number of bytes to move
;       (TOS+8)  =  linear address of destination
;       (TOS+12) =  linear address of source
;
; Notes
;
;   1)  Valid page table entries must already exist for the
;       source and destination memory.
;
;   2)  ALL memory in the lower one megabyte is assumed to
;       be identity mapped if used.
;
; USES  ESI, EDI, ECX, FLAGS
;
;
;--


public _MoveMemory
_MoveMemory proc near

        enter    0,0
        push     ds
        push     es
;
; Get source, destination, and count arguments from the stack
; Make "count" the number of dwords to move.
;

        mov      esi,dword ptr [bp+4]
        mov      edi,dword ptr [bp+8]
        mov      ecx,dword ptr [bp+12]
        shr      ecx,2

;
; Load FLAT selectors into DS and ES
;

        mov      ax,KeDataSelector
        mov      ds,ax
        mov      es,ax

;
; Move the block of data.
;
assume es:FLAT, ds:FLAT

;
; move the dwords
;
        cld
        rep     movs    dword ptr [edi],dword ptr [esi]

;
; move the remaining tail
;
        mov     ecx, dword ptr [bp+12]
        and     ecx, 3
        rep     movs    byte ptr [edi],byte ptr [esi]


assume es:nothing, ds:DGROUP

        pop      es
        pop      ds
        leave
        ret

_MoveMemory endp



;++
;
; _ZeroMemory
;
; Routine Description
;
;       Writes zeros into memory at the target address.
;
; Arguments
;
;       (TOS+4)  =  linear address of target
;       (TOS+8)  =  number of bytes to zero
;
; Notes
;
;   1)  Valid page table entries must already exist for the
;       source and destination memory.
;
;   2)  ALL memory in the lower one megabyte is assumed to
;       be identity mapped if used.
;
; USES  ESI, EDI, ECX, FLAGS
;
;
;--

public _ZeroMemory
_ZeroMemory proc near


        enter    0,0
        push     es
;
; Get source, destination, and count arguments from the stack
; Make "count" the number of dwords to move.
;

        mov      edi,dword ptr [bp+4]
        mov      ecx,dword ptr [bp+8]
        shr      ecx,2

;
; Load FLAT selectors into DS and ES
;

        mov      ax,KeDataSelector
        mov      es,ax
        xor      eax,eax

;
; Zero the the block of data.
;
assume es:FLAT

;
; Zero the dwords
;
        cld
        rep     stos    dword ptr [edi]

;
; Zero the remaining bytes
;
        mov     ecx, dword ptr [bp+8]
        and     ecx, 3
        rep     stos    byte ptr [edi]

assume es:nothing, ds:DGROUP

        pop      es
        leave
        ret


_ZeroMemory endp

public _SetMemory
_SetMemory proc near


        enter    0,0
        push     es
;
; Get source, destination, and count arguments from the stack
; Make "count" the number of dwords to move.
;

        mov      edi,dword ptr [bp+4]
        mov      ecx,dword ptr [bp+8]
        shr      ecx,2

;
; Load FLAT selectors into DS and ES
;

        mov      ax,KeDataSelector
        mov      es,ax
        mov      eax,dword ptr [bp+12]

;
; Set the the block of data.
;
assume es:FLAT

;
; Set the dwords
;
        cld
        rep     stos    dword ptr [edi]

;
; Set the remaining bytes
;
        mov     ecx, dword ptr [bp+8]
        and     ecx, 3
        rep     stos    byte ptr [edi]

assume es:nothing, ds:DGROUP

        pop      es
        leave
        ret


_SetMemory endp




;++
;
; Turn Floppy Drive Motor Off
;
;--

public _TurnMotorOff
DriveControlRegister      equ      3f2h     ; Floppy control register

_TurnMotorOff proc near

        mov      dx,DriveControlRegister
        mov      ax,0CH
        out      dx,al
        ret

_TurnMotorOff endp


;
; Note: we do not save and restore the gdt and idt values because they
; cannot change while external services are being used by the OS loader.
; This is because they MUST remain identity mapped until all mode
; switching has ceased.
;

public _RealMode
_RealMode proc near

;
; Switch to real-mode
;

        sgdt     fword ptr [_GDTregister]
        sidt     fword ptr [_IDTregister]
        push     [saveDS]          ; push this so we can get to it later
        mov      ax,SuDataSelector
        mov      es,ax
        mov      fs,ax
        mov      gs,ax

        mov      eax,cr0
        and      eax, not (ENABLE_PAGING + PROT_MODE)
        mov      cr0,eax

;
; flush the pipeline
;
        jmp     far ptr here
here:

;
; Flush TLB
;

; HACKHACK - We don't know where the page directory is, since it was
;       allocated in the osloader.  So we don't want to clear out cr3,
;       but we DO want to flush the TLB....
;
        mov     eax,cr3

        nop                             ; Fill - Ensure 13 non-page split
        nop                             ; accesses before CR3 load
        nop                             ; (P6 errata #11 stepping B0)
        nop

        mov     cr3,eax
;
; switch to real mode addressing
;
; N. B. We need to do a far jump rather than a retf, because a retf will not
;       reset the access rights to CS properly.
;
        db      0EAh                    ; JMP FAR PTR
        dw      offset _TEXT:rmode      ; 2000:rmode
        dw      02000h
rmode:
        pop      ax
        mov      ds,ax
        mov      ss,ax
;
; Stamp video pointers for real-mode use
;
        mov     si,offset _ScreenStart
        mov     word ptr [si+2],0b800h
        mov     si,offset _vp
        mov     word ptr [si+2],0b800h
;
; re-enable interrups
;
        lidt    fword ptr [_IDTregisterZero]

;
; Re-enable interrupts
;

        sti
        ret

_RealMode endp

;** _TransferToLoader  - transfer control the the OS loader
;
;
;  Arguments:
;
;       None
;
;  Returns:
;
;       Does not return
;
;**

public _TransferToLoader
_TransferToLoader proc near

;  generates a double fault for debug purposes
;        mov      sp,0
;        push 0

        mov      ebx,dword ptr [esp+2]      ; get entrypoint arg
        xor      eax,eax
        mov      ax,[saveDS]

;
; Setup OS loader's stack. Compute FLAT model esp to id map to
; original stack.
;
        mov      cx,KeDataSelector
        mov      ss,cx
        mov      esp,LOADER_STACK  
;
; Load ds and es with kernel's data selectors
;

        mov      ds,cx
        mov      es,cx

;
; Setup pointer to file system and boot context records
;
; Make a linear pointer to the Boot Context Record

        shl      eax,4
        xor      ecx,ecx
        mov      cx,offset _BootRecord
        add      eax,ecx
        push     eax

        push     1010h       ; dummy return address.
        push     1010h       ; dummy return address.

;
; Push 48bit address of loader entry-point
;
        db OVERRIDE
        push    KeCodeSelector
        push    ebx

;
; Pass control to the OS loader
;
        db OVERRIDE
        retf

_TransferToLoader endp




;++
; Description:
;
;       Gets memory block sizes for memory from zero to one meg and
;       from one meg to 64 meg. We do this by calling int 12h
;       (get conventional memory size) and int 15h function 88h (get
;       extended memory size).
;
; Arguments:
;
;       None
;
; Returns:
;
;       USHORT - Size of usable memory (in pages)
;
;--

public _IsaConstructMemoryDescriptors
BmlTotal        equ     [bp-4]
Func88Result    equ     [bp-6]
_IsaConstructMemoryDescriptors proc near
        push    bp                     ; save ebp
        mov     bp, sp
        sub     sp, 6
;
; Initialize the MemoryList to start with a zero entry.  (end-of-list)
;
        les     si, dword ptr _MemoryDescriptorList
        xor     eax,eax
        mov     es:[si].BlockSize,eax
        mov     es:[si].BlockBase,eax

;
; Get conventional (below one meg) memory size
;
        push    es
        push    si
        int     12h
        movzx   eax,ax
;
; EAX is the number of 1k blocks, which we need to convert to the
; number of bytes.
;
        shl     eax,10

        push    eax
        shr     eax, 12
        mov     BmlTotal, eax
        xor     eax,eax
        push    eax
        call    _InsertDescriptor
        add     sp,8

;
; Get extended memory size and fill-in the second descriptor
;

        mov     ah,88h

        int     15h

        mov     Func88Result,ax
        and     eax,0ffffh
;
; EAX is the number of 1k blocks, which we need to convert to the
; number of bytes.
;
        shl     eax,10
        push    eax
        shr     eax,12
        add     BmlTotal, ax
        mov     eax,0100000h
        push    eax
        call    _InsertDescriptor
        add     sp,8

;
; Try function E801, see if that is supported on this machine
;
        mov     ax,0E801h
        int     15h
        jc      short Isa50

        cmp     ax,Func88Result     ; Is extended memory same as 88?
        je      short Isa40         ; Yes, go add the rest

        cmp     ax, (16-1) * 1024   ; Is extended memory exactly 16MB?
        jne     short Isa50         ; No, conflict between 88 & E801

Isa40:
;
; Function looks like it worked
;
; AX = extended memory < 16M in 1k blocks
; BX = extended memory > 16M in 64k blocks
;
        and     ebx,0ffffh
        jz      short Isa50

        shl     ebx,16              ; ebx = memory > 16M in bytes (via E801)
        add     ebx, 16*1024*1024   ; ebx = end of memory in bytes (via E801)

        mov     ax, Func88Result
        and     eax,0ffffh
        shl     eax, 10             ; eax = memory > 1M in bytes (via 88)
        add     eax, 1*1024*1024    ; eax = end of memory in bytes (via 88)

        sub     ebx, eax            ; ebx = memory above eax
        jbe     short Isa50         ; if ebx <= eax, done

        push    ebx
        shr     ebx,12
        add     BmlTotal, bx
        push    eax
        call    _InsertDescriptor
        add     sp,8
        and     eax,0ffffh

Isa50:
        pop     si
        pop     es
        mov     eax, BmlTotal
        mov     sp, bp
        pop     bp
        ret

_IsaConstructMemoryDescriptors endp

;++
;
; BOOLEAN
; Int15E820 (
;     E820Frame     *Frame
;     );
;
;
; Description:
;
;       Gets address range descriptor by calling int 15 function E820h.
;
; Arguments:
;
; Returns:
;
;       BOOLEAN - failed or succeed.
;
;--

cmdpFrame       equ     [bp + 6]
public _Int15E820
_Int15E820 proc near

        push    ebp
        mov     bp, sp
        mov     bp, cmdpFrame           ; (bp) = Frame
        push    es
        push    edi
        push    esi
        push    ebx

        push    ss
        pop     es

        mov     ebx, [bp].Key
        mov     ecx, [bp].DescSize
        lea     di,  [bp].BaseAddrLow
        mov     eax, 0E820h
        mov     edx, 'SMAP'             ; (edx) = signature

        INT     15h

        mov     [bp].Key, ebx           ; update callers ebx
        mov     [bp].DescSize, ecx      ; update callers size

        sbb     ecx, ecx                ; ecx = -1 if carry, else 0
        sub     eax, 'SMAP'             ; eax = 0 if signature matched
        or      ecx, eax
        mov     [bp].ErrorFlag, ecx     ; return 0 or non-zero

        pop     ebx
        pop     esi
        pop     edi
        pop     es
        pop     ebp
        ret

_Int15E820 endp

;++
;
; t_PXENV_ENTRY far *
; PxenvGetEntry (
;     VOID
; );
;
;
; Description:
;       Get the address of the PXENV Entry Point structure using Int 1Ah.
;
; Arguments:
;       none
;
; Returns:
;       DX:AX := Far pointer to PXENV Entry Point structure.
;
;--

public _PxenvGetEntry
_PxenvGetEntry proc near

        push    ebp                     ; Save important C registers
        push    edi
        push    esi
        push    ds
        push    es

        mov     ax, 5650h               ; Get address of PXENV Entry Point
        int     1Ah                     ; structure.

        jc      no_pxenv_entry          ; CF set if function not supported.

        cmp     ax, 564Eh               ; Check for PXENV API signature.
        jne     no_pxenv_entry

        mov     dx, es                  ; Return far pointer to C in DX:AX.
        mov     ax, bx

        jmp     exit

no_pxenv_entry:
        xor     dx, dx                  ; Return NULL if PXENV Entry Point
        xor     ax, ax                  ; structure is not available.

exit:
        pop     es                      ; Restore C registers.
        pop     ds
        pop     esi
        pop     edi
        pop     ebp

        ret

_PxenvGetEntry endp


;++
;
; UINT16
; PxenvApiCall(
;     UINT16 service,
;     void far *param
; );
;
;
; Description:
;       Make a service call into the PXENV API.
;
; Arguments:
;       ENTRY (TOS+6) := Far pointer to PXENV Entry Point structure
;       SERVICE (TOS+10) := PXENV API service number
;       PARAM (TOS+12) := Far pointer to PXENV API parameter structure
;
; Returns:
;       AX := Return value from PXENV API service
;       Contents of parameter structure will be modified as per API.
;
;--

SERVICE equ     word ptr [bp + 6]
PARAM   equ     dword ptr [bp + 8]

public _PxenvApiCall
_PxenvApiCall proc near

        push    ebp                     ; Save caller's stack frame & use BP
        mov     bp, sp                  ; to reference stack parameters.

        push    ebx                     ; Save all general use registers.
        push    ecx
        push    edx
        push    edi
        push    esi
        push    ds
        push    es

        mov     bx, SERVICE             ; Setup BX & ES:DI for call to

ifdef ALLOW_WAIT_FOR_F12_API
        cmp     bx,-1
        jne     xxxSkip
xxxLoop:
        call    GetKeyEx                ; get keystroke, if any
        mov     ebx,eax                 ; copy it
        cmp     ebx,08600h              ; check for F12
        jz      pxenv_api_ret           ; jump out if F12 pressed
        cmp     ebx,0011Bh              ; check for ESC
        jz      pxenv_api_ret           ; jump out if ESC pressed
        jmp     xxxLoop                 ; loop
xxxSkip:
endif

        les     di, PARAM               ; PXENV API service.

        lds     si, dword ptr _NetPcRomEntry

        push    cs                      ; Push far return address onto stack
        lea     ax, pxenv_api_ret       ; (just as if we did a far call).
        push    ax

        push    ds
        push    si

        retf                            ; Far return into API entry point.

pxenv_api_ret:

        pop     es                      ; Restore all general use registers.
        pop     ds
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx

        pop     ebp                     ; Restore caller's stack frame.

        ret

_PxenvApiCall endp

;++
;
; ULONG
; CheckForF12(
;     VOID
; );
;
;
; Description:
;       This routine spins for three seconds monitoring the keyboard.
;       If the user presses F12, the routine returns immediately with
;       eax==1. If the user presses ESC, the routine returns immediately
;       with eax==0. All other keys are ignored. If neither F12 nor ESC
;       is pressed within three seconds, the routine returns with eax==0.
;       
;       If this is a restart invoked by a loader program (indicate by
;       a block of memory at a known location initialized correctly), the
;       return returns immediately with eax==1.
;
; Arguments:
;       None.
;
; Returns:
;       EAX - 1 if F12 pressed or if this is a restart; otherwise 0.
;
;--

CheckForF12     proc    near

;
; Save DS and ES.
;

        push    ds
        push    es

;
; Set DS and ES to 0.
;

        mov     ax,0
        mov     ds,ax
        mov     es,ax

;
; Point ESI to the last DWORD of the restart block. Check to see if the
; tag value is present. If not, jump to the wait loop.
;

        mov     esi,07c00h + 08000h - 4 ; point to last DWORD of block

        mov     ebx,[esi]               ; get the tag value
        cmp     ebx,'rtsR'              ; is it right?
        jnz     DoF12Check              ; if not, enter wait loop

;
; Calculate the checksum of the block. If it is 0, then this is a valid
; restart block, so pretend that the user pressed F12.
;

        mov     eax,0                   ; accumulated checksum
        mov     ecx,128/4               ; length of block (last 128 bytes
                                        ;  of restart block)

F12csLoop:

        mov     ebx,[esi]               ; get next DWORD
        add     eax,ebx                 ; add it to accumulated checksum
        sub     esi,4                   ; point to previous DWORD
        dec     ecx                     ; check for end of block
        jnz     F12csLoop

        cmp     eax,0                   ; is checksum correct?
        mov     eax,1                   ; indicate F12 pressed
        jz      F12Done                 ; jump out if checksum is correct

DoF12Check:

;
; Write a prompt string. (Yes, this is not internationalizable.)
;

        push    cs                      ; prompt string is in code segment
        pop     ds
        mov     si,offset F12Prompt     ; ds:si points to prompt string

IFDEF HEADLESS_SRV

        mov     ax, cs:TerminalStatus   ; If there is a terminal, initialize it
        and     al, 0b0h
        cmp     al, 0b0h
        jne     SkipTerminalInit

;
; Set color to black on white "\033[m\017"
;
        mov     ah, 01h
        mov     al, 1bh
        int     14h
        mov     ah, 01h
        mov     al, '['
        int     14h
        mov     ah, 01h
        mov     al, 'm'
        int     14h
        mov     ah, 01h
        mov     al, 11h
        int     14h
    
;
; Clear the terminal screen "\033[H\033[J"
; 
        mov     ah, 01h
        mov     al, 1bh
        int     14h
        mov     ah, 01h
        mov     al, '['
        int     14h
        mov     ah, 01h
        mov     al, 'H'
        int     14h
        mov     ah, 01h
        mov     al, 1bh
        int     14h
        mov     ah, 01h
        mov     al, '['
        int     14h
        mov     ah, 01h
        mov     al, 'J'
        int     14h
        
SkipTerminalInit:

endif   

PromptLoop:

        lodsb                           ; get next byte of string
        cmp     al,0                    ; end of string?
        jz      PromptDone              ; jump out if yes

IFDEF HEADLESS_SRV
        
        mov     bx, cs:TerminalStatus   ; if there is a terminal, write out to it as well
        and     bl, 0b0h
        cmp     bl, 0b0h
        jne     SkipTerminalPrompt
        
        mov     ah, 01h                 ; Write command
        mov     dx, HEADLESS_COMPORT    ; Com port
        int     14h                     ; Make com port call
        
SkipTerminalPrompt:

endif

        mov     ah,14
        mov     bx,7
        int     10h                     ; print the byte

        jmp     PromptLoop

PromptDone:

        push    es                      ; restore ds
        pop     ds
        

;
; Capture the current RTC value.
;

        call    GetCounterReal          ; get starting RTC value
        mov     edi,eax                 ; calculate RTC value for now + 3 secs.
IFDEF HEADLESS_SRV
        add     edi,182                 ;  (if this is headless, make it 10 seconds)
ELSE
        add     edi,55                  ;  (RTC clicks 18.2 times per second)
ENDIF

F12Loop:

        call    GetKeyEx                ; get keystroke, if any
        mov     ebx,eax                 ; copy it

        cmp     ebx,08600h              ; check for F12
        mov     eax,1                   ; indicate F12 pressed
        jz      F12Done                 ; jump out if F12 pressed

        cmp     ebx,0DA00h              ; check for F12
        mov     eax,1                   ; indicate F12 pressed
        jz      F12Done                 ; jump out if F12 pressed

        cmp     ebx,0011Bh              ; check for ESC
        mov     eax,0                   ; indicate F12 not pressed
        jz      F12Done                 ; jump out if ESC pressed

        call    GetCounterReal          ; get current RTC value
        cmp     eax,edi                 ; is it higher than end value?
        mov     eax,0                   ; indicate F12 not pressed
        jb      F12Loop                 ; loop if current < end

F12Done:

        pop     es
        pop     ds

        ret

CheckForF12     endp

F12Prompt       db      13,10,"Press F12 for network service boot",13,10,0


;++
;
;   ULONG
;   GetTickCount(
;       VOID
;       )
;
;   Description:
;
;       Reads the tick counter (incremented 18.2 times per second)
;
;   Arguments:
;       None.
;
;--
        public  _GetTickCount
_GetTickCount proc near

		push 	cx
        mov     ah,0
        int     01ah
        mov     ax,dx           ; low word of count
        mov     dx,cx           ; high word of count
		pop     cx
        ret
_GetTickCount endp



_TEXT   ends

        end      Start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\su.h ===
//
// Master include file for StartUp Module
//

#define i386
#define __stdcall
#define __cdecl
#define UNALIGNED
#pragma warning(4:4103)
#include "types.h"
#include "ntmisc.h"
#include "ntconfig.h"
#include "global.h"
#include "constant.h"
#include "memmap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\pxe_api.inc ===
;
; Modifications:   $Header:   W:/LCS/ARCHIVES/preboot/lsa2/base/iputil.asv   1.3   Apr 04 1997 10:05:58   GRGUSTAF  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Local includes
;

include pxe_cmn.inc


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; One of the following command op-codes needs to be loaded into the
; op-code register (BX) before making a call a PXENV API service.
;
PXENV_UNLOAD_STACK		equ	070h
PXENV_GET_BINL_INFO		equ	071h
PXENV_RESTART_DHCP		equ	072h
PXENV_RESTART_TFTP		equ	073h


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Structures and records
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
s_pxenv_entry struc
en_signature	db	6 dup(?)	; 'PXENV+'

en_version	dw	?		; MSB=major, LSB=minor

en_bytes	db	?		; sizeof s_pxenv_entry
en_checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.

en_rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
en_rm_entry_seg	dw	?

en_pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
en_pm_entry_base dd	?		; address and 16-bit offset.
s_pxenv_entry ends


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; PXENV API parameter structure typedefs.
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
s_PXENV_UNLOAD_STACK struc
ul_status	dw	?		; Out: See PXENV_STATUS_xxx constants.
ul_rm_entry_off	dw	?		; Out: 16-bit real-mode segment and
ul_rm_entry_seg	dw	?		;      offset of PXENV Entry Point
					;      structure.
ul_pm_entry_off	dw	?		; Out: 16-bit protected-mode offset
ul_pm_entry_base dd	?		;      and segment base address of
					;      PXENV Entry Point structure.
s_PXENV_UNLOAD_STACK ends


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
s_PXENV_GET_BINL_INFO struc
gbi_status	dw	?		; Out: See PXENV_STATUS_xxx constants.
gbi_packet_type	dw	?		; In: See PXEVN_PACKET_TYPE_xxx */
					;     constants.
gbi_buffer_size	dw	?		; In: Size of the buffer in
					;     bytes.  Specifies the maximum
					;     amount of data that will be
					;     copied by the service.  A size
					;     of zero is valid.
					; Out: Amount of BINL data, in
					;      bytes, that was copied into
					;      the buffer.  For an input
					;      size of zero, no data will be
					;      copied and BufferSize will be
					;      set to the maximum amount of
					;      data available to be copied.
gbi_buffer_offset dw	?		; In: 16-bit offset and segment/
gbi_buffer_segment dw	?		;     selector of a buffer to copy
					;     the BINL information into.
s_PXENV_GET_BINL_INFO ends


PXENV_PACKET_TYPE_DHCP_DISCOVER	equ	1
PXENV_PACKET_TYPE_DHCP_ACK	equ	2
PXENV_PACKET_TYPE_BINL_REPLY	equ	3


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
s_PXENV_RESTART_DHCP struc
rd_status	dw	?		; Out: See PXENV_STATUS_xxx constants.
s_PXENV_RESTART_DHCP ends



; EOF - $Workfile:   pxe_api.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\sudata.asm ===
;++
;
; Module name
;
;       su.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Mar-1-90
;
; Description
;
;       Static data for Startup module for the 386 NT OS loader. The gdt
;       idt, and double fault tss are statically defined here. Also most
;       of the zero init static data is defined here because the SU module
;       must have a zero length .bss section.
;
;
;--

.386p

SU_DATAMODULE       equ      1


include su.inc
include memmap.inc



_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

;
; Global Descriptor Table
;
; Note, the SuCode and SuData segments must have limits of 64k in
; order for the mode switch code to work.
;

public _Beginx86Relocation
public _GDT

_Beginx86Relocation       equ      $
_GDT  equ $
;;;
;;;   Lim 0-15,  Base0-15,Base 16-23, LimAcc,
;;;

;
; Selector 00h - Null selector - unsused
;

GDTDesc <00000h, 00000h, 000h, 000h, 000h, 000h>

;
; Selector 08h  KeCodeSelector  - kernel code segment : FLAT 4gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 09ah, 0cfh, 000h>

;
; Selector 10h - KeDataSelector - kernel data segment : FLAT 4gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 092h, 0cfh, 000h>

;
; Selector 18h - UsCodeSelector - User code segment : FLAT 2gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 0fah, 0cfh, 000h>

;
; Selector 20h - UsDataSelector - User data segment : FLAT 2gig limit
;
GDTDesc <0ffffh, 00000h, 000h, 0f2h, 0cfh, 000h>

;
; Selector 28h - TSS_Selector - Kernels TSS
;

GDTDesc <EndTssKernel - _TssKernel - 1, offset _TEXT:_TssKernel, \
002h, 089h, 000h, 000h> ; TSS

;
; Selector 30h - PCR_Selector - Master Boot Processor's PCR segment
;       This is actually edited later in BlSetupForNt in order to
;       point to a page located at a high virtual address.
;

GDTDesc <01h, 00000h, 000h, 092h, 0c0h, 000h>

;
; Selector 38h - TEP_Selector - Thread Environment
;

GDTDesc <0fffh, 00000h, 000h, 0f3h, 040h, 000h>

;
; Selector 40 - BDA_SAelector - Bios Data Area near-clone
;

GDTDesc <0ffffh, 00400h, 000h, 0f2h, 000h, 000h>

;
; Selector 48h - LdtDescriptor - used to load an ldt
;       (Gets set at Ldt set and process switch by the kernel)
;

GDTDesc <00000h, 00000h, 000h, 000h, 000h, 000h>

;
; Selector 50h - DblFltTskSelector - Double Fault TSS
;

GDTDesc <EndTssDblFault32 - _TssDblFault32 - 1, offset _TEXT:_TssDblFault32,  \
002h, 089h, 000h, 000h> ;

;
; Selector 58h - SuCodeSelector - Startup module's code segment
;

GDTDesc <0ffffh, 00000h, 002h, 09ah, 000h, 000h>

;
; Selector 60h - SuDataSelector - Startup module's data segment
;

GDTDesc <0ffffh, offset _TEXT:DGROUP, 002h, 092h, 000h, 000h>

;
; Selector 68h - VideoSelector - Video display buffer
;

GDTDesc <03fffh, 08000h, 00bh, 092h, 000h, 000h>

;
; Selector 70h - GDT_AliasSelector - GDT Alias Selector
;

GDTDesc <EndGDT - _GDT - 1, 7000h, 0ffh, 092h, 000h,0ffh>


; Debug selectors : CURRENTLY NOT USED

GDTDesc <0ffffh, 00000h, 040h, 09ah, 000h, 080h>  ; 78 Debug Code
GDTDesc <0ffffh, 00000h, 040h, 092h, 000h, 080h>  ; 80 Debug Data
GDTDesc <00000h, 00000h, 000h, 092h, 000h, 000h>  ; 88 Debug Use
GDTDesc <0ffffh, 00000h, 007h, 092h, 000h, 000h>  ; 90 Memory Descriptor List
DEFINED_GDT_ENTRIES     equ     ($ - _GDT) / size GDTDesc
                 dq ((1024 / size GDTDesc) - DEFINED_GDT_ENTRIES) DUP(0)
EndGDT  equ      $
GDT_SIZE         equ      (EndGDT - _GDT)


;;
;; Interrupt Descriptor Table
;;


public _IDT
align   16
_IDT    equ      $
TrapDesc         <offset Trap0,  KeCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap1,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap2,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap3,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap4,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap5,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap6,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap7,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap8,  SuCodeSelector, 8f00h,  0>
;TrapDesc         <offset Trap8,  DblFltTskSelector,8500h,  0>
TrapDesc         <offset Trap9,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapA,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapB,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapC,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapD,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapE,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapF,  SuCodeSelector, 8f00h,  0>
DEFINED_IDT_ENTRIES     equ     ($ - _IDT) / size TrapDesc
                 dq (IDT_ENTRIES - DEFINED_IDT_ENTRIES) DUP(0)



EndIDT                    equ   $
public _Endx86Relocation
_Endx86Relocation         equ      $

;
; disk-base table.  We copy it from the ROM to here so we can patch the
; last sector number.  This lets us access both 5.25" and 3.5" drives.
;
Public _DiskBaseTable
_DiskBaseTable  equ     $
    SpecifyBytes dw 0
    WaitTime     db 0
    SectorLength db 0
    LastSector   db 0
    SecGapLength db 0
    DataTransfer db 0
    TrackGapLength db 0
    DataValue    db 0
    HeadSettle   db 0
    StartupTime  db 0

Public _RomDiskBasePointer
_RomDiskBasePointer dd 0

;
; Enhanced Disk Drive Spec. Disk Address Packet
;
Public _EddsAddressPacket
_EddsAddressPacket  equ     $
    PacketSize   db  10h
    Reserved1    db  0
    Blocks2Xfer  dw  0
    XferBuf      dd  0
    LBALow       dd  0
    LBAHigh      dd  0

;
; Task State Segment for Double Fault Handler
;
Public _TssDblFault
align 16
_TssDblFault     equ      $
        dw       0 ;link
        dw       offset _DATA:DblFaultStack
        dw       SuDataSelector
        dd       0 ; ring1 ss:sp
        dd       0 ; ring2 ss:sp
        dw       offset _TEXT:Trap8
        dw       0 ; flags
        dw       0 ; ax
        dw       0 ; cx
        dw       0 ; dx
        dw       0 ; bx
        dw       offset _DATA:DblFaultStack ; sp
        dw       0 ; bp
        dw       0 ; si
        dw       0 ; di
        dw       SuDataSelector  ; es
        dw       SuCodeSelector  ; cs
        dw       SuDataSelector  ; ss
        dw       SuDataSelector  ; ds
        dw       0 ; ldt selector
        dw       0
EndTssDblFault   equ      $


_TssDblFault32   equ      $
        dd       0 ;link
        dd       offset _DATA:DblFaultStack
        dd       SuDataSelector
        dd       0 ; ring1 esp
        dd       0 ; ring1 ss
        dd       0 ; ring2 esp
        dd       0 ; ring2 ss
        dd       PD_PHYSICAL_ADDRESS
        dd       offset _TEXT:Trap8
        dd       0 ; eflags
        dd       0 ; eax
        dd       0 ; ecx
        dd       0 ; edx
        dd       0 ; ebx
        dd       offset _DATA:DblFaultStack ; sp
        dd       0 ; bp
        dd       0 ; si
        dd       0 ; di
        dd       SuDataSelector  ; es
        dd       SuCodeSelector  ; cs
        dd       SuDataSelector  ; ss
        dd       SuDataSelector  ; ds
        dd       0 ;fs
        dd       0 ;gs
        dd       0 ; ldt selector
        dd       0 ; i/o map
        dd       0 ;
        dd       0 ;
EndTssDblFault32   equ      $



;
; Stack for Double Fault Handler Task
;

public _FileStart
_FileStart       dd       0

align 4
public DblFaultStack
                 dw       50 DUP(0)
DblFaultStack    equ      $

;
; Note that we need at least 2k of real-mode stack because some EISA BIOS
; routines require it.
;
align 4
public SuStack
public _SuStackBegin
_SuStackBegin    equ      $
                 db       2048 DUP (0)
SuStack          equ      $

align 16
public _TssKernel
_TssKernel       dw       60  DUP(0)
EndTssKernel     equ      $

align 4
public _GDTregister
_GDTregister     dw       EndGDT - _GDT - 1
                 dw       (SYSTEM_PAGE_PA and 0ffffh) + offset DGROUP:_GDT
                 dw       (SYSTEM_PAGE_PA SHR 16) and 0ffh

align 4
public _IDTregister
_IDTregister     dw       EndIDT - _IDT - 1
                 dw       (SYSTEM_PAGE_PA and 0ffffh) + offset DGROUP:_IDT
                 dw       (SYSTEM_PAGE_PA SHR 16) and 0ffh

;
; We load the idtr from the this fword .
;
public _IDTregisterZero
_IDTregisterZero dw       0ffffh
                 dd       0

;
; We save the base of the real mode data segment here so we
; can use it later in calculations of the linear address of
; the start of DGROUP.
;
public saveDS
saveDS           dw       0
;
; When ever we enter the debugger we set this variable to
; on so we can tell if we've faulted in the debugger when
; we get an exception.
;
public _InDebugger
_InDebugger      dw       0

; We save SP here when we get an exception in the debugging
; version of the SU module. If we get an exception in the
; debugger, we use this value to reset the stack to point to
; the base of the original exception/break-point stack frame.
;
public SaveSP
SaveSP           dw       0

;
; NetPcRomEntry is the address of the entry point exported by the
; NetPC ROM.
;

public _NetPcRomEntry
_NetPcRomEntry  dd      0

;
; BOOT CONTEXT RECORD
;

;
; Export Entry Table
;

extrn RebootProcessor:near
extrn GetSector:near
extrn GetEddsSector:near
extrn GetKey:near
extrn GetCounter:near
extrn Reboot:near
extrn DetectHardware:near
extrn HardwareCursor:near
extrn GetDateTime:near
extrn ComPort:near
extrn GetStallCount:near
extrn InitializeDisplayForNt:near
extrn GetMemoryDescriptor:near
extrn GetElToritoStatus:near
extrn GetExtendedInt13Params:near
extrn NetPcRomServices:near
extrn BiosRedirectService:near

SU_LOAD_ADDRESS equ 20000h



; FsContext
;
;
public _FsContext
align 4
_FsContext FsContextRecord      <0>

;
; Memory Descriptor Table
;       The Memory Descriptor Table begins at 7000:0000 and grows upward.
;       Note that this is 64k above the start of the OS Loader Heap and
;       64k below the start of the OS Loader Stack.  This is ok, since the
;       x86 Arc Emulation will have converted all of this information into
;       Arc Memory Descriptors before the OS Loader is initialized.
;

align 4
public _MemoryDescriptorList
_MemoryDescriptorList  dw       0
                       dw       7000h

;
; This is called the External Services Table by the OS loader
;

;**
;   NOTE WELL
;       The offsets of entries in this table must match its twin
;       in startup\i386\sudata.asm, and the structure in boot\inc\bldrx86.h
;**
align 4
public _ExportEntryTable
_ExportEntryTable equ     $
                 dw       offset _TEXT:RebootProcessor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetSector
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetKey
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetCounter
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:Reboot
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:DetectHardware
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:HardwareCursor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetDateTime
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:ComPort
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetStallCount
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:InitializeDisplayForNt
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetMemoryDescriptor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetEddsSector
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetElToritoStatus
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetExtendedInt13Params
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:NetPcRomServices
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       0             ; null slot for
                 dw       0             ; apmattemptreconnect
                 dw       offset _TEXT:BiosRedirectService
                 dw       SU_LOAD_ADDRESS SHR 16
                 dd       0
;**
; See note above
;**

align 4
Public _BootRecord
_BootRecord      dw       offset _TEXT:_FsContext
                 dw       SU_LOAD_ADDRESS SHR 16

                 dw       offset _TEXT:_ExportEntryTable
                 dw       SU_LOAD_ADDRESS SHR 16

;
; The memory descriptor table begins at 0x70000
;
                 dw       0
                 dw       7

public _MachineType
_MachineType     dd       0             ; Machine type infor.

;
; pointer to where osloader.exe is in memory
;
public _OsLoaderStart
_OsLoaderStart          dd      0
public _OsLoaderEnd
_OsLoaderEnd            dd      0
public _ResourceDirectory
_ResourceDirectory      dd      0
public _ResourceOffset
_ResourceOffset         dd      0
public _OsLoaderBase
_OsLoaderBase           dd      0
public _OsLoaderExports
_OsLoaderExports        dd      0
public _BootFlags
_BootFlags              dd      0
public _NtDetectStart
_NtDetectStart          dd      0
public _NtDetectEnd
_NtDetectEnd            dd      0
public _SdiAddress
_SdiAddress             dd      0


;
; Defines the machine variables, we can use them to check the validity of
; loaded Ram Extension later.
;

                public  MachineModel, MachineSubmodel, BiosRevision
MachineModel            db      0
MachineSubmodel         db      0
BiosRevision            db      0

;
; keeps track of 8042 access failing so we can avoid doing it repeatedly
;
public _Empty_8042Failed
_Empty_8042Failed       db      0

_DATA   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\trap.asm ===
;++
;
; Module Name:
;
;       trap.asm
;
; Author:
;
;       Thomas Parslow [tomp]
;
; Created:
;
;       15-Jan-91
;
;
; Description:
;
;       x86 exception code
;
;

include su.inc

;
; Exception Routing Table:
; ~~~~~~~~~~~~~~~~~~~~~~~~
; When an exception occurs in the SU module or before the OS loader
; is able to setup its own IDT, control is vectored to one of the
; Trap0 though TrapF labels. We push a number on the stack identifying
; the exception number and then jump to code that pushes the register set
; onto the stack. We then call a general purpose C routine that will dump
; the register contents, the trap number, and error code information
; onto the display.
;

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

extrn _TrapHandler:near
extrn _putx:near
extrn _GDTregister:fword
extrn _IDTregister:fword
extrn _InDebugger:word
extrn SaveSP:word

public  Trap0,Trap1,Trap2,Trap3,Trap4,Trap5,Trap6,Trap7
public  Trap8,Trap9,TrapA,TrapB,TrapC,TrapD,TrapE,TrapF


Trap0:  TRAP_NUMBER  0,MakeTrapFrame
Trap1:  TRAP_NUMBER  1,MakeTrapFrame
Trap2:  TRAP_NUMBER  2,MakeTrapFrame
Trap3:  TRAP_NUMBER  3,MakeTrapFrame
Trap4:  TRAP_NUMBER  4,MakeTrapFrame
Trap5:  TRAP_NUMBER  5,MakeTrapFrame
Trap6:  TRAP_NUMBER  6,MakeTrapFrame
Trap7:  TRAP_NUMBER  7,MakeTrapFrame
Trap8:  TRAP_NUMBER  8,MakeTrapFrame
Trap9:  TRAP_NUMBER  9,MakeTrapFrame
TrapA:  TRAP_NUMBER  0Ah,MakeTrapFrame
TrapB:  TRAP_NUMBER  0Bh,MakeTrapFrame
TrapC:  TRAP_NUMBER  0Ch,MakeTrapFrame
TrapD:  TRAP_NUMBER  0Dh,MakeTrapFrame
TrapE:  TRAP_NUMBER  0Eh,MakeTrapFrame
TrapF:  TRAP_NUMBER  0Fh,MakeTrapFrame


;
; We save the user's register contents here on the stack and call
; a C routine to display those contents.
; Uses 42 bytes of stack. (40 for frame)
;
; Note that we build a stack frame that's independent of the code and
; stack segments' "size" during execution. That way whether we enter
; with a 16bit or 32bit stack, the arguments frame is exacely the same.
;

MakeTrapFrame:

        mov      eax,esp
        push     ecx
        push     edx
        push     ebx
        push     eax  ; (eax)=(esp)
        push     ebp
        push     esi
        push     edi

        mov      ax,ds
        push     ax
        mov      ax,es
        push     ax
        mov      ax,fs
        push     ax
        mov      ax,gs
        push     ax
        mov      ax,ss
        push     ax
        mov      eax,cr3
        push     eax
        mov      eax,cr2
        push     eax
        mov      eax,cr0
        push     eax
        mov      eax,dr6
        push     eax
        str      ax
        push     ax
;
; Clear out debug register signals
;

        xor      eax,eax
        mov      dr6,eax

;
; Get a known good data segment
;
        mov      ax,SuDataSelector
        mov      ds,ax
;
; Save system registers
;
        mov      bx,offset DGROUP:_GDTregister
        sgdt     fword ptr [bx]
        mov      bx,offset DGROUP:_IDTregister
        sidt     fword ptr [bx]
;
; Is the exception frame on a 16bit or 32bit stack?
;
        mov      ax,ss
        cmp      ax,KeDataSelector
        je       Trap32
        cmp      ax,DbDataSelector
        jne      mtf8
;
; Most likely we took a trap while initializing the 386 kernel debugger
; So we've got a 16bit stack that isn't ours. We need to move
; the stack frame onto the SU module's stack.

        jmp      Trap16

mtf8:
;
; Frame on a our 16bit stack so just call the trap dump routine
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

;
; Get rid of the junk we saved just to display
;
        pop      eax      ; get rid of ebp pushed for other returns
        add      sp,ExceptionFrame.Fgs
;
; Reload the user's context and return to 16bit code
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret





Trap32:
;
; The exception frame is on a 32bit stack so we must setup a 16bit
; stack and then move the exception frame on to it before calling
; the trap dump routine.
;

        mov      ebx,esp
;
; Setup a known good stack
;
        mov      ax,SuDataSelector
        mov      ss,ax
        mov      sp,EXPORT_STACK
;
; Copy the exception frame to the new stack
;

        mov     ecx, (size ExceptionFrame)/2 ; # of words in frame
        mov     esi,ebx                 ; (esi) = offset of argument frame
        push    KeDataSelector          ; (ax) = Flat 32bit segment selector
        pop     ds                      ; (ds:esi) points to argument frame
        push    ss                      ;
        pop     es                      ; (es) = 16bit stack selector
        sub     sp, size ExceptionFrame ; make room for the arguments
        xor     edi,edi                 ; clear out upper 16bits of edi
        mov     di,sp                   ; (es:edi) points to top of stack
;
; Loop and copy a word at a time.
;
msf1:
        mov     ax,[esi]
        mov     es:[edi],ax
        add     esi,2
        add     edi,2
        loop    msf1

        push    es                      ;
        pop     ds                      ; put 16bit selector back into ds

;
; Now call the general purpose exception handler
;
        push     ebx                    ; save esp for return
;
;  Save SP in order to restore the stack in case we
;  take a fault in the debugger
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

IFDEF  DEBUG0
public DebugReturn
DebugReturn:
ENDIF ;DEBUG
        pop      ebx
;
; We may have changed the flags while in the debugger. Copy the
; new eflag to the iret frame. After we restore the original stack
; pointers.
;

        mov      bp,sp
        mov      ecx,[bp].Feflags

        mov      ax,KeDataSelector
        mov      ss,ax
        mov      esp,ebx

        mov      [esp].Feflags,ecx
;
; Get rid of the junk we saved just to display
;
        add      esp,ExceptionFrame.Fgs
;
; Reload the user's context
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret


Trap16:

; The exception frame is on a 16bit stack that isn't ours. So we must
; move the exception frame on to the SU module's stack before calling
; the trap dump routine.
;

        mov      ebx,esp
;
; Setup a known good stack
;
        mov      ax,SuDataSelector
        mov      ss,ax
        mov      sp,EXPORT_STACK
;
; Copy the exception frame to the new stack
;

        mov      ecx, (size ExceptionFrame)/2
        mov      si,bx                 ; (esi) = offset of argument frame
        push     DbDataSelector          ;
        pop      ds                      ; (ds:esi) points to argument frame
        push     ss                      ;
        pop      es                      ; (es) = 16bit stack selector
        sub      sp, size ExceptionFrame ; make room for the arguments
        mov      di,sp                   ; (es:edi) points to top of stack
;
; Loop and copy a word at a time.
;
Trap16_10:
        mov      ax,[si]
        mov      es:[di],ax
        add      si,2
        add      di,2
        loop     Trap16_10

        push     es                      ;
        pop      ds                      ; put 16bit selector back into ds

;
; Now call the general purpose exception handler
;

        push     ebx                    ; save (original esp) for return
;
;  Save SP in order to restore the stack in case we
;  take a fault in the debugger
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

IFDEF  DEBUG0
public Debug16Return
Debug16Return:
ENDIF ;DEBUG
        pop      ebx
;
; We may have changed the flags while in the debugger. Copy the
; new eflag to the iret frame. After we restore the original stack
; pointers.
;

        mov      bp,sp
        mov      ecx,dword ptr [bp].Feflags

        mov      ax,DbDataSelector
        mov      ss,ax
        mov      esp,ebx

        mov      dword ptr ss:[bx].Feflags,ecx
;
; Get rid of the junk we saved just to display
;
        add      sp,ExceptionFrame.Fgs
;
; Reload the user's context
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret



_TEXT   ends
        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\su.inc ===
;++
;
; Module name
;
;       su.inc
;
; Author
;
;       Thomas Parslow  (tomp)  Mar-1-90
;
; Description
;
;       Include file for SU.ASM.
;
;
;--

.386

PAGE_SIZE               equ     1000h
MACHINE_TYPE_ISA        equ     0
MACHINE_TYPE_EISA       equ     1
MACHINE_TYPE_MCA        equ     2

;
; Define the segment:offset address pair of the location to
; load detection module.
; N.B. This definition *MUST* be the same as the ones defined
;      in ..\constant.h
;

DETECTION_ADDRESS_SEG   equ     1000h
DETECTION_ADDRESS_OFFSET        equ     0

;
; Structure definitions and equates for INT 15 function E820
;

E820Frame struc
        ErrorFlag       dd      ?
        Key             dd      ?
        DescSize        dd      ?

        BaseAddrLow     dd      ?
        BaseAddrHigh    dd      ?
        SizeLow         dd      ?
        SizeHigh        dd      ?
        MemoryType      dd      ?
E820Frame ends

MemoryDescriptorFramePointer struc
        E820FramePointer    dd      ?
MemoryDescriptorFramePointer ends



;

IFDEF NEC_98
IDT_ENTRIES             equ     100h

BIOS_KEYBOARD_INTERRUPT equ     18h
BIOS_DISK_INTERRUPT     equ     1bh
else  ;NEC_98
BIOS_DISK_INTERRUPT     equ     13h
BIOS_READ_SECTOR        equ     2
IDT_ENTRIES             equ     100h

BIOS_KEYBOARD_INTERRUPT equ     16h
endif ;NEC_98

EXPORT_STACK            equ     07ffeh
RE_ENABLING             equ     1
LOADER_STACK            equ     061ffch

CR0_ET                  equ     10h

;
; Trap Number macro save eax on the stack and then pushes the
; number of the trap that's in progress.
;

TRAP_NUMBER      macro  num,addr
        IF num EQ 9
        push     eax  ; push place holder for error code
        ENDIF
        IF num LE 7
        push     eax  ; push place holder for error code
        ENDIF
        push     eax       ; save eax on stack first
        mov      eax,num
        push     eax
        jmp      addr
        endm

;;
;
; GetSector Stack Frame Structure
;
; Stack frame definition for GetSector call from OS loader
; to 16bit routines.
;
;;

GetSectorFrame          struc
        FunctionNumber  dd      ?
        DriveNumber     dd      ?
        HeadNumber      dd      ?
        TrackNumber     dd      ?
        SectorNumber    dd      ?
        NumberOfSectors dd      ?
        BufferPointer   dd      ?
GetSectorFrame          ends

;;
;
; GetEddsSector Stack Frame Structure
;
; Stack frame definition for GetEddsSector call from OS loader
; to 16bit routines.
;
;;

GetEddsSectorFrame      struc
        DriveNum        dd      ?
        LBNLow          dd      ?
        LBNHigh         dd      ?
        NumberOfBlocks  dd      ?
        BufPointer      dd      ?
        FunctionNum     dd      ?
GetEddsSectorFrame      ends

RebootFrame             struc
        BootType        dd      ?
RebootFrame             ends

;
; ABIOS services Stack Frame Structure
;
; Stack frame definition for ABIOS services call from OS loader
; to 16 bit routine.
;

AbiosServicesFrame      struc
        AbiosFunction   dd      ?
        CommonDataArea  dd      ?
        InitTable       dd      ?
        RamExtension    dd      ?
        AbiosRoutine    dd      ?
        LogicalId       dd      ?
        NumberLids      dd      ?
AbiosServicesFrame      ends

;
; Hardware detection frame structure
;
; Stack frame definition for DetectHardware call from OS loader
; to 16 bit routine.
;

DetectionFrame          struc
        HeapStart       dd      ?
        HeapSize        dd      ?
        ConfigTree      dd      ?
        HeapUsed        dd      ?
        LoadOptions     dd      ?
        OptionsLength   dd      ?
DetectionFrame          ends

;
; HardwareCursor Stack Frame Structure
;
; Stack frame definition for HardwareCursor call from OS loader
; to 16 bit routine.
;

HardwareCursorFrame     struc
        XCoord          dd      ?
        YCoord          dd      ?
HardwareCursorFrame     ends

;
; GetDateTime Stack Frame Structure
;
; Stack frame definition for GetDateTime call from OS loader
; to 16 bit routine.
;

GetDateTimeFrame        struc
        DateDword       dd      ?
        TimeDword       dd      ?
GetDateTimeFrame        ends


;
; ComPort Stack Frame Structure
;
; Stack frame definition for ComPort call from OS loader
; to 16 bit routine.
;

ComPortFrame            struc
        ComPortPort     dd      ?
        ComPortFunction dd      ?
        ComPortArg      dd      ?
ComPortFrame            ends

;
; IsMcaMachine Stack Frame Structure
;
; Stack frame definition for IsMcaMachine call from OS loader
; to 16 bit routine.
;

IsMcaMachineFrame       struc
        Dummy           dd      ?
IsMcaMachineFrame       ends

;;
;
; GetElToritoStatus Stack Frame Structure
;
; Stack frame definition for GetElToritoStatus call from OS loader
; to 16bit routines.
;
;;

GetElToritoStatusFrame     struc
        SpecPacketPointer  dd      ?
        ETDriveNum         dd      ?
GetElToritoStatusFrame     ends

;;
;
; GetExtendedInt13Params Stack Frame Structure
;
; Stack frame definition for GetExtendedInt13Params call from OS loader
; to 16bit routines.
;
;;

GetExtendedInt13ParamsFrame struc
        ParamPacketPointer dd      ?
        Int13UnitNumber    dd      ?            ; really only a byte >= 0x80
GetExtendedInt13ParamsFrame ends

;;
;
; NetPcRomServices Stack Frame Structure
;
; Stack frame definition for NetPcRomServices call from OS loader
; to 16bit routines.
;
;;

NetPcRomServicesFrame struc
        NetPcRomFunctionNumber          dd      ?
        NetPcRomCommandPacketPointer    dd      ?
NetPcRomServicesFrame ends

;;
;
; BiosRedirectService Stack Frame Structure
;
; Stack frame definition for BiosRedirectService call from OS loader
; to 16bit routines.
;
;;

BiosRedirectServiceFrame struc
        Command          dd      ?
BiosRedirectServiceFrame ends

;;
;
; Memory Descriptor Structure.
;
; Passed to OS loader as part of the boot context record
;
;;

MemoryDescriptor struc
        BlockBase       dd              ?
        BlockSize       dd              ?
MemoryDescriptor ends

;;
;
; File System Context Record Structure
;
;;

FsContextRecord struc
        BootDrive       db              ?
FsContextRecord ends

;;
;
; IDT Descriptor Structure
;
;;

TrapDesc        struc
        IDT_offset      dw              ?
        IDT_selector    dw              ?
        IDT_attribute   dw              ?
        IDT_reserved    dw              ?
TrapDesc        ends

;;
;
; GDT Descriptor Structure ;;
;
;;

GDTDesc         struc
        GDT_limit       dw              0
        GDT_base1       dw              0
        GDT_base2       db              0
        GDT_access      db              0
        GDT_limacc      db              0
        GDT_base3       db              0
GDTDesc         ends


;;
;
; GDT Selector Definitions
;
;;

NULL_Selector           equ     0h
KeCodeSelector          equ     8h
KeDataSelector          equ     10h
UsCodeSelector          equ     18h
UsDataSelector          equ     20h
TSS_Selector            equ     28h
PCR_Selector            equ     30h
TEP_Selector            equ     38h
BDA_Selector            equ     40h
KeLdtSelector           equ     48h
DblFltTskSelector       equ     50h
SuCodeSelector          equ     58h
SuDataSelector          equ     60h
VideoSelector           equ     68h
GDT_AliasSelector       equ     70h
DbCodeSelector          equ     78h
DbDataSelector          equ     80h
DebugUseSelector        equ     88h
MdlSelector             equ     90h

;;
;
; Exception Frame Structure
; Note, this absolutely must match the corresponding structure
; defined in "types.h"
;
;;

ExceptionFrame struc
        Ftr     dw       0
        Fdr6    dd       0
        Fcr0    dd       0
        Fcr2    dd       0
        Fcr3    dd       0
        Fss     dw       0
        Fgs     dw       0
        Ffs     dw       0
        Fes     dw       0
        Fds     dw       0
        Fedi    dd       0
        Fesi    dd       0
        Febp    dd       0
        Fesp    dd       0
        Febx    dd       0
        Fedx    dd       0
        Fecx    dd       0
        TrapNum dd       0
        Feax    dd       0
        Error   dd       0
        Feip    dd       0
        Fcs     dd       0
        Feflags dd       0
ExceptionFrame  ends



FUNCTION_ERROR  equ     -1

;;
;
; Register Frame Structure
;
; For bios int calls
;
;;

reg_frame struc
        intnum  dw      ?
        sfg     dw      ?
        sax     dw      ?
        sbx     dw      ?
        scx     dw      ?
        sdx     dw      ?
        ssi     dw      ?
        ses     dw      ?
reg_frame ends

IFDEF NEC_98
gdpRegistors    struc
    rAL     db  0FFh
    FLG     db  ?
    rBX     dw  ?
    rCX     dw  ?
    rDX     dw  ?
gdpRegistors    ends

PartitionDescriptor struc
    BootableFlag        db  ?
    PartitionType       db  ?
    Reserved00          dw  ?
    IPLSector           db  ?
    IPLTrack            db  ?
    IPLCylinder         dw  ?
    StartingSector      db  ?
    StartingTrack       db  ?
    StartingCylinder    dw  ?
    EndingSector        db  ?
    EndingTrack         db  ?
    EndingCylinder      dw  ?
    PartitionName       db  16 dup(?)       ; ASCII strings
PartitionDescriptor ends

BIOS_FLAG           equ     500h        ; byte in ROM work segment
BIOS_FLAG1          equ     480h        ; byte in ROM work segment
BIOS_FLAG4          equ     484h        ; byte in ROM work segment
BIOS_FLAG5          equ     458h        ; byte in ROM work segment
BIOS_FLAG6          equ     45Ah        ; byte in ROM work segment
AT_SWITCH           equ     457h        ; byte in ROM work segment
DAUA                equ     584h        ; byte in ROM work segment
DISK_EQUIP          equ     55Ch        ; byte in ROM work segment
DISK_EQUIPS_SCSI    equ     482h        ; byte in ROM work segment
EXPMMSIZ            equ     401h        ; byte in ROM work segment
EXPMMSZ2            equ     594h        ; word in ROM work segment
DISK_RESULT         equ     564h        ; word in ROM work segment
H_EQUIPS            equ     47Dh        ; byte in ROM work segment
H_DISK_EQUIPS       equ     47Eh        ; word in ROM work segment
EQUIPS_47Ch         equ     47Ch        ; byte in ROM work segment
IC0                 equ     10000000b
IC1                 equ     01000000b
DAFloppy            equ     00010000b   ; floppy bit in DA
DASCSI              equ     00100000b   ; SCSI bit in DA
DASASI              equ     00000000b   ; SASI bit in DA
DEVICEFORMAT        equ     0FFFFh
TRACKFORMAT         equ     00000h
MEMBANK08           equ     91h         ; bank 08
MEMBANK0A           equ     93h         ; bank 0A

ROLLOVER_COUNT      equ     45011       ; 1/18.2 * 2457.6KHz /3
TIMER_VECTOR        equ     (8*4)
TIMER1_DATA_PORT0   equ     71h         ; Timer1, channel 0 data port
TIMER1_CONTROL_PORT0 equ    77h         ; Timer1, channel 0 control port
TIMER1_INTSHAREREG  equ     879h        ; PC-H98 TIMER INT SHARE REGISTER
COMMAND_8254_COUNTER0 equ   00h         ; Select count 0
COMMAND_8254_RW_16BIT equ   30h         ; Read/Write LSB firt then MSB
COMMAND_8254_MODE2  equ     4           ; Use mode 2

UR_DAT              equ     030h        ; data port
UR_LCR              equ     UR_DAT+2    ; line control registers
UR_LSR              equ     UR_DAT+2    ; line status register
UR_IEN              equ     UR_DAT+5    ; Interrupt enable
UR_TIMERSET         equ     75h         ; 8253 counter set
UR_TIMERMODE        equ     77h         ; 8253 counter mode

UR_MODE             equ     01001110B   ; stop 1, disable p, 8 bpc, 1 stop, x16
UR_COMMAND          equ     00110111B   ; RTS, err reset, RXE, DTR, TXEN
UR_RESET            equ     01000000B   ; internal reset command

RD_RDY              equ     02h         ; recieve data ready
TX_RDY              equ     01h         ; transmitter empty if 1
endif ;NEC_98

;;
;; Processor Flags
;;

PROT_MODE               equ     000000001       ; Enable protect mode operation
ENABLE_PAGING           equ     80000000h       ; Enable paging hardware
PD_PHYSICAL_ADDRESS     equ     99000h
TSS_SIZE                equ     80h
OVERRIDE                equ     66h

;
; Operand and Address size overrides
;

OPSIZE          macro
                db 66h
                endm
ADSIZE          macro
                db 67h
                endm


;
; External Procedures for SUDATA.ASM
;

IFDEF SU_CODEMODULE
extrn _SuMain:near
extrn _ScreenStart:near
extrn _vp:near
extrn _putx:near
extrn _TrapHandler:near
extrn _GDTregister:fword
extrn _IDTregister:fword
extrn _IDTregisterZero:fword
extrn saveDS:word
extrn SuStack:word
extrn _edata:word
extrn _FileStart:dword
ENDIF



;
; External Procedures for SUDATA.ASM
;

IFDEF SU_DATAMODULE
extrn  Trap0:far
extrn  Trap1:far
extrn  Trap2:far
extrn  Trap3:far
extrn  Trap4:far
extrn  Trap5:far
extrn  Trap6:far
extrn  Trap7:far
extrn  Trap8:far
extrn  Trap9:far
extrn  TrapA:far
extrn  TrapB:far
extrn  TrapC:far
extrn  TrapD:far
extrn  TrapE:far
extrn  TrapF:far
extrn  _edata:near
ENDIF



;
; Segment declarations for "Small Model" 16 bit Su Module.
;

_TEXT   segment para use16 public 'CODE'
_TEXT   ends

_DATA   segment para use16 public 'DATA'
_DATA   ends

CONST   segment para use16 public 'CONST'
CONST   ends

_BSS    segment para use16 public 'BSS'
_BSS    ends

DGROUP  group   const, _BSS, _DATA


;;; END OF FILE ;;;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\br\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\cs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\da\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\el\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\es\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\fi\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\fr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\usa\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT has found only %dK of low memory.  512k of low memory\n"  \
"is required to run Windows NT.  You may need to upgrade your\n"      \
"computer or run a configuration program provided by the manufacturer.\n"

#define SU_NO_EXTENDED_MEMORY \
"Windows NT has not found enough extended memory.  7Mb of extended\n"       \
"memory is required to run Windows NT.  You may need to upgrade your\n"     \
"computer or run a configuration program provided by the manufacturer.\n"   \
"\n\nMemory Map:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR is corrupt.  The system cannot boot."

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== GENERAL PROTECTION FAULT ======================== \n\n"
#define STK_OVERRUN_MSG " ===== STACK SEGMENT OVERRUN or NOT PRESENT FAULT =============== \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** At linear address %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\types.h ===
/*

File

      types.h


Description

      defines and structure definitions for nt386 boot loader


Author

      Thomas Parslow  [TomP]

*/

#define IN
#define OUT
#define OPTIONAL
#define NOTHING
#define CONST               const

//
// Void
//

typedef void *PVOID;    // winnt

//
// Basics
//

#define VOID    void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
typedef long LONGLONG;

//
// ANSI (Multi-byte Character) types
//

typedef CHAR *PCHAR;

typedef double DOUBLE;

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt

//
// Unsigned Basics
//

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef unsigned long ULONGLONG;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef ULONG KAFFINITY;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

//
// Far point to Basic
//

typedef UCHAR far  * FPCHAR;
typedef UCHAR far  * FPUCHAR;
typedef VOID far   * FPVOID;
typedef USHORT far * FPUSHORT;
typedef ULONG far  * FPULONG;

//
// Boolean
//

typedef CCHAR BOOLEAN;
typedef BOOLEAN *PBOOLEAN;

//
// UNICODE (Wide Character) types
//

typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

//
// Large (64-bit) integer types and operations
//

typedef struct _LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))
#define toupper(x) (((x) >= 'a' && (x) <= 'z') ? x - 'a' + 'A' : x )
#define isascii(x) (((x) >= ' ' && (x) < 0x80) ? 1 : 0)

#define FLAG_CF 0x01L
#define FLAG_ZF 0x40L
#define FLAG_TF 0x100L
#define FLAG_IE 0x200L
#define FLAG_DF 0x400L

#define TRUE 1
#define FALSE 0
#define NULL   ((void *)0)

typedef UCHAR far  * FPCHAR;
typedef UCHAR far  * FPUCHAR;
typedef VOID far   * FPVOID;
typedef USHORT far * FPUSHORT;
typedef ULONG far  * FPULONG;
typedef UCHAR FAT;
typedef FAT * PFAT;
typedef LONG  NTSTATUS;


typedef struct _FSCONTEXT_RECORD {
    UCHAR BootDrive;
} FSCONTEXT_RECORD, *PFSCONTEXT_RECORD;

typedef struct {
    USHORT SpecifyBytes;
    UCHAR  WaitTime;
    UCHAR  SectorLength;
    UCHAR  LastSector;
    UCHAR  SecGapLength;
    UCHAR  DataTransfer;
    UCHAR  TrackGapLength;
    UCHAR  DataValue;
    UCHAR  HeadSettle;
    UCHAR  StartupTime;
} DISK_BASE_TABLE;

//
// biosint register structure
//

typedef struct {
   USHORT   fn;
   USHORT   fg;
   USHORT   ax;
   USHORT   bx;
   USHORT   cx;
   USHORT   dx;
   USHORT   si;
   USHORT   es;
} BIOSREGS;


//
// Trap Frame Structure when error code is present
//

typedef struct {
    USHORT Ftr;
    ULONG  Fdr6;
    ULONG  Fcr0;
    ULONG  Fcr2;
    ULONG  Fcr3;
    USHORT Fss;
    USHORT Fgs;
    USHORT Ffs;
    USHORT Fes;
    USHORT Fds;
    ULONG  Fedi;
    ULONG  Fesi;
    ULONG  Febp;
    ULONG  Fesp;
    ULONG  Febx;
    ULONG  Fedx;
    ULONG  Fecx;
    ULONG  TrapNum;
    ULONG  Feax;
    ULONG  Error;
    ULONG  Feip;
    ULONG  Fcs;
    ULONG  Feflags;

} TF_ERRCODE, *PTF ;

//
//  Task State Segment structure
//

typedef struct {
    USHORT Link;
    USHORT a;
    ULONG  Esp0;
    USHORT SS0;
    USHORT b;
    ULONG  Esp1;
    USHORT SS1;
    USHORT c;
    ULONG  Esp2;
    USHORT SS2;
    USHORT d;
    ULONG  Cr3;
    ULONG  Eip;
    ULONG  Eflags;
    ULONG  Eax;
    ULONG  Ecx;
    ULONG  Edx;
    ULONG  Ebx;
    ULONG  Esp;
    ULONG  Ebp;
    ULONG  Esi;
    ULONG  Edi;
    USHORT ES;
    USHORT e;
    USHORT CS;
    USHORT f;
    USHORT SS;
    USHORT g;
    USHORT DS;
    USHORT h;
    USHORT FS;
    USHORT i;
    USHORT GS;
    USHORT j;
    USHORT Ldt;
    USHORT k;

} TSS_FRAME, *PTSS_FRAME;


//
// Overlay structure of disk bios parameter block
//

typedef struct {
   USHORT   bps;
   UCHAR    spc;
   USHORT   sra;
   UCHAR    cof;
   USHORT   rde;
   USHORT   tns;
   UCHAR    dmd;
   USHORT   spf;
   USHORT   spt;
   USHORT   noh;
   union {
   USHORT   shs;
   ULONG    bhs;   // hidden sectors
   } hs;
   ULONG    bts;  // extended total sectors
} DISKBPB;

typedef DISKBPB far * FPDISKBPB;



//
// FAT directory structure
//

typedef struct {
   CHAR     fname[11];
   UCHAR    attrb;
   UCHAR    rsrv[10];
   USHORT   time;
   USHORT   date;
   USHORT   clust;
   ULONG    size;

} DIRENTRY,*PDIRENTRY,far * FPDIRENTRY;

typedef struct {
   CHAR  fname[11];
   UCHAR attrb;
   UCHAR rsrv[10];
   USHORT time;
   USHORT date;
   USHORT starting_cluster;
   ULONG file_size;
   ULONG fptr;
   PUCHAR clusterbuffer;
   USHORT cur_phys_cluster;
   USHORT cur_file_cluster;
} FILEDESCRIPTOR,* FILEHANDLE;

/*
typedef struct {

   USHORT bff[FAT_BUFFERS];
   USHORT usebuf;
   FAT *  fcptr;

} FATCACHE;
*/

typedef struct {
   USHORT   limit;
   USHORT   base1;
   UCHAR     base2;
   UCHAR     access;
   UCHAR     limacc;
   UCHAR     base3;
} _GDT,far *FPGDT;


// Debugger initialization table

typedef  ULONG  IDT,*PIDT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\ger\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\hu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startrom\i386\trapdump.c ===
/*++

Copyright (c) 1990  Microsoft Corporation


Module Name:

    trap.c

Author:

    Thomas Parslow   [TomP]  Mar-01-90


Abstract:

    General purpose trap handler for 80386 boot loader. When built in
    debugger is present, output is redirected to the com port. When no
    debugger is present, output goes to the display.


--*/

#include "su.h"

extern
USHORT
InDebugger;

extern
USHORT
DebuggerPresent;

extern
UCHAR
GDTregister;

extern
UCHAR
IDTregister;

extern
VOID
OutPort(
    USHORT
    );

extern
USHORT
InPort(
    VOID
    );

extern
VOID
ReEnterDebugger(
    VOID
    );

extern
USHORT
TssKernel;

extern
USHORT
Redirect;

extern
VOID RealMode(
    VOID
    );

VOID
TrapHandler(
    IN ULONG,
    IN USHORT
    );

VOID
DumpProcessorContext(
    VOID
    );

VOID
DumpSystemRegisters(
    VOID
    );

VOID
DumpCommonRegisters(
    VOID
    );

VOID
DisplayFlags(
    ULONG f
    );


VOID
DumpTSS(
    VOID
    );


ULONG
GetAddress(
    VOID
    );

VOID
GetNumber(
    PCHAR cp
    );

USHORT
GetChar(
    VOID
    );

VOID
DumpAddress(
    ULONG
    );

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== GENERAL PROTECTION FAULT ======================== \n\n"
#define STK_OVERRUN_MSG " ===== STACK SEGMENT OVERRUN or NOT PRESENT FAULT =============== \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define ishex(x)  ( ( x >= '0' && x <= '9') || (x >= 'A' && x <= 'F') || (x >= 'a' && x <= 'f') )


//
// Global Trap Frame Pointer
//

PTF TrapFrame;


VOID
TrapHandler(
    IN ULONG Padding,
    IN USHORT TF_base
    )
/*++

Routine Description:

    Prints minimal trap information

Arguments:


    386 Trap Frame on Stack

Environment:

    16-bit protect mode only.


--*/

{
    //
    // Initialize global trap frame pointer and print trap number
    //

    TrapFrame = (PTF)&TF_base;

    //
    // Fix esp to point to where it pointed before trap
    //

    TrapFrame->Fesp += 24;

    BlPrint("\n TRAP %lx ",TrapFrame->TrapNum);

    //
    // Print the trap specific header and display processor context
    //

    switch(TrapFrame->TrapNum) {

        case 1:
        case 3:
            puts( DEBUG_EXCEPTION );
            DumpCommonRegisters();
            break;

        case 8:
            puts( DBL_FAULT_MSG );
            DumpTSS();
            break;

        case 12:
            puts( STK_OVERRUN_MSG );
            DumpProcessorContext();
            break;

        case 13:
            puts( GP_FAULT_MSG );
            DumpProcessorContext();
            break;

        case 14:
            puts( PG_FAULT_MSG );
            BlPrint("** At linear address %lx\n",TrapFrame->Fcr2);
            DumpProcessorContext();
            break;

        default :
            puts( EX_FAULT_MSG );
            DumpProcessorContext();
            break;
    }

    RealMode();
    while (1); //**** WAITFOREVER *** //


}


VOID
DumpProcessorContext(
    VOID
    )
/*++

Routine Description:

    Dumps all the processors registers. Called whenever a trap or fault
    occurs.

Arguments:

    None

Returns:

    Nothing

--*/
{
    DumpSystemRegisters();
    DumpCommonRegisters();
}

VOID
DumpSystemRegisters(
    VOID
    )
/*++

Routine Description:

    Dumps (writes to the display or com poirt) the x86 processor control
    registers only. Does not dump the common registers (see
    DumpCommonRegisters)

Arguments:

    None

Returns:

    Nothing


--*/
{
    BlPrint("\n tr=%x  cr0=%lx  cr2=%lx  cr3=%lx\n",
            TrapFrame->Ftr,TrapFrame->Fcr0,TrapFrame->Fcr2,TrapFrame->Fcr3);
    BlPrint(" gdt limit=%x  base=%lx    idt limit=%x  base=%lx\n",
          *(PUSHORT)&GDTregister,*(PULONG)(&GDTregister + 2),
          *(PUSHORT)&IDTregister,*(PULONG)(&IDTregister + 2));
}



VOID
DumpCommonRegisters(
    VOID
    )
/*++

Routine Description:

    Dumps (writes to the display or com poirt) the x86 processor
    commond registers only.

Arguments:

    None

Returns:

    Nothing


--*/
{
    USHORT err;

    //
    // Is the error code valid or just a padding dword
    //

    if ((TrapFrame->TrapNum == 8) || (TrapFrame->TrapNum >= 10 && TrapFrame->TrapNum <= 14) )
        err = (USHORT)TrapFrame->Error;
    else
        err = 0;

    //
    // Display the processor's common registers
    //

    BlPrint("\n cs:eip=%x:%lx  ss:esp=%x:%lx  errcode=%x\n",
        (USHORT)(TrapFrame->Fcs & 0xffff),TrapFrame->Feip,(USHORT)TrapFrame->Fss,TrapFrame->Fesp,err);
    DisplayFlags(TrapFrame->Feflags);
    BlPrint(" eax=%lx  ebx=%lx  ecx=%lx  edx=%lx",TrapFrame->Feax,TrapFrame->Febx,TrapFrame->Fecx,TrapFrame->Fedx);
    BlPrint(" ds=%x  es=%x\n",TrapFrame->Fds,TrapFrame->Fes);
    BlPrint(" edi=%lx  esi=%lx  ebp=%lx  cr0=%lx",TrapFrame->Fedi,TrapFrame->Fesi,TrapFrame->Febp,TrapFrame->Fcr0);
    BlPrint(" fs=%x  gs=%x\n",TrapFrame->Ffs,TrapFrame->Fgs);

}


VOID
DisplayFlags(
    ULONG f
    )
/*++

Routine Description:

    Writes the value of the key flags in the flags register to
    the display or com port.

Arguments:

    f - the 32bit flags word

Returns:

    Nothing

--*/
{

    BlPrint(" flags=%lx  ",f);
    if (f & FLAG_CF) puts("Cy "); else puts("NoCy ");
    if (f & FLAG_ZF) puts("Zr "); else puts("NoZr ");
    if (f & FLAG_IE) puts("IntEn"); else puts("IntDis ");
    if (f & FLAG_DF) puts("Up "); else puts("Down ");
    if (f & FLAG_TF) puts("TrapEn \n"); else puts("TrapDis \n");

}



VOID
DumpTSS(
    VOID
    )
/*++

Routine Description:

    Writes the contents of the TSS to the display or com port when
    called after a double fault.

Arguments:

    None

Returns:

    Nothing

--*/
{

    PTSS_FRAME pTss;

//  FP_SEG(Fp) = Fcs;
//  FP_OFF(Fp) = Fip;

    pTss = (PTSS_FRAME) &TssKernel;

    //
    //  Dump the outgoing TSS
    //

    BlPrint("Link %x\n",pTss->Link);
    BlPrint("Esp0 %x\n",pTss->Esp0);
    BlPrint("SS0  %x\n",pTss->SS0);
    BlPrint("Esp1 %lx\n",pTss->Esp1);
    BlPrint("Cr3  %lx\n",pTss->Cr3);
    BlPrint("Eip  %lx\n",pTss->Eip);
    BlPrint("Eflg %lx\n",pTss->Eflags);
    BlPrint("Eax  %lx\n",pTss->Eax);
    BlPrint("Ebx  %lx\n",pTss->Ebx);
    BlPrint("Ecx  %lx\n",pTss->Ecx);
    BlPrint("Edx  %lx\n",pTss->Edx);
    BlPrint("Esp  %lx\n",pTss->Esp);
    BlPrint("Ebp  %lx\n",pTss->Ebp);
    BlPrint("Esi  %lx\n",pTss->Esi);
    BlPrint("Edi  %lx\n",pTss->Edi);
    BlPrint("ES   %x\n",pTss->ES);
    BlPrint("CS   %x\n",pTss->CS);
    BlPrint("SS   %x\n",pTss->SS);
    BlPrint("DS   %x\n",pTss->DS);
    BlPrint("FS   %x\n",pTss->FS);
    BlPrint("GS   %x\n",pTss->GS);
    BlPrint("Ldt  %x\n",pTss->Ldt);
    RealMode();
    while(1);
}

// END OF FILE

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

!ENDIF

MAJORCOMP=ntos
MINORCOMP=startup

TARGETNAME=startup.com
TARGETPATH=obj
TARGETTYPE=UMAPPL_NOLIB

INCLUDES=$(SDK_INC_PATH);..\..\inc;..\..\..\inc;..\..\..\config;..\..\..\nthals

SOURCES=

i386_SOURCES=..\i386\su.asm         \
             ..\i386\exp.asm        \
             ..\i386\sudata.asm     \
             ..\i386\eisaa.asm      \
             ..\i386\eisac.c        \
             ..\i386\main.c         \
             ..\i386\a20.asm        \
             ..\i386\trap.asm       \
             ..\i386\trapdump.c     \
             ..\i386\display.c      \
             ..\i386\backend.asm    \


!IF $(386)

NTTARGETFILES=$(_OBJ_DIR)\i386\startup.com

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\constant.h ===
/*--

    Module Name

        constant.h

    Author

        Thomas Parslow  (tomp)

--*/

//
// Debugging Level defines
//

#ifdef DEBUG0
#define DBG0(x)     x
#define DBG1(x)
#elif defined  DEBUG1
#define DBG0(x)     x
#define DBG1(x)     x
#else
#define DBG0(x)
#define DBG1(x)
#endif

#define WAITFOREVER while(1);
#define BUGCHECK    while(1);


#define ENTRIES_PER_PAGETABLE       1024
#define PAGE_SIZE                   0x1000
#define ENABLING                    0
#define RE_ENABLING                 1



//
// Define page-table-entry bit definitions
//
//     Dir       Table
//  ----------==========
//  00000000000000000000xxxxxxxxxxxx
//                           ::::::+--- Present    = 1 - Not Present = 0
//                           :::::+---- ReadWrite  = 1 - Read only   = 0
//                           ::::+----- UserAccess = 1 - Supervisor  = 0
//                           :::+------ Reserved
//                           ::+------- Reserved
//                           :+-------- Dirty      = 1 - Not written = 0
//                           +--------- Accessed   = 1 - No accessed = 0

#define  PAGE_SUPERVISOR     0x0000
#define  PAGE_READ_ONLY      0x0000
#define  PAGE_PRESENT        0x0001
#define  PAGE_NOT_PRESENT    0x0000
#define  PAGE_READ_WRITE     0x0002
#define  PAGE_USER_ACCESS    0x0004
#define  PAGE_PERSIST        0x0200 // Tells kernel maintain
//
//  Define RWSP (Read, Write, Supervisor, Present)
//

#define  PAGE_RWSP      0L | PAGE_READ_WRITE | PAGE_SUPERVISOR | PAGE_PRESENT
#define  PAGE_ROSP      0L | PAGE_READ_ONLY | PAGE_SUPERVISOR | PAGE_PRESENT
// Since the entire boot process occurs at ring 0, the only way we can
// protext areas that we don't want trashed is too mark them not present
#define  PAGE_NO_ACCESS    0L | PAGE_READ_ONLY  | PAGE_SUPERVISOR | PAGE_NOT_PRESENT


//
// Page-entry macros
//

#define PD_Entry(x)     (USHORT)((x)>>22) & 0x3ff
#define PT_Entry(x)     (USHORT)((x)>>12) & 0x3ff
#define PAGE_Count(x)     (USHORT)((x)/PAGE_SIZE) + (((x) % PAGE_SIZE) ? 1 : 0)
#define PhysToSeg(x)    (USHORT)((x) >> 4) & 0xffff
#define PhysToOff(x)    (USHORT)((x) & 0x0f)
#define MAKE_FP(p,a)    FP_SEG(p) = (USHORT)((a) >> 4) & 0xffff; FP_OFF(p) = (USHORT)((a) & 0x0f)
#define MAKE_FLAT_ADDRESS(fp) ( ((ULONG)FP_SEG(fp) * 16 ) +  (ULONG)FP_OFF(fp) )

//
// Machine type definitions.
// N.B.  All the constants defined here
//       must match the ones defined in ntos\inc\i386.h
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\eisa.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisa.h

Abstract:

    This module contains the i386 EISA bus specific header file.

Author:

    Shie-Lin Tzong (shielint) 6-June-1991

Revision History:

--*/

//
// SU module's version of the memory descriptor
//
typedef struct _MEMORY_LIST_ENTRY {
    ULONG BlockBase;
    ULONG BlockSize;
} MEMORY_LIST_ENTRY, *PMEMORY_LIST_ENTRY;


//
// SU module's version of the address space parameters for int-15 E820 calls
//

typedef struct {
    ULONG       ErrorFlag;
    ULONG       Key;
    ULONG       Size;
    struct {
        ULONG       BaseAddrLow;
        ULONG       BaseAddrHigh;
        ULONG       SizeLow;
        ULONG       SizeHigh;
        ULONG       MemoryType;
    } Descriptor;
} E820Frame;


//
// Misc. definitions
//

#define _16MEGB                  ((ULONG)16 * 1024 * 1024)
#define _64MEGB                  ((ULONG)64 * 1024 * 1024)

typedef CM_EISA_SLOT_INFORMATION BTEISA_SLOT_INFORMATION;
typedef CM_EISA_SLOT_INFORMATION *PBTEISA_SLOT_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION BTEISA_FUNCTION_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION *PBTEISA_FUNCTION_INFORMATION;
typedef EISA_MEMORY_CONFIGURATION BTEISA_MEMORY_CONFIGURATION;
typedef EISA_MEMORY_CONFIGURATION *PBTEISA_MEMORY_CONFIGURATION;

BOOLEAN
FindFunctionInformation (
    IN UCHAR SlotFlags,
    IN UCHAR FunctionFlags,
    OUT PBTEISA_FUNCTION_INFORMATION Buffer,
    IN BOOLEAN FromBeginning
    );

USHORT
CountMemoryBlocks (
    VOID
    );

ULONG
EisaConstructMemoryDescriptors (
    VOID
    );

UCHAR
BtGetEisaSlotInformation (
   PBTEISA_SLOT_INFORMATION SlotInformation,
   UCHAR Slot
   );

UCHAR
BtGetEisaFunctionInformation (
   PBTEISA_FUNCTION_INFORMATION FunctionInformation,
   UCHAR Slot,
   UCHAR Function
   );

BOOLEAN
BtIsEisaSystem (
   VOID
   );

//
// External References
//

extern MEMORY_LIST_ENTRY _far *MemoryDescriptorList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\eisa.inc ===
;++
;
;   Copyright (c) 1989	Microsoft Corporation
;
;   Module Name:
;
;	eisa.inc
;
;   Abstract:
;
;	This module contains the assembly structures and definitions
;       for making 16-bit real mode EISA BIOS calls.
;
;   Author:
;
;	Shie-Lin (shielint) 7-June-1991
;
;   Revision History:
;
;--

;
; EISA BIOS call function number.
;

GET_EISA_SLOT_INFORMATION     equ 0D800h
GET_EISA_FUNCTION_INFORMATION equ 0D801h

;
; Length of EISA information block
;

EISA_INFORMATION_BLOCK_LENGTH equ 320

;
; Structure for EISA slot information block
;

EISA_SLOT_INFORMATION   struc

    SlotReturn                  db      0
    SlotFlags                   db      0
    SlotMajorRevision           db      0
    SlotMinorRevision           db      0
    SlotChecksum                dw      0
    SlotNumberFunctions         db      0
    SlotFunctionInformation     db      0
    SlotCompressedId            dd      0

EISA_SLOT_INFORMATION   ends

;
; Structure for EISA function information block
;

EISA_FUNCTION_INFORMATION       struc

    FunctionReturn      db      0
    FunctionInformation db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

EISA_FUNCTION_INFORMATION       ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\makefile.inc ===
# Copyright (C) by Microsoft Corporation.
#
# MAKEFILE for NT SU.X86
#
# Created:
#               91.01.18
#
# Author:
#               Thomas Parslow
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

.SUFFIXES:       .com .exe .obj .lst .c .asm .def .lnk .inc


#
#       C Compiler Definitions
#       ~~~~~~~~~~~~~~~~~~~~~~

# Environment Variable to set debugging level
# LOADER_DEBUG is the debugging level for building the OS loader, SU module, and BFSD. It should be
# set to either -DDEBUG0 or -DDEBUG1 to enable either level 1 or 2 debugging.
#
!IFDEF ALT_PROJECT_MAKE
ALT_PROJECT_FLAGS=-D$(ALT_PROJECT)
!ENDIF

PATH= $(PATH_TOOLS16);$(PATH)

CC=     cl16
CFLAGS= -W3 -G2s -Zelp $(LOADER_DEBUG)  $(BLFLAGS) $(ALT_PROJECT_FLAGS)
CINC=   -I. -I$(SDK_INC_PATH) -I..\i386 -I..\i386\$(LANGUAGE)


#
#       Assembler Definitions
#       ~~~~~~~~~~~~~~~~~~~~~

ASM=    masm386
AFLAGS= -Mx  -z $(LOADER_DEBUG) $(GAFLAGS) $(ALT_PROJECT_FLAGS)
AINC=  -I$(SDK_INC_PATH) -I..\i386


#
#       Linker Definitions
#       ~~~~~~~~~~~~~~~~~~

LINK=link16 /map:full
LIBS=..\long.lib
DEF=


#
#       Rules for generating objects
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~



{..\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
        $(ASM) $(AFLAGS) $(AINC) $< $@;

{..\i386\}.asm.lst:
        $(ASM) -l -n $(AFLAGS) $(AINC) $<;

#        $(CC) $(CFLAGS) $(CINC) -c $<

{..\i386\}.c{$(_OBJ_DIR)\i386\}.obj:
    $(CC) $(CFLAGS) $(CINC) -Fo$@  -c $<

{..\}.c{$(_OBJ_DIR)\i386\}.obj:
    $(CC) $(CFLAGS) $(CINC) -Fo$@ -c $<

{..\i386\}.c.lst:
        $(CC) $(CFLAGS) -Fc$*.cod -Fo$*.obj -dos $(CINC) -c $<


#
#       List of object files required
#       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OBJ= $(_OBJ_DIR)\i386\su.obj  $(_OBJ_DIR)\i386\exp.obj  $(_OBJ_DIR)\i386\sudata.obj \
$(_OBJ_DIR)\i386\eisaa.obj  $(_OBJ_DIR)\i386\a20.obj  $(_OBJ_DIR)\i386\trap.obj  $(_OBJ_DIR)\i386\eisac.obj \
$(_OBJ_DIR)\i386\main.obj  $(_OBJ_DIR)\i386\trapdump.obj $(_OBJ_DIR)\i386\display.obj $(_OBJ_DIR)\i386\backend.obj


#
#       Dependencies
#       ~~~~~~~~~~~~


$(_OBJ_DIR)\i386\startup.com: $(OBJ)

$(_OBJ_DIR)\i386\exp.obj         exp.lst:        ..\i386\exp.asm ..\i386\su.inc ..\i386\macro.inc

$(_OBJ_DIR)\i386\eisaa.obj       eisaa.lst:      ..\i386\eisa.inc ..\i386\eisaa.asm

$(_OBJ_DIR)\i386\eisac.obj       eisac.lst:      ..\i386\eisa.h ..\i386\eisac.c

$(_OBJ_DIR)\i386\su.obj          su.lst:         ..\i386\su.asm ..\i386\su.inc

$(_OBJ_DIR)\i386\sudata.obj      sudata.lst:     ..\i386\sudata.asm ..\i386\su.inc ..\i386\memmap.inc

$(_OBJ_DIR)\i386\main.obj        main.lst:       ..\i386\main.c ..\i386\global.h ..\i386\types.h ..\i386\constant.h

$(_OBJ_DIR)\i386\trap.obj        trap.lst:       ..\i386\trap.asm ..\i386\su.inc

$(_OBJ_DIR)\i386\trapdump.obj    trapdump.lst:   ..\i386\trapdump.c ..\i386\types.h ..\i386\constant.h

$(_OBJ_DIR)\i386\display.obj     display.lst:    ..\i386\display.c ..\i386\types.h ..\i386\constant.h ..\i386\global.h

$(_OBJ_DIR)\i386\backend.obj     backend.lst:    ..\i386\backend.asm

$(_OBJ_DIR)\i386\startup.com: $(OBJ) $(DOBJ) $(LIBS)
        $(LINK) @<<
/tiny /nod /noi +
$(OBJ)
$(_OBJ_DIR)\i386\startup.com
$(_OBJ_DIR)\i386\startup.map
$(LIBS)

<<
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\eisaa.asm ===
title  "EISA bus Support Assembley Code"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    eisaa.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to get configuration
;    information on EISA machines.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 7-June-1991
;
; Environment:
;
;    Real Mode 16-bit code.
;
; Revision History:
;
;
;--


.386p
        .xlist
include eisa.inc
        .list

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

        public  _FunctionInformation
_FunctionInformation     db      0
                         db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT

;++
;
; VOID
; BtGetEisaSlotInformation (
;    PBTEISA_SLOT_INFORMATION SlotInformation,
;    UCHAR Slot
;    )
;
; Routine Description:
;
;    This function retrieves the slot information for the specified slot.
;
; Arguments:
;
;    SlotInformation - Supplies a pointer to the structure which will
;                      receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
; Return Value:
;
;    None.
;
;--

BgesSlotInformation     equ     [bp + 4]
BgesSlot                equ     [bp + 6]

        public  _BtGetEisaSlotInformation
_BtGetEisaSlotInformation       proc

        push    bp                      ; The following INT 15H destroies
        mov     bp, sp                  ;   ALL the general registers.
        push    si
        push    di
        push    bx

        mov     cl, BgesSlot
        mov     ax, GET_EISA_SLOT_INFORMATION
        int     15h

        push    bx                      ; Save revision level
        mov     bx, BgesSlotInformation

        ;
        ; fill values into eisa slot info structure.
        ;

        mov     [bx].SlotReturn, ah
        mov     [bx].SlotFlags, al
        pop     ax                      ; [ax] = revision level
        mov     [bx].SlotMajorRevision, ah
        mov     [bx].SlotMinorRevision, al
        mov     [bx].SlotChecksum, cx
        mov     [bx].SlotNumberFunctions, dh
        mov     [bx].SlotFunctionInformation, dl
        mov     word ptr [bx].SlotCompressedId, di
        mov     word ptr [bx+2].SlotCompressedId, si

        pop     bx
        pop     di
        pop     si
        pop     bp
        ret

_BtGetEisaSlotInformation       endp

;++
;
; UCHAR
; BtGetEisaFunctionInformation (
;    PBTEISA_FUNCTION_INFORMATION FunctionInformation,
;    UCHAR Slot,
;    UCHAR Function
;    )
;
; Routine Description:
;
;    This function retrieves function information for the specified slot
;    and function.
;
; Arguments:
;
;    FunctionInformation - Supplies a pointer to the structure which will
;           receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
;    Function - Supplies the function number of the desired slot.
;
; Return Value:
;
;    Return code of the EISA function call.
;
;--

BgefFunctionInformation equ     [bp + 4]
BgefSlot                equ     [bp + 6]
BgefFunction            equ     [bp + 8]

        public  _BtGetEisaFunctionInformation
_BtGetEisaFunctionInformation     proc

        push    bp
        mov     bp, sp
        push    si

        mov     ax, GET_EISA_FUNCTION_INFORMATION
        mov     cl, BgefSlot            ; [cl] = slot, [ch]=function
        mov     ch, BgefFunction
        mov     si, BgefFunctionInformation
                                        ; (ds:si)->Function information
        int     15h

        mov     al, ah                  ; move the return code to AL

        pop     si
        pop     bp
        ret
_BtGetEisaFunctionInformation     endp

;++
;
; BOOLEAN
; BtIsEisaSystem (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines if the target machines is EISA based machines.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE - if this is EISA machine.  Otherwise, a value of FALSE is returned.
;--

        public _BtIsEisaSystem
_BtIsEisaSystem proc

        push    es
        push    bx

;
;       Check for an EISA system.  If "EISA" is at F000:FFD9h then it
;       is an EISA system.
;

        mov     ax,0f000h               ; segment
        mov     es,ax
        mov     bx,0ffd9h               ; offset in the ROM
        mov     eax, "ASIE"
        cmp     eax, es:[bx]
        jne     short bies00            ; if ne, Not EISA system, go bies00

        mov     ax, 1                   ; set return value to TRUE
        jmp     short bies10

bies00:
        mov     ax, 0
bies10:
        pop     bx
        pop     es
        ret
_BtIsEisaSystem endp

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\backend.asm ===
;++
;
; Module Name:
;
;       backend.asm
;
; Module Description:
;
;       This module is needed only to get around a linker quirk we
;       run into because we're linking an app compiled as a "small"
;       model app as a "tiny" model app.
;
; This is how we find the end of the com file and the beginning of the
; OS loader coff header. This file must always be linked last when
; generating STARTUP.COM
;--


.386p

_DATA   segment para use16 public 'DATA'

public _BackEnd
_BackEnd equ $

_DATA   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\a20.asm ===
;  NOTICE
;  This was taken from the os2 bios sources and was slightly modified to
;  enable the a20 line. There's still some work to do and much clean-up to
;  bring the file upto coding standards. I'll do this when time permits.
;  TomP


;* _EnableA20
;* Description:                                                               *
;*      This routine enables and disables the A20 address line, depending on  *
;*      the value in ax                                                       *
;*                                                                            *
;*      In general when in real mode we want the A20 line disabled,           *
;*      when in protected mode enabled. However if there is no high           *
;*      memory installed we can optimise out unnecessary switching            *
;*      of the A20 line. Unfortunately the PC/AT ROM does not allow           *
;*      us to completely decouple mode switching the 286 from gating          *
;*      the A20 line.                                                         *
;*                                                                            *
;*      In real mode we would want A20 enabled if we need to access           *
;*      high memory, for example in a device driver. We want it               *
;*      disabled while running arbitrary applications because they            *
;*      may rely on the 1 meg address wrap feature which having the           *
;*      A20 line off provides.                                                *
;*                                                                            *
;*      This code is largely duplicated from the PC/AT ROM BIOS.              *
;*      See Module "BIOS1" on page 5-155 of the PC/AT tech ref.               *
;*                                                                            *
;*      WARNING:                                                              *
;*                                                                            *
;*      The performance characteristics of these routines                     *
;*      are not well understood. There may be worst case                      *
;*      scenarios where the routine could take a relatively                   *
;*      long time to complete.                                                *
;*                                                                            *
;* Linkage:                                                                   *
;*      far call                                                              *
;*                                                                            *
;* Input:                                                                     *
;*                                                                            *
;* Exit:                                                                      *
;*      A20 line enabled/disabled                                             *
;*                                                                            *
;* Uses:                                                                      *
;*      ax                                                                    *
;*                                                                            *
;* Internal References:                                                       *
;*      empty_8042  --  waits for 8042 input buffer to drain                  *

.386p
include su.inc

IODelay macro
        jmp     $+2
        endm

extrn  _puts:near
extrn  _Empty_8042Failed:near


; Equates for cmos

CMOS_DATA       equ     71h             ; I/O word for cmos chip
SHUT_ADDR       equ     8fh             ; shutdown byte address in cmos
SHUT_CODE       equ     9               ; block copy return code we use


; equates for 8042
STATUS_PORT     equ     64h             ; 8042 com port
PORT_A          equ     60h             ; 8042 data port
BUF_FULL        equ     2               ; 8042 busy bit


SHUT_CMD        equ     0feh            ; RESET 286 command

MSW_VIRTUAL     equ     1               ; protected mode bit of MSW

MASTER_IMR      equ     21h             ; mask port for master 8259


;CONST   SEGMENT WORD USE16 PUBLIC 'CONST'
;CONST   ENDS

;_BSS   SEGMENT WORD USE16 PUBLIC 'BSS'
;_BSS   ENDS

;DGROUP  GROUP   CONST, _BSS, _DATA
;        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP


;++
;
;VOID
;EnableA20(
;    VOID
;    )
;
;Routine Description:
;
;    Enables the A20 line for any machine.  
;
;Arguments:
;
;    None
;
;Return Value:
;
;    None.
;
;    The A20 line is enabled.
;
;--
        public  _EnableA20

_EnableA20      proc    near

;            Check if empty_8042 has failed before
;            If so, skip this function.  This would occur
;            on legacy free systems.

         mov   di,offset DGROUP:_Empty_8042Failed
         cmp   byte ptr [di],1
         jz   EA2
         
;         cmp   byte ptr [di],0
        
        call    empty_8042              ; ensure 8042 input buffer empty
        jnz     EA2                     ; 8042 error return


;            Enable or disable the A20 line

        mov     al,0d1h                 ; 8042 cmd to write output port
        out     STATUS_PORT,al          ; send cmd to 8042
        call    empty_8042              ; wait for 8042 to accept cmd
        jnz     EA2                     ; 8042 error return
        mov     al,0dfh                 ; 8042 port data
        out     PORT_A,al               ; output port data to 8042
        call    empty_8042

;       We must wait for the a20 line to settle down, which (on an AT)
;       may not happen until up to 20 usec after the 8042 has accepted
;       the command.  We make use of the fact that the 8042 will not
;       accept another command until it is finished with the last one.
;       The 0FFh command does a NULL 'Pulse Output Port'.  Total execution
;       time is on the order of 30 usec, easily satisfying the IBM 8042
;       settling requirement.  (Thanks, CW!)

        mov     al,0FFh                 ;* Pulse Output Port (pulse no lines)
        out     STATUS_PORT,al          ;* send cmd to 8042
        call    empty_8042              ;* wait for 8042 to accept cmd

EA2:
        ret

_EnableA20   endp


;++
;
;VOID
;DisableA20(
;    VOID
;    )
;
;Routine Description:
;
;    Disables the A20 line for any machine. 
;
;Arguments:
;
;    None
;
;Return Value:
;
;    None.
;
;    The A20 line is disabled.
;
;--
        public  _DisableA20

_DisableA20      proc    near

;            Check if empty_8042 has failed before
;            If so, skip this function.  This would occur
;            on legacy free systems.

         mov   di,offset DGROUP:_Empty_8042Failed
         cmp   byte ptr [di],1
         jz   EA2
         
         cmp   byte ptr [di],0
            
DA1:
        call    empty_8042              ; ensure 8042 input buffer empty
        jnz     DA2                     ; 8042 error return


;            Disable the A20 line

        mov     al,0d1h                 ; 8042 cmd to write output port
        out     STATUS_PORT,al          ; send cmd to 8042
        call    empty_8042              ; wait for 8042 to accept cmd
        jnz     DA2                     ; 8042 error return
        mov     al,0ddh                 ; 8042 port data
        out     PORT_A,al               ; output port data to 8042
        call    empty_8042

;       We must wait for the a20 line to settle down, which (on an AT)
;       may not happen until up to 20 usec after the 8042 has accepted
;       the command.  We make use of the fact that the 8042 will not
;       accept another command until it is finished with the last one.
;       The 0FFh command does a NULL 'Pulse Output Port'.  Total execution
;       time is on the order of 30 usec, easily satisfying the IBM 8042
;       settling requirement.  (Thanks, CW!)

        mov     al,0FFh                 ;* Pulse Output Port (pulse no lines)
        out     STATUS_PORT,al          ;* send cmd to 8042
        call    empty_8042              ;* wait for 8042 to accept cmd

DA2:
        ret

_DisableA20   endp
;**
; empty_8042 -- wait for 8042 input buffer to drain
;
; Input:
;      interrupts disabled
;
; Exit:
;      al=0, z=0   => 8042 input buffer empty
;
; Uses:
;      ax, flags

        public  Empty8042
Empty8042     proc    near
empty_8042:
        sub     cx,cx                   ; cx = 0, timeout loop counter

emp1:   in      al,STATUS_PORT          ; read 8042 status port
        IODelay
        IODelay
        IODelay
        IODelay
        and     al,BUF_FULL             ; test buffer full bit
        loopnz  emp1

        cmp     cx,0                    ; see if buffer is full
        jnz     emp2
        

        ; if we reached this point this indicates an error
        
        mov   di,offset DGROUP:_Empty_8042Failed
        mov   byte ptr [di],1
        
        
        
;        mov     [_Empty_8042Failed],1                    ; set Empty_8042Failed global to "TRUE"
;        mov     _Empty_8042Failed,1                    ; set Empty_8042Failed global to "TRUE"
;        mov     cx, offset _Empty_8042Failed
;        mov     [cx],ah
                

emp2:
        and   al,BUF_FULL                               ; reset the Z flag
        ret

Empty8042     endp

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\memmap.h ===
//
// The following memory address definitions apply to
// indentity mapped objects for the x86 environment.
//

#define RM_PROTECT_BASE_VA          0x000000
#define RM_PROTECT_BASE_PA          0x000000
#define RM_PROTECT_SIZE             0x001000
#define RM_PROTECT_ATTRIBUTES       PAGE_ROSP

#define BPB_BASE_VA                 0x007000
#define BPB_BASE_PA                 0x007000
#define BPB_SIZE                    0x001000
#define BPB_ATTRIBUTES              PAGE_ROSP

#define SU_MODULE_BASE_VA           0x020000
#define SU_MODULE_BASE_PA           0x020000
#define SU_MODULE_SIZE              0x020000
#define SU_MODULE_ATTRIBUTES        PAGE_RWSP

#define LOADER_BASE_VA              0x040000
#define LOADER_BASE_PA              0x040000
#define LOADER_SIZE                 0x020000
#define LOADER_ATTRIBUTES           PAGE_RWSP

#define SYSTEM_STRUCTS_BASE_VA      0x80420000
#define SYSTEM_STRUCTS_BASE_PA      0x00017000
#define SYSTEM_STRUCTS_SIZE         0x002000
#define SYSTEM_STRUCTS_ATTRIBUTES   PAGE_RWSP + PAGE_PERSIST

#define PAGE_TABLE_AREA_BASE_VA     0x00099000
#define PAGE_TABLE_AREA_BASE_PA     0x00099000
#define PAGE_TABLE_AREA_SIZE        0x002000
#define PAGE_TABLE_AREA_ATTRIBUTES  PAGE_RWSP + PAGE_PERSIST

#define LDR_STACK_BASE_VA           0x09b000
#define LDR_STACK_BASE_PA           0x09b000
#define LDR_STACK_SIZE              0x001000
#define LDR_STACK_ATTRIBUTES        PAGE_RWSP
#define LDR_STACK_POINTER           0x09bffe // in su.inc also

#define VIDEO_BUFFER_BASE_VA        0x0B8000
#define VIDEO_BUFFER_BASE_PA        0x0B8000
#define VIDEO_BUFFER_SIZE           0x004000
#define VIDEO_BUFFER_ATTRIBUTES     PAGE_RWSP


#define HYPER_PAGE_DIRECTORY        0xC0300C00
#define HYPER_SPACE_BEGIN           0xC0000000  // points to 1st page table
#define HYPER_SPACE_SIZE            0x8000L
#define HYPER_SPACE_ENTRY           768
#define PAGE_TABLE1_ADDRESS         0xC0000000L
#define PD_PHYSICAL_ADDRESS         PAGE_TABLE_AREA_BASE_PA  // in su.inc also.
#define PT_PHYSICAL_ADDRESS         PAGE_TABLE_AREA_BASE_PA + PAGE_SIZE
#define VIDEO_ENTRY                 0xB8

/*



Switching to Realmode
~~~~~~~~~~~~~~~~~~~~~

When switching to realmode "sp" will be initialized to
0xfffe and (ss) will be set to the base of the SU module's
data segment. This has several effects.

 1) The stack will remain withing the 0x20000 - 0x3ffff range
    reserved for the original SU module and loader image prior to
    relocation, and since the loader will already have been relocated
    it is no longer necessary to preserve this area.

 2) This will preserve the SU module's small model character which
    requires that offsets can be used interchangably through (ss) or (ds).

 3) This allows for the maximum stack size for small model apps (which is
    what the SU module is). Bios calls should not be tromping on any
    data or code while in realmode.

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Author:

    Thomas Parslow (tomp) Mar-01-90

Abstract:

    Video support routines.

    The SU module only need to be able to write to the video display
    in order to report errors, traps, etc.

    The routines in this file all write to a video buffer assumed to be
    at realmode address b800:0000, and 4k bytes in length. The segment
    portion of the far pointers used to access the video buffer are stamped
    with a protmode selector value when we switch to protect mode. This is
    done in the routine "ProtMode" in "misc386.asm".


--*/

#include "su.h"


#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))

#ifdef DEBUG1
#define ROWS 43
#else
#define ROWS 25
#endif
#define COLUMNS 80
#define SCREEN_WIDTH COLUMNS
#define SCREEN_SIZE ROWS * COLUMNS
#define NORMAL_ATTRIB 0x07
#define REVERSE_ATTRIB 0x70
#define SCREEN_START 0xb8000000

#define VIDEO_BIOS   0x10
#define LINES_400_CONFIGURATION  0x1202
#define SELECT_SCAN_LINE 0x301
#define SET_80X25_16_COLOR_MODE  0x3
#define LOAD_8X8_CHARACTER_SET   0x1112

//
// Internal routines
//

static
VOID
tab(
    VOID
    );

static
VOID
newline(
    VOID
    );

static
VOID
putzeros(
    USHORT,
    USHORT
    );


USHORT
Redirect = 0;

VOID
InitializeVideoSubSystem(
    VOID
    )
/*++

Routine Description:

    Initializes the video mode to 80x50 alphanumeric mode with 400 lines
    vertical resolution.

Arguments:

    None

Returns:

    Nothing


--*/

{
    BIOSREGS ps;
    UCHAR _far *BiosArea;

    //
    // Set 40:10 to indicate color is the default display
    //   *(40:10) &= ~0x30;
    //   *(40:10) |= 0x20;
    //
    // Fixes obscure situation where both monochrome and VGA adapters
    // are installed and the monochrome is the default display.
    //
    BiosArea = (UCHAR _far *)(0x410L);

    *BiosArea &= ~0x30;
    *BiosArea |= 0x20;

    //
    // Establish 80x25 alphanumeric mode with 400-lines vertical resolution
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = LINES_400_CONFIGURATION;
    ps.bx = SELECT_SCAN_LINE;
    biosint(&ps);

    ps.fn = VIDEO_BIOS;
    ps.ax = SET_80X25_16_COLOR_MODE;
    biosint(&ps);

    DBG1(
        ps.ax = LOAD_8X8_CHARACTER_SET;
        ps.bx = 0;
        biosint(&ps);
    )

    //
    // HACK-O-RAMA - Make some random video BIOS calls here to make sure the
    // BIOS is initialized and warmed up and ready to go.  Otherwise,
    // some Number 9 S3 cards don't quite work right later in the game.
    //  John Vert (jvert) 9-Jun-1993
    //

    //
    // set cursor position to 0,0
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = 0x2000;
    ps.bx = 0;
    ps.dx = 0;
    biosint(&ps);

    //
    // write character (' ' in this case)
    //
    ps.fn = VIDEO_BIOS;
    ps.ax = 0x0a00 | (USHORT)' ';
    ps.bx = 0;
    ps.cx = 1;
    biosint(&ps);

    clrscrn();
    return ;
}


//
// Used by all BlPrint subordinate routines for padding computations.
//

CHAR sc=0;
ULONG fw=0;



VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.


Returns:

    Nothing


--*/

{
    USHORT b,c,w,len;
    PUCHAR ap;
    ULONG l;

    //
    // Cast a pointer to the first word on the stack
    //

    ap = (PUCHAR)&cp + sizeof(PCHAR);
    sc = ' '; // default padding char is space

    //
    // Process the arguments using the descriptor string
    //


    while (b = *cp++)
        {
        if (b == '%')
            {
            c = *cp++;

            switch (c)
                {
                case 'd':
                    puti((long)*((int *)ap));
                    ap += sizeof(int);
                    break;

                case 's':
                    puts(*((PCHAR *)ap));
                    ap += sizeof (char *);
                    break;

                case 'c':
                    putc(*((char *)ap));
                    ap += sizeof(int);
                    break;

                case 'x':
                    w = *((USHORT *)ap);
                    len = ZLEN_SHORT(w);
                    while(len--) putc('0');
                    putx((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'u':
                    putu((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'l':
                    c = *cp++;

                switch(c) {

                    case 'u':
                        putu(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'x':
                        l = *((ULONG *)ap);
                        len = ZLEN_LONG(l);
                        while(len--) putc('0');
                        putx(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'd':
                        puti(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                }
                break;

                default :
                    putc((char)b);
                    putc((char)c);
                }
            }
        else
            putc((char)b);
        }

}

FPUCHAR vp = (FPUCHAR)SCREEN_START;
FPUCHAR ScreenStart = (FPUCHAR)SCREEN_START;

static int lcnt = 0;
static int row  = 0;


VOID puts(
    PCHAR cp
    )
/*++

Routine Description:

    Writes a string on the display at the current cursor position

Arguments:

    cp - pointer to ASCIIZ string to display.


Returns:

    Nothing



--*/


{
    char c;

    while(c = *cp++)
        putc(c);
}


//
// Write a hex short to display
//


VOID putx(
    ULONG x
    )
/*++

Routine Description:

    Writes hex long to the display at the current cursor position.

Arguments:

    x  - ulong to write.

Returns:

    Nothing


--*/

{
    ULONG j;

    if (x/16)
        putx(x/16);

    if((j=x%16) > 9) {
        putc((char)(j+'A'- 10));
    } else {
        putc((char)(j+'0'));
    }
}


VOID puti(
    LONG i
    )
/*++

Routine Description:

    Writes a long integer on the display at the current cursor position.

Arguments:

    i - the integer to write to the display.

Returns:

    Nothing


--*/


{
    if (i<0)
        {
        i = -i;
        putc((char)'-');
        }

    if (i/10)
        puti(i/10);

    putc((char)((i%10)+'0'));
}



VOID putu(
    ULONG u
    )
/*++

Routine Description:

    Write an unsigned long to display

Arguments:

    u - unsigned


--*/

{
    if (u/10)
        putu(u/10);

    putc((char)((u%10)+'0'));

}


VOID putc(
    CHAR c
    )
/*++

Routine Description:

    Writes a character on the display at the current position.

Arguments:

    c - character to write


Returns:

    Nothing


--*/

{
    switch (c)
        {
        case '\n':
            newline();
            break;

        case '\t':
            tab();
            break;

        default :
            if (FP_OFF(vp) >= (SCREEN_SIZE * 2)) {
                vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
                scroll();
            }
            *vp = c;
            vp += 2;
            ++lcnt;
      }
}


VOID newline(
    VOID
    )
/*++

Routine Description:

    Moves the cursor to the beginning of the next line. If the bottom
    of the display has been reached, the screen is scrolled one line up.

Arguments:

    None


Returns:

    Nothing


--*/

{
    vp += (SCREEN_WIDTH - lcnt)<<1;

    if (++row > ROWS-1) {

        vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
        scroll();

    }

    lcnt = 0;

}


VOID scroll(
    VOID
    )
/*++

Routine Description:

    Scrolls the display UP one line.

Arguments:

    None

Returns:

    Nothing

Notes:

    Currently we scroll the display by reading and writing directly from
    and to the video display buffer. We optionally switch to real mode
    and to int 10s

--*/

{
    USHORT i,j;
    USHORT far *p1 = (USHORT far *)ScreenStart;
    USHORT far *p2 = (USHORT far *)(ScreenStart + 2*SCREEN_WIDTH) ;

    for (i=0; i < ROWS - 1; i++)
        for (j=0; j < SCREEN_WIDTH; j++)
            *p1++ = *p2++;

    for (i=0; i < SCREEN_WIDTH; i++)
        *p1++ = REVERSE_ATTRIB*256 + ' ';

}


static
VOID tab(
    VOID
    )
/*++

Routine Description:


    Computes the next tab stop and moves the cursor to that location.


Arguments:


    None


Returns:

    Nothing

--*/

{
    int inc;

    inc = 8 - (lcnt % 8);
    vp += inc<<1;
    lcnt += inc;
}


VOID clrscrn(
    VOID
    )
/*++

Routine Description:

    Clears the video display by writing blanks with the current
    video attribute over the entire display.


Arguments:

    None

Returns:

    Nothing


--*/

{
    int i,a;
    unsigned far *vwp = (unsigned far *)ScreenStart;
    a = NORMAL_ATTRIB*256 + ' ';

    for (i = SCREEN_SIZE ; i ; i--)
        *vwp++ = a;

    row  = 0;
    lcnt = 0;
    vp = (FPUCHAR)ScreenStart;

}

// END OF FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\exp.asm ===
;++
;
; Module name
;
;       exp.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Feb-26-91
;
; Description
;
;       Entry points exported to OS loader by SU module. Exported
;       routines provide basic machine dependent i/o funtions needed
;       by the OS loader. Providing these routines decouples the
;       OS loader from the h/w. Note that the OS loader will
;       refer to these exported routines as the "external services".
;
;
; Exported Procedures
;
;       RebootProcessor - Reboots the machine
;       GetSector - Read one or more sectors from the boot device.
;       PutChar - Puts a character on the video display.
;       GetKey - Gets a key from the keyboard
;       GetCounter - Reads the Tick Counter
;       Reboot - Transfers control to a loaded boot sector.
;       HardwareCursor - set position of hardware cursor
;       GetDateTime - gets date and time
;       ComPort - int14 functions
;       GetStallCount - calculates processor stall count
;
;
; Notes
;
;       When adding a new exported routine note that you must manually add the
;       entry's name to the BootRecord in "sudata.asm".
;
;--

include su.inc
include macro.inc

DISK_TABLE_VECTOR       equ     01Eh * 4

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

        extrn   _DiskBaseTable:near
        extrn   _RomDiskBasePointer:near
        extrn   _EddsAddressPacket:near


;++
;
; Exported Name:
;
;       RebootProcessor
;
; Arguments:
;
;       None
;
; Description:
;
;       Reboot the processor using INT 19h
;
;
;
;--
;
; ExportEntry takes us from a 32bit cs to a 16bit cs, inits 16bit stack
; and ds segments and saves the callers esp and ebp.
;
;--

EXPORT_ENTRY_MACRO    RebootProcessor
;
; Switch to real mode so we can take interrupts
;

        ENTER_REALMODE_MACRO

;
; int 19h doesn't do what you would expect on BIOS Boot Specification machines.
; It either goes on to the next boot device or goes back to the first boot
; device. In both cases, it does not properly reset the machine. So we write
; to the keyboard port instead (as does HalpReboot).
;
;        int 19h
        mov     ax, 040h
        mov     ds, ax
        mov     word ptr ds:[72h], 1234h        ; set location 472 to 1234 to indicate warm reboot
        mov     al, 0feh
        out     64h, al                         ; write to keyboard port to cause reboot

;
; Loop forever and wait to ctrl-alt-del (should never get here)
;

        WAIT_FOREVER_MACRO

;EXPORT_EXIT_MACRO


;++
;
; Name:
;
;       GetSector
;
; Description:
;
;       Reads the requested number of sectors from the specified drive into
;       the specified buffer.
;
; Arguments:
;
;             ULONG Virtual address into which to read data
;             ULONG Number of sectors to read
;             ULONG Physical sector number
;             ULONG Drive Number
;             ULONG Function Number
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

EXPORT_ENTRY_MACRO    GetSector
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetSectorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Put the buffer pointer into es:bx. Note that and buffer
; addresses passed to this routine MUST be in the lower one
; megabyte of memory to be addressable in real mode.
;

        mov      eax,[bp].BufferPointer
        mov      bx,ax
        and      bx,0fh
        shr      eax,4
        mov      es,ax
;
; Place the upper 2 bits of the 10bit track/cylinder number
; into the uppper 2 bits of the SectorNumber as reguired by
; the bios.
;
        mov      cx,word ptr [bp].TrackNumber
        xchg     ch,cl
        shl      cl,6
        add      cl,byte ptr [bp].SectorNumber

;
; Get the rest of the arguments
;
        mov      ah,byte ptr [bp].FunctionNumber
        mov      al,byte ptr [bp].NumberOfSectors
        mov      dh,byte ptr [bp].HeadNumber
        mov      dl,byte ptr [bp].DriveNumber

;
; Check to see if we are trying to reset/read/write/verify off the second
; floppy drive.  If so, we need to go change the disk-base vector.
;
        cmp     dl,1
        jne     gs3
        cmp     ah,4
        jg      gs3
        cmp     ah,0
        je      gs1
        cmp     ah,2
        jl      gs3

gs1:
;
; We need to point the BIOS disk-table vector to our own table for this
; drive.
;
        push    es
        push    bx
        push    di

        push    0
        pop     es

        mov     di, offset DGROUP:_RomDiskBasePointer

        mov     bx,es:[DISK_TABLE_VECTOR]
        mov     [di],bx
        mov     bx,es:[DISK_TABLE_VECTOR+2]
        mov     [di+2],bx

        mov     bx,offset DGROUP:_DiskBaseTable
        mov     es:[DISK_TABLE_VECTOR],bx
        mov     bx,ds
        mov     es:[DISK_TABLE_VECTOR+2],bx

        pop     di
        pop     bx
        pop     es

        int     BIOS_DISK_INTERRUPT

        push    es
        push    bx
        push    di

        push    0
        pop     es

        mov     di, offset DGROUP:_RomDiskBasePointer

        mov     bx, [di]
        mov     es:[DISK_TABLE_VECTOR],bx
        mov     bx, [di+2]
        mov     es:[DISK_TABLE_VECTOR+2],bx

        pop     di
        pop     bx
        pop     es

        jc      gs5
        xor     eax,eax
        jmp     short gs5

gs3:

;
; Call the bios to read the sector now
;
if 0
        push     ax
        push     dx
        push     cx
        push     bx
        push     es
extrn _DisplayArgs:near
        call     _DisplayArgs
        pop      es
        pop      bx
        pop      cx
        pop      dx
        pop      ax
endif

        int      BIOS_DISK_INTERRUPT
        jc       gs5

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor     eax,eax
gs5:
if 0
        push     ax
        push     dx
        push     cx
        push     bx
        push     es
extrn _DisplayArgs:near
        call     _DisplayArgs
        pop      es
        pop      bx
        pop      cx
        pop      dx
        pop      ax
endif

;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and      eax,0000ffffh

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetSectorFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

; move cx into high 16-bits of ecx, and dx into cx.  This is so the loader
; can get at interesting values in dx, even though edx gets munged by the
; random real-mode macros.

        shl     ecx, 16
        mov     cx,dx
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax
;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; Name:
;
;       GetEddsSector
;
; Description:
;
;       Reads the requested number of sectors from the specified drive into
;       the specified buffer based on the Phoenix Enhanced Disk Drive Spec.
;
; Arguments:
;
;             ULONG xint13 function number (42 = read, 43 = write)
;             ULONG Virtual address into which to read data
;             ULONG Number of logical blocks to read (word)
;             ULONG Logical block number (High dword)
;             ULONG Logical block number (Low dword)
;             ULONG Drive Number (byte)
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

EXPORT_ENTRY_MACRO    GetEddsSector
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetEddsSectorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

        push     ds
        push     si
        push     bx

;
; Set up DS:SI -> Disk Address Packet
;
        push    0
        pop     ds
        mov     si, offset DGROUP:_EddsAddressPacket
        mov     ds:[si],word ptr 10h             ; Packet size = 10h, plus reserved byte
        mov     ax,word ptr [bp].NumberOfBlocks
        mov     ds:[si][2],ax                    ; Num blocks to transfer
        mov     eax,[bp].BufPointer
        mov     bx,ax
        and     bx,0fh
        mov     ds:[si][4],bx                    ; Transfer buffer address (low word=offset)
        shr     eax,4
        mov     ds:[si][6],ax                    ; Transfer buffer address (high word=segment)
        mov     eax,[bp].LBNLow
        mov     ds:[si][8],eax                   ; Starting logical block number (low dword)
        mov     eax,[bp].LBNHigh
        mov     ds:[si][12],eax                  ; Starting logical block number (high dword)

;
; Call the bios to read the sector now (DS:SI -> Disk address packet)
;
       mov      ah,byte ptr [bp].FunctionNum    ; function
       xor      al,al                           ; force verify on write off
       mov      dl,byte ptr [bp].DriveNum       ; DL = drive number
       int      BIOS_DISK_INTERRUPT
       jc       geserror1

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor      eax,eax
geserror1:

;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and      eax,0000ffffh

        pop      bx
        pop      si
        pop      ds

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetEddsSectorFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

; move cx into high 16-bits of ecx, and dx into cx.  This is so the loader
; can get at interesting values in dx, even though edx gets munged by the
; random real-mode macros.

        shl      ecx, 16
        mov      cx,dx
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax
;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetKey
;
; Description:
;
;       Checks the keyboard to see if a key is available.
;
; Arguments:
;
;       None.
;
; Returns:
;
;       If no key is available, returns 0
;
;       If ASCII character is available, LSB 0 is ASCII code
;                                        LSB 1 is keyboard scan code
;       If extended character is available, LSB 0 is extended ASCII code
;                                           LSB 1 is keyboard scan code
;
;--

EXPORT_ENTRY_MACRO      GetKey
;
; Go into real mode.  We still have the same stack and sp
; but we'll be executing in real mode.
;

        ENTER_REALMODE_MACRO

;
; Set up registers to call BIOS and check to see if a key is available
;

        mov     ax,0100h
        int     BIOS_KEYBOARD_INTERRUPT

        jnz     GkKeyAvail
        mov     eax, 0
        jmp     GkDone

GkKeyAvail:
;
; Now we call BIOS again, this time to get the key from the keyboard buffer
;
        mov     ax,0h
        int     BIOS_KEYBOARD_INTERRUPT
        and     eax,0000ffffh

;
; Save return code on 16bit stack
; Re-enable protect mode and paging
;
GkDone:
        push    eax
        RE_ENABLE_PAGING_MACRO
        pop     eax
;
; Return to caller and the 32-bit universe
;
EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetCounter
;
; Description:
;
;       Reads the tick counter (incremented 18.2 times per second)
;
; Arguments:
;
;       None
;
; Returns:
;
;       The current value of the tick counter
;
;--

EXPORT_ENTRY_MACRO      GetCounter
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

        mov     ah,0
        int     01ah
        mov     ax,cx           ; high word of count
        shl     eax,16
        mov     ax,dx           ; low word of count

        push    eax
        RE_ENABLE_PAGING_MACRO
        pop     eax

EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       Reboot
;
; Description:
;
;       Switches to real-mode and transfers control to a loaded boot sector
;
; Arguments:
;
;       unsigned BootType
;           0 = FAT. Just jump to 0:7c00.
;           1 = HPFS. Assumes boot code and super+spare areas (20 sectors)
;                  are already loaded at 0xd000; jumps to d00:200.
;           2 = NTFS. Assumes boot code is loaded (16 sectors) at 0xd000.
;                  Jumps to d00:256.
;
; Returns:
;       Does not return
;
; Environment:
;
;       Boot sector has been loaded at 7C00
;--

EXPORT_ENTRY_MACRO      Reboot
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <RebootFrame>, ebx
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

;
; Get the BootType argument.  Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;

        push     bp
        mov      bp,sp
        add      bp,2
        mov      edx, [bp].BootType

;
; Zero out the firmware heaps, 3000:0000 - 4000:ffff.
;

        xor     eax,eax         ; prepare for stosd
        mov     bx,3000h
        mov     es,bx
        mov     di,ax           ; es:di = physical address 30000
        mov     cx,4000h        ; cx = rep count, # dwords in 64K
        cld
        rep stosd
        mov     cx,4000h        ; rep count
        mov     es,cx           ; es:di = physical address 40000
        rep stosd

;
; Disable the A20 line.  Some things (like EMM386 and OS/2 on PS/2 machines)
; hiccup or die if we don't do this.
;

extrn   _DisableA20:near
        call    _DisableA20

;
; Put the video adapter back in 80x25 mode
;
        push    dx
        mov     ax, 0003h
        int     010h
        pop     dx

;
; Reset all the segment registers and setup the original stack
;
        mov     ax,0
        mov     ds,ax
        mov     es,ax
        mov     fs,ax
        mov     gs,ax

        mov     ax,30
        mov     ss,ax
        mov     esp,0100h
        mov     ebp,0
        mov     esi,0
        mov     edi,0

        test    dx,-1
        jz      FatBoot

;
; Setup the registers the way the second sector of the OS/2 HPFS boot code
; expects them.  We skip the first sector entirely, as that just loads in
; the rest of the sectors.  Since the rest of the sectors are ours and not
; OS/2's, this would cause great distress.
;
        mov     ax,07c0h
        mov     ds, ax
        mov     ax, 0d00h
        mov     es, ax

        cli
        xor     ax,ax
        mov     ss,ax
        mov     sp, 07c00h
        sti

        push    0d00h
        push    0256h
        jmp     RebootDoit

FatBoot:
        push    0            ; set up for branch to boot sector
        push    07c00h
        mov     dx,080h

;
; And away we go!
;
RebootDoit:
        retf

        RE_ENABLE_PAGING_MACRO

        REMOVE_STACK_FRAME_MACRO  <RebootFrame>

EXPORT_EXIT_MACRO

;++
;
; Name:
;
;       HardwareCursor
;
; Description:
;
;       Positions the hardware cursor and performs other display stuff.
;
; Arguments:
;
;             ULONG Y coord (0 based)
;             ULONG X coord (0 based)
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;       If X = 0x80000000, then Y contains values that get placed into
;           ax (low word of Y) and bx (hi word of y).
;       Otherwise X,Y = coors for cursor
;
;
;--

EXPORT_ENTRY_MACRO    HardwareCursor
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <HardwareCursorFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Get the requested sectors. Arguments on realmode stack
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Put the row (y coord) in dh and the column (x coord) in dl.
;

        mov      eax,[bp].YCoord
        mov      edx,[bp].XCoord
        cmp      edx,80000000h
        jne      gotxy

        mov      ebx,eax
        shr      ebx,16
        jmp      doint10

    gotxy:
        mov      dh,al
        mov      ah,2
        mov      bh,0

    doint10:
        int      10h

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <HardwareCursorFrame>

;
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; Name:
;
;       GetDateTime
;
; Description:
;
;       Gets date and time
;
; Arguments:
;
;             ULONG Virtual address of a dword in which to place time.
;             ULONG Virtual address of a dword in which to place date.
;     TOS ->  ULONG Flat return address (must be used with KeCodeSelector)
;
;--

BCD_TO_BIN  macro
    xor ah,ah
    rol ax,4
    ror al,4
    aad
endm

EXPORT_ENTRY_MACRO    GetDateTime
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetDateTimeFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Get the time
;

        mov      ah,2
        int      1ah

;
; Convert BIOS time format into our format and place in caller's dword
; bits 0-5 are the second
; bits 6-11 are the minute
; bits 12-16 are the hour
;
        xor      eax,eax
        mov      al,dh      ; BCD seconds
        BCD_TO_BIN
        movzx    edx,ax
        mov      al,cl      ; BCD minutes
        BCD_TO_BIN
        shl      ax,6
        or       dx,ax
        mov      al,ch      ; BCD hours
        BCD_TO_BIN
        shl      eax,12
        or       edx,eax

        mov      eax,[bp].TimeDword
        mov      bx,ax
        and      bx,0fh
        shr      eax,4
        mov      es,ax

        mov      es:[bx],edx

;
; Get the date
;

        mov      ah,4
        int      1ah

;
; Convert BIOS date format into our format and place in caller's dword
; bits 0-4  are the day
; bits 5-8  are the month
; bits 9-31 are the year
;

        xor     eax,eax
        mov     al,dl       ; BCD day
        BCD_TO_BIN
        mov     bl,dh
        movzx   edx,ax
        mov     al,bl       ; BCD month
        BCD_TO_BIN
        shl     ax,5
        or      dx,ax
        mov     al,cl       ; BCD year
        BCD_TO_BIN
        mov     cl,al
        mov     al,ch       ; BCD century
        BCD_TO_BIN
        mov     ah,100
        mul     ah
        xor     ch,ch
        add     ax,cx
        shl     eax,9
        or      edx,eax

        mov     eax,[bp].DateDword
        mov     bx,ax
        and     bx,0fh
        shr     eax,4
        mov     es,ax

        mov     es:[bx],edx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetDateTimeFrame>

;
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO

;++
;
; VOID
; DetectHardware (
;    IN PDETECTION_RECORD DetectionRecord
;    )
;
; Routine Description:
;
;    This routine invokes x86 16 bit real mode detection code from
;    osloader 32 bit flat mode.
;
; Arguments:
;
;    DetectionRecord - Supplies a pointer to a detection record structure.
;
; Return Value:
;
;    None.
;
;--


EXPORT_ENTRY_MACRO    DetectHardware

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <DetectionFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Call the Hardware Detection code
;

        push    cs
        push    offset _TEXT:DetectionDone      ; push far return addr

        push    DETECTION_ADDRESS_SEG
        push    DETECTION_ADDRESS_OFFSET
        retf

DetectionDone:

;
; Restore bp and remove stack-frame from stack
;

        REMOVE_STACK_FRAME_MACRO <DetectionFrame>

;
; No return code, so we don't save return code around page enabling code
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO

;++
;
; VOID
; ComPort (
;    IN LONG  Port,
;    IN ULONG Function,
;    IN UCHAR Arg
;    )
;
; Routine Description:
;
;    Invoke int14 on com1.
;
; Arguments:
;
;    Port - port # (0 = com1, etc).
;
;    Function - int 14 function (for ah)
;
;    Arg - arg for function (for al)
;
; Return Value:
;
;    None.
;
;--


EXPORT_ENTRY_MACRO    ComPort

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <ComPortFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push     bp
        mov      bp,sp
        add      bp,2

;
; Get args and call int14
;

        mov      ah,byte ptr [bp].ComPortFunction
        mov      al,byte ptr [bp].ComPortArg
        mov      dx,word ptr [bp].ComPortPort
        int      14h

;
; Restore bp and remove stack-frame from stack
;

        pop      bp

        REMOVE_STACK_FRAME_MACRO <ComPortFrame>

;
; No return code, so we don't save return code around page enabling code
; Re-enable protect-mode and paging.
;

        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO

;++
;
; ULONG
; GetStallCount (
;    VOID
;    )
;
; Routine Description:
;
;    Calculates how many increments are required to stall for one microsecond
;
;    The way this routine works is to set up an ISR on the BIOS vector 1C.
;    This routine will get called 18.2 times a second.  The location where
;    IP will be stored when the interrupt occurs is computed and stashed in
;    the code segment.  When the ISR fires, the IP on the stack is changed
;    to point to the next chunk of code to execute.  So we can spin in a
;    very tight loop and automatically get blown out of the loop when the
;    interrupt occurs.
;
;    This is all pretty sleazy, but it allows us to calibrate accurately
;    without relying on the 8259 or 8254 (just BIOS).  It also does not
;    depend on whether the ISR can affect the CPU registers or not.  (some
;    BIOSes, notably Olivetti, will preserve the registers for you)
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Number of increments required to stall for one microsecond
;
;--

EXPORT_ENTRY_MACRO    GetStallCount
;
; Go into real mode.
;


        ENTER_REALMODE_MACRO

        cli

        push    di
        push    si
        push    ds
        mov     ax,0
        mov     ds,ax

;
; save previous vector
;
        mov     di, 01ch*4
        mov     cx, [di]
        mov     dx, [di+2]

;
; insert our vector
;
        mov     ax, offset GscISR
        mov     [di], ax
        push    cs
        pop     ax
        mov     [di+2], ax

        mov     eax,0
        mov     ebx,0
        mov     si,sp
        sub     si,6
        mov     cs:savesp,si
        mov     cs:newip,offset GscLoop2
        sti

;
; wait for first tick.
;
GscLoop1:
        cmp     ebx,0
        je      GscLoop1

;
; start counting
;
;
; We spin in this loop until the ISR fires.  The ISR will munge the return
; address on the stack to blow us out of the loop and into GscLoop3
;
GscLoop2:
        mov     cs:newip,offset GscLoop4

GscLoop3:

        add     eax,1
        jnz     short GscLoop3

;
GscLoop4:
;
; stop counting
;

;
; replace old vector
;
        cli
        mov     [di],cx
        mov     [di+2],dx
        sti

        pop     ds
        pop     si
        pop     di
        jmp     GscDone

newip   dw      ?
savesp  dw      ?

GscISR:
;
; blow out of loop
;
        push    bp
        push    ax
        mov     bp,cs:savesp
        mov     ax,cs:newip
        mov     ss:[bp],ax
        pop     ax
        pop     bp

GscISRdone:
        iret


GscDone:
        mov     edx, eax
        mov     ecx,16
        shr     edx,cl                  ; (dx:ax) = dividend
        mov     cx,0D6A6h               ; (cx) = divisor

        div     cx

        and     eax,0ffffh
        inc     eax                     ; round loopcount up (prevent 0)

;
; Re-enable protect-mode and paging.
;
        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;

EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       InitializeDisplayForNt
;
; Description:
;
;       Puts the display into 50 line mode
;
; Arguments:
;
;       None
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      InitializeDisplayForNt
;
; Go into real mode.
;

        ENTER_REALMODE_MACRO

        mov     ax, 1112h       ; Load 8x8 font
        mov     bx, 0
        int     10h

        RE_ENABLE_PAGING_MACRO

EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetMemoryDescriptor
;
; Description:
;
;       Returns a memory descriptor
;
; Arguments:
;
;       pointer to MemoryDescriptorFrame
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      GetMemoryDescriptor

;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <MemoryDescriptorFramePointer>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2


        mov     eax,[bp].E820FramePointer
        mov     bp,ax
        and     bp,0fh
        shr     eax,4
        mov     es,ax                   ; (es:bp) = E820 Frame

        mov     ebx, es:[bp].Key
        mov     ecx, es:[bp].DescSize
        lea     di, [bp].BaseAddrLow
        mov     eax, 0E820h
        mov     edx, 'SMAP'             ; (edx) = signature

        INT     15h
        mov     es:[bp].Key, ebx        ; update callers ebx
        mov     es:[bp].DescSize, ecx   ; update callers size

        sbb     ecx, ecx                ; ecx = -1 if carry, else 0
        sub     eax, 'SMAP'             ; eax = 0 if signature matched
        or      ecx, eax
        mov     es:[bp].ErrorFlag, ecx  ; return 0 or non-zero

;
; Restore bp and remove stack-frame from stack
;

        pop     bp
        REMOVE_STACK_FRAME_MACRO <MemoryDescriptorFramePointer>
        RE_ENABLE_PAGING_MACRO

EXPORT_EXIT_MACRO

;++
;
; Routine Name:
;
;       GetElToritoStatus
;
; Description:
;
;       Get El Torito Disk Emulation Status
;
; Arguments:
;
;       None
;
; Returns:
;
;       None
;
;--

EXPORT_ENTRY_MACRO      GetElToritoStatus
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetElToritoStatusFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2

        push    dx
        push    bx
        push    ds
        push    si

;
; Put the Specification Packet pointer into DS:SI, and the Drive
; Number on DL. Note that and buffer
; addresses passed to this routine MUST be in the lower one
; megabyte of memory to be addressable in real mode.
;

        mov     eax,[bp].SpecPacketPointer
        mov     bx,ax
        and     bx,0fh
        mov     si,bx
        shr     eax,4
        mov     ds,ax

        mov     dl,byte ptr [bp].ETDriveNum

        mov     ax,04B01h                       ; Function = Return Disk Emulation status
        int     BIOS_DISK_INTERRUPT

        jc      etstatuserr

;
; Carry wasn't set so we have no error and need to "clean" eax of
; any garbage that may have been left in it.
;
        xor     eax,eax

etstatuserr:
;
; Mask-off any garbage that my have been left in the upper
; 16bits of eax.
;
        and     eax,0000ffffh

        pop     si
        pop     ds
        pop     bx
        pop     dx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetElToritoStatusFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       GetExtendedInt13Params
;
; Description:
;
;       Determine if extended int13 services are available for a drive
;       and if so retrieve extended disk parameters.
;
; Arguments:
;
;       - 32-bit flat pointer to 26-byte param packet filled by this routine
;
;       - int 13 unit number
;
; Returns:
;
;       ax = 0 means extended int13 not supported on the given drive
;       ax = 1 means extended int13 supported and param packet filled in
;
;--

EXPORT_ENTRY_MACRO      GetExtendedInt13Params
;
; Move the arguments from the caller's 32bit stack to the SU module's
; 16bit stack.
;

        MAKE_STACK_FRAME_MACRO  <GetExtendedInt13ParamsFrame>, ebx

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;

        ENTER_REALMODE_MACRO

;
; Make (bp) point to the bottom of the argument frame.
;
        push    bp
        mov     bp,sp
        add     bp,2

        push    dx
        push    bx
        push    ds
        push    si

;
; Check for support for this drive.
;
        mov     ah,41h
        mov     bx,55aah
        mov     dl,byte ptr [bp].Int13UnitNumber
        int     BIOS_DISK_INTERRUPT
        jc      noxint13                        ; carry set means no xint13
        cmp     bx,0aa55h                       ; check signature
        jnz     noxint13                        ; not present, no xint13
        test    cl,1                            ; bit 0 clear means no xint13
        jz      noxint13

;
; If we get here it looks like we have xint13 support.
; Some BIOSes are broken though so we do some validation while we're
; asking for the extended int13 drive parameters for the drive.
; Note that and buffer addresses passed to this routine
; MUST be in the lower one megabyte of memory to be addressable in real mode.
;
        mov     eax,[bp].ParamPacketPointer
        mov     bx,ax
        and     bx,0fh
        mov     si,bx
        shr     eax,4
        mov     ds,ax                           ; DS:SI -> param packet
        mov     word ptr [si],26                ; initialize packet with size
                                                ; some bioses helpfully zero out
                                                ; the whole buffer according to
                                                ; this size, so make SURE the
                                                ; entire word is initialized and
                                                ; there's no junk in the high byte.

        mov     dl,byte ptr [bp].Int13UnitNumber
        mov     ah,48h
        int     BIOS_DISK_INTERRUPT
        jc      noxint13
;
; If we get here then everything's cool and we have xint13 parameters.
; We also know carry isn't set.
;
        mov     al,1
        jnc     xint13done

noxint13:
        xor     al,al

xint13done:
        movzx   eax,al

        pop     si
        pop     ds
        pop     bx
        pop     dx

;
; Restore bp and remove stack-frame from stack
;
        pop      bp

        REMOVE_STACK_FRAME_MACRO <GetExtendedInt13ParamsFrame>

;
; Save return code on 16bit stack
; Re-enable protect-mode and paging.
;

        push     eax
        RE_ENABLE_PAGING_MACRO
        pop      eax

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


;++
;
; Routine Name:
;
;       ApmAttemptReconnect
;
; Description:
;
;       Called only during x86 resume from hiberate operation.  Attempts
;       to connect to APM bios in same way ntdetect.com did on first try,
;       so that if APM is present on the machine, it will be reinited to
;       the same working state it was in before hibernate.
;
;       APM version, addresses, selector mappings, etc, are assumed
;       not to have changed while the machine is hibernated.
;
;
; Arguments:
;
;       None.
;
; Returns:
;
;       None.  (It either works or it doesn't.)
;
;--

;
; Yet another set of cheater APM include values
;
APM_INSTALLATION_CHECK          equ     5300h
APM_REAL_MODE_CONNECT           equ     5301h
APM_PROTECT_MODE_16bit_CONNECT  equ     5302h
APM_DRIVER_VERSION              equ     530Eh
APM_DISCONNECT                  equ     5304h

APM_DEVICE_BIOS                 equ     0h
APM_MODE_16BIT                  equ     1h

EXPORT_ENTRY_MACRO      ApmAttemptReconnect

;
; Go into real mode. We still have the same stack and sp
; but we'll be executing in realmode.
;
        ENTER_REALMODE_MACRO

;
; APM installation check
;
        mov     eax,APM_INSTALLATION_CHECK
        mov     ebx,APM_DEVICE_BIOS
        int     15h

        jc      aar_punt
        cmp     bl,'M'
        jnz     aar_punt
        cmp     bh,'P'
        jnz     aar_punt

;
; If we get here, we have an APM bios.  If we just call it,
; we may get grief.  So we will connect in real mode, then
; set our version to the whatever the driver says it is, or 1.2,
; whichever is LESS.  Then query options again.
;

        cmp     ah,1
        jle     aar10
        mov     ah,1            ; ah = min(old ah, 1)
aar10:

        cmp     al,2
        jle     aar20
        mov     al,2            ; al = min(old al, 2)
aar20:

;
; ax = min(apm version, 1.2)
;
        push    ax

;
; connect to the real mode interface
;

        mov     ax,APM_REAL_MODE_CONNECT
        mov     bx,APM_DEVICE_BIOS
        int     15h

        pop     ax
        jc      aar_punt
        push    ax

;
; set the version of the real mode interface
;
        mov     cx,ax           ; ax = major.minor
        mov     bx,APM_DEVICE_BIOS
        mov     ax,APM_DRIVER_VERSION
        int     15h

        pop     ax
        jc      aar_punt

;
; do the install check again, now that we've connected and
; set the version to min(apm ver, 1.2)  some apm bios code
; will give us different install parameters now.
;
        mov     ax,APM_INSTALLATION_CHECK
        mov     bx,APM_DEVICE_BIOS
        int     15h

        jc      aar_punt

;
; If we are here:
;       AH = revised Major version
;       AL = revised Minor version
;       CX = APM Flags
;
        push    cx
        push    ax

;
; Now disconnect from the real mode interface
;
        mov     ax,APM_DISCONNECT
        mov     bx,APM_DEVICE_BIOS
        int     15h

        pop     ax
        pop     cx
        jc      aar_punt

;
; Since we are here:
;       AH = revised Major version
;       AL = revised Minor version
;       CX = apm parameters
;
;       APM is present, and seems to work, and we've set it to the
;       version number that we think it and we both like.
;
;       So, things should just work, if APM has proper support
;       for the modes and features that we need.
;

        cmp     cx,APM_MODE_16BIT
        jz      aar_punt

;
; 16bit protected mode is available
;
        push    ax
        push    cx

;
; do 16 bit protected mode connect
;
        mov     ax,APM_PROTECT_MODE_16bit_CONNECT
        mov     bx,APM_DEVICE_BIOS
        int     15h

        pop     cx
        pop     ax
        jc      aar_punt

;
; do 16 bit protected mode set version
;

        mov     cx,ax
        mov     ax,APM_DRIVER_VERSION
        mov     bx,APM_DEVICE_BIOS
        int     15h

;
; if NC, then we have connect to 16bit proected mode interface,
; AND set the version.  since ntdetect.com presumably did this
; exact same thing at first boot, we already have GDT entries pointing
; to the 16bit code, hooks set, etc.  So, in theory, it just works.
;
; if CY here, or anywhere above, APM doesn't work for us.  Too bad.
;

aar_punt:
;
; return to paged mode
;
        RE_ENABLE_PAGING_MACRO

;
; Return to caller and the 32bit universe.
;
EXPORT_EXIT_MACRO


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\memmap.inc ===
PAGE_DIR_ADDRESS        equ     99000h
PAGE_TABLE_ADDRESS      equ     9A000h

;;
;; Address Mappings
;;


PhysAddressVideo        equ     0b8000h
PhysSizeVideo           equ     2000h

SYSTEM_PAGE_PA          equ     17000h
SYSTEM_PAGE_VA          equ     80420000h
GDT_LOC                 equ     0
IDT_LOC                 equ     400h
TSS_LOC                 equ     0C00h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\macro.inc ===
;++
;
; File Name:
;
;       macro.inc
;
; Author:
;
;       Thomas Parslow [tomp]
;
; Created:
;
;       27-Feb-91
;
; Abstract:
;
;       The macros used for creating the exported entry points the
;       OS loader will use for basic h/w dependent services. These
;       services are:
;
;       o       Disk I/O
;       o       Character I/O
;
;
;--


;++
;
; EXPORT_ENTRY_MACRO
; We arrive here from the OS loader with a 32bit CS. That is, we're
; executing the code with cs:eip where cs contains a selector for a
; 32bit flat segment. We want to get to a 16bit cs. That is, cs:ip.
; The entry points are exported as 32bit near pointers to the OS loader.
; All code in the SU module is identity mapped so the flat 32bit offset
; is equal to the physical address.
;
; Therefore, we export the 32bit physical address as the
; entry point and the code may be executed with either the 32bit
; flat cs or the SU module's 16bit based cs.  Before we can switch
; modes we must load all of the segment registers with selectors for
; 16bit segments.  We start by pushing a far pointer to a label in
; the macro and then doing a retf. This allows us to fall through
; to the next instruction, but we're now executing through cs:ip
; with a 16bit CS.
;
; Output:
;
;       (ebx) = pointer to stack frame (and top of 32bit stack).
;

EXPORT_ENTRY_MACRO  macro entryname
        LOCAL    exp1
_TEXT32 segment para use32 public 'CODE'
        ASSUME CS:_TEXT32
ALIGN 4
Public  EntryName
EntryName LABEL near
;
; We've go a 32bit CS:EIP - go to a 16bit CS:IP

        push     dword ptr SuCodeSelector
        push     dword ptr (offset exp1)

        retf
_TEXT32 ends
        ASSUME CS:_TEXT
ALIGN 4
exp1:
;
; Save caller's EBP register and stack pointer (ESP)
;

        push     ebp
        push     ebx
        push     esi
        push     edi
        mov      ebx,esp
;
; Load all the segment registers with 16bit segment selectors
;
        mov      ax,SuDataSelector
        mov      ds,ax
        mov      ss,ax
;
; Set the stack to the top of the segment. We can do this now since
; all of the OS loader's code has already be relocated. Also, we need
; plenty of stack since we'll be calling BIOS routines.
;
        mov      sp,EXPORT_STACK
        push     ebx                  ; save the caller's esp
        endm
;
; EXPORT_ENTRY_MACRO end
;



;++
;
; Name:
;
;       ExportExit
;
; Arguments:
;
;
; Notes:
;
;       EAX = return code and MUST be preserved by this macro.
;
;--

EXPORT_EXIT_MACRO macro
;
; Next get caller's esp that we saved upon entry on the 16bit stack
;
        pop      ebx                    ; get caller's esp
;
; Restore flat selectors in segment registers.
;
        mov      dx,KeDataSelector
        mov      ds,dx
        mov      ss,dx
        mov      es,dx
        mov      esp,ebx


;
; Restore callers' ebp that we saved on the 32bit stack
;
        pop      edi
        pop      esi
        pop      ebx
        pop      ebp      ; (ebp) = caller's ebp

;
; Pull callers flat return address off stack and push the
; flat code selector followed by the return offset, then
; execute a far return and we'll be back in the OS loaders code space.
;
        pop      edx      ; (edx) = caller's return address
        push     dword ptr KeCodeSelector
        push     edx
        db OVERRIDE
        retf
        endm

;++
;
;
;
;--

RE_ENABLE_PAGING_MACRO macro
extrn _EnableProtectPaging:near
        push     RE_ENABLING
        call     _EnableProtectPaging
        add      sp,2
        endm

ENTER_REALMODE_MACRO macro
extrn _RealMode:near
        call    _RealMode
        endm



WAIT_FOREVER_MACRO macro
        LOCAL wf1
wf1:    jmp     wf1
        endm

;++
;
; MAKE_STACK_FRAME_MACRO
;
; Arguments:
;
;    _FrameName_ - is the name of the structure defining the
;                  stack frame layout.
;
;    _PointerRegister_ - is the register containing the linear pointer to
;                        the top of the stack frame.
; ProtectMode ONLY
;
;--

MAKE_STACK_FRAME_MACRO macro _FrameName_ , _PointerRegister_
Local msf1
        mov     ecx, (size _FrameName_)/2
        mov     esi,_PointerRegister_   ; (esi) = offset of argument frame
        add     esi,20                  ; account for ebp, ebx, esi, edi and
                                        ; return address
        push    KeDataSelector          ; (ax) = Flat 32bit segment selector
        pop     ds                      ; (ds:esi) points to argument frame
        push    ss                      ;
        pop     es                      ; (es) = 16bit stack selector
        sub     sp, size _FrameName_    ; make room for the arguments
        xor     edi,edi                 ; clear out upper 16bits of edi
        mov     di,sp                   ; (es:edi) points to top of stack
msf1:
        mov     ax,[esi]
        mov     es:[edi],ax
        add     esi,2
        add     edi,2
        loop    msf1
        push    es                      ;
        pop     ds                      ; put 16bit selector back into ds
        endm


REMOVE_STACK_FRAME_MACRO macro _FrameName_

        add     sp, size _FrameName_
        endm


;BuildDescriptor macro   Base,Limit,Access,Dpl,Stype
;        dw       (Limit AND 0ffffh)
;        dw       (Base AND 0ffffh)
;        db       ((Base SHR 16) AND 0ffh)
;        db       (Gran + Dpl + Stype)
;        db       ((Limit SHR 16) AND 0ffh)
;        db       ((Base SHR 24) AND 0ffh)
;        endm



;
;
;
RETURNCODE_IN_EAX_MACRO macro

        shl      edx,16
        mov      dx,ax
        mov      eax,edx
        endm

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\ntmisc.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ntmisc.h

Abstract:

    This module contains the misc. definitions in \nt\public\sdk\inc
    directory.  Note, we created this file because ntdetect uses 16 bit
    compiler and various new C compiler switches/pragamas are not recognized
    by the 16 bit C compiler.

Author:

    Shie-Lin Tzong (shielint) 11-Nov-1992


Revision History:


--*/
//
// PHYSICAL_ADDRESS
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

//
// Note all the definitions defined below are used to make compiler shut up.
// Ntdetect.com does not rely on the correctness of the structures.
//

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY far *Flink;
   struct _LIST_ENTRY far *Blink;
} LIST_ENTRY, far *PLIST_ENTRY;

#define PTIME_FIELDS    PVOID


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\global.h ===
/*++

Copyright (c) 1990  Microsoft Corporation


File Name:

   global.h


Abstract:

     Prototypes for all global functions defined for the 386 NT bootloader


Author

    Thomas Parslow  (TomP) 2-Jan-90



--*/


VOID
SuMain(
    IN UCHAR BtBootDrive
    );

extern
USHORT
Debugger;


/////
///// IN sumain.c
/////


VOID
SetupPageTables(
    VOID
    );


//
// in Supage.c
//

extern
VOID
InitializePageTables(
    VOID
    );

VOID
ZeroMemory(
    ULONG,
    ULONG
    );


VOID
PrintBootMessage(
    VOID
    );

/*
VOID
DoGlobalInitialization(
    IN FPVOID,
    IN FPDISKBPB,
    IN USHORT
    );


VOID
MoveMemory(
    IN ULONG,
    IN PUCHAR,
    IN USHORT
    );


/////
///// IN disk.c
/////

VOID
InitializeDiskSubSystem(
    IN FPDISKBPB,
    IN USHORT
    );

/*

VOID
InitializePageSets(
    IN PIMAGE_FILE_HEADER
    );

VOID
EnableA20(
    VOID
    );


extern IDT IDT_Table;

*/

/////
///// IN su.asm
/////


VOID
EnableProtectPaging(
    USHORT
    );


SHORT
biosint(
    IN BIOSREGS far *
    );

extern
VOID
TransferToLoader(
    ULONG
    );


/////
///// IN video.c
/////

VOID
InitializeVideoSubSystem(
    VOID
    );

VOID
putc(
    IN CHAR
    );
VOID
putu(
    IN ULONG
    );

VOID
puts(
    IN PCHAR
    );

VOID
puti(
    IN LONG
    );

VOID
putx(
    IN ULONG
    );

VOID
scroll(
    VOID
    );

VOID
clrscrn(
    VOID
    );

VOID
BlPrint(
    IN PCHAR,
    ...
    );


// END OF FILE //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\main.c ===
/*++

Copyright (c) 1991  Microsoft Corporation


Module Name:

    main.c

Abstract:

    Main for the SU (startup) module for the OS loader. The SU module
    must take the x86 from a real-mode 16bit state to a FLAT model,
    32bit protect/paging enabled state.

Author:

    Thomas Parslow (tomp) Created 20-Dec-90


Revision History:

--*/


#define NTAPI

#include "su.h"
#include "eisa.h"
#define _SYS_GUID_OPERATORS_
#include <guiddef.h>
#include "ntimage.h"
#include "strings.h"

extern VOID RealMode(VOID);
extern USHORT IDTregisterZero;
extern IMAGE_DOS_HEADER edata;
extern USHORT end;
extern VOID MoveMemory(ULONG,ULONG,ULONG);
extern USHORT SuStackBegin;
extern UCHAR Beginx86Relocation;
extern UCHAR Endx86Relocation;
extern USHORT BackEnd;
extern ULONG FileStart;
extern BOOLEAN IsNpxPresent(VOID);
extern USHORT HwGetProcessorType(VOID);
extern USHORT HwGetCpuStepping(USHORT);
extern ULONG MachineType;
extern ULONG OsLoaderStart;
extern ULONG OsLoaderEnd;
extern ULONG ResourceDirectory;
extern ULONG ResourceOffset;
extern ULONG OsLoaderBase;
extern ULONG OsLoaderExports;

extern
TurnMotorOff(
    VOID
    );

extern
EnableA20(
    VOID
    );

extern
BOOLEAN
ConstructMemoryDescriptors(
    VOID
    );

extern
USHORT
IsaConstructMemoryDescriptors(
    VOID
    );

VOID
Relocatex86Structures(
    VOID
    );

ULONG
RelocateLoaderSections(
    OUT PULONG Start,
    OUT PULONG End
    );

extern
FSCONTEXT_RECORD
FsContext;

#define DISK_TABLE_VECTOR (0x1e*4)

FPULONG DiskTableVector = (FPULONG)(DISK_TABLE_VECTOR);

VOID
SuMain(
    IN UCHAR BtBootDrive
    )
/*++

Routine Description:

    Main entrypoint of the SU module. Control is passed from the boot
    sector to startup.asm which does some run-time fixups on the stack
    and data segments and then passes control here.

Arguments:

    BtBootDrive - Drive that we booted from (int13 unit number)

Returns:

    Does not return. Passes control to the OS loader

--*/
{
    ULONG LoaderEntryPoint;
    ULONG EisaNumPages;
    USHORT IsaNumPages;
    MEMORY_LIST_ENTRY _far *CurrentEntry;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    ULONG BlockEnd;
    ULONG ImageSize;
    ULONG ImageBase;

    //
    // Save fs context info
    //
    FsContext.BootDrive = BtBootDrive;

    //
    // Initialize the video subsystem first so that
    // errors end exceptions can be displayed.
    //

    InitializeVideoSubSystem();

    //
    // In case we booted from a floppy, turn the drive motor off.
    //

    TurnMotorOff();

    //
    // Set up machine type based on its Bus type.
    //

    if (BtIsEisaSystem()) {
        MachineType = MACHINE_TYPE_EISA;
    } else {
        MachineType = MACHINE_TYPE_ISA;
    }

    if (!ConstructMemoryDescriptors()) {
        //
        // If INT 15 E802h fails...
        //

        if (MachineType == MACHINE_TYPE_EISA) {

            //
            // HACKHACK John Vert (jvert)
            //    This is completely bogus.  Since there are a number of EISA
            //    machines which do not let you correctly configure the EISA
            //    NVRAM, and even MORE machines which are improperly configured,
            //    we first check to see how much memory the ISA routines say
            //    exists.  Then we check what the EISA routines tell us, and
            //    compare the two.  If the EISA number is much lower (where "much"
            //    is a completely random fudge factor) than the ISA number, we
            //    assume the machine is improperly configured and we throw away
            //    the EISA numbers and use the ISA ones.  If not, we assume that
            //    the machine is actually configured properly and we trust the
            //    EISA numbers..
            //

            IsaNumPages = IsaConstructMemoryDescriptors();
            EisaNumPages = EisaConstructMemoryDescriptors();
            if (EisaNumPages + 0x80 < IsaNumPages) {
                IsaConstructMemoryDescriptors();
            }
        } else {
            IsaConstructMemoryDescriptors();
        }
    }

    //
    // Search for memory descriptor describing low memory
    //
    CurrentEntry = MemoryDescriptorList;
    while ((CurrentEntry->BlockBase != 0) &&
           (CurrentEntry->BlockSize != 0)) {
        CurrentEntry++;
    }

    if ((CurrentEntry->BlockBase == 0) &&
        (CurrentEntry->BlockSize < (ULONG)512 * (ULONG)1024)) {

        BlPrint(SU_NO_LOW_MEMORY,CurrentEntry->BlockSize/1024);
        while (1) {
        }
    }

    //
    // Ensure there is a memory descriptor to contain osloader image
    //
    OptionalHeader = &((PIMAGE_NT_HEADERS) ((PUCHAR) &edata + edata.e_lfanew))->OptionalHeader;
    ImageBase = OptionalHeader->ImageBase;
    ImageSize = OptionalHeader->SizeOfImage;
    OsLoaderBase = ImageBase;
    OsLoaderExports = ImageBase + OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    CurrentEntry = MemoryDescriptorList;
    while (ImageSize > 0) {
        while (CurrentEntry->BlockSize != 0) {
            BlockEnd = CurrentEntry->BlockBase + CurrentEntry->BlockSize;

            if ((CurrentEntry->BlockBase <= ImageBase) &&
                (BlockEnd > ImageBase)) {

                //
                // this descriptor at least partially contains a chunk
                // of the osloader.
                //
                if (BlockEnd-ImageBase > ImageSize) {
                    ImageSize = 0;
                } else {
                    ImageSize -= (BlockEnd-ImageBase);
                    ImageBase = BlockEnd;
                }

                //
                // look for remaining part (if any) of osloader
                //
                CurrentEntry = MemoryDescriptorList;
                break;
            }
            CurrentEntry++;
        }
        if (CurrentEntry->BlockSize == 0) {
            break;
        }
    }

    if (ImageSize > 0) {
        //
        // We could not relocate the osloader to high memory.  Error out
        // and display the memory map.
        //
        BlPrint(SU_NO_EXTENDED_MEMORY);

        CurrentEntry = MemoryDescriptorList;
        while (CurrentEntry->BlockSize != 0) {
            BlPrint("    %lx - %lx\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockBase + CurrentEntry->BlockSize);

            CurrentEntry++;
        }
        while (1) {
        }

    }

    //
    // Enable the A20 line for protect mode
    //

    EnableA20();

    //
    // Relocate x86 structures. This includes the GDT, IDT,
    // page directory, and first level page table.
    //

    Relocatex86Structures();

    //
    // Enable protect and paging modes for the first time
    //


    EnableProtectPaging(ENABLING);

    //
    // Go relocate loader sections and build page table entries
    //

    LoaderEntryPoint = RelocateLoaderSections(&OsLoaderStart, &OsLoaderEnd);

    //
    // Search for memory descriptor containing the osloader and
    // change it.
    //

    //
    // Transfer control to the OS loader
    //

    TransferToLoader(LoaderEntryPoint);

}

ULONG
RelocateLoaderSections(
    OUT PULONG Start,
    OUT PULONG End
    )
/*++

Routine Description:

    The SU module is prepended to the OS loader file. The OS loader file
    is a coff++ file. This routine computes the beginning of the OS loader
    file, then relocates the OS loader's sections as if it were just
    loading the file from disk file.

Arguments:

    Start - Returns the address of the start of the image
    End   - Returns the address of the end of the image

Returns:

    Entry point of loader


--*/
{
    USHORT Section;
    ULONG Source,Destination;
    ULONG VirtualSize;
    ULONG SizeOfRawData;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER SectionHeader;

    //
    // Make a pointer to the beginning of the loader's coff header
    //
    FileHeader = &((PIMAGE_NT_HEADERS) ((PUCHAR) &edata + edata.e_lfanew))->FileHeader;


    //
    // Validate the appended loader image by checking signatures.
    //   1st - is it an executable image?
    //   2nd - is the target environment the 386?
    //

    if ((FileHeader->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) {
        puts(SU_NTLDR_CORRUPT);
        WAITFOREVER;
    }

    if (FileHeader->Machine != IMAGE_FILE_MACHINE_I386) {
        puts(SU_NTLDR_CORRUPT);
        WAITFOREVER;
    }

    //
    // Make a pointer to the optional header in the header-buffer
    //

    OptionalHeader = (PIMAGE_OPTIONAL_HEADER)((PUCHAR)FileHeader +
        sizeof(IMAGE_FILE_HEADER));

    //
    // Make a pointer to the first section in the header buffer
    //

    SectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)OptionalHeader +
        FileHeader->SizeOfOptionalHeader);

    *Start = OptionalHeader->ImageBase+SectionHeader->VirtualAddress;
    *End   = *Start + SectionHeader->SizeOfRawData;

    //
    // Display some debug stuff for now
    //

    DBG1(
    BlPrint("Machine = %x\n",FileHeader->Machine);
    BlPrint("NumberOfSections = %x\n",FileHeader->NumberOfSections);
    BlPrint("TimeDateStamp %lx\n",FileHeader->TimeDateStamp);
    BlPrint("PointerToSymbolTable = %lx\n",FileHeader->PointerToSymbolTable);
    BlPrint("NumberOfSymbols %lx\n",FileHeader->NumberOfSymbols);
    BlPrint("SizeOfOptionalHeader = %x\n",FileHeader->SizeOfOptionalHeader);
    BlPrint("Characteristics = %x\n",FileHeader->Characteristics);
    )

    //
    // Loop and relocate each section with a non-zero RawData size
    //

    for (Section=FileHeader->NumberOfSections ; Section-- ; SectionHeader++) {

        //
        // Compute source, destination, and count arguments
        //

        Source = FileStart  + SectionHeader->PointerToRawData;
        Destination = OptionalHeader->ImageBase + SectionHeader->VirtualAddress;

        VirtualSize = SectionHeader->Misc.VirtualSize;
        SizeOfRawData = SectionHeader->SizeOfRawData;

        if (VirtualSize == 0) {
            VirtualSize = SizeOfRawData;
        }

        if (SectionHeader->PointerToRawData == 0) {
            //
            // SizeOfRawData can be non-zero even if PointerToRawData is zero
            //

            SizeOfRawData = 0;
        } else if (SizeOfRawData > VirtualSize) {
            //
            // Don't load more from image than is expected in memory
            //

            SizeOfRawData = VirtualSize;
        }

        if (Destination < *Start) {
            *Start = Destination;
        }

        if (Destination+VirtualSize > *End) {
            *End = Destination+VirtualSize;
        }

        DBG1(BlPrint("src=%lx  dest=%lx raw=%lx\n",Source,Destination,SizeOfRawData);)

        if (SizeOfRawData != 0) {
            //
            // This section is either a code (.TEXT) section or an
            // initialized data (.DATA) section.
            // Relocate the section to memory at the virtual/physical
            // addresses specified in the section header.
            //
            MoveMemory(Source,Destination,SizeOfRawData);
        }

        if (SizeOfRawData < VirtualSize) {
            //
            // Zero the portion not loaded from the image
            //

            DBG1( BlPrint("Zeroing destination %lx\n",Destination+SizeOfRawData); )
            ZeroMemory(Destination+SizeOfRawData,VirtualSize - SizeOfRawData);
        }
        //
        // Check if this is the resource section.  If so, we need
        // to pass its location to the osloader.
        //
        if ((SectionHeader->Name[0] == '.') &&
            (SectionHeader->Name[1] == 'r') &&
            (SectionHeader->Name[2] == 's') &&
            (SectionHeader->Name[3] == 'r') &&
            (SectionHeader->Name[4] == 'c')) {
            ResourceDirectory = Destination;
            ResourceOffset = SectionHeader->VirtualAddress;
        }
    }

    DBG1( BlPrint("RelocateLoaderSections done - EntryPoint == %lx\n",
            OptionalHeader->AddressOfEntryPoint + OptionalHeader->ImageBase);)
    return(OptionalHeader->AddressOfEntryPoint + OptionalHeader->ImageBase);

}

VOID
Relocatex86Structures(
    VOID
    )
/*++

Routine Description:

    The gdt and idt are statically defined and imbedded in the SU modules
    data segment. This routine moves then out of the data segment and into
    a page mapped at a defined location.

Arguments:

    None

Returns:

    Nothing


--*/
{
    FPUCHAR Fpsrc, Fpdst;
    USHORT Count;

    //
    // Make pointers to the data and compute the size
    // of the block to use.
    //

    Fpsrc = (FPUCHAR)&Beginx86Relocation;
    MAKE_FP(Fpdst,SYSTEM_STRUCTS_BASE_PA);
    Count = (&Endx86Relocation - &Beginx86Relocation);

    //
    // Move the data to its new location
    //

    while (Count--) {
        *Fpdst++ = *Fpsrc++;

    }

}

VOID
DisplayArgs(
    USHORT es,
    USHORT bx,
    USHORT cx,
    USHORT dx,
    USHORT ax
    )
/*++

Routine Description:

    Just a debugging routine to dump some registers.

Arguments:

    The x86 registers es, bx, cx, dx, and ax are pushed on the stack
    before this routine is called.


Returns:

    Nothing


Environment:

    Real Mode ONLY


--*/
{
    BlPrint("ax:%x dx:%x cx:%x bx:%x es:%x\n",
                (USHORT) ax,
                (USHORT) dx,
                (USHORT) cx,
                (USHORT) bx,
                (USHORT) es);

    return;
}

// END OF FILE //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\eisac.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisac.c

Abstract:

    This module implements routines to get EISA configuration information.

Author:

    Shie-Lin Tzong (shielint) 10-June-1991

Environment:

    16-bit real mode.


Revision History:

    John Vert (jvert) 5-Sep-1991
        Moved into the SU module of portable bootloader

--*/
#include "su.h"
#include "eisa.h"

//
// HACKHACK - John Vert (jvert) 12-Sep-1991
//      We have to initialize this or else it gets stuck in our BSS section
//      which is right in the middle of the osloader.exe header
//
extern BTEISA_FUNCTION_INFORMATION FunctionInformation;


BOOLEAN
FindFunctionInformation (
    IN UCHAR SlotFlags,
    IN UCHAR FunctionFlags,
    OUT PBTEISA_FUNCTION_INFORMATION Buffer,
    IN BOOLEAN FromBeginning
    )

/*++

Routine Description:

    This routine finds function information that matches the specified
    flags.  It starts, either where it left off last time, or at the
    beginning (slot 0, function 0)

Arguments:

    Flags - Flags to check against EISA function and slot information.

    Buffer - pointer to buffer to store EISA information in.

    FromBeginning - if TRUE, search starts at slot 0, function 0.
                    else continue from where it left off last time.

Return Value:

    TRUE - If the operation is success (Buffer is filled in.)
    FALSE - Request fails.

    Notes: The buffer is always changed, reguardless of the success
    of the function.  When failure is returned, the info is invalid.

--*/

{
    static UCHAR Slot=0;
    static UCHAR Function=0;
    BTEISA_SLOT_INFORMATION  SlotInformation;
    UCHAR Flags;
    UCHAR ReturnCode;

    if (FromBeginning) {
        Slot = 0;
        Function = 0;
    }
    BtGetEisaSlotInformation(&SlotInformation, Slot);
    while (SlotInformation.ReturnCode != EISA_INVALID_SLOT) {

        //
        // insure that the slot is not empty, and all of the flags are set.
        // the flags are tested by performing the following logic:
        //
        // -- (RequestSlotFlags XOR (SlotFlags AND RequestSlotFlags)) --
        //
        // if all the requested flags are set, the result will be zero
        //

        if ((SlotInformation.ReturnCode != EISA_EMPTY_SLOT) &&
            (!(SlotFlags ^ (SlotInformation.FunctionInformation & SlotFlags)))) {

            while (SlotInformation.NumberFunctions > Function) {
                ReturnCode = BtGetEisaFunctionInformation(Buffer, Slot, Function);
                Function++;

                //
                // if function call succeeded
                //

                if (!ReturnCode){

                    Flags = Buffer->FunctionFlags;

                    //
                    // Function Enable/Disable bit reversed.
                    //

                    Flags |= (~Flags & EISA_FUNCTION_ENABLED);

                    //
                    // insure that all the function flags are set.
                    // the flags are tested by performing the following logic:
                    //
                    // -- (ReqFuncFlags XOR (FuncFlags AND ReqFuncFlags)) --
                    //
                    // if all the requested flags are set, the result will
                    // be zero
                    //

                    if (!(FunctionFlags ^ (Flags & FunctionFlags))) {
                        return TRUE;
                    }
                }

            }
        }
        Slot++;
        Function = 0;
        BtGetEisaSlotInformation(&SlotInformation, Slot);
    }

    Slot = 0;
    Function = 0;
    return FALSE;
}

VOID
InsertDescriptor (
    ULONG Address,
    ULONG Size
    )

/*++

Routine Description:

    This routine inserts a descriptor into the correct place in the
    memory descriptor list.

Arguments:

    Address - Starting address of the memory block.

    Size - Size of the memory block to be inserted.

Return Value:

    None.

--*/

{
    MEMORY_LIST_ENTRY _far *CurrentEntry;

#ifdef DEBUG1
    BlPrint("Inserting descriptor %lx at %lx\n",Size,Address);
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif
    //
    // Search the spot to insert the new descriptor.
    //

    CurrentEntry = MemoryDescriptorList;

    while (CurrentEntry->BlockSize > 0) {
        //
        // Check to see if this memory descriptor is contiguous with
        // the current one.  If so, coalesce them.  (yes, some machines
        // will return memory descriptors that look like this.  Compaq
        // Prosignia machines)
        //
        if (Address+Size == CurrentEntry->BlockBase) {
#ifdef DEBUG1
            BlPrint("  coalescing with descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            CurrentEntry->BlockBase = Address;
            CurrentEntry->BlockSize += Size;
#ifdef DEBUG1
            BlPrint("  new descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            break;
        }
        if (Address == (CurrentEntry->BlockBase + CurrentEntry->BlockSize)) {
#ifdef DEBUG1
            BlPrint("  coalescing with descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            CurrentEntry->BlockSize += Size;
#ifdef DEBUG1
            BlPrint("  new descriptor at %lx (%lx)\n",
                    CurrentEntry->BlockBase,
                    CurrentEntry->BlockSize);
#endif
            break;
        }

        CurrentEntry++;
    }

    if (CurrentEntry->BlockSize == 0) {
        //
        // If CurrentEntry->BlockSize == 0, we  have reached the end of the list
        // So, insert the new descriptor here, and create a new end-of-list entry
        //
        CurrentEntry->BlockBase = Address;
        CurrentEntry->BlockSize = Size;

        ++CurrentEntry;
        //
        // Create a new end-of-list marker
        //
        CurrentEntry->BlockBase = 0L;
        CurrentEntry->BlockSize = 0L;
    }
#ifdef DEBUG1
    //
    // Wait for a keypress
    //
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif

}

ULONG
EisaConstructMemoryDescriptors (
    VOID
    )

/*++

Routine Description:

    This routine gets the information EISA memory function above 16M
    and creates entries in the memory Descriptor array for them.

Arguments:

    None.

Return Value:

    Number of pages of usable memory.

--*/

{
    BOOLEAN Success;
    PBTEISA_MEMORY_CONFIGURATION MemoryConfiguration;
    ULONG Address;
    ULONG EndAddress;
    ULONG Size;
    ULONG MemorySize=0;
    ULONG IsaMemUnder1Mb=0xffffffff;
    MEMORY_LIST_ENTRY _far *CurrentEntry;

    //
    // HACKHACK John Vert (jvert) 5-Mar-1993
    //
    // See if there is already a memory descriptor for the 640k under
    // 1Mb.  If so, we will believe it instead of the EISA routine.  This
    // is because many EISA routines will always return 640k, even if
    // the disk parameter table is in the last 1k.  The ISA routines will
    // always account for the disk parameter tables.  If we believe the
    // EISA routines, we can overwrite the disk parameter tables, causing
    // much grief.
    //
    CurrentEntry = MemoryDescriptorList;
    while (CurrentEntry->BlockSize > 0) {
        if (CurrentEntry->BlockBase == 0) {
            //
            // found a descriptor starting at zero with a size > 0, so
            // this is the one we want to override the EISA information.
            //
            IsaMemUnder1Mb = CurrentEntry->BlockSize;
            break;
        }
        ++CurrentEntry;
    }

    //
    // Initialize the first entry in the list to zero (end-of-list)
    //

    MemoryDescriptorList->BlockSize = 0;
    MemoryDescriptorList->BlockBase = 0;

    Success = FindFunctionInformation(
                              EISA_HAS_MEMORY_ENTRY,
                              EISA_FUNCTION_ENABLED | EISA_HAS_MEMORY_ENTRY,
                              &FunctionInformation,
                              TRUE
                              );

    //
    // while there are more memory functions, and more free descriptors
    //

    while (Success) {

        MemoryConfiguration = &FunctionInformation.EisaMemory[0];

        do {

            //
            // Get physical address of the memory.
            // Note: physical address is stored divided by 100h
            //

            Address = (((ULONG)MemoryConfiguration->AddressHighByte << 16)
                      + MemoryConfiguration->AddressLowWord) * 0x100;

            //
            // Get the size of the memory block.
            // Note: Size is stored divided by 400h with the value of 0
            //       meaning a size of 64M
            //

            if (MemoryConfiguration->MemorySize) {
                Size = ((ULONG)MemoryConfiguration->MemorySize) * 0x400;
            } else {
                Size = (_64MEGB);
            }

#ifdef DEBUG1
            BlPrint("EISA memory at %lx  Size=%lx  Type=%x ",
                    Address,
                    Size,
                    MemoryConfiguration->ConfigurationByte);

            if ((MemoryConfiguration->ConfigurationByte.Type == EISA_SYSTEM_MEMORY) &&
                (MemoryConfiguration->ConfigurationByte.ReadWrite == EISA_MEMORY_TYPE_RAM) ) {

                BlPrint("  (USED BY NT)\n");
            } else {
                BlPrint("  (not used)\n");
            }
#endif

            //
            // Compute end address to determine if any part of the block
            // is above 16M
            //

            EndAddress = Address + Size;

            //
            // If it is SYSTEM memory and RAM, add the descriptor to the list.
            //

            if ((MemoryConfiguration->ConfigurationByte.Type == EISA_SYSTEM_MEMORY) &&
                (MemoryConfiguration->ConfigurationByte.ReadWrite == EISA_MEMORY_TYPE_RAM) ) {

                if (Address==0) {
                    //
                    // This is the descriptor for the memory under 1Mb.
                    // Compare it with the ISA routine's result, and see
                    // if the ISA one is smaller.  If it is, use the ISA
                    // answer.
                    //
                    if (Size > IsaMemUnder1Mb) {
                        Size = IsaMemUnder1Mb;
                    }
                }
                InsertDescriptor(Address, Size);
                MemorySize += (Size >> 12);
            }

        } while (MemoryConfiguration++->ConfigurationByte.MoreEntries);

        Success = FindFunctionInformation(
                                  EISA_HAS_MEMORY_ENTRY,
                                  EISA_FUNCTION_ENABLED | EISA_HAS_MEMORY_ENTRY,
                                  &FunctionInformation,
                                  FALSE
                                  );
    }
#ifdef DEBUG1
    //
    // Wait for a keypress
    //
        _asm {
            push    ax
            mov     ax, 0
            int     16h
            pop     ax
        }
#endif
    return(MemorySize);
}

BOOLEAN
Int15E820 (
    E820Frame       *Frame
    );


BOOLEAN
ConstructMemoryDescriptors (
    VOID
    )
/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    ULONG           BAddr, EAddr;
    E820Frame       Frame;

    //
    // Initialize the first entry in the list to zero (end-of-list)
    //

    MemoryDescriptorList->BlockSize = 0;
    MemoryDescriptorList->BlockBase = 0;

    //
    // Any entries returned for E820?
    //

    Frame.Key = 0;
    Frame.Size = sizeof (Frame.Descriptor);
    Int15E820 (&Frame);
    if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {
        return FALSE;
    }

    //
    // Found memory in table, use the reported memory
    //

    Frame.Key = 0;
    do {
        Frame.Size = sizeof (Frame.Descriptor);
        Int15E820 (&Frame);
        if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {
            break ;
        }

#ifdef DEBUG1
        BlPrint("E820: %lx  %lx:%lx %lx:%lx %lx %lx\n",
            Frame.Size,
            Frame.Descriptor.BaseAddrHigh,  Frame.Descriptor.BaseAddrLow,
            Frame.Descriptor.SizeHigh,      Frame.Descriptor.SizeLow,
            Frame.Descriptor.MemoryType,
            Frame.Key
            );

            _asm {
                push    ax
                mov     ax, 0
                int     16h
                pop     ax
            }
#endif

        BAddr = Frame.Descriptor.BaseAddrLow;
        EAddr = Frame.Descriptor.BaseAddrLow + Frame.Descriptor.SizeLow - 1;

        //
        // All the processors we have right now only support 32 bits
        // If the upper 32 bits of the Base Address is non-zero, then
        // this range is entirely above the 4g mark and can be ignored
        //

        if (Frame.Descriptor.BaseAddrHigh == 0) {

            if (EAddr < BAddr) {
                //
                // address wrapped - truncate the Ending address to
                // 32 bits of address space
                //

                EAddr = 0xFFFFFFFF;
            }

            //
            // Based upon the address range descriptor type, find the
            // available memory and add it to the descriptor list
            //

            switch (Frame.Descriptor.MemoryType) {
                case 1:
                    //
                    // This is a memory descriptor
                    //

                    InsertDescriptor (BAddr, EAddr - BAddr + 1);
                    break;
            }
        }

    } while (Frame.Key) ;

    return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\trap.asm ===
;++
;
; Module Name:
;
;       trap.asm
;
; Author:
;
;       Thomas Parslow [tomp]
;
; Created:
;
;       15-Jan-91
;
;
; Description:
;
;       x86 exception code
;
;

include su.inc

;
; Exception Routing Table:
; ~~~~~~~~~~~~~~~~~~~~~~~~
; When an exception occurs in the SU module or before the OS loader
; is able to setup its own IDT, control is vectored to one of the
; Trap0 though TrapF labels. We push a number on the stack identifying
; the exception number and then jump to code that pushes the register set
; onto the stack. We then call a general purpose C routine that will dump
; the register contents, the trap number, and error code information
; onto the display.
;

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

extrn _TrapHandler:near
extrn _putx:near
extrn _GDTregister:fword
extrn _IDTregister:fword
extrn _InDebugger:word
extrn SaveSP:word

public  Trap0,Trap1,Trap2,Trap3,Trap4,Trap5,Trap6,Trap7
public  Trap8,Trap9,TrapA,TrapB,TrapC,TrapD,TrapE,TrapF


Trap0:  TRAP_NUMBER  0,MakeTrapFrame
Trap1:  TRAP_NUMBER  1,MakeTrapFrame
Trap2:  TRAP_NUMBER  2,MakeTrapFrame
Trap3:  TRAP_NUMBER  3,MakeTrapFrame
Trap4:  TRAP_NUMBER  4,MakeTrapFrame
Trap5:  TRAP_NUMBER  5,MakeTrapFrame
Trap6:  TRAP_NUMBER  6,MakeTrapFrame
Trap7:  TRAP_NUMBER  7,MakeTrapFrame
Trap8:  TRAP_NUMBER  8,MakeTrapFrame
Trap9:  TRAP_NUMBER  9,MakeTrapFrame
TrapA:  TRAP_NUMBER  0Ah,MakeTrapFrame
TrapB:  TRAP_NUMBER  0Bh,MakeTrapFrame
TrapC:  TRAP_NUMBER  0Ch,MakeTrapFrame
TrapD:  TRAP_NUMBER  0Dh,MakeTrapFrame
TrapE:  TRAP_NUMBER  0Eh,MakeTrapFrame
TrapF:  TRAP_NUMBER  0Fh,MakeTrapFrame


;
; We save the user's register contents here on the stack and call
; a C routine to display those contents.
; Uses 42 bytes of stack. (40 for frame)
;
; Note that we build a stack frame that's independent of the code and
; stack segments' "size" during execution. That way whether we enter
; with a 16bit or 32bit stack, the arguments frame is exacely the same.
;

MakeTrapFrame:

        mov      eax,esp
        push     ecx
        push     edx
        push     ebx
        push     eax  ; (eax)=(esp)
        push     ebp
        push     esi
        push     edi

        mov      ax,ds
        push     ax
        mov      ax,es
        push     ax
        mov      ax,fs
        push     ax
        mov      ax,gs
        push     ax
        mov      ax,ss
        push     ax
        mov      eax,cr3
        push     eax
        mov      eax,cr2
        push     eax
        mov      eax,cr0
        push     eax
        mov      eax,dr6
        push     eax
        str      ax
        push     ax
;
; Clear out debug register signals
;

        xor      eax,eax
        mov      dr6,eax

;
; Get a known good data segment
;
        mov      ax,SuDataSelector
        mov      ds,ax
;
; Save system registers
;
        mov      bx,offset DGROUP:_GDTregister
        sgdt     fword ptr [bx]
        mov      bx,offset DGROUP:_IDTregister
        sidt     fword ptr [bx]
;
; Is the exception frame on a 16bit or 32bit stack?
;
        mov      ax,ss
        cmp      ax,KeDataSelector
        je       Trap32
        cmp      ax,DbDataSelector
        jne      mtf8
;
; Most likely we took a trap while initializing the 386 kernel debugger
; So we've got a 16bit stack that isn't ours. We need to move
; the stack frame onto the SU module's stack.

        jmp      Trap16

mtf8:
;
; Frame on a our 16bit stack so just call the trap dump routine
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

;
; Get rid of the junk we saved just to display
;
        pop      eax      ; get rid of ebp pushed for other returns
        add      sp,ExceptionFrame.Fgs
;
; Reload the user's context and return to 16bit code
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret





Trap32:
;
; The exception frame is on a 32bit stack so we must setup a 16bit
; stack and then move the exception frame on to it before calling
; the trap dump routine.
;

        mov      ebx,esp
;
; Setup a known good stack
;
        mov      ax,SuDataSelector
        mov      ss,ax
        mov      sp,EXPORT_STACK
;
; Copy the exception frame to the new stack
;

        mov     ecx, (size ExceptionFrame)/2 ; # of words in frame
        mov     esi,ebx                 ; (esi) = offset of argument frame
        push    KeDataSelector          ; (ax) = Flat 32bit segment selector
        pop     ds                      ; (ds:esi) points to argument frame
        push    ss                      ;
        pop     es                      ; (es) = 16bit stack selector
        sub     sp, size ExceptionFrame ; make room for the arguments
        xor     edi,edi                 ; clear out upper 16bits of edi
        mov     di,sp                   ; (es:edi) points to top of stack
;
; Loop and copy a word at a time.
;
msf1:
        mov     ax,[esi]
        mov     es:[edi],ax
        add     esi,2
        add     edi,2
        loop    msf1

        push    es                      ;
        pop     ds                      ; put 16bit selector back into ds

;
; Now call the general purpose exception handler
;
        push     ebx                    ; save esp for return
;
;  Save SP in order to restore the stack in case we
;  take a fault in the debugger
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

IFDEF  DEBUG0
public DebugReturn
DebugReturn:
ENDIF ;DEBUG
        pop      ebx
;
; We may have changed the flags while in the debugger. Copy the
; new eflag to the iret frame. After we restore the original stack
; pointers.
;

        mov      bp,sp
        mov      ecx,[bp].Feflags

        mov      ax,KeDataSelector
        mov      ss,ax
        mov      esp,ebx

        mov      [esp].Feflags,ecx
;
; Get rid of the junk we saved just to display
;
        add      esp,ExceptionFrame.Fgs
;
; Reload the user's context
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret


Trap16:

; The exception frame is on a 16bit stack that isn't ours. So we must
; move the exception frame on to the SU module's stack before calling
; the trap dump routine.
;

        mov      ebx,esp
;
; Setup a known good stack
;
        mov      ax,SuDataSelector
        mov      ss,ax
        mov      sp,EXPORT_STACK
;
; Copy the exception frame to the new stack
;

        mov      ecx, (size ExceptionFrame)/2
        mov      si,bx                 ; (esi) = offset of argument frame
        push     DbDataSelector          ;
        pop      ds                      ; (ds:esi) points to argument frame
        push     ss                      ;
        pop      es                      ; (es) = 16bit stack selector
        sub      sp, size ExceptionFrame ; make room for the arguments
        mov      di,sp                   ; (es:edi) points to top of stack
;
; Loop and copy a word at a time.
;
Trap16_10:
        mov      ax,[si]
        mov      es:[di],ax
        add      si,2
        add      di,2
        loop     Trap16_10

        push     es                      ;
        pop      ds                      ; put 16bit selector back into ds

;
; Now call the general purpose exception handler
;

        push     ebx                    ; save (original esp) for return
;
;  Save SP in order to restore the stack in case we
;  take a fault in the debugger
;
        mov      bx,offset DGROUP:SaveSP
        mov      [bx],sp

        call     _TrapHandler

IFDEF  DEBUG0
public Debug16Return
Debug16Return:
ENDIF ;DEBUG
        pop      ebx
;
; We may have changed the flags while in the debugger. Copy the
; new eflag to the iret frame. After we restore the original stack
; pointers.
;

        mov      bp,sp
        mov      ecx,dword ptr [bp].Feflags

        mov      ax,DbDataSelector
        mov      ss,ax
        mov      esp,ebx

        mov      dword ptr ss:[bx].Feflags,ecx
;
; Get rid of the junk we saved just to display
;
        add      sp,ExceptionFrame.Fgs
;
; Reload the user's context
;
        pop      gs
        pop      fs
        pop      es
        pop      ds
        pop      edi
        pop      esi
        pop      ebp
        pop      eax
        pop      ebx
        pop      edx
        pop      ecx
        pop      eax      ; get rid of trap #
        pop      eax      ; get original eax
        add      esp,4    ; get rid of error code
;
; Pop IRET frame and return to where the trap occured
;
        OPSIZE
        iret



_TEXT   ends
        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\su.inc ===
;++
;
; Module name
;
;       su.inc
;
; Author
;
;       Thomas Parslow  (tomp)  Mar-1-90
;
; Description
;
;       Include file for SU.ASM.
;
;
;--

.386

PAGE_SIZE               equ     1000h
MACHINE_TYPE_ISA        equ     0
MACHINE_TYPE_EISA       equ     1
MACHINE_TYPE_MCA        equ     2

;
; Define the segment:offset address pair of the location to
; load detection module.
; N.B. This definition *MUST* be the same as the ones defined
;      in ..\constant.h
;

DETECTION_ADDRESS_SEG   equ     1000h
DETECTION_ADDRESS_OFFSET        equ     0

;
; Structure definitions and equates for INT 15 function E820
;

E820Frame struc
        ErrorFlag       dd      ?
        Key             dd      ?
        DescSize        dd      ?

        BaseAddrLow     dd      ?
        BaseAddrHigh    dd      ?
        SizeLow         dd      ?
        SizeHigh        dd      ?
        MemoryType      dd      ?
E820Frame ends

MemoryDescriptorFramePointer struc
        E820FramePointer    dd      ?
MemoryDescriptorFramePointer ends



;

BIOS_DISK_INTERRUPT     equ     13h
BIOS_READ_SECTOR        equ     2
IDT_ENTRIES             equ     100h

BIOS_KEYBOARD_INTERRUPT equ     16h

EXPORT_STACK            equ     07ffeh
RE_ENABLING             equ     1
LOADER_STACK            equ     061ffch

CR0_ET                  equ     10h

;
; Trap Number macro save eax on the stack and then pushes the
; number of the trap that's in progress.
;

TRAP_NUMBER      macro  num,addr
        IF num EQ 9
        push     eax  ; push place holder for error code
        ENDIF
        IF num LE 7
        push     eax  ; push place holder for error code
        ENDIF
        push     eax       ; save eax on stack first
        mov      eax,num
        push     eax
        jmp      addr
        endm

;;
;
; GetSector Stack Frame Structure
;
; Stack frame definition for GetSector call from OS loader
; to 16bit routines.
;
;;

GetSectorFrame          struc
        FunctionNumber  dd      ?
        DriveNumber     dd      ?
        HeadNumber      dd      ?
        TrackNumber     dd      ?
        SectorNumber    dd      ?
        NumberOfSectors dd      ?
        BufferPointer   dd      ?
GetSectorFrame          ends

;;
;
; GetEddsSector Stack Frame Structure
;
; Stack frame definition for GetEddsSector call from OS loader
; to 16bit routines.
;
;;

GetEddsSectorFrame      struc
        DriveNum        dd      ?
        LBNLow          dd      ?
        LBNHigh         dd      ?
        NumberOfBlocks  dd      ?
        BufPointer      dd      ?
        FunctionNum     dd      ?
GetEddsSectorFrame      ends

RebootFrame             struc
        BootType        dd      ?
RebootFrame             ends

;
; ABIOS services Stack Frame Structure
;
; Stack frame definition for ABIOS services call from OS loader
; to 16 bit routine.
;

AbiosServicesFrame      struc
        AbiosFunction   dd      ?
        CommonDataArea  dd      ?
        InitTable       dd      ?
        RamExtension    dd      ?
        AbiosRoutine    dd      ?
        LogicalId       dd      ?
        NumberLids      dd      ?
AbiosServicesFrame      ends

;
; Hardware detection frame structure
;
; Stack frame definition for DetectHardware call from OS loader
; to 16 bit routine.
;

DetectionFrame          struc
        HeapStart       dd      ?
        HeapSize        dd      ?
        ConfigTree      dd      ?
        HeapUsed        dd      ?
        LoadOptions     dd      ?
        OptionsLength   dd      ?
DetectionFrame          ends

;
; HardwareCursor Stack Frame Structure
;
; Stack frame definition for HardwareCursor call from OS loader
; to 16 bit routine.
;

HardwareCursorFrame     struc
        XCoord          dd      ?
        YCoord          dd      ?
HardwareCursorFrame     ends

;
; GetDateTime Stack Frame Structure
;
; Stack frame definition for GetDateTime call from OS loader
; to 16 bit routine.
;

GetDateTimeFrame        struc
        DateDword       dd      ?
        TimeDword       dd      ?
GetDateTimeFrame        ends


;
; ComPort Stack Frame Structure
;
; Stack frame definition for ComPort call from OS loader
; to 16 bit routine.
;

ComPortFrame            struc
        ComPortPort     dd      ?
        ComPortFunction dd      ?
        ComPortArg      dd      ?
ComPortFrame            ends

;
; IsMcaMachine Stack Frame Structure
;
; Stack frame definition for IsMcaMachine call from OS loader
; to 16 bit routine.
;

IsMcaMachineFrame       struc
        Dummy           dd      ?
IsMcaMachineFrame       ends

;;
;
; GetElToritoStatus Stack Frame Structure
;
; Stack frame definition for GetElToritoStatus call from OS loader
; to 16bit routines.
;
;;

GetElToritoStatusFrame     struc
        SpecPacketPointer  dd      ?
        ETDriveNum         dd      ?
GetElToritoStatusFrame     ends

;;
;
; GetExtendedInt13Params Stack Frame Structure
;
; Stack frame definition for GetExtendedInt13Params call from OS loader
; to 16bit routines.
;
;;

GetExtendedInt13ParamsFrame struc
        ParamPacketPointer dd      ?
        Int13UnitNumber    dd      ?            ; really only a byte >= 0x80
GetExtendedInt13ParamsFrame ends

;;
;
; Memory Descriptor Structure.
;
; Passed to OS loader as part of the boot context record
;
;;

MemoryDescriptor struc
        BlockBase       dd              ?
        BlockSize       dd              ?
MemoryDescriptor ends

;;
;
; File System Context Record Structure
;
;;

FsContextRecord struc
        BootDrive       db              ?
FsContextRecord ends

;;
;
; IDT Descriptor Structure
;
;;

TrapDesc        struc
        IDT_offset      dw              ?
        IDT_selector    dw              ?
        IDT_attribute   dw              ?
        IDT_reserved    dw              ?
TrapDesc        ends

;;
;
; GDT Descriptor Structure ;;
;
;;

GDTDesc         struc
        GDT_limit       dw              0
        GDT_base1       dw              0
        GDT_base2       db              0
        GDT_access      db              0
        GDT_limacc      db              0
        GDT_base3       db              0
GDTDesc         ends


;;
;
; GDT Selector Definitions
;
;;

NULL_Selector           equ     0h
KeCodeSelector          equ     8h
KeDataSelector          equ     10h
UsCodeSelector          equ     18h
UsDataSelector          equ     20h
TSS_Selector            equ     28h
PCR_Selector            equ     30h
TEP_Selector            equ     38h
BDA_Selector            equ     40h
KeLdtSelector           equ     48h
DblFltTskSelector       equ     50h
SuCodeSelector          equ     58h
SuDataSelector          equ     60h
VideoSelector           equ     68h
GDT_AliasSelector       equ     70h
DbCodeSelector          equ     78h
DbDataSelector          equ     80h
DebugUseSelector        equ    88h
ReservedSelector        equ    90h

;;
;
; Exception Frame Structure
; Note, this absolutely must match the corresponding structure
; defined in "types.h"
;
;;

ExceptionFrame struc
        Ftr     dw       0
        Fdr6    dd       0
        Fcr0    dd       0
        Fcr2    dd       0
        Fcr3    dd       0
        Fss     dw       0
        Fgs     dw       0
        Ffs     dw       0
        Fes     dw       0
        Fds     dw       0
        Fedi    dd       0
        Fesi    dd       0
        Febp    dd       0
        Fesp    dd       0
        Febx    dd       0
        Fedx    dd       0
        Fecx    dd       0
        TrapNum dd       0
        Feax    dd       0
        Error   dd       0
        Feip    dd       0
        Fcs     dd       0
        Feflags dd       0
ExceptionFrame  ends



FUNCTION_ERROR  equ     -1

;;
;
; Register Frame Structure
;
; For bios int calls
;
;;

reg_frame struc
        intnum  dw      ?
        sfg     dw      ?
        sax     dw      ?
        sbx     dw      ?
        scx     dw      ?
        sdx     dw      ?
        ssi     dw      ?
        ses     dw      ?
reg_frame ends

;;
;; Processor Flags
;;

PROT_MODE               equ     000000001       ; Enable protect mode operation
ENABLE_PAGING           equ     80000000h       ; Enable paging hardware
PD_PHYSICAL_ADDRESS     equ     99000h
TSS_SIZE                equ     80h
OVERRIDE                equ     66h

;
; Operand and Address size overrides
;

OPSIZE          macro
                db 66h
                endm
ADSIZE          macro
                db 67h
                endm


;
; External Procedures for SUDATA.ASM
;

IFDEF SU_CODEMODULE
extrn _SuMain:near
extrn _ScreenStart:near
extrn _vp:near
extrn _putx:near
extrn _TrapHandler:near
extrn _GDTregister:fword
extrn _IDTregister:fword
extrn _IDTregisterZero:fword
extrn saveDS:word
extrn SuStack:word
extrn _edata:word
extrn _FileStart:dword
ENDIF



;
; External Procedures for SUDATA.ASM
;

IFDEF SU_DATAMODULE
extrn  Trap0:far
extrn  Trap1:far
extrn  Trap2:far
extrn  Trap3:far
extrn  Trap4:far
extrn  Trap5:far
extrn  Trap6:far
extrn  Trap7:far
extrn  Trap8:far
extrn  Trap9:far
extrn  TrapA:far
extrn  TrapB:far
extrn  TrapC:far
extrn  TrapD:far
extrn  TrapE:far
extrn  TrapF:far
extrn  _edata:near
ENDIF



;
; Segment declarations for "Small Model" 16 bit Su Module.
;

_TEXT   segment para use16 public 'CODE'
_TEXT   ends

_DATA   segment para use16 public 'DATA'
_DATA   ends

CONST   segment para use16 public 'CONST'
CONST   ends

_BSS    segment para use16 public 'BSS'
_BSS    ends

DGROUP  group   const, _BSS, _DATA


;;; END OF FILE ;;;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\su.asm ===
;++
;
; Module name
;
;       su.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Jan-15-91
;
; Description
;
;       Startup module for the 386 NT OS loader.
;
; Exported Procedures
;
;       EnableProtectPaging
;
; Notes
;       NT386 Boot Loader program. This assembly file is required in
;       order to link C modules into a "/TINY"  (single segment) memory
;       model.
;
;
; This file does the following:
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 1) Defines the entry point for the boot loader's startup program
; 2) Computes what values should actually be in the DS and SS registers.
; 3) Provides the int bios functionality
; 4) Provides 386/486 mode (protect/paging) switching code.
;
; The OS/2 bootstrap routine (boot sector) loads the boot loader program at
; real-mode address 2000:0000 with the following register values:
;
;       CS = 2000
;       IP = 0000
;       DS = 07C0
;       ES = 1000
;       SS = 0000
;       SP = 7C00
;
; Build Notes:
; ~~~~~~~~~~~~
; The microsoft C compiler will not produce "tiny" model programs. In the
; tiny model, the entire program consists of only one segment. The small
; model produced by our compilers consists of two segments: DGROUP and _TEXT.
; If you convert a small model program into a tiny model program, DS (which
; should point to DGROUP (bss,const,data) will always be wrong. For this reason
; we need an assembly module to do a simple run-time fixup on SS and DS. To
; guarantee that DS will point to DGROUP no matter where os2ldr is loaded,
; the paragraph (shifted right four bits) offset of DGROUP from _TEXT must
; be added to the value in CS to compute DS and SS.
;
; We get the linker to fixup the offset of the beginning of the dgroup segment
; relative to the beginning of the code segment and it's this value added
; to the value in CS that allows us to build a "tiny" model program in C
; without a lot of munging around in order to get the data reference offsets
; in the code correct.
;
; If the _TEXT:DGROUP fixup appears in other files (which it does), the linker
; will not compute the correct value unless the accumulated data pointer is
; zero when it gets there. Therefore, no data should be placed in the data segment
; until after all instances of _TEXT:DGROUP have been encountered by the linker.
; The linker processes files from right to left on the command line.
;
; A Note About Stacks
; Initially we run on our internal stack (SuStack) which is only 160 bytes deep
; but seems to do the trick. Then we have to have a separate double fault stack.
; This stack can be in the middle of the stack/data segment. It will step on
; the loader image, but that's ok since the fault was either caused by 16bit
; code (which won't be in the loader image) or, it was caused by the 32bit
; loader (which has already been relocated) so we won't be stepping on code
; that may have caused the fault. And finally, we have the "call back" stack
; which  starts at the top of the stack/data segment. We use this during
; all call backs since the original loader source is no longer needed and
; this'll give us plenty of stack for bios calls etc.
;
;--

DoubleWord      struc
lsw     dw      ?
msw     dw      ?
DoubleWord      ends

;
; This is the structure used to pass all shared data between the boot sector
; and NTLDR.
;

SHARED  struc
        ReadClusters            dd      ?               ; function pointer
        ReadSectors             dd      ?               ; function pointer

        SectorBase              dd      ?               ; starting sector
                                                        ; for ReadSectors
                                                        ; callback
SHARED  ends


BPB     struc
        BytesPerSector          dw      ?
        SectorsPerCluster       db      ?
        ReservedSectors         dw      ?
        Fats                    db      ?
        DirectoryEntries        dw      ?
        Sectors                 dw      ?
        Media                   db      ?
        FatSectors              dw      ?
        SectorsPerTrack         dw      ?
        Heads                   dw      ?
        HiddenSectors           dd      ?
        SectorsLong             dd      ?
;
; The following byte is NOT part of the BPB but is set by SYS and format
;

        BootDriveNumber         db      ?
BPB     ends

SU_CODEMODULE    equ      1        ; Identifies this module to "su.inc"
include su.inc
include macro.inc

extrn _BootRecord:word
extrn _puts:near
extrn _MemoryDescriptorList:near
extrn _InsertDescriptor:near

MAXREAD     EQU 10000h
MAXSECTORS  EQU MAXREAD/0200h

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP
.386p

;
; Run-time fixups for stack and data segment
;

public Start
Start:
;
; The FAT boot sector only reads in the first 512 bytes of NTLDR.  This is
; the module that contains those 512 bytes, so we are now responsible for
; loading the rest of the file.  Other filesystems (i.e. HPFS, NTFS, RIPL)
; will load the whole file, so the default entrypoint branches around the
; FAT-specific code.
;
        jmp     RealStart

FatBegin:
.386
;
; If we're here, we've booted off a FAT system and we must load the rest
; of NTLDR at 2000:0200 (right behind this sector)  NTLDR passes us the
; following:
;       BX = Starting Cluster Number of NTLDR
;       DL = INT 13h drive number we've booted from
;       DS:SI -> boot media's BPB
;       DS:DI -> argument structure (see above struc definition)
;
;
; Save away the boot drive and the starting cluster number
;
        push    dx
        push    bx

;
; Blast the FAT into memory at 6000:0000 - 8000:0000
;

.386
        push    06000h
.8086
        pop     es
        xor     bx,bx                           ; (es:bx) = 6000:0000
        mov     cx,ds:[si].ReservedSectors
        mov     ds:[di].SectorBase.msw,0
        mov     ds:[di].SectorBase.lsw,cx       ; set up Sector Base

        mov     ax,ds:[si].FatSectors           ; (al) = # Sectors to read
        cmp     ax,080h
        jbe     FatLt64k

;  The FAT is > 64k, so we read the first 64k chunk, then the rest.
;  (A 16-bit FAT can't be bigger than 128k)

        push    cx
        mov     ax,080h         ; (al) = # of sectors to read
        call    ds:[di].ReadSectors
        pop     cx                      ; (cx) = previous SectorBase
.386
        push    07000h
.8086
        pop     es
        xor     bx,bx                   ; (es:bx) = 7000:0000
        mov     ax,ds:[si].FatSectors
        sub     ax,080h                 ; (ax) = # Sectors left to read
        add     cx,080h                 ; (cx) = SectorBase for next read
        mov     ds:[di].SectorBase.lsw,cx
        adc     ds:[di].SectorBase.msw,0        ; set up SectorBase

;
; (al) = # of sectors to read
;
FatLt64k:
        call    ds:[di].ReadSectors

;
; FAT is in memory, now we restore our starting cluster number
;
        pop     dx                      ; (dx) = starting cluster number
        xor     bx,bx

;
; set up FS and GS for reading the FAT
;
.386
        mov     ax,6000h
        mov     fs,ax
        mov     ax,7000h
        mov     gs,ax
.8086

;
; set up ES for reading in the rest of us
;
        push    cs
        pop     es

        mov     ah,MAXSECTORS           ; (ah) = number of sectors we can read
                                        ;        until boundary
FatLoop:
;
; (dx) = next cluster to load
;
        push    dx
        mov     al,ds:[si].SectorsPerCluster    ; (al) = number of contiguous sectors
                                                ;        found
        sub     ah,ds:[si].SectorsPerCluster                                                    ;        can read before 64k

;
; Check to see if we've reached the end of the file
;
        cmp     dx,0ffffh
        jne     Fat10

;
; The entire file has been loaded.  Throw away the saved next cluster,
; restore the boot drive, and let NTLDR do its thing.
;
        pop     dx
        pop     dx
        jmp     RealStart

Fat10:
        mov     cx,dx
;
; (dx) = (cx) = last contiguous cluster
; (al) = # of contiguous clusters found
;

        call    NextFatEntry
;
; (dx) = cluster following last contiguous cluster

;
; Check to see if the next cluster is contiguous.  If not, go load the
; contiguous block we've found.
;
        inc     cx
        cmp     dx,cx

        jne     LncLoad

;
; Check to see if we've reached the 64k boundary.  If so, go load the
; contiguous block so far.  If not, increment the number of contiguous
; sectors and loop again.
;
        cmp     ah,0
        jne     Lnc20
        mov     ah,MAXSECTORS           ; (ah) = number of sectors until
                                        ;        boundary reached again
        jmp     short LncLoad

Lnc20:
        add     al,ds:[si].SectorsPerCluster
        sub     ah,ds:[si].SectorsPerCluster
        jmp     short Fat10


LncLoad:
;
; (TOS) = first cluster to load
; (dx)  = first cluster of next group to load
; (al)  = number of contiguous sectors
;
        pop     cx
        push    dx
        mov     dx,cx
        mov     cx,10                   ; (cx) = retry count

;
; N.B.
;       This assumes that we will never have more than 255 contiguous clusters.
;       Since that would get broken up into chunks that don't cross the 64k
;       boundary, this is ok.
;
; (dx) = first cluster to load
; (al) = number of contiguous sectors
; (TOS) = first cluster of next group to load
; (es:bx) = address where clusters should be loaded
;
FatRetry:
        push    bx
        push    ax
        push    dx
        push    cx

if 0
        push    dx
        call    PrintDbg
        mov     dx,ax
        call    PrintDbg
        pop     dx
endif

        call    [di].ReadClusters
        jnc     ReadOk
;
; error in the read, reset the drive and try again
;
if 0
        mov     dx, ax
        call    PrintDbg
endif
        mov     ax,01h
        mov     al,ds:[si].BootDriveNumber
        int     13h
if 0
        mov     dx,ax
        call    PrintDbg
endif
        xor     ax,ax
        mov     al,ds:[si].BootDriveNumber
        int     13h

;
; pause for a while
;
        xor     ax,ax
FatPause:
        dec     ax
        jnz     FatPause

        pop     cx
        pop     dx
        pop     ax
        pop     bx

        dec     cx
        jnz     FatRetry

;
; we have re-tried ten times, it still doesn't work, so punt.
;
        push    cs
        pop     ds
        mov     si,offset FAT_ERROR
FatErrPrint:
        lodsb
        or      al,al
        jz      FatErrDone
        mov     ah,14           ; write teletype
        mov     bx,7            ; attribute
        int     10h             ; print it
        jmp     FatErrPrint

FatErrDone:
        jmp     $
        ; this should be replaced by a mechanism to get a pointer
        ; passed to us in the param block. since the boot sector msg itself
        ; is properly localized but this one isn't.
FAT_ERROR       db      13,10,"Disk I/O error",0dh,0ah,0


ReadOk:
        pop     cx
        pop     dx
        pop     ax
        pop     bx
        pop     dx                      ; (dx) = first cluster of next group
                                        ;        to load.

.386
;
; Convert # of sectors into # of bytes.
;
        mov     cl,al
        xor     ch,ch
        shl     cx,9
.8086
        add     bx,cx
        jz      FatLoopDone
        jmp     FatLoop

FatLoopDone:
;
; (bx) = 0
;   This means we've just ended on a 64k boundary, so we have to
;   increment ES to continue reading the file.  We are guaranteed to
;   always end on a 64k boundary and never cross it, because we
;   will reduce the number of contiguous clusters to read
;   to ensure that the last cluster read will end on the 64k boundary.
;   Since we start reading at 0, and ClusterSize will always be a power
;   of two, a cluster will never cross a 64k boundary.
;
        mov     ax,es
        add     ax,01000h
        mov     es,ax
        mov     ah,MAXSECTORS
        jmp     FatLoop

;++
;
; NextFatEntry - This procedure returns the next cluster in the FAT chain.
;                It will deal with both 12-bit and 16-bit FATs.  It assumes
;                that the entire FAT has been loaded into memory.
;
; Arguments:
;    (dx)   = current cluster number
;    (fs:0) = start of FAT in memory
;    (gs:0) = start of second 64k of FAT in memory
;
; Returns:
;    (dx)   = next cluster number in FAT chain
;    (dx)   = 0ffffh if there are no more clusters in the chain
;
;--
NextFatEntry    proc    near
        push    bx

;
; Check to see if this is a 12-bit or 16-bit FAT.  The biggest FAT we can
; have for a 12-bit FAT is 4080 clusters.  This is 6120 bytes, or just under
; 12 sectors.
;
; A 16-bit FAT that's 12 sectors long would only hold 3072 clusters.  Thus,
; we compare the number of FAT sectors to 12.  If it's greater than 12, we
; have a 16-bit FAT.  If it's less than or equal to 12, we have a 12-bit FAT.
;
        call    IsFat12
        jnc     Next16Fat

Next12Fat:
        mov     bx,dx                   ; (fs:bx) => temporary index
        shr     dx,1                    ; (dx) = offset/2
                                        ; (CY) = 1  need to shift
        pushf                           ;      = 0  don't need to shift
        add     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        popf
        jc      shift                   ; carry flag tells us whether to
        and     dx,0fffh                ; mask
        jmp     short N12Tail
shift:
.386
        shr     dx,4                    ; or shift
.8086

N12Tail:
;
; Check for end of file
;
        cmp     dx,0ff8h                ; If we're at the end of the file,
        jb      NfeDone                 ; convert to canonical EOF.
        mov     dx,0ffffh
        jmp     short NfeDone

Next16Fat:
        add     dx,dx                   ; (dx) = offset
        jc      N16high

        mov     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        jmp     short N16Tail

N16high:
        mov     bx,dx
.386
        mov     dx,gs:[bx]
.8086

N16Tail:
        cmp     dx,0fff8h
        jb      NfeDone
        mov     dx,0ffffh               ; If we're at the end of the file
                                        ; convert to canonical EOF.

NfeDone:
        pop     bx
        ret
NextFatEntry    endp

;++
;
; IsFat12 - This function determines whether the BPB describes a 12-bit
;           or 16-bit FAT.
;
; Arguments - ds:si supplies pointer to BPB
;
; Returns
;       CY set -   12-bit FAT
;       CY clear - 16-bit FAT
;
;--
IsFat12 proc    near

.386
        push    eax
        push    ebx
        push    ecx
        push    edx

        movzx   ecx, ds:[si].Sectors
        or      cx,cx
        jnz     if10
        mov     ecx, ds:[si].SectorsLong
if10:
;
; (ecx) = number of sectors
;
        movzx   ebx, byte ptr ds:[si].Fats
        movzx   eax, word ptr ds:[si].FatSectors
        mul     ebx
        sub     ecx,eax

;
; (ecx) = (#sectors)-(sectors in FATs)
;
        movzx   eax, word ptr ds:[si].DirectoryEntries
        shl     eax, 5
;
; (eax) = #bytes in root dir
;
        mov     edx,eax
        and     edx,0ffff0000h
        div     word ptr ds:[si].BytesPerSector
        sub     ecx,eax

;
; (ecx) = (#sectors) - (sectors in fat) - (sectors in root dir)
;
        movzx   eax, word ptr ds:[si].ReservedSectors
        sub     ecx, eax
        mov     eax, ecx
        movzx   ecx, byte ptr ds:[si].SectorsPerCluster
        xor     edx,edx
        div     ecx

        cmp     eax, 4087
        jae     if20
        stc
        jmp     short if30
if20:
        clc
if30:
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        ret
.8086
IsFat12 endp



PrintDbg       proc    near
        push    ax
        push    bx
        push    cx

        mov     cx,4
pd10:
.386
        rol     dx,4
.8086
        mov     ah,0eh
        mov     bx,7
        mov     al,dl
        and     al,0fh
        add     al,'0'
        cmp     al,'9'
        jbe     pd15
        add     al,'A'-('9'+1)

pd15:
        int     010h
        loop    pd10

        mov     ah,0eh
        mov     al,' '
        mov     bx,7
        int     010h
        pop     cx
        pop     bx
        pop     ax

        ret

PrintDbg      endp

Free    EQU     512-($-Start)
if Free lt 0
        %out FATAL PROBLEM: FAT-specific startup code is greater than
        %out 512 bytes.  Fix it!
        .err
endif

RealStart:
.386p
;
; Compute the paragraph needed for DS
;
if 0
        mov     ax,0
        int     16h
endif

        mov     bx,offset _TEXT:DGROUP  ; first calculate offset to data
        shr     bx,4                    ; must be para aligned

        mov     ax,cs                   ; get base of code
        add     ax,bx                   ; add paragraph offset to data

        mov     ss,ax                      ; ints disabled for next instruct
        mov     sp,offset DGROUP:SuStack   ; (sp) = top of internal stack
;
; Build C stack frame for _SuMain
;
        push    dx                      ; pass bootdisk to main (high byte is ignored)
;
; Make DS point to the paragraph address of DGROUP
;
        mov     ds,ax                   ; ds now points to beginning of DGROUP
        mov     es,ax                   ; es now points to beginning of DGROUP
;
; Compute the physical address of the end of the data segment (which
; will be the beginning of the prepended loader file).
;

        movzx    edx,ax
        shl      edx,4
        add      edx,offset DGROUP:_edata
        mov      dword ptr _FileStart,edx

;
; Force the upper parts of
; of EBP and ESP to be zero in real mode.
;

        xor      bp,bp
        movzx    ebp,bp
        movzx    esp,sp
        mov      [saveDS],ds

        call    _SuMain                 ; go to C code to do everything else.


;++
; _EnableProtectPaging
;
; Loads 386 protect mode registers.
; Enables 386 protection h/w
; Loads pagings registers
; Enables 386 paging h/w
;
;--

public _EnableProtectPaging
_EnableProtectPaging  proc near
;
; Sanitize ES and GS and clean out any junk in the upper 16bits
; of the flags that may have been left by the bios, before we go protected
;
        push     dword ptr 0
        popfd
        mov      bx,sp
        mov      dx,[bx+2]  ; are we enabling prot/paging for the first time?
        xor      ax,ax
        mov      gs,ax
        mov      es,ax


;
; FS must contain the selector of the PCR when we call the kernel
;
        push    PCR_Selector
        pop     fs
;
; Load the gdtr and idtr.
; We disable interrupts here since we can't handle interrups with the
; idt loaded while were in real mode and before we switch to protmode.

        cli
        lgdt     fword ptr [_GDTregister]
        lidt     fword ptr [_IDTregister]


;
; We have to stamp the segment portion of any real-mode far pointer with
; the corresponding selector values before we go protected.
;
        mov      si,offset _ScreenStart
        mov      word ptr [si+2],VideoSelector
        mov      si,offset _vp
        mov      word ptr [si+2],VideoSelector

;
; Enable protect and paging mode
;
        mov      eax,cr0

; If we're enabling protect mode for the first time, don't turn on paging
; because the osloader does all that.  However, if we're returning to
; protected mode, the page tables are already setup, therefore we do want
; to turn paging on.
        or      dx,dx
        jz      only_prot
        or      eax,PROT_MODE + ENABLE_PAGING
        mov     cr0,eax

;
; The following JMP must be DWORD-aligned in order to avoid an obscure i386
; hardware bug.  If not, it is possible (albeit unlikely) that the prefetch
; queue can get trashed.
;

ALIGN 4
        jmp     flush


only_prot:
        or       eax,PROT_MODE
        mov      cr0,eax
;
; Flush the prefetch queue
;

ALIGN 4
        jmp     flush
flush:


;
; Load CS with the SU module's code selector
;
        push    SuCodeSelector
        push    offset cs:restart
        retf
;
; Now load DS and SS with the SU module's protect mode data selector.
;

restart:
        mov      ax,SuDataSelector
        mov      ds,ax
        mov      ss,ax

;
; Load LDT with zero since it will never be used.
;
        xor      bx,bx
        lldt     bx

;
; Load the Task Register and return to the boot SU module.
;
        or       dx,dx
        jnz      epp10


        mov      bx,TSS_Selector
        ltr      bx


epp10:
        ret

_EnableProtectPaging endp

.286p
;** _biosint
;
;   Rom bios interrupt dispatcher
;

public _biosint
_biosint proc    near

        enter   0,0
        push    di
        push    si
        push    ds
        push    es

;       Get pointer to register parameter frame

        les     di,[bp+4]

;       Get requested interrupt number

        mov     ax,es:[di].intnum

;       Check that requested bios interrupt is supported

        sub     ax,10h          ; sub lowest int number supported
        jnc     short bios1
        mov     es:[di].intnum,FUNCTION_ERROR
        jmp     short biosx
bios1:
        shl     ax,1            ; shift if to make it a word offset
        cmp     ax,bios_cnt     ; offset beyond end of table?
        jb      short bios2

;       Error: requested interrupt not supported

        mov     es:[di].sax,FUNCTION_ERROR
        jmp     short biosx

bios2:  mov     bx,ax
        mov     ax,word ptr cs:bios_table[bx]
        push    es              ; save seg of address frame
        push    di              ; save stack register frame pointer
        push    ax              ; address of bios int

        mov     ax,es:[di].sax
        mov     bx,es:[di].sbx
        mov     cx,es:[di].scx
        mov     dx,es:[di].sdx
        mov     si,es:[di].ssi
        mov     es,es:[di].ses
        ret                     ; this sends us to the "int #" instruction

;       We return here from the jmp instruction following the int

bios_ret:

        pop     di              ; get address of register parameter frame
        pop     es              ; restore segment of parameter frame


bios5:  pushf
        pop     es:[di].sfg
        mov     es:[di].sax,ax
        mov     es:[di].sbx,bx
        mov     es:[di].scx,cx
        mov     es:[di].sdx,dx
        mov     es:[di].ssi,si
        mov     es:[di].ses,es

;       Restore original registers and return to caller

biosx:
        pop     es
        pop     ds
        pop     si
        pop     di
        leave
        ret

_biosint endp

;** Bios Interrupt Table
;


bios10: int     10h
        jmp     short bios_ret
bios11: int     11h
        jmp     short bios_ret
bios12: int     12h
        jmp     short bios_ret
bios13: int     13h
        jmp     short bios_ret
bios14: int     14h
        jmp     short bios_ret
bios15: int     15h
        jmp     short bios_ret
bios16: int     16h
        jmp     short bios_ret
bios17: int     17h
        jmp     short bios_ret
bios18: int     18h
        jmp     short bios_ret
bios19: int     19h
        jmp     short bios_ret

bios_table dw      bios10,bios11,bios12,bios13,bios14,bios15,bios16,bios17,bios18,bios19

bios_cnt        equ     $ - bios_table

.386p

;++
;
; _MoveMemory
;
; Routine Description
;
;       Moves dwords in memory from source to destination.
;
; Arguments
;
;       (TOS+4)  =  number of bytes to move
;       (TOS+8)  =  linear address of destination
;       (TOS+12) =  linear address of source
;
; Notes
;
;   1)  Valid page table entries must already exist for the
;       source and destination memory.
;
;   2)  ALL memory in the lower one megabyte is assumed to
;       be identity mapped if used.
;
; USES  ESI, EDI, ECX, FLAGS
;
;
;--


public _MoveMemory
_MoveMemory proc near

        enter    0,0
        push     ds
        push     es
;
; Get source, destination, and count arguments from the stack
; Make "count" the number of dwords to move.
;

        mov      esi,dword ptr [bp+4]
        mov      edi,dword ptr [bp+8]
        mov      ecx,dword ptr [bp+12]
        shr      ecx,2

;
; Load FLAT selectors into DS and ES
;

        mov      ax,KeDataSelector
        mov      ds,ax
        mov      es,ax

;
; Move the block of data.
;
assume es:FLAT, ds:FLAT

;
; move the dwords
;
        cld
        rep     movs    dword ptr [edi],dword ptr [esi]

;
; move the remaining tail
;
        mov     ecx, dword ptr [bp+12]
        and     ecx, 3
        rep     movs    byte ptr [edi],byte ptr [esi]


assume es:nothing, ds:DGROUP

        pop      es
        pop      ds
        leave
        ret

_MoveMemory endp



;++
;
; _ZeroMemory
;
; Routine Description
;
;       Writes zeros into memory at the target address.
;
; Arguments
;
;       (TOS+4)  =  linear address of target
;       (TOS+8)  =  number of bytes to zero
;
; Notes
;
;   1)  Valid page table entries must already exist for the
;       source and destination memory.
;
;   2)  ALL memory in the lower one megabyte is assumed to
;       be identity mapped if used.
;
; USES  ESI, EDI, ECX, FLAGS
;
;
;--

public _ZeroMemory
_ZeroMemory proc near


        enter    0,0
        push     es
;
; Get source, destination, and count arguments from the stack
; Make "count" the number of dwords to move.
;

        mov      edi,dword ptr [bp+4]
        mov      ecx,dword ptr [bp+8]
        shr      ecx,2

;
; Load FLAT selectors into DS and ES
;

        mov      ax,KeDataSelector
        mov      es,ax
        xor      eax,eax

;
; Zero the the block of data.
;
assume es:FLAT

;
; Zero the dwords
;
        cld
        rep     stos    dword ptr [edi]

;
; Zero the remaining bytes
;
        mov     ecx, dword ptr [bp+8]
        and     ecx, 3
        rep     stos    byte ptr [edi]

assume es:nothing, ds:DGROUP

        pop      es
        leave
        ret


_ZeroMemory endp




;++
;
; Turn Floppy Drive Motor Off
;
;--

public _TurnMotorOff
DriveControlRegister      equ      3f2h     ; Floppy control register

_TurnMotorOff proc near

        mov      dx,DriveControlRegister
        mov      ax,0CH
        out      dx,al
        ret

_TurnMotorOff endp


;
; Note: we do not save and restore the gdt and idt values because they
; cannot change while external services are being used by the OS loader.
; This is because they MUST remain identity mapped until all mode
; switching has ceased.
;

public _RealMode
_RealMode proc near

;
; Switch to real-mode
;

        sgdt     fword ptr [_GDTregister]
        sidt     fword ptr [_IDTregister]
        push     [saveDS]          ; push this so we can get to it later
        mov      ax,SuDataSelector
        mov      es,ax
        mov      fs,ax
        mov      gs,ax

        mov      eax,cr0
        and      eax, not (ENABLE_PAGING + PROT_MODE)
        mov      cr0,eax

;
; flush the pipeline
;
        jmp     far ptr here
here:

;
; Flush TLB
;

; HACKHACK - We don't know where the page directory is, since it was
;       allocated in the osloader.  So we don't want to clear out cr3,
;       but we DO want to flush the TLB....
;
        mov     eax,cr3

        nop                             ; Fill - Ensure 13 non-page split
        nop                             ; accesses before CR3 load
        nop                             ; (P6 errata #11 stepping B0)
        nop

        mov     cr3,eax
;
; switch to real mode addressing
;
; N. B. We need to do a far jump rather than a retf, because a retf will not
;       reset the access rights to CS properly.
;
        db      0EAh                    ; JMP FAR PTR
        dw      offset _TEXT:rmode      ; 2000:rmode
        dw      02000h
rmode:
        pop      ax
        mov      ds,ax
        mov      ss,ax
;
; Stamp video pointers for real-mode use
;
        mov     si,offset _ScreenStart
        mov     word ptr [si+2],0b800h
        mov     si,offset _vp
        mov     word ptr [si+2],0b800h
;
; re-enable interrups
;
        lidt    fword ptr [_IDTregisterZero]

;
; Re-enable interrupts
;

        sti
        ret

_RealMode endp








;** _TransferToLoader  - transfer control the the OS loader
;
;
;  Arguments:
;
;       None
;
;  Returns:
;
;       Does not return
;
;**

public _TransferToLoader
_TransferToLoader proc near

;  generates a double fault for debug purposes
;        mov      sp,0
;        push 0

        mov      ebx,dword ptr [esp+2]      ; get entrypoint arg
        xor      eax,eax
        mov      ax,[saveDS]

;
; Setup OS loader's stack. Compute FLAT model esp to id map to
; original stack.
;
        mov      cx,KeDataSelector
        mov      ss,cx
        mov      esp,LOADER_STACK  
;
; Load ds and es with kernel's data selectors
;

        mov      ds,cx
        mov      es,cx

;
; Setup pointer to file system and boot context records
;
; Make a linear pointer to the Boot Context Record

        shl      eax,4
        xor      ecx,ecx
        mov      cx,offset _BootRecord
        add      eax,ecx
        push     eax

        push     1010h       ; dummy return address.
        push     1010h       ; dummy return address.

;
; Push 48bit address of loader entry-point
;
        db OVERRIDE
        push    KeCodeSelector
        push    ebx

;
; Pass control to the OS loader
;
        db OVERRIDE
        retf

_TransferToLoader endp




;++
; Description:
;
;       Gets memory block sizes for memory from zero to one meg and
;       from one meg to 64 meg. We do this by calling int 12h
;       (get conventional memory size) and int 15h function 88h (get
;       extended memory size).
;
; Arguments:
;
;       None
;
; Returns:
;
;       USHORT - Size of usable memory (in pages)
;
;--

public _IsaConstructMemoryDescriptors
BmlTotal        equ     [bp-4]
Func88Result    equ     [bp-6]
_IsaConstructMemoryDescriptors proc near
        push    bp                     ; save ebp
        mov     bp, sp
        sub     sp, 6
;
; Initialize the MemoryList to start with a zero entry.  (end-of-list)
;
        les     si, dword ptr _MemoryDescriptorList
        xor     eax,eax
        mov     es:[si].BlockSize,eax
        mov     es:[si].BlockBase,eax

;
; Get conventional (below one meg) memory size
;
        push    es
        push    si
        int     12h
        movzx   eax,ax
;
; EAX is the number of 1k blocks, which we need to convert to the
; number of bytes.
;
        shl     eax,10

        push    eax
        shr     eax, 12
        mov     BmlTotal, eax
        xor     eax,eax
        push    eax
        call    _InsertDescriptor
        add     sp,8

;
; Get extended memory size and fill-in the second descriptor
;

        mov     ah,88h

        int     15h

        mov     Func88Result,ax
        and     eax,0ffffh
;
; EAX is the number of 1k blocks, which we need to convert to the
; number of bytes.
;
        shl     eax,10
        push    eax
        shr     eax,12
        add     BmlTotal, ax
        mov     eax,0100000h
        push    eax
        call    _InsertDescriptor
        add     sp,8

;
; Try function E801, see if that is supported on this machine
;
        mov     ax,0E801h
        int     15h
        jc      short Isa50

        cmp     ax,Func88Result     ; Is extended memory same as 88?
        je      short Isa40         ; Yes, go add the rest

        cmp     ax, (16-1) * 1024   ; Is extended memory exactly 16MB?
        jne     short Isa50         ; No, conflict between 88 & E801

Isa40:
;
; Function looks like it worked
;
; AX = extended memory < 16M in 1k blocks
; BX = extended memory > 16M in 64k blocks
;
        and     ebx,0ffffh
        jz      short Isa50

        shl     ebx,16              ; ebx = memory > 16M in bytes (via E801)
        add     ebx, 16*1024*1024   ; ebx = end of memory in bytes (via E801)

        mov     ax, Func88Result
        and     eax,0ffffh
        shl     eax, 10             ; eax = memory > 1M in bytes (via 88)
        add     eax, 1*1024*1024    ; eax = end of memory in bytes (via 88)

        sub     ebx, eax            ; ebx = memory above eax
        jbe     short Isa50         ; if ebx <= eax, done

        push    ebx
        shr     ebx,12
        add     BmlTotal, bx
        push    eax
        call    _InsertDescriptor
        add     sp,8
        and     eax,0ffffh

Isa50:
        pop     si
        pop     es
        mov     eax, BmlTotal
        mov     sp, bp
        pop     bp
        ret

_IsaConstructMemoryDescriptors endp

;++
;
; BOOLEAN
; Int15E820 (
;     E820Frame     *Frame
;     );
;
;
; Description:
;
;       Gets address range descriptor by calling int 15 function E820h.
;
; Arguments:
;
; Returns:
;
;       BOOLEAN - failed or succeed.
;
;--

cmdpFrame       equ     [bp + 6]
public _Int15E820
_Int15E820 proc near

        push    ebp
        mov     bp, sp
        mov     bp, cmdpFrame           ; (bp) = Frame
        push    es
        push    edi
        push    esi
        push    ebx

        push    ss
        pop     es

        mov     ebx, [bp].Key
        mov     ecx, [bp].DescSize
        lea     di,  [bp].BaseAddrLow
        mov     eax, 0E820h
        mov     edx, 'SMAP'             ; (edx) = signature

        INT     15h

        mov     [bp].Key, ebx           ; update callers ebx
        mov     [bp].DescSize, ecx      ; update callers size

        sbb     ecx, ecx                ; ecx = -1 if carry, else 0
        sub     eax, 'SMAP'             ; eax = 0 if signature matched
        or      ecx, eax
        mov     [bp].ErrorFlag, ecx     ; return 0 or non-zero

        pop     ebx
        pop     esi
        pop     edi
        pop     es
        pop     ebp
        ret

_Int15E820 endp

_TEXT   ends

        end      Start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\su.h ===
//
// Master include file for StartUp Module
//

#define i386
#define __stdcall
#define __cdecl
#define UNALIGNED
#pragma warning(disable:4103)
#pragma warning(disable:4341)
#include "types.h"
#include "ntmisc.h"
#include "ntconfig.h"
#include "global.h"
#include "constant.h"
#include "memmap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\types.h ===
/*

File

      types.h


Description

      defines and structure definitions for nt386 boot loader


Author

      Thomas Parslow  [TomP]

*/

#define IN
#define OUT
#define OPTIONAL
#define NOTHING
#define CONST               const

//
// Void
//

typedef void *PVOID;    // winnt

//
// Basics
//

#define VOID    void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
typedef long LONGLONG;

//
// ANSI (Multi-byte Character) types
//

typedef CHAR *PCHAR;

typedef double DOUBLE;

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt

//
// Unsigned Basics
//

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef unsigned long ULONGLONG;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef ULONG KAFFINITY;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

//
// Far point to Basic
//

typedef UCHAR far  * FPCHAR;
typedef UCHAR far  * FPUCHAR;
typedef VOID far   * FPVOID;
typedef USHORT far * FPUSHORT;
typedef ULONG far  * FPULONG;

//
// Boolean
//

typedef CCHAR BOOLEAN;
typedef BOOLEAN *PBOOLEAN;

//
// UNICODE (Wide Character) types
//

typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

//
// Large (64-bit) integer types and operations
//

typedef struct _LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))
#define toupper(x) (((x) >= 'a' && (x) <= 'z') ? x - 'a' + 'A' : x )
#define isascii(x) (((x) >= ' ' && (x) < 0x80) ? 1 : 0)

#define FLAG_CF 0x01L
#define FLAG_ZF 0x40L
#define FLAG_TF 0x100L
#define FLAG_IE 0x200L
#define FLAG_DF 0x400L

#define TRUE 1
#define FALSE 0
#define NULL   ((void *)0)

typedef UCHAR far  * FPCHAR;
typedef UCHAR far  * FPUCHAR;
typedef VOID far   * FPVOID;
typedef USHORT far * FPUSHORT;
typedef ULONG far  * FPULONG;
typedef UCHAR FAT;
typedef FAT * PFAT;
typedef LONG  NTSTATUS;


typedef struct _FSCONTEXT_RECORD {
    UCHAR BootDrive;
} FSCONTEXT_RECORD, *PFSCONTEXT_RECORD;

typedef struct {
    USHORT SpecifyBytes;
    UCHAR  WaitTime;
    UCHAR  SectorLength;
    UCHAR  LastSector;
    UCHAR  SecGapLength;
    UCHAR  DataTransfer;
    UCHAR  TrackGapLength;
    UCHAR  DataValue;
    UCHAR  HeadSettle;
    UCHAR  StartupTime;
} DISK_BASE_TABLE;

//
// biosint register structure
//

typedef struct {
   USHORT   fn;
   USHORT   fg;
   USHORT   ax;
   USHORT   bx;
   USHORT   cx;
   USHORT   dx;
   USHORT   si;
   USHORT   es;
} BIOSREGS;


//
// Trap Frame Structure when error code is present
//

typedef struct {
    USHORT Ftr;
    ULONG  Fdr6;
    ULONG  Fcr0;
    ULONG  Fcr2;
    ULONG  Fcr3;
    USHORT Fss;
    USHORT Fgs;
    USHORT Ffs;
    USHORT Fes;
    USHORT Fds;
    ULONG  Fedi;
    ULONG  Fesi;
    ULONG  Febp;
    ULONG  Fesp;
    ULONG  Febx;
    ULONG  Fedx;
    ULONG  Fecx;
    ULONG  TrapNum;
    ULONG  Feax;
    ULONG  Error;
    ULONG  Feip;
    ULONG  Fcs;
    ULONG  Feflags;

} TF_ERRCODE, *PTF ;

//
//  Task State Segment structure
//

typedef struct {
    USHORT Link;
    USHORT a;
    ULONG  Esp0;
    USHORT SS0;
    USHORT b;
    ULONG  Esp1;
    USHORT SS1;
    USHORT c;
    ULONG  Esp2;
    USHORT SS2;
    USHORT d;
    ULONG  Cr3;
    ULONG  Eip;
    ULONG  Eflags;
    ULONG  Eax;
    ULONG  Ecx;
    ULONG  Edx;
    ULONG  Ebx;
    ULONG  Esp;
    ULONG  Ebp;
    ULONG  Esi;
    ULONG  Edi;
    USHORT ES;
    USHORT e;
    USHORT CS;
    USHORT f;
    USHORT SS;
    USHORT g;
    USHORT DS;
    USHORT h;
    USHORT FS;
    USHORT i;
    USHORT GS;
    USHORT j;
    USHORT Ldt;
    USHORT k;

} TSS_FRAME, *PTSS_FRAME;


//
// Overlay structure of disk bios parameter block
//

typedef struct {
   USHORT   bps;
   UCHAR    spc;
   USHORT   sra;
   UCHAR    cof;
   USHORT   rde;
   USHORT   tns;
   UCHAR    dmd;
   USHORT   spf;
   USHORT   spt;
   USHORT   noh;
   union {
   USHORT   shs;
   ULONG    bhs;   // hidden sectors
   } hs;
   ULONG    bts;  // extended total sectors
} DISKBPB;

typedef DISKBPB far * FPDISKBPB;



//
// FAT directory structure
//

typedef struct {
   CHAR     fname[11];
   UCHAR    attrb;
   UCHAR    rsrv[10];
   USHORT   time;
   USHORT   date;
   USHORT   clust;
   ULONG    size;

} DIRENTRY,*PDIRENTRY,far * FPDIRENTRY;

typedef struct {
   CHAR  fname[11];
   UCHAR attrb;
   UCHAR rsrv[10];
   USHORT time;
   USHORT date;
   USHORT starting_cluster;
   ULONG file_size;
   ULONG fptr;
   PUCHAR clusterbuffer;
   USHORT cur_phys_cluster;
   USHORT cur_file_cluster;
} FILEDESCRIPTOR,* FILEHANDLE;

/*
typedef struct {

   USHORT bff[FAT_BUFFERS];
   USHORT usebuf;
   FAT *  fcptr;

} FATCACHE;
*/

typedef struct {
   USHORT   limit;
   USHORT   base1;
   UCHAR     base2;
   UCHAR     access;
   UCHAR     limacc;
   UCHAR     base3;
} _GDT,far *FPGDT;


typedef  ULONG  IDT,*PIDT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\br\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"O Windows NT encontrou apenas %dKB de memria convencional. So necessrios\n"  \
"512KB de memria convencional para executar o Windows NT. Voc talvez tenha\n"  \
"que atualizar seu computador ou executar o programa de configurao\n"          \
"fornecido pelo fabricante.\n"

#define SU_NO_EXTENDED_MEMORY \
"O Windows NT no encontrou memria estendida suficiente. So necessrios\n"     \
"7MB de memria estendida para executar o Windows NT. Voc talvez tenha\n"       \
"que atualizar seu computador ou executar o programa de configurao\n"          \
"fornecido pelo fabricante.\n"                                                   \
"\n\nMapa da memria:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR est corrompido. O sistema no pode ser reiniciado."


#define PG_FAULT_MSG    " ======================== ERRO DE PGINA ======================== \n\n"
#define DBL_FAULT_MSG   " ========================= FALHA DUPLA ========================== \n\n"
#define GP_FAULT_MSG    " ==================== FALHA DE PROTEO GERAL =================== \n\n"
#define STK_OVERRUN_MSG " === SEGMENTO DA PILHA AUSENTE OU FALHA DE SATURAO DO MESMO === \n\n"
#define EX_FAULT_MSG    " =========================== EXCEO ============================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** No endereo linear %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\trapdump.c ===
/*++

Copyright (c) 1990  Microsoft Corporation


Module Name:

    trap.c

Author:

    Thomas Parslow   [TomP]  Mar-01-90


Abstract:

    General purpose trap handler for 80386 boot loader. When built in
    debugger is present, output is redirected to the com port. When no
    debugger is present, output goes to the display.


--*/

#include "su.h"

extern
USHORT
InDebugger;

extern
UCHAR
GDTregister;

extern
UCHAR
IDTregister;

extern
VOID
OutPort(
    USHORT
    );

extern
USHORT
InPort(
    VOID
    );

extern
VOID
ReEnterDebugger(
    VOID
    );

extern
USHORT
TssKernel;

extern
USHORT
Redirect;

extern
VOID RealMode(
    VOID
    );

VOID
TrapHandler(
    IN ULONG,
    IN USHORT
    );

VOID
DumpProcessorContext(
    VOID
    );

VOID
DumpSystemRegisters(
    VOID
    );

VOID
DumpCommonRegisters(
    VOID
    );

VOID
DisplayFlags(
    ULONG f
    );


VOID
DumpTSS(
    VOID
    );


ULONG
GetAddress(
    VOID
    );

VOID
GetNumber(
    PCHAR cp
    );

USHORT
GetChar(
    VOID
    );

VOID
DumpAddress(
    ULONG
    );

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== GENERAL PROTECTION FAULT ======================== \n\n"
#define STK_OVERRUN_MSG " ===== STACK SEGMENT OVERRUN or NOT PRESENT FAULT =============== \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define ishex(x)  ( ( x >= '0' && x <= '9') || (x >= 'A' && x <= 'F') || (x >= 'a' && x <= 'f') )


//
// Global Trap Frame Pointer
//

PTF TrapFrame=0;


VOID
TrapHandler(
    IN ULONG Padding,
    IN USHORT TF_base
    )
/*++

Routine Description:

    Prints minimal trap information

Arguments:


    386 Trap Frame on Stack

Environment:

    16-bit protect mode only.


--*/

{
    //
    // Initialize global trap frame pointer and print trap number
    //

    TrapFrame = (PTF)&TF_base;

    //
    // Fix esp to point to where it pointed before trap
    //

    TrapFrame->Fesp += 24;

    BlPrint("\n TRAP %lx ",TrapFrame->TrapNum);

    //
    // Print the trap specific header and display processor context
    //

    switch(TrapFrame->TrapNum) {

        case 1:
        case 3:
            puts( DEBUG_EXCEPTION );
            DumpCommonRegisters();
            break;

        case 8:
            puts( DBL_FAULT_MSG );
            DumpTSS();
            break;

        case 12:
            puts( STK_OVERRUN_MSG );
            DumpProcessorContext();
            break;

        case 13:
            puts( GP_FAULT_MSG );
            DumpProcessorContext();
            break;

        case 14:
            puts( PG_FAULT_MSG );
            BlPrint("** At linear address %lx\n",TrapFrame->Fcr2);
            DumpProcessorContext();
            break;

        default :
            puts( EX_FAULT_MSG );
            DumpProcessorContext();
            break;
    }

    RealMode();
    while (1); //**** WAITFOREVER *** //


}


VOID
DumpProcessorContext(
    VOID
    )
/*++

Routine Description:

    Dumps all the processors registers. Called whenever a trap or fault
    occurs.

Arguments:

    None

Returns:

    Nothing

--*/
{
    DumpSystemRegisters();
    DumpCommonRegisters();
}

VOID
DumpSystemRegisters(
    VOID
    )
/*++

Routine Description:

    Dumps (writes to the display or com poirt) the x86 processor control
    registers only. Does not dump the common registers (see
    DumpCommonRegisters)

Arguments:

    None

Returns:

    Nothing


--*/
{
    BlPrint("\n tr=%x  cr0=%lx  cr2=%lx  cr3=%lx\n",
            TrapFrame->Ftr,TrapFrame->Fcr0,TrapFrame->Fcr2,TrapFrame->Fcr3);
    BlPrint(" gdt limit=%x  base=%lx    idt limit=%x  base=%lx\n",
          *(PUSHORT)&GDTregister,*(PULONG)(&GDTregister + 2),
          *(PUSHORT)&IDTregister,*(PULONG)(&IDTregister + 2));
}



VOID
DumpCommonRegisters(
    VOID
    )
/*++

Routine Description:

    Dumps (writes to the display or com poirt) the x86 processor
    commond registers only.

Arguments:

    None

Returns:

    Nothing


--*/
{
    USHORT err;

    //
    // Is the error code valid or just a padding dword
    //

    if ((TrapFrame->TrapNum == 8) || (TrapFrame->TrapNum >= 10 && TrapFrame->TrapNum <= 14) )
        err = (USHORT)TrapFrame->Error;
    else
        err = 0;

    //
    // Display the processor's common registers
    //

    BlPrint("\n cs:eip=%x:%lx  ss:esp=%x:%lx  errcode=%x\n",
        (USHORT)(TrapFrame->Fcs & 0xffff),TrapFrame->Feip,(USHORT)TrapFrame->Fss,TrapFrame->Fesp,err);
    DisplayFlags(TrapFrame->Feflags);
    BlPrint(" eax=%lx  ebx=%lx  ecx=%lx  edx=%lx",TrapFrame->Feax,TrapFrame->Febx,TrapFrame->Fecx,TrapFrame->Fedx);
    BlPrint(" ds=%x  es=%x\n",TrapFrame->Fds,TrapFrame->Fes);
    BlPrint(" edi=%lx  esi=%lx  ebp=%lx  cr0=%lx",TrapFrame->Fedi,TrapFrame->Fesi,TrapFrame->Febp,TrapFrame->Fcr0);
    BlPrint(" fs=%x  gs=%x\n",TrapFrame->Ffs,TrapFrame->Fgs);

}


VOID
DisplayFlags(
    ULONG f
    )
/*++

Routine Description:

    Writes the value of the key flags in the flags register to
    the display or com port.

Arguments:

    f - the 32bit flags word

Returns:

    Nothing

--*/
{

    BlPrint(" flags=%lx  ",f);
    if (f & FLAG_CF) puts("Cy "); else puts("NoCy ");
    if (f & FLAG_ZF) puts("Zr "); else puts("NoZr ");
    if (f & FLAG_IE) puts("IntEn"); else puts("IntDis ");
    if (f & FLAG_DF) puts("Up "); else puts("Down ");
    if (f & FLAG_TF) puts("TrapEn \n"); else puts("TrapDis \n");

}



VOID
DumpTSS(
    VOID
    )
/*++

Routine Description:

    Writes the contents of the TSS to the display or com port when
    called after a double fault.

Arguments:

    None

Returns:

    Nothing

--*/
{

    PTSS_FRAME pTss;

//  FP_SEG(Fp) = Fcs;
//  FP_OFF(Fp) = Fip;

    pTss = (PTSS_FRAME) &TssKernel;

    //
    //  Dump the outgoing TSS
    //

    BlPrint("Link %x\n",pTss->Link);
    BlPrint("Esp0 %x\n",pTss->Esp0);
    BlPrint("SS0  %x\n",pTss->SS0);
    BlPrint("Esp1 %lx\n",pTss->Esp1);
    BlPrint("Cr3  %lx\n",pTss->Cr3);
    BlPrint("Eip  %lx\n",pTss->Eip);
    BlPrint("Eflg %lx\n",pTss->Eflags);
    BlPrint("Eax  %lx\n",pTss->Eax);
    BlPrint("Ebx  %lx\n",pTss->Ebx);
    BlPrint("Ecx  %lx\n",pTss->Ecx);
    BlPrint("Edx  %lx\n",pTss->Edx);
    BlPrint("Esp  %lx\n",pTss->Esp);
    BlPrint("Ebp  %lx\n",pTss->Ebp);
    BlPrint("Esi  %lx\n",pTss->Esi);
    BlPrint("Edi  %lx\n",pTss->Edi);
    BlPrint("ES   %x\n",pTss->ES);
    BlPrint("CS   %x\n",pTss->CS);
    BlPrint("SS   %x\n",pTss->SS);
    BlPrint("DS   %x\n",pTss->DS);
    BlPrint("FS   %x\n",pTss->FS);
    BlPrint("GS   %x\n",pTss->GS);
    BlPrint("Ldt  %x\n",pTss->Ldt);
    RealMode();
    while(1);
}

// END OF FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\sudata.asm ===
;++
;
; Module name
;
;       su.asm
;
; Author
;
;       Thomas Parslow  (tomp)  Mar-1-90
;
; Description
;
;       Static data for Startup module for the 386 NT OS loader. The gdt
;       idt, and double fault tss are statically defined here. Also most
;       of the zero init static data is defined here because the SU module
;       must have a zero length .bss section.
;
;
;--

.386p

SU_DATAMODULE       equ      1


include su.inc
include memmap.inc



_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

;
; Global Descriptor Table
;
; Note, the SuCode and SuData segments must have limits of 64k in
; order for the mode switch code to work.
;

public _Beginx86Relocation
public _GDT

_Beginx86Relocation       equ      $
_GDT  equ $
;;;
;;;   Lim 0-15,  Base0-15,Base 16-23, LimAcc,
;;;

;
; Selector 00h - Null selector - unsused
;

GDTDesc <00000h, 00000h, 000h, 000h, 000h, 000h>

;
; Selector 08h  KeCodeSelector  - kernel code segment : FLAT 4gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 09ah, 0cfh, 000h>

;
; Selector 10h - KeDataSelector - kernel data segment : FLAT 4gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 092h, 0cfh, 000h>

;
; Selector 18h - UsCodeSelector - User code segment : FLAT 2gig limit
;

GDTDesc <0ffffh, 00000h, 000h, 0fah, 0cfh, 000h>

;
; Selector 20h - UsDataSelector - User data segment : FLAT 2gig limit
;
GDTDesc <0ffffh, 00000h, 000h, 0f2h, 0cfh, 000h>

;
; Selector 28h - TSS_Selector - Kernels TSS
;

GDTDesc <EndTssKernel - _TssKernel - 1, offset _TEXT:_TssKernel, \
002h, 089h, 000h, 000h> ; TSS

;
; Selector 30h - PCR_Selector - Master Boot Processor's PCR segment
;       This is actually edited later in BlSetupForNt in order to
;       point to a page located at a high virtual address.
;

GDTDesc <01h, 00000h, 000h, 092h, 0c0h, 000h>

;
; Selector 38h - TEP_Selector - Thread Environment
;

GDTDesc <0fffh, 00000h, 000h, 0f3h, 040h, 000h>

;
; Selector 40 - BDA_SAelector - Bios Data Area near-clone
;

GDTDesc <0ffffh, 00400h, 000h, 0f2h, 000h, 000h>

;
; Selector 48h - LdtDescriptor - used to load an ldt
;       (Gets set at Ldt set and process switch by the kernel)
;

GDTDesc <00000h, 00000h, 000h, 000h, 000h, 000h>

;
; Selector 50h - DblFltTskSelector - Double Fault TSS
;

GDTDesc <EndTssDblFault32 - _TssDblFault32 - 1, offset _TEXT:_TssDblFault32,  \
002h, 089h, 000h, 000h> ;

;
; Selector 58h - SuCodeSelector - Startup module's code segment
;

GDTDesc <0ffffh, 00000h, 002h, 09ah, 000h, 000h>

;
; Selector 60h - SuDataSelector - Startup module's data segment
;

GDTDesc <0ffffh, offset _TEXT:DGROUP, 002h, 092h, 000h, 000h>

;
; Selector 68h - VideoSelector - Video display buffer
;

GDTDesc <03fffh, 08000h, 00bh, 092h, 000h, 000h>

;
; Selector 70h - GDT_AliasSelector - GDT Alias Selector
;

GDTDesc <EndGDT - _GDT - 1, 7000h, 0ffh, 092h, 000h,0ffh>


; Debug selectors : CURRENTLY NOT USED

GDTDesc <0ffffh, 00000h, 040h, 09ah, 000h, 080h>  ; 70 Debug Code
GDTDesc <0ffffh, 00000h, 040h, 092h, 000h, 080h>  ; 78 Debug Data
GDTDesc <00000h, 00000h, 000h, 092h, 000h, 000h>  ; 80 Debug Use
GDTDesc <00000h, 00000h, 000h, 000h, 000h, 000h>  ; 88 Spare
DEFINED_GDT_ENTRIES     equ     ($ - _GDT) / size GDTDesc
                 dq ((1024 / size GDTDesc) - DEFINED_GDT_ENTRIES) DUP(0)
EndGDT  equ      $
GDT_SIZE         equ      (EndGDT - _GDT)


;;
;; Interrupt Descriptor Table
;;


public _IDT
align   16
_IDT    equ      $
TrapDesc         <offset Trap0,  KeCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap1,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap2,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap3,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap4,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap5,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap6,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap7,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset Trap8,  SuCodeSelector, 8f00h,  0>
;TrapDesc         <offset Trap8,  DblFltTskSelector,8500h,  0>
TrapDesc         <offset Trap9,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapA,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapB,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapC,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapD,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapE,  SuCodeSelector, 8f00h,  0>
TrapDesc         <offset TrapF,  SuCodeSelector, 8f00h,  0>
DEFINED_IDT_ENTRIES     equ     ($ - _IDT) / size TrapDesc
                 dq (IDT_ENTRIES - DEFINED_IDT_ENTRIES) DUP(0)



EndIDT                    equ   $
public _Endx86Relocation
_Endx86Relocation         equ      $

;
; disk-base table.  We copy it from the ROM to here so we can patch the
; last sector number.  This lets us access both 5.25" and 3.5" drives.
;
Public _DiskBaseTable
_DiskBaseTable  equ     $
    SpecifyBytes dw 0
    WaitTime     db 0
    SectorLength db 0
    LastSector   db 0
    SecGapLength db 0
    DataTransfer db 0
    TrackGapLength db 0
    DataValue    db 0
    HeadSettle   db 0
    StartupTime  db 0

Public _RomDiskBasePointer
_RomDiskBasePointer dd 0

;
; Enhanced Disk Drive Spec. Disk Address Packet
;
Public _EddsAddressPacket
_EddsAddressPacket  equ     $
    PacketSize   db  10h
    Reserved1    db  0
    Blocks2Xfer  dw  0
    XferBuf      dd  0
    LBALow       dd  0
    LBAHigh      dd  0

;
; Task State Segment for Double Fault Handler
;
Public _TssDblFault
align 16
_TssDblFault     equ      $
        dw       0 ;link
        dw       offset _DATA:DblFaultStack
        dw       SuDataSelector
        dd       0 ; ring1 ss:sp
        dd       0 ; ring2 ss:sp
        dw       offset _TEXT:Trap8
        dw       0 ; flags
        dw       0 ; ax
        dw       0 ; cx
        dw       0 ; dx
        dw       0 ; bx
        dw       offset _DATA:DblFaultStack ; sp
        dw       0 ; bp
        dw       0 ; si
        dw       0 ; di
        dw       SuDataSelector  ; es
        dw       SuCodeSelector  ; cs
        dw       SuDataSelector  ; ss
        dw       SuDataSelector  ; ds
        dw       0 ; ldt selector
        dw       0
EndTssDblFault   equ      $


_TssDblFault32   equ      $
        dd       0 ;link
        dd       offset _DATA:DblFaultStack
        dd       SuDataSelector
        dd       0 ; ring1 esp
        dd       0 ; ring1 ss
        dd       0 ; ring2 esp
        dd       0 ; ring2 ss
        dd       PD_PHYSICAL_ADDRESS
        dd       offset _TEXT:Trap8
        dd       0 ; eflags
        dd       0 ; eax
        dd       0 ; ecx
        dd       0 ; edx
        dd       0 ; ebx
        dd       offset _DATA:DblFaultStack ; sp
        dd       0 ; bp
        dd       0 ; si
        dd       0 ; di
        dd       SuDataSelector  ; es
        dd       SuCodeSelector  ; cs
        dd       SuDataSelector  ; ss
        dd       SuDataSelector  ; ds
        dd       0 ;fs
        dd       0 ;gs
        dd       0 ; ldt selector
        dd       0 ; i/o map
        dd       0 ;
        dd       0 ;
EndTssDblFault32   equ      $



;
; Stack for Double Fault Handler Task
;

public _FileStart
_FileStart       dd       0

align 4
public DblFaultStack
                 dw       50 DUP(0)
DblFaultStack    equ      $

;
; Note that we need at least 2k of real-mode stack because some EISA BIOS
; routines require it.
;
align 4
public SuStack
public _SuStackBegin
_SuStackBegin    equ      $
                 db       2048 DUP (0)
SuStack          equ      $

align 16
public _TssKernel
_TssKernel       dw       60  DUP(0)
EndTssKernel     equ      $

align 4
public _GDTregister
_GDTregister     dw       EndGDT - _GDT - 1
                 dw       (SYSTEM_PAGE_PA and 0ffffh) + offset DGROUP:_GDT
                 dw       (SYSTEM_PAGE_PA SHR 16) and 0ffh

align 4
public _IDTregister
_IDTregister     dw       EndIDT - _IDT - 1
                 dw       (SYSTEM_PAGE_PA and 0ffffh) + offset DGROUP:_IDT
                 dw       (SYSTEM_PAGE_PA SHR 16) and 0ffh

;
; We load the idtr from the this fword .
;
public _IDTregisterZero
_IDTregisterZero dw       0ffffh
                 dd       0

;
; We save the base of the real mode data segment here so we
; can use it later in calculations of the linear address of
; the start of DGROUP.
;
public saveDS
saveDS           dw       0
;
; When ever we enter the debugger we set this variable to
; on so we can tell if we've faulted in the debugger when
; we get an exception.
;
public _InDebugger
_InDebugger      dw       0

; We save SP here when we get an exception in the debugging
; version of the SU module. If we get an exception in the
; debugger, we use this value to reset the stack to point to
; the base of the original exception/break-point stack frame.
;
public SaveSP
SaveSP           dw       0

;
; BOOT CONTEXT RECORD
;

;
; Export Entry Table
;

extrn RebootProcessor:near
extrn GetSector:near
extrn GetEddsSector:near
extrn GetKey:near
extrn GetCounter:near
extrn Reboot:near
extrn DetectHardware:near
extrn HardwareCursor:near
extrn GetDateTime:near
extrn ComPort:near
extrn GetStallCount:near
extrn InitializeDisplayForNt:near
extrn GetMemoryDescriptor:near
extrn GetElToritoStatus:near
extrn GetExtendedInt13Params:near
extrn ApmAttemptReconnect:near

SU_LOAD_ADDRESS equ 20000h



; FsContext
;
;
public _FsContext
align 4
_FsContext FsContextRecord      <0>

;
; Memory Descriptor Table
;       The Memory Descriptor Table begins at 7000:0000 and grows upward.
;       Note that this is 64k above the start of the OS Loader Heap and
;       64k below the start of the OS Loader Stack.  This is ok, since the
;       x86 Arc Emulation will have converted all of this information into
;       Arc Memory Descriptors before the OS Loader is initialized.
;

align 4
public _MemoryDescriptorList
_MemoryDescriptorList  dw       0
                       dw       7000h

;
; This is called the External Services Table by the OS loader
;

;**
;   NOTE WELL
;       The offsets of entries in this table must match its twin
;       in startup\i386\sudata.asm, and the structure in boot\inc\bldrx86.h
;**
align 4
public _ExportEntryTable
_ExportEntryTable equ     $
                 dw       offset _TEXT:RebootProcessor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetSector
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetKey
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetCounter
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:Reboot
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:DetectHardware
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:HardwareCursor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetDateTime
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:ComPort
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetStallCount
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:InitializeDisplayForNt
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetMemoryDescriptor
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetEddsSector
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetElToritoStatus
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       offset _TEXT:GetExtendedInt13Params
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       0                             ; fake entry for
                 dw       0                             ; NetPcRomServices
                 dw       offset _TEXT:ApmAttemptReconnect
                 dw       SU_LOAD_ADDRESS SHR 16
                 dw       0                             ; fake entry for
                 dw       0                             ; BiosRedirectService
                 dd       0
;**
; See note above
;**

align 4
Public _BootRecord
_BootRecord      dw       offset _TEXT:_FsContext
                 dw       SU_LOAD_ADDRESS SHR 16

                 dw       offset _TEXT:_ExportEntryTable
                 dw       SU_LOAD_ADDRESS SHR 16

;
; The memory descriptor table begins at 0x70000
;
                 dw       0
                 dw       7

public _MachineType
_MachineType     dd       0             ; Machine type infor.

;
; pointer to where osloader.exe is in memory
;
public _OsLoaderStart
_OsLoaderStart          dd      0
public _OsLoaderEnd
_OsLoaderEnd            dd      0
public _ResourceDirectory
_ResourceDirectory      dd      0
public _ResourceOffset
_ResourceOffset         dd      0
public _OsLoaderBase
_OsLoaderBase           dd      0
public _OsLoaderExports
_OsLoaderExports        dd      0
public _BootFlags
_BootFlags              dd      0
public _NtDetectStart
_NtDetectStart          dd      0
public _NtDetectEnd
_NtDetectEnd            dd      0


;
; Defines the machine variables, we can use them to check the validity of
; loaded Ram Extension later.
;

                public  MachineModel, MachineSubmodel, BiosRevision
MachineModel            db      0
MachineSubmodel         db      0
BiosRevision            db      0


;
; keeps track of 8042 access failing so we can avoid doing it repeatedly
;
public _Empty_8042Failed
_Empty_8042Failed       db      0

_DATA   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\fi\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT lysi vain %d kt alamuistia. Windows NT:n kynnistmiseen\n"  \
"tarvitaan vhintn 512 kt alamuistia. Saatat joutua pivittmn\n"  \
"tietokoneesi tai suorittamaan valmistajan toimittaman kokoonpanon\n"\
"mritysohjelman.\n"

#define SU_NO_EXTENDED_MEMORY \
"Windows NT ei havainnut tarpeeksi laajennettua muistia. Windows NT:n\n"  \
"kyttmiseen tarvitaan vhintn 7 Mt laajennettua muistia. Saatat\n"  \
"joutua pivittmn tietokoneesi tai suorittamaan valmistajan\n"\
"toimittaman kokoonpanon mritysohjelman.\n"\
"\n\nMuistikartta:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR on vioittunut. Jrjestelm ei voi kynnist."

#define PG_FAULT_MSG    " =================== SIVUVIRHE ================================== \n\n"
#define DBL_FAULT_MSG   " ================== KAKSOISVIRHE ================================ \n\n"
#define GP_FAULT_MSG    " ============== YLEINEN SUOJAUSVIRHE ============================ \n\n"
#define STK_OVERRUN_MSG " ===== PINOSEGMENTIN YLIAJO TAI EI PAIKALLA -VIRHE ============== \n\n"
#define EX_FAULT_MSG    " ==================== POIKKEUS ================================== \n\n"
#define DEBUG_EXCEPTION "\nDEBUG-POIKKEUS "
#define PG_FAULT_ADDRESS "** Lineaarisessa osoitteessa %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\es\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT ha encontrado slo %dKB de memoria baja. Se requieren 512 KB\n"  \
"de memoria baja para ejecutar Windows NT. Puede ser necesario actualizar \n"      \
"el equipo o ejecutar un programa de configuracin suministrado\n"   \
"por el fabricante."

#define SU_NO_EXTENDED_MEMORY \
"Windows NT no ha encontrado suficiente memoria extendida. Se requieren 7 MB \n"       \
"de memoria extendida para ejecutar Windows NT. Puede ser necesario \n"     \
"actualizar el equipo o ejecutar un programa de configuracin \n"   \
"suministrado por el fabricante de hardware. \n"   \
"\n\nMapa de memoria:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR est daado.  No se puede iniciar el sistema."

#define PG_FAULT_MSG    " =================== ERROR DE PGINA ======================= \n\n"
#define DBL_FAULT_MSG   " ================== ERROR DOBLE ================================ \n\n"
#define GP_FAULT_MSG    " ============== ERROR DE PROTECCIN GENERAL=================== \n\n"
#define STK_OVERRUN_MSG " ===== DESBORDAMIENTO DEL SEGMENTO DE PILA O ERROR DE AUSENCIA == \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPCIN ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** En direccin lineal %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\el\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
" Windows NT 槠 椦 %dK  㣞 low.  512k  㣞 low\n"  \
"礫   ⢜  Windows NT.   ᝜ \n"       \
"婜      ⢜ ⤘ 暨 矣\n" \
"⫨   柞   \n"

#define SU_NO_EXTENDED_MEMORY \
" Windows NT  槠  㣞 extended.  7Mb  㣞 extended\n"       \
"礫   ⢜  Windows NT.   ᝜  \n"                \
"婜      ⢜ ⤘ 暨 矣\n"           \
"⫨   柞   \n"                                   \
"\n\n椠 㣞:\n"

#define SU_NTLDR_CORRUPT \
" NTLDR 夘 ⤦.   穫    㩜."

#define PG_FAULT_MSG    " ===================   ============================= \n\n"
#define DBL_FAULT_MSG   " ====================   ============================== \n\n"
#define GP_FAULT_MSG    " ==============    ======================== \n\n"
#define STK_OVERRUN_MSG " =====       =========== \n\n"
#define EX_FAULT_MSG    " =====================  ================================= \n\n"
#define DEBUG_EXCEPTION "\N      "
#define PG_FAULT_ADDRESS "**   矬 %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\da\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT har kun registreret %dK konventionel hukommelse. Der krves mindst\n"  \
"512k for at kre Windows NT. Det kan vre ndvendigt at opgradere\n"      \
"din computer eller kre et konfigurationsprogram fra producenten.\n"

#define SU_NO_EXTENDED_MEMORY \
"Windows NT har ikke fundet nok udvidet hukommelse (XMS). Der krves\n"       \
"mindst 7Mb for at kre Windows NT. Det kan vre ndvendigt at opgradere\n"     \
"din computer eller kre et konfigurationsprogram fra producenten.\n"   \
"\n\nHukommelse:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR er beskadiget. Systemet kan ikke starte."

#define PG_FAULT_MSG    " =================== SIDEFEJL ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOBBELTFEJL ================================ \n\n"
#define GP_FAULT_MSG    " ============== ALMEN BESKYTTELSESFEJL (GPF) ======================== \n\n"
#define STK_OVERRUN_MSG " ===== STAK SEGMENT-OVERLB ELLER IKKE TILGNGELIG-FEJL =============== \n\n"
#define EX_FAULT_MSG    " ===================== UNDTAGELSE ================================ \n\n"
#define DEBUG_EXCEPTION "\nFEJLSGNINGS-TRAP "
#define PG_FAULT_ADDRESS "** P liner adresse %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\cs\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Systm Windows NT nael pouze %d kB doln pamti. Ke sputn systmu\n"   \
"je poteba 512 kB i vce doln pamti. Asi budete muset inovovat dan\n"  \
"pota, nebo spustit konfiguran program, kter byl dodn vrobcem.\n"

#define SU_NO_EXTENDED_MEMORY \
"Systm Windows NT nenael dost rozen pamti. Systm Windows NT\n"     \
"potebuje ke sputn 7 MB rozen pamti. Asi budete muset inovovat\n"  \
"pota, nebo spustit konfiguran program, kter byl dodn vrobcem.\n"   \
"\n\nMapa pamti:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR je pokozen. Systm nelze nastartovat."

#define PG_FAULT_MSG    " ================== CHYBA STRNKY =============================== \n\n"
#define DBL_FAULT_MSG   " ==================== DVOJCHYBA ================================= \n\n"
#define GP_FAULT_MSG    " ============== VEOBECN CHYBA OCHRANY ========================= \n\n"
#define STK_OVERRUN_MSG " ====== CHYBA: SEGMENT ZSOBNKU PEKRYT i CHYB =============== \n\n"
#define EX_FAULT_MSG    " ====================== VYJMKA ================================= \n\n"
#define DEBUG_EXCEPTION  "\nPAST DEBUG "
#define PG_FAULT_ADDRESS "** Na linern adrese %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\ger\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT hat nur %d KB konventionellen Speicherplatz gefunden. \n"  \
"Zur Ausfhrung von Windows NT werden 512 KB konventioneller \n"       \
"Speicherplatz bentigt. Sie mssen evtl. Ihren Computer aufrsten \n" \
"oder ein Konfigurationsprogramm des Herstellers ausfhren.\n"


#define SU_NO_EXTENDED_MEMORY \
"Windows NT hat nicht gengend Erweiterungsspeicher gefunden. Zur\n"  \
"Ausfhrung von Windows NT werden 7 MB Erweiterungsspeicher \n"       \
"bentigt. Sie mssen evtl. Ihren Computer aufrsten oder ein \n"     \
"Konfigurationsprogramm des Herstellers ausfhren.\n"                 \
"\n\nSpeichertabelle:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR ist beschdigt. Das System kann nicht gestartet werden."


#define PG_FAULT_MSG    " ================== SEITENFEHLER ================================ \n\n"
#define DBL_FAULT_MSG   " ================ DOPPELTER FEHLER ============================== \n\n"
#define GP_FAULT_MSG    " =========== ALLGEMEINE SCHUTZVERLETZUNG ======================== \n\n"
#define STK_OVERRUN_MSG " = STAPELSPEICHER-SEGMENTBERLAUF oder NICHT VORHANDENER FEHLER = \n\n"
#define EX_FAULT_MSG    " ====================== AUSNAHME ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** Bei linearer Adresse %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\fr\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT a trouv seulement %d Ko de mmoire basse. 512 Ko\n"     \
"de mmoire basse sont requis pour excuter Windows NT. La mise \n"   \
"niveau de votre ordinateur ou l'excution d'un programme de configuration\n"   \
"fourni par votre fabriquant est peut-tre ncessaire.\n"      

#define SU_NO_EXTENDED_MEMORY \
"Windows NT n'a pas trouv suffisamment de mmoire tendue. 7 Mo\n"     \
"de mmoire tendue sont requis pour excuter Windows NT. La mise \n"   \
"niveau de votre ordinateur ou l'excution d'un programme de configuration\n"   \
"fourni par votre fabriquant est peut-tre ncessaire.\n"  \
"\n\nCarte de la mmoire :\n"

#define SU_NTLDR_CORRUPT \
"NTLDR est endommag. Le systme ne peut pas dmarrer."

#define PG_FAULT_MSG    " ================= PANNE DE PAGE ================================ \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE PANNE ================================ \n\n"
#define GP_FAULT_MSG    " =========== PANNE DE PROTECTION GENERALE ======================= \n\n"
#define STK_OVERRUN_MSG " === SEGMENT STACK SUREXECUTE ou PANNE NON PRESENTE ============= \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBOGUER LES PAQUETS "
#define PG_FAULT_ADDRESS "** A l'adresse linaire %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\hu\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"A Windows 2000  %dK hagyomnyos memrit tallt. A Windows 2000  futtatshoz\n"  \
"legalbb 512k hagyomnyos memrira van szksg. Ellenrizze a szmtgp \n"  \
"hardver konfigurcijt, s szksg esetn szerezzen be tovbbi memrit.\n"

#define SU_NO_EXTENDED_MEMORY \
"A Windows 2000 nem tallt elegend kiterjesztett memrit. A Windows 2000\n"   \
"futtatshoz legalbb 7 megabjt kiterjesztett memrira van szksg. \n"   \
"Ellenrizze a szmtgp konfigurcijt, s szksg esetn szerezzen be\n" \
"tovbbi memrit.\n" \
"\n\nMemriatrkp:\n"

#define SU_NTLDR_CORRUPT \
"Az NTLDR hibs vagy srlt. A rendszer nem indthat."

#define PG_FAULT_MSG    " ======================= LAPHIBA ============================== \n\n"
#define DBL_FAULT_MSG   " =================== DUPLAHIBA FAULT ========================== \n\n"
#define GP_FAULT_MSG    " ============== MEMRIA vagy I/O VDELMI HIBA ================= \n\n"
#define STK_OVERRUN_MSG " ======= VEREMTLCSORDUS vagy HINYZ OBJEKTUM HIBA ========== \n\n"
#define EX_FAULT_MSG    " ======================= KIVTEL ============================== \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** cm %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\tr\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT has found only %dK of low memory.  512k of low memory\n"  \
"is required to run Windows NT.  You may need to upgrade your\n"      \
"computer or run a configuration program provided by the manufacturer.\n"

#define SU_NO_EXTENDED_MEMORY \
"Windows NT has not found enough extended memory.  7Mb of extended\n"       \
"memory is required to run Windows NT.  You may need to upgrade your\n"     \
"computer or run a configuration program provided by the manufacturer.\n"   \
"\n\nMemory Map:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR is corrupt.  The system cannot boot."

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== GENERAL PROTECTION FAULT ======================== \n\n"
#define STK_OVERRUN_MSG " ===== STACK SEGMENT OVERRUN or NOT PRESENT FAULT =============== \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** At linear address %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\usa\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT has found only %dK of low memory.  512k of low memory\n"  \
"is required to run Windows NT.  You may need to upgrade your\n"      \
"computer or run a configuration program provided by the manufacturer.\n"

#define SU_NO_EXTENDED_MEMORY \
"Windows NT has not found enough extended memory.  7Mb of extended\n"       \
"memory is required to run Windows NT.  You may need to upgrade your\n"     \
"computer or run a configuration program provided by the manufacturer.\n"   \
"\n\nMemory Map:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR is corrupt.  The system cannot boot."

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== GENERAL PROTECTION FAULT ======================== \n\n"
#define STK_OVERRUN_MSG " ===== STACK SEGMENT OVERRUN or NOT PRESENT FAULT =============== \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPTION ================================ \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** At linear address %lx\n"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\it\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\nl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\nl\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT heeft slechts %d kB aan laag geheugen aangetroffen.\n"    \
"Er is 512 kB aan laag geheugen voor Windows NT nodig. Mogelijk\n"    \
"dient u de geheugencapaciteit van de computer uit te breiden\n"      \
"of een configuratieprogramma van de fabrikant te starten.\n"         \

#define SU_NO_EXTENDED_MEMORY \
"Windows NT heeft onvoldoende extended memory aangetroffen. Er is 7 MB\n"   \
"aan extended memory voor Windows NT nodig. Mogelijk dient u de geheugen-\n"\
"capaciteit van de computer uit te breiden of een configuratieprogramma\n"  \
"van de fabrikant te starten.\n"                                            \
"\n\nGeheugentoewijzing:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR is beschadigd. Het systeem kan niet worden gestart."

#define PG_FAULT_MSG    " =================== PAGINAFOUT ================================= \n\n"
#define DBL_FAULT_MSG	" ================== DUBBELE FOUT ================================ \n\n"
#define GP_FAULT_MSG	" ============== ALGEMENE BESCHERMINGSFOUT ======================= \n\n"
#define STK_OVERRUN_MSG " ===== STACK-SEGMENT-OVERLOOP of NIET-AANWEZIG-FOUT ============= \n\n"
#define EX_FAULT_MSG	" ===================== UITZONDERING ============================= \n\n"
#define DEBUG_EXCEPTION "\nDEBUG TRAP "
#define PG_FAULT_ADDRESS "** Op lineair adres %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\pl\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"System Windows NT wykry tylko %d KB pamici niskiej. Do uruchomienia\n"  \
"systemu Windows NT wymagane jest 512 KB. Musisz rozbudowa komputer\n"      \
"lub uruchomi program konfiguracyjny dostarczony przez producenta.\n"

#define SU_NO_EXTENDED_MEMORY \
"System Windows NT nie znalaz wystarczajcej iloci pamici typu Extended.\n"       \
"Do uruchomienia systemu Windows NT wymagane jest 7 MB pamici Extended.\n"     \
"Musisz rozbudowa komputer lub uruchomi program konfiguracyjny dostarczony\n"   \
"przez producenta.\n\nMapa pamici:\n"

#define SU_NTLDR_CORRUPT \
"Plik NTLDR jest uszkodzony. System nie zostanie uruchomiony."

#define PG_FAULT_MSG    " =============== BD STRONY == (PAGE FAULT) ==================== \n\n"
#define DBL_FAULT_MSG   " =========== BD PODWJNY == (DOUBLE FAULT) ==================== \n\n"
#define GP_FAULT_MSG    " ======== OGLNY BD OCHRONY == (GENERAL PROTECTION FAULT) ===== \n\n"
#define STK_OVERRUN_MSG " ====== BD PRZEPENIENIA SEGMENTU STOSU lub NIEOBECNOCI ====== \n\n"
#define EX_FAULT_MSG    " =================== WYJTEK == (EXCEPTION) ===================== \n\n"
#define DEBUG_EXCEPTION "\nPUAPKA DEBUGOWANIA "
#define PG_FAULT_ADDRESS "** Pod adresem liniowym %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\sv\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT hittade bara %d kB lgt minne. 512 kB lgt minne\n"  \
"krvs fr att kra Windows NT. Du behver kanske uppgradera\n"      \
"datorn eller kra ett konfigurationsprogram frn terfrsljaren.\n"

#define SU_NO_EXTENDED_MEMORY \
"Inte tillrckligt med utkat minne fr att starta Windows NT. 7 MB utkat\n"       \
"minne krvs fr att kra Windows NT. Du behver kanske uppgradera\n"      \
"datorn eller kra ett konfigurationsprogram frn terfsljaren.\n"   \
"\n\nInformation om minne:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR r skadad. Datorn kan inte startas."

#define PG_FAULT_MSG    " =================== SIDFEL ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DUBBELFEL ================================ \n\n"
#define GP_FAULT_MSG    " ============== ALLMNNT SKERHETSFEL ======================= \n\n"
#define STK_OVERRUN_MSG " ===== STACKSEGMENTVERKRNING ELLER ICKE-TILLGNGLIG =============== \n\n"
#define EX_FAULT_MSG    " ===================== UNDANTAG ================================ \n\n"
#define DEBUG_EXCEPTION "\nFELSKNINGSFLLA "
#define PG_FAULT_ADDRESS "** Vid linjr adress %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\ru\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT 㦨 ⮫쪮 %d  筮 . \n"                  \
" ᪠ Windows NT ॡ 512  筮 . \n"             \
" ॡ  ⮣    \n"          \
"ணࠬ ன, ⠢塞 ⮢⥫. \n"

#define SU_NO_EXTENDED_MEMORY \
"Windows NT  㦨 筮 ꥬ ⥫쭮 . \n"  \
" ᪠ Windows NT 室 7  ⥫쭮 . \n"        \
" ॡ  ⮣    \n"           \
"ணࠬ ன, ⠢塞 ⮢⥫. \n"                     \
"\n\nᯮ짮 :\n"

#define SU_NTLDR_CORRUPT \
"NTLDR ᯮ祭.   㧨 ⥬."

#define PG_FAULT_MSG    " ===================   ============================ \n\n"
#define DBL_FAULT_MSG   " ====================   ============================ \n\n"
#define GP_FAULT_MSG    " =================    ========================== \n\n"
#define STK_OVERRUN_MSG " =====       ======== \n\n"
#define EX_FAULT_MSG    " =====================  =============================== \n\n"
#define DEBUG_EXCEPTION "\n誠 DEBUG "
#define PG_FAULT_ADDRESS "**    %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\it\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"Sono stati rilevati solo %d Kb di memoria convenzionale. Per eseguire\n"	\
"Windows NT sono necessari almeno 512 Kb. Aggiornare il computer o \n"	   \
"eseguire un programma di configurazione fornito dal costruttore.\n"

#define SU_NO_EXTENDED_MEMORY \
"Memoria estesa insufficiente. Per eseguire Windows NT sono necessari\n"	     \
"almeno 7 Mb di memoria estesa. Aggiornare il computer o eseguire\n"	 \
"un programma di configurazione fornito dal costruttore.\n"   \
"\n\nMappa della memoria:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR danneggiato. Impossibile avviare il sistema."

#define PG_FAULT_MSG    " =================== PAGE FAULT ================================= \n\n"
#define DBL_FAULT_MSG   " ================== DOUBLE FAULT ================================ \n\n"
#define GP_FAULT_MSG    " ============== ERRORE DI PROTEZIONE GENERALE =================== \n\n"
#define STK_OVERRUN_MSG " ===== OVERRUN DI STACK DEL SEGMENTO o FAULT DI ASSENZA ========= \n\n"
#define EX_FAULT_MSG    " ===================== ERRORE DI EXCEPTION ====================== \n\n"
#define DEBUG_EXCEPTION "\nTRAP DI DEBUG "
#define PG_FAULT_ADDRESS "** All'indirizzo lineare %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\pt\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
        created

--*/

#define SU_NO_LOW_MEMORY \
"O Windows NT detectou apenas %dK de memria baixa.  So necessrios 512K\n"  \
"de memria baixa para executar o Windows NT. Poder ter de actualizar\n"      \
"o computador ou executar um prog. de config. fornecido pelo fabricante.\n"

#define SU_NO_EXTENDED_MEMORY \
"O Windows NT no detectou memria de extenso suficiente. So necessrios\n"       \
"7Mb de memria de extenso para o Windows NT. Poder ter de actualizar\n"     \
"o computador ou executar um prog. de config. fornecido pelo fabricante.\n"   \
"\n\nMapa de memria:\n"

#define SU_NTLDR_CORRUPT \
"O NTLDR est danificado. O sistema no pode arrancar."

#define PG_FAULT_MSG    " =================== FALHA DE PGINA============================= \n\n"
#define DBL_FAULT_MSG   " ================== FALHA DUPLA ================================= \n\n"
#define GP_FAULT_MSG    " ============== FALHA GERAL DE PROTECO ======================== \n\n"
#define STK_OVERRUN_MSG " === SOBRE-EXECUO DO SEGMENTO DE PILHA ou FALHA DE AUSNCIA === \n\n"
#define EX_FAULT_MSG    " ===================== EXCEPO ================================= \n\n"
#define DEBUG_EXCEPTION "\nInterrupo de depurao "
#define PG_FAULT_ADDRESS "** No endereo linear  %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\no\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\i386\no\strings.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Contains all localizable strings for startup.com

Author:

    John Vert (jvert) 4-Jan-1994

Revision History:

    John Vert (jvert) 4-Jan-1994
	created

--*/

#define SU_NO_LOW_MEMORY \
"Windows NT fant bare %d kB lavminne.  Windows NT krever\n"     \
"512 kB lavminne for  kjre.  Du m kanskje oppgradere\n"          \
"datamaskinen eller kjre et konfigurasjonsprogram fra leverandren.\n"

#define SU_NO_EXTENDED_MEMORY \
"Ikke nok utvidet minne til  starte Windows NT.  Windows NT krever 7 MB\n"        \
"utvidet minne for  starte.  Du m kanskje oppgradere datamaskinen eller kjre\n"       \
"et konfigurasjonsprogram fra en maskinvareleverandr.\n"   \
"\n\nMinnelisting:\n"

#define SU_NTLDR_CORRUPT \
"NTLDR er skadet.  Datamaskinen kan ikke startes opp."

#define PG_FAULT_MSG    " ========================= SIDEFEIL ======================== \n\n"
#define DBL_FAULT_MSG   " ======================== DOBBELTFEIL ====================== \n\n"
#define GP_FAULT_MSG    " ================ GENERELL BESKYTTELSESFEIL ================ \n\n"
#define STK_OVERRUN_MSG " ======= OVERFYLT I STAKKSEGMENT eller IKKE TILSTEDE ======= \n\n"
#define EX_FAULT_MSG    " ========================== UNNTAK ========================= \n\n"
#define DEBUG_EXCEPTION "\nFEILSKINGSUNNTAK "
#define PG_FAULT_ADDRESS "** ved liner addresse %lx\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\psu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\pl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\pt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\ru\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\sv\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\tst\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\startup\tr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\tftplib\i386\xsum.asm ===
include xsum.x86
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\tftplib\udp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    udp.c

Abstract:

    Boot loader UDP routines.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

ULONG UdpNextPort = 0;

USHORT UdpUnicastDestinationPort;

#if 0
USHORT UdpMulticastDestinationPort;
ULONG UdpMulticastDestinationAddress;
USHORT UdpMulticastSourcePort;
ULONG UdpMulticastSourceAddress;
#endif


USHORT
UdpAssignUnicastPort (
    VOID
    )
{
    if ( UdpNextPort == 0 ) {
        UdpNextPort = (ArcGetRelativeTime() & 0x7fff) | 0x8000;
    } else if ( ++UdpNextPort > 0xffff ) {
        UdpNextPort = 0x8000;
    }

    UdpUnicastDestinationPort = SWAP_WORD( UdpNextPort );

#if 0
    UdpMulticastDestinationPort = 0;
#endif

    RomSetReceiveStatus(
        UdpUnicastDestinationPort
#if 0
        ,
        UdpMulticastDestinationPort,
        UdpMulticastDestinationAddress,
        UdpMulticastSourcePort,
        UdpMulticastSourceAddress
#endif
        );

    return (USHORT)UdpUnicastDestinationPort;

} // UdpAssignUnicastPort


#if 0
VOID
UdpSetMulticastPort (
    IN USHORT DestinationPort,
    IN ULONG DestinationAddress,
    IN USHORT SourcePort,
    IN ULONG SourceAddress
    )
{
    UdpMulticastDestinationPort = DestinationPort;
    UdpMulticastDestinationAddress = DestinationAddress;
    UdpMulticastSourcePort = SourcePort;
    UdpMulticastSourceAddress = SourceAddress;

    RomSetReceiveStatus(
        UdpUnicastDestinationPort,
        UdpMulticastDestinationPort,
        UdpMulticastDestinationAddress,
        UdpMulticastSourcePort,
        UdpMulticastSourceAddress
        );

    return;

} // UdpSetMulticastPort
#endif


ULONG
UdpReceive (
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG RemoteHost,
    OUT PUSHORT RemotePort,
    IN ULONG Timeout
    )

//
// Read in packet from the specified socket. The host and port
// the packet comes from is filled in fhost and fport.
// The data is put in buffer buf, which should have size len. If no packet
// arrives in tmo seconds, then 0 is returned.
// Otherwise it returns the size of the packet read.
//

{
    return RomReceiveUdpPacket( Buffer, BufferLength, Timeout, RemoteHost, RemotePort );

} // UdpReceive


ULONG
UdpSend (
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG RemoteHost,
    IN USHORT RemotePort
    )

//
// writes a packet to the specified socket. The host and port the packet
// should go to should be in fhost and fport
// The data should be put in buffer buf, and should have size len.
// It usually returns the number of characters sent, or -1 on failure.
//

{
    return RomSendUdpPacket( Buffer, BufferLength, RemoteHost, RemotePort );

} // UdpSend
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\tftplib\precomp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Boot loader TFTP header file.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Revision History:

Notes:

--*/

#include <bldr.h>
#include <netboot.h>
#include <netfs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\tftplib\i386\rom.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rom.c

Abstract:

    Boot loader ROM routines.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#include <bldrx86.h>

#define PhysToSeg(x)    (USHORT)((ULONG)(x) >> 4) & 0xffff
#define PhysToOff(x)    (USHORT)((ULONG)(x) & 0x0f)

#include <pxe_cmn.h>
#include <pxe_api.h>
#include <tftp_api.h>
#include <udp_api.h>
#include <undi_api.h>
#include <dhcp.h>
#include <pxe.h>

USHORT NetUnicastUdpDestinationPort = 0;

#if 0
USHORT NetMulticastUdpDestinationPort;
ULONG NetMulticastUdpDestinationAddress;
USHORT NetMulticastUdpSourcePort;
ULONG NetMulticastUdpSourceAddress;
#endif

#if 0 && DBG
#include <stdio.h>
VOID
RomDumpRawData (
    IN PUCHAR DataStart,
    IN ULONG DataLength,
    IN ULONG Offset
    );
ULONG RomMaxDumpLength = 64;
#endif


#if 0

//
// chuckl: Don't do this. We added it as part of a solution a problem
// with DEC cards and the boot floppy. We disabled broadcasts in
// startrom\i386\main.c so that the card wouldn't overflow and lock up,
// but we need to have broadcasts enabled in case the server needs to
// ARP us. The purpose of this routine is to enable/disable broadcasts
// during the receive loop, but that seems to put Compaq cards to sleep.
// So we need to leave broadcasts enabled all the time. The DEC card
// problem will have to be fixed another way.
//

VOID
RomSetBroadcastStatus(
    BOOLEAN Enable
    )
{
    t_PXENV_UNDI_SET_PACKET_FILTER UndiSetPF;
    USHORT status;

    UndiSetPF.Status = 0;
    if (Enable) {
        UndiSetPF.filter = FLTR_DIRECTED | FLTR_BRDCST;
    } else {
        UndiSetPF.filter = FLTR_DIRECTED;
    }
    status = NETPC_ROM_SERVICES( PXENV_UNDI_SET_PACKET_FILTER, &UndiSetPF );

    if ((status != 0) || (UndiSetPF.Status != 0)) {
        DPRINT( ERROR, ("RomSetBroadcastStatus: set packet filter failed %lx, %lx\n", status, UndiSetPF.Status ));
    }
}
#endif

VOID
RomSetReceiveStatus (
    IN USHORT UnicastUdpDestinationPort
#if 0
    ,
    IN USHORT MulticastUdpDestinationPort,
    IN ULONG MulticastUdpDestinationAddress,
    IN USHORT MulticastUdpSourcePort,
    IN ULONG MulticastUdpSourceAddress
#endif
    )
{
    USHORT status;
    PUCHAR multicastAddress;
    union {
        t_PXENV_UDP_OPEN UdpOpen;
        t_PXENV_UNDI_SHUTDOWN UndiShutdown;
    } command;

    if ( UnicastUdpDestinationPort != 0 ) {

        //
        // If we haven't opened UDP in the ROM yet, do so now.
        //

        if ( NetUnicastUdpDestinationPort == 0 ) {
            command.UdpOpen.Status = 0;
            *(UINT32 *)command.UdpOpen.SrcIp = 0;
            status = NETPC_ROM_SERVICES( PXENV_UDP_OPEN, &command );
            if ( status != 0 ) {
                DPRINT( ERROR, ("RomSetReceiveStatus: error %d from UDP_OPEN\n", status) );
            }
        }
        NetUnicastUdpDestinationPort = UnicastUdpDestinationPort;

#if 0
        NetMulticastUdpDestinationPort = MulticastUdpDestinationPort;
        NetMulticastUdpDestinationAddress = MulticastUdpDestinationAddress;
        NetMulticastUdpSourceAddress = MulticastUdpSourceAddress;
        NetMulticastUdpSourceAddress = MulticastUdpSourceAddress;
#endif

    } else {

        //
        // This is a loader shutdown notification. Shut the NIC down.
        //
        // NB: This is irreversible!
        //
        
        command.UndiShutdown.Status = 0;
        status = NETPC_ROM_SERVICES( PXENV_UNDI_SHUTDOWN, &command );
    }

    return;

} // RomSetReceiveStatus


ULONG
RomSendUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG RemoteHost,
    IN USHORT RemotePort
    )
{
    USHORT status;
    t_PXENV_UDP_WRITE command;
    UCHAR tmpBuffer[MAXIMUM_TFTP_PACKET_LENGTH];

#if 0 && DBG
    DPRINT( SEND_RECEIVE, ("RomSendUdpPacket: sending this packet:\n") );
    IF_DEBUG(SEND_RECEIVE) {
        RomDumpRawData( Buffer, Length, 0 );
    }
#endif

    Length = ( MAXIMUM_TFTP_PACKET_LENGTH < Length ) ? MAXIMUM_TFTP_PACKET_LENGTH : Length;
    RtlCopyMemory( tmpBuffer, Buffer, Length );

    command.Status = 0;

    //
    // Determine whether we need to send via the gateway.
    //

    if ( (RemoteHost & NetLocalSubnetMask) == (NetLocalIpAddress & NetLocalSubnetMask) ) {
        *(UINT32 *)command.GatewayIp = 0;
    } else {
        *(UINT32 *)command.GatewayIp = NetGatewayIpAddress;
    }

    *(UINT32 *)command.DestIp = RemoteHost;
    command.DestPort = RemotePort;
    command.SrcPort = NetUnicastUdpDestinationPort;

    command.BufferSize = (USHORT)Length;
    command.BufferOffset = PhysToOff(tmpBuffer);
    command.BufferSegment = PhysToSeg(tmpBuffer);
    //DbgPrint( "UDP write pktaddr %lx = %x:%x\n", tmpBuffer, command.BufferSegment, command.BufferOffset );

    status = NETPC_ROM_SERVICES( PXENV_UDP_WRITE, &command );
    //DbgPrint( "UDP write status = %x\n", command.Status );

    if ( status == 0 ) {
        return Length;
    } else {
        return 0;
    }

} // RomSendUdpPacket


ULONG
RomReceiveUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Timeout,
    OUT PULONG RemoteHost,
    OUT PUSHORT RemotePort
    )
{
    USHORT status;
    t_PXENV_UDP_READ command;
    ULONG startTime;
    UCHAR tmpBuffer[MAXIMUM_TFTP_PACKET_LENGTH];

    //
    // Turn on broadcasts while in the receive loop, in case
    // the other end needs to ARP to find us.
    //

#if 0
    RomSetBroadcastStatus(TRUE);
#endif

    startTime = SysGetRelativeTime();
    if ( Timeout < 2 ) Timeout = 2;

    while ( (SysGetRelativeTime() - startTime) < Timeout ) {
    
        command.Status = 0;
    
        *(UINT32 *)command.SrcIp = 0;
        *(UINT32 *)command.DestIp = 0;
        command.SrcPort = 0;
        command.DestPort = 0;
    
        command.BufferSize = (USHORT)Length;
        command.BufferOffset = PhysToOff(tmpBuffer);
        command.BufferSegment = PhysToSeg(tmpBuffer);
        //DbgPrint( "UDP read pktaddr %lx = %x:%x\n", tmpBuffer, command.BufferSegment, command.BufferOffset );
    
        status = NETPC_ROM_SERVICES( PXENV_UDP_READ, &command );
    
        if ( *(UINT32 *)command.SrcIp == 0 ) {
            continue;
        }

        //DbgPrint( "UDP read status = %x, src ip/port = %d.%d.%d.%d/%d, length = %x\n", command.Status,
        //            command.SrcIp[0], command.SrcIp[1], command.SrcIp[2], command.SrcIp[3],
        //            SWAP_WORD(command.SrcPort), command.BufferSize );
        //DbgPrint( "  dest ip/port = %d.%d.%d.%d/%d\n", 
        //            command.DestIp[0], command.DestIp[1], command.DestIp[2], command.DestIp[3],
        //            SWAP_WORD(command.DestPort) );

#if 0
        if ( (command.DestIp[0] < 224) || (command.DestIp[0] > 239) ) {
#endif

            //
            // This is a directed IP packet.
            //

            if ( !COMPARE_IP_ADDRESSES(command.DestIp, &NetLocalIpAddress) ||
                     (command.DestPort != NetUnicastUdpDestinationPort)
               ) {
                // DPRINT( ERROR, ("  Directed UDP packet to wrong port\n") );
                continue;
            }

#if 0
        } else {

            //
            // This is a multicast IP packet.
            //

            if ( !COMPARE_IP_ADDRESSES(command.SrcIp, &NetMulticastUdpSourceAddress) ||
                 !COMPARE_IP_ADDRESSES(command.DestIp, &NetMulticastUdpDestinationAddress) ||
                 (command.SrcPort != NetMulticastUdpSourcePort) ||
                 (command.DestPort != NetMulticastUdpDestinationPort) ) {
                DPRINT( ERROR, ("  Multicast UDP packet with wrong source/destination\n") );
                continue;
            }
        }
#endif

        //
        // We want this packet.
        //

        goto packet_received;
    }

    //
    // Timeout.
    //

    DPRINT( SEND_RECEIVE, ("RomReceiveUdpPacket: timeout\n") );

#if 0
    RomSetBroadcastStatus(FALSE);   // turn off broadcast reception
#endif
    return 0;

packet_received:

    //
    // Packet received.
    //

    RtlCopyMemory( Buffer, tmpBuffer, command.BufferSize );

    *RemoteHost = *(UINT32 *)command.SrcIp;
    *RemotePort = command.SrcPort;

#if 0 && DBG
    if ( command.BufferSize != 0 ) {
        DPRINT( SEND_RECEIVE, ("RomReceiveUdpPacket: received this packet:\n") );
        IF_DEBUG(SEND_RECEIVE) {
            RomDumpRawData( Buffer, command.BufferSize, 0 );
        }
    }
#endif

#if 0
    RomSetBroadcastStatus(FALSE);   // turn off broadcast reception
#endif
    return command.BufferSize;

} // RomReceiveUdpPacket


ULONG
RomGetNicType (
    OUT t_PXENV_UNDI_GET_NIC_TYPE *NicType
    )
{
    return NETPC_ROM_SERVICES( PXENV_UNDI_GET_NIC_TYPE, NicType );
}

#if 0 && DBG
VOID
RomDumpRawData (
    IN PUCHAR DataStart,
    IN ULONG DataLength,
    IN ULONG Offset
    )

{
    ULONG lastByte;
    UCHAR lineBuffer[88];
    PUCHAR bufferPtr;

    if ( DataLength > RomMaxDumpLength ) {
        DataLength = RomMaxDumpLength;
    }

    for ( lastByte = Offset + DataLength; Offset < lastByte; Offset += 16 ) {

        ULONG i;

        bufferPtr = lineBuffer;

        sprintf( bufferPtr, "  %08x  %04x: ", &DataStart[Offset], Offset );
        bufferPtr += 18;

        for ( i = 0; i < 16 && Offset + i < lastByte; i++ ) {

            sprintf( bufferPtr, "%02x", (UCHAR)DataStart[Offset + i] & (UCHAR)0xFF );
            bufferPtr += 2;

            if ( i == 7 ) {
                *bufferPtr++ = '-';
            } else {
                *bufferPtr++ = ' ';
            }
        }

        //
        // Print enough spaces so that the ASCII display lines up.
        //

        for ( ; i < 16; i++ ) {
            *bufferPtr++ = ' ';
            *bufferPtr++ = ' ';
            *bufferPtr++ = ' ';
        }

        *bufferPtr++ = ' ';
        *bufferPtr++ = ' ';
        *bufferPtr++ = '*';

        for ( i = 0; i < 16 && Offset + i < lastByte; i++ ) {
            if ( isprint( DataStart[Offset + i] ) ) {
                *bufferPtr++ = (CCHAR)DataStart[Offset + i];
            } else {
                *bufferPtr++ = '.';
            }
        }

        *bufferPtr = 0;
        DbgPrint( "%s*\n", lineBuffer );
    }

    return;

} // RomDumpRawData
#endif // DBG


ARC_STATUS
RomMtftpReadFile (
    IN PUCHAR FileName,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG ServerIPAddress, // network byte order
    IN ULONG MCastIPAddress, // network byte order
    IN USHORT MCastCPort, // network byte order
    IN USHORT MCastSPort, // network byte order
    IN USHORT Timeout,
    IN USHORT Delay,
    OUT PULONG DownloadSize
    )
{
    USHORT status;
    t_PXENV_TFTP_READ_FILE tftp;
    t_PXENV_UDP_CLOSE udpclose;

    if (DownloadSize != NULL) {
        *DownloadSize = 0;
    }

    memset( &tftp, 0 , sizeof( tftp ) );

    strcpy(tftp.FileName, FileName);
    tftp.BufferSize = BufferLength;
    tftp.BufferOffset = (UINT32)Buffer; 

    if ( (ServerIPAddress & NetLocalSubnetMask) == (NetLocalIpAddress & NetLocalSubnetMask) ) {
        *((UINT32 *)tftp.GatewayIPAddress) = 0;
    } else {
        *((UINT32 *)tftp.GatewayIPAddress) = NetGatewayIpAddress;
    }

    *((UINT32 *)tftp.ServerIPAddress) = ServerIPAddress;
    *((UINT32 *)tftp.McastIPAddress) = MCastIPAddress;
    tftp.TFTPClntPort = MCastCPort;
    tftp.TFTPSrvPort = MCastSPort;
    tftp.TFTPOpenTimeOut = Timeout;
    tftp.TFTPReopenDelay = Delay;

    // make sure that any UDP sessions are already closed.
    status = NETPC_ROM_SERVICES( PXENV_UDP_CLOSE, &udpclose );

    status = NETPC_ROM_SERVICES( PXENV_TFTP_READ_FILE, &tftp );
    if (status != PXENV_EXIT_SUCCESS) {
        return EINVAL;
    }

    if (DownloadSize != NULL) {
        *DownloadSize = tftp.BufferSize;
    }

    return ESUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\tftplib\tftp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    tftp.c

Abstract:

    Boot loader TFTP routines.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

//
// This removes macro redefinitions which appear because we define __RPC_DOS__,
// but rpc.h defines __RPC_WIN32__
//

#pragma warning(disable:4005)

//
// As of 12/17/98, SECURITY_DOS is *not* defined - adamba
//

#if defined(SECURITY_DOS)
//
// These appear because we defined SECURITY_DOS
//

#define __far
#define __pascal
#define __loadds
#endif

#include <security.h>
#include <rpc.h>
#include <spseal.h>

#if defined(_X86_)
#include <bldrx86.h>
#endif

#if defined(SECURITY_DOS)
//
// PSECURITY_STRING is not supposed to be used when SECURITY_DOS is
// defined -- it should be a WCHAR*. Unfortunately ntlmsp.h breaks
// this rule and even uses the SECURITY_STRING structure, which there
// is really no equivalent for in 16-bit mode.
//

typedef SEC_WCHAR * SECURITY_STRING;   // more-or-less the intention where it is used
typedef SEC_WCHAR * PSECURITY_STRING;
#endif

#include <ntlmsp.h>

#if DBG
ULONG NetDebugFlag =
        DEBUG_ERROR             |
        DEBUG_CONN_ERROR        |
        //DEBUG_LOUD              |
        //DEBUG_REAL_LOUD         |
        //DEBUG_STATISTICS        |
        //DEBUG_SEND_RECEIVE      |
        //DEBUG_TRACE             |
        //DEBUG_ARP               |
        //DEBUG_INITIAL_BREAK     |
        0;
#endif

//
// Global variables
//

CONNECTION NetTftpConnection;

UCHAR NetTftpPacket[3][MAXIMUM_TFTP_PACKET_LENGTH];

#if defined(REMOTE_BOOT_SECURITY)
//
// Globals used during login.
//

static CHAR OutgoingMessage[1024];
static CHAR IncomingMessage[1024];

static CredHandle CredentialHandle;
static BOOLEAN CredentialHandleValid = FALSE;
CtxtHandle TftpClientContextHandle;
BOOLEAN TftpClientContextHandleValid = FALSE;
#endif // defined(REMOTE_BOOT_SECURITY)

//
// Local declarations.
//

NTSTATUS
TftpGet (
    IN PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    );

NTSTATUS
TftpPut (
    IN PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    );


NTSTATUS
TftpGetPut (
    IN PTFTP_REQUEST Request
    )
{
    NTSTATUS status;
    PCONNECTION connection = NULL;
    ULONG FileSize;
    ULONG basePage;
#if 0 && DBG
    LARGE_INTEGER startTime;
    LARGE_INTEGER endTime;
    LARGE_INTEGER elapsedTime;
    LARGE_INTEGER frequency;
    ULONG seconds;
    ULONG secondsFraction;
    ULONG bps;
    ULONG bpsFraction;
#endif

#if defined(REMOTE_BOOT)
    if (!NetworkBootRom) {

        //  Booting from the hard disk cache because server is not available
        return STATUS_UNSUCCESSFUL;
    }
#endif // defined(REMOTE_BOOT)



#ifndef EFI
    //
    // We don't need to do any of this initialization if
    // we're in EFI.
    //


    FileSize = Request->MaximumLength;

    status = ConnInitialize(
                &connection,
                Request->Operation,
                Request->ServerIpAddress,
                TFTP_PORT,
                Request->RemoteFileName,
                0,
#if defined(REMOTE_BOOT_SECURITY)
                &Request->SecurityHandle,   // will be set to 0 if security negotiation fails
#endif // defined(REMOTE_BOOT_SECURITY)
                &FileSize
                );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

#if 0 && DBG
    IF_DEBUG(STATISTICS) {
        startTime = KeQueryPerformanceCounter( &frequency );
    }
#endif

    if ( Request->Operation == TFTP_RRQ ) {

        if ( Request->MemoryAddress != NULL ) {

            if ( Request->MaximumLength < FileSize ) {
                ConnError(
                    connection,
                    connection->RemoteHost,
                    connection->RemotePort,
                    TFTP_ERROR_UNDEFINED,
                    "File too big"
                    );
                return STATUS_INSUFFICIENT_RESOURCES;
            }

        } else {

            //
            // NB: (ChuckL) Removed code added by MattH to check for
            // allocation >= 1/3 of (BlUsableLimit - BlUsableBase)
            // because calling code now sets BlUsableLimit to 1 GB
            // or higher.
            //


            status = BlAllocateAlignedDescriptor(
                        Request->MemoryType,
                        0,
                        BYTES_TO_PAGES(FileSize),
                        0,
                        &basePage
                        );

            if (status != ESUCCESS) {
                ConnError(
                    connection,
                    connection->RemoteHost,
                    connection->RemotePort,
                    TFTP_ERROR_UNDEFINED,
                    "File too big"
                    );
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            Request->MemoryAddress = (PUCHAR)ULongToPtr( (basePage << PAGE_SHIFT) );
            Request->MaximumLength = FileSize;
            DPRINT( REAL_LOUD, ("TftpGetPut: allocated %d bytes at 0x%08x\n",
                    Request->MaximumLength, Request->MemoryAddress) );
        }

        status = TftpGet( connection, Request );

    } else {

        status = TftpPut( connection, Request );
    }

#else  // #ifndef EFI

    if ( Request->Operation == TFTP_RRQ ) {

        status = TftpGet( connection, Request );
    } else {

        status = TftpPut( connection, Request );
    }

    if( status != STATUS_SUCCESS ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

#endif  // #ifndef EFI


    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    return status;

} // TftpGetPut


#ifdef EFI

extern VOID
FlipToPhysical (
    );

extern VOID
FlipToVirtual (
    );

NTSTATUS
TftpGet (
    IN OUT PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    )
{
    EFI_STATUS      Status;
    CHAR16          *Size = NULL;
    PVOID           MyBuffer = NULL;
    EFI_IP_ADDRESS  MyServerIpAddress;
    INTN            Count = 0;
    INTN            BufferSizeX = sizeof(CHAR16);
    ULONG           basePage;
    UINTN           BlockSize = 512;

    //
    // They sent us an IP address as a ULONG.  We need to convert
    // that into an EFI_IP_ADDRESS.
    //
    for( Count = 0; Count < 4; Count++ ) {
        MyServerIpAddress.v4.Addr[Count] = PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr[Count];
    }


    //
    // Get the file size, allocate some memory, then get the file.
    //
    FlipToPhysical();
    Status = PXEClient->Mtftp( PXEClient,
                               EFI_PXE_BASE_CODE_TFTP_GET_FILE_SIZE,
                               Size,
                               TRUE,
                               &BufferSizeX,
                               &BlockSize,
                               &MyServerIpAddress,
                               Request->RemoteFileName,
                               0,
                               FALSE );
    FlipToVirtual();


    if( Status != EFI_SUCCESS ) {

        return (NTSTATUS)Status;

    }

    Status = BlAllocateAlignedDescriptor(
                Request->MemoryType,
                0,
                (ULONG) BYTES_TO_PAGES(BufferSizeX),
                0,
                &basePage
                );

    if ( Status != ESUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "TftpGet: BlAllocate failed! (%d)\n", Status );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Request->MemoryAddress = (PUCHAR)ULongToPtr( (basePage << PAGE_SHIFT) );
    Request->MaximumLength = (ULONG)BufferSizeX;


    //
    // Make sure we send EFI a physical address.
    //
    MyBuffer = (PVOID)((ULONGLONG)(Request->MemoryAddress) & ~KSEG0_BASE);    
    
    FlipToPhysical();
    Status = PXEClient->Mtftp( PXEClient,
                               EFI_PXE_BASE_CODE_TFTP_READ_FILE,
                               MyBuffer,
                               TRUE,
                               &BufferSizeX,
                               NULL,
                               &MyServerIpAddress,
                               Request->RemoteFileName,
                               0,
                               FALSE );
    FlipToVirtual();

    if( Status != EFI_SUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "TftpGet: GetFile failed! (%d)\n", Status );
        }
        return (NTSTATUS)Status;

    }



    Request->BytesTransferred = (ULONG)BufferSizeX;

    return (NTSTATUS)Status;

} // TftpGet


NTSTATUS
TftpPut (
    IN OUT PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    )
{
    EFI_STATUS      Status;
    EFI_IP_ADDRESS  MyServerIpAddress;
    INTN            Count = 0;
    PVOID           MyBuffer = NULL;


    //
    // They sent us an IP address as a ULONG.  We need to convert
    // that into an EFI_IP_ADDRESS.
    //
    for( Count = 0; Count < 4; Count++ ) {
        MyServerIpAddress.v4.Addr[Count] = PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr[Count];
    }

    //
    // Make sure we send EFI a physical address.
    //
    MyBuffer = (PVOID)((ULONGLONG)(Request->MemoryAddress) & ~KSEG0_BASE);    

    FlipToPhysical();
    Status = PXEClient->Mtftp( PXEClient,
                               EFI_PXE_BASE_CODE_TFTP_WRITE_FILE,
                               MyBuffer,
                               TRUE,
                               (UINTN *)(&Request->MaximumLength),
                               NULL,
                               &MyServerIpAddress,
                               Request->RemoteFileName,
                               0,
                               FALSE );
    FlipToVirtual();

    if( Status != EFI_SUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "TftpPut: WriteFile failed! (%d)\n", Status );
        }

    }

    return (NTSTATUS)Status;

} // TftpPut

#else   // #ifdef EFI

NTSTATUS
TftpGet (
    IN OUT PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    )
{
    NTSTATUS status;
    PTFTP_PACKET packet;
    ULONG length;
    ULONG offset;
    PUCHAR packetData;
    ULONG lastProgressPercent = -1;
    ULONG currentProgressPercent;
#if defined(REMOTE_BOOT_SECURITY)
    UCHAR Sign[NTLMSSP_MESSAGE_SIGNATURE_SIZE];
    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    SECURITY_STATUS SecStatus;
#endif // defined(REMOTE_BOOT_SECURITY)

    DPRINT( TRACE, ("TftpGet\n") );

#if defined(REMOTE_BOOT)
    if (!NetworkBootRom) {

        //  Booting from the hard disk cache because server is not available
        return STATUS_UNSUCCESSFUL;
    }
#endif // defined(REMOTE_BOOT)

    offset = 0;

    if ( Request->ShowProgress ) {
        BlUpdateProgressBar(0);
    }

    do {

        status = ConnReceive( Connection, &packet );
        if ( !NT_SUCCESS(status) ) {
            break;
        }

        length = Connection->CurrentLength - 4;

#if defined(REMOTE_BOOT_SECURITY)
        //
        // If we are doing a security transfer, then the first packet
        // has the sign in it, so put that in the Sign buffer first.
        //

        if (Request->SecurityHandle && (offset == 0)) {

            if (length < NTLMSSP_MESSAGE_SIGNATURE_SIZE) {
                status = STATUS_UNEXPECTED_NETWORK_ERROR;
                break;
            }
            memcpy(Sign, packet->Data, NTLMSSP_MESSAGE_SIGNATURE_SIZE);
            packetData = packet->Data + NTLMSSP_MESSAGE_SIGNATURE_SIZE;
            length -= NTLMSSP_MESSAGE_SIGNATURE_SIZE;

        } else
#endif // defined(REMOTE_BOOT_SECURITY)
        {

            packetData = packet->Data;
        }

        if ( (offset + length) > Request->MaximumLength ) {
            length = Request->MaximumLength - offset;
        }

        RtlCopyMemory( Request->MemoryAddress + offset, packetData, length );

        offset += length;

        if ( Request->ShowProgress ) {
            currentProgressPercent = (ULONG)(((ULONGLONG)offset * 100) / Request->MaximumLength);
            if ( currentProgressPercent != lastProgressPercent ) {
                BlUpdateProgressBar( currentProgressPercent );
            }
            lastProgressPercent = currentProgressPercent;
        }

        //
        // End the loop when we get a packet smaller than the max size --
        // the extra check is to handle the first packet (length == offset)
        // since we get NTLMSSP_MESSAGE_SIGNATURE_SIZE bytes less.
        //

    } while ( (length == Connection->BlockSize)
#if defined(REMOTE_BOOT_SECURITY)
              || ((length == offset) &&
                  (length == (Connection->BlockSize - NTLMSSP_MESSAGE_SIGNATURE_SIZE)))
#endif // defined(REMOTE_BOOT_SECURITY)
            );

#if defined(REMOTE_BOOT_SECURITY)
    if (Request->SecurityHandle) {

        //
        // Unseal the message if it was encrypted.
        //

        SigBuffers[1].pvBuffer = Sign;
        SigBuffers[1].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        SigBuffers[1].BufferType = SECBUFFER_TOKEN;

        SigBuffers[0].pvBuffer = Request->MemoryAddress;
        SigBuffers[0].cbBuffer = offset;
        SigBuffers[0].BufferType = SECBUFFER_DATA;

        SignMessage.pBuffers = SigBuffers;
        SignMessage.cBuffers = 2;
        SignMessage.ulVersion = 0;

        ASSERT (TftpClientContextHandleValid);

        SecStatus = UnsealMessage(
                            &TftpClientContextHandle,
                            &SignMessage,
                            0,
                            0 );

        if ( SecStatus != SEC_E_OK ) {
            DPRINT( ERROR, ("TftpGet: UnsealMessage failed %x\n", SecStatus) );
            status = STATUS_UNEXPECTED_NETWORK_ERROR;
        }

    }
#endif // defined(REMOTE_BOOT_SECURITY)

    Request->BytesTransferred = offset;

    return status;

} // TftpGet


NTSTATUS
TftpPut (
    IN OUT PCONNECTION Connection,
    IN PTFTP_REQUEST Request
    )
{
    NTSTATUS status;
    PTFTP_PACKET packet;
    ULONG length;
    ULONG offset;

    DPRINT( TRACE, ("TftpPut\n") );

#if defined(REMOTE_BOOT)
    if (!NetworkBootRom) {

        //  Booting from the hard disk cache because server is not available
        return STATUS_UNSUCCESSFUL;
    }
#endif // defined(REMOTE_BOOT)

    offset = 0;

    do {

        packet = ConnPrepareSend( Connection );

        length = Connection->BlockSize;
        if ( (offset + length) > Request->MaximumLength ) {
            length = Request->MaximumLength - offset;
        }

        RtlCopyMemory( packet->Data, Request->MemoryAddress + offset, length );

        status = ConnSend( Connection, length );
        if ( !NT_SUCCESS(status) ) {
            break;
        }

        offset += length;

    } while ( length == Connection->BlockSize );

    Request->BytesTransferred = offset;

    if ( NT_SUCCESS(status) ) {
        status = ConnWaitForFinalAck( Connection );
    }

    return status;

} // TftpPut
#endif  // #if defined(_IA64_)

#if defined(REMOTE_BOOT_SECURITY)
NTSTATUS
UdpSendAndReceiveForTftp(
    IN PVOID SendBuffer,
    IN ULONG SendBufferLength,
    IN ULONG SendRemoteHost,
    IN USHORT SendRemotePort,
    IN ULONG SendRetryCount,
    IN PVOID ReceiveBuffer,
    IN ULONG ReceiveBufferLength,
    OUT PULONG ReceiveRemoteHost,
    OUT PUSHORT ReceiveRemotePort,
    IN ULONG ReceiveTimeout,
    IN USHORT ReceiveSequenceNumber
    )
{
    ULONG i, j;
    ULONG length;

    //
    // Try sending the packet SendRetryCount times, until we receive
    // a response with the right sequence number, waiting ReceiveTimeout
    // each time.
    //

    for (i = 0; i < SendRetryCount; i++) {

        length = UdpSend(
                    SendBuffer,
                    SendBufferLength,
                    SendRemoteHost,
                    SendRemotePort);

        if ( length != SendBufferLength ) {
            DPRINT( ERROR, ("UdpSend only sent %d bytes, not %d\n", length, SendBufferLength) );
            return STATUS_UNEXPECTED_NETWORK_ERROR;
        }

ReReceive:

        //
        // NULL out the first 12 bytes in case we get shorter data.
        //

        memset(ReceiveBuffer, 0x0, 12);

        length = UdpReceive(
                    ReceiveBuffer,
                    ReceiveBufferLength,
                    ReceiveRemoteHost,
                    ReceiveRemotePort,
                    ReceiveTimeout);

        if ( length == 0 ) {
            DPRINT( ERROR, ("UdpReceive timed out sending %d, %d sends\n", SendBufferLength, i) );
            continue;
        }

        //
        // Make sure that it is a TFTP security packet.
        //

        if (((USHORT UNALIGNED *)ReceiveBuffer)[0] != SWAP_WORD(0x10)) {
            DPRINT( ERROR, ("UdpReceive not a TFTP packet\n") );
            continue;
        }

        //
        // Make sure that the sequence number is correct -- what we
        // expect, or 0xffff.
        //

        if ((((USHORT UNALIGNED *)ReceiveBuffer)[1] == SWAP_WORD(0xffff)) ||
            (((USHORT UNALIGNED *)ReceiveBuffer)[1] == SWAP_WORD(ReceiveSequenceNumber))) {

            return STATUS_SUCCESS;

        } else {

            DPRINT( ERROR, ("UdpReceive expected seq %d, got %d\n",
                    ReceiveSequenceNumber, ((UCHAR *)ReceiveBuffer)[3]) );

        }

        DPRINT( ERROR, ("UdpReceive got wrong signature\n") );

        // CLEAN THIS UP -- but the idea is not to UdpSend again just
        // because we got a bad signature. Still need to respect the
        // original ReceiveTimeout however!

        goto ReReceive;

    }

    //
    // We timed out.
    //

    return STATUS_TIMEOUT;
}


NTSTATUS
TftpLogin (
    IN PUCHAR Domain,
    IN PUCHAR Name,
    IN PUCHAR OwfPassword,
    IN ULONG ServerIpAddress,
    OUT PULONG LoginHandle
    )
{
    NTSTATUS status;
    ARC_STATUS Status;
    SECURITY_STATUS SecStatus;
    NTSTATUS remoteStatus;
    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;
    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;
    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;
    ULONG ContextAttributes;
    SEC_WINNT_AUTH_IDENTITY AuthIdentity;
    TimeStamp Lifetime;
    ULONG RemoteHost;
    USHORT RemotePort;
    ULONG LoginHeaderLength;
    USHORT LocalPort;
    PUCHAR OptionLoc;
    ULONG MaxToken;
    PSecPkgInfo PackageInfo;

#if defined(REMOTE_BOOT)
    if (!NetworkBootRom) {

        //  Booting from the hard disk cache because server is not available
        return STATUS_UNSUCCESSFUL;
    }
#endif // defined(REMOTE_BOOT)

    //
    // Get ourselves a UDP port.
    //

    LocalPort = UdpAssignUnicastPort();


    //
    // Delete both contexts if needed.
    //

    if (TftpClientContextHandleValid) {

        SecStatus = DeleteSecurityContext( &TftpClientContextHandle );
        TftpClientContextHandleValid = FALSE;

    }

    if (CredentialHandleValid) {

        SecStatus = FreeCredentialsHandle( &CredentialHandle );
        CredentialHandleValid = FALSE;

    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfoA( NTLMSP_NAME_A, &PackageInfo );

    if ( SecStatus != SEC_E_OK ) {
        DPRINT( ERROR, ("QuerySecurityPackageInfo failed %d", SecStatus) );
        return (RtlMapSecurityErrorToNtStatus(SecStatus));
    }

    MaxToken = PackageInfo->cbMaxToken;
    FreeContextBuffer(PackageInfo);


    //
    // Acquire a credential handle for the client side
    //


    RtlZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );

    AuthIdentity.Domain = Domain;
    AuthIdentity.User = Name;
    AuthIdentity.Password = OwfPassword;

    SecStatus = AcquireCredentialsHandleA(
                    NULL,           // New principal
                    NTLMSP_NAME_A,    // Package Name
                    SECPKG_CRED_OUTBOUND | SECPKG_CRED_OWF_PASSWORD,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle,
                    &Lifetime );

    if ( SecStatus != SEC_E_OK ) {
        DPRINT( ERROR, ("AcquireCredentialsHandle failed: %s ", SecStatus) );
        return (RtlMapSecurityErrorToNtStatus(SecStatus));
    }

    CredentialHandleValid = TRUE;

    //
    // Get the NegotiateMessage (ClientSide)
    //

    ((USHORT UNALIGNED *)OutgoingMessage)[0] = SWAP_WORD(0x10);   // TFTP packet type 16

    memcpy(OutgoingMessage+2, "login", 6);  // copy the final \0 also
    strcpy(OutgoingMessage+8, NTLMSP_NAME_A);

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = MaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;

    // allow 8 for the type and "login", then NTLMSP_NAME_A + 1 for the \0,
    // plus four bytes for the length.
    LoginHeaderLength = 8 + strlen(NTLMSP_NAME_A) + 1;
    NegotiateBuffer.pvBuffer = OutgoingMessage + LoginHeaderLength + 4;

    SecStatus = InitializeSecurityContextA(
                    &CredentialHandle,
                    NULL,               // No Client context yet
                    NULL,
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &TftpClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( (SecStatus != SEC_E_OK) && (SecStatus != SEC_I_CONTINUE_NEEDED) ) {
        DPRINT( ERROR, ("InitializeSecurityContext (negotiate): %d", SecStatus) );
        return (RtlMapSecurityErrorToNtStatus(SecStatus));
    }

    TftpClientContextHandleValid = TRUE;

    //
    // Send the negotiate buffer to the server and wait for a response.
    //

    *((ULONG UNALIGNED *)(OutgoingMessage + LoginHeaderLength)) =
                                        SWAP_DWORD(NegotiateBuffer.cbBuffer);

    Status = UdpSendAndReceiveForTftp(
                OutgoingMessage,
                NegotiateBuffer.cbBuffer + LoginHeaderLength + 4,
                ServerIpAddress,
                TFTP_PORT,
                10,     // retry count
                IncomingMessage,
                MaxToken + 8,
                &RemoteHost,
                &RemotePort,
                3,      // receive timeout
                0);     // sequence number);

    if ( !NT_SUCCESS(Status) ) {
        DPRINT( ERROR, ("UdpSendAndReceiveForTftp status is %x\n", Status) );
        return Status;
    }

    //
    // Get the AuthenticateMessage (ClientSide)
    //

    AuthenticateDesc.ulVersion = 0;
    AuthenticateDesc.cBuffers = 1;
    AuthenticateDesc.pBuffers = &AuthenticateBuffer;

    AuthenticateBuffer.cbBuffer = MaxToken;
    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
    AuthenticateBuffer.pvBuffer = OutgoingMessage + 8;

    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = SWAP_DWORD(((ULONG UNALIGNED *)IncomingMessage)[1]);
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN | SECBUFFER_READONLY;
    ChallengeBuffer.pvBuffer = IncomingMessage + 8;

    SecStatus = InitializeSecurityContextA(
                    NULL,
                    &TftpClientContextHandle,
                    NULL,
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    &ChallengeDesc,
                    0,                  // Reserved 2
                    &TftpClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( (SecStatus != SEC_E_OK) ) {
        DPRINT( ERROR, ("InitializeSecurityContext (Authenticate): %d\n", SecStatus) );
        return (RtlMapSecurityErrorToNtStatus(SecStatus));
    }

    //
    // Send the authenticate buffer to the server and wait for the response.
    //

    ((USHORT UNALIGNED *)OutgoingMessage)[0] = SWAP_WORD(0x10);   // TFTP packet type 16
    ((USHORT UNALIGNED *)OutgoingMessage)[1] = SWAP_WORD(0x00);   // sequence number 0

    ((ULONG UNALIGNED *)OutgoingMessage)[1] = SWAP_DWORD(AuthenticateBuffer.cbBuffer);

    Status = UdpSendAndReceiveForTftp(
                OutgoingMessage,
                AuthenticateBuffer.cbBuffer + 8,
                ServerIpAddress,
                RemotePort,  // send it to whatever port he sent from
                10,        // retry count
                IncomingMessage,
                MaxToken + 8,
                &RemoteHost,
                &RemotePort,
                5,         // receive timeout
                1);     // sequence number (but we really expect 0xffff)

    if ( !NT_SUCCESS(Status) ) {
        DPRINT( ERROR, ("UdpSendAndReceiveForTftp status is %x\n", Status) );
        return Status;
    }

    if (((USHORT UNALIGNED *)IncomingMessage)[1] == SWAP_WORD(0xffff)) {

        //
        // Send a response to the server, but don't bother trying to
        // resend it, since if he doesn't see it he eventually
        // times out.
        //

        ((USHORT UNALIGNED *)OutgoingMessage)[0] = SWAP_WORD(0x10);   // TFTP packet type 16
        ((USHORT UNALIGNED *)OutgoingMessage)[1] = SWAP_WORD(0xffff);   // sequence number 0

        UdpSend(
            OutgoingMessage,
            4,
            ServerIpAddress,
            RemotePort);

        //
        // Parse the result to see if we succeeded. 
        //

        OptionLoc = IncomingMessage + 4;

        if (memcmp(OptionLoc, "status", 6) != 0) {
            DPRINT( ERROR, ("Login response has no status!!\n") );
            status = STATUS_UNEXPECTED_NETWORK_ERROR;
        }

        OptionLoc += strlen("status") + 1;

        remoteStatus = ConnSafeAtol(OptionLoc, OptionLoc+20);  // end doesn't matter because it is NULL-terminated

        if (remoteStatus == STATUS_SUCCESS) {

            OptionLoc += strlen(OptionLoc) + 1;

            if (memcmp(OptionLoc, "handle", 6) != 0) {
                DPRINT( ERROR, ("Login success response has no handle!!\n") );
                status = STATUS_UNEXPECTED_NETWORK_ERROR;
            } else {
                OptionLoc += strlen("handle") + 1;
                *LoginHandle = ConnSafeAtol(OptionLoc, OptionLoc+20);     // end doesn't matter because it is NULL-terminated
                DPRINT( ERROR, ("TftpLogin SUCCESS, remoteHandle %d\n", *LoginHandle) );
                status = STATUS_SUCCESS;
            }

        } else {
            DPRINT( ERROR, ("Login reported failure %x\n", remoteStatus) );
            status = remoteStatus;
        }

    } else {

        DPRINT( ERROR, ("Got strange response to negotiate!!\n") );
        status = STATUS_UNEXPECTED_NETWORK_ERROR;

    }

    return status;

} // TftpLogin


NTSTATUS
TftpLogoff (
    IN ULONG ServerIpAddress,
    IN ULONG LoginHandle
    )
{
    SECURITY_STATUS SecStatus;
    NTSTATUS status;
    ULONG Status;
    ULONG stringSize;
    PUCHAR options;
    ULONG length;
    ULONG RemoteHost;
    USHORT RemotePort;

#if defined(REMOTE_BOOT)
    if (!NetworkBootRom) {

        //  Booting from the hard disk cache because server is not available
        return STATUS_UNSUCCESSFUL;
    }
#endif // defined(REMOTE_BOOT)

    //
    // Delete both contexts if needed.
    //

    if (TftpClientContextHandleValid) {

        SecStatus = DeleteSecurityContext( &TftpClientContextHandle );
        TftpClientContextHandleValid = FALSE;

    }

    if (CredentialHandleValid) {

        SecStatus = FreeCredentialsHandle( &CredentialHandle );
        CredentialHandleValid = FALSE;

    }

    //
    // Send the logoff message to the server.
    //

    ((USHORT UNALIGNED *)OutgoingMessage)[0] = SWAP_WORD(0x10);   // TFTP packet type 16

    memcpy(OutgoingMessage+2, "logoff", 7);  // copy the final \0 also
    strcpy(OutgoingMessage+9, NTLMSP_NAME_A);

    // allow 9 for the type and "logoff", then NTLMSP_NAME_A + 1 for the \0.
    length= 9 + strlen(NTLMSP_NAME_A) + 1;
    options = OutgoingMessage + length;

    strcpy( options, "security" );
    length += sizeof("security");
    options += sizeof("security");
    stringSize = ConnItoa( LoginHandle, options );
    length += stringSize;
    options += stringSize;


    Status = UdpSendAndReceiveForTftp(
                OutgoingMessage,
                length,
                ServerIpAddress,
                TFTP_PORT,
                3,        // retry count
                IncomingMessage,
                512,      // size - we don't expect a big response
                &RemoteHost,
                &RemotePort,
                2,         // receive timeout
                0);     // sequence number (but we really expect 0xffff)

    if ( !NT_SUCCESS(Status) ) {
        DPRINT( ERROR, ("UdpSendAndReceiveForTftp status is %d\n", Status) );
        return STATUS_UNEXPECTED_NETWORK_ERROR;
    }

    if (((USHORT UNALIGNED *)IncomingMessage)[1] == SWAP_WORD(0xffff)) {

        //
        // Send a response to the server, but don't bother trying to
        // resend it, since if he doesn't see it he eventually
        // times out.
        //

        ((USHORT UNALIGNED *)OutgoingMessage)[0] = SWAP_WORD(0x10);   // TFTP packet type 16
        ((USHORT UNALIGNED *)OutgoingMessage)[1] = SWAP_WORD(0xffff);   // sequence number 0

        UdpSend(
            OutgoingMessage,
            4,
            ServerIpAddress,
            RemotePort);

        //
        // The status code follows the 0xffff, but for the moment we
        // don't care.
        //

        DPRINT( ERROR, ("TftpLogoff SUCCESS, remoteHandle %d\n", LoginHandle) );

        status = STATUS_SUCCESS;

    } else {

        DPRINT( ERROR, ("Got strange response to logoff!!\n") );
        status = STATUS_UNEXPECTED_NETWORK_ERROR;

    }

    return status;

} // TftpLogoff


NTSTATUS
TftpSignString (
    IN PUCHAR String,
    OUT PUCHAR * Sign,
    OUT ULONG * SignLength
    )
{
    SECURITY_STATUS SecStatus;
    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    static UCHAR StaticSign[NTLMSSP_MESSAGE_SIGNATURE_SIZE];

    //
    // Sign the name and send that, to make sure it is not changed.
    //

    SigBuffers[1].pvBuffer = StaticSign;
    SigBuffers[1].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = String;
    SigBuffers[0].cbBuffer = strlen(String);
    SigBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    ASSERT (TftpClientContextHandleValid);

    SecStatus = MakeSignature(
                        &TftpClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != SEC_E_OK ) {
        DPRINT( ERROR, ("TftpSignString: MakeSignature: %lx\n", SecStatus) );
        return STATUS_UNEXPECTED_NETWORK_ERROR;
    }

    *Sign = StaticSign;
    *SignLength = NTLMSSP_MESSAGE_SIGNATURE_SIZE;

    return STATUS_SUCCESS;

}
#endif // defined(REMOTE_BOOT_SECURITY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\tftplib\helper.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    helper.c

Abstract:

    Helper functions for the loader.

Author:

    Adam Barr (adamba)              Aug 29, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    adamba      08-29-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#include <pxe_cmn.h>
#include <pxe_api.h>
#include <undi_api.h>
#include <ntexapi.h>

#ifdef EFI
#define BINL_PORT   0x0FAB    // 4011 (decimal) in little-endian
#else
#define BINL_PORT   0xAB0F    // 4011 (decimal) in big-endian
#endif

//
// This removes macro redefinitions which appear because we define __RPC_DOS__,
// but rpc.h defines __RPC_WIN32__
//

#pragma warning(disable:4005)

//
// As of 12/17/98, SECURITY_DOS is *not* defined - adamba
//

#if defined(SECURITY_DOS)
//
// These appear because we defined SECURITY_DOS
//

#define __far
#define __pascal
#define __loadds
#endif

#include <security.h>
#include <rpc.h>
#include <spseal.h>

#ifdef EFI
#include "bldr.h"
#include "efi.h"
#include "efip.h"
#include "bldria64.h"
#include "extern.h"
#endif

#if defined(SECURITY_DOS)
//
// PSECURITY_STRING is not supposed to be used when SECURITY_DOS is
// defined -- it should be a WCHAR*. Unfortunately ntlmsp.h breaks
// this rule and even uses the SECURITY_STRING structure, which there
// is really no equivalent for in 16-bit mode.
//

typedef SEC_WCHAR * SECURITY_STRING;   // more-or-less the intention where it is used
typedef SEC_WCHAR * PSECURITY_STRING;
#endif

#include <ntlmsp.h>


extern ULONG TftpSecurityHandle;
extern CtxtHandle TftpClientContextHandle;
extern BOOLEAN TftpClientContextHandleValid;

//
// From conn.c.
//

ULONG
ConnItoa (
    IN ULONG Value,
    OUT PUCHAR Buffer
    );

#if defined(REMOTE_BOOT_SECURITY)
ULONG
ConnAtosign (
    IN PUCHAR Buffer,
    IN ULONG SignLength,
    OUT PUCHAR Sign
    );
#endif // defined(REMOTE_BOOT_SECURITY)

ULONG
ConnSafeAtol (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    );

// for now, we pull the hack mac list and code so that we only support new ROMs

#ifdef EFI


#pragma pack(1)
typedef struct {
    UINT16      VendorId;
    UINT16      DeviceId;
    UINT16      Command;
    UINT16      Status;
    UINT8       RevisionID;
    UINT8       ClassCode[3];
    UINT8       CacheLineSize;
    UINT8       LaytencyTimer;
    UINT8       HeaderType;
    UINT8       BIST;
} PCI_DEVICE_INDEPENDENT_REGION;

typedef struct {
    UINT32      Bar[6];
    UINT32      CISPtr;
    UINT16      SubsystemVendorID;
    UINT16      SubsystemID;
    UINT32      ExpansionRomBar;
    UINT32      Reserved[2];
    UINT8       InterruptLine;
    UINT8       InterruptPin;
    UINT8       MinGnt;
    UINT8       MaxLat;     
} PCI_DEVICE_HEADER_TYPE_REGION;

typedef struct {
    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
    PCI_DEVICE_HEADER_TYPE_REGION   Device;
} PCI_TYPE00;



NTSTATUS
NetQueryCardInfo(
    IN OUT PNET_CARD_INFO CardInfo
    )

/*++

Routine Description:

    This routine queries the ROM for information about the card.

Arguments:

    CardInfo - returns the structure defining the card.

Return Value:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL

--*/

{

    EFI_STATUS              Status = EFI_UNSUPPORTED;
    EFI_DEVICE_PATH         *DevicePath = NULL;
    EFI_DEVICE_PATH         *OriginalRootDevicePath = NULL;
    EFI_DEVICE_PATH_ALIGNED DevicePathAligned;
    UINT16                  BusNumber = 0;
    UINT8                   DeviceNumber = 0;
    UINT8                   FunctionNumber = 0;
    BOOLEAN                 FoundACPIDevice = FALSE;
    BOOLEAN                 FoundPCIDevice = FALSE;
    EFI_GUID                DeviceIoProtocol = DEVICE_IO_PROTOCOL;
    EFI_HANDLE              MyHandle;
    EFI_DEVICE_IO_INTERFACE *IoDev;




    RtlZeroMemory(CardInfo, sizeof(NET_CARD_INFO));



    //
    // Get the device path for the NIC that we're using for PXE.
    //
    FlipToPhysical();
    Status = EfiST->BootServices->HandleProtocol( PXEHandle,
                                                  &EfiDevicePathProtocol,
                                                  &DevicePath );
    FlipToVirtual();
    if( Status != EFI_SUCCESS ) {
        DbgPrint( "NetQueryCardInfo: HandleProtocol(1) failed (%x)\n", Status);
        return (ARC_STATUS)Status;
    }

    FlipToPhysical();
    EfiAlignDp( &DevicePathAligned,
                DevicePath,
                DevicePathNodeLength(DevicePath));

    FlipToVirtual();

    
    //
    // Save off this root DevicePath in case we need it later.
    //
    OriginalRootDevicePath = DevicePath;


    //
    // Now we need to read the PCI header information from the specific
    // card.  To do that, we need to dig out the BusNumber, DeviceNumber and
    // FunctionNumber that help describe this PCI device.
    //
    
    //
    // AcpiDevicePath = (ACPI_HID_DEVICE_PATH *)&DevicePathAligned;
    // BusNumber = AcpiDevicePath->UID
    //
    // PciDevicePath = (PCI_DEVICE_PATH *)&DevicePathAligned;
    // DeviceNumber = PciDevicePath->Device
    // FunctionNumber = PciDevicePath->Function
    //

    FlipToPhysical();
    while( DevicePathAligned.DevPath.Type != END_DEVICE_PATH_TYPE ) {

        if( (DevicePathAligned.DevPath.Type == ACPI_DEVICE_PATH) &&
            (DevicePathAligned.DevPath.SubType == ACPI_DP) ) {

            //
            // We'll find the BusNumber here.
            //
            ACPI_HID_DEVICE_PATH *AcpiDevicePath;
            
            AcpiDevicePath = (ACPI_HID_DEVICE_PATH *)&DevicePathAligned;
            BusNumber = (UINT16)AcpiDevicePath->UID;
            FoundACPIDevice = TRUE;
        }


        if( (DevicePathAligned.DevPath.Type == HARDWARE_DEVICE_PATH) &&
            (DevicePathAligned.DevPath.SubType == HW_PCI_DP) ) {

            //
            // We'll find the BusNumber here.
            //
            PCI_DEVICE_PATH *PciDevicePath;
            
            PciDevicePath = (PCI_DEVICE_PATH *)&DevicePathAligned;
            DeviceNumber = PciDevicePath->Device;
            FunctionNumber = PciDevicePath->Function;
            FoundPCIDevice = TRUE;
        }
    
        //
        // Get the next structure in our packed array.
        //
        DevicePath = NextDevicePathNode( DevicePath );

        EfiAlignDp(&DevicePathAligned,
                   DevicePath,
                   DevicePathNodeLength(DevicePath));
    
    
    }
    FlipToVirtual();


    
    //
    // Derive the function pointer that will allow us to read from
    // PCI space.
    //
    DevicePath = OriginalRootDevicePath;
    FlipToPhysical();
    Status = EfiST->BootServices->LocateDevicePath( &DeviceIoProtocol,
                                                    &DevicePath,
                                                    &MyHandle );
    FlipToVirtual();
    if( Status != EFI_SUCCESS ) {
        DbgPrint( "NetQueryCardInfo: LocateDevicePath failed (%X)\n", Status);
        return (ARC_STATUS)Status;
    }

    FlipToPhysical();
    Status = EfiST->BootServices->HandleProtocol( MyHandle,
                                                  &DeviceIoProtocol,
                                                  (VOID*)&IoDev );
    FlipToVirtual();

    if( Status != EFI_SUCCESS ) {
        DbgPrint( "NetQueryCardInfo: HandleProtocol(2) failed (%X)\n", Status);
        return (ARC_STATUS)Status;
    }





    //
    // We've got the Bus, Device, and Function number for this device.  Go read
    // his header (with the PCI-Read function that we just derived) and get
    // the information we're after.
    //
    if( FoundPCIDevice && FoundACPIDevice ) {
        UINT64                  Address;
        PCI_TYPE00              Pci;
        
        DbgPrint( "NetQueryCardInfo: Found all the config info for the device.\n" );
        DbgPrint( "                  BusNumber: %d  DeviceNumber: %d  FunctionNumber: %d\n", BusNumber, DeviceNumber, FunctionNumber );
        
        //
        // Generate the address, then read the PCI header from the device.
        //
        Address = EFI_PCI_ADDRESS( BusNumber, DeviceNumber, FunctionNumber );
        
        RtlZeroMemory(&Pci, sizeof(PCI_TYPE00));


        FlipToPhysical();
        Status = IoDev->Pci.Read( IoDev,
                                  IO_UINT32,
                                  Address,
                                  sizeof(PCI_TYPE00) / sizeof(UINT32),
                                  &Pci );
        FlipToVirtual();
        if( Status != EFI_SUCCESS ) {
            DbgPrint( "NetQueryCardInfo: Pci.Read failed (%X)\n", Status);
            return (ARC_STATUS)Status;
        }

        //
        // It all worked.  Copy the information from the device into
        // the CardInfo structure and exit.
        //

        CardInfo->NicType = 2;          // He's PCI
        CardInfo->pci.Vendor_ID = Pci.Hdr.VendorId;
        CardInfo->pci.Dev_ID = Pci.Hdr.DeviceId;
        CardInfo->pci.Rev = Pci.Hdr.RevisionID;
        
        // SubSys_ID is actually ((SubsystemID << 16) | SubsystemVendorID)
        CardInfo->pci.Subsys_ID = Pci.Device.SubsystemID;
        CardInfo->pci.Subsys_ID = (CardInfo->pci.Subsys_ID << 16) | (Pci.Device.SubsystemVendorID);

#if DBG
        DbgPrint( "\n" );
        DbgPrint( "NetQueryCardInfo: Pci.Hdr.VendorId %x\n", Pci.Hdr.VendorId );
        DbgPrint( "                  Pci.Hdr.DeviceId %x\n", Pci.Hdr.DeviceId );
        DbgPrint( "                  Pci.Hdr.Command %x\n", Pci.Hdr.Command );
        DbgPrint( "                  Pci.Hdr.Status %x\n", Pci.Hdr.Status );
        DbgPrint( "                  Pci.Hdr.RevisionID %x\n", Pci.Hdr.RevisionID );
        DbgPrint( "                  Pci.Hdr.HeaderType %x\n", Pci.Hdr.HeaderType );
        DbgPrint( "                  Pci.Hdr.BIST %x\n", Pci.Hdr.BIST );
        DbgPrint( "                  Pci.Device.SubsystemVendorID %x\n", Pci.Device.SubsystemVendorID );    
        DbgPrint( "                  Pci.Device.SubsystemID %x\n", Pci.Device.SubsystemID );    
        DbgPrint( "\n" );
        
        DbgPrint( "NetQueryCardInfo: CardInfo->NicType %x\n", CardInfo->NicType );
        DbgPrint( "                  CardInfo->pci.Vendor_ID %x\n", CardInfo->pci.Vendor_ID );
        DbgPrint( "                  CardInfo->pci.Dev_ID %x\n", CardInfo->pci.Dev_ID );
        DbgPrint( "                  CardInfo->pci.Rev %x\n", CardInfo->pci.Rev );
        DbgPrint( "                  CardInfo->pci.Subsys_ID %x\n", CardInfo->pci.Subsys_ID );
        DbgPrint( "\n" );
#endif

        Status = STATUS_SUCCESS;

    } else {
        
        DbgPrint( "NetQueryCardInfo: Failed to find all the config info for the device.\n" );
    }


    return STATUS_SUCCESS;


}


#else

NTSTATUS
NetQueryCardInfo(
    IN OUT PNET_CARD_INFO CardInfo
    )

/*++

Routine Description:

    This routine queries the ROM for information about the card.

Arguments:

    CardInfo - returns the structure defining the card.

Return Value:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL

--*/

{
    ULONG status;
    t_PXENV_UNDI_GET_NIC_TYPE nicType;

    RtlZeroMemory(CardInfo, sizeof(NET_CARD_INFO));

    status = RomGetNicType( &nicType );
    if ((status != PXENV_EXIT_SUCCESS) || (nicType.Status != PXENV_EXIT_SUCCESS)) {

#if DBG
        DbgPrint( "RomGetNicType returned 0x%x, nicType.Status = 0x%x. Time to upgrade your netcard ROM\n",
                    status, nicType.Status );
#endif
        status = STATUS_UNSUCCESSFUL;

    } else {

#if DBG
        if ( nicType.NicType == 2 ) {
            DbgPrint( "Vendor_ID: %04x, Dev_ID: %04x\n",
                        nicType.pci_pnp_info.pci.Vendor_ID,
                        nicType.pci_pnp_info.pci.Dev_ID );
            DbgPrint( "Base_Class: %02x, Sub_Class: %02x, Prog_Intf: %02x\n",
                        nicType.pci_pnp_info.pci.Base_Class,
                        nicType.pci_pnp_info.pci.Sub_Class,
                        nicType.pci_pnp_info.pci.Prog_Intf );
            DbgPrint( "Rev: %02x, BusDevFunc: %04x, SubSystem: %04x\n",
                        nicType.pci_pnp_info.pci.Rev,
                        nicType.pci_pnp_info.pci.BusDevFunc,
                        nicType.pci_pnp_info.pci.Subsys_ID );
        } else {
            DbgPrint( "NicType: 0x%x  EISA_Dev_ID: %08x\n",
                        nicType.NicType,
                        nicType.pci_pnp_info.pnp.EISA_Dev_ID );
            DbgPrint( "Base_Class: %02x, Sub_Class: %02x, Prog_Intf: %02x\n",
                        nicType.pci_pnp_info.pnp.Base_Class,
                        nicType.pci_pnp_info.pnp.Sub_Class,
                        nicType.pci_pnp_info.pnp.Prog_Intf );
            DbgPrint( "CardSelNum: %04x\n",
                        nicType.pci_pnp_info.pnp.CardSelNum );
        }
#endif
        //
        // The call worked, so copy the information.
        //

        CardInfo->NicType = nicType.NicType;
        if (nicType.NicType == 2) {

            CardInfo->pci.Vendor_ID = nicType.pci_pnp_info.pci.Vendor_ID;
            CardInfo->pci.Dev_ID = nicType.pci_pnp_info.pci.Dev_ID;
            CardInfo->pci.Base_Class = nicType.pci_pnp_info.pci.Base_Class;
            CardInfo->pci.Sub_Class = nicType.pci_pnp_info.pci.Sub_Class;
            CardInfo->pci.Prog_Intf = nicType.pci_pnp_info.pci.Prog_Intf;
            CardInfo->pci.Rev = nicType.pci_pnp_info.pci.Rev;
            CardInfo->pci.BusDevFunc = nicType.pci_pnp_info.pci.BusDevFunc;
            CardInfo->pci.Subsys_ID = nicType.pci_pnp_info.pci.Subsys_ID;

            status = STATUS_SUCCESS;

        } else {

            status = STATUS_UNSUCCESSFUL;
        }
    }

    return status;
}

#endif  // EFI

NTSTATUS
UdpSendAndReceiveForNetQuery(
    IN PVOID SendBuffer,
    IN ULONG SendBufferLength,
    IN ULONG SendRemoteHost,
    IN USHORT SendRemotePort,
    IN ULONG SendRetryCount,
    IN PVOID ReceiveBuffer,
    IN ULONG ReceiveBufferLength,
    IN ULONG ReceiveTimeout,
    IN ULONG ReceiveSignatureCount,
    IN PCHAR ReceiveSignatures[]
    )
{
    ULONG i, j;
    ULONG length;
    ULONG RemoteHost;
    USHORT RemotePort;

    //
    // Try sending the packet SendRetryCount times, until we receive
    // a response with the right signature, waiting ReceiveTimeout
    // each time.
    //

    for (i = 0; i < SendRetryCount; i++) {

        length = UdpSend(
                    SendBuffer,
                    SendBufferLength,
                    SendRemoteHost,
                    SendRemotePort);

        if ( length != SendBufferLength ) {
            DbgPrint("UdpSend only sent %d bytes, not %d\n", length, SendBufferLength);
            return STATUS_UNEXPECTED_NETWORK_ERROR;
        }

ReReceive:

        //
        // NULL out the first 12 bytes in case we get shorter data.
        //

        memset(ReceiveBuffer, 0x0, 12);

        length = UdpReceive(
                    ReceiveBuffer,
                    ReceiveBufferLength,
                    &RemoteHost,
                    &RemotePort,
                    ReceiveTimeout);

        if ( length == 0 ) {
            DPRINT( ERROR, ("UdpReceive timed out\n") );
            continue;
        }

        //
        // Make sure the signature is one of the ones we expect.
        //

        for (j = 0; j < ReceiveSignatureCount; j++) {
            if (memcmp(ReceiveBuffer, ReceiveSignatures[j], 4) == 0) {
                return STATUS_SUCCESS;
            }
        }

        DbgPrint("UdpReceive got wrong signature\n");

        // ISSUE NTRAID #60513: CLEAN THIS UP -- but the idea is not to UdpSend
        // again just because we got a bad signature. Still need to respect the
        // original ReceiveTimeout however!

        goto ReReceive;

    }

    //
    // We timed out.
    //

    return STATUS_IO_TIMEOUT;
}

#define NETCARD_REQUEST_RESPONSE_BUFFER_SIZE    4096
UCHAR   NetCardResponseBuffer[NETCARD_REQUEST_RESPONSE_BUFFER_SIZE];

NTSTATUS
NetQueryDriverInfo(
    IN PNET_CARD_INFO CardInfo,
    IN PCHAR SetupPath,
    IN PCHAR NtBootPathName,
    IN OUT PWCHAR HardwareId,
    IN ULONG HardwareIdLength,
    IN OUT PWCHAR DriverName,
    IN OUT PCHAR DriverNameAnsi OPTIONAL,
    IN ULONG DriverNameLength,
    IN OUT PWCHAR ServiceName,
    IN ULONG ServiceNameLength,
    OUT PCHAR * Registry,
    OUT ULONG * RegistryLength
    )

/*++

Routine Description:

    This routine does an exchange with the server to get information
    about the card described by CardInfo.

Arguments:

    CardInfo - Information about the card.

    SetupPath - UNC path (with only a single leading backslash) to our setup directory

    NtBootPathName - UNC path (with only a single leading backslash) to our boot directory

    HardwareId - returns the hardware ID of the card.

    HardwareIdLength - the length (in bytes) of the passed-in HardwareId buffer.

    DriverName - returns the name of the driver.

    DriverNameAnsi - if present, returns the name of the driver in ANSI.

    DriverNameLength - the length (in bytes) of the passed-in DriverName buffer
        (it is assumed that DriverNameAnsi is at least half this length).

    ServiceName - returns the service key of the driver.

    ServiceNameLength - the length (in bytes) of the passed-in ServiceName buffer.

    Registry - if needed, allocates and returns extra registry parameters
        for the card.

    RegistryLength - the length of Registry.

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_OVERFLOW if either of the buffers are too small.
    STATUS_INSUFFICIENT_RESOURCES if we cannot allocate memory for Registry.
    STATUS_IO_TIMEOUT if we can't get a response from the server.

--*/

{
    NTSTATUS Status;
    USHORT localPort;
    PNETCARD_REQUEST_PACKET requestPacket;
    PCHAR ReceiveSignatures[2];
    PCHAR ReceiveBuffer;
    ULONG GuidLength;
    PUCHAR Guid;
    ULONG sendSize;
    PNETCARD_REQUEST_PACKET allocatedRequestPacket = NULL;


    //
    // Get the local UDP port.
    //

    localPort = UdpUnicastDestinationPort;

    //
    // Now construct the outgoing packet.
    //


    //
    // Don't allocate ReceiveBuffer.  We're about to call UdpSend, and he's
    // going to want a physical address on ia64.  If we just use a static
    // here, the virtual-physical mapping will be 1-to-1.  This isn't a big
    // deal since the allocation is hardcoded to NETCARD_REQUEST_RESPONSE_BUFFER_SIZE
    // and is never freed anyway.
    //
    //    ReceiveBuffer = BlAllocateHeap( NETCARD_REQUEST_RESPONSE_BUFFER_SIZE );
    //
    ReceiveBuffer = NetCardResponseBuffer;

    if (ReceiveBuffer == NULL) {

        return STATUS_BUFFER_OVERFLOW;
    }

    requestPacket = (PNETCARD_REQUEST_PACKET) ReceiveBuffer;

    RtlCopyMemory(requestPacket->Signature, NetcardRequestSignature, sizeof(requestPacket->Signature));
    requestPacket->Length = sizeof(NETCARD_REQUEST_PACKET) - FIELD_OFFSET(NETCARD_REQUEST_PACKET, Version);
    requestPacket->Version = OSCPKT_NETCARD_REQUEST_VERSION;

#if defined(_ALPHA_)
#if defined(_AXP64)
    requestPacket->Architecture = PROCESSOR_ARCHITECTURE_ALPHA64;
#else
    requestPacket->Architecture = PROCESSOR_ARCHITECTURE_ALPHA;
#endif
#endif
#if defined(_MIPS_)
    requestPacket->Architecture = PROCESSOR_ARCHITECTURE_MIPS;
#endif
#if defined(_PPC_)
    requestPacket->Architecture = PROCESSOR_ARCHITECTURE_PPC;
#endif
#if defined(_IA64_)
    requestPacket->Architecture = PROCESSOR_ARCHITECTURE_IA64;
#endif
#if defined(_X86_)
    requestPacket->Architecture = PROCESSOR_ARCHITECTURE_INTEL;
#endif

    requestPacket->SetupDirectoryLength = SetupPath ? (strlen( SetupPath ) + 1) : 0;

#if defined(REMOTE_BOOT)
    if (NtBootPathName != NULL) {

        ULONG bufferOffset;

        requestPacket->FileCheckAndCopy = (ULONG)TRUE;

        //
        //  make it a fully qualified UNC by sticking on a leading slash and
        //  appending the "\system32\drivers" to form the full drivers
        //  directory path.
        //

        requestPacket->DriverDirectoryLength = sizeof( "\\\\System32\\Drivers" );
        requestPacket->DriverDirectoryLength += strlen( NtBootPathName );

        sendSize = sizeof(NETCARD_REQUEST_PACKET) +
                requestPacket->DriverDirectoryLength +
                requestPacket->SetupDirectoryLength;

        requestPacket->DriverDirectoryPath[0] = '\\';
        strcpy( &requestPacket->DriverDirectoryPath[1], NtBootPathName );
        strcat( requestPacket->DriverDirectoryPath, "\\SYSTEM32\\DRIVERS" );

        bufferOffset = strlen( requestPacket->DriverDirectoryPath ) + 1;

        if (requestPacket->SetupDirectoryLength) {

            requestPacket->DriverDirectoryPath[bufferOffset++] = '\\';
            strcpy( &requestPacket->DriverDirectoryPath[bufferOffset], SetupPath );
        }

    } else {

        requestPacket->FileCheckAndCopy = (ULONG)FALSE;
        requestPacket->DriverDirectoryLength = 0;
#endif

        sendSize = sizeof(NETCARD_REQUEST_PACKET) + requestPacket->SetupDirectoryLength;

        if (requestPacket->SetupDirectoryLength) {

            requestPacket->SetupDirectoryPath[0] = '\\';
            strcpy( &requestPacket->SetupDirectoryPath[1], SetupPath );
        }

#if defined(REMOTE_BOOT)
    }
#endif

    GetGuid(&Guid, &GuidLength);
    
    if (GuidLength == sizeof(requestPacket->Guid)) {        
        memcpy(requestPacket->Guid, Guid, GuidLength);
    }
    RtlCopyMemory(&requestPacket->CardInfo, CardInfo, sizeof(NET_CARD_INFO));

    ReceiveSignatures[0] = NetcardResponseSignature;
    ReceiveSignatures[1] = NetcardErrorSignature;

    Status = UdpSendAndReceiveForNetQuery(
                 requestPacket,
                 sendSize,
                 NetServerIpAddress,
                 BINL_PORT,
                 4,             // retry count
                 ReceiveBuffer,
                 NETCARD_REQUEST_RESPONSE_BUFFER_SIZE,
                 60,            // receive timeout... may have to parse INF files
                 2,
                 ReceiveSignatures
                 );

    if (Status == STATUS_SUCCESS) {

        PWCHAR stringInPacket;
        ULONG maxOffset;
        UNICODE_STRING uString;
        ULONG len;
        PNETCARD_RESPONSE_PACKET responsePacket;

        responsePacket = (PNETCARD_RESPONSE_PACKET)ReceiveBuffer;

        if (responsePacket->Status != STATUS_SUCCESS) {
            return responsePacket->Status;
        }

        if (responsePacket->Length < sizeof( NETCARD_RESPONSE_PACKET )) {
            return STATUS_UNSUCCESSFUL;
        }

        //
        // The exchange succeeded, so copy the results back.
        //

        maxOffset = NETCARD_REQUEST_RESPONSE_BUFFER_SIZE -
                    sizeof( NETCARD_RESPONSE_PACKET );

        if (responsePacket->HardwareIdOffset < sizeof(NETCARD_RESPONSE_PACKET) ||
            responsePacket->HardwareIdOffset >= maxOffset ) {

            return STATUS_BUFFER_OVERFLOW;
        }

        //
        //  pick up the hardwareId string.  It's given to us as an offset
        //  within the packet to a unicode null terminated string.
        //

        stringInPacket = (PWCHAR)(PCHAR)((PCHAR)responsePacket +
                                   responsePacket->HardwareIdOffset );

        RtlInitUnicodeString( &uString, stringInPacket );

        if (uString.Length + sizeof(WCHAR) > HardwareIdLength) {
            return STATUS_BUFFER_OVERFLOW;
        }

        RtlCopyMemory( HardwareId, uString.Buffer, uString.Length + sizeof(WCHAR));

        //
        //  pick up the driverName string.  It's given to us as an offset
        //  within the packet to a unicode null terminated string.
        //

        stringInPacket = (PWCHAR)(PCHAR)((PCHAR)responsePacket +
                                   responsePacket->DriverNameOffset );

        RtlInitUnicodeString( &uString, stringInPacket );

        if (uString.Length + sizeof(WCHAR) > DriverNameLength) {
            return STATUS_BUFFER_OVERFLOW;
        }

        RtlCopyMemory( DriverName, uString.Buffer, uString.Length + sizeof(WCHAR));

        //
        //  we convert this one into ansi if the caller requested
        //

        if (ARGUMENT_PRESENT(DriverNameAnsi)) {

            RtlUnicodeToMultiByteN( DriverNameAnsi,
                                    DriverNameLength,
                                    NULL,
                                    uString.Buffer,
                                    uString.Length + sizeof(WCHAR));
        }

        //
        //  pick up the serviceName string.  It's given to us as an offset
        //  within the packet to a unicode null terminated string.
        //

        stringInPacket = (PWCHAR)(PCHAR)((PCHAR)responsePacket +
                                   responsePacket->ServiceNameOffset );

        RtlInitUnicodeString( &uString, stringInPacket );

        if (uString.Length + sizeof(WCHAR) > ServiceNameLength) {
            return STATUS_BUFFER_OVERFLOW;
        }

        RtlCopyMemory( ServiceName, uString.Buffer, uString.Length + sizeof(WCHAR));

        //
        // If any extra registry params were passed back, allocate/copy those.
        //

        *RegistryLength = responsePacket->RegistryLength;

        if (*RegistryLength) {

            *Registry = BlAllocateHeap(*RegistryLength);
            if (*Registry == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            stringInPacket = (PWCHAR)(PCHAR)((PCHAR)responsePacket +
                                       responsePacket->RegistryOffset );

            RtlCopyMemory(*Registry, stringInPacket, *RegistryLength);

        } else {

            *Registry = NULL;
        }
    }

    return Status;

}

#if defined(REMOTE_BOOT)
NTSTATUS
UdpSendAndReceiveForIpsec(
    IN PVOID SendBuffer,
    IN ULONG SendBufferLength,
    IN ULONG SendRemoteHost,
    IN USHORT SendRemotePort,
    IN PVOID ReceiveBuffer,
    IN ULONG ReceiveBufferLength,
    IN ULONG ReceiveTimeout
    )
{
    ULONG i, j;
    ULONG length;
    ULONG RemoteHost;
    USHORT RemotePort;

    length = UdpSend(
                SendBuffer,
                SendBufferLength,
                SendRemoteHost,
                SendRemotePort);

    if ( length != SendBufferLength ) {
        DbgPrint("UdpSend only sent %d bytes, not %d\n", length, SendBufferLength);
        return STATUS_UNEXPECTED_NETWORK_ERROR;
    }

    length = UdpReceive(
                ReceiveBuffer,
                ReceiveBufferLength,
                &RemoteHost,
                &RemotePort,
                ReceiveTimeout);

    if ( length == 0 ) {
        DPRINT( ERROR, ("UdpReceive timed out\n") );
        return STATUS_IO_TIMEOUT;
    }

    return STATUS_SUCCESS;

}

ULONG
ConnItoa (
    IN ULONG Value,
    OUT PUCHAR Buffer
    );

ULONG
ConnSafeAtol (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    );

NTSTATUS
NetPrepareIpsec(
    IN ULONG InboundSpi,
    OUT ULONG * SessionKey,
    OUT ULONG * OutboundSpi
    )

/*++

Routine Description:

    This routine does an exchange with the server to set up for a future
    IPSEC conversation. We pass him the SPI we will use for our inbound
    conversation (from the server to us). He replies with the the session
    key that he has generated and the outbound SPI he has gotten (for the
    conversation from us to him). We also return the IP address of the
    server in this call.

Arguments:

    InboundSpi - The SPI for the conversation from the server to us. This
        is typically generated by the caller, and will later be passed to
        IPSEC in an IOCTL_IPSEC_SET_SPI.

    SessionKey - Returns the server-generated session key.

    OutboundSpi - The server will take the information we give him and
        call IOCTL_IPSEC_GET_SPI, this returns the SPI he is assigned for
        the conversation from us to the server.

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_OVERFLOW if either of the buffers are too small.
    STATUS_INSUFFICIENT_RESOURCES if we cannot allocate memory for Registry.
    STATUS_IO_TIMEOUT if we can't get a response from the server.

--*/

{
    NTSTATUS Status;
    USHORT localPort;
    CHAR SendBuffer[128];
    PCHAR SendBufferLoc;
    PCHAR ReceiveSignatures[2];
    CHAR ReceiveBuffer[512];
    CHAR SignBuffer[NTLMSSP_MESSAGE_SIGNATURE_SIZE];
    CHAR KeyBuffer[4];
    ULONG SendCount = 0;
    ULONG SecurityHandle;
    ULONG Nibble;
    PUCHAR CurLoc, Options;
    BOOLEAN SpiReceived, SecurityReceived, SignReceived, KeyReceived;
    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    SECURITY_STATUS SecStatus;

    //
    // Get the local UDP port.
    //

    localPort = UdpUnicastDestinationPort;

    //
    // Loop until we get a valid response.
    //

    while (SendCount < 5) {

        //
        // Construct the outgoing TFTP packet. We increment the
        // sequence number by one each time. We have to make sure
        // that the response we receive matches our last sequence
        // numbet sent since the server may generate a new key each
        // time.
        //

        SendBuffer[0] = 0;
        SendBuffer[1] = 17;
        SendBuffer[2] = 0x00;
        SendBuffer[3] = (UCHAR)(SendCount + 1);
        SendBufferLoc = SendBuffer+4;
        strcpy(SendBufferLoc, "spi");
        SendBufferLoc += sizeof("spi");
        SendBufferLoc += ConnItoa(InboundSpi, SendBufferLoc);
#if defined(REMOTE_BOOT_SECURITY)
        strcpy(SendBufferLoc, "security");
        SendBufferLoc += sizeof("security");
        SendBufferLoc += ConnItoa(TftpSecurityHandle, SendBufferLoc);
#endif // defined(REMOTE_BOOT_SECURITY)

        memset(ReceiveBuffer, 0x0, sizeof(ReceiveBuffer));

        Status = UdpSendAndReceiveForIpsec(
                     SendBuffer,
                     (ULONG)(SendBufferLoc - SendBuffer),
                     NetServerIpAddress,
                     TFTP_PORT,
                     ReceiveBuffer,
                     sizeof(ReceiveBuffer),
                     3             // receive timeout
                     );

        if (Status == STATUS_SUCCESS) {

            if ((ReceiveBuffer[1] == 17) &&
                (ReceiveBuffer[3] == (UCHAR)(SendCount+1))) {

                Options = ReceiveBuffer+4;

                SpiReceived = FALSE;
                SecurityReceived = FALSE;
                SignReceived = FALSE;
                KeyReceived = FALSE;

                while (*Options != '\0') {

                    if (strcmp(Options, "spi") == 0) {

                        Options += sizeof("spi");

                        *OutboundSpi = ConnSafeAtol(Options, ReceiveBuffer+sizeof(ReceiveBuffer));
                        if (*OutboundSpi != (ULONG)-1) {
                            SpiReceived = TRUE;
                        }
                        Options += strlen(Options) + 1;

                    } else if (strcmp(Options, "security") == 0) {

                        Options += sizeof("security");

                        SecurityHandle = ConnSafeAtol(Options, ReceiveBuffer + sizeof(ReceiveBuffer));
                        if (SecurityHandle != (ULONG)-1) {
                            SecurityReceived = TRUE;
                        }
                        Options += strlen(Options) + 1;

                    } else if (strcmp(Options, "sign") == 0) {

                        Options += sizeof("sign");
                        Options += ConnAtosign(Options, sizeof(SignBuffer), SignBuffer);
                        SignReceived = TRUE;

                    } else if (strcmp(Options, "key") == 0) {

                        Options += sizeof("key");
                        Options += ConnAtosign(Options, sizeof(KeyBuffer), KeyBuffer);
                        KeyReceived = TRUE;

                    } else {

                        //
                        // Unknown option.
                        //

                        break;

                    }

                }

#if defined(REMOTE_BOOT_SECURITY)

                if (SpiReceived && SecurityReceived && SignReceived && KeyReceived) {

                    if (SecurityHandle != TftpSecurityHandle) {

                        DbgPrint("Got incorrect security handle in response\n");
                        Status = STATUS_INVALID_HANDLE;

                    } else {

                        //
                        // Decrypt the key using the sign.
                        //

                        SigBuffers[1].pvBuffer = SignBuffer;
                        SigBuffers[1].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
                        SigBuffers[1].BufferType = SECBUFFER_TOKEN;

                        SigBuffers[0].pvBuffer = KeyBuffer;
                        SigBuffers[0].cbBuffer = sizeof(KeyBuffer);
                        SigBuffers[0].BufferType = SECBUFFER_DATA;

                        SignMessage.pBuffers = SigBuffers;
                        SignMessage.cBuffers = 2;
                        SignMessage.ulVersion = 0;

                        ASSERT (TftpClientContextHandleValid);

                        SecStatus = UnsealMessage(
                                            &TftpClientContextHandle,
                                            &SignMessage,
                                            0,
                                            0 );

                        if ( SecStatus != SEC_E_OK ) {

                            DbgPrint("NetPrepareIpsec: UnsealMessage failed %x\n", SecStatus);
                            Status = STATUS_UNEXPECTED_NETWORK_ERROR;

                        } else {

                            *SessionKey = *(PULONG)KeyBuffer;

                            DbgPrint("NetPrepareIpsec: Send SPI %d, got key %d (%lx) and response %d\n",
                                InboundSpi, *SessionKey, *SessionKey, *OutboundSpi);

                            Status = STATUS_SUCCESS;
                            break;   // exit (SendCount < 5) loop

                        }

                    }

                } else {

                    DbgPrint("Response had no SPI, security, sign, or key!\n");
                    Status = STATUS_UNSUCCESSFUL;

                }

#else // defined(REMOTE_BOOT_SECURITY)

                if (SpiReceived && KeyReceived) {

                    // if (SendCount == 0) { DbgPrint("SKIPPING!!\n"); ++SendCount; continue; }  // drop a frame to test retry

                    *SessionKey = *(PULONG)KeyBuffer;

                    DbgPrint("NetPrepareIpsec: Send SPI %d, got key %d (%lx) and response %d\n",
                        InboundSpi, *SessionKey, *SessionKey, *OutboundSpi);

                    Status = STATUS_SUCCESS;
                    break;   // exit (SendCount < 5) loop

                } else {

                    DbgPrint("Response had no SPI or key!\n");
                    Status = STATUS_UNSUCCESSFUL;

                }

#endif // defined(REMOTE_BOOT_SECURITY)

            } else {

                DbgPrint("Got bogus response from IPSEC request!!\n");
                Status = STATUS_UNSUCCESSFUL;
            }

        }

        ++SendCount;

    }

    return Status;

}
#endif // defined(REMOTE_BOOT)


#if defined(REMOTE_BOOT)
NTSTATUS
NetCopyHalAndKernel(
    IN PCHAR HalName,
    IN PCHAR Guid,
    IN ULONG GuidLength
    )

/*++

Routine Description:

    This routine takes a detected HAL name and this machine's GUID, passing them
    to the BINL server

Arguments:

    HalName - The detected Hal.

    Guid - The Guid for this machine.

    GuidLength - Number of bytes in Guid.

Return Value:

    Status - STATUS_SUCCESS if all goes well.

--*/

{
    NTSTATUS Status;
    USHORT localPort;
    HAL_REQUEST_PACKET requestPacket;
    HAL_RESPONSE_PACKET responsePacket;
    PCHAR ReceiveSignatures[1];

    //
    // Get the local UDP port.
    //

    localPort = UdpUnicastDestinationPort;

    //
    // Now construct the outgoing packet.
    //

    RtlCopyMemory(requestPacket.Signature, HalRequestSignature, sizeof(requestPacket.Signature));
    requestPacket.Length = sizeof(HAL_REQUEST_PACKET) - FIELD_OFFSET(HAL_REQUEST_PACKET, Guid);
    strcpy(requestPacket.HalName, HalName);
    memset(requestPacket.Guid, 0x0, sizeof(requestPacket.Guid));
    memcpy(requestPacket.Guid, Guid, GuidLength);
    requestPacket.GuidLength = GuidLength;

    ReceiveSignatures[0] = HalResponseSignature;

    Status = UdpSendAndReceiveForNetQuery(
                 &requestPacket,
                 sizeof(HAL_REQUEST_PACKET),
                 NetServerIpAddress,
                 BINL_PORT,
                 4,             // retry count
                 &responsePacket,
                 sizeof(responsePacket),
                 15,             // receive timeout
                 2,
                 ReceiveSignatures
                 );

    if (Status == STATUS_SUCCESS) {
        Status = responsePacket.Status;

    }

    return Status;
}
#endif // defined(REMOTE_BOOT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\tftplib\conn.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    conn.c

Abstract:

    Boot loader TFTP connection handling routines.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996
        based on code by Mike Massa (mikemas) Feb 21, 1992
        based on SpiderTCP code

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

ULONG
ConnItoa (
    IN ULONG Value,
    OUT PUCHAR Buffer
    );

#if defined(REMOTE_BOOT_SECURITY)
ULONG
ConnSigntoa (
    IN PUCHAR Sign,
    IN ULONG SignLength,
    OUT PUCHAR Buffer
    );

ULONG
ConnAtoSign (
    IN PUCHAR Buffer,
    IN ULONG SignLength,
    OUT PUCHAR Sign
    );
#endif // defined(REMOTE_BOOT_SECURITY)

ULONG
ConnSafeAtol (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    );

BOOLEAN
ConnSafeStrequal (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd,
    IN PUCHAR CompareString
    );

ULONG
ConnSafeStrsize (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    );

ULONG
ConnStrsize (
    IN PUCHAR Buffer
    );


NTSTATUS
ConnInitialize (
    IN OUT PCONNECTION *Connection,
    IN USHORT Operation,
    IN ULONG RemoteHost,
    IN USHORT RemotePort,
    IN PUCHAR Filename,
    IN ULONG BlockSize,
#if defined(REMOTE_BOOT_SECURITY)
    IN OUT PULONG SecurityHandle,
#endif // defined(REMOTE_BOOT_SECURITY)
    IN OUT PULONG FileSize
    )
//
// Open up the connection, make a request packet, and send the
// packet out on it.  Allocate space for the connection control
// block and fill it in. Allocate another packet for data and,
// on writes, another to hold received packets.  Don't wait
// for connection ack; it will be waited for in cn_rcv or cn_wrt.
// Return pointer to the connection control block, or NULL on error.
//
//

{
    NTSTATUS status;
    PCONNECTION connection;
    PTFTP_PACKET packet;
    ULONG length;
    ULONG stringSize;
    PUCHAR options;
    PUCHAR end;
    BOOLEAN blksizeAcked;
    BOOLEAN tsizeAcked;
#if defined(REMOTE_BOOT_SECURITY)
    BOOLEAN securityAcked;
    PUCHAR sign;
    ULONG signLength;
#endif // defined(REMOTE_BOOT_SECURITY)

    DPRINT( TRACE, ("ConnInitialize\n") );


#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    return STATUS_SUCCESS;
#endif

    connection = &NetTftpConnection;
    *Connection = connection;

    RtlZeroMemory( connection, sizeof(CONNECTION) );
    connection->Synced = FALSE;             // connection not synchronized yet
    connection->Operation = Operation;
    connection->RemoteHost = RemoteHost;
    connection->LocalPort = UdpAssignUnicastPort();
    connection->RemotePort = RemotePort;
    connection->Timeout = INITIAL_TIMEOUT;
    connection->Retransmissions = 0;

    connection->LastSentPacket = NetTftpPacket[0];
    connection->CurrentPacket = NetTftpPacket[1];

    if ( Operation == TFTP_RRQ ) {
        connection->LastReceivedPacket = connection->CurrentPacket;
    } else {
        connection->LastReceivedPacket = NetTftpPacket[2];
    }

    packet = connection->LastSentPacket;
    packet->Opcode = Operation;

    options = (PUCHAR)&packet->BlockNumber;     // start of file name
    strcpy( options, Filename );
    //DPRINT( LOUD, ("ConnInitialize: opening %s\n", options) );
    length = ConnStrsize( options );
    options += length;
    strcpy( options, "octet" );
    length += sizeof("octet");
    options += sizeof("octet");
    length += sizeof(packet->Opcode);

    if ( BlockSize == 0 ) {
        BlockSize = DEFAULT_BLOCK_SIZE;
    }
    strcpy( options, "blksize" );
    length += sizeof("blksize");
    options += sizeof("blksize");
    stringSize = ConnItoa( BlockSize, options );
    DPRINT( REAL_LOUD, ("ConnInitialize: requesting block size = %s\n", options) );
    length += stringSize;
    options += stringSize;

    strcpy( options, "tsize" );
    length += sizeof("tsize");
    options += sizeof("tsize");
    stringSize = ConnItoa( (Operation == TFTP_RRQ) ? 0 : *FileSize, options );
    DPRINT( REAL_LOUD, ("ConnInitialize: requesting transfer size = %s\n", options) );
    length += stringSize;
    options += stringSize;

#if defined(REMOTE_BOOT_SECURITY)
    if (*SecurityHandle) {
        strcpy( options, "security" );
        length += sizeof("security");
        options += sizeof("security");
        stringSize = ConnItoa( *SecurityHandle, options );
        DPRINT( REAL_LOUD, ("ConnInitialize: requesting security handle = %s\n", options) );
        length += stringSize;
        options += stringSize;

        //
        // Sign the name and send that, to make sure it is not changed.
        //

        if (TftpSignString(Filename, &sign, &signLength) != STATUS_SUCCESS) {
            return STATUS_UNEXPECTED_NETWORK_ERROR;
        }

        strcpy(options, "sign");
        length += sizeof("sign");
        options += sizeof("sign");
        stringSize = ConnSigntoa( sign, signLength, options );
        DPRINT( REAL_LOUD, ("ConnInitialize: using sign = %s\n", options) );
        length += stringSize;
        options += stringSize;
    }
#endif // defined(REMOTE_BOOT_SECURITY)

    ConnSendPacket( connection, packet, length );

    connection->BlockNumber = 0;
    connection->BlockSize = BlockSize;

    status = ConnWait( connection, TFTP_OACK, &packet );
    if ( NT_SUCCESS(status) ) {

        options = (PUCHAR)&packet->BlockNumber;
        end = (PUCHAR)packet + connection->LastReceivedLength;

        blksizeAcked = FALSE;
        tsizeAcked = FALSE;
#if defined(REMOTE_BOOT_SECURITY)
        securityAcked = FALSE;
#endif // defined(REMOTE_BOOT_SECURITY)

        while ( (options < end) && (!blksizeAcked || !tsizeAcked
#if defined(REMOTE_BOOT_SECURITY)
                    || !securityAcked
#endif // defined(REMOTE_BOOT_SECURITY)
                ) ) {

            if ( ConnSafeStrequal(options, end, "blksize") ) {

                options += sizeof("blksize");
                DPRINT( REAL_LOUD, ("ConnInitialize: received block size = %s\n", options) );
                BlockSize = ConnSafeAtol( options, end );
                if ( (BlockSize < 8) || (BlockSize > connection->BlockSize) ) {
                    goto bad_options;
                }
                options += ConnStrsize(options);
                connection->BlockSize = BlockSize;
                DPRINT( REAL_LOUD, ("ConnInitialize: block size for transfer = %d\n", BlockSize) );
                blksizeAcked = TRUE;

            } else if ( ConnSafeStrequal(options, end, "tsize") ) {

                options += sizeof("tsize");
                DPRINT( REAL_LOUD, ("ConnInitialize: received transfer size = %s\n", options) );
                BlockSize = ConnSafeAtol( options, end );  // use this as a temp variable
                if ( BlockSize == (ULONG)-1 ) {
                    goto bad_options;
                }
                options += ConnStrsize(options);
                if ( Operation == TFTP_RRQ ) {
                    *FileSize = BlockSize;
                }
                tsizeAcked = TRUE;

#if defined(REMOTE_BOOT_SECURITY)
            } else if ( ConnSafeStrequal(options, end, "security") ) {

                options += sizeof("security");
                DPRINT( REAL_LOUD, ("ConnInitialize: received security handle = %s\n", options) );
                BlockSize = ConnSafeAtol( options, end );  // use this as a temp variable
                if ( BlockSize == (ULONG)-1 ) {
                    goto bad_options;
                }
                options += ConnStrsize(options);
                if ( BlockSize == *SecurityHandle ) {
                    securityAcked = TRUE;
                }
#endif // defined(REMOTE_BOOT_SECURITY)

            } else {

                DPRINT( ERROR, ("ConnInitialize: skipping unrecognized option %s\n", options) );
                options += ConnSafeStrsize( options, end );
                options += ConnSafeStrsize( options, end );
            }
        }

        if ( !blksizeAcked || !tsizeAcked ) {
            goto bad_options;
        }

#if defined(REMOTE_BOOT_SECURITY)
        if ((!securityAcked) && (*SecurityHandle != 0)) {
            goto bad_options;
        }
#endif // defined(REMOTE_BOOT_SECURITY)

        if ( Operation == TFTP_RRQ ) {
            DPRINT( REAL_LOUD, ("ConnInitialize: ACKing OACK\n") );
            ConnAck( connection );
        }
    }

    return status;

bad_options:

    DPRINT( ERROR, ("ConnInitialize: bad options in OACK\n") );

    ConnError(
        connection,
        connection->RemoteHost,
        connection->RemotePort,
        TFTP_ERROR_OPTION_NEGOT_FAILED,
        "Bad TFTP options"
        );

    return STATUS_UNSUCCESSFUL;

} // ConnInitialize


NTSTATUS
ConnReceive (
    IN PCONNECTION Connection,
    OUT PTFTP_PACKET *Packet
    )
//
// Receive a tftp packet into the packet buffer pointed to by Connection->CurrentPacket.
// The packet to be received must be a packet of block number Connection->BlockNumber.
// Returns a pointer to the tftp part of received packet.  Also performs
// ack sending and retransmission.
//

{
    NTSTATUS status;


#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return STATUS_SUCCESS;
#endif

    status = ConnWait( Connection, TFTP_DATA, Packet );
    if ( NT_SUCCESS(status) ) {

        Connection->CurrentPacket = Connection->LastReceivedPacket;
        Connection->CurrentLength = Connection->LastReceivedLength;

        ConnAck( Connection );
    }

    return status;

} // ConnReceive


NTSTATUS
ConnSend (
    IN PCONNECTION Connection,
    IN ULONG Length
    )
//
// Write the data packet contained in Connection->CurrentPacket, with data length len,
// to the net.  Wait first for an ack for the previous packet to arrive,
// retransmitting it as needed.  Then fill in the net headers, etc. and
// send the packet out.  Return TRUE if the packet is sent successfully,
// or FALSE if a timeout or error occurs.
//

{
    NTSTATUS status;
    PTFTP_PACKET packet;
    PVOID temp;
    USHORT blockNumber;


#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return STATUS_SUCCESS;
#endif


    packet = Connection->CurrentPacket;
    packet->Opcode = TFTP_DATA;
    blockNumber = Connection->BlockNumber + 1;
#ifdef WRAP_TO_1
    if ( blockNumber == 0 ) {
        blockNumber = 1;
    }
#endif
    packet->BlockNumber = SWAP_WORD( blockNumber );
    Length += sizeof(packet->Opcode) + sizeof(packet->BlockNumber);

    if ( Connection->BlockNumber != 0 ) {
        status = ConnWait( Connection, TFTP_DACK, NULL );
        if ( !NT_SUCCESS(status) ) {
            return status;
        }
    }

    Connection->BlockNumber = blockNumber;  // next expected block number
    Connection->Retransmissions = 0;

    temp = Connection->LastSentPacket;      // next write packet buffer
    ConnSendPacket( Connection, Connection->CurrentPacket, Length ); // sets up LastSent...
    Connection->CurrentPacket = temp;       // for next ConnPrepareSend

    return STATUS_SUCCESS;

} // ConnSend


NTSTATUS
ConnWait (
    IN PCONNECTION Connection,
    IN USHORT Opcode,
    OUT PTFTP_PACKET *Packet OPTIONAL
    )
//
// Wait for a valid tftp packet of the specified type to arrive on the
// specified tftp connection, retransmitting the previous packet as needed up
// to the timeout period.  When a packet comes in, check it out.
// Return a pointer to the received packet or NULL if error or timeout.
//

{
    ULONG now;
    ULONG timeout;
    ULONG remoteHost;
    USHORT remotePort;
    PTFTP_PACKET packet;
    ULONG length;
    USHORT blockNumber;


#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    return STATUS_SUCCESS;
#endif


    while ( TRUE) {

        now = SysGetRelativeTime();
        timeout = Connection->NextRetransmit - now;
        DPRINT( REAL_LOUD, ("ConnWait: now=%d, next retransmit=%d, timeout=%d\n",
                        now, Connection->NextRetransmit, timeout) );
        length = UdpReceive(
                    Connection->LastReceivedPacket,
                    sizeof(TFTP_HEADER) + Connection->BlockSize,
                    &remoteHost,
                    &remotePort,
                    timeout
                    );
        if ( length <= 0 ) {
            if ( !ConnRetransmit( Connection, TRUE ) ) {
                break;
            }
            continue;
        }

        //
        // Got a packet; check it out.
        //

        packet = Connection->LastReceivedPacket;

        //
        // First, check the received length for validity.
        //

        Connection->LastReceivedLength = length;
        if ( (length < sizeof(TFTP_HEADER)) ||
             ((packet->Opcode == TFTP_DATA) &&
              (length > (sizeof(TFTP_HEADER) + Connection->BlockSize))) ) {
            ConnError(
                Connection,
                remoteHost,
                remotePort,
                TFTP_ERROR_UNDEFINED,
                "Bad TFTP packet length"
                );
            continue;
        }

        //
        // Next, check for correct remote host.
        //

        if ( remoteHost != Connection->RemoteHost ) {
            ConnError(
                Connection,
                remoteHost,
                remotePort,
                TFTP_ERROR_UNKNOWN_TRANSFER_ID,
                "Sorry, wasn't talking to you!"
                );
            continue;
        }

        //
        // Next, the remote port.  If still unsynchronized, use his port.
        //

        blockNumber = SWAP_WORD( packet->BlockNumber );

        if ( !Connection->Synced &&
             (((packet->Opcode == Opcode) &&
               ((Opcode == TFTP_OACK) || (blockNumber == Connection->BlockNumber))) ||
              (packet->Opcode == TFTP_ERROR)) ) {

            Connection->Synced = TRUE;
            Connection->RemotePort = remotePort;
            Connection->Timeout = TIMEOUT;  // normal data timeout

        } else if ( remotePort != Connection->RemotePort ) {

            ConnError(
                Connection,
                remoteHost,
                remotePort,
                TFTP_ERROR_UNKNOWN_TRANSFER_ID,
                "Unexpected port number"
                );
            continue;
        }

        //
        // Now check out the TFTP opcode.
        //

        if ( packet->Opcode == Opcode ) {

            if ( (Opcode == TFTP_OACK) || (blockNumber == Connection->BlockNumber) ) {

                if ( Packet != NULL ) {
                    *Packet = packet;
                }
                Connection->Timeout = TIMEOUT;  // normal data timeout
                return STATUS_SUCCESS;

            } else if ( (blockNumber == Connection->BlockNumber - 1) &&
                        (Opcode == TFTP_DATA) ) {

                if ( !ConnRetransmit( Connection, FALSE ) ) {
                    break;
                }

            } else if ( blockNumber > Connection->BlockNumber ) {

                DPRINT( ERROR, ("ConnWait: Block number too high (%d vs. %d)\n",
                                blockNumber, Connection->BlockNumber) );
                ConnError(
                    Connection,
                    remoteHost,
                    remotePort,
                    TFTP_ERROR_ILLEGAL_OPERATION,
                    "Block number greater than expected"
                    );

                return STATUS_UNSUCCESSFUL;

            } else {                        // old duplicate; ignore

                continue;
            }

        } else if ( packet->Opcode == TFTP_OACK ) {

            DPRINT( ERROR, ("ConnWait: received duplicate OACK packet\n") );

            if ( Connection->BlockNumber == 1 ) {

                if ( !ConnRetransmit( Connection, FALSE ) ) {
                    break;
                }
            }

        } else if ( packet->Opcode == TFTP_ERROR ) {

            //DPRINT( ERROR, ("ConnWait: received error packet; code %x, msg %s\n",
            //                packet->BlockNumber, packet->Data) );

            return STATUS_UNSUCCESSFUL;

        } else {                            // unexpected TFTP opcode

            DPRINT( ERROR, ("ConnWait: received unknown TFTP opcode %d\n", packet->Opcode) );

            ConnError(
                Connection,
                remoteHost,
                remotePort,
                TFTP_ERROR_ILLEGAL_OPERATION,
                "Bad opcode received"
                );

            return STATUS_UNSUCCESSFUL;
        }
    }

    DPRINT( ERROR, ("ConnWait: timeout\n") );

    ConnError(
        Connection,
        Connection->RemoteHost,
        Connection->RemotePort,
        TFTP_ERROR_UNDEFINED,
        "Timeout on receive" );

    return STATUS_IO_TIMEOUT;

} // ConnWait


VOID
ConnAck (
    IN PCONNECTION Connection
    )
//
// Generate and send an ack packet for the specified connection.  Also
// update the block number.  Use the packet stored in Connection->LastSent to build
// the ack in.
//

{
    PTFTP_PACKET packet;
    ULONG length;


#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return;
#endif


    packet = Connection->LastSentPacket;

    length = 4;
    packet->Opcode = TFTP_DACK;
    packet->BlockNumber = SWAP_WORD( Connection->BlockNumber );

    ConnSendPacket( Connection, packet, length );
    Connection->Retransmissions = 0;
    Connection->BlockNumber++;
#ifdef WRAP_TO_1
    if ( Connection->BlockNumber == 0 ) {
        Connection->BlockNumber = 1;
    }
#endif

    return;

} // ConnAck


VOID
ConnError (
    IN PCONNECTION Connection,
    IN ULONG RemoteHost,
    IN USHORT RemotePort,
    IN USHORT ErrorCode,
    IN PUCHAR ErrorMessage
    )
//
// Make an error packet to send to the specified foreign host and port
// with the specified error code and error message.  This routine is
// used to send error messages in response to packets received from
// unexpected foreign hosts or tid's as well as those received for the
// current connection.  It allocates a packet specially
// for the error message because such error messages will not be
// retransmitted.  Send it out on the connection.
//

{
    PTFTP_PACKET packet;
    ULONG length;

    DPRINT( CONN_ERROR, ("ConnError: code %x, msg %s\n", ErrorCode, ErrorMessage) );


#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    return;
#endif


    packet = (PTFTP_PACKET)NetTftpPacket[2];

    length = 4;
    packet->Opcode = TFTP_ERROR;
    packet->BlockNumber = ErrorCode;
    strcpy( packet->Data, ErrorMessage );
    length += ConnStrsize(ErrorMessage);

    UdpSend( packet, length, RemoteHost, RemotePort );

    return;

} // ConnError


VOID
ConnSendPacket (
    IN PCONNECTION Connection,
    IN PVOID Packet,
    IN ULONG Length
    )
//
// Send the specified packet, with the specified tftp length (length -
// udp and ip headers) out on the current connection.  Fill in the
// needed parts of the udp and ip headers, byte-swap the tftp packet,
// etc; then write it out.  Then set up for retransmit.
//

{


#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return;
#endif


    UdpSend(
        Packet,
        Length,
        Connection->RemoteHost,
        Connection->RemotePort
        );

    Connection->LastSentPacket = Packet;
    Connection->LastSentLength = Length;
    Connection->NextRetransmit = SysGetRelativeTime() + Connection->Timeout;

    return;

} // ConnSendPacket


PTFTP_PACKET
ConnPrepareSend (
    IN PCONNECTION Connection
    )
//
// Return a pointer to the next tftp packet suitable for filling for
// writes on the connection.
//

{
#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return NULL;
#endif

    return Connection->CurrentPacket;

} // ConnPrepareSend


NTSTATUS
ConnWaitForFinalAck (
    IN PCONNECTION Connection
    )
//
// Finish off a write connection.  Wait for the last ack, then
// close the connection and return.
//

{
    return ConnWait( Connection, TFTP_DACK, NULL );

} // ConnWaitForFinalAck


BOOLEAN
ConnRetransmit (
    IN PCONNECTION Connection,
    IN BOOLEAN Timeout
    )
//
// Retransmit the last-sent packet, up to MAX_RETRANS times.  Exponentially
// back off the timeout time up to a maximum of MAX_TIMEOUT.  This algorithm
// may be replaced by a better one in which the timeout time is set from
// the maximum round-trip time to date.
// The second argument indicates whether the retransmission is due to the
// arrival of a duplicate packet or a timeout.  If a duplicate, don't include
// this retransmission in the maximum retransmission count.
//

{


#ifdef EFI

    //
    // There's nothing to do here for an EFI environment.
    //
    ASSERT( FALSE );
    return TRUE;
#endif

    if ( Timeout ) {

        //
        // This is a timeout. Check the retransmit count.
        //

        if ( ++Connection->Retransmissions >= MAX_RETRANS ) {

            //
            // Retransmits exhausted.
            //

            return FALSE;
        }

    } else {

        //
        // Duplicate packet. If we just sent a packet, don't send
        // another one. This deals with the case where we receive
        // multiple identical packets in rapid succession, possibly
        // due to network problems or slowness at the remote computer.
        //

        if ( Connection->NextRetransmit == SysGetRelativeTime() + Connection->Timeout ) {
            return TRUE;
        }
    }

    Connection->Timeout <<= 1;
    if ( Connection->Timeout > MAX_TIMEOUT ) {
        Connection->Timeout = MAX_TIMEOUT;
    }

    ConnSendPacket( Connection, Connection->LastSentPacket, Connection->LastSentLength );

    return TRUE;

} // ConnRetransmit


ULONG
ConnSafeAtol (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    )
{
    ULONG value;
    UCHAR c;

    value = 0;

    while ( Buffer < BufferEnd ) {

        c = *Buffer++;

        if ( c == 0 ) {
            return value;
        }

        if ( (c < '0') || (c > '9') ) {
            break;
        }

        value = (value * 10) + (c - '0');
    }

    return (ULONG)-1;

} // ConnSafeAtol


ULONG
ConnItoa (
    IN ULONG Value,
    OUT PUCHAR Buffer
    )
{
    PUCHAR p;
    ULONG digit;
    UCHAR c;

    p = Buffer;

    //
    // Put the value string into the buffer in reverse order.
    //

    do {
        digit = Value % 10;
        Value /= 10;
        *p++ = (UCHAR)(digit + '0');
    } while ( Value > 0 );

    //
    // Terminate the string and move back to the last character in the string.
    //

    digit = (ULONG)(p - Buffer + 1);     // size of string (including terminator)

    *p-- = 0;

    //
    // Reverse the string.
    //

    do {
        c = *p;
        *p-- = *Buffer;
        *Buffer++ = c;
    } while ( Buffer < p );

    return digit;

} // ConnItoa


#if defined(REMOTE_BOOT_SECURITY)
ULONG
ConnSigntoa (
    IN PUCHAR Sign,
    IN ULONG SignLength,
    OUT PUCHAR Buffer
    )
{
    PUCHAR p;
    ULONG digit;
    UCHAR c;
    ULONG i;

    for (i = 0; i < SignLength; i++) {

        digit = Sign[i] / 16;

        if (digit >= 10) {
            c = (UCHAR)('a' + digit - 10);
        } else {
            c = (UCHAR)('0' + digit);
        }

        *Buffer = c;
        ++Buffer;

        digit = Sign[i] % 16;

        if (digit >= 10) {
            c = (UCHAR)('a' + digit - 10);
        } else {
            c = (UCHAR)('0' + digit);
        }

        *Buffer = c;
        ++Buffer;

    }

    *Buffer = '\0';

    return (2 * SignLength) + 1;

} // ConnSigntoa


ULONG
ConnAtosign (
    IN PUCHAR Buffer,
    IN ULONG SignLength,
    OUT PUCHAR Sign
    )
{
    ULONG nibble;
    ULONG curDigit;
    PUCHAR curBuffer;

    curDigit = 0;
    curBuffer = Buffer;

    while (curDigit <= SignLength) {

        if ((*curBuffer >= '0') && (*curBuffer <= '9')) {
            nibble = *curBuffer - '0';
        } else if ((*curBuffer >= 'a') && (*curBuffer <= 'f')) {
            nibble = *curBuffer - 'a' + 10;
        } else if ((*curBuffer >= 'A') && (*curBuffer <= 'F')) {
            nibble = *curBuffer - 'A' + 10;
        } else {
            break;
        }
        ++curBuffer;

        if ((*curBuffer >= '0') && (*curBuffer <= '9')) {
            Sign[curDigit] = (CHAR)((nibble << 4) + *curBuffer - '0');
        } else if ((*curBuffer >= 'a') && (*curBuffer <= 'f')) {
            Sign[curDigit] = (CHAR)((nibble << 4) + *curBuffer - 'a' + 10);
        } else if ((*curBuffer >= 'A') && (*curBuffer <= 'F')) {
            Sign[curDigit] = (CHAR)((nibble << 4) + *curBuffer - 'A' + 10);
        } else {
            break;
        }
        ++curBuffer;

        ++curDigit;
    }

    //
    // If we hit the end of our curBuffer, then skip the rest of the input.
    //

    while (*curBuffer != '\0') {
        ++curBuffer;
    }

    //
    // Return the amount consumed, plus one for the final \0.
    //

    return (ULONG)((curBuffer - Buffer) + 1);

} // ConnAtosign
#endif // defined(REMOTE_BOOT_SECURITY)


BOOLEAN
ConnSafeStrequal (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd,
    IN PUCHAR CompareString
    )
{

    while ( Buffer < BufferEnd ) {
        if ( *Buffer != *CompareString ) {
            return FALSE;
        }
        if ( *CompareString == 0 ) {
            return TRUE;
        }
        Buffer++;
        CompareString++;
    }

    return FALSE;

} // ConnSafeStrequal


ULONG
ConnSafeStrsize (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    )
{
    PUCHAR eos;

    eos = Buffer;

    while ( eos < BufferEnd ) {
        if ( *eos++ == 0 ) {
            return (ULONG)(eos - Buffer);
        }
    }

    return 0;

} // ConnSafeStrsize


ULONG
ConnStrsize (
    IN PUCHAR Buffer
    )
{
    PUCHAR eos;

    eos = Buffer;

    while ( *eos++ != 0 ) ;

    return (ULONG)(eos - Buffer);

} // ConnStrsize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\tftplib\alpha\rom.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rom.c

Abstract:

    Boot loader ROM routines.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
RomSetReceiveStatus (
    IN USHORT UnicastUdpDestinationPort
#if 0
    ,
    IN USHORT MulticastUdpDestinationPort,
    IN ULONG MulticastUdpDestinationAddress,
    IN USHORT MulticastUdpSourcePort,
    IN ULONG MulticastUdpSourceAddress
#endif
    )
{
    return;

} // RomSetReceiveStatus


ULONG
RomSendUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG RemoteHost,
    IN USHORT RemotePort
    )
{
    return 0;

} // RomSendUdpPacket


ULONG
RomReceiveUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Timeout,
    OUT PULONG RemoteHost,
    OUT PUSHORT RemotePort
    )
{
    return 0;

} // RomReceiveUdpPacket


ULONG
RomGetNicType (
    OUT t_PXENV_UNDI_GET_NIC_TYPE *NicType
    )
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpienab\idchange.h ===
#pragma once

DWORD
DwRegOpenKeyExWithAdminAccess(HKEY hkey,
			      LPCTSTR szSubKey,
			      DWORD samDesired,
                              HKEY* phkeySubKey,
			      PSECURITY_DESCRIPTOR* ppsd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpienab\acpienab.h ===
#pragma once
#ifndef _ACPIENAB_H
#define _ACPIENAB_H

/* ----------------------------------------------------------------------

Copyright (c) 1998 Microsoft Corporation

Module Name:

    acpienab.h

Abstract:

    Header file for Windows NT DLL which enables ACPI on systems on which
    NT5 has been installed in legacy mode.

Author:

    Susan Dey : 27 July 98

Revision History:

 ---------------------------------------------------------------------- */

// Copy char to wide or char...  (Note: ToSize in wide characters)
#if (defined(_UNICODE) || defined(UNICODE ))
#define CHAR2TCHAR(From, To, ToSize) \
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, From, -1, To, ToSize)
#else
#define CHAR2TCHAR(From, To, ToSize) \
	strcpy(To, From)
#endif  // _UNICODE


// Functions
HRESULT ACPIEnable ();
LONG RegDeleteKeyAndSubkeys(HKEY hKey, LPTSTR lpszSubKey, BOOL UseAdminAccess);
int DisplayDialogBox(DWORD dwCaptionID, DWORD dwMessageID, UINT uiBoxType);
BOOL InstallRegistryAndFilesUsingInf(LPCTSTR szInfFileName,
				     LPCTSTR szInstallSection);
BOOL RegDeleteDeviceKey(IN const GUID* guid);
void DisplayGenericErrorAndUndoChanges();
BOOL IsAdministrator(void);
BOOL UsePICHal(IN BOOL* PIC);


// Variables
extern HINSTANCE g_hinst;

#endif // _ACPIENAB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpienab\acpirsrc.h ===
// Used by acpienab.rc
#define ACPI_STR_WARNING_DIALOG_CAPTION	1000
#define ACPI_STR_SHUTDOWN_WARNING	1001
#define ACPI_STR_ERROR_DIALOG_CAPTION	1002
#define ACPI_STR_GENERAL_ERROR_MESSAGE	1003
#define ACPI_STR_NOT_SUPPORTED		1004
#define ACPI_STR_ADMIN_ACCESS_REQUIRED	1005
#define ACPI_STR_REBOOT_DIALOG_CAPTION	1006
#define ACPI_STR_REBOOT_WARNING		1007
#define ACPI_STR_REBOOT_ERROR		1008
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpienab\makefile.inc ===
acpienab.inf: acpienab.inx acpienab.txt
    copy acpienab.inx+acpienab.txt $@
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\tftplib\ia64\rom.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rom.c

Abstract:

    Boot loader ROM routines.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#include <udp_api.h>
#include <tftp_api.h>
#include "bldr.h"
#include "efi.h"
#include "efip.h"
#include "bldria64.h"
#include "extern.h"


//
// We'll use this to keep track of which port we're communicating through.
//
EFI_PXE_BASE_CODE_UDP_PORT      MachineLocalPort = 2000;


#define STALL_TIME      (40000)
extern VOID
FwStallExecution(
    IN ULONG Microseconds
    );




VOID
RomSetReceiveStatus (
    IN USHORT UnicastUdpDestinationPort
#if 0
    ,
    IN USHORT MulticastUdpDestinationPort,
    IN ULONG MulticastUdpDestinationAddress,
    IN USHORT MulticastUdpSourcePort,
    IN ULONG MulticastUdpSourceAddress
#endif
    )
{
    return;

} // RomSetReceiveStatus


ULONG
RomSendUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG RemoteHost,
    IN USHORT pServerPort
    )
{
    EFI_STATUS                      EfiStatus = EFI_SUCCESS;
    EFI_IP_ADDRESS                  DestinationIpAddress;
    INTN                            Count = 0;
    EFI_PXE_BASE_CODE_UDP_PORT      ServerPort = pServerPort;
    UINTN                           BufferLength = Length;
    PVOID                           MyBuffer = NULL;


    //
    // Get the server's EFI_IP_ADDRESS from the handle to the PXE base code.
    //
    for( Count = 0; Count < 4; Count++ ) {
        DestinationIpAddress.v4.Addr[Count] = PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr[Count];
    }        

    FlipToPhysical();
    
    //
    // Make sure the address is a physical address, then do the UdpWrite.
    //
    MyBuffer = (PVOID)((ULONG_PTR)Buffer & ~KSEG0_BASE);
    EfiStatus = PXEClient->UdpWrite( PXEClient,
                                     0,
                                     &DestinationIpAddress,
                                     &ServerPort,
                                     NULL,
                                     NULL,
                                     &MachineLocalPort,
                                     NULL,
                                     NULL,
                                     &BufferLength,
                                     MyBuffer );
    
    //
    // This is really gross, but on retail builds with no debugger, EFI will go
    // off in the weeds unless we slow down transactions over the network.  So
    // after Udp operations, take a short nap.
    //
    FwStallExecution( STALL_TIME );
    
    FlipToVirtual();
    
    
    if( EfiStatus != EFI_SUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "RomSendUdpPacket: UdpWrite failed. MachineLocalPort: %d ServerPort: %d (%d)\r\n", MachineLocalPort, ServerPort, EfiStatus );
        }
        return 0;
    }

    return Length;


} // RomSendUdpPacket


ULONG
RomReceiveUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Timeout,
    IN OUT PULONG RemoteHost,
    IN OUT PUSHORT LocalPort
    )
{
    EFI_STATUS                      EfiStatus = EFI_SUCCESS;
    UINTN                           BufferLength = Length;
    EFI_IP_ADDRESS                  ServerIpAddress;
    EFI_IP_ADDRESS                  MyIpAddress;
    INTN                            Count = 0;
    EFI_PXE_BASE_CODE_UDP_PORT      ServerPort = (EFI_PXE_BASE_CODE_UDP_PORT)(0xFAB);    // hardcode to 4011
    PVOID                           MyBuffer = NULL;

    //
    // Get The server's EFI_IP_ADDRESS from the handle to the PXE base code.
    //
    for( Count = 0; Count < 4; Count++ ) {
        ServerIpAddress.v4.Addr[Count] = PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr[Count];
    }        


    //
    // Get our EFI_IP_ADDRESS from the handle to the PXE base code.
    //
    for( Count = 0; Count < 4; Count++ ) {
        MyIpAddress.v4.Addr[Count] = PXEClient->Mode->StationIp.v4.Addr[Count];
    }        


    FlipToPhysical();

    //
    // Make sure the address is a physical address, then do the UdpWrite.
    //
    MyBuffer = (PVOID)((ULONG_PTR)Buffer & ~KSEG0_BASE);
    EfiStatus = PXEClient->UdpRead( PXEClient,
                                    0,
                                    &MyIpAddress,
                                    &MachineLocalPort,
                                    &ServerIpAddress,
                                    &ServerPort,
                                    NULL,                   // &HeaderLength
                                    NULL,                   // HeaderBuffer
                                    &BufferLength,
                                    MyBuffer );
    
    //
    // This is really gross, but on retail builds with no debugger, EFI will go
    // off in the weeds unless we slow down transactions over the network.  So
    // after Udp operations, take a short nap.
    //
    FwStallExecution( STALL_TIME );
    
    FlipToVirtual();
    

    if( EfiStatus != EFI_SUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "RomReceiveUdpPacket: UdpRead failed. MachineLocalPort: %d ServerPort: %d (%d)\r\n", MachineLocalPort, ServerPort, EfiStatus );
        }
        return 0;
    }


    return Length;




} // RomReceiveUdpPacket


ULONG
RomGetNicType (
    OUT t_PXENV_UNDI_GET_NIC_TYPE *NicType
    )
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpienab\idchange.c ===
// Copied from \nt\private\net\config\upgrade\netupgrd
// August 98  --  t-sdey

#pragma hdrstop
#include <winnt32.h>
#include "idchange.h"



DWORD
DwRegKeySetAdministratorSecurity(HKEY hkey, DWORD samDesired,
                                 PSECURITY_DESCRIPTOR* ppsdOld);

DWORD
DwRegCreateOrOpenKeyExWithAdminAccess(HKEY hkey, LPCTSTR szSubKey,
                                      DWORD samDesired, 
                                      BOOL fCreate, HKEY* phkeySubKey,
                                      PSECURITY_DESCRIPTOR* ppsd);

DWORD
DwRegOpenKeyExWithAdminAccess(HKEY hkey, LPCTSTR szSubKey, DWORD samDesired,
                              HKEY* phkeySubKey, PSECURITY_DESCRIPTOR* ppsd)
{
    return DwRegCreateOrOpenKeyExWithAdminAccess(hkey, szSubKey, samDesired,
            FALSE, phkeySubKey, ppsd);
}


//+--------------------------------------------------------------------------
//
//  Function:   DwRegCreateOrOpenKeyExWithAdminAccess
//
//  Purpose:    Creates/Opens a subkey.  If the key exists but the local
//                  administrators group does not have samDesired access to 
//                  it, the function will add the access needed to the 
//                  security descriptor
//
//  Arguments:
//      hkeyParent [in]  The key to create the subkey in
//      szSubKey   [in]  The subkey name
//      samDesired [in]  The desired access for phkey
//      fCreate    [in]  TRUE if the key is to be created.  
//      phSubkey   [out] The handle to the subkey
//      ppsdOrig   [out] The previous security settings of the key
//                          if it already existed, optional
//
//  Returns:    DWORD. ERROR_SUCCESS or a failure code from winerror.h
//
//  Author:     billbe   15 Dec 1997
//
//  Notes:      
//
DWORD
DwRegCreateOrOpenKeyExWithAdminAccess(HKEY hkey, LPCTSTR szSubKey,
                                      DWORD samDesired, 
                                      BOOL fCreate, HKEY* phkeySubKey,
                                      PSECURITY_DESCRIPTOR* ppsd)
{
    DWORD dwError = ERROR_SUCCESS;

    if (ppsd)
    {
        *ppsd = NULL;
    }

    // Create or open the key based on fCreate
    //
    if (fCreate)
    {
        dwError = RegCreateKeyEx(hkey, szSubKey, 0, NULL,
                REG_OPTION_NON_VOLATILE, samDesired, NULL, phkeySubKey,
                NULL);
    }
    else
    {
        dwError = RegOpenKeyEx(hkey, szSubKey, 0, samDesired,
                phkeySubKey);
    }

    // If access was denied we either tried to create or open a prexisting 
    // key that we didn't have access to. We need to grant ourselves
    // permission.  
    //
    if (ERROR_ACCESS_DENIED == dwError)
    {
        // open with access to read and set security
        dwError = RegOpenKeyEx(hkey, szSubKey, 0,
            WRITE_DAC | READ_CONTROL, phkeySubKey);

        if (ERROR_SUCCESS == dwError)
        {
            // Grant samDesired access to the local Administrators group
            dwError = DwRegKeySetAdministratorSecurity(*phkeySubKey, samDesired,
                    ppsd);

            // Close and reopen the key with samDesired access
            RegCloseKey(*phkeySubKey);
            if (ERROR_SUCCESS == dwError)
            {
                dwError = RegOpenKeyEx(hkey, szSubKey, 0, samDesired,
                        phkeySubKey);
            }
        }
    }

    return dwError;
}


//+--------------------------------------------------------------------------
//
//  Function:   DwAddToRegKeySecurityDescriptor
//
//  Purpose:    Adds access for a specified SID to a registry key
//
//  Arguments:
//      hkey         [in]  The registry key that will receive the
//                            modified security descriptor
//      psidGroup    [in]  The SID (in self-relative mode) that will be 
//                            granted access to the key 
//      dwAccessMask [in]  The access level to grant
//      ppsd         [out] The previous security descriptor
//
//  Returns:    DWORD. ERROR_SUCCESS or a failure code from winerror.h
//
//  Author:     billbe   13 Dec 1997
//
//  Notes:      This function is based on AddToRegKeySD in the MSDN
//                  article Windows NT Security by Christopher Nefcy
//
DWORD 
DwAddToRegKeySecurityDescriptor(HKEY hkey, PSID psidGroup,
                                DWORD dwAccessMask,
                                PSECURITY_DESCRIPTOR* ppsd)
{ 
    PSECURITY_DESCRIPTOR        psdAbsolute = NULL;
    PACL                        pdacl;
    DWORD                       cbSecurityDescriptor = 0;
    DWORD                       dwSecurityDescriptorRevision;
    DWORD                       cbDacl = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    PACL                        pdaclNew = NULL; 
    DWORD                       cbAddDaclLength = 0; 
    BOOL                        fAceFound = FALSE;
    BOOL                        fHasDacl  = FALSE;
    BOOL                        fDaclDefaulted = FALSE; 
    ACCESS_ALLOWED_ACE*         pAce;
    DWORD                       i;
    BOOL                        fAceForGroupPresent = FALSE;
    DWORD                       dwMask;
    PSECURITY_DESCRIPTOR        psdRelative = NULL;
    DWORD                       cbSize = 0;

    // Get the current security descriptor for hkey
    //
    DWORD dwError = RegGetKeySecurity(hkey, DACL_SECURITY_INFORMATION, 
            psdRelative, &cbSize);

    if (ERROR_INSUFFICIENT_BUFFER == dwError)
    {
        psdRelative = malloc(cbSize);
        
        dwError = RegGetKeySecurity(hkey, DACL_SECURITY_INFORMATION, 
                psdRelative, &cbSize);
    }

    // get security descriptor control from the security descriptor 
    if (!GetSecurityDescriptorControl(psdRelative, 
            (PSECURITY_DESCRIPTOR_CONTROL) &sdc,
             (LPDWORD) &dwSecurityDescriptorRevision))  
    {
         return (GetLastError());
    }

    // check if DACL is present 
    if (SE_DACL_PRESENT & sdc) 
    {
        // get dacl   
        if (!GetSecurityDescriptorDacl(psdRelative, (LPBOOL) &fHasDacl,
                (PACL *) &pdacl, (LPBOOL) &fDaclDefaulted))
        {
            return ( GetLastError());
        }
        // get dacl length  
        cbDacl = pdacl->AclSize;
        // now check if SID's ACE is there  
        for (i = 0; i < pdacl->AceCount; i++)  
        {
            if (!GetAce(pdacl, i, (LPVOID *) &pAce))
            {
                return ( GetLastError());   
            }
            // check if group sid is already there
            if (EqualSid((PSID) &(pAce->SidStart), psidGroup))    
            {
                // If the correct access is present, return success
                if ((pAce->Mask & dwAccessMask) == dwAccessMask)
                {
                    return ERROR_SUCCESS;
                }
                fAceForGroupPresent = TRUE;
                break;  
            }
        }
        // if the group did not exist, we will need to add room
        // for another ACE
        if (!fAceForGroupPresent)  
        {
            // get length of new DACL  
            cbAddDaclLength = sizeof(ACCESS_ALLOWED_ACE) - 
                sizeof(DWORD) + GetLengthSid(psidGroup); 
        }
    } 
    else
    {
        // get length of new DACL
        cbAddDaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - 
            sizeof(DWORD) + GetLengthSid (psidGroup);
    }


    // get memory needed for new DACL
    pdaclNew = (PACL) malloc (cbDacl + cbAddDaclLength);
    if (!pdaclNew)
    {
        return (GetLastError()); 
    }

    // get the sd length
    cbSecurityDescriptor = GetSecurityDescriptorLength(psdRelative); 

    // get memory for new SD
    psdAbsolute = (PSECURITY_DESCRIPTOR) 
            malloc(cbSecurityDescriptor + cbAddDaclLength);
    if (!psdAbsolute) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // change self-relative SD to absolute by making new SD
    if (!InitializeSecurityDescriptor(psdAbsolute, 
        SECURITY_DESCRIPTOR_REVISION)) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // init new DACL
    if (!InitializeAcl(pdaclNew, cbDacl + cbAddDaclLength, 
           ACL_REVISION)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // now add in all of the ACEs into the new DACL (if org DACL is there)
    if (SE_DACL_PRESENT & sdc) 
    {
        for (i = 0; i < pdacl->AceCount; i++)
        {   
            // get ace from original dacl
            if (!GetAce(pdacl, i, (LPVOID*) &pAce))   
            {
                dwError = GetLastError();    
                goto ErrorExit;   
            }
        
            // If an ACE for our SID exists, we just need to bump
            // up the access level instead of creating a new ACE
            //
            if (EqualSid((PSID) &(pAce->SidStart), psidGroup))    
                dwMask = dwAccessMask | pAce->Mask;
            else
                dwMask = pAce->Mask;

            // now add ace to new dacl   
            if (!AddAccessAllowedAce(pdaclNew, 
                    ACL_REVISION, dwMask,
                    (PSID) &(pAce->SidStart)))   
            {
                dwError = GetLastError();
                goto ErrorExit;   
            }  
        } 
    } 

    // Add a new ACE for our SID if one was not already present
    if (!fAceForGroupPresent)
    {
        // now add new ACE to new DACL
        if (!AddAccessAllowedAce(pdaclNew, ACL_REVISION, dwAccessMask,
                psidGroup)) 
        {  
            dwError = GetLastError();  
            goto ErrorExit; 
        }
    }

    // check if everything went ok 
    if (!IsValidAcl(pdaclNew)) 
    {
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // now set security descriptor DACL
    if (!SetSecurityDescriptorDacl(psdAbsolute, TRUE, pdaclNew, 
            fDaclDefaulted)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // check if everything went ok 
    if (!IsValidSecurityDescriptor(psdAbsolute)) 
    {
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // now set the reg key security (this will overwrite any
    // existing security)
    dwError = RegSetKeySecurity(hkey, 
          (SECURITY_INFORMATION)(DACL_SECURITY_INFORMATION), psdAbsolute);

    if (ppsd)
    {
        *ppsd = psdRelative;
    }
ErrorExit: 
    // free memory
    if (psdAbsolute)  
    {
        free (psdAbsolute); 
        if (pdaclNew)
        {
            free((VOID*) pdaclNew); 
        }
    }

    return dwError;
}

//+--------------------------------------------------------------------------
//
//  Function:   DwRegKeySetAdministratorSecurity
//
//  Purpose:    Grants the local Administrators group full access to
//                  hkey.
//
//  Arguments:
//      hkey    [in]  The registry key
//      ppsdOld [out] The previous security descriptor for hkey
//
//  Returns:    DWORD. ERROR_SUCCESS or a failure code from winerror.h
//
//  Author:     billbe   13 Dec 1997
//
//  Notes:
//
DWORD
DwRegKeySetAdministratorSecurity(HKEY hkey, DWORD samDesired,
                                 PSECURITY_DESCRIPTOR* ppsdOld)
{
    PSID                     psid;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    DWORD                    dwError = ERROR_SUCCESS;

    // Get sid for the local Administrators group
    if (!AllocateAndInitializeSid(&sidAuth, 2,
            SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psid) ) 
    {
        dwError = GetLastError();
    }

    if (ERROR_SUCCESS == dwError)
    {
        // Add all access privileges for the local administrators group
        dwError = DwAddToRegKeySecurityDescriptor(hkey, psid, 
                samDesired, ppsdOld);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpienab\acpienab.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       acpienab.cpp
//
//  Contents:   Functions to enable ACPI on a machine which has had NT5
//		installed in legacy mode
//
//  Notes:      
//
//  Author:     t-sdey   17 July 98
//
//----------------------------------------------------------------------------

#include <winnt32.h>
#include <devguid.h>
extern "C" {
  #include <cfgmgr32.h>
  #include "idchange.h"
}
#include "acpienab.h"
#include "acpirsrc.h"

// Global Variables
HINSTANCE g_hinst;
TCHAR g_ACPIENAB_INF[] = TEXT(".\\acpienab.inf");  // local directory
TCHAR g_LAYOUT_INF[] = TEXT("layout.inf");         // winnt\inf directory
TCHAR g_HAL_BACKUP[] = TEXT("hal-old.dll");


//+---------------------------------------------------------------------------
//
//  Function:   WinMain
//
//  Purpose:    Run everything
//
//  Arguments:  Standard WinMain arguments
//
//  Author:     t-sdey	27 July 98
//
//  Notes:      
//
int WINAPI WinMain(HINSTANCE hInstance,  
		   HINSTANCE hPrevInstance,  
		   LPSTR lpCmdLine,     
		   int nCmdShow)
{
   g_hinst = hInstance;
   
   // Enable ACPI
   ACPIEnable();
   
   return TRUE;
}


// ----------------------------------------------------------------------
//
// Function:  ACPIEnable
//
// Purpose:   This function performs the steps necessary to enable ACPI
//	      and bring the system to a point where the user can log in
//	      after rebooting.  It leaves finding "new" hardware to after
//	      the user has rebooted and logged in again.
//
// Arguments: 
//
// Returns:   S_OK if successful
//            S_FALSE if unsuccessful
//
// Author:    t-sdey     27 July 98
//
// Notes: 
//
HRESULT ACPIEnable()
{
   //
   // These steps are in order from least to most crucial to the stability
   // of the system, in case of errors.
   //
   // Step 1: Test to see if ACPI can be enabled and warn the user to close 
   //         everything else.
   // Step 2: Prepare a safe configuration in case of errors.
   // Step 3: Set up keyboard and mouse for use after reboot.  This involves
   //         removing them from the CriticalDeviceDatabase so that they will
   //         be reconfigured (according to the new ACPI layout) after reboot.
   //         The current keyboards and mice are in the CDD, but we must 
   //         populate it with all possibilities, because their HardwareIDs 
   //         will probably change once ACPI is enabled.
   // Step 4: Add new values to the registry:
   //         - Add ACPI to the CriticalDeviceDatabase
   //         - Add keyboards and mice to the CriticalDeviceDatabase
   //         - Enable ACPI in the registry
   // Step 5: Copy the ACPI driver.
   // Step 6: Copy the new HAL.
   // Step 7: Reboot.
   //


   //
   // Step 1: Test to see if ACPI can be enabled and warn the user to close
   //         everything else.
   //
   
   // Make sure the user has administrative access
   if (!IsAdministrator()) {
      DisplayDialogBox(ACPI_STR_ERROR_DIALOG_CAPTION,
		       ACPI_STR_ADMIN_ACCESS_REQUIRED,
		       MB_OK | MB_ICONERROR);
      return S_FALSE;
   }

   // Test to see if ACPI is supported on this architecture
   SYSTEM_INFO SystemInfo;  // Will be used later to determine HAL
   GetSystemInfo(&SystemInfo);
   if (SystemInfo.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) {
      // Not supported
      DisplayDialogBox(ACPI_STR_ERROR_DIALOG_CAPTION,
		       ACPI_STR_NOT_SUPPORTED,
		       MB_OK | MB_ICONERROR);
      return S_FALSE;
   }

   // Warn the user to shut down any other programs
   if (DisplayDialogBox(ACPI_STR_WARNING_DIALOG_CAPTION,
			ACPI_STR_SHUTDOWN_WARNING,
			MB_YESNO | MB_ICONWARNING) == IDNO) {
      // The user cancelled
      return S_FALSE;
   }


   //
   // Step 2: Prepare a safe configuration in case of errors.
   //

   // Make a backup copy of the old HAL

   // Get location of the system directory
   TCHAR* szSystemDir = new TCHAR[MAX_PATH+1];
   if (!szSystemDir) {
      // Out of memory
      DisplayGenericErrorAndUndoChanges(); 
      return S_FALSE;
   }
   UINT uiSysDirLen = GetSystemDirectory(szSystemDir, MAX_PATH+1);
   if (uiSysDirLen == 0) {
      // Some error occurred
      DisplayGenericErrorAndUndoChanges(); 
      if (szSystemDir) delete[] szSystemDir;
      return S_FALSE;
   }
      
   // Assemble strings with the locations of the current and backup file
   TCHAR szHal[] = TEXT("hal.dll");
   TCHAR* szHalCurrent = new TCHAR[uiSysDirLen + lstrlen(szHal) + 1];
   TCHAR* szHalBackup = new TCHAR[uiSysDirLen + lstrlen(g_HAL_BACKUP) + 1];
   if (!szHalCurrent || !szHalBackup) {
      // Out of memory
      DisplayGenericErrorAndUndoChanges();
      delete[] szSystemDir;
      if (szHalCurrent) delete[] szHalCurrent;
      if (szHalBackup) delete[] szHalBackup;
      return S_FALSE;
   }
   _tcscpy(szHalCurrent, szSystemDir);
   _tcscat(szHalCurrent, TEXT("\\"));
   _tcscat(szHalCurrent, szHal);
   _tcscpy(szHalBackup, szSystemDir);
   _tcscat(szHalBackup, TEXT("\\"));
   _tcscat(szHalBackup, g_HAL_BACKUP);

   // Copy the HAL
   if (CopyFile(szHalCurrent, szHalBackup, FALSE) == FALSE) {
      // Error copying file
      DisplayGenericErrorAndUndoChanges();
      delete[] szSystemDir;
      delete[] szHalCurrent;
      delete[] szHalBackup;
      return S_FALSE;
   }
   
   delete[] szSystemDir;
   delete[] szHalCurrent;
   delete[] szHalBackup;
   

   // Make it possible to boot with the backup HAL if necessary
   
   // Find the system partition letter

   // Edit boot.ini
   //   -- add new NT5 boot line with "\HAL=hal-old.dll" on the end
   
   // Temporary: tell the user to do it manually
   MessageBox(NULL,
	      TEXT("If you want to ensure that you can recover if this process fails,\nadd a line to your boot.ini with \" /HAL=hal-old.dll\""),
	      TEXT("This is a temporary hack!"),
	      MB_ICONWARNING | MB_OK);



   //
   // Step 3: Set up keyboard and mouse for use after reboot.  This involves
   //         removing them from the CriticalDeviceDatabase so that they will
   //         be reconfigured (according to the new ACPI layout) after reboot.
   //         The current keyboards and mice are in the CDD, but we must 
   //         populate it with all possibilities, because their HardwareIDs 
   //         will probably change once ACPI is enabled.
   //

   //  Set up keyboard(s) for use after reboot
   if (RegDeleteDeviceKey(&GUID_DEVCLASS_KEYBOARD) == FALSE) {
      // Error
      DisplayGenericErrorAndUndoChanges();
      return S_FALSE;
   }

   //  Set up mouse (mice) for use after reboot
   if (RegDeleteDeviceKey(&GUID_DEVCLASS_MOUSE) == FALSE) {
      // Error
      DisplayGenericErrorAndUndoChanges();
      return S_FALSE;
   }

   
   
   //
   // Step 4: Add new values to the registry:
   //         - Add ACPI to the CriticalDeviceDatabase
   //         - Add keyboards and mice to the CriticalDeviceDatabase
   //         - Enable ACPI in the registry
   //

   if (InstallRegistryAndFilesUsingInf(g_ACPIENAB_INF,
				       TEXT("ACPI_REGISTRY.Install")) == 0) {
      // Error
      DisplayGenericErrorAndUndoChanges();
      return S_FALSE;
   }



   //
   // Step 5: Copy the ACPI driver.
   //
   
   // Copy the ACPI driver to the system directory
   if (InstallRegistryAndFilesUsingInf(g_ACPIENAB_INF,
				       TEXT("ACPI_DRIVER.Install")) == 0) {
      // Error
      DisplayGenericErrorAndUndoChanges();
      return S_FALSE;
   }



   //
   // Step 6: Copy the new HAL.
   //
   
   // Determine which HAL will be needed

   TCHAR szHalInstall[50];
   int HAL = 0;
   
   // Determine if it's a single or multi-processor machine
   BOOL SingleProc = (SystemInfo.dwNumberOfProcessors == 1);
   if (SingleProc) {
      HAL += 2;
   }
   
   // Determine if it's a PIC or APIC machine
   BOOL PIC = TRUE;
   if (!SingleProc) {  // Don't run the UsePICHal function unless we have to
      PIC = FALSE;
   } else {
      if (UsePICHal(&PIC) == FALSE) {
	 // An error occurred
	 DisplayGenericErrorAndUndoChanges();
	 return S_FALSE;
      }
   }
   if (PIC) {
      HAL += 1;
   }

   // Lookup table for HALs
   switch (HAL) {
   case 3: // x86 1-proc PIC
      _tcscpy(szHalInstall, TEXT("INTEL_1PROC_PIC_HAL"));
      break;
   case 2: // x86 1-proc APIC
      _tcscpy(szHalInstall, TEXT("INTEL_1PROC_APIC_HAL"));
      break;
   case 1: // x86 multi-proc PIC -- doesn't exist...
      _tcscpy(szHalInstall, TEXT("INTEL_MULTIPROC_PIC_HAL"));
      break;
   case 0: // x86 multi-proc APIC
      _tcscpy(szHalInstall, TEXT("INTEL_MULTIPROC_APIC_HAL"));
      break;
   }
   _tcscat(szHalInstall, TEXT(".Install"));

   // Copy the HAL to the system directory
   if (InstallRegistryAndFilesUsingInf(g_ACPIENAB_INF, szHalInstall) == 0) {
      // Error
      DisplayGenericErrorAndUndoChanges();
      return S_FALSE;
   }



   //
   // Step 7: Reboot.
   //

   // Warn the user that we're going to reboot
   DisplayDialogBox(ACPI_STR_REBOOT_DIALOG_CAPTION,
		    ACPI_STR_REBOOT_WARNING,
		    MB_OK);

   // Get shutdown privilege by opening the process token and adjusting its
   // privileges.
   HANDLE hToken;
   TOKEN_PRIVILEGES tkp;
   if (!OpenProcessToken(GetCurrentProcess(),
			 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
			 &hToken)) {
      // Could not open process token.  Tell the user to reboot manually.
      DisplayDialogBox(ACPI_STR_REBOOT_DIALOG_CAPTION,
		       ACPI_STR_REBOOT_ERROR,
		       MB_OK);
      return S_OK;
   }									
   LookupPrivilegeValue(NULL,
			SE_SHUTDOWN_NAME,
			&tkp.Privileges[0].Luid);
   tkp.PrivilegeCount = 1;
   tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);

   // Reboot
   if (ExitWindowsEx(EWX_REBOOT | EWX_FORCEIFHUNG, 0) == 0) {
      // An error occurred.  Tell the user to reboot manually.
	 DisplayDialogBox(ACPI_STR_REBOOT_DIALOG_CAPTION,
			  ACPI_STR_REBOOT_ERROR,
			  MB_OK);
   }

   return S_OK;

}


//+---------------------------------------------------------------------------
//
//  Function:   InstallRegistryAndFilesUsingInf
//
//  Purpose:    Open an INF file and perform the registry addition/deletion and
//              file copy operations specified there under a given install 
//              section.
//
//  Arguments:  szInfFileName    [in]    Name of INF file to open
//                                       (should be located in system inf 
//					 directory)
//		szInstallSection [in]    Install section (in INF) to use
//
//  Returns:    TRUE if successful
//              FALSE otherwise
//
//  Author:     t-sdey    14 Aug 98
//
//  Notes:      
//
BOOL InstallRegistryAndFilesUsingInf(IN LPCTSTR szInfFileName,
				     IN LPCTSTR szInstallSection)
{
   HINF hinf;

   //
   // Prepare the file queue
   //

   // Create a file queue
   HSPFILEQ FileQueue = SetupOpenFileQueue();
   if(!FileQueue || (FileQueue == INVALID_HANDLE_VALUE)) {
      // Error
      return FALSE;
   }

   // Initialize the queue callback function
   HWND Window = NULL;
   VOID* DefaultContext = SetupInitDefaultQueueCallback(Window);


   //
   // Open the INF file and perform file installation
   //

   // Open the source INF
   hinf = SetupOpenInfFile(szInfFileName, TEXT("System"), INF_STYLE_WIN4, NULL);
   if (hinf == INVALID_HANDLE_VALUE) {
      // Error
      SetupCloseFileQueue(FileQueue);
      return FALSE;
   }
      
   // Append the layout INF to get the source location for the files
   if (SetupOpenAppendInfFile(g_LAYOUT_INF, hinf, NULL) == FALSE) {
      // Could not open file
      SetupCloseInfFile(hinf);
      SetupCloseFileQueue(FileQueue);
      return FALSE;
   }

   // Read the INF and perform the actions it dictates
   if (SetupInstallFromInfSection(NULL,
				  hinf,
				  szInstallSection,
				  SPINST_REGISTRY | SPINST_FILES,
				  HKEY_LOCAL_MACHINE,
				  NULL,  // Source root path
				  SP_COPY_WARNIFSKIP,
				  (PSP_FILE_CALLBACK)SetupDefaultQueueCallback,
				  DefaultContext,
				  NULL,
				  NULL) == 0) {
      // Error
      SetupCloseInfFile(hinf);
      SetupCloseFileQueue(FileQueue);
      return FALSE;
   }

   // Commit the file queue to make sure all queued file copies are performed
   if (SetupCommitFileQueue(NULL,
			    FileQueue,
			    (PSP_FILE_CALLBACK)SetupDefaultQueueCallback,
			    DefaultContext) == 0) {
      // Error
      SetupCloseInfFile(hinf);
      SetupCloseFileQueue(FileQueue);
      return FALSE;
   }

   // Clean up
   SetupCloseInfFile(hinf);
   SetupCloseFileQueue(FileQueue);

   return TRUE;
} 


//+---------------------------------------------------------------------------
//
//  Function:   RegDeleteDeviceKey
//
//  Purpose:    All devices described by guid are removed from the device 
//              tree (HKLM\SYSTEM\CurrentControlSet\Enum\Root).
//              This forces them to be reconfigured on reboot.
//
//  Arguments:  guid  [in]  GUID of device class
//
//  Returns:    TRUE if successful.
//              FALSE otherwise.
//
//  Author:     t-sdey    14 Aug 98
//
//  Notes:      
//
BOOL RegDeleteDeviceKey(IN const GUID* guid)
{
   // Open the Root key under Enum with administrative access
   HKEY hkey = NULL;
   TCHAR szEnumRoot[] = TEXT("SYSTEM\\CurrentControlSet\\Enum\\Root");
   PSECURITY_DESCRIPTOR psdOriginal = NULL;
   if (DwRegOpenKeyExWithAdminAccess(HKEY_LOCAL_MACHINE,
				     szEnumRoot,
				     KEY_ALL_ACCESS,
				     &hkey,
				     &psdOriginal) != ERROR_SUCCESS) {
      // Error
      RegCloseKey(hkey);
      return FALSE;
   }

   // Get the list of devices with this GUID on the system. Remove each 
   // of them from the device tree, so that the next time the computer boots 
   // it is re-detected and re-configured for the new ACPI setup.
   // (Otherwise the device will be configured incorrectly.)
   
   // Get the list of devices with this GUID on the system
   HDEVINFO hdiDeviceClass = SetupDiGetClassDevs(guid, NULL, NULL, 0);
   
   // Prepare data structures for loop
   SP_DEVINFO_DATA DeviceInfoData;
   DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
   DWORD dwIndex = 0;
   unsigned long BufferMax = 5000;  // 5000 chars better be enough for the HID!
   unsigned long BufferLen;
   TCHAR* szHardwareID = new TCHAR[BufferMax];
   if (szHardwareID == NULL) {
      // Out of memory
      DisplayGenericErrorAndUndoChanges();
      SetupDiDestroyDeviceInfoList(hdiDeviceClass);
      if (psdOriginal) delete psdOriginal;
      RegCloseKey(hkey);
      return FALSE;
   }

   // Loop for each device with this GUID
   while (SetupDiEnumDeviceInfo(hdiDeviceClass, dwIndex, &DeviceInfoData)) {
      // Get the Hardware ID
      BufferLen = BufferMax;
      if (CM_Get_DevInst_Registry_Property_Ex(DeviceInfoData.DevInst,
					      CM_DRP_HARDWAREID,
					      NULL,
					      szHardwareID,
					      &BufferLen,
					      0,
					      0) != CR_SUCCESS) {
	 // Error
	 DisplayGenericErrorAndUndoChanges();
	 SetupDiDestroyDeviceInfoList(hdiDeviceClass);
	 if (szHardwareID) delete[] szHardwareID;
	 if (psdOriginal) delete psdOriginal;
	 RegCloseKey(hkey);
	 return FALSE;
      }
   
      // Remove from the device tree
      if (RegDeleteKeyAndSubkeys(hkey, szHardwareID, TRUE) != ERROR_SUCCESS) {
	 // Error
	 DisplayGenericErrorAndUndoChanges();
         SetupDiDestroyDeviceInfoList(hdiDeviceClass);
	 if (szHardwareID) delete[] szHardwareID;
	 if (psdOriginal) delete psdOriginal;
	 RegCloseKey(hkey);
	 return FALSE;
      }

      dwIndex++;
   }
   
   // Reset the security on the Root key
   if (psdOriginal) {
      RegSetKeySecurity(hkey,
			(SECURITY_INFORMATION) (DACL_SECURITY_INFORMATION),
			psdOriginal);
      delete psdOriginal;
   }

   // Clean up
   SetupDiDestroyDeviceInfoList(hdiDeviceClass);
   if (szHardwareID)
      delete[] szHardwareID;
   if (hkey)
      RegCloseKey(hkey);

   return TRUE;
}

   
//+---------------------------------------------------------------------------
//
//  Function:   DisplayGenericErrorAndUndoChanges
//
//  Purpose:    Pop up a message box with a generic error message and then
//              undo as many changes as possible.  Basically, used to recover
//              from errors which occur before ACPI is fully enabled.
//
//  Arguments:  
//
//  Author:     t-sdey	31 July 98
//
//  Notes:      
//
void DisplayGenericErrorAndUndoChanges()
{
   // Give a generic error message
   DisplayDialogBox(ACPI_STR_ERROR_DIALOG_CAPTION,
		    ACPI_STR_GENERAL_ERROR_MESSAGE,
		    MB_OK | MB_ICONERROR);
   
   // Remove new entries from the CriticalDeviceDatabase
   InstallRegistryAndFilesUsingInf(g_ACPIENAB_INF,
				   TEXT("ACPI_UNDO_CHANGES.Install"));
   
}


//+---------------------------------------------------------------------------
//
//  Function:   DisplayDialogBox
//
//  Purpose:    Display a popup informing the user of a warning or error.
//
//  Arguments:  dwCaptionID  [in]    the ID of the caption for the window
//              dwMessageID  [in]    the ID of the message to display
//              uiBoxType    [in]    the type of box to use
//
//  Returns:    integer flag, as would be returned by MessageBox
//
//  Author:     t-sdey    28 July 98
//
//  Notes:
//
int DisplayDialogBox(IN DWORD dwCaptionID,
		     IN DWORD dwMessageID,
		     IN UINT uiBoxType)
{
   // Prepare the strings
   TCHAR szCaption[512];
   TCHAR szMessage[5000];
   if(!LoadString(g_hinst, dwCaptionID, szCaption, 512)) {
      szCaption[0] = 0;
   }
   if(!LoadString(g_hinst, dwMessageID, szMessage, 5000)) {
      szMessage[0] = 0;
   }

   // Create the dialog box
   return (MessageBox(NULL, szMessage, szCaption, uiBoxType));
}


//+---------------------------------------------------------------------------
//
//  Function:   RegDeleteKeyAndSubkeys
//
//  Purpose:    (Recursively) Remove a registry key and all of its subkeys
//
//  Arguments:  hKey        [in]    Handle to an open registry key
//              lpszSubKey  [in]    Name of a subkey to be deleted along with all
//                                    of its subkeys
//              UseAdminAccess [in] Flag to indicate whether or not to try to
//                                    use administrative access
//
//  Returns:    ERROR_SUCCESS if entire subtree was successfully deleted.
//              ERROR_ACCESS_DENIED if given subkey could not be deleted.
//
//  Author:     t-sdey    15 July 98
//
//  Notes:      Modified from regedit.
//              This specifically does not attempt to deal rationally with the
//              case where the caller may not have access to some of the subkeys
//              of the key to be deleted.  In this case, all the subkeys which
//              the caller can delete will be deleted, but the api will still
//              return ERROR_ACCESS_DENIED.
//
LONG RegDeleteKeyAndSubkeys(IN HKEY hKey,
			    IN LPTSTR lpszSubKey,
			    IN BOOL UseAdminAccess)
{
    DWORD i;
    HKEY Key;
    LONG Status;
    DWORD dwStatus;
    DWORD ClassLength=0;
    DWORD SubKeys;
    DWORD MaxSubKey;
    DWORD MaxClass;
    DWORD Values;
    DWORD MaxValueName;
    DWORD MaxValueData;
    DWORD SecurityLength;
    FILETIME LastWriteTime;
    LPTSTR NameBuffer;
    PSECURITY_DESCRIPTOR psdOriginal = NULL;  // used to remember security settings

    //
    // First open the given key so we can enumerate its subkeys
    //
    if (UseAdminAccess) {
       dwStatus = DwRegOpenKeyExWithAdminAccess(hKey,
						lpszSubKey,
						KEY_ALL_ACCESS,
						&Key,
						&psdOriginal);
       if (dwStatus == ERROR_SUCCESS) {
	  Status = ERROR_SUCCESS;
       } else {
	  Status = !(ERROR_SUCCESS);  // It just has to be something else
       }
    } else {
       Status = RegOpenKeyEx(hKey,
			     lpszSubKey,
			     0,
			     KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
			     &Key);
    }

    if (Status != ERROR_SUCCESS) {
        //
        // possibly we have delete access, but not enumerate/query.
        // So go ahead and try the delete call, but don't worry about
        // any subkeys.  If we have any, the delete will fail anyway.
        //
	Status = RegDeleteKey(hKey, lpszSubKey);
	if (psdOriginal) {
	   // Make sure to reset the subkey security -- probably a paranoid check
	   RegSetKeySecurity(Key,
			     (SECURITY_INFORMATION) (DACL_SECURITY_INFORMATION),
			     psdOriginal);
	   free(psdOriginal);
	}
	return(Status);
    }

    //
    // Use RegQueryInfoKey to determine how big to allocate the buffer
    // for the subkey names.
    //
    Status = RegQueryInfoKey(Key,
                             NULL,
                             &ClassLength,
                             0,
                             &SubKeys,
                             &MaxSubKey,
                             &MaxClass,
                             &Values,
                             &MaxValueName,
                             &MaxValueData,
                             &SecurityLength,
                             &LastWriteTime);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA) &&
        (Status != ERROR_INSUFFICIENT_BUFFER)) {
       // Make sure to reset the subkey security
       if (psdOriginal) {
	  RegSetKeySecurity(Key,
			    (SECURITY_INFORMATION) (DACL_SECURITY_INFORMATION),
			    psdOriginal);
	  free(psdOriginal);
       }

       RegCloseKey(Key);
       return(Status);
    }

    NameBuffer = (LPTSTR) LocalAlloc(LPTR, (MaxSubKey + 1)*sizeof(TCHAR));
    if (NameBuffer == NULL) {
       // Make sure to reset the subkey security
       if (psdOriginal) {
	  RegSetKeySecurity(Key,
			    (SECURITY_INFORMATION) (DACL_SECURITY_INFORMATION),
			    psdOriginal);
	  free(psdOriginal);
       }
        
       RegCloseKey(Key);
       return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate subkeys and apply ourselves to each one.
    //
    i=0;
    do {
        Status = RegEnumKey(Key, i, NameBuffer, MaxSubKey+1);
        if (Status == ERROR_SUCCESS) {
	   Status = RegDeleteKeyAndSubkeys(Key, NameBuffer, UseAdminAccess);
        }

        if (Status != ERROR_SUCCESS) {
            //
            // Failed to delete the key at the specified index.  Increment
            // the index and keep going.  We could probably bail out here,
	    // since the api is going to fail, but we might as well keep
            // going and delete everything we can.
            //
	    ++i;
        }

    } while ((Status != ERROR_NO_MORE_ITEMS) && (i < SubKeys));
  
    LocalFree((HLOCAL) NameBuffer);
    RegCloseKey(Key);

    // Delete the key
    Status = RegDeleteKey(hKey, lpszSubKey);

    if (psdOriginal)
       free(psdOriginal);

    return (Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsAdministrator
//
//  Purpose:    Determine whether or not the current user has administrative
//              access to the system.
//
//  Arguments:  
//
//  Returns:    TRUE if the current user has administrative access
//              FALSE otherwise
//
//  Author:     t-sdey    17 Aug 98
//
//  Notes:      Copied from \nt\private\tapi\tomahawk\admin\setup\admin.c
//
BOOL IsAdministrator()
{
    PTOKEN_GROUPS           ptgGroups;
    DWORD                   dwSize, dwBufferSize;
    HANDLE                  hThread;
    HANDLE                  hAccessToken;
    PSID                    psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    UINT                    x;
    BOOL                    bResult = FALSE;
    

    dwSize = 1000;
    ptgGroups = (PTOKEN_GROUPS)GlobalAlloc(GPTR, dwSize);
    hThread = GetCurrentProcess();
    if (!(OpenProcessToken(hThread,
			   TOKEN_READ,
			   &hAccessToken))) {
        CloseHandle(hThread);
        return FALSE;
    }

    dwBufferSize = 0;
    while (TRUE)
    {
        if (GetTokenInformation(hAccessToken,
                                TokenGroups,
                                (LPVOID)ptgGroups,
                                dwSize,
                                &dwBufferSize)) {
            break;
        }

        if (dwBufferSize > dwSize) {
            GlobalFree(ptgGroups);
            ptgGroups = (PTOKEN_GROUPS)GlobalAlloc(GPTR, dwBufferSize);
            dwSize = dwBufferSize;
        } else {
            CloseHandle(hThread);
            CloseHandle(hAccessToken);
            return FALSE;
        }
    }

    if ( !(AllocateAndInitializeSid(&siaNtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &psidAdministrators))) {
        CloseHandle(hThread);
        CloseHandle(hAccessToken);
        GlobalFree( ptgGroups );
        return FALSE;
    }

    for (x = 0; x < ptgGroups->GroupCount; x++) {
        if (EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid)) {
            bResult = TRUE;
            break;
        }
    }

    FreeSid(psidAdministrators);
    CloseHandle(hAccessToken);
    CloseHandle(hThread);
    GlobalFree(ptgGroups);

    return bResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   UsePICHal
//
//  Purpose:    Determine whether this is a PIC machine or not (not=APIC).
//
//  Arguments:  pPIC  [out]  A flag saying whether or not the machine is a PIC
//                           machine.  If it is (and there are no errors) then
//                           pPIC will be set to TRUE.  If it is an APIC machine
//                           pPIC will be FALSE.
//
//  Returns:    TRUE if test was successful
//              FALSE if an error occurred
//
//  Author:     t-sdey    20 Aug 98
//
//  Notes:      
//
BOOL UsePICHal(IN BOOL* PIC)
{
   *PIC = TRUE;

   // Find out which HAL was installed during setup by looking at
   // winnt\repair\setup.log.

   //
   // Determine the location of the setup log
   //

   // Determine the location of the windows directory
   TCHAR* szLogPath = new TCHAR[MAX_PATH+1];
   if (!szLogPath) {
      // Out of memory
      return FALSE;
   }
   if (GetWindowsDirectory(szLogPath, MAX_PATH+1) == 0) {
      // Some error occurred
      if (szLogPath) delete[] szLogPath;
      return FALSE;
   }
	 
   // Complete the log path
   _tcscat(szLogPath, TEXT("\\repair\\setup.log"));

   //
   // Get the string describing the HAL that was used in setup
   //

   TCHAR szSetupHal[100];
   int numchars= GetPrivateProfileString(TEXT("Files.WinNt"),
					 TEXT("\\WINNT\\system32\\hal.dll"),
					 TEXT("DEFAULT"),
					 szSetupHal,
					 100,
					 szLogPath);
   if (numchars == 0) {
      // Could not get string
      if (szLogPath) delete[] szLogPath;
      return FALSE;
   }

   //
   // Determine if the APIC HAL was installed
   //

   // Test to see if the string is "halapic.dll"
   TCHAR szApicHal[] = TEXT("halapic.dll");
   szSetupHal[lstrlen(szApicHal)] = 0;  // make sure it's null-terminated
   if (_tcsstr(szSetupHal, szApicHal) != NULL) {
      // They match...  It's an APIC HAL
      *PIC = FALSE;
   }

   delete[] szLogPath;
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpitab\acpimain.asm ===
PAGE 58,132
;******************************************************************************
TITLE ACPIMAIN.ASM - ACPI Table IOCTL DLVxD Driver
;******************************************************************************
;
;   Title:	ACPIMAIN.ASM - ACPI Table IOCTL DLVxD Driver
;
;   Date:	10/08/97
;
;   Author:	Michael Tsang
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;
;==============================================================================
;
;   DESCRIPTION:
;
;******************************************************************************


	.386p

;******************************************************************************
;			      I N C L U D E S
;******************************************************************************

	.XLIST
	INCLUDE vmm.inc
        INCLUDE acpitab.inc

	.LIST


;******************************************************************************
;		 V I R T U A L	 D E V I C E   D E C L A R A T I O N
;******************************************************************************

Declare_Virtual_Device ACPITAB, ACPITAB_MAJOR_VER, ACPITAB_MINOR_VER, \
		       ACPITabControl, ACPITAB_DEVICE_ID, ACPITAB_INIT_ORDER


VXD_LOCKED_CODE_SEG

;******************************************************************************
;
;   ACPITabControl
;
;   DESCRIPTION:
;	Control procedure for device driver.
;
;   ENTRY:
;	EAX = Control call ID
;
;   EXIT:
;	If carry clear then
;	    Successful
;	else
;	    Control call failed
;
;   USES:
;	EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;==============================================================================

BeginProc ACPITabControl

        Control_Dispatch W32_DEVICEIOCONTROL, ACPITabIOCtrl, sCall, <esi>
IFDEF DEBUG
	Control_Dispatch DEBUG_QUERY, ACPITabDebug, sCall
ENDIF
	clc
	ret

EndProc ACPITabControl

VXD_LOCKED_CODE_ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpitab\acpitab.h ===
/*** acpitab.h - ACPI Table IOCTL DLVxD Public Definitions
 *
 *  Author:     Michael Tsang
 *  Created     10/08/97
 *
 *  MODIFICATION HISTORY
 */

#ifndef _ACPITAB_H
#define _ACPITAB_H

/*** Constants
 */

#define ACPITAB_VXD_NAME        "\\\\.\\ACPITAB.VXD"
#define SIG_RSDP                'PDSR'
#define SIG_LOW_RSDP		' DSR'
#define SIG_BOOT                'TOOB'

//W32 Device IO Control Code
#define ACPITAB_DIOC_GETVERSION 1
#define ACPITAB_DIOC_GETTABINFO 2
#define ACPITAB_DIOC_GETTABLE   3

//Miscellaneous Constants
#define ACPITAB_MAJOR_VER       0x01
#define ACPITAB_MINOR_VER       0x01
#define ACPITAB_DEVICE_ID       UNDEFINED_DEVICE_ID
#define ACPITAB_INIT_ORDER      UNDEFINED_INIT_ORDER

//Type definitions
/*XLATOFF*/
typedef struct _tabinfo
{
    DWORD dwTabSig;
    DWORD dwPhyAddr;
    union
    {
        DESCRIPTION_HEADER dh;
        RSDP rsdp;
        FACS facs;
    };
} TABINFO, *PTABINFO;
/*XLATON*/

#endif  //ifndef _ACPITAB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpitab\acpitabp.h ===
/*** acpitabp.h - ACPI Table IOCTL DLVxD Private Definitions
 *
 *  Author:     Michael Tsang
 *  Created     10/08/97
 *
 *  MODIFICATION HISTORY
 */

#ifndef _ACPITABP_H
#define _ACPITABP_H

/*XLATOFF*/
#include <basedef.h>
#ifndef BOOLEAN
  #define BOOLEAN BOOL
#endif
#include <vmm.h>
#define USECMDWRAPPERS
#include <vxdwraps.h>
#include <configmg.h>
#include <vwin32.h>
#include <winerror.h>
#define SPEC_VER 100
#include "..\driver\inc\acpitabl.h"
#include "acpitab.h"
/*XLATON*/

/*** Build Options
 */

#ifdef DEBUG
  #define TRACING
  #define DEBUGGER
#endif  //DEBUG

/*** Constants
 */

#define WARNNAME                "ACPITAB"

/*XLATOFF*/
#pragma intrinsic(memcpy)

/*** Global Data
 */

#ifdef TRACING
extern int giIndent;
#endif

/*** Macros
 */

#define DEREF(x)        ((x) = (x))
#define EXPORT          __cdecl
#define LOCAL           __cdecl
#define BYTEOF(d,i)     (((BYTE *)&(d))[i])
#define WORDOF(d,i)     (((WORD *)&(d))[i])

#ifdef TRACING
  BOOL LOCAL IsTraceOn(BYTE n, char *pszProcName, BOOL fEnter);
  #define TRACENAME(s)  char *pszTraceName = s;
  #define ENTER(n,p)    {                                               \
                            if (IsTraceOn(n, pszTraceName, TRUE))       \
                                CMDD p;                                 \
                            ++giIndent;                                 \
                        }
  #define EXIT(n,p)     {                                               \
                            --giIndent;                                 \
                            if (IsTraceOn(n, pszTraceName, FALSE))      \
                                CMDD p;                                 \
                        }
#else
  #define TRACENAME(s)
  #define ENTER(n,p)
  #define EXIT(n,p)
#endif  //TRACING

#ifdef DEBUGGER
VOID CM_SYSCTRL ACPITabDebug(VOID);
#endif

#ifdef DEBUG
  #define VXD_PAGEABLE_CODE VxD_LOCKED_CODE_SEG
  #define VXD_PAGEABLE_DATA VxD_LOCKED_DATA_SEG
  #define VXD_LOCKED_CODE   VxD_LOCKED_CODE_SEG
  #define VXD_LOCKED_DATA   VxD_LOCKED_DATA_SEG
  #define VXD_INIT_CODE     VxD_LOCKED_CODE_SEG
  #define VXD_INIT_DATA     VxD_LOCKED_DATA_SEG
  #define VXD_DEBUG_CODE    VxD_LOCKED_CODE_SEG
  #define VXD_DEBUG_DATA    VxD_LOCKED_DATA_SEG
  #define DBG_PRINTF(str)   _Debug_Printf_Service##str
  #define DBG_WARN(str)  {                              \
        _Debug_Printf_Service(WARNNAME ":WARNS:");      \
        _Debug_Printf_Service##str;                     \
        _Debug_Printf_Service("\n");                    \
  }
  #define DBG_ERR(str)  {                               \
        _Debug_Printf_Service(WARNNAME ":ERROR:");      \
        _Debug_Printf_Service##str;                     \
        _Debug_Printf_Service("\n");                    \
        _asm int 3                                      \
  }
  #define ASSERT(x)     if (!(x))                                           \
                            DBG_ERR(("Assertion failed: file %s, line %d",  \
                                     __FILE__, __LINE__))
#else
  #define VXD_PAGEABLE_CODE VxD_PAGEABLE_CODE_SEG
  #define VXD_PAGEABLE_DATA VxD_PAGEABLE_DATA_SEG
  #define VXD_LOCKED_CODE   VxD_LOCKED_CODE_SEG
  #define VXD_LOCKED_DATA   VxD_LOCKED_DATA_SEG
  #define VXD_INIT_CODE     VxD_INIT_CODE_SEG
  #define VXD_INIT_DATA     VxD_INIT_DATA_SEG
  #define VXD_DEBUG_CODE    VxD_DEBUG_ONLY_CODE_SEG
  #define VXD_DEBUG_DATA    VxD_DEBUG_ONLY_DATA_SEG
  #define DBG_PRINTF(str)
  #define DBG_WARN(str)
  #define DBG_ERR(str)
  #define ASSERT(x)
#endif  //DEBUG
/*XLATON*/

#endif  //ifndef _ACPITABP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpitab\acpitab.c ===
/*** acpitab.c - ACPI VXD to provide table access IOCTLs
 *
 *  Author:     Michael Tsang (MikeTs)
 *  Created     10/08/97
 *
 *  MODIFICATION HISTORY
 */

#include "acpitabp.h"

/*** Function prototypes
 */

CM_VXD_RESULT CM_SYSCTRL ACPITabIOCtrl(PDIOCPARAMETERS pdioc);
PRSDT LOCAL FindRSDT(PDWORD pdwRSDPAddr, PDWORD pdwRSDTAddr);
DWORD LOCAL FindTable(DWORD dwSig, PDWORD pdwLen);
BOOL LOCAL ValidateTable(DWORD dwTableAddr, DWORD dwLen);
BOOL LOCAL IsALikelySig(DWORD dwTableSig);
VOID LOCAL CopyROM(DWORD dwPhyAddr, PBYTE pbBuff, DWORD dwLen);
BYTE LOCAL CheckSum(PBYTE pb, DWORD dwLen);
#ifdef TRACING
PSZ LOCAL SigStr(DWORD dwSig);
#endif

#pragma VXD_PAGEABLE_DATA
#pragma VXD_PAGEABLE_CODE

/***EP  ACPITabIOCtrl - Win32 Device IO Control entry point
 *
 *  ENTRY
 *      pioc -> DIOC structure
 *
 *  EXIT-SUCCESS
 *      returns ERROR_SUCCESS
 *  EXIT-FAILURE
 *      returns ERROR_*
 */

CM_VXD_RESULT CM_SYSCTRL ACPITabIOCtrl(PDIOCPARAMETERS pdioc)
{
    TRACENAME("ACPITabIOCTRL")
    CM_VXD_RESULT rc = ERROR_SUCCESS;

    ENTER(1, ("ACPITabIOCtrl(hVM=%lx,hDev=%lx,Code=%lx)\n",
              pdioc->VMHandle, pdioc->hDevice, pdioc->dwIoControlCode));

    switch (pdioc->dwIoControlCode)
    {
        case ACPITAB_DIOC_GETVERSION:
            if ((pdioc->cbOutBuffer < sizeof(DWORD)) ||
                (pdioc->lpvOutBuffer == NULL))
            {
                DBG_ERR(("ACPITabIOCtrl: invalid parameter on GetVersion"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                PVMMDDB pddb = (PVMMDDB)pdioc->Internal2;

                *((PDWORD)pdioc->lpvOutBuffer) =
                    (pddb->DDB_Dev_Major_Version << 8) |
                    pddb->DDB_Dev_Minor_Version;

                if (pdioc->lpcbBytesReturned != NULL)
                    *((PDWORD)pdioc->lpcbBytesReturned) = sizeof(DWORD);
            }
            break;

        case ACPITAB_DIOC_GETTABINFO:
            if ((pdioc->lpvOutBuffer == NULL) ||
                (pdioc->cbOutBuffer != sizeof(TABINFO)))
            {
                DBG_ERR(("ACPITabIOCtrl: invalid parameter on GetTabInfo"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                PTABINFO pTabInfo = (PTABINFO)pdioc->lpvOutBuffer;
                DWORD dwLen;

                if ((pTabInfo->dwPhyAddr = FindTable(pTabInfo->dwTabSig, NULL))
                    != 0)
                {
                    if (pTabInfo->dwTabSig == SIG_RSDP)
                    {
                        dwLen = sizeof(RSDP);
                    }
                    else if (pTabInfo->dwTabSig == FACS_SIGNATURE)
                    {
                        dwLen = sizeof(FACS);
                    }
                    else
                    {
                        dwLen = sizeof(DESCRIPTION_HEADER);
                    }
                    CopyROM(pTabInfo->dwPhyAddr, (PBYTE)&pTabInfo->dh, dwLen);
                }
                else
                {
                    DBG_ERR(("ACPITabIOCtrl: failed to get table info"));
                    rc = ERROR_GEN_FAILURE;
                }
            }
            break;

        case ACPITAB_DIOC_GETTABLE:
            if ((pdioc->lpvInBuffer == NULL) || (pdioc->lpvOutBuffer == NULL) ||
                (pdioc->cbOutBuffer == 0) ||
                !ValidateTable((DWORD)pdioc->lpvInBuffer, pdioc->cbOutBuffer))
            {
                DBG_ERR(("ACPITabIOCtrl: invalid parameter on GetTable"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                CopyROM((DWORD)pdioc->lpvInBuffer, (PBYTE)pdioc->lpvOutBuffer,
                        pdioc->cbOutBuffer);
            }
            break;
    }

    EXIT(1, ("ACPITabIOCtrl=%x\n", rc));
    return rc;
}       //ACPITabIOCtrl

/***LP  FindRSDT - Find the RSDT
 *
 *  ENTRY
 *	pdwRSDPAddr -> to hold the physical address of RSDP
 *	pdwRSDTAddr -> to hold the physical address of RSDT
 *
 *  EXIT-SUCCESS
 *      returns the RSDT pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PRSDT LOCAL FindRSDT(PDWORD pdwRSDPAddr, PDWORD pdwRSDTAddr)
{
    TRACENAME("FINDRSDT")
    PRSDT pRSDT = NULL;
    PBYTE pbROM;

    ENTER(2, ("FindRSDT(pdwRSDPAddr=%p,pdwRSDTAddr=%p)\n",
              pdwRSDPAddr, pdwRSDTAddr));

    if ((pbROM = (PBYTE)_MapPhysToLinear(RSDP_SEARCH_RANGE_BEGIN,
                                         RSDP_SEARCH_RANGE_LENGTH, 0)) !=
        (PBYTE)0xffffffff)
    {
        PBYTE pbROMEnd;

        pbROMEnd = pbROM + RSDP_SEARCH_RANGE_LENGTH - RSDP_SEARCH_INTERVAL;
        while (pbROM != NULL)
        {
            if ((((PRSDP)pbROM)->Signature == RSDP_SIGNATURE) &&
                (CheckSum(pbROM, sizeof(RSDP)) == 0))
            {
		*pdwRSDPAddr = (RSDP_SEARCH_RANGE_BEGIN +
		                RSDP_SEARCH_RANGE_LENGTH) -
			       (pbROMEnd + RSDP_SEARCH_INTERVAL - pbROM);
                *pdwRSDTAddr = ((PRSDP)pbROM)->RsdtAddress;
                if (((pbROM = (PBYTE)_MapPhysToLinear(*pdwRSDTAddr,
                                                      sizeof(DESCRIPTION_HEADER),
                                                      0)) ==
                     (PBYTE)0xffffffff) ||
                    (((PDESCRIPTION_HEADER)pbROM)->Signature != RSDT_SIGNATURE))
                {
                    pbROM = NULL;
                    *pdwRSDTAddr = 0;
                }
                break;
            }
            else
            {
                pbROM += RSDP_SEARCH_INTERVAL;
                if (pbROM > pbROMEnd)
                {
                    pbROM = NULL;
                }
            }
        }

        if (pbROM != NULL)
        {
            DWORD dwLen = ((PDESCRIPTION_HEADER)pbROM)->Length;

            pRSDT = (PRSDT)_MapPhysToLinear(*pdwRSDTAddr, dwLen, 0);
            if ((pRSDT == (PRSDT)0xffffffff) ||
                (CheckSum((PBYTE)pRSDT, dwLen) != 0))
            {
                pRSDT = NULL;
                *pdwRSDTAddr = 0;
            }
        }
    }

    EXIT(2, ("FindRSDT=%x (RSDPAddr=%x,RSDTAddr=%x)\n",
             pRSDT, *pdwRSDPAddr, *pdwRSDTAddr));
    return pRSDT;
}       //FindRSDT

/***LP  FindTable - Find an ACPI Table
 *
 *  ENTRY
 *      dwSig - signature of the table
 *      pdwLen -> to hold length of table (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns physical address of table
 *  EXIT-FAILURE
 *      returns 0
 */

DWORD LOCAL FindTable(DWORD dwSig, PDWORD pdwLen)
{
    TRACENAME("FINDTABLE")
    DWORD dwPhyAddr = 0, dwTableLen = 0;
    static PRSDT pRSDT = (PRSDT)0xffffffff;
    static DWORD dwRSDPAddr = 0, dwRSDTAddr = 0;

    ENTER(2, ("FindTable(Sig=%s,pdwLen=%x)\n", SigStr(dwSig), pdwLen));

    if (pRSDT == (PRSDT)0xffffffff)
    {
        pRSDT = FindRSDT(&dwRSDPAddr, &dwRSDTAddr);
    }

    if (pRSDT != NULL)
    {
        PVOID pv;

        if (dwSig == SIG_RSDP)
        {
            //
            // We are looking for "RSD PTR"
            //
            dwPhyAddr = dwRSDPAddr;
            dwTableLen = sizeof(RSDP);
        }
        else if (dwSig == RSDT_SIGNATURE)
        {
            dwPhyAddr = dwRSDTAddr;
            dwTableLen = pRSDT->Header.Length;
        }
        else if ((dwSig == DSDT_SIGNATURE) || (dwSig == FACS_SIGNATURE))
        {
            PFADT pFADT;

            if (((dwPhyAddr = FindTable(FADT_SIGNATURE, &dwTableLen)) != 0) &&
                ((pFADT = (PFADT)_MapPhysToLinear(dwPhyAddr, dwTableLen, 0)) !=
                 (PFADT)0xffffffff))
            {
                if (dwSig == DSDT_SIGNATURE)
                {
                    dwPhyAddr = pFADT->dsdt;
                    if ((pv = _MapPhysToLinear(dwPhyAddr,
                                               sizeof(DESCRIPTION_HEADER), 0))
                        != (PVOID)0xffffffff)
                    {
                        dwTableLen = ((PDESCRIPTION_HEADER)pv)->Length;
                    }
                    else
                    {
                        dwPhyAddr = 0;
                    }
                }
                else
                {
                    dwPhyAddr = pFADT->facs;
                    if ((pv = _MapPhysToLinear(dwPhyAddr, sizeof(FACS), 0)) !=
                        (PVOID)0xffffffff)
                    {
                        dwTableLen = ((PFACS)pv)->Length;
                    }
                    else
                    {
                        dwPhyAddr = 0;
                    }
                }
            }
            else
            {
                dwPhyAddr = 0;
            }
        }
        else
        {
            int i, iNumTables = NumTableEntriesFromRSDTPointer(pRSDT);

            for (i = 0; i < iNumTables; ++i)
            {
                if (((pv = _MapPhysToLinear(pRSDT->Tables[i],
                                            sizeof(DESCRIPTION_HEADER), 0)) !=
                     (PVOID)0xffffffff) &&
                    (((PDESCRIPTION_HEADER)pv)->Signature == dwSig))
                {
                    dwPhyAddr = pRSDT->Tables[i];
                    dwTableLen = ((PDESCRIPTION_HEADER)pv)->Length;
                    break;
                }
            }
        }

        if ((dwPhyAddr != 0) && (pdwLen != NULL))
        {
            *pdwLen = dwTableLen;
        }
    }

    EXIT(2, ("FindTable=%x (Len=%x)\n", dwPhyAddr, pdwLen? *pdwLen: 0));
    return dwPhyAddr;
}       //FindTable

/***LP  ValidateTable - Validate the table
 *
 *  ENTRY
 *      dwTableAddr - physical address of table
 *      dwLen - table length
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL ValidateTable(DWORD dwTableAddr, DWORD dwLen)
{
    TRACENAME("VALIDATETABLE")
    BOOL rc = TRUE;
    PBYTE pbTable;

    ENTER(2, ("ValidateTable(TableAddr=%x,Len=%d)\n", dwTableAddr, dwLen));

    if ((pbTable = (PBYTE)_MapPhysToLinear(dwTableAddr, dwLen, 0)) !=
        (PBYTE)0xffffffff)
    {
        DWORD dwTableSig, dwTableLen = 0;
        BOOL fNeedChkSum = FALSE;

        dwTableSig = ((PDESCRIPTION_HEADER)pbTable)->Signature;
        switch (dwTableSig)
        {
            case SIG_LOW_RSDP:
                dwTableLen = sizeof(RSDP);
                fNeedChkSum = TRUE;
                break;

            case RSDT_SIGNATURE:
            case FADT_SIGNATURE:
            case DSDT_SIGNATURE:
            case SSDT_SIGNATURE:
            case PSDT_SIGNATURE:
            case APIC_SIGNATURE:
            case SBST_SIGNATURE:
            case SIG_BOOT:
                dwTableLen = ((PDESCRIPTION_HEADER)pbTable)->Length;
                fNeedChkSum = TRUE;
                break;

            case FACS_SIGNATURE:
                dwTableLen = ((PFACS)pbTable)->Length;
                break;

            default:
                if (IsALikelySig(dwTableSig) &&
                    (((PDESCRIPTION_HEADER)pbTable)->Length < 256))
                {
                    dwTableLen = ((PDESCRIPTION_HEADER)pbTable)->Length;
                    fNeedChkSum = TRUE;
                }
                else
                {
                    rc = FALSE;
                }
        }

        if ((rc == TRUE) && fNeedChkSum)
        {
            if (((pbTable = (PBYTE)_MapPhysToLinear(dwTableAddr, dwTableLen, 0))
                 == (PBYTE)0xffffffff) ||
                (CheckSum(pbTable, dwTableLen) != 0))
            {
                rc = FALSE;
            }
        }
    }
    else
    {
        rc = FALSE;
    }

    EXIT(2, ("ValidateTable=%x\n", rc));
    return rc;
}       //ValidateTable

/***LP  IsALikelySig - Check if it looks like a table signature
 *
 *  ENTRY
 *      dwTableSig - table signature
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL IsALikelySig(DWORD dwTableSig)
{
    TRACENAME("ISALIKELYSIG")
    BOOL rc = TRUE;
    int i, ch;

    ENTER(2, ("IsALikelySig(TableSig=%x)\n", dwTableSig));

    for (i = 0; i < sizeof(DWORD); ++i)
    {
        ch = BYTEOF(dwTableSig, i);
        if ((ch < 'A') || (ch > 'Z'))
        {
            rc = FALSE;
            break;
        }
    }

    EXIT(2, ("IsALikelySig=%x\n", rc));
    return rc;
}       //IsALikelySig

/***LP  CopyROM - Copy ROM memory to buffer
 *
 *  ENTRY
 *      dwPhyAddr - physical address of ROM location
 *      pbBuff -> buffer
 *      dwLen - buffer length
 *
 *  EXIT
 *      None
 */

VOID LOCAL CopyROM(DWORD dwPhyAddr, PBYTE pbBuff, DWORD dwLen)
{
    TRACENAME("COPYROM")
    PBYTE pbROM;

    ENTER(2, ("CopyROM(PhyAddr=%x,pbBuff=%x,Len=%x)\n",
              dwPhyAddr, pbBuff, dwLen));

    if ((pbROM = (PBYTE)_MapPhysToLinear(dwPhyAddr, dwLen, 0)) !=
        (PBYTE)0xffffffff)
    {
        memcpy(pbBuff, pbROM, dwLen);
    }

    EXIT(2, ("CopyROM!\n"));
}       //CopyROM

/***LP  CheckSum - Calculate checksum of a buffer
 *
 *  ENTRY
 *      pb -> buffer
 *      dwLen - length of buffer
 *
 *  EXIT
 *      returns checksum
 */

BYTE LOCAL CheckSum(PBYTE pb, DWORD dwLen)
{
    TRACENAME("CHECKSUM")
    BYTE bChkSum = 0;

    ENTER(2, ("CheckSum(pb=%x,Len=%x)\n", pb, dwLen));

    while (dwLen > 0)
    {
        bChkSum = (BYTE)(bChkSum + *pb);
        pb++;
        dwLen--;
    }

    EXIT(2, ("CheckSum=%x\n", bChkSum));
    return bChkSum;
}       //CheckSum

#ifdef TRACING
/***LP  SigStr - return string of DWORD signature
 *
 *  ENTRY
 *      dwSig - signature
 *
 *  EXIT
 *      returns signature string
 */

PSZ LOCAL SigStr(DWORD dwSig)
{
    static char szSig[sizeof(DWORD) + 1] = {0};

    memcpy(szSig, &dwSig, sizeof(DWORD));

    return (PSZ)szSig;
}       //SigStr
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpitab\debug.c ===
/*** debug.c - Debug functions
 *
 *  This module contains all the debug functions.
 *
 *  Author:     Michael Tsang (MikeTs)
 *  Created     10/08/97
 *
 *  MODIFICATION HISTORY
 */

#include "acpitabp.h"

//Miscellaneous Constants
#ifdef TRACING
#define MAX_TRIG_PTS            10
#define MAX_TRIGPT_LEN          31
#define TF_TRIG_MODE            0x00000001
#endif

//Local function prototypes
#ifdef TRACING
VOID LOCAL TraceIndent(VOID);
BOOL LOCAL IsTrigPt(char *pszProcName);
PCHAR LOCAL InStr(PCHAR pszStr, PCHAR pszSubStr);
VOID EXPORT DebugSetTraceLevel(VOID);
VOID EXPORT DebugToggleTrigMode(VOID);
VOID EXPORT DebugClearTrigPts(VOID);
VOID EXPORT DebugAddTrigPt(VOID);
VOID EXPORT DebugZapTrigPt(VOID);
PCHAR LOCAL GetString(PCHAR pszPrompt, PCHAR pszBuff, BYTE bcLen, BOOL fUpper);
#endif

//Local Data
#ifdef TRACING
#pragma VXD_LOCKED_DATA
int giTraceLevel = 0, giIndent = 0;
char aszTrigPtBuff[MAX_TRIG_PTS][MAX_TRIGPT_LEN + 1] = {0};
DWORD dwfTrace = 0, dwcTriggers = 0;
#endif

#ifdef DEBUGGER
#pragma VXD_DEBUG_DATA
CMDDC DebugCmds[] =
{
  #ifdef TRACING
    {'t', DebugSetTraceLevel,  "set Trace level     ", "Set Trace Level"},
    {'g', DebugToggleTrigMode, "toGgle trigger mode ", "Toggle Trace Trigger mode"},
    {'x', DebugClearTrigPts,   "clear trigger points", "Clear all trace trigger points"},
    {'y', DebugAddTrigPt,      "add trigger point   ", "Add a trace trigger point"},
    {'z', DebugZapTrigPt,      "Zap trigger point   ", "Delete a trace trigger point"},
  #endif
    {'q', NULL,                "Quit                ", "Quit the debugger"},
    {'\0'}
};
#endif  //ifdef DEBUGGER

#ifdef TRACING
#pragma VXD_LOCKED_DATA
#pragma VXD_LOCKED_CODE
/***LP  TraceIndent - Indent trace output
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL TraceIndent(VOID)
{
    int i;

    CMDD(WARNNAME ":");
    for (i = 0; i < giIndent; i++)
    {
        CMDD("..");
    }
}       //TraceIndent

/***LP  IsTraceOn - Determine if tracing is on for the given procedure
 *
 *  ENTRY
 *      n - trace level
 *      pszProcName -> procedure name
 *      fEnter - TRUE if EnterProc trace
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL LOCAL IsTraceOn(BYTE n, char *pszProcName, BOOL fEnter)
{
    BOOL rc = FALSE;

    if ((dwfTrace & TF_TRIG_MODE) && IsTrigPt(pszProcName))
    {
        if (fEnter)
            dwcTriggers++;
        else
            dwcTriggers--;
        rc = TRUE;
    }
    else if ((n <= giTraceLevel) &&
             (!(dwfTrace & TF_TRIG_MODE) || (dwcTriggers > 0)))
    {
        rc = TRUE;
    }

    if (rc == TRUE)
        TraceIndent();

    return rc;
}       //IsTraceOn

/***LP  IsTrigPt - Find the procedure name in the TrigPt buffer
 *
 *  ENTRY
 *      pszProcName -> procedure name
 *
 *  EXIT-SUCCESS
 *      returns TRUE - matched whole or partial name in the TrigPt buffer
 *  EXIT-FAILURE
 *      returns FALSE - no match
 */

BOOL LOCAL IsTrigPt(char *pszProcName)
{
    BOOL rc = FALSE;
    BYTE i;

    for (i = 0; (rc == FALSE) && (i < MAX_TRIG_PTS); ++i)
    {
        if (InStr(pszProcName, &aszTrigPtBuff[i][0]) != NULL)
            rc = TRUE;
    }

    return rc;
}       //IsTrigPt

/***LP  InStr - Match a sub-string in a given string
 *
 *  ENTRY
 *      pszStr -> string
 *      pszSubStr -> sub-string
 *
 *  EXIT-SUCCESS
 *      returns pointer to the string where the substring is found
 *  EXIT-FAILURE
 *      returns NULL
 */

PCHAR LOCAL InStr(PCHAR pszStr, PCHAR pszSubStr)
{
    PCHAR psz = NULL;
    BYTE bcStrLen = (BYTE)_lstrlen(pszStr);
    BYTE bcSubStrLen = (BYTE)_lstrlen(pszSubStr);

    _asm
    {
        cld
        mov edi,pszStr

    Next:
        mov esi,pszSubStr
        movzx ecx,BYTE PTR bcStrLen
        lodsb
        repne scasb
        jnz NotFound

        movzx ecx,BYTE PTR bcSubStrLen
        repe cmpsb
        jne Next

        movzx ecx,BYTE PTR bcSubStrLen
        sub edi,ecx
        mov psz,edi

    NotFound:
    }

    return psz;
}       //InStr
#endif  //ifdef TRACING

#ifdef DEBUGGER
#pragma VXD_DEBUG_DATA
#pragma VXD_DEBUG_CODE
/***EP  ACPITabDebug - Debugger entry point
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_SYSCTRL ACPITabDebug(VOID)
{
    CMDMenu(WARNNAME, DebugCmds);
}       //ACPITabDebug

#ifdef TRACING
/***LP  DebugSetTraceLevel - Set Trace Level
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID EXPORT DebugSetTraceLevel(VOID)
{
    CMDD("\n");
    giTraceLevel = (int)CMDReadNumber("Trace Level", 1, FALSE);
    CMDD("\n\n");
}       //DebugSetTraceLevel

/***LP  DebugToggleTrigMode - Toggle Trace Trigger mode
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID EXPORT DebugToggleTrigMode(VOID)
{
    dwfTrace ^= TF_TRIG_MODE;
    if (!(dwfTrace & TF_TRIG_MODE))
        dwcTriggers = 0;
    CMDD("\nTrace Trigger Mode is %s\n\n",
         (dwfTrace & TF_TRIG_MODE)? "On": "Off");
}       //DebugToggleTrigMode

/***LP  DebugClearTrigPts - Clear all trace trigger points
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID EXPORT DebugClearTrigPts(VOID)
{
    BYTE i;

    for (i = 0; i < MAX_TRIG_PTS; ++i)
        aszTrigPtBuff[i][0] = '\0';

    CMDD("\n");
}       //DebugClearTrigPts

/***LP  DebugAddTrigPt - Add a trace trigger point
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID EXPORT DebugAddTrigPt(VOID)
{
    char szTrigPt[MAX_TRIGPT_LEN + 1];
    BYTE i;

    CMDD("\n");
    GetString("Trigger Point", szTrigPt, sizeof(szTrigPt), TRUE);
    CMDD("\n");
    for (i = 0; i < MAX_TRIG_PTS; ++i)
    {
        if (aszTrigPtBuff[i][0] == '\0')
        {
            _lstrcpyn(aszTrigPtBuff[i], szTrigPt, MAX_TRIGPT_LEN + 1);
            break;
        }
    }

    if (i == MAX_TRIG_PTS)
        CMDD("No free trigger point.\n");

    CMDD("\n");
}       //DebugAddTrigPt

/***LP  DebugZapTrigPt - Delete a trace trigger point
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID EXPORT DebugZapTrigPt(VOID)
{
    BYTE i, bcTrigPts;

    CMDD("\n");
    for (i = 0, bcTrigPts = 0; i < MAX_TRIG_PTS; ++i)
    {
        if (aszTrigPtBuff[i][0] != '\0')
        {
            CMDD("%2d: %s\n", i, &aszTrigPtBuff[i][0]);
            bcTrigPts++;
        }
    }

    if (bcTrigPts > 0)
    {
        CMDD("\n");
        i = (BYTE)CMDReadNumber("Trigger Point", 1, FALSE);
        CMDD("\n");

        if ((i < MAX_TRIG_PTS) && (aszTrigPtBuff[i][0] != '\0'))
            aszTrigPtBuff[i][0] = '\0';
        else
            CMDD("Invalid Trace Trigger Point.\n");
    }
    else
        CMDD("No Trace Trigger Point set.\n");

    CMDD("\n");
}       //DebugZapTrigPt

/***LP  GetString - Read a string from the debug terminal
 *
 *  ENTRY
 *      pszPrompt -> prompt string
 *      pszBuff -> buffer to hold the string
 *      bcLen - buffer length
 *      fUpper - TRUE if convert to upper case
 *
 *  EXIT
 *      always returns pszBuff
 */

PCHAR LOCAL GetString(PCHAR pszPrompt, PCHAR pszBuff, BYTE bcLen, BOOL fUpper)
{
    BYTE i, ch;

    CMDD("%s: ", pszPrompt);
    for (i = 0; i < bcLen - 1; ++i)
    {
        ch = CMDInChar();

        if ((ch == '\r') || (ch == '\n'))
            break;
        else if (ch == '\b')
        {
            if (i > 0)
                i -= 2;
        }
        else if (fUpper && (ch >= 'a') && (ch <= 'z'))
            pszBuff[i] = (BYTE)(ch - 'a' + 'A');
        else if ((ch < ' ') || (ch > '~'))
        {
            ch = '\a';          //change it to a BELL character
            i--;                //don't store it
        }
        else
            pszBuff[i] = ch;

        CMDD("%c", ch);
    }
    pszBuff[i] = '\0';

    return pszBuff;
}       //GetString
#endif  //ifdef TRACING
#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpiver_stub\acpiver_stub.c ===
/*++
Copyright (c) 1991-1998  Microsoft Corporation

Module Name:


Abstract


  Acpiver.sys stub filter driver.
  This driver is just their , so it will get loaded once we replace it 
  with the real acpiver driver.


  This driver just has a DriverEntry and an AddDevice function that does nothing but 
  return success.
  

Environment:

    kernel mode only

Notes:

--*/


#include "wdm.h"


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


NTSTATUS
AcpiVerDumyAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );


//
// Define the sections that allow for discarding (i.e. paging) some of
// the code.
//


#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, AcpiVerDumyAddDevice)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:


Arguments:

    DriverObject - The  driver object.

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful

--*/

   {
   DriverObject->DriverExtension->AddDevice            = AcpiVerDumyAddDevice;
   return(STATUS_SUCCESS);
   } 


NTSTATUS
AcpiVerDumyAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:

    Creates and initializes a new filter device object FiDO for the
    corresponding PDO.  Then it attaches the device object to the device
    stack of the drivers for the device.

Arguments:

    DriverObject - Disk performance driver object.
    PhysicalDeviceObject - Physical Device Object from the underlying layered driver

Return Value:

    NTSTATUS
--*/

   {
   return STATUS_SUCCESS;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\acpins.c ===
/*** acpins.c - ACPI Name Space functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     10/18/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***LP  InitNameSpace - Initialize NameSpace
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL InitNameSpace(VOID)
{
    int rc = ASLERR_NONE;

    ENTER((1, "InitNameSpace()\n"));

    if ((rc = CreateNameSpaceObj(NULL, "\\", NULL, NULL, NULL, NSF_EXIST_ERR))
        == ASLERR_NONE)
    {
        static struct _defobj {
            PSZ   pszName;
            USHORT dwObjType;
        } DefinedRootObjs[] = {
            "_GPE", OBJTYPE_UNKNOWN,
            "_PR",  OBJTYPE_UNKNOWN,
            "_SB",  OBJTYPE_UNKNOWN,
            "_SI",  OBJTYPE_UNKNOWN,
            "_TZ",  OBJTYPE_UNKNOWN,
            "_REV", OBJTYPE_INTDATA,
            "_OS",  OBJTYPE_STRDATA,
            "_GL",  OBJTYPE_MUTEX,
            NULL,   0
        };
        int i;
        PNSOBJ pns;

        gpnsCurrentScope = gpnsNameSpaceRoot;

        for (i = 0; DefinedRootObjs[i].pszName != NULL; ++i)
        {
            if ((rc = CreateNameSpaceObj(NULL, DefinedRootObjs[i].pszName, NULL,
                                         NULL, &pns, NSF_EXIST_ERR)) ==
                ASLERR_NONE)
            {
                pns->ObjData.dwDataType = DefinedRootObjs[i].dwObjType;
            }
            else
            {
                break;
            }
        }
    }

    EXIT((1, "InitNameSpace=%d\n", rc));
    return rc;
}       //InitNameSpace

/***LP  GetNameSpaceObj - Find a name space object
 *
 *  ENTRY
 *      pszObjPath -> name path string
 *      pnsScope -> scope to start the search (NULL means root)
 *      ppns -> to hold the nsobj pointer found
 *      dwfNS - flags
 *
 *  EXIT-SUCCESS
 *      returns ASLERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int LOCAL GetNameSpaceObj(PSZ pszObjPath, PNSOBJ pnsScope, PPNSOBJ 